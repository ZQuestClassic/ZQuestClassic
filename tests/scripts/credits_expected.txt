Compiling 'credits.zs'
Pass 1: Parsing
Pass 2: Preprocessing
Pass 3: Registration
Pass 4: Analyzing Code
Pass 5: Checking code paths
Pass 6: Generating object code
Pass 7: Assembling
Success!
Compile finished with exit code '0' (success)
=== METADATA (elided)
{
  "currentFileSymbols": 56,
  "symbols": 83,
  "identifiers": 250
}
PUSHR REFFFC; void run() Body Start
SETR d4,SP2
CALLFUNC 0.0546; UsrFunc[void runTestCredits()] Call AND [Opt:NeverRet] AND [Opt:NeverRet] AND void run() Body End
SETR d4,SP2; Func[void addHeader(char32)] Body Start
PUSHR d4
LOAD d2,0; UsrFunc[void addLine(char32, int, int, int, int)] Params Start
PUSHR d2
SETR d2,gd3
PUSHR d2
POP d0
READPODARRAYV d2,4
PUSHR d2
PUSHV 1
SETR d2,gd3
PUSHR d2
POP d0
READPODARRAYV d2,5
PUSHR d2
SETR d2,gd3
PUSHR d2
POP d0
READPODARRAYV d2,2
PUSHR d2; UsrFunc[void addLine(char32, int, int, int, int)] Params End
CALLFUNC 0.0028; UsrFunc[void addLine(char32, int, int, int, int)] Call
POP d4
POP d5
RETURNFUNC; Func[void addHeader(char32)] Body End
PUSHARGSV 0,0.0003; Func[void addLine(char32, int, int, int, int)] Body Start
SETR d4,SP2
STOREV 0,0.0002
LOAD d2,0.0005; switch() #84 Key
SETR SWITCHKEY,d2; Store key
COMPAREV SWITCHKEY,0
GOTOCMP 40,==; case '0'
COMPAREV SWITCHKEY,2
GOTOCMP 46,==; case '20000'
COMPAREV SWITCHKEY,1
GOTOCMP 53,==; case '10000'
GOTO 53; switch() #84 NoMatch
SETR d2,gd3; Case block
PUSHR d2
POP d0
READPODARRAYV d2,3
STORE d2,0.0002
GOTO 55; break 1;
SETR d2,gd3; Case block
PUSHR d2
POP d0
READPODARRAYV d2,3
SUBV2 256,d2
STORE d2,0.0002
GOTO 55; break 1;
SETV d2,128; Case block
STORE d2,0.0002
LOAD d2,0.0006; InlineFunc[int Text->FontHeight(int)] Params
FONTHEIGHTR d2; InlineFunc[int Text->FontHeight(int)] Body
STORE d2,0.0001
SETR d2,gd2
STORE_OBJECT d2,0
SETR d2,gd3; if() #558 Test
PUSHR d2
POP d0
READPODARRAYV d2,0
PUSHR d2
LOAD d2,0.0003
POP d3
ADDR d2,d3
PUSHR d2
LOAD d2,0.0001
POP d3
ADDR d2,d3
PUSHR d2
LOAD d2,0
PUSHR d2
POP REFBITMAP
SETR d2,BITMAPHEIGHT
POP d3
COMPARER d3,d2
SETCMP d2,I>
COMPAREV d2,0
GOTOCMP 93,==; Test 'if'
PUSHR d4; if() #558 Body Start
LOAD d2,0; UsrFunc[void resize(int)] Params Start
PUSHR d2
POP REFBITMAP
SETR d2,BITMAPHEIGHT
ADDV d2,256
PUSHR d2; UsrFunc[void resize(int)] Params End
CALLFUNC 0.0160; UsrFunc[void resize(int)] Call
POP d4
SETR d2,gd2
STORE_OBJECT d2,0; if() #558 Body End
LOAD d2,0; InlineFunc[void Bitmap->DrawString(int, int, int, int, int, int, int, char32, int)] Params Start
PUSHR d2
PUSHV 0
LOAD d2,0.0002
PUSHR d2
SETR d2,gd3
PUSHR d2
POP d0
READPODARRAYV d2,0
PUSHR d2
LOAD d2,0.0003
POP d3
ADDR d2,d3
PUSHR d2
LOAD d2,0.0006
PUSHR d2
LOAD d2,0.0004
PUSHR d2
PUSHV -1
LOAD d2,0.0005
PUSHR d2
LOAD d2,0.0007
PUSHR d2
PUSHV 128; InlineFunc[void Bitmap->DrawString(int, int, int, int, int, int, int, char32, int)] Params End
BMPDRAWSTRINGR; InlineFunc[void Bitmap->DrawString(int, int, int, int, int, int, int, char32, int)] Body Start
POPARGS d5,0.0009
POP d3; InlineFunc[void Bitmap->DrawString(int, int, int, int, int, int, int, char32, int)] Body End
SETR d2,gd3
PUSHR d2
POP d0
READPODARRAYV d2,0
PUSHR d2
LOAD d2,0.0003
PUSHR d2
LOAD d2,0.0001
POP d3
ADDR d2,d3
POP d3
ADDR d2,d3
PUSHR d2
SETR d2,gd3
SETR d0,d2
POP d2
WRITEPODARRAYVR 0,d2
POPARGS d5,0.0008
RETURNFUNC; Func[void addLine(char32, int, int, int, int)] Body End
SETR d4,SP2; Func[void addLine(char32, int)] Body Start
PUSHR d4
LOAD d2,0.0001; UsrFunc[void addLine(char32, int, int, int, int)] Params Start
PUSHR d2
LOAD d2,0
PUSHR d2
PUSHV 1
SETR d2,gd3
PUSHR d2
POP d0
READPODARRAYV d2,5
PUSHR d2
SETR d2,gd3
PUSHR d2
POP d0
READPODARRAYV d2,1
PUSHR d2; UsrFunc[void addLine(char32, int, int, int, int)] Params End
CALLFUNC 0.0028; UsrFunc[void addLine(char32, int, int, int, int)] Call
POP d4
POPARGS d5,0.0002
RETURNFUNC; Func[void addLine(char32, int)] Body End
PUSHARGSV 0,0.0002; Func[void resize(int)] Body Start
SETR d4,SP2
SETR d2,gd2; if() #564 Test
PUSHR d2
POP REFBITMAP
SETR d2,BITMAPHEIGHT
PUSHR d2
LOAD d2,0.0002
POP d3
COMPARER d3,d2
SETCMP d2,I==
COMPAREV d2,0
GOTOCMP 216,!=; Test 'if' AND return (Void) AND if() #564 Body
PUSHR d4
PUSHV 256; UsrFunc[Bitmap create(int, int)] Params Start
LOAD d2,0.0002
PUSHR d2; UsrFunc[Bitmap create(int, int)] Params End
CALLFUNC 0.0244; UsrFunc[Bitmap create(int, int)] Call
POP d4
STORE_OBJECT d2,0.0001
LOAD d2,0.0001; InlineFunc[void Bitmap->Clear(int)] Params Start
PUSHR d2
PUSHV 0; InlineFunc[void Bitmap->Clear(int)] Params End
CLEARBITMAP; InlineFunc[void Bitmap->Clear(int)] Body Start
POP d5
POP d3; InlineFunc[void Bitmap->Clear(int)] Body End
SETR d2,gd2; InlineFunc[int Min(int, int)] Params Start
PUSHR d2
POP REFBITMAP
PUSHVARGR BITMAPHEIGHT
LOAD d2,0.0002
PUSHVARGR d2; InlineFunc[int Min(int, int)] Params End
MINVARG; InlineFunc[int Min(int, int)] Body
STORE d2,0
SETR d2,gd2; InlineFunc[void Bitmap->Blit(int, untyped, int, int, int, int, int, int, int, int, int, int, int, int, int, bool)] Params Start
PUSHR d2
PUSHV 0
LOAD d2,0.0001
PUSHR d2
PUSHARGSV 0,0.0002
PUSHV 256
LOAD d2,0
PUSHR d2
PUSHARGSV 0,0.0002
PUSHV 256
LOAD d2,0
PUSHR d2
PUSHARGSV 0,0.0006; InlineFunc[void Bitmap->Blit(int, untyped, int, int, int, int, int, int, int, int, int, int, int, int, int, bool)] Params End
BMPBLIT; InlineFunc[void Bitmap->Blit(int, untyped, int, int, int, int, int, int, int, int, int, int, int, int, int, bool)] Body Start
POPARGS d5,0.0016
POP REFBITMAP; InlineFunc[void Bitmap->Blit(int, untyped, int, int, int, int, int, int, int, int, int, int, int, int, int, bool)] Body End
SETR d2,gd2; InlineFunc[void Bitmap->Free()] Params Start
SETR REFBITMAP,d2; InlineFunc[void Bitmap->Free()] Params End
BITMAPFREE; InlineFunc[void Bitmap->Free()] Body
LOAD d2,0.0001
SET_OBJECT gd2,d2
POPARGS d5,0.0003
RETURNFUNC; Func[void resize(int)] Body End
SETR d4,SP2; Func[void blackDelay(int)] Body Start
LOAD d2,0; while() #8 Test
PUSHR d2
SUBV d2,1
STORE d2,0
POP d2
COMPAREV d2,0
SETCMP d2,I>
COMPAREV d2,0
GOTOCMP 242,==; Test 'while'
PUSHV 7; InlineFunc[void Screen->Rectangle(int, int, int, int, int, int, int, int, int, int, bool, int)] Params Start AND while() #8 Body Start
PUSHV 0
PUSHV -56
PUSHV 255
PUSHV 175
PUSHV 15
PUSHV 1
PUSHARGSV 0,0.0003
PUSHV 1
PUSHV 128; InlineFunc[void Screen->Rectangle(int, int, int, int, int, int, int, int, int, int, bool, int)] Params End
RECT; InlineFunc[void Screen->Rectangle(int, int, int, int, int, int, int, int, int, int, bool, int)] Body Start
POPARGS d5,0.0012; InlineFunc[void Screen->Rectangle(int, int, int, int, int, int, int, int, int, int, bool, int)] Body End
WAITFRAME; InlineFunc[void Waitframe()] Body AND while() #8 Body End
GOTO 219; while() #8 End
POP d5
RETURNFUNC; Func[void blackDelay(int)] Body End
SETR d4,SP2; Func[Bitmap create(int, int)] Body Start
SETV d2,652; if() #186 Test
PUSHR d2
POP d0
SETR d2,FFRULE
COMPAREV d2,0
GOTOCMP 259,==; Test 'if'
LOAD d2,0; InlineFunc[Bitmap Game->CreateBitmap(int, int)] Params Start AND return Start AND if() #186 Body Start
PUSHR d2
LOAD d2,0.0001
SETR d1,d2; InlineFunc[Bitmap Game->CreateBitmap(int, int)] Params End
POP d0; InlineFunc[Bitmap Game->CreateBitmap(int, int)] Body Start
SETR d2,CREATEBITMAP; InlineFunc[Bitmap Game->CreateBitmap(int, int)] Body End
GOTO 267; return End
GOTO 266; if() #186 Body End
LOAD d2,0.0001; InlineFunc[Bitmap Game->CreateBitmap(int, int)] Params Start AND return Start AND if() #186 Else Start
PUSHR d2
LOAD d2,0
SETR d1,d2; InlineFunc[Bitmap Game->CreateBitmap(int, int)] Params End
POP d0; InlineFunc[Bitmap Game->CreateBitmap(int, int)] Body Start
SETR d2,CREATEBITMAP; InlineFunc[Bitmap Game->CreateBitmap(int, int)] Body End
GOTO 267; return End AND if() #186 Else End
REF_AUTORELEASE d2
POPARGS d5,0.0002
RETURNFUNC; Func[Bitmap create(int, int)] Body End
SETR d4,SP2; Func[void destroy()] Body Start
SETR d2,gd2; InlineFunc[bool Bitmap->isValid()] Params AND if() #560 Test
ISVALIDBITMAP d2; InlineFunc[bool Bitmap->isValid()] Body
COMPAREV d2,0
GOTOCMP 277,==; Test 'if'
SETR d2,gd2; InlineFunc[void Bitmap->Free()] Params Start AND if() #560 Body Start
SETR REFBITMAP,d2; InlineFunc[void Bitmap->Free()] Params End
BITMAPFREE; InlineFunc[void Bitmap->Free()] Body AND if() #560 Body End
SETV d2,0
SET_OBJECT gd2,d2
SETV d2,0
PUSHR d2
SETR d2,gd3
SETR d0,d2
POP d2
WRITEPODARRAYVR 0,d2
SETV d2,2
PUSHR d2
SETR d2,gd3
SETR d0,d2
POP d2
WRITEPODARRAYVR 1,d2
SETV d2,8
PUSHR d2
SETR d2,gd3
SETR d0,d2
POP d2
WRITEPODARRAYVR 2,d2
SETV d2,16
PUSHR d2
SETR d2,gd3
SETR d0,d2
POP d2
WRITEPODARRAYVR 3,d2
SETV d2,30
PUSHR d2
SETR d2,gd3
SETR d0,d2
POP d2
WRITEPODARRAYVR 4,d2
SETV d2,1
PUSHR d2
SETR d2,gd3
SETR d0,d2
POP d2
WRITEPODARRAYVR 5,d2
RETURNFUNC; Func[void destroy()] Body End
PUSHARGSV 0,0.0002; Func[void drawCredits(int)] Body Start
SETR d4,SP2
PUSHV 7; InlineFunc[void Screen->Rectangle(int, int, int, int, int, int, int, int, int, int, bool, int)] Params Start
PUSHV 0
PUSHV -56
PUSHV 255
PUSHV 175
PUSHV 15
PUSHV 1
PUSHARGSV 0,0.0003
PUSHV 1
PUSHV 128; InlineFunc[void Screen->Rectangle(int, int, int, int, int, int, int, int, int, int, bool, int)] Params End
RECT; InlineFunc[void Screen->Rectangle(int, int, int, int, int, int, int, int, int, int, bool, int)] Body Start
POPARGS d5,0.0012; InlineFunc[void Screen->Rectangle(int, int, int, int, int, int, int, int, int, int, bool, int)] Body End
LOAD d2,0.0002
COMPAREV d2,0
SETCMP d2,I<
COMPAREV d2,0
GOTOCMP 337,==
LOAD d2,0.0002
GOTO 338
SETV d2,0
ADDV d2,224
STORE d2,0.0001
LOAD d2,0.0001; if() #561 Test
COMPAREV d2,0
SETCMP d2,I<=
COMPAREV d2,0
GOTOCMP 384,!=; Test 'if' AND return (Void) AND if() #561 Body
LOAD d2,0.0002
COMPAREV d2,0
SETCMP d2,I<
COMPAREV d2,0
GOTOCMP 353,==
LOAD d2,0.0002
SUBV2 0,d2
GOTO 354
SETV d2,0
SUBV d2,56
STORE d2,0
LOAD d2,0.0002; if() #562 Test
COMPAREV d2,0
SETCMP d2,I<
COMPAREV d2,0
GOTOCMP 363,==; Test 'if'
SETV d2,0; if() #562 Body Start
STORE d2,0.0002; if() #562 Body End
SETR d2,gd2; InlineFunc[void Bitmap->Blit(int, untyped, int, int, int, int, int, int, int, int, int, int, int, int, int, bool)] Params Start
PUSHR d2
PUSHV 7
PUSHV -1
PUSHV 0
LOAD d2,0.0002
PUSHR d2
PUSHV 256
LOAD d2,0.0001
PUSHR d2
PUSHV 0
LOAD d2,0
PUSHR d2
PUSHV 256
LOAD d2,0.0001
PUSHR d2
PUSHARGSV 0,0.0005
PUSHV 1; InlineFunc[void Bitmap->Blit(int, untyped, int, int, int, int, int, int, int, int, int, int, int, int, int, bool)] Params End
BMPBLIT; InlineFunc[void Bitmap->Blit(int, untyped, int, int, int, int, int, int, int, int, int, int, int, int, int, bool)] Body Start
POPARGS d5,0.0016
POP REFBITMAP; InlineFunc[void Bitmap->Blit(int, untyped, int, int, int, int, int, int, int, int, int, int, int, int, int, bool)] Body End
POPARGS d5,0.0003
RETURNFUNC; Func[void drawCredits(int)] Body End
SETR d4,SP2; Func[void init()] Body Start
SETR d2,gd2; InlineFunc[bool Bitmap->isValid()] Params AND if() #563 Test
ISVALIDBITMAP d2; InlineFunc[bool Bitmap->isValid()] Body
COMPAREV d2,0
GOTOCMP 394,==; Test 'if'
SETR d2,gd2; InlineFunc[void Bitmap->Free()] Params Start AND if() #563 Body Start
SETR REFBITMAP,d2; InlineFunc[void Bitmap->Free()] Params End
BITMAPFREE; InlineFunc[void Bitmap->Free()] Body AND if() #563 Body End
PUSHR d4
PUSHV 256; UsrFunc[Bitmap create(int, int)] Params Start
PUSHV 1024; UsrFunc[Bitmap create(int, int)] Params End
CALLFUNC 0.0244; UsrFunc[Bitmap create(int, int)] Call
POP d4
SET_OBJECT gd2,d2
SETR d2,gd2; InlineFunc[void Bitmap->Clear(int)] Params Start
PUSHR d2
PUSHV 0; InlineFunc[void Bitmap->Clear(int)] Params End
CLEARBITMAP; InlineFunc[void Bitmap->Clear(int)] Body Start
POP d5
POP d3; InlineFunc[void Bitmap->Clear(int)] Body End
SETV d2,0
PUSHR d2
SETR d2,gd3
SETR d0,d2
POP d2
WRITEPODARRAYVR 0,d2
SETV d2,2
PUSHR d2
SETR d2,gd3
SETR d0,d2
POP d2
WRITEPODARRAYVR 1,d2
SETV d2,8
PUSHR d2
SETR d2,gd3
SETR d0,d2
POP d2
WRITEPODARRAYVR 2,d2
SETV d2,16
PUSHR d2
SETR d2,gd3
SETR d0,d2
POP d2
WRITEPODARRAYVR 3,d2
SETV d2,30
PUSHR d2
SETR d2,gd3
SETR d0,d2
POP d2
WRITEPODARRAYVR 4,d2
SETV d2,1
PUSHR d2
SETR d2,gd3
SETR d0,d2
POP d2
WRITEPODARRAYVR 5,d2
RETURNFUNC; Func[void init()] Body End
PUSHV 0; Func[void output(char32)] Body Start
SETR d4,SP2
PUSHR d4
PUSHV 256; UsrFunc[Bitmap create(int, int)] Params Start
SETR d2,gd3
PUSHR d2
POP d0
READPODARRAYV d2,0
PUSHR d2; UsrFunc[Bitmap create(int, int)] Params End
CALLFUNC 0.0244; UsrFunc[Bitmap create(int, int)] Call
POP d4
STORE_OBJECT d2,0
SETR d2,gd2; InlineFunc[void Bitmap->Blit(int, untyped, int, int, int, int, int, int, int, int, int, int, int, int, int, bool)] Params Start
PUSHR d2
PUSHV 7
LOAD d2,0
PUSHR d2
PUSHARGSV 0,0.0002
PUSHV 256
SETR d2,gd3
PUSHR d2
POP d0
READPODARRAYV d2,0
PUSHR d2
PUSHARGSV 0,0.0002
PUSHV 256
SETR d2,gd3
PUSHR d2
POP d0
READPODARRAYV d2,0
PUSHR d2
PUSHARGSV 0,0.0006; InlineFunc[void Bitmap->Blit(int, untyped, int, int, int, int, int, int, int, int, int, int, int, int, int, bool)] Params End
BMPBLIT; InlineFunc[void Bitmap->Blit(int, untyped, int, int, int, int, int, int, int, int, int, int, int, int, int, bool)] Body Start
POPARGS d5,0.0016
POP REFBITMAP; InlineFunc[void Bitmap->Blit(int, untyped, int, int, int, int, int, int, int, int, int, int, int, int, int, bool)] Body End
LOAD d2,0; InlineFunc[void Bitmap->Write(int, char32, bool)] Params Start
PUSHR d2
PUSHV 7
LOAD d2,0.0001
PUSHR d2
PUSHV 1; InlineFunc[void Bitmap->Write(int, char32, bool)] Params End
WRITEBITMAP; InlineFunc[void Bitmap->Write(int, char32, bool)] Body Start
POPARGS d5,0.0003
POP d3; InlineFunc[void Bitmap->Write(int, char32, bool)] Body End
LOAD d2,0; InlineFunc[void Bitmap->Free()] Params Start
SETR REFBITMAP,d2; InlineFunc[void Bitmap->Free()] Params End
BITMAPFREE; InlineFunc[void Bitmap->Free()] Body
REF_REMOVE 0
POPARGS d5,0.0002
RETURNFUNC; Func[void output(char32)] Body End
PUSHARGSV 0,0.0002; Func[void rollCredits(int)] Body Start
SETR d4,SP2
STOREV -224,0.0001; for() #187 setup
LOAD d2,0.0001; for() #187 LoopTest
PUSHR d2
SETR d2,gd3
PUSHR d2
POP d0
READPODARRAYV d2,0
POP d3
COMPARER d3,d2
SETCMP d2,I<
COMPAREV d2,0
GOTOCMP 544,==; for() #187 TestFail?
PUSHR d4; for() #187 Body Start
LOAD d2,0.0001; UsrFunc[void drawCredits(int)] Params Start
PUSHR d2; UsrFunc[void drawCredits(int)] Params End
CALLFUNC 0.0316; UsrFunc[void drawCredits(int)] Call
POP d4
STOREV 0,0; for() #188 setup
LOAD d2,0; for() #188 LoopTest
COMPAREV d2,18
SETCMP d2,I<
COMPAREV d2,0
GOTOCMP 536,==; for() #188 TestFail?
SETV d2,0; for() #188 Body Start
PUSHR d2
LOAD d2,0
PUSHR d2
POP d0
POP d2
SETR BUTTONINPUT,d2
SETV d2,0
PUSHR d2
LOAD d2,0
PUSHR d2
POP d0
POP d2
SETR BUTTONPRESS,d2; for() #188 Body End
LOAD d2,0; for() #188 LoopIncrement
ADDV d2,1
STORE d2,0
GOTO 513; for() #188 End
WAITFRAME; InlineFunc[void Waitframe()] Body AND for() #187 Body End
LOAD d2,0.0001; for() #187 LoopIncrement
PUSHR d2
LOAD d2,0.0002
POP d3
ADDR d2,d3
STORE d2,0.0001
GOTO 496; for() #187 End
POPARGS d5,0.0003
RETURNFUNC; Func[void rollCredits(int)] Body End
PUSHARGSV 0,0.0008; Func[void runTestCredits()] Body Start
SETR d4,SP2
PUSHR d4
CALLFUNC 0.0386; UsrFunc[void init()] Call
POP d4
ALLOCATEMEMV d2,7,0
STORE d2,0.0007
WRITEPODSTRING d2,"Author"
PUSHR d4
LOAD d2,0.0007; UsrFunc[void addHeader(char32)] Params Start
PUSHR d2; UsrFunc[void addHeader(char32)] Params End
CALLFUNC 0.0004; UsrFunc[void addHeader(char32)] Call
POP d4
LOAD d3,0.0007
DEALLOCATEMEMR d3
ALLOCATEMEMV d2,6,0
STORE d2,0.0006
WRITEPODSTRING d2,"Emily"
PUSHR d4
LOAD d2,0.0006; UsrFunc[void addLine(char32, int)] Params Start
PUSHR d2
PUSHV 2; UsrFunc[void addLine(char32, int)] Params End
CALLFUNC 0.0139; UsrFunc[void addLine(char32, int)] Call
POP d4
LOAD d3,0.0006
DEALLOCATEMEMR d3
ALLOCATEMEMV d2,9,0
STORE d2,0.0005
WRITEPODSTRING d2,"Graphics"
PUSHR d4
LOAD d2,0.0005; UsrFunc[void addHeader(char32)] Params Start
PUSHR d2; UsrFunc[void addHeader(char32)] Params End
CALLFUNC 0.0004; UsrFunc[void addHeader(char32)] Call
POP d4
LOAD d3,0.0005
DEALLOCATEMEMR d3
ALLOCATEMEMV d2,6,0
STORE d2,0.0004
WRITEPODSTRING d2,"Emily"
PUSHR d4
LOAD d2,0.0004; UsrFunc[void addLine(char32, int)] Params Start
PUSHR d2
PUSHV 2; UsrFunc[void addLine(char32, int)] Params End
CALLFUNC 0.0139; UsrFunc[void addLine(char32, int)] Call
POP d4
LOAD d3,0.0004
DEALLOCATEMEMR d3
ALLOCATEMEMV d2,8,0
STORE d2,0.0003
WRITEPODSTRING d2,"Scripts"
PUSHR d4
LOAD d2,0.0003; UsrFunc[void addHeader(char32)] Params Start
PUSHR d2; UsrFunc[void addHeader(char32)] Params End
CALLFUNC 0.0004; UsrFunc[void addHeader(char32)] Call
POP d4
LOAD d3,0.0003
DEALLOCATEMEMR d3
ALLOCATEMEMV d2,6,0
STORE d2,0.0002
WRITEPODSTRING d2,"Emily"
PUSHR d4
LOAD d2,0.0002; UsrFunc[void addLine(char32, int)] Params Start
PUSHR d2
PUSHV 2; UsrFunc[void addLine(char32, int)] Params End
CALLFUNC 0.0139; UsrFunc[void addLine(char32, int)] Call
POP d4
LOAD d3,0.0002
DEALLOCATEMEMR d3
ALLOCATEMEMV d2,15,0
STORE d2,0.0001
WRITEPODSTRING d2,"CreditsBMP.png"
PUSHR d4
LOAD d2,0.0001; UsrFunc[void output(char32)] Params Start
PUSHR d2; UsrFunc[void output(char32)] Params End
CALLFUNC 0.0443; UsrFunc[void output(char32)] Call
POP d4
LOAD d3,0.0001
DEALLOCATEMEMR d3
PUSHR d4
PUSHV 30; UsrFunc[void blackDelay(int)] Params
CALLFUNC 0.0218; UsrFunc[void blackDelay(int)] Call
PEEK d4
PUSHV 0.5000; UsrFunc[void rollCredits(int)] Params
CALLFUNC 0.0493; UsrFunc[void rollCredits(int)] Call
PEEK d4
PUSHV 30; UsrFunc[void blackDelay(int)] Params
CALLFUNC 0.0218; UsrFunc[void blackDelay(int)] Call
PEEK d4
CALLFUNC 0.0269; UsrFunc[void destroy()] Call
POP d4
STOREV 0,0; for() #189 setup
LOAD d2,0; for() #189 LoopTest
COMPAREV d2,10
SETCMP d2,I<
COMPAREV d2,0
GOTOCMP 647,==; for() #189 TestFail?
WAITFRAME; InlineFunc[void Waitframe()] Body AND for() #189 Body
LOAD d2,0; for() #189 LoopIncrement
ADDV d2,1
STORE d2,0
GOTO 637; for() #189 End
QUIT; InlineFunc[void Quit()] Body AND [Opt:NeverRet] AND Func[void runTestCredits()] Body End


ALLOCATEGMEMV d2,4096,0; void run() Body Start
SETR gd1,d2
MARK_TYPE_REG gd2,0.0001
SETV gd2,0
ALLOCATEGMEMV d2,6,0
SETR gd3,d2
QUIT; void run() Body End