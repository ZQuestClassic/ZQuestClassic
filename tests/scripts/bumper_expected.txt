Compiling 'bumper.zs'
Pass 1: Parsing
Pass 2: Preprocessing
Pass 3: Registration
Pass 4: Analyzing Code
Pass 5: Checking code paths
Pass 6: Generating object code
Pass 7: Assembling
Success!
Compile finished with exit code '0' (success)

PUSHR d0; void run(int) Params
PUSHR REFFFC; void run(int) Body Start
PUSHARGSV 0,0.0007
SETR d4,SP
LOADD d2,7
PUSHR d2
POP REFFFC
SETR d2,DATA
STORED d2,6
SETV d2,0
STORED d2,5
SETV d2,0
STORED d2,4
SETV d2,0
PUSHR d2
LOADD d2,7
POP d3
PUSHR d2
PUSHR d3
SETV d2,7
PUSHR d2
POP d0
POP d2
POP REFFFC
SETR FFINITDD,d2
SETV d2,0
STORED d2,3
SETV d2,0
STORED d2,2
SETV d2,0
STORED d2,1
PUSHARGSR d4,0.0002; if() #9322 Test AND while(true) #9320 Body [Opt:AlwaysOn] Start AND Int.Func[int Distance(int, int, int, int)] Params Start
LOADD d2,7; UsrFunc[int CenterX(FFC)] Params Start
PUSHR d2; UsrFunc[int CenterX(FFC)] Params End
CALLFUNC 0.0859; UsrFunc[int CenterX(FFC)] Call
POP d4
PUSHR d2
PUSHR d4
LOADD d2,7; UsrFunc[int CenterY(FFC)] Params Start
PUSHR d2; UsrFunc[int CenterY(FFC)] Params End
CALLFUNC 0.0882; UsrFunc[int CenterY(FFC)] Call
POP d4
PUSHR d2
PUSHR d4
CALLFUNC 0.0851; UsrFunc[int CenterLinkX()] Call
POP d4
PUSHR d2
PUSHR d4
CALLFUNC 0.0855; UsrFunc[int CenterLinkY()] Call
POP d4
PUSHR d2; Int.Func[int Distance(int, int, int, int)] Params End
CALLFUNC 0.0485; Int.Func[int Distance(int, int, int, int)] Call
POP d4
PUSHR d2
LOADD d2,7
PUSHR d2
POP REFFFC
SETR d2,FFTWIDTH
MULTV d2,8
ADDV d2,2
POP d3
COMPARER d3,d2
SETMORE d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 72
SETR d2,LINKZ
COMPAREV d2,0
SETTRUEI d2
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0
GOTOTRUE 119; Test 'if'
LOADD d2,7; if() #9324 Test AND if() #9322 Body Start
PUSHR d2
SETV d2,7
PUSHR d2
POP d0
POP REFFFC
SETR d2,FFINITDD
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 116; Test 'if'
SETV d2,76; InlineFunc[void Game->PlaySound(int)] Params AND if() #9324 Body Start
PLAYSOUNDR d2; InlineFunc[void Game->PlaySound(int)] Body
PUSHARGSR d4,0.0002; UsrFunc[int Angle(int, int, int, int)] Params Start
LOADD d2,7; UsrFunc[int CenterX(FFC)] Params Start
PUSHR d2; UsrFunc[int CenterX(FFC)] Params End
CALLFUNC 0.0859; UsrFunc[int CenterX(FFC)] Call
POP d4
PUSHR d2
PUSHR d4
LOADD d2,7; UsrFunc[int CenterY(FFC)] Params Start
PUSHR d2; UsrFunc[int CenterY(FFC)] Params End
CALLFUNC 0.0882; UsrFunc[int CenterY(FFC)] Call
POP d4
PUSHR d2
PUSHR d4
CALLFUNC 0.0851; UsrFunc[int CenterLinkX()] Call
POP d4
PUSHR d2
PUSHR d4
CALLFUNC 0.0855; UsrFunc[int CenterLinkY()] Call
POP d4
PUSHR d2; UsrFunc[int Angle(int, int, int, int)] Params End
CALLFUNC 0.0530; UsrFunc[int Angle(int, int, int, int)] Call
POP d4
STORED d2,5
LOADD d2,8
STORED d2,4
SETV d2,16
STORED d2,3; if() #9324 Body End
PUSHR d4
CALLFUNC 0.0905; UsrFunc[void NoAction()] Call
POP d4; if() #9322 Body End
LOADD d2,4; if() #9325 Test
COMPAREV d2,0
SETLESS d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 153; Test 'if'
LOADD d2,2; if() #9325 Body Start
PUSHR d2
PUSHR d4
PUSHV 3; UsrFunc[int VectorX(int, int)] Params Start
LOADD d2,5
PUSHR d2; UsrFunc[int VectorX(int, int)] Params End
CALLFUNC 0.0950; UsrFunc[int VectorX(int, int)] Call
POP d4
POP d3
ADDR d2,d3
STORED d2,2
LOADD d2,1
PUSHR d2
PUSHR d4
PUSHV 3; UsrFunc[int VectorY(int, int)] Params Start
LOADD d2,5
PUSHR d2; UsrFunc[int VectorY(int, int)] Params End
CALLFUNC 0.0960; UsrFunc[int VectorY(int, int)] Call
POP d4
POP d3
ADDR d2,d3
STORED d2,1
LOADD d2,4
PUSHR d2
SUBV d2,1
STORED d2,4
POP d2; if() #9325 Body End
LOADD d2,2; InlineFunc[int Abs(int)] Params AND if() #9326 Test
ABS d2; InlineFunc[int Abs(int)] Body
COMPAREV d2,0
SETLESS d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 305; Test 'if'
SETV d2,0; for() #9327 setup AND if() #9326 Body Start
STORED d2,0
LOADD d2,0; for() #9327 LoopTest
COMPAREV d2,4
SETMORE d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 174
LOADD d2,2
COMPAREV d2,-1
SETLESSI d2
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0
GOTOTRUE 233; for() #9327 TestFail?
PUSHR d4; if() #9331 Test AND for() #9327 Body Start
PUSHR LINKX; UsrFunc[bool CanWalk(int, int, int, int, bool)] Params Start
PUSHR LINKY
PUSHV 2
PUSHV 1
PUSHV 0; UsrFunc[bool CanWalk(int, int, int, int, bool)] Params End
CALLFUNC 0.0549; UsrFunc[bool CanWalk(int, int, int, int, bool)] Call
POP d4
COMPAREV d2,0
GOTOTRUE 201; Test 'if'
SETR d2,LINKX; if() #9331 Body Start
PUSHR d2
SUBV d2,1
PUSHR d2
POP d2
SETR LINKX,d2
POP d2
LOADD d2,2
PUSHR d2
ADDV d2,1
STORED d2,2
POP d2
GOTO 227; if() #9331 Body End
LOADD d2,1; InlineFunc[int Abs(int)] Params AND if() #9333 Test AND if() #9331 Else Start
ABS d2; InlineFunc[int Abs(int)] Body
COMPAREV d2,0
SETLESS d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 225; Test 'if'
LOADD d2,1; if() #9333 Body Start
PUSHR d2
PUSHR d4
LOADD d2,1; UsrFunc[int Sign(int)] Params Start
PUSHR d2; UsrFunc[int Sign(int)] Params End
CALLFUNC 0.0970; UsrFunc[int Sign(int)] Call
POP d4
PUSHR d2
LOADD d2,2; InlineFunc[int Abs(int)] Params Start
DIVV d2,2; InlineFunc[int Abs(int)] Params End
ABS d2; InlineFunc[int Abs(int)] Body
POP d3
MULTR d2,d3
POP d3
ADDR d2,d3
STORED d2,1; if() #9333 Body End
SETV d2,0
STORED d2,2; if() #9331 Else End
LOADD d2,0; for() #9327 Body End AND for() #9327 LoopIncrement
PUSHR d2
ADDV d2,1
STORED d2,0
POP d2
GOTO 163; for() #9327 End
SETV d2,0; for() #9334 setup
STORED d2,0
LOADD d2,0; for() #9334 LoopTest
COMPAREV d2,4
SETMORE d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 246
LOADD d2,2
COMPAREV d2,1
SETMOREI d2
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0
GOTOTRUE 305; for() #9334 TestFail?
PUSHR d4; if() #9338 Test AND for() #9334 Body Start
PUSHR LINKX; UsrFunc[bool CanWalk(int, int, int, int, bool)] Params Start
PUSHR LINKY
PUSHV 3
PUSHV 1
PUSHV 0; UsrFunc[bool CanWalk(int, int, int, int, bool)] Params End
CALLFUNC 0.0549; UsrFunc[bool CanWalk(int, int, int, int, bool)] Call
POP d4
COMPAREV d2,0
GOTOTRUE 273; Test 'if'
SETR d2,LINKX; if() #9338 Body Start
PUSHR d2
ADDV d2,1
PUSHR d2
POP d2
SETR LINKX,d2
POP d2
LOADD d2,2
PUSHR d2
SUBV d2,1
STORED d2,2
POP d2
GOTO 299; if() #9338 Body End
LOADD d2,1; InlineFunc[int Abs(int)] Params AND if() #9340 Test AND if() #9338 Else Start
ABS d2; InlineFunc[int Abs(int)] Body
COMPAREV d2,0
SETLESS d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 297; Test 'if'
LOADD d2,1; if() #9340 Body Start
PUSHR d2
PUSHR d4
LOADD d2,1; UsrFunc[int Sign(int)] Params Start
PUSHR d2; UsrFunc[int Sign(int)] Params End
CALLFUNC 0.0970; UsrFunc[int Sign(int)] Call
POP d4
PUSHR d2
LOADD d2,2; InlineFunc[int Abs(int)] Params Start
DIVV d2,2; InlineFunc[int Abs(int)] Params End
ABS d2; InlineFunc[int Abs(int)] Body
POP d3
MULTR d2,d3
POP d3
ADDR d2,d3
STORED d2,1; if() #9340 Body End
SETV d2,0
STORED d2,2; if() #9338 Else End
LOADD d2,0; for() #9334 Body End AND for() #9334 LoopIncrement
PUSHR d2
ADDV d2,1
STORED d2,0
POP d2
GOTO 235; for() #9334 End
LOADD d2,1; if() #9326 Body End AND InlineFunc[int Abs(int)] Params AND if() #9341 Test
ABS d2; InlineFunc[int Abs(int)] Body
COMPAREV d2,0
SETLESS d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 456; Test 'if'
SETV d2,0; for() #9342 setup AND if() #9341 Body Start
STORED d2,0
LOADD d2,0; for() #9342 LoopTest
COMPAREV d2,4
SETMORE d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 326
LOADD d2,1
COMPAREV d2,-1
SETLESSI d2
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0
GOTOTRUE 385; for() #9342 TestFail?
PUSHR d4; if() #9346 Test AND for() #9342 Body Start
PUSHR LINKX; UsrFunc[bool CanWalk(int, int, int, int, bool)] Params Start
PUSHR LINKY
PUSHV 0
PUSHV 1
PUSHV 0; UsrFunc[bool CanWalk(int, int, int, int, bool)] Params End
CALLFUNC 0.0549; UsrFunc[bool CanWalk(int, int, int, int, bool)] Call
POP d4
COMPAREV d2,0
GOTOTRUE 353; Test 'if'
SETR d2,LINKY; if() #9346 Body Start
PUSHR d2
SUBV d2,1
PUSHR d2
POP d2
SETR LINKY,d2
POP d2
LOADD d2,1
PUSHR d2
ADDV d2,1
STORED d2,1
POP d2
GOTO 379; if() #9346 Body End
LOADD d2,2; InlineFunc[int Abs(int)] Params AND if() #9348 Test AND if() #9346 Else Start
ABS d2; InlineFunc[int Abs(int)] Body
COMPAREV d2,0
SETLESS d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 377; Test 'if'
LOADD d2,2; if() #9348 Body Start
PUSHR d2
PUSHR d4
LOADD d2,2; UsrFunc[int Sign(int)] Params Start
PUSHR d2; UsrFunc[int Sign(int)] Params End
CALLFUNC 0.0970; UsrFunc[int Sign(int)] Call
POP d4
PUSHR d2
LOADD d2,1; InlineFunc[int Abs(int)] Params Start
DIVV d2,2; InlineFunc[int Abs(int)] Params End
ABS d2; InlineFunc[int Abs(int)] Body
POP d3
MULTR d2,d3
POP d3
ADDR d2,d3
STORED d2,2; if() #9348 Body End
SETV d2,0
STORED d2,1; if() #9346 Else End
LOADD d2,0; for() #9342 Body End AND for() #9342 LoopIncrement
PUSHR d2
ADDV d2,1
STORED d2,0
POP d2
GOTO 315; for() #9342 End
SETV d2,0; for() #9349 setup
STORED d2,0
LOADD d2,0; for() #9349 LoopTest
COMPAREV d2,4
SETMORE d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 398
LOADD d2,1
COMPAREV d2,1
SETMOREI d2
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0
GOTOTRUE 456; for() #9349 TestFail?
PUSHR d4; if() #9353 Test AND for() #9349 Body Start
PUSHR LINKX; UsrFunc[bool CanWalk(int, int, int, int, bool)] Params Start
PUSHR LINKY
PUSHARGSV 1,0.0002
PUSHV 0; UsrFunc[bool CanWalk(int, int, int, int, bool)] Params End
CALLFUNC 0.0549; UsrFunc[bool CanWalk(int, int, int, int, bool)] Call
POP d4
COMPAREV d2,0
GOTOTRUE 424; Test 'if'
SETR d2,LINKY; if() #9353 Body Start
PUSHR d2
ADDV d2,1
PUSHR d2
POP d2
SETR LINKY,d2
POP d2
LOADD d2,1
PUSHR d2
SUBV d2,1
STORED d2,1
POP d2
GOTO 450; if() #9353 Body End
LOADD d2,2; InlineFunc[int Abs(int)] Params AND if() #9355 Test AND if() #9353 Else Start
ABS d2; InlineFunc[int Abs(int)] Body
COMPAREV d2,0
SETLESS d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 448; Test 'if'
LOADD d2,2; if() #9355 Body Start
PUSHR d2
PUSHR d4
LOADD d2,2; UsrFunc[int Sign(int)] Params Start
PUSHR d2; UsrFunc[int Sign(int)] Params End
CALLFUNC 0.0970; UsrFunc[int Sign(int)] Call
POP d4
PUSHR d2
LOADD d2,1; InlineFunc[int Abs(int)] Params Start
DIVV d2,2; InlineFunc[int Abs(int)] Params End
ABS d2; InlineFunc[int Abs(int)] Body
POP d3
MULTR d2,d3
POP d3
ADDR d2,d3
STORED d2,2; if() #9355 Body End
SETV d2,0
STORED d2,1; if() #9353 Else End
LOADD d2,0; for() #9349 Body End AND for() #9349 LoopIncrement
PUSHR d2
ADDV d2,1
STORED d2,0
POP d2
GOTO 387; for() #9349 End
LOADD d2,3; if() #9341 Body End AND if() #9356 Test
COMPAREV d2,0
SETLESS d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 468; Test 'if'
LOADD d2,3; if() #9356 Body Start
PUSHR d2
SUBV d2,1
STORED d2,3
POP d2; if() #9356 Body End
LOADD d2,6
PUSHR d2
LOADD d2,3; InlineFunc[untyped Floor(untyped)] Params Start
DIVV d2,4; InlineFunc[untyped Floor(untyped)] Params End
FLOOR d2; InlineFunc[untyped Floor(untyped)] Body
POP d3
ADDR d2,d3
PUSHR d2
LOADD d2,7
POP d3
PUSHR d2
PUSHR d3
POP d2
POP REFFFC
SETR DATA,d2
WAITFRAME; InlineFunc[void Waitframe()] Body AND while(true) #9320 Body [Opt:AlwaysOn] End
GOTO 32; while() #9320 End
POP d2; [Opt:NeverRet] AND void run(int) Body End AND Func[int Distance(int, int, int, int)] Body Start
POP d1
POP d0
POP d6
SETR d2,DISTANCE
RETURNFUNC; Func[int Distance(int, int, int, int)] Body End
SETR d4,SP; Func[int DirNormal(int)] Body Start
LOADD d2,0; switch() #4324 Key
SETR SWITCHKEY,d2; Store key
COMPAREV SWITCHKEY,8
GOTOTRUE 511; case '80000'
COMPAREV SWITCHKEY,9
GOTOTRUE 513; case '90000'
COMPAREV SWITCHKEY,10
GOTOTRUE 515; case '100000'
COMPAREV SWITCHKEY,11
GOTOTRUE 517; case '110000'
COMPAREV SWITCHKEY,12
GOTOTRUE 519; case '120000'
COMPAREV SWITCHKEY,13
GOTOTRUE 521; case '130000'
COMPAREV SWITCHKEY,14
GOTOTRUE 523; case '140000'
COMPAREV SWITCHKEY,15
GOTOTRUE 525; case '150000'
GOTO 527; switch() #4324 NoMatch
SETV d2,0; Case block AND return Start
GOTO 528; return End
SETV d2,5; Case block AND return Start
GOTO 528; return End
SETV d2,3; Case block AND return Start
GOTO 528; return End
SETV d2,7; Case block AND return Start
GOTO 528; return End
SETV d2,1; Case block AND return Start
GOTO 528; return End
SETV d2,6; Case block AND return Start
GOTO 528; return End
SETV d2,2; Case block AND return Start
GOTO 528; return End
SETV d2,4; Case block AND return Start
GOTO 528; return End
LOADD d2,0; Case block AND return Start
POP d5; return End
RETURNFUNC; Func[int DirNormal(int)] Body End
SETR d4,SP; Func[int Angle(int, int, int, int)] Body Start
LOADD d2,1; InlineFunc[int ArcTan(int, int)] Params Start AND InlineFunc[int RadtoDeg(int)] Params Start AND return Start
PUSHR d2
LOADD d2,3
POP d3
SUBR d3,d2
PUSHR d3
LOADD d2,0
PUSHR d2
LOADD d2,2
POP d3
SUBR d3,d2
SETR d1,d3; InlineFunc[int ArcTan(int, int)] Params End
POP d0; InlineFunc[int ArcTan(int, int)] Body Start
ARCTANR d2; InlineFunc[int ArcTan(int, int)] Body End
SETR d3,d2; InlineFunc[int RadtoDeg(int)] Params End
RADTODEG d2,d3; InlineFunc[int RadtoDeg(int)] Body
POPARGS d5,0.0004; return End
RETURNFUNC; Func[int Angle(int, int, int, int)] Body End
PUSHARGSV 0,0.0004; Func[bool CanWalk(int, int, int, int, bool)] Body Start
SETR d4,SP
SETV d2,8
STORED d2,3
LOADD d2,8
ADDV d2,15
STORED d2,2
LOADD d2,7
ADDV d2,15
STORED d2,1
LOADD d2,4; if() #3643 Test
COMPAREV d2,0
GOTOTRUE 564; Test 'if'
SETV d2,0; if() #3643 Body Start
STORED d2,3; if() #3643 Body End
PUSHR d4; switch() #3644 Key
LOADD d2,6; UsrFunc[int DirNormal(int)] Params Start
PUSHR d2; UsrFunc[int DirNormal(int)] Params End
CALLFUNC 0.0491; UsrFunc[int DirNormal(int)] Call
POP d4
SETR SWITCHKEY,d2; Store key
COMPAREV SWITCHKEY,0
GOTOTRUE 579; case '0'
COMPAREV SWITCHKEY,1
GOTOTRUE 650; case '10000'
COMPAREV SWITCHKEY,2
GOTOTRUE 706; case '20000'
COMPAREV SWITCHKEY,3
GOTOTRUE 773; case '30000'
GOTO 837; switch() #3644 NoMatch
LOADD d2,7; Case block AND return Start
PUSHR d2
LOADD d2,5
POP d3
SUBR d3,d2
SETR d2,d3
COMPAREV d2,0
SETMORE d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0.0001
GOTOMORE 607
LOADD d2,8; InlineFunc[bool Screen->isSolid(int, int)] Params Start
PUSHR d2
LOADD d2,7
PUSHR d2
LOADD d2,3
POP d3
ADDR d2,d3
PUSHR d2
LOADD d2,5
POP d3
SUBR d3,d2
SETR d1,d3; InlineFunc[bool Screen->isSolid(int, int)] Params End
POP d0; InlineFunc[bool Screen->isSolid(int, int)] Body Start
ISSOLID d2; InlineFunc[bool Screen->isSolid(int, int)] Body End
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0.0001
GOTOMORE 627
LOADD d2,8; InlineFunc[bool Screen->isSolid(int, int)] Params Start
ADDV d2,8
PUSHR d2
LOADD d2,7
PUSHR d2
LOADD d2,3
POP d3
ADDR d2,d3
PUSHR d2
LOADD d2,5
POP d3
SUBR d3,d2
SETR d1,d3; InlineFunc[bool Screen->isSolid(int, int)] Params End
POP d0; InlineFunc[bool Screen->isSolid(int, int)] Body Start
ISSOLID d2; InlineFunc[bool Screen->isSolid(int, int)] Body End
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0.0001
GOTOMORE 646
LOADD d2,2; InlineFunc[bool Screen->isSolid(int, int)] Params Start
PUSHR d2
LOADD d2,7
PUSHR d2
LOADD d2,3
POP d3
ADDR d2,d3
PUSHR d2
LOADD d2,5
POP d3
SUBR d3,d2
SETR d1,d3; InlineFunc[bool Screen->isSolid(int, int)] Params End
POP d0; InlineFunc[bool Screen->isSolid(int, int)] Body Start
ISSOLID d2; InlineFunc[bool Screen->isSolid(int, int)] Body End
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0
SETTRUEI d2
GOTO 849; return End
LOADD d2,1; Case block AND return Start
PUSHR d2
LOADD d2,5
POP d3
ADDR d2,d3
COMPAREV d2,176
SETMOREI d2
COMPAREV d2,0.0001
GOTOMORE 671
LOADD d2,8; InlineFunc[bool Screen->isSolid(int, int)] Params Start
PUSHR d2
LOADD d2,1
PUSHR d2
LOADD d2,5
POP d3
ADDR d2,d3
SETR d1,d2; InlineFunc[bool Screen->isSolid(int, int)] Params End
POP d0; InlineFunc[bool Screen->isSolid(int, int)] Body Start
ISSOLID d2; InlineFunc[bool Screen->isSolid(int, int)] Body End
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0.0001
GOTOMORE 687
LOADD d2,8; InlineFunc[bool Screen->isSolid(int, int)] Params Start
ADDV d2,8
PUSHR d2
LOADD d2,1
PUSHR d2
LOADD d2,5
POP d3
ADDR d2,d3
SETR d1,d2; InlineFunc[bool Screen->isSolid(int, int)] Params End
POP d0; InlineFunc[bool Screen->isSolid(int, int)] Body Start
ISSOLID d2; InlineFunc[bool Screen->isSolid(int, int)] Body End
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0.0001
GOTOMORE 702
LOADD d2,2; InlineFunc[bool Screen->isSolid(int, int)] Params Start
PUSHR d2
LOADD d2,1
PUSHR d2
LOADD d2,5
POP d3
ADDR d2,d3
SETR d1,d2; InlineFunc[bool Screen->isSolid(int, int)] Params End
POP d0; InlineFunc[bool Screen->isSolid(int, int)] Body Start
ISSOLID d2; InlineFunc[bool Screen->isSolid(int, int)] Body End
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0
SETTRUEI d2
GOTO 849; return End
LOADD d2,8; Case block AND return Start
PUSHR d2
LOADD d2,5
POP d3
SUBR d3,d2
SETR d2,d3
COMPAREV d2,0
SETMORE d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0.0001
GOTOMORE 734
LOADD d2,8; InlineFunc[bool Screen->isSolid(int, int)] Params Start
PUSHR d2
LOADD d2,5
POP d3
SUBR d3,d2
PUSHR d3
LOADD d2,7
PUSHR d2
LOADD d2,3
POP d3
ADDR d2,d3
SETR d1,d2; InlineFunc[bool Screen->isSolid(int, int)] Params End
POP d0; InlineFunc[bool Screen->isSolid(int, int)] Body Start
ISSOLID d2; InlineFunc[bool Screen->isSolid(int, int)] Body End
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0.0001
GOTOMORE 754
LOADD d2,8; InlineFunc[bool Screen->isSolid(int, int)] Params Start
PUSHR d2
LOADD d2,5
POP d3
SUBR d3,d2
PUSHR d3
LOADD d2,7
PUSHR d2
LOADD d2,3
POP d3
ADDR d2,d3
ADDV d2,7
SETR d1,d2; InlineFunc[bool Screen->isSolid(int, int)] Params End
POP d0; InlineFunc[bool Screen->isSolid(int, int)] Body Start
ISSOLID d2; InlineFunc[bool Screen->isSolid(int, int)] Body End
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0.0001
GOTOMORE 769
LOADD d2,8; InlineFunc[bool Screen->isSolid(int, int)] Params Start
PUSHR d2
LOADD d2,5
POP d3
SUBR d3,d2
PUSHR d3
LOADD d2,1
SETR d1,d2; InlineFunc[bool Screen->isSolid(int, int)] Params End
POP d0; InlineFunc[bool Screen->isSolid(int, int)] Body Start
ISSOLID d2; InlineFunc[bool Screen->isSolid(int, int)] Body End
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0
SETTRUEI d2
GOTO 849; return End
LOADD d2,2; Case block AND return Start
PUSHR d2
LOADD d2,5
POP d3
ADDR d2,d3
COMPAREV d2,256
SETMOREI d2
COMPAREV d2,0.0001
GOTOMORE 798
LOADD d2,2; InlineFunc[bool Screen->isSolid(int, int)] Params Start
PUSHR d2
LOADD d2,5
POP d3
ADDR d2,d3
PUSHR d2
LOADD d2,7
PUSHR d2
LOADD d2,3
POP d3
ADDR d2,d3
SETR d1,d2; InlineFunc[bool Screen->isSolid(int, int)] Params End
POP d0; InlineFunc[bool Screen->isSolid(int, int)] Body Start
ISSOLID d2; InlineFunc[bool Screen->isSolid(int, int)] Body End
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0.0001
GOTOMORE 818
LOADD d2,2; InlineFunc[bool Screen->isSolid(int, int)] Params Start
PUSHR d2
LOADD d2,5
POP d3
ADDR d2,d3
PUSHR d2
LOADD d2,7
PUSHR d2
LOADD d2,3
POP d3
ADDR d2,d3
ADDV d2,7
SETR d1,d2; InlineFunc[bool Screen->isSolid(int, int)] Params End
POP d0; InlineFunc[bool Screen->isSolid(int, int)] Body Start
ISSOLID d2; InlineFunc[bool Screen->isSolid(int, int)] Body End
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0.0001
GOTOMORE 833
LOADD d2,2; InlineFunc[bool Screen->isSolid(int, int)] Params Start
PUSHR d2
LOADD d2,5
POP d3
ADDR d2,d3
PUSHR d2
LOADD d2,1
SETR d1,d2; InlineFunc[bool Screen->isSolid(int, int)] Params End
POP d0; InlineFunc[bool Screen->isSolid(int, int)] Body Start
ISSOLID d2; InlineFunc[bool Screen->isSolid(int, int)] Body End
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0
SETTRUEI d2
GOTO 849; return End
ALLOCATEMEMV d2,60; Case block
STORED d2,0
WRITEPODSTRING d2,"Invalid direction %d passed to CanWalk(x,y,dir,step,bool) \n"
LOADD d2,0; InlineFunc[void printf(char32)] Params Start
PUSHR d2
LOADD d2,6
PUSHVARGR d2; InlineFunc[void printf(char32)] Params End
PRINTFVARG; InlineFunc[void printf(char32)] Body Start
POP d5; InlineFunc[void printf(char32)] Body End
LOADD d3,0
DEALLOCATEMEMR d3
SETV d2,0; return Start
POPARGS d5,0.0009; return End
RETURNFUNC; Func[bool CanWalk(int, int, int, int, bool)] Body End
SETR d4,SP; Func[int CenterLinkX()] Body Start
SETR d2,LINKX; return Start
ADDV d2,8
RETURNFUNC; return End AND Func[int CenterLinkX()] Body End
SETR d4,SP; Func[int CenterLinkY()] Body Start
SETR d2,LINKY; return Start
ADDV d2,8
RETURNFUNC; return End AND Func[int CenterLinkY()] Body End
SETR d4,SP; Func[int CenterX(FFC)] Body Start
LOADD d2,0; return Start
PUSHR d2
POP REFFFC
SETR d2,X
PUSHR d2
LOADD d2,0
PUSHR d2
POP REFFFC
SETR d2,FFTWIDTH
MULTV d2,8
SETV d2,8
PUSHR d2
LOADD d2,0
PUSHR d2
POP REFFFC
SETR d2,FFTWIDTH
POP d3
MULTR d2,d3
POP d3
ADDR d2,d3
POP d5; return End
RETURNFUNC; Func[int CenterX(FFC)] Body End
SETR d4,SP; Func[int CenterY(FFC)] Body Start
LOADD d2,0; return Start
PUSHR d2
POP REFFFC
SETR d2,Y
PUSHR d2
LOADD d2,0
PUSHR d2
POP REFFFC
SETR d2,FFTHEIGHT
MULTV d2,8
SETV d2,8
PUSHR d2
LOADD d2,0
PUSHR d2
POP REFFFC
SETR d2,FFTHEIGHT
POP d3
MULTR d2,d3
POP d3
ADDR d2,d3
POP d5; return End
RETURNFUNC; Func[int CenterY(FFC)] Body End
PUSHV 0; Func[void NoAction()] Body Start
SETR d4,SP
SETV d2,0; for() #6211 setup
STORED d2,0
LOADD d2,0; for() #6211 LoopTest
COMPAREV d2,14
SETMORE d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 948; for() #6211 TestFail?
LOADD d2,0; if() #6214 Test AND for() #6211 Body Start
COMPAREV d2,9
SETTRUEI d2
SETV d2,0
COMPAREV d2,0
GOTOTRUE 923; Test 'if'
GOTO 944; continue #6213 AND if() #6214 Body
LOADD d2,0; if() #6215 Test
COMPAREV d2,6
SETTRUEI d2
SETV d2,0
COMPAREV d2,0
GOTOTRUE 930; Test 'if'
GOTO 944; continue #6213 AND if() #6215 Body
SETV d2,0
PUSHR d2
LOADD d2,0
PUSHR d2
POP d0
POP d2
SETR BUTTONINPUT,d2
SETV d2,0
PUSHR d2
LOADD d2,0
PUSHR d2
POP d0
POP d2
SETR BUTTONPRESS,d2; for() #6211 Body End
LOADD d2,0; for() #6211 LoopIncrement
ADDV d2,1
STORED d2,0
GOTO 909; for() #6211 End
POP d5
RETURNFUNC; Func[void NoAction()] Body End
SETR d4,SP; Func[int VectorX(int, int)] Body Start
LOADD d2,0; InlineFunc[int Cos(int)] Params Start AND return Start
SETR d3,d2; InlineFunc[int Cos(int)] Params End
COSR d2,d3; InlineFunc[int Cos(int)] Body
PUSHR d2
LOADD d2,1
POP d3
MULTR d2,d3
POPARGS d5,0.0002; return End
RETURNFUNC; Func[int VectorX(int, int)] Body End
SETR d4,SP; Func[int VectorY(int, int)] Body Start
LOADD d2,0; InlineFunc[int Sin(int)] Params Start AND return Start
SETR d3,d2; InlineFunc[int Sin(int)] Params End
SINR d2,d3; InlineFunc[int Sin(int)] Body
PUSHR d2
LOADD d2,1
POP d3
MULTR d2,d3
POPARGS d5,0.0002; return End
RETURNFUNC; Func[int VectorY(int, int)] Body End
SETR d4,SP; Func[int Sign(int)] Body Start
LOADD d2,0; if() #7537 Test
COMPAREV d2,0
SETLESS d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 980; Test 'if'
SETV d2,1; return Start AND if() #7537 Body Start
GOTO 990; return End AND if() #7537 Body End
LOADD d2,0; if() #7539 Test AND if() #7537 Else Start
COMPAREV d2,0
SETMORE d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 989; Test 'if'
SETV d2,-1; return Start AND if() #7539 Body Start
GOTO 990; return End AND if() #7539 Body End
SETV d2,0; return Start AND if() #7539 Else Start
POP d5; return End AND if() #7539 Else End AND if() #7537 Else End
RETURNFUNC; Func[int Sign(int)] Body End


ALLOCATEGMEMV d2,4096; void run() Body Start
SETR gd1,d2
QUIT; void run() Body End