Compiling 'bumper.zs'
Pass 1: Parsing
Pass 2: Preprocessing
Pass 3: Registration
Pass 4: Analyzing Code
Pass 5: Checking code paths
Pass 6: Generating object code
Pass 7: Assembling
Success!
Compile finished with exit code '0' (success)
=== METADATA (elided)
{
  "currentFileSymbols": 16,
  "symbols": 38,
  "identifiers": 117
}
ALLOCATEGMEMV D2 4096 0; void run() Body Start
SETR GD1 D2
QUIT; void run() Body End
PUSHR D0; void run(int) Params
PUSHR REFFFC; void run(int) Body Start
PUSHARGSV 0 0.0007
SETR D4 SP2
LOAD D2 0.0007
PUSHR D2
POP REFFFC
SETR D2 DATA
STORE D2 0.0006
STOREV 0 0.0005
STOREV 0 0.0004
SETV D2 0
PUSHR D2
LOAD D2 0.0007
POP D3
PUSHR D2
PUSHR D3
SETV D2 7
PUSHR D2
POP D0
POP D2
POP REFFFC
SETR FFINITDD D2
STOREV 0 0.0003
STOREV 0 0.0002
STOREV 0 0.0001
PUSHR D4; InlineFunc[int Distance(int, int, int, int)] Params Start AND if() #448 Test AND while(true) #2 Body [Opt:AlwaysOn] Start
LOAD D2 0.0007; UsrFunc[int CenterX(ffc)] Params Start
PUSHR D2; UsrFunc[int CenterX(ffc)] Params End
CALLFUNC 0.0755; UsrFunc[int CenterX(ffc)] Call
POP D4
PUSHR D2
PUSHR D4
LOAD D2 0.0007; UsrFunc[int CenterY(ffc)] Params Start
PUSHR D2; UsrFunc[int CenterY(ffc)] Params End
CALLFUNC 0.0778; UsrFunc[int CenterY(ffc)] Call
POP D4
PUSHR D2
PUSHR D4
CALLFUNC 0.0747; UsrFunc[int CenterLinkX()] Call
POP D4
PUSHR D2
PUSHR D4
CALLFUNC 0.0751; UsrFunc[int CenterLinkY()] Call
POP D4; InlineFunc[int Distance(int, int, int, int)] Params End
POP D1; InlineFunc[int Distance(int, int, int, int)] Body Start
POP D0
POP D6
SETR D2 DISTANCE; InlineFunc[int Distance(int, int, int, int)] Body End
PUSHR D2
LOAD D2 0.0007
PUSHR D2
POP REFFFC
SETR D2 FFTWIDTH
MULTV D2 8
ADDV D2 2
POP D3
COMPARER D3 D2
GOTOCMP 68 >=
SETR D2 LINKZ
COMPAREV D2 0
GOTOCMP 68 !=
SETV D2 1
GOTO 69
SETV D2 0
COMPAREV D2 0
GOTOCMP 114 ==; Test 'if'
LOAD D2 0.0007; if() #449 Test AND if() #448 Body Start
PUSHR D2
SETV D2 7
PUSHR D2
POP D0
POP REFFFC
SETR D2 FFINITDD
COMPAREV D2 0
SETCMP D2 I==
COMPAREV D2 0
GOTOCMP 111 ==; Test 'if'
SETV D2 76; InlineFunc[void Audio::PlaySound(int)] Params AND if() #449 Body Start
PLAYSOUNDR D2; InlineFunc[void Audio::PlaySound(int)] Body
PUSHARGSR D4 0.0002; UsrFunc[int Angle(int, int, int, int)] Params Start
LOAD D2 0.0007; UsrFunc[int CenterX(ffc)] Params Start
PUSHR D2; UsrFunc[int CenterX(ffc)] Params End
CALLFUNC 0.0755; UsrFunc[int CenterX(ffc)] Call
POP D4
PUSHR D2
PUSHR D4
LOAD D2 0.0007; UsrFunc[int CenterY(ffc)] Params Start
PUSHR D2; UsrFunc[int CenterY(ffc)] Params End
CALLFUNC 0.0778; UsrFunc[int CenterY(ffc)] Call
POP D4
PUSHR D2
PUSHR D4
CALLFUNC 0.0747; UsrFunc[int CenterLinkX()] Call
POP D4
PUSHR D2
PUSHR D4
CALLFUNC 0.0751; UsrFunc[int CenterLinkY()] Call
POP D4
PUSHR D2; UsrFunc[int Angle(int, int, int, int)] Params End
CALLFUNC 0.0455; UsrFunc[int Angle(int, int, int, int)] Call
POP D4
STORE D2 0.0005
LOAD D2 0.0008
STORE D2 0.0004
SETV D2 16
STORE D2 0.0003; if() #449 Body End
PUSHR D4
CALLFUNC 0.0801; UsrFunc[void NoAction()] Call
POP D4; if() #448 Body End
LOAD D2 0.0004; if() #450 Test
COMPAREV D2 0
SETCMP D2 I>
COMPAREV D2 0
GOTOCMP 144 ==; Test 'if'
LOAD D2 0.0002; if() #450 Body Start
PUSHR D2
PUSHR D4
PUSHV 3; UsrFunc[int VectorX(int, int)] Params Start
LOAD D2 0.0005
PUSHR D2; UsrFunc[int VectorX(int, int)] Params End
CALLFUNC 0.0847; UsrFunc[int VectorX(int, int)] Call
POP D4
POP D3
ADDR D2 D3
STORE D2 0.0002
LOAD D2 0.0001
PUSHR D2
PUSHR D4
PUSHV 3; UsrFunc[int VectorY(int, int)] Params Start
LOAD D2 0.0005
PUSHR D2; UsrFunc[int VectorY(int, int)] Params End
CALLFUNC 0.0857; UsrFunc[int VectorY(int, int)] Call
POP D4
POP D3
ADDR D2 D3
STORE D2 0.0001
LOAD D2 0.0004
SUBV D2 1
STORE D2 0.0004; if() #450 Body End
LOAD D2 0.0002; InlineFunc[int Abs(int)] Params AND if() #451 Test
ABS D2; InlineFunc[int Abs(int)] Body
COMPAREV D2 0
SETCMP D2 I>
COMPAREV D2 0
GOTOCMP 268 ==; Test 'if'
STOREV 0 0; for() #160 setup AND if() #451 Body Start
LOAD D2 0; for() #160 LoopTest
COMPAREV D2 4
GOTOCMP 159 >=
LOAD D2 0.0002
COMPAREV D2 -1
GOTOCMP 159 >
SETV D2 1
GOTO 160
SETV D2 0
COMPAREV D2 0
GOTOCMP 209 ==; for() #160 TestFail?
PUSHR D4; if() #160 Test AND for() #160 Body Start
PUSHR LINKX; UsrFunc[bool CanWalk(int, int, int, int, bool)] Params Start
PUSHR LINKY
PUSHV 2
PUSHV 1
PUSHV 0; UsrFunc[bool CanWalk(int, int, int, int, bool)] Params End
CALLFUNC 0.0474; UsrFunc[bool CanWalk(int, int, int, int, bool)] Call
POP D4
COMPAREV D2 0
GOTOCMP 181 ==; Test 'if'
SETR D2 LINKX; if() #160 Body Start
SUBV D2 1
PUSHR D2
POP D2
SETR LINKX D2
LOAD D2 0.0002
ADDV D2 1
STORE D2 0.0002
GOTO 205; if() #160 Body End
LOAD D2 0.0001; InlineFunc[int Abs(int)] Params AND if() #452 Test AND if() #160 Else Start
ABS D2; InlineFunc[int Abs(int)] Body
COMPAREV D2 0
SETCMP D2 I>
COMPAREV D2 0
GOTOCMP 203 ==; Test 'if'
LOAD D2 0.0001; if() #452 Body Start
PUSHR D2
PUSHR D4
LOAD D2 0.0001; UsrFunc[int Sign(int)] Params Start
PUSHR D2; UsrFunc[int Sign(int)] Params End
CALLFUNC 0.0867; UsrFunc[int Sign(int)] Call
POP D4
PUSHR D2
LOAD D2 0.0002; InlineFunc[int Abs(int)] Params Start
DIVV D2 2; InlineFunc[int Abs(int)] Params End
ABS D2; InlineFunc[int Abs(int)] Body
POP D3
MULTR D2 D3
POP D3
ADDR D2 D3
STORE D2 0.0001; if() #452 Body End
SETV D2 0
STORE D2 0.0002; if() #160 Else End
LOAD D2 0; for() #160 Body End AND for() #160 LoopIncrement
ADDV D2 1
STORE D2 0
GOTO 151; for() #160 End
STOREV 0 0; for() #161 setup
LOAD D2 0; for() #161 LoopTest
COMPAREV D2 4
GOTOCMP 218 >=
LOAD D2 0.0002
COMPAREV D2 1
GOTOCMP 218 <
SETV D2 1
GOTO 219
SETV D2 0
COMPAREV D2 0
GOTOCMP 268 ==; for() #161 TestFail?
PUSHR D4; if() #161 Test AND for() #161 Body Start
PUSHR LINKX; UsrFunc[bool CanWalk(int, int, int, int, bool)] Params Start
PUSHR LINKY
PUSHV 3
PUSHV 1
PUSHV 0; UsrFunc[bool CanWalk(int, int, int, int, bool)] Params End
CALLFUNC 0.0474; UsrFunc[bool CanWalk(int, int, int, int, bool)] Call
POP D4
COMPAREV D2 0
GOTOCMP 240 ==; Test 'if'
SETR D2 LINKX; if() #161 Body Start
ADDV D2 1
PUSHR D2
POP D2
SETR LINKX D2
LOAD D2 0.0002
SUBV D2 1
STORE D2 0.0002
GOTO 264; if() #161 Body End
LOAD D2 0.0001; InlineFunc[int Abs(int)] Params AND if() #453 Test AND if() #161 Else Start
ABS D2; InlineFunc[int Abs(int)] Body
COMPAREV D2 0
SETCMP D2 I>
COMPAREV D2 0
GOTOCMP 262 ==; Test 'if'
LOAD D2 0.0001; if() #453 Body Start
PUSHR D2
PUSHR D4
LOAD D2 0.0001; UsrFunc[int Sign(int)] Params Start
PUSHR D2; UsrFunc[int Sign(int)] Params End
CALLFUNC 0.0867; UsrFunc[int Sign(int)] Call
POP D4
PUSHR D2
LOAD D2 0.0002; InlineFunc[int Abs(int)] Params Start
DIVV D2 2; InlineFunc[int Abs(int)] Params End
ABS D2; InlineFunc[int Abs(int)] Body
POP D3
MULTR D2 D3
POP D3
ADDR D2 D3
STORE D2 0.0001; if() #453 Body End
SETV D2 0
STORE D2 0.0002; if() #161 Else End
LOAD D2 0; for() #161 Body End AND for() #161 LoopIncrement
ADDV D2 1
STORE D2 0
GOTO 210; for() #161 End
LOAD D2 0.0001; if() #451 Body End AND InlineFunc[int Abs(int)] Params AND if() #454 Test
ABS D2; InlineFunc[int Abs(int)] Body
COMPAREV D2 0
SETCMP D2 I>
COMPAREV D2 0
GOTOCMP 391 ==; Test 'if'
STOREV 0 0; for() #162 setup AND if() #454 Body Start
LOAD D2 0; for() #162 LoopTest
COMPAREV D2 4
GOTOCMP 283 >=
LOAD D2 0.0001
COMPAREV D2 -1
GOTOCMP 283 >
SETV D2 1
GOTO 284
SETV D2 0
COMPAREV D2 0
GOTOCMP 333 ==; for() #162 TestFail?
PUSHR D4; if() #162 Test AND for() #162 Body Start
PUSHR LINKX; UsrFunc[bool CanWalk(int, int, int, int, bool)] Params Start
PUSHR LINKY
PUSHV 0
PUSHV 1
PUSHV 0; UsrFunc[bool CanWalk(int, int, int, int, bool)] Params End
CALLFUNC 0.0474; UsrFunc[bool CanWalk(int, int, int, int, bool)] Call
POP D4
COMPAREV D2 0
GOTOCMP 305 ==; Test 'if'
SETR D2 LINKY; if() #162 Body Start
SUBV D2 1
PUSHR D2
POP D2
SETR LINKY D2
LOAD D2 0.0001
ADDV D2 1
STORE D2 0.0001
GOTO 329; if() #162 Body End
LOAD D2 0.0002; InlineFunc[int Abs(int)] Params AND if() #455 Test AND if() #162 Else Start
ABS D2; InlineFunc[int Abs(int)] Body
COMPAREV D2 0
SETCMP D2 I>
COMPAREV D2 0
GOTOCMP 327 ==; Test 'if'
LOAD D2 0.0002; if() #455 Body Start
PUSHR D2
PUSHR D4
LOAD D2 0.0002; UsrFunc[int Sign(int)] Params Start
PUSHR D2; UsrFunc[int Sign(int)] Params End
CALLFUNC 0.0867; UsrFunc[int Sign(int)] Call
POP D4
PUSHR D2
LOAD D2 0.0001; InlineFunc[int Abs(int)] Params Start
DIVV D2 2; InlineFunc[int Abs(int)] Params End
ABS D2; InlineFunc[int Abs(int)] Body
POP D3
MULTR D2 D3
POP D3
ADDR D2 D3
STORE D2 0.0002; if() #455 Body End
SETV D2 0
STORE D2 0.0001; if() #162 Else End
LOAD D2 0; for() #162 Body End AND for() #162 LoopIncrement
ADDV D2 1
STORE D2 0
GOTO 275; for() #162 End
STOREV 0 0; for() #163 setup
LOAD D2 0; for() #163 LoopTest
COMPAREV D2 4
GOTOCMP 342 >=
LOAD D2 0.0001
COMPAREV D2 1
GOTOCMP 342 <
SETV D2 1
GOTO 343
SETV D2 0
COMPAREV D2 0
GOTOCMP 391 ==; for() #163 TestFail?
PUSHR D4; if() #163 Test AND for() #163 Body Start
PUSHR LINKX; UsrFunc[bool CanWalk(int, int, int, int, bool)] Params Start
PUSHR LINKY
PUSHARGSV 1 0.0002
PUSHV 0; UsrFunc[bool CanWalk(int, int, int, int, bool)] Params End
CALLFUNC 0.0474; UsrFunc[bool CanWalk(int, int, int, int, bool)] Call
POP D4
COMPAREV D2 0
GOTOCMP 363 ==; Test 'if'
SETR D2 LINKY; if() #163 Body Start
ADDV D2 1
PUSHR D2
POP D2
SETR LINKY D2
LOAD D2 0.0001
SUBV D2 1
STORE D2 0.0001
GOTO 387; if() #163 Body End
LOAD D2 0.0002; InlineFunc[int Abs(int)] Params AND if() #456 Test AND if() #163 Else Start
ABS D2; InlineFunc[int Abs(int)] Body
COMPAREV D2 0
SETCMP D2 I>
COMPAREV D2 0
GOTOCMP 385 ==; Test 'if'
LOAD D2 0.0002; if() #456 Body Start
PUSHR D2
PUSHR D4
LOAD D2 0.0002; UsrFunc[int Sign(int)] Params Start
PUSHR D2; UsrFunc[int Sign(int)] Params End
CALLFUNC 0.0867; UsrFunc[int Sign(int)] Call
POP D4
PUSHR D2
LOAD D2 0.0001; InlineFunc[int Abs(int)] Params Start
DIVV D2 2; InlineFunc[int Abs(int)] Params End
ABS D2; InlineFunc[int Abs(int)] Body
POP D3
MULTR D2 D3
POP D3
ADDR D2 D3
STORE D2 0.0002; if() #456 Body End
SETV D2 0
STORE D2 0.0001; if() #163 Else End
LOAD D2 0; for() #163 Body End AND for() #163 LoopIncrement
ADDV D2 1
STORE D2 0
GOTO 334; for() #163 End
LOAD D2 0.0003; if() #454 Body End AND if() #457 Test
COMPAREV D2 0
SETCMP D2 I>
COMPAREV D2 0
GOTOCMP 399 ==; Test 'if'
LOAD D2 0.0003; if() #457 Body Start
SUBV D2 1
STORE D2 0.0003; if() #457 Body End
LOAD D2 0.0006
PUSHR D2
LOAD D2 0.0003; InlineFunc[int Floor(int)] Params Start
DIVV D2 4; InlineFunc[int Floor(int)] Params End
FLOOR D2; InlineFunc[int Floor(int)] Body
POP D3
ADDR D2 D3
PUSHR D2
LOAD D2 0.0007
POP D3
PUSHR D2
PUSHR D3
POP D2
POP REFFFC
SETR DATA D2
WAITFRAME; InlineFunc[void Waitframe()] Body AND while(true) #2 Body [Opt:AlwaysOn] End
GOTO 30; while() #2 End AND [Opt:NeverRet] AND void run(int) Body End
SETR D4 SP2; Func[int DirNormal(int)] Body Start
LOAD D2 0; switch() #15 Key
SETR SWITCHKEY D2; Store key
COMPAREV SWITCHKEY 8
GOTOCMP 436 ==; case '80000'
COMPAREV SWITCHKEY 9
GOTOCMP 438 ==; case '90000'
COMPAREV SWITCHKEY 10
GOTOCMP 440 ==; case '100000'
COMPAREV SWITCHKEY 11
GOTOCMP 442 ==; case '110000'
COMPAREV SWITCHKEY 12
GOTOCMP 444 ==; case '120000'
COMPAREV SWITCHKEY 13
GOTOCMP 446 ==; case '130000'
COMPAREV SWITCHKEY 14
GOTOCMP 448 ==; case '140000'
COMPAREV SWITCHKEY 15
GOTOCMP 450 ==; case '150000'
GOTO 452; switch() #15 NoMatch
SETV D2 0; Case block AND return Start
GOTO 453; return End
SETV D2 5; Case block AND return Start
GOTO 453; return End
SETV D2 3; Case block AND return Start
GOTO 453; return End
SETV D2 7; Case block AND return Start
GOTO 453; return End
SETV D2 1; Case block AND return Start
GOTO 453; return End
SETV D2 6; Case block AND return Start
GOTO 453; return End
SETV D2 2; Case block AND return Start
GOTO 453; return End
SETV D2 4; Case block AND return Start
GOTO 453; return End
LOAD D2 0; Case block AND return Start
POP D5; return End
RETURNFUNC; Func[int DirNormal(int)] Body End
SETR D4 SP2; Func[int Angle(int, int, int, int)] Body Start
LOAD D2 0.0001; InlineFunc[int ArcTan(int, int)] Params Start AND InlineFunc[int RadtoDeg(int)] Params Start AND return Start
PUSHR D2
LOAD D2 0.0003
POP D3
SUBR D3 D2
PUSHR D3
LOAD D2 0
PUSHR D2
LOAD D2 0.0002
POP D3
SUBR D3 D2
SETR D1 D3; InlineFunc[int ArcTan(int, int)] Params End
POP D0; InlineFunc[int ArcTan(int, int)] Body Start
ARCTANR D2; InlineFunc[int ArcTan(int, int)] Body End
SETR D3 D2; InlineFunc[int RadtoDeg(int)] Params End
RADTODEG D2 D3; InlineFunc[int RadtoDeg(int)] Body
POPARGS D5 0.0004; return End
RETURNFUNC; Func[int Angle(int, int, int, int)] Body End
PUSHARGSV 0 0.0004; Func[bool CanWalk(int, int, int, int, bool)] Body Start
SETR D4 SP2
STOREV 8 0.0003
LOAD D2 0.0008
ADDV D2 15
STORE D2 0.0002
LOAD D2 0.0007
ADDV D2 15
STORE D2 0.0001
LOAD D2 0.0004; if() #29 Test
COMPAREV D2 0
GOTOCMP 488 ==; Test 'if'
SETV D2 0; if() #29 Body Start
STORE D2 0.0003; if() #29 Body End
PUSHR D4; switch() #4 Key
LOAD D2 0.0006; UsrFunc[int DirNormal(int)] Params Start
PUSHR D2; UsrFunc[int DirNormal(int)] Params End
CALLFUNC 0.0416; UsrFunc[int DirNormal(int)] Call
POP D4
SETR SWITCHKEY D2; Store key
COMPAREV SWITCHKEY 0
GOTOCMP 503 ==; case '0'
COMPAREV SWITCHKEY 1
GOTOCMP 566 ==; case '10000'
COMPAREV SWITCHKEY 2
GOTOCMP 616 ==; case '20000'
COMPAREV SWITCHKEY 3
GOTOCMP 675 ==; case '30000'
GOTO 733; switch() #4 NoMatch
LOAD D2 0.0007; Case block AND return Start
PUSHR D2
LOAD D2 0.0005
POP D3
SUBR D3 D2
SETR D2 D3
COMPAREV D2 0
GOTOCMP 562 <
LOAD D2 0.0008; InlineFunc[bool screendata::isSolid(int, int)] Params Start
PUSHR D2
LOAD D2 0.0007
PUSHR D2
LOAD D2 0.0003
POP D3
ADDR D2 D3
PUSHR D2
LOAD D2 0.0005
POP D3
SUBR D3 D2
SETR D1 D3; InlineFunc[bool screendata::isSolid(int, int)] Params End
POP D0; InlineFunc[bool screendata::isSolid(int, int)] Body Start
ISSOLID D2; InlineFunc[bool screendata::isSolid(int, int)] Body End
COMPAREV D2 0
GOTOCMP 562 !=
LOAD D2 0.0008; InlineFunc[bool screendata::isSolid(int, int)] Params Start
ADDV D2 8
PUSHR D2
LOAD D2 0.0007
PUSHR D2
LOAD D2 0.0003
POP D3
ADDR D2 D3
PUSHR D2
LOAD D2 0.0005
POP D3
SUBR D3 D2
SETR D1 D3; InlineFunc[bool screendata::isSolid(int, int)] Params End
POP D0; InlineFunc[bool screendata::isSolid(int, int)] Body Start
ISSOLID D2; InlineFunc[bool screendata::isSolid(int, int)] Body End
COMPAREV D2 0
GOTOCMP 562 !=
LOAD D2 0.0002; InlineFunc[bool screendata::isSolid(int, int)] Params Start
PUSHR D2
LOAD D2 0.0007
PUSHR D2
LOAD D2 0.0003
POP D3
ADDR D2 D3
PUSHR D2
LOAD D2 0.0005
POP D3
SUBR D3 D2
SETR D1 D3; InlineFunc[bool screendata::isSolid(int, int)] Params End
POP D0; InlineFunc[bool screendata::isSolid(int, int)] Body Start
ISSOLID D2; InlineFunc[bool screendata::isSolid(int, int)] Body End
COMPAREV D2 0
GOTOCMP 562 !=
SETV D2 0
GOTO 563
SETV D2 1
COMPAREV D2 0
SETCMP D2 I==
GOTO 745; return End
LOAD D2 0.0001; Case block AND return Start
PUSHR D2
LOAD D2 0.0005
POP D3
ADDR D2 D3
COMPAREV D2 176
GOTOCMP 612 >=
LOAD D2 0.0008; InlineFunc[bool screendata::isSolid(int, int)] Params Start
PUSHR D2
LOAD D2 0.0001
PUSHR D2
LOAD D2 0.0005
POP D3
ADDR D2 D3
SETR D1 D2; InlineFunc[bool screendata::isSolid(int, int)] Params End
POP D0; InlineFunc[bool screendata::isSolid(int, int)] Body Start
ISSOLID D2; InlineFunc[bool screendata::isSolid(int, int)] Body End
COMPAREV D2 0
GOTOCMP 612 !=
LOAD D2 0.0008; InlineFunc[bool screendata::isSolid(int, int)] Params Start
ADDV D2 8
PUSHR D2
LOAD D2 0.0001
PUSHR D2
LOAD D2 0.0005
POP D3
ADDR D2 D3
SETR D1 D2; InlineFunc[bool screendata::isSolid(int, int)] Params End
POP D0; InlineFunc[bool screendata::isSolid(int, int)] Body Start
ISSOLID D2; InlineFunc[bool screendata::isSolid(int, int)] Body End
COMPAREV D2 0
GOTOCMP 612 !=
LOAD D2 0.0002; InlineFunc[bool screendata::isSolid(int, int)] Params Start
PUSHR D2
LOAD D2 0.0001
PUSHR D2
LOAD D2 0.0005
POP D3
ADDR D2 D3
SETR D1 D2; InlineFunc[bool screendata::isSolid(int, int)] Params End
POP D0; InlineFunc[bool screendata::isSolid(int, int)] Body Start
ISSOLID D2; InlineFunc[bool screendata::isSolid(int, int)] Body End
COMPAREV D2 0
GOTOCMP 612 !=
SETV D2 0
GOTO 613
SETV D2 1
COMPAREV D2 0
SETCMP D2 I==
GOTO 745; return End
LOAD D2 0.0008; Case block AND return Start
PUSHR D2
LOAD D2 0.0005
POP D3
SUBR D3 D2
SETR D2 D3
COMPAREV D2 0
GOTOCMP 671 <
LOAD D2 0.0008; InlineFunc[bool screendata::isSolid(int, int)] Params Start
PUSHR D2
LOAD D2 0.0005
POP D3
SUBR D3 D2
PUSHR D3
LOAD D2 0.0007
PUSHR D2
LOAD D2 0.0003
POP D3
ADDR D2 D3
SETR D1 D2; InlineFunc[bool screendata::isSolid(int, int)] Params End
POP D0; InlineFunc[bool screendata::isSolid(int, int)] Body Start
ISSOLID D2; InlineFunc[bool screendata::isSolid(int, int)] Body End
COMPAREV D2 0
GOTOCMP 671 !=
LOAD D2 0.0008; InlineFunc[bool screendata::isSolid(int, int)] Params Start
PUSHR D2
LOAD D2 0.0005
POP D3
SUBR D3 D2
PUSHR D3
LOAD D2 0.0007
PUSHR D2
LOAD D2 0.0003
POP D3
ADDR D2 D3
ADDV D2 7
SETR D1 D2; InlineFunc[bool screendata::isSolid(int, int)] Params End
POP D0; InlineFunc[bool screendata::isSolid(int, int)] Body Start
ISSOLID D2; InlineFunc[bool screendata::isSolid(int, int)] Body End
COMPAREV D2 0
GOTOCMP 671 !=
LOAD D2 0.0008; InlineFunc[bool screendata::isSolid(int, int)] Params Start
PUSHR D2
LOAD D2 0.0005
POP D3
SUBR D3 D2
PUSHR D3
LOAD D2 0.0001
SETR D1 D2; InlineFunc[bool screendata::isSolid(int, int)] Params End
POP D0; InlineFunc[bool screendata::isSolid(int, int)] Body Start
ISSOLID D2; InlineFunc[bool screendata::isSolid(int, int)] Body End
COMPAREV D2 0
GOTOCMP 671 !=
SETV D2 0
GOTO 672
SETV D2 1
COMPAREV D2 0
SETCMP D2 I==
GOTO 745; return End
LOAD D2 0.0002; Case block AND return Start
PUSHR D2
LOAD D2 0.0005
POP D3
ADDR D2 D3
COMPAREV D2 256
GOTOCMP 729 >=
LOAD D2 0.0002; InlineFunc[bool screendata::isSolid(int, int)] Params Start
PUSHR D2
LOAD D2 0.0005
POP D3
ADDR D2 D3
PUSHR D2
LOAD D2 0.0007
PUSHR D2
LOAD D2 0.0003
POP D3
ADDR D2 D3
SETR D1 D2; InlineFunc[bool screendata::isSolid(int, int)] Params End
POP D0; InlineFunc[bool screendata::isSolid(int, int)] Body Start
ISSOLID D2; InlineFunc[bool screendata::isSolid(int, int)] Body End
COMPAREV D2 0
GOTOCMP 729 !=
LOAD D2 0.0002; InlineFunc[bool screendata::isSolid(int, int)] Params Start
PUSHR D2
LOAD D2 0.0005
POP D3
ADDR D2 D3
PUSHR D2
LOAD D2 0.0007
PUSHR D2
LOAD D2 0.0003
POP D3
ADDR D2 D3
ADDV D2 7
SETR D1 D2; InlineFunc[bool screendata::isSolid(int, int)] Params End
POP D0; InlineFunc[bool screendata::isSolid(int, int)] Body Start
ISSOLID D2; InlineFunc[bool screendata::isSolid(int, int)] Body End
COMPAREV D2 0
GOTOCMP 729 !=
LOAD D2 0.0002; InlineFunc[bool screendata::isSolid(int, int)] Params Start
PUSHR D2
LOAD D2 0.0005
POP D3
ADDR D2 D3
PUSHR D2
LOAD D2 0.0001
SETR D1 D2; InlineFunc[bool screendata::isSolid(int, int)] Params End
POP D0; InlineFunc[bool screendata::isSolid(int, int)] Body Start
ISSOLID D2; InlineFunc[bool screendata::isSolid(int, int)] Body End
COMPAREV D2 0
GOTOCMP 729 !=
SETV D2 0
GOTO 730
SETV D2 1
COMPAREV D2 0
SETCMP D2 I==
GOTO 745; return End
ALLOCATEMEMV D2 60 0; Case block
STORE D2 0
WRITEPODSTRING D2 "Invalid direction %d passed to CanWalk(x,y,dir,step,bool) \n"
LOAD D2 0; InlineFunc[void printf(char32[])] Params Start
PUSHR D2
LOAD D2 0.0006
PUSHVARGR D2; InlineFunc[void printf(char32[])] Params End
PRINTFVARG; InlineFunc[void printf(char32[])] Body Start
POP D5; InlineFunc[void printf(char32[])] Body End
LOAD D3 0
DEALLOCATEMEMR D3
SETV D2 0; return Start
POPARGS D5 0.0009; return End
RETURNFUNC; Func[bool CanWalk(int, int, int, int, bool)] Body End
SETR D4 SP2; Func[int CenterLinkX()] Body Start
SETR D2 LINKX; return Start
ADDV D2 8
RETURNFUNC; return End AND Func[int CenterLinkX()] Body End
SETR D4 SP2; Func[int CenterLinkY()] Body Start
SETR D2 LINKY; return Start
ADDV D2 8
RETURNFUNC; return End AND Func[int CenterLinkY()] Body End
SETR D4 SP2; Func[int CenterX(ffc)] Body Start
LOAD D2 0; return Start
PUSHR D2
POP REFFFC
SETR D2 X
PUSHR D2
LOAD D2 0
PUSHR D2
POP REFFFC
SETR D2 FFTWIDTH
MULTV D2 8
SETV D2 8
PUSHR D2
LOAD D2 0
PUSHR D2
POP REFFFC
SETR D2 FFTWIDTH
POP D3
MULTR D2 D3
POP D3
ADDR D2 D3
POP D5; return End
RETURNFUNC; Func[int CenterX(ffc)] Body End
SETR D4 SP2; Func[int CenterY(ffc)] Body Start
LOAD D2 0; return Start
PUSHR D2
POP REFFFC
SETR D2 Y
PUSHR D2
LOAD D2 0
PUSHR D2
POP REFFFC
SETR D2 FFTHEIGHT
MULTV D2 8
SETV D2 8
PUSHR D2
LOAD D2 0
PUSHR D2
POP REFFFC
SETR D2 FFTHEIGHT
POP D3
MULTR D2 D3
POP D3
ADDR D2 D3
POP D5; return End
RETURNFUNC; Func[int CenterY(ffc)] Body End
PUSHV 0; Func[void NoAction()] Body Start
SETR D4 SP2
STOREV 0 0; for() #74 setup
LOAD D2 0; for() #74 LoopTest
COMPAREV D2 14
SETCMP D2 I<
COMPAREV D2 0
GOTOCMP 845 ==; for() #74 TestFail?
LOAD D2 0; if() #249 Test AND for() #74 Body Start
COMPAREV D2 9
GOTOCMP 815 !=
GOTO 815
SETV D2 1
GOTO 816
SETV D2 0
COMPAREV D2 0
GOTOCMP 841 !=; Test 'if' AND continue 1; AND if() #249 Body
LOAD D2 0; if() #250 Test
COMPAREV D2 6
GOTOCMP 824 !=
GOTO 824
SETV D2 1
GOTO 825
SETV D2 0
COMPAREV D2 0
GOTOCMP 841 !=; Test 'if' AND continue 1; AND if() #250 Body
SETV D2 0
PUSHR D2
LOAD D2 0
PUSHR D2
POP D0
POP D2
SETR BUTTONINPUT D2
SETV D2 0
PUSHR D2
LOAD D2 0
PUSHR D2
POP D0
POP D2
SETR BUTTONPRESS D2; for() #74 Body End
LOAD D2 0; for() #74 LoopIncrement
ADDV D2 1
STORE D2 0
GOTO 804; for() #74 End
POP D5
RETURNFUNC; Func[void NoAction()] Body End
SETR D4 SP2; Func[int VectorX(int, int)] Body Start
LOAD D2 0; InlineFunc[int Cos(int)] Params Start AND return Start
SETR D3 D2; InlineFunc[int Cos(int)] Params End
COSR D2 D3; InlineFunc[int Cos(int)] Body
PUSHR D2
LOAD D2 0.0001
POP D3
MULTR D2 D3
POPARGS D5 0.0002; return End
RETURNFUNC; Func[int VectorX(int, int)] Body End
SETR D4 SP2; Func[int VectorY(int, int)] Body Start
LOAD D2 0; InlineFunc[int Sin(int)] Params Start AND return Start
SETR D3 D2; InlineFunc[int Sin(int)] Params End
SINR D2 D3; InlineFunc[int Sin(int)] Body
PUSHR D2
LOAD D2 0.0001
POP D3
MULTR D2 D3
POPARGS D5 0.0002; return End
RETURNFUNC; Func[int VectorY(int, int)] Body End
SETR D4 SP2; Func[int Sign(int)] Body Start
LOAD D2 0; if() #123 Test
COMPAREV D2 0
SETCMP D2 I>
COMPAREV D2 0
GOTOCMP 875 ==; Test 'if'
SETV D2 1; return Start AND if() #123 Body Start
GOTO 883; return End AND if() #123 Body End
LOAD D2 0; if() #124 Test AND if() #123 Else Start
COMPAREV D2 0
SETCMP D2 I<
COMPAREV D2 0
GOTOCMP 882 ==; Test 'if'
SETV D2 -1; return Start AND if() #124 Body Start
GOTO 883; return End AND if() #124 Body End
SETV D2 0; return Start AND if() #124 Else Start
POP D5; return End AND if() #124 Else End AND if() #123 Else End
RETURNFUNC; Func[int Sign(int)] Body End