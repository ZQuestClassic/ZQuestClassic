//New FUNCTIONS. Requires other std.zh update files, std_constants_2.50.2.zh, and std.cfg
//05-JULY-2016 Standalone File


//Returns true if Link is on a Dungeon (flagged) screen
bool IsDungeonFlag() {
	return Screen->Flags[SF_ROOMTYPE] & 1;
}

//Returns true if Link is on an Interior (flagged) screen
bool IsInteriorFlag() {
	return Screen->Flags[SF_ROOMTYPE] & 2;
}

//Layer 0 is the screen itself.
int GetLayerComboI(int layer, int pos) {
	if (layer==0) return Screen->ComboI[pos];
	else return Game->GetComboInherentFlag(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos);
}

//A shorthand way to set a combo inherent flag on the current layer.
//Layer 0 is the screen itself.
void SetLayerComboI(int layer, int pos, int flag) {
	if (layer == 0) Screen->ComboI[pos] = flag;
	else Game->SetComboInherentFlag(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, flag);
}

//A shorthand way to get a combo CSet on the current layer.
//Layer 0 is the screen itself.
int GetLayerComboC(int layer, int pos) {
	if (layer==0) return Screen->ComboC[pos];
	else return Game->GetComboCSet(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos);
}

//A shorthand way to set a combo CSet on the current layer.
//Layer 0 is the screen itself.
void SetLayerComboC(int layer, int pos, int cset) {
	if (layer == 0) Screen->ComboC[pos] = cset;
	else Game->SetComboCSet(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, cset);
}



//Fairly select between true or false.
int ChooseB(){
	return Rand(0,1);
}

// Chooses one of the boolean options randomly and fairly.
bool ChooseB(bool a, bool b) {
	if (Rand(0,1)==0) return a;
	else return b;
}

bool ChooseB(bool a, bool b, bool c) {
	int r = Rand(0,2);
	if (r==0) return a;
	else if (r==1) return b;
	else return c;
}

bool ChooseB(bool a, bool b, bool c, bool d) {
	int r = Rand(0,3);
	if (r==0) return a;
	else if (r==1) return b;
	else if (r==2) return c;
	else return d;
}

bool ChooseB(bool a, bool b, bool c, bool d, bool e) {
	int r = Rand(0,4);
	if (r==0) return a;
	else if (r==1) return b;
	else if (r==2) return c;
	else if (r==3) return d;
	else return e;
}

bool ChooseB(bool a, bool b, bool c, bool d, bool e, bool f) {
	int r = Rand(0,5);
	if (r==0) return a;
	else if (r==1) return b;
	else if (r==2) return c;
	else if (r==3) return d;
	else if (r==4) return e;
	else return f;
}





//Randomly returns true, or false. 
bool RandB(){
	int a = Rand(0,1);
	if ( a == 0 ) return false;
	else return true;
}


//Randomly returns true, or false, using input percentTrue to determine the percentage change of a 'true return'
bool RandB(int percentTrue){
	int a = Rand(1,100);
	if ( a <= percentTrue ) return true;
	else return false;
}



//Safe Sqrt functions if an irrational number would be involved.
//Returns '464' (square root of 215296), if the value passed is negative. 
//Returns '0' on Sqrt(0).
float SafeSqrt(float val){
	
	if ( STD_NEVER_USE_SAFESQRT ) return Sqrt(val);
	else {
		//if ( val > 214748.3648 ) val = 214748.3648;
		if ( val > 0 && val <= 214747.9999 ) return Sqrt(val);
		//Return a predesignated square root, instead of performing a Sqrt(MAX_INT) would be more optimised. 
		if ( val < 0 ) return 464; 	//! This is the smallest integer square root value possible 
						//! that is greater than the square root of MAX_INT.
						//! and would help identify errors.
		//if ( val < 0 ) return 463.4095; //The square root of 214798.3648
		//! We could also returm 363 here, which is the smallest square root over MAX_INT.
		//Returns the square root of MAX_INT if the value passed is a negative number. 
		//if ( val < 0 ) return Sqrt(214747.9999);
		return 0;
	}
}



//Returns square root of 'val'. Returns 'specifyNegRet' if a negative value is passed as 'val'. Returns '0' for Sqrt(0).
float SafeSqrt(float val, float specifyNegRet){
	if ( val > 214747.9999 ) val = 214747.9999;
	if ( val > 0 && val <= 214747.9999 ) return Sqrt(val);
	if ( val < 0 ) return specifyNegRet;
	return 0;
}


//Safely sets an equipment item, without lagging ZC. 
//Sets an item 'itm' true if it is false, and false if it is true.
void SetLinkItem(int itm){
	unless ( Link->Item[itm] ) Link->Item[itm] = true;
	else if ( Link->Item[itm] ) Link->Item[itm] = false;
}

//Sets an item 'itm' to the boolean value of 'state'.
void SetLinkItem(int itm, bool state){
	if ( !Link->Item[itm] && state ) Link->Item[itm] = true;
	else if ( Link->Item[itm] && !state ) Link->Item[itm] = false;
}




//Trace the indices of an array, with a space between each. max 20 per line. 
//NOT overloaded to accept all array types. Trace() does nto work on ffc, item, itemdata, lweapon, or eweapon!
//Mayne next version. 
void TraceArray(int arr){
	TraceNL();
	for ( int q = 0; q < SizeOfArray(arr); q++ ) {
		Trace(arr[q]); TraceS(" ");
		if ( q % 10 == 0 ) TraceNL();
	}
}

//Trace the indices of a Boolean array, with a space between each. max 20 per line. 
void TraceArrayB(bool arr, int size){
	TraceNL();
	for ( int q = 0; q < size; q++ ) {
		TraceB(arr[q]); TraceS(" ");
		if ( q % 10 == 0 ) TraceNL();
	}
}

void TraceArray(int arr, bool verbose){
	if ( verbose ) 	{
		TraceNL(); TraceS("Tracing array with Pointer: "); Trace(arr); TraceNL();

		for ( int q = 0; q < SizeOfArray(arr); q++ ) {
			TraceS("Index: "); Trace(q); TraceS("is : "); Trace(arr[q]);
			TraceNL();
		}
	}
	else {
		TraceNL();
		for ( int q = 0; q < SizeOfArray(arr); q++ ) {
			Trace(arr[q]); TraceS(" ");
			if ( q % 10 == 0 ) TraceNL();
		}
	}
}

//Trace the indices of a Boolean array, allows verbose logging.
void TraceArrayB(bool arr, int size, bool verbose){
	if ( verbose ) {
		//ZScript has no facility to read a pointer ID of an array with a type of bool, ffc, item, *weapon, or itemdata.
		TraceNL(); TraceS("Tracing Boolean Array: "); TraceNL();
		
		for ( int q = 0; q < size; q++ ) {
			TraceS("Index: "); Trace(q); TraceS("is : "); TraceB(arr[q]); TraceS(" ");
			TraceNL();
		}
	}
	else {
		TraceNL();
		for ( int q = 0; q < size; q++ ) {
			TraceB(arr[q]); TraceS(" ");
			if ( q % 10 == 0 ) TraceNL();
		}	
	}
}


//Shorthand for TraceArray()
void TraceA(bool arr,int size){TraceArrayB(arr,size);}
void TraceA(float arr){TraceArray(arr);}
void TraceA(bool arr,int size, bool verbose){TraceArrayB(arr,size,verbose);}
void TraceA(float arr, bool verbose){TraceArray(arr,verbose);}

//Terminate an FFC, and set all its properties to 0. 
void EndFFC(int ffc_id){
	ffc f = Screen->LoadFFC(ffc_id);
	f->Data = 0;
	f->Script = 0;
	f->CSet = 0;
	f->Delay = 0;
	f->X = 0;
	f->Y = 0;
	f->Vx = 0;
	f->Vy = 0;
	f->Ax = 0;
	f->Ay = 0;
	for ( int q = 0; q < 10; q++ ) f->Flags[q] = 0;
	f->TileWidth = 0;
	f->TileHeight = 0;
	f->EffectWidth = 0;
	f->EffectHeight = 0;
	f->Link = 0;
	for ( int q = 0; q < 15; q++ ) f->Misc[q] = 0;
}


//Returns true if the central mouse button (if equipped) is pressed
bool InputMiddleClick() {
	return (Link->InputMouseB&MB_MIDDLECLICK) != 0;
}


//Negates engine knockback for Link on land, or in water.
void NoLinkKnockback(){
	if ( Link->Action == LA_GOTHURTLAND || Link->Action == LA_GOTHURTWATER ) Link->HitDir = -1;
}

//Negates engine knockback for Link only on land.
void NoLinkKnockbackLand(){
	if ( Link->Action == LA_GOTHURTLAND ) Link->HitDir = -1;
}

//Negates engine knockback for Link only in water.
void NoLinkKnockbackWater(){
	if ( Link->Action == LA_GOTHURTWATER ) Link->HitDir = -1;
}


//Convert boolean variable 'input' to floating point, or int.
float BoolToFloat(bool input){
	if ( input ) return 1;
	else return 0;
}

int BoolToInt(bool input) {
	BoolToFloat(input);
}



//Draws a screen specified by 'sourceMap and sourceScreen;, from layers specified by 'layerMin and layerMax', 
//at a desired opacity, to the layer specified by 'destLayer' of the current screen.
void ScreenToLayer(int sourceMap, int sourceScreen, int layerMin, int layerMax, int drawOpacity, int destLayer){
	for (int i = layerMin; i < layerMax; i++){
		Screen->DrawLayer(destLayer, sourceMap, sourceScreen, i, 0, 0, 0, drawOpacity);
	}
}

//Draws all layers of a screen specified by 'sourceMap and sourceScreen;,
//at a desired opacity, to the layer specified by 'destLayer' of the current screen.
void ScreenToLayer(int sourceMap, int sourceScreen, int drawOpacity, int destLayer){
	for (int i = 0; i < 6; i++){
		Screen->DrawLayer(destLayer, sourceMap, sourceScreen, i, 0, 0, 0, drawOpacity);
	}
}


//Takes a float as input 'n', and returns the integer portion as int. 
int GetHighFloat(int n) {
	return n >> 0;
}

//Takes a float as input 'n', and returns the decimal portion as int. 
int GetLowFloat(int n) {
	return (n - (n >> 0)) * 10000;
}

//Converts floating point value 'v', after the decimal, to an integer.
int DecimalToInt(int v) {
	int r = (v - (v << 0)) * 10000;
	return r;
}

//Extracts a single digit from n at the place specified. 
//-4 is the ten-thousandTHs place, 0 is the ones spot, and 4 is the ten-thousanDs spot. 
int GetDigitValue(int n, int place){
	place = Clamp(place, -4, 4);
	if( place < 0 ){
		n = DecimalToInt(n);
		place += 4;
	}

	int r = ((n / Pow(10, place)) % 10) << 0;
	return r;
}

//Extracts an integer using specific places of any value 'n', from position 'place' plus a number of places 'num'.
int GetPartialValue(int n, int place, int num){
	place = Clamp(place, -4, 4);
	int r;
	int adj = 1;
	for(int i = num-1; i > -1; i--){
		if(place - i < -4) continue;
		r += GetDigitValue(n, place - i) * adj;
		adj *= 10;
	}
	return r;
}



//Xor comparison of two boolean values. 
bool Xor(bool valA, bool valB){
	if ( !valA && valB ) return true;
	else if ( valA && !valB ) return true;
	return false;
}

//Xor comparison of two boolean values. 
bool Xor(bool valA, bool valB){
	if ( !valA && valB ) return true;
	else if ( valA && !valB ) return true;
	return false;
}


//Collision functions, to avoid errors when using Collision() where LinkCOllision() is needed. 

bool Collision(ffc f) {
	return LinkCollision(f);
}

bool Collision(npc n){
	return LinkCollision(n);
}

bool Collision(lweapon l){
	return LinkCollision(l);
}

bool Collision(eweapon e){
	return LinkCollision(e);
}

bool Collision(item i){
	return LinkCollision(i);
}

// A very simple layer 0 tile drawing routine.
void DrawTileSimple(int x, int y, int tile, int color) {
	Screen->FastTile(0, x, y, tile, color, 128);
}


//Returns the distance between two sets of coordinates using Pythagoras' Theorem
float Distance(int x1, int y1, int x2, int y2) {
	int x = (x1-x2);
	int y = (y1-y2);
	if ( STD_FORCE_OLD_DISTANCE ) return Sqrt(x*x+y*y);
	else {
		if ( ( x * y ) < 0 ) { 
			
			if ( STD_DISTANCE_USE_SAFESQRT ) return SafeSqrt(x*x+y*y);
			else {
				
				//...or reduce factor by MAX_INT, Sqrt(factor) and add 464?
				//...which way does it roll over?
				//factor = ; 
				int factor =  214747.9999 + (x*y);
				if ( factor > 0 ) return Sqrt(factor) + 464;
				else if ( factor == 0 ) return 464;
				else return Sqrt(214747.9999);
				//else return -1;
				//return Sqrt(( x*y ) * -1) + 464;
			}
		}
	}
		//
}

//Returns the distance between two sets of coordinates using Pythagoras' Theorem
//Allows scaling for large distance determinations.
//Argument 'scale' represents a ratio of 1:scale.
//Argument 'scale' is most precise when using powers of 10 (i.e. 1, 10, 100, 1000, 10000).
//If arg 'scale' is set to 0, it defaults to '1'. 
//Returns -1 on error. 
float Distance(int x1, int y1, int x2, int y2, int scale) {
	if ( scale == 0 ) scale = 1; 
	float x = (x1-x2) / scale;
	float y = (y1-y2) / scale;
	float factor = (x*x)+(y*y);
	if ( factor < 0 ) return -1;
	else return Sqrt(factor) * scale;
}




//Returns the distance between two sets of coordinates using Pythagoras' Theorem
float SafeDistance(int x1, int y1, int x2, int y2) {
	int x; 
	int y;
	if ( x1 > x2 ) x = x1-x2;
	else x = x2 - x1;
	if ( y1 > y2 ) y = y1-y2;
	else y = y2 - y1;
	return Sqrt(x*x+y*y);
}

//Kills inputs from A, B, L, R, Start, Map, and Ex buttons. 
void NoInput(){ 
	Link->InputA = false;
	Link->InputB = false;
	Link->InputL = false;
	Link->InputR = false;
	Link->InputEx1 = false;
	Link->InputEx2 = false;
	Link->InputEx3 = false;
	Link->InputEx4 = false;
	Link->InputStart = false;
	Link->InputMap = false;
}

//Kills presses from A, B, L, R, Start, Map, and Ex buttons. 
void NoPress(){ 
	Link->PressA = false;
	Link->PressB = false;
	Link->PressL = false;
	Link->PressR = false;
	Link->PressEx1 = false;
	Link->PressEx2 = false;
	Link->PressEx3 = false;
	Link->PressEx4 = false;
	Link->PressStart = false;
	Link->PressMap = false;
}

//Kills inputs from A, B, L, R, Start, Map, and Ex buttons. 
void NoInput(bool stick){ 
	Link->InputA = false;
	Link->InputB = false;
	Link->InputL = false;
	Link->InputR = false;
	Link->InputEx1 = false;
	Link->InputEx2 = false;
	Link->InputEx3 = false;
	Link->InputEx4 = false;
	Link->InputStart = false;
	Link->InputMap = false;
	if ( stick ) {
		Link->InputAxisUp = false; 
		Link->InputAxisDown = false; 
		Link->InputAxisLeft = false; 
		Link->InputAxisRight = false; 
	}
}

//Kills presses from A, B, L, R, Start, Map, and Ex buttons. 
void NoPress(bool stick){ 
	Link->PressA = false;
	Link->PressB = false;
	Link->PressL = false;
	Link->PressR = false;
	Link->PressEx1 = false;
	Link->PressEx2 = false;
	Link->PressEx3 = false;
	Link->PressEx4 = false;
	Link->PressStart = false;
	Link->PressMap = false;
	if ( stick ) {
		Link->PressAxisUp = false; 
		Link->PressAxisDown = false; 
		Link->PressAxisLeft = false; 
		Link->PressAxisRight = false; 
	}
}

//Returns a multiplication factor for ->Step based on direction.
// Specifically, return the x component of a line with a length of 1 extending
// in the given direction from origin.
//Step = step * DirX(dir);
//Valid only if dir is 0 to 7.

int DirX(int dir) {
	// Is a diagonal.
	if (dir & 100b) return ((dir & 001b) ? Sin(45) : -Sin(45));
	// Is horizontal.
	if (dir & 010b) return ((dir & 001b) ? 1 : -1);
	return 0;
}

//Returns a multiplication factor for ->Step based on direction.
//Step = step * DirY(dir);
//Valid only if dir is 0 to 7.
// Specifically, return the y component of a line with a length of 1 extending
// in the given direction from origin.
int DirY(int dir) {
	// Is a diagonal.
	if (dir & 100b) return ((dir & 010b) ? Sin(45) : -Sin(45));
	// Is vertical.
	unless ((dir & 010b)) return ((dir & 001b) ? 1 : -1);
	return 0;
}


//Matching - Comparison Functions: use an array (list) of values, and compare against a pointer, or pointer variable. 

//Match a given lweapon to the contents of an array 'list'
//Returns true of any of the entries on the list match. 
bool MatchLWeaponType(int list, lweapon l){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( l->ID == list[q] ) match = true;
	}
	return match;
}

//Match a given eweapon to the contents of an array 'list'
//Returns true of any of the entries on the list match. 
bool MatchEWeaponType(int list, eweapon e){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( e->ID == list[q] ) match = true;
	}
	return match;
}

//Match a given npc ID number to the contents of an array 'list'
//Returns true of any of the entries on the list match. 
bool MatchNPC(int list, npc n){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( n->ID == list[q] ) match = true;
	}
	return match;
}

//Match a given NPC TYPE to the contents of an array 'list'
//Returns true of any of the entries on the list match. 
bool MatchNPCT(int list, npc n){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( n->Type == list[q] ) match = true;
	}
	return match;
}

//Match a given item ID number to the contents of an array 'list'
//Returns true of any of the entries on the list match. 
bool MatchItem(int list, item i){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( i->ID == list[q] ) match = true;
	}
	return match;
}

//Match the present Link->Action to those on array 'list'.
//Returns true of any of the entries on the list match. 
//Checks if the present Link->Action is one from a predefined list.
bool MatchAction(int list){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( Link->Action == list[q] ) match = true;
	}
	return match;
}

//Compares combo 'cmb' and compares it to the values in array 'list'. 
//Returns true of any of the entries on the list match its Data. 
bool MatchComboD(int list, int cmb){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( Screen->ComboD[cmb] == list[q] ) match = true;
	}
	return match;
}

//Compares combo 'cmb' and compares it to the values in array 'list'. 
//Returns true of any of the entries on the list match its Type.
bool MatchComboT(int list, int cmb){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( Screen->ComboT[cmb] == list[q] ) match = true;
	}
	return match;
}

//Compares combo 'cmb' and compares it to the values in array 'list'. 
//Returns true of any of the entries on the list match its CSet.
bool MatchComboC(int list, int cmb){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( Screen->ComboC[cmb] == list[q] ) match = true;
	}
	return match;
}

//Compares combo 'cmb' and compares it to the values in array 'list'. 
//Returns true of any of the entries on the list match its Flag.
bool MatchComboF(int list, int cmb){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( Screen->ComboF[cmb] == list[q] ) match = true;
	}
	return match;
}

//Compares combo 'cmb' and compares it to the values in array 'list'. 
//Returns true of any of the entries on the list match its Inherent Flag.
bool MatchComboI(int list, int cmb){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( Screen->ComboI[cmb] == list[q] ) match = true;
	}
	return match;
}

//Compares combo 'cmb' and compares it to the values in array 'list'. 
//Returns true of any of the entries on the list match its Solidity.
bool MatchComboS(int list, int cmb){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( Screen->ComboS[cmb] == list[q] ) match = true;
	}
	return match;
}

//Compares combo 'cmb' on Layer 'layer' and compares it to the values in array 'list'. 
//Returns true of any of the entries on the list match its Data. 
bool MatchLayerComboD(int list, int layer, int cmb){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( GetLayerComboD(layer,cmb) == list[q] ) match = true;
	}
	return match;
}

//Compares combo 'cmb' on Layer 'layer' and compares it to the values in array 'list'. 
//Returns true of any of the entries on the list match its Type.
bool MatchLayerComboT(int list, int layer, int cmb){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( GetLayerComboT(layer,cmb) == list[q] ) match = true;
	}
	return match;
}

//Compares combo 'cmb' on Layer 'layer' and compares it to the values in array 'list'. 
//Returns true of any of the entries on the list match its CSet.
bool MatchLayerComboC(int list, int layer, int cmb){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( GetLayerComboC(layer,cmb) == list[q] ) match = true;
	}
	return match;
}

//Compares combo 'cmb' on Layer 'layer' and compares it to the values in array 'list'. 
//Returns true of any of the entries on the list match its Flag.
bool MatchLayerComboF(int list, int layer, int cmb){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( GetLayerComboF(layer,cmb) == list[q] ) match = true;
	}
	return match;
}

//Compares combo 'cmb' on Layer 'layer' and compares it to the values in array 'list'. 
//Returns true of any of the entries on the list match its Inherent Flag.
bool MatchLayerComboI(int list, int layer, int cmb){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( GetLayerComboI(layer,cmb) == list[q] ) match = true;
	}
	return match;
}

//Compares combo 'cmb' on Layer 'layer' and compares it to the values in array 'list'. 
//Returns true of any of the entries on the list match its Solidity.
bool MatchLayerComboS(int list, int layer, int cmb){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( GetLayerComboS(layer,cmb) == list[q] ) match = true;
	}
	return match;
}

//Matches a running ffc script to script_id. Returns true if they match.
int MatchScript(int script_id){
	for ( int q = 1; q < 32; q++ ) {
		ffc MatchScript = Screen->LoadFFC(q);
		if ( MatchScript->Script == script_id ) return q;
	}
	return 0;
}

//Compares the scripts of all running ffcs, to all indices of an array 'list' searching for
//a match to ffc script 'script_id'.
//If there is a match, it MatchScript() will return the first match (FFC number) found. 
int MatchScript(int script_id, int list){
	bool match;
	for ( int q = 1; q < 32; q++ ) {
		ffc MatchScript = Screen->LoadFFC(q);
		for ( int w = 0; w < SizeOfArray(list); w++ ) {
			if ( MatchScript->Script == script_id ) return q;
		}
	}
	return 0;
}


//Returns if Link has the Triforce piece for a given level.
int HasTriforce(int level){
        if(Game->LItems[level]&LI_TRIFORCE) return 1;
	return 0;
}

//Returns if Link has the compass for a given level.
int HasCompass(int level){
        if(Game->LItems[level]&LI_COMPASS) return 1;
	return 0;
}

//Returns if Link has the map for a given level.
int HasMap(int level){
        if(Game->LItems[level]&LI_MAP) return 1;
	return 0;
}

//Returns if Link has the map for a given level.
int HasBossKey(int level){
        if(Game->LItems[level]&LI_BOSSKEY) return 1;
	return 0;
}

//Returns if Link has defeated the dungeon boss for a given level.
int DefeatedLevelBoss(int level){
        if(Game->LItems[level]&LI_BOSS) return 1;
	return 0;
}

//Returns the item ID for the current screen, if there is one. 
int ScreenItem(){
	if ( Screen->RoomType == RT_SPECIALITEM ) return Screen->RoomData;
	return -1;
}


//Returns the number of Triforce Pieces Link currently has.
//Specify the highest level in your game with arg 'maxlevel'.
int NumTriforcePieces(int maxlevel){
    int ret = 0;
    for(int i=1;i<=maxlevel;i++)
        if(Game->LItems[i]&LI_TRIFORCE) ret++;
    return ret;
}


//Sets the values for combo at position 'pos' to those specified. Pass -1 to leave a value unchanged.
void SetCombo(int pos, int data, int type, int flag, int inh_flag, int cset, int solid){
	if ( data >=0 ) Screen->ComboD[pos] = data;
	if ( type >= 0 ) Screen->ComboT[pos] = type;
	if ( flag >= 0 ) Screen->ComboF[pos] = flag;
	if ( inh_flag >= 0 ) Screen->ComboI[pos] = inh_flag;
	if ( cset >= 0 ) Screen->ComboC[pos] = cset;
	if ( solid >= 0 ) Screen->ComboS[pos] = solid;
}

//Sets the values for a combo on layer 'layer', at position 'pos' to the values specified.
//Pass -1 to any value to leave it unchanged. 
void SetLayerComboValues(int layer, int pos, int data, int type, int flag, int inh_flag, int cset, int solid){
	if ( data >=0 ) SetLayerComboD(layer,pos,data);
	if ( type >= 0 ) SetLayerComboT(layer,pos,type);
	if ( flag >= 0 ) SetLayerComboF(layer,pos,flag);
	if ( inh_flag >= 0 ) SetLayerComboI(layer,pos,inh_flag);
	if ( cset >= 0 ) SetLayerComboC(layer,pos,cset);
	if ( solid >= 0 ) SetLayerComboS(layer,pos,solid);
}

//Clones combo from position 'pos_a' to position 'pos_b'
void CloneCombo(int pos_a, int pos_b){
	Screen->ComboD[pos_b] = Screen->ComboD[pos_a];
	Screen->ComboT[pos_b] = Screen->ComboT[pos_a];
	Screen->ComboF[pos_b] = Screen->ComboF[pos_a];
	Screen->ComboI[pos_b] = Screen->ComboI[pos_a];
	Screen->ComboC[pos_b] = Screen->ComboC[pos_a];
	Screen->ComboS[pos_b] = Screen->ComboS[pos_a];
}

//Clones combo on layer 'layer' posigtion 'pos_a' to the same layer at position 'pos_b'
void CloneLayerCombo(int layer, int pos_a, int pos_b){
	SetLayerComboD(layer,pos_b,GetLayerComboD(layer,pos_a));
	SetLayerComboT(layer,pos_b,GetLayerComboT(layer,pos_a));
	SetLayerComboF(layer,pos_b,GetLayerComboF(layer,pos_a));
	SetLayerComboI(layer,pos_b,GetLayerComboI(layer,pos_a));
	SetLayerComboC(layer,pos_b,GetLayerComboC(layer,pos_a));
	SetLayerComboS(layer,pos_b,GetLayerComboS(layer,pos_a));
}

//Clones a combo on layer 'layer_a' at position 'pos_a', to layer 'layer_b" at position 'pos_b'.
void CloneLayerCombo(int layer_a, int layer_b, int pos_a, int pos_b){
	SetLayerComboD(layer_b,pos_b,GetLayerComboD(layer_a,pos_a));
	SetLayerComboT(layer_b,pos_b,GetLayerComboT(layer_a,pos_a));
	SetLayerComboF(layer_b,pos_b,GetLayerComboF(layer_a,pos_a));
	SetLayerComboI(layer_b,pos_b,GetLayerComboI(layer_a,pos_a));
	SetLayerComboC(layer_b,pos_b,GetLayerComboC(layer_a,pos_a));
	SetLayerComboS(layer_b,pos_b,GetLayerComboS(layer_a,pos_a));
}


//A shorthand way to set a combo's solidity on the current layer.
//Layer 0 is the screen itself.
//Set layer0 to true to use LayerMap() to handle layer 0 combos. This should allow changes to remain static. 
void SetLayerComboS(int layer, int pos, int solidity, bool layer0) {
	if (layer==0 && !layer0) Screen->ComboS[pos] = solidity;
	if ( MIN_CONSTANT > -214747.9999 ) { //Not compile don 2.50.3
		if ( layer == 1 ) 
		Game->SetComboSolid(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, solidity);
		else if ( layer > 1 ) {
			TraceS("Setting solidity on layers higher than 1 causes this version of ZC to crash.");
		}
	}
	else Game->SetComboSolid(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, solidity);
}

//Check for collisions of two squares given upper-left coordinates and a side length for each.
bool SquareCollision(int c1x, int c1y, int side1, int c2x, int c2y, int side2) {
	return RectCollision(c1x, c1y, c1x+side1, c1y+side1, c2x, c2y, c2x+side2, c2y+side2);
}

//Check for collisions of two squares given center coordinates and a halved side length for each.
bool SquareCollision2(int c1x, int c1y, int radius1, int c2x, int c2y, int radius2) {
	if( c1y + radius1 < c2y - radius2 ) return false;
	else if( c1y - radius1 > c2y + radius2 ) return false;
	else if( c1x + radius1 < c2x - radius2 ) return false;
	else if( c1x - radius1 > c2x + radius2 ) return false;
	return true;
}


int DirRev(int dir) {
	if ( dir == DIR_LEFT) return DIR_RIGHT;
	if ( dir == DIR_DOWN) return DIR_UP;
	if ( dir == DIR_UP) return DIR_DOWN;
	if ( dir == DIR_RIGHT) return DIR_LEFT;
	if ( dir == DIR_LEFTUP) return DIR_RIGHTDOWN;
	if ( dir == DIR_RIGHTDOWN) return DIR_LEFTUP;
	if ( dir == DIR_LEFTDOWN) return DIR_RIGHTUP;
	if ( dir == DIR_RIGHTUP) return DIR_LEFTDOWN;
}
	

int SpeedRev(int speed, int reduceinertia){
	if ( speed > 0 ) speed = ((speed * -1) + reduceinertia);
	if ( speed < 0 ) speed = ((speed * -1) - reduceinertia);
	return speed;
}

//Accepts the mass, and velocity if two objects. Determins the acceleration on impact. 
//Returns the net change that would affect both objects. 
int ImpactVelocity(int mass1, int velocity1, int mass2, int velociy2 ) { //, int time){ //time is sed here, as the amount of time that both objects are in contact.
	int momentum1 = mass1*velocity1; //mv1
	int momentum2 = mass2*velociy2; //mv2
	//int accel1;
	//int accel2;
	return momentum1 - momentum2;
}

//Accepts the mass, and velocity if two objects. Determins the acceleration on impact. 
//Returns the change of acceleration for object 'B'. 
int ImpactVelocityA(int massA, int velocityA, int massB, int velociyB ) { //, int time){ //time is sed here, as the amount of time that both objects are in contact.
	int momentumA = massA*velocityA; //mv1
	int momentumB = massB*velociyB; //mv2
	return momentumA - momentumB;
}

//Accepts the mass, and velocity if two objects. Determins the acceleration on impact. 
//Returns the change of acceleration for object 'B'.
int ImpactVelocityB(int massA, int velocityA, int massB, int velociyB ) { //, int time){ //time is sed here, as the amount of time that both objects are in contact.
	int momentumA = massA*velocityA; //mv1
	int momentumB = massB*velociyB; //mv2
	return momentumB - momentumA;
}

//Accepts the mass, and velocity if two weapons. Determins the acceleration on impact. 
//Changes the Step of both to reflect their mass on collision. 
void ImpactVelocity(lweapon a, eweapon b, int massA, int velocityA, int massB, int velociyB ) { //, int time){ //time is sed here, as the amount of time that both objects are in contact.
	int momentumA = massA*velocityA; //mv1
	int momentumB = massB*velociyB; //mv2
	int accelA = momentumA - momentumB;
	int accelB = momentumB - momentumA;
	a->Step += accelA;
	b->Step += accelB;
}


//Returns centre of lweapon, with option to use either its actual coordinates, or those of its sprite. 
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterX(lweapon anLWeapon, bool usehitbox) { 
	if ( usehitbox ) return anLWeapon->X+anLWeapon->HitWidth/2 + anLWeapon->HitXOffset;
	else return anLWeapon->X+8*anLWeapon->TileWidth + anLWeapon->DrawXOffset;
}

//Returns centre of lweapon, with option to use either its actual coordinates, or those of its sprite. 
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterY(lweapon anLWeapon, bool usehitbox) {
	if ( usehitbox ) return anLWeapon->Y+anLWeapon->HitHeight/2 + anLWeapon->HitYOffset;
	else return  anLWeapon->Y+8*anLWeapon->TileHeight + anLWeapon->DrawYOffset;
}

//Returns centre of eweapon, with option to use either its actual coordinates, or those of its sprite. 
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterX(eweapon anEWeapon, bool usehitbox) { 
	if ( usehitbox ) return anEWeapon->X+anEWeapon->HitWidth/2 + anEWeapon->HitXOffset;
	else return  anEWeapon->X+8*anEWeapon->TileWidth + anEWeapon->DrawXOffset;
}

//Returns centre of eweapon, with option to use either its actual coordinates, or those of its sprite. 
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterY(eweapon anEWeapon, bool usehitbox) {
	if ( usehitbox ) return anEWeapon->Y+anEWeapon->HitHeight/2 + anEWeapon->HitYOffset;
	else return anEWeapon->Y+8*anEWeapon->TileHeight + anEWeapon->DrawYOffset;
}

//Returns centre of npc, with option to use either its actual coordinates, or those of its sprite. 
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterX(npc n, bool usehitbox) { 
	if ( usehitbox ) return n->X+n->HitWidth/2 + n->HitXOffset;
	else return n->X+8*n->TileWidth + n->DrawXOffset;
}

//Returns centre of npc, with option to use either its actual coordinates, or those of its sprite. 
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterY(npc n, bool usehitbox) {
	if ( usehitbox ) return n->Y+n->HitHeight/2 + n->HitYOffset;
	else return n->Y+8*n->TileHeight + n->DrawYOffset;
}

//Returns centre of npc, with option to use either its actual coordinates, or those of its sprite. 
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterX(item i, bool usehitbox) { 
	if ( usehitbox ) return i->X+i->HitWidth/2 + i->HitXOffset;
	else return i->X+8*i->TileWidth + i->DrawXOffset;
}

//Returns centre of npc, with option to use either its actual coordinates, or those of its sprite. 
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterY(item i, bool usehitbox) {
	if ( usehitbox ) return i->Y+i->HitHeight/2 + i->HitYOffset;
	else return i->X+8*i->TileHeight + i->DrawYOffset;
}


////////////////

//Returns centre of lweapon, with option to include its HitXOffset and DrawXOffset (individually).
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterX(lweapon anLWeapon, bool usehitbox, bool trueoffset, bool drawoffset) { 
	int lx = anLWeapon->X;
	if ( usehitbox ) lx += anLWeapon->HitWidth/2;
	unless ( usehitbox ) lx += 8*anLWeapon->TileWidth;
	if ( trueoffset ) lx += anLWeapon->HitXOffset;
	if ( drawoffset ) lx += anLWeapon->DrawXOffset;
	return lx;
}

//Returns centre of lweapon, with option to include its HitYOffset and DrawYOffset (individually).
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterY(lweapon anLWeapon, bool usehitbox, bool trueoffset, bool drawoffset) { 
	int ly = anLWeapon->Y;
	if ( usehitbox ) ly += anLWeapon->HitHeight/2;
	unless ( usehitbox ) ly += 8*anLWeapon->TileHeight;
	if ( trueoffset ) ly += anLWeapon->HitYOffset;
	if ( drawoffset ) ly += anLWeapon->DrawYOffset;
	return ly;
}

//Returns centre of eweapon, with option to include its HitXOffset and DrawXOffset (individually).
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterX(eweapon anEWeapon, bool usehitbox, bool trueoffset, bool drawoffset) { 
	int ex = anEWeapon->X;
	if ( usehitbox ) ex += anEWeapon->HitWidth/2;
	unless ( usehitbox ) ex += 8*anEWeapon->TileWidth;
	if ( trueoffset ) ex += anEWeapon->HitXOffset;
	if ( drawoffset ) ex += anEWeapon->DrawXOffset;
	return ex;
}

//Returns centre of eweapon, with option to include its HitYOffset and DrawYOffset (individually).
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterY(eweapon anEWeapon, bool usehitbox, bool trueoffset, bool drawoffset) { 
	int ey = anEWeapon->Y;
	if ( usehitbox ) ey += anEWeapon->HitHeight/2;
	unless ( usehitbox ) ey += 8*anEWeapon->TileHeight;
	if ( trueoffset ) ey += anEWeapon->HitYOffset;
	if ( drawoffset ) ey += anEWeapon->DrawYOffset;
	return ey;
}

//Returns centre of npc, with option to include its HitXOffset and DrawXOffset (individually).
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterX(npc n, bool usehitbox, bool trueoffset, bool drawoffset) { 
	int nx = n->X;
	if ( usehitbox ) nx += n->HitWidth/2;
	unless ( usehitbox ) nx += 8*n->TileWidth;
	if ( trueoffset ) nx += n->HitXOffset;
	if ( drawoffset ) nx += n->DrawXOffset;
	return nx;
}

//Returns centre of npc, with option to include its HitYOffset and DrawYOffset (individually).
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterY(npc n, bool usehitbox, bool trueoffset, bool drawoffset) { 
	int ny = n->Y;
	if ( usehitbox ) ny += n->HitHeight/2;
	unless ( usehitbox ) ny += 8*n->TileHeight;
	if ( trueoffset ) ny += n->HitYOffset;
	if ( drawoffset ) ny += n->DrawYOffset;
	return ny;
}

//Returns centre of item, with option to include its HitXOffset and DrawXOffset (individually).
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterX(item i, bool usehitbox, bool trueoffset, bool drawoffset) { 
	int ix = i->X;
	if ( usehitbox ) ix += i->HitWidth/2;
	unless ( usehitbox ) ix += 8*i->TileWidth;
	if ( trueoffset ) ix += i->HitXOffset;
	if ( drawoffset ) ix += i->DrawXOffset;
	return ix;
}

//Returns centre of item, with option to include its HitYOffset and DrawYOffset (individually).
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterY(item i, bool usehitbox, bool trueoffset, bool drawoffset) { 
	int iy = i->Y;
	if ( usehitbox ) iy += i->HitHeight/2;
	unless ( usehitbox ) iy += 8*i->TileHeight;
	if ( trueoffset ) iy += i->HitYOffset;
	if ( drawoffset ) iy += i->DrawYOffset;
	return iy;
}

////////////////

//We need to modify these functions to allow the same options as the non-Link versions. g

int CenterLinkX(bool hitoffset) { 
	if ( hitoffset ) return Link->X + 8 * Link->TileWidth + Link->HitXOffset;
	else return Link->X + 8 * Link->TileWidth;
}

int CenterLinkY(bool hitoffset) {
	if ( hitoffset ) return Link->Y + 8 * Link->TileHeight + Link->HitYOffset;
	else return Link->Y + 8 * Link->TileHeight;
}

int CenterLinkX(bool hitoffset, bool drawoffset) { 
	int lx = Link->X + 8 * Link->TileWidth;
	if ( hitoffset ) lx += Link->HitXOffset;
	if ( drawoffset ) lx += Link->DrawXOffset;	
	return lx;
}

int CenterLinkY(bool hitoffset, bool drawoffset) {
	int ly = Link->Y + 8 * Link->TileHeight;
	if ( hitoffset ) ly += Link->HitYOffset;
	if ( drawoffset ) ly += Link->DrawYOffset;	
	return ly;
}


//Returns the centre coordinates of a combo at position 'loc' similar to Center*() functions, and ComboX/Y.
int CenterComboX(int loc){
	return (loc%16*16) + 8;
}

int CenterComboY(int loc){
	return (loc&0xF0) +8;
}

bool Collision(ffc f, int cmb) { return Collision(cmb,f); }
bool Collision(lweapon l, int cmb) { return Collision(cmb,l); }
bool Collision(eweapon e, int cmb) { return Collision(cmb,e); }
bool Collision(npc n, int cmb) { return Collision(cmb,n); }
bool Collision(item i, int cmb) { return Collision(cmb,i); }



//Check for collision between lweapon 'l' and a combo at location 'cmb'. 
//Set checkcoldetection to true if you wish to return false from an lweapon with ColDetection disabled. 
bool Collision(lweapon l, int cmb, bool checkcoldetection) { 
	if ( checkcoldetection && !l->CollDetection ) return false;
	else return Collision(cmb,l); 
}

bool Collision(int cmb, lweapon l, bool checkcoldetection) { 
	if ( checkcoldetection && !l->CollDetection ) return false;
	else return Collision(cmb,l); 
}


//Check for collision between eweapon 'e' and a combo at location 'cmb' . 
//Set checkcoldetection to true if you wish to return false from an eweapon with ColDetection disabled. 
bool Collision(eweapon e, int cmb, bool checkcoldetection) {
	if ( checkcoldetection && !e->CollDetection ) return false;
	else return Collision(cmb,e); 
}


bool Collision(int cmb, eweapon e, bool checkcoldetection) {
	if ( checkcoldetection && !e->CollDetection ) return false;
	else return Collision(cmb,e); 
}

//Check for collision between NPC 'n' and a combo at location 'cmb' . 
//Set checkcoldetection to true if you wish to return false from an NPC with ColDetection disabled. 
bool Collision(npc n, int cmb, bool checkcoldetection) { 
	if ( checkcoldetection && !n->CollDetection ) return false;
	else return Collision(cmb,n); 
}

bool Collision(int cmb, npc n, bool checkcoldetection) { 
	if ( checkcoldetection && !n->CollDetection ) return false;
	else return Collision(cmb,n); 
}

//Check for collision between Link and a combo at location 'cmb' . 
//Set checkcoldetection to true if you wish to return false from an NPC with ColDetection disabled. 
bool Collision(int cmb, bool checkcoldetection) {
	if ( checkcoldetection && !Link->CollDetection ) return false;
	else return Collision(cmb); 
}

//Check for collision between ffc 'f' and a combo at location 'cmb'. 
bool Collision(int cmb, ffc f){
	int c[8];
	c[0] = ComboX(cmb);
	c[1] = ComboY(cmb);
	c[2] = ComboX(cmb)+16;
	c[3] = ComboY(cmb)+16;
	c[4] = (f->X);
	c[5] = (f->Y);
	c[6] = c[4]+(f->EffectWidth);
	c[7] = c[5]+(f->EffectHeight);
	return RectCollision( c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7] );
}

//Check for collision between lweapon 'l' and a combo at location 'cmb'. 
bool Collision(int cmb, lweapon l){
	int c[8];
	c[0] = ComboX(cmb);
	c[1] = ComboY(cmb);
	c[2] = ComboX(cmb)+16;
	c[3] = ComboY(cmb)+16;
	c[4] = (l->X)+l->HitXOffset+l->DrawXOffset;
	c[5] = (l->Y)+l->HitYOffset+l->DrawYOffset;
	c[6] = c[4]+l->HitWidth;
	c[7] = c[5]+l->HitHeight;
	return RectCollision( c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7] );
}

//Check for collision between eweapon 'e' and a combo at location 'cmb'. 
bool Collision(int cmb, eweapon e){
	int c[8];
	c[0] = ComboX(cmb);
	c[1] = ComboY(cmb);
	c[2] = ComboX(cmb)+16;
	c[3] = ComboY(cmb)+16;
	c[4] = (e->X)+e->HitXOffset+e->DrawXOffset;
	c[5] = (e->Y)+e->HitYOffset+e->DrawYOffset;
	c[5] = c[4]+e->HitWidth;
	c[7] = c[5]+e->HitHeight;
	return RectCollision( c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7] );
}

//Check for collision between npc 'n' and a combo at location 'cmb'. 
bool Collision(int cmb, npc n){
	int c[8];
	c[0] = ComboX(cmb);
	c[1] = ComboY(cmb);
	c[2] = ComboX(cmb)+16;
	c[3] = ComboY(cmb)+16;
	c[4] = (n->X)+n->HitXOffset+n->DrawXOffset;
	c[5] = (n->Y)+n->HitYOffset+n->DrawYOffset;
	c[6] = c[4]+n->HitWidth;
	c[7] = c[5]+n->HitHeight;
	return RectCollision( c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7] );
}

//Check for collision between item 'i' and a combo at location 'cmb'. 
bool Collision(int cmb, item i){
	int c[8];
	c[0] = ComboX(cmb);
	c[1] = ComboY(cmb);
	c[2] = ComboX(cmb)+16;
	c[3] = ComboY(cmb)+16;
	c[4] = (i->X)+i->HitXOffset+i->DrawXOffset;
	c[5] = (i->Y)+i->HitYOffset+i->DrawYOffset;
	c[6] = c[4]+i->HitWidth;
	c[7] = c[5]+i->HitHeight;
	return RectCollision( c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7] );
}


//Check for collision between Link and a combo at location 'cmb'. 
bool Collision(int cmb){
	int c[4];
	c[0] = Link->X+Link->HitXOffset+Link->DrawXOffset;
	c[1] = Link->Y+Link->HitYOffset+Link->DrawYOffset;
	c[2] = c[0]+(Link->HitWidth);
	c[3] = c[1]+(Link->HitHeight);
	unless ( RectCollision( ComboX(cmb), ComboY(cmb), (ComboX(cmb)+16), (ComboY(cmb)+16), c[0], c[1], c[2], c[3]) ) return false;
	else unless ( (Distance(CenterLinkX(), CenterLinkY(), (ComboX(cmb)+8), (ComboY(cmb)+8)) < 8) ) return false;
	return true;
}


//Returns angle of the given direction.
int DirAngle(int dir){
	dir &=7;
	if (dir==DIR_UP) return 90;
	if (dir==DIR_DOWN) return 270;
	if (dir==DIR_LEFT) return 180;
	if (dir==DIR_RIGHT) return 0;
	if (dir==DIR_LEFTUP) return 135;
	if (dir==DIR_RIGHTUP) return 45;
	if (dir==DIR_LEFTDOWN) return 225;
	if (dir==DIR_RIGHTDOWN) return 315;
	return -1;
}

//Same as DirAngle, but return value is measured in radians.
int DirRad(int dir){
	return DirAngle(dir)*0.0174;
}

//Use SetCombo* on Layer 0 using LayerMap()
//A shorthand way to set a combo on the current layer.
//Layer 0 is the screen itself.
//Set layer0 to true to use LayerMap() to handle layer 0 combos. This should allow changes to remain static. 
void SetLayerComboD(int layer, int pos, int combo, bool layer0) {
	if (layer==0 && !layer0) Screen->ComboD[pos] = combo;
	else Game->SetComboData(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, combo);
}


//A shorthand way to set a combo flag on the current layer.
//Layer 0 is the screen itself.
//Set layer0 to true to use LayerMap() to handle layer 0 combos. This should allow changes to remain static. 
void SetLayerComboF(int layer, int pos, int flag, bool layer0) {
	if (layer==0 && !layer0) Screen->ComboF[pos] = flag;
	else Game->SetComboFlag(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, flag);
}

//Layer 0 is the screen itself.
//Set layer0 to true to use LayerMap() to handle layer 0 combos. This should allow changes to remain static. 
void SetLayerComboI(int layer, int pos, int flag, bool layer0) {
	if (layer==0 && !layer0) Screen->ComboI[pos] = flag;
	else Game->SetComboInherentFlag(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, flag);
}


//A shorthand way to set a combo CSet on the current layer.
//Layer 0 is the screen itself.
//Set layer0 to true to use LayerMap() to handle layer 0 combos. This should allow changes to remain static. 
void SetLayerComboC(int layer, int pos, int cset, bool layer0) {
	if (layer==0 && !layer0) Screen->ComboC[pos] = cset;
	else Game->SetComboCSet(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, cset);
}


//A shorthand way to set a combo type on the current layer.
//Layer 0 is the screen itself.
//Set layer0 to true to use LayerMap() to handle layer 0 combos. This should allow changes to remain static. 
void SetLayerComboT(int layer, int pos, int type, bool layer0) {
	if (layer==0 && !layer0) Screen->ComboT[pos] = type;
	else Game->SetComboType(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, type);
}


//A shorthand way to set a combo's solidity on the current layer.
//Layer 0 is the screen itself.
//Set layer0 to true to use LayerMap() to handle layer 0 combos. This should allow changes to remain static. 
void SetLayerComboS(int layer, int pos, int solidity, bool layer0) {
	if (layer==0 && !layer0) Screen->ComboS[pos] = solidity;
	if ( MIN_CONSTANT > -214747.9999 ) { //Not compile don 2.50.3
		if ( layer == 1 ) 
		Game->SetComboSolid(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, solidity);
		else if ( layer > 1 ) {
			TraceS("Setting solidity on layers higher than 1 causes this version of ZC to crash.");
		}
	}
	else Game->SetComboSolid(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, solidity);
}

//Read link's HitBox values
int HitboxTop() {
  return (Link->Y + Link->HitYOffset);
}

int HitboxLeft() {
  return (Link->X + Link->HitXOffset);
}

int HitboxRight() {
  return (Link->X + Link->HitXOffset + Link->HitWidth - 1);
}

int HitboxBottom() {
  return (Link->Y + Link->HitYOffset + Link->HitHeight - 1);
}


//Converts the ID (type) of a given weapon to its opposite class. 
//Returns -1 if the type is illegal.
int EWeaponToLWeaponID(int type){
	if ( type == EW_ARROW ) return LW_ARROW;
	if ( type == EW_BRANG ) return LW_BRANG;
	if ( type == EW_BEAM ) return LW_BEAM;
	if ( type == EW_MAGIC ) return LW_MAGIC;
	if ( type == EW_BOMB ) return LW_BOMB;
	if ( type == EW_BOMBBLAST ) return LW_BOMBBLAST;
	if ( type == EW_SBOMB ) return LW_SBOMB;
	if ( type == EW_SBOMBBLAST ) return LW_SBOMBBLAST;
	if ( type == EW_WIND ) return LW_WIND;
	if ( type >= 31 && type <= 40 ) return type;
	else return -1;
}

//Converts the ID (type) of a given weapon to its opposite class. 
//Returns -1 if the type is illegal.
int LWeaponToEWeaponID(int type){
	if ( type == LW_ARROW ) return EW_ARROW;
	if ( type == LW_BRANG ) return EW_BRANG;
	if ( type == LW_BEAM ) return EW_BEAM;
	if ( type == LW_MAGIC ) return EW_MAGIC;
	if ( type == LW_BOMB ) return EW_BOMB;
	if ( type == LW_BOMBBLAST ) return EW_BOMBBLAST;
	if ( type == LW_SBOMB ) return EW_SBOMB;
	if ( type == LW_SBOMBBLAST ) return EW_SBOMBBLAST;
	if ( type == LW_WIND ) return EW_WIND;
	if ( type >= 31 && type <= 40 ) return type;
	else return -1;
}


//Copy the attributes of a given lweapon to an eweapon.
//Returns -1 on error, including if the type (weap->ID) conversion is illegal.
eweapon LWeaponToEWeapon(lweapon a, eweapon b){
	int type = LWeaponToEWeaponID(a->ID);
	//if ( type == -1 ) return type;
	b->ID = type;
	b->X = a->X;
	b->Y = a->Y;
	b->Z = a->Z;
	b->Jump = a->Jump;
	b->Extend = a->Extend;
	b->TileWidth = a->TileWidth;
	b->TileHeight = a->TileHeight;
	b->HitWidth = a->HitWidth;
	b->HitHeight = a->HitHeight;
	b->HitZHeight = a->HitZHeight;
	b->HitXOffset = a->HitXOffset;
	b->HitYOffset = a->HitYOffset;
	b->DrawXOffset = a->DrawXOffset;
	b->DrawYOffset = a->DrawYOffset;
	b->DrawZOffset = a->DrawZOffset;
	b->Tile = a->Tile;
	b->CSet = a->CSet;
	b->DrawStyle = a->DrawStyle;
	b->Dir = a->Dir;
	b->OriginalTile = a->OriginalTile;
	b->OriginalCSet = a->OriginalCSet;
	b->FlashCSet = a->FlashCSet;
	b->NumFrames = a->NumFrames;
	b->Frame = a->Frame;
	b->ASpeed = a->ASpeed;
	b->Damage = a->Damage;
	b->Step = a->Step;
	b->Angle = a->Angle;
	b->Angular = a->Angular;
	b->CollDetection = a->CollDetection;
	b->DeadState = a->DeadState;
	b->Flash = a->Flash;
	b->Flip = a->Flip;
	for (int i = 0; i < 16; i++)
		b->Misc[i] = a->Misc[i];
	return b;
}



//Copy the attributes of a given lweapon to a new eweapon.
//Returns -1 on error, including if the type (weap->ID) conversion is illegal.
eweapon LWeaponToEWeapon(lweapon a){
	int type = LWeaponToEWeaponID(a->ID);
//	if ( type == -1 ) return type;
	eweapon b = Screen->CreateEWeapon(type);
	b->X = a->X;
	b->Y = a->Y;
	b->Z = a->Z;
	b->Jump = a->Jump;
	b->Extend = a->Extend;
	b->TileWidth = a->TileWidth;
	b->TileHeight = a->TileHeight;
	b->HitWidth = a->HitWidth;
	b->HitHeight = a->HitHeight;
	b->HitZHeight = a->HitZHeight;
	b->HitXOffset = a->HitXOffset;
	b->HitYOffset = a->HitYOffset;
	b->DrawXOffset = a->DrawXOffset;
	b->DrawYOffset = a->DrawYOffset;
	b->DrawZOffset = a->DrawZOffset;
	b->Tile = a->Tile;
	b->CSet = a->CSet;
	b->DrawStyle = a->DrawStyle;
	b->Dir = a->Dir;
	b->OriginalTile = a->OriginalTile;
	b->OriginalCSet = a->OriginalCSet;
	b->FlashCSet = a->FlashCSet;
	b->NumFrames = a->NumFrames;
	b->Frame = a->Frame;
	b->ASpeed = a->ASpeed;
	b->Damage = a->Damage;
	b->Step = a->Step;
	b->Angle = a->Angle;
	b->Angular = a->Angular;
	b->CollDetection = a->CollDetection;
	b->DeadState = a->DeadState;
	b->Flash = a->Flash;
	b->Flip = a->Flip;
	for (int i = 0; i < 16; i++)
		b->Misc[i] = a->Misc[i];
	return b;
}

lweapon EWeaponToLWeapon(lweapon b, eweapon a) { return EWeaponToLWeapon(a,b);}
eweapon LWeaponToEWeapon(eweapon b, lweapon a) { return LWeaponToEWeapon(a,b);}
lweapon EToLWeapon(lweapon b, eweapon a) { return EWeaponToLWeapon(a,b);}
eweapon LtoEWeapon(eweapon b, lweapon a) { return LWeaponToEWeapon(a,b);}

lweapon EToLWeapon(eweapon a, lweapon b) { return EWeaponToLWeapon(a,b);}
eweapon LtoEWeapon(lweapon a, eweapon b) { return LWeaponToEWeapon(a,b);}


eweapon LtoEWeapon(lweapon a){return LtoEWeapon(a);}
lweapon EtoLWeapon(eweapon a){return EtoLWeapon(a);}

//Copy the attributes of a given eweapon to a new lweapon.
//Returns -1 on error, including if the type (weap->ID) conversion is illegal.
lweapon EWeaponToLWeapon(eweapon a){
	int type = EWeaponToLWeaponID(a->ID);
	//if ( type == -1 ) return type;
	lweapon b = Screen->CreateLWeapon(type);
	b->X = a->X;
	b->Y = a->Y;
	b->Z = a->Z;
	b->Jump = a->Jump;
	b->Extend = a->Extend;
	b->TileWidth = a->TileWidth;
	b->TileHeight = a->TileHeight;
	b->HitWidth = a->HitWidth;
	b->HitHeight = a->HitHeight;
	b->HitZHeight = a->HitZHeight;
	b->HitXOffset = a->HitXOffset;
	b->HitYOffset = a->HitYOffset;
	b->DrawXOffset = a->DrawXOffset;
	b->DrawYOffset = a->DrawYOffset;
	b->DrawZOffset = a->DrawZOffset;
	b->Tile = a->Tile;
	b->CSet = a->CSet;
	b->DrawStyle = a->DrawStyle;
	b->Dir = a->Dir;
	b->OriginalTile = a->OriginalTile;
	b->OriginalCSet = a->OriginalCSet;
	b->FlashCSet = a->FlashCSet;
	b->NumFrames = a->NumFrames;
	b->Frame = a->Frame;
	b->ASpeed = a->ASpeed;
	b->Damage = a->Damage;
	b->Step = a->Step;
	b->Angle = a->Angle;
	b->Angular = a->Angular;
	b->CollDetection = a->CollDetection;
	b->DeadState = a->DeadState;
	b->Flash = a->Flash;
	b->Flip = a->Flip;
	for (int i = 0; i < 16; i++)
		b->Misc[i] = a->Misc[i];
	return b;
}


//Copy the attributes of a given eweapon to an lweapon.
//Returns -1 on error, including if the type (weap->ID) conversion is illegal.
lweapon EWeaponToLWeapon(eweapon a, lweapon b){
	int type = EWeaponToLWeaponID(a->ID);
	//if ( type == -1 ) return type;
	b->ID = type;
	b->X = a->X;
	b->Y = a->Y;
	b->Z = a->Z;
	b->Jump = a->Jump;
	b->Extend = a->Extend;
	b->TileWidth = a->TileWidth;
	b->TileHeight = a->TileHeight;
	b->HitWidth = a->HitWidth;
	b->HitHeight = a->HitHeight;
	b->HitZHeight = a->HitZHeight;
	b->HitXOffset = a->HitXOffset;
	b->HitYOffset = a->HitYOffset;
	b->DrawXOffset = a->DrawXOffset;
	b->DrawYOffset = a->DrawYOffset;
	b->DrawZOffset = a->DrawZOffset;
	b->Tile = a->Tile;
	b->CSet = a->CSet;
	b->DrawStyle = a->DrawStyle;
	b->Dir = a->Dir;
	b->OriginalTile = a->OriginalTile;
	b->OriginalCSet = a->OriginalCSet;
	b->FlashCSet = a->FlashCSet;
	b->NumFrames = a->NumFrames;
	b->Frame = a->Frame;
	b->ASpeed = a->ASpeed;
	b->Damage = a->Damage;
	b->Step = a->Step;
	b->Angle = a->Angle;
	b->Angular = a->Angular;
	b->CollDetection = a->CollDetection;
	b->DeadState = a->DeadState;
	b->Flash = a->Flash;
	b->Flip = a->Flip;
	for (int i = 0; i < 16; i++)
		b->Misc[i] = a->Misc[i];
	return b;
}


int EtoLWeaponID(int type){
	return EWeaponToLWeaponID(type);
}

int LtoEWeaponID(int type){
	return LWeaponToEWeaponID(type);
}
	


//Xor comparison of two calculations. ( e.g. Xor(n-x, n+y) ) 
//Returns true if they do not match. 
bool Xor(float calcA, float calcB){
	if ( calcA != calcB ) return true;
	return false;
}


//Randomly return true or false. 
int Chance(){
	return Rand(0,1);
}

//Randomly returns true, or false, using input 'percentChance' to determine the percentage change of a 'true return'
bool Chance(int percentChance){
	return RandB(percentChance);
}

int ProximityX(ffc a, ffc b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}


int ProximityX(ffc a, lweapon b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}


int ProximityX(ffc a, eweapon b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}
	

int ProximityX(ffc a, npc b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}


int ProximityX(ffc a, item b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}


int ProximityX(lweapon a, ffc b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(lweapon a, lweapon b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(lweapon a, eweapon b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(lweapon a, npc b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(lweapon a, item b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(eweapon a, ffc b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(eweapon a, lweapon b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(eweapon a, eweapon b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(eweapon a, npc b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(eweapon a, item b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(npc a, ffc b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(npc a, lweapon b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(npc a, eweapon b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(npc a, npc b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(npc a, item b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}


int ProximityX(item a, ffc b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(item a, lweapon b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(item a, eweapon b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(item a, npc b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(item a, item b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(int b, ffc a) {
	if ( a->X > ComboX(b) ) return a->X - ComboX(b);
	else return ComboX(b) - a->X;
}


int ProximityX(int b, lweapon a) {
	if ( a->X > ComboX(b) ) return a->X - ComboX(b);
	else return ComboX(b) - a->X;
}


int ProximityX(int b, eweapon a) {
	if ( a->X > ComboX(b) ) return a->X - ComboX(b);
	else return ComboX(b) - a->X;
}
	

int ProximityX(int b, npc a) {
	if ( a->X > ComboX(b) ) return a->X - ComboX(b);
	else return ComboX(b) - a->X;
}


int ProximityX(int b, item a) {
	if ( a->X > ComboX(b) ) return a->X - ComboX(b);
	else return ComboX(b) - a->X;
}

int ProximityX(ffc a, int b) {
	if ( a->X > ComboX(b) ) return a->X - ComboX(b);
	else return ComboX(b) - a->X;
}


int ProximityX(lweapon a, int b) {
	if ( a->X > ComboX(b) ) return a->X - ComboX(b);
	else return ComboX(b) - a->X;
}


int ProximityX(eweapon a, int b) {
	if ( a->X > ComboX(b) ) return a->X - ComboX(b);
	else return ComboX(b) - a->X;
}
	

int ProximityX(npc a, int b) {
	if ( a->X > ComboX(b) ) return a->X - ComboX(b);
	else return ComboX(b) - a->X;
}


int ProximityX(item a, int b) {
	if ( a->X > ComboX(b) ) return a->X - ComboX(b);
	else return ComboX(b) - a->X;
}

int ProximityX(int b, int a) {
	if ( ComboX(a) > ComboX(b) ) return ComboX(a) - ComboX(b);
	else return ComboX(b) - ComboX(a);
}

int ProximityX(ffc a) {
	if ( a->X > Link->X ) return a->X - Link->X;
	else return Link->X - a->X;
}

int ProximityX(lweapon a) {
	if ( a->X > Link->X ) return a->X - Link->X;
	else return Link->X - a->X;
}

int ProximityX(eweapon a) {
	if ( a->X > Link->X ) return a->X - Link->X;
	else return Link->X - a->X;
}

int ProximityX(npc a) {
	if ( a->X > Link->X ) return a->X - Link->X;
	else return Link->X - a->X;
}

int ProximityX(item a) {
	if ( a->X > Link->X ) return a->X - Link->X;
	else return Link->X - a->X;
}

int ProximityX(int a) {
	int ax = ComboX(a);
	if ( ax > Link->X ) return ax - Link->X;
	else return Link->X - ax;
}

int ProximityY(ffc a, ffc b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}


int ProximityY(ffc a, lweapon b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}


int ProximityY(ffc a, eweapon b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}
	

int ProximityY(ffc a, npc b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}


int ProximityY(ffc a, item b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}


int ProximityY(lweapon a, ffc b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(lweapon a, lweapon b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(lweapon a, eweapon b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(lweapon a, npc b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(lweapon a, item b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(eweapon a, ffc b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(eweapon a, lweapon b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(eweapon a, eweapon b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(eweapon a, npc b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(eweapon a, item b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(npc a, ffc b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(npc a, lweapon b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(npc a, eweapon b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(npc a, npc b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(npc a, item b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}


int ProximityY(item a, ffc b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(item a, lweapon b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(item a, eweapon b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(item a, npc b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(item a, item b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(int b, ffc a) {
	if ( a->Y > ComboY(b) ) return a->Y - ComboY(b);
	else return ComboY(b) - a->Y;
}


int ProximityY(int b, lweapon a) {
	if ( a->Y > ComboY(b) ) return a->Y - ComboY(b);
	else return ComboY(b) - a->Y;
}


int ProximityY(int b, eweapon a) {
	if ( a->Y > ComboY(b) ) return a->Y - ComboY(b);
	else return ComboY(b) - a->Y;
}
	

int ProximityY(int b, npc a) {
	if ( a->Y > ComboY(b) ) return a->Y - ComboY(b);
	else return ComboY(b) - a->Y;
}


int ProximityY(int a, item b) {
	if ( b->Y > ComboY(a) ) return b->Y - ComboY(a);
	else return ComboY(a) - b->Y;
}

int ProximityY(ffc a, int b) {
	if ( a->Y > ComboY(b) ) return a->Y - ComboY(b);
	else return ComboY(b) - a->Y;
}


int ProximityY(lweapon a, int b) {
	if ( a->Y > ComboY(b) ) return a->Y - ComboY(b);
	else return ComboY(b) - a->Y;
}


int ProximityY(eweapon a, int b) {
	if ( a->Y > ComboY(b) ) return a->Y - ComboY(b);
	else return ComboY(b) - a->Y;
}
	

int ProximityY(npc a, int b) {
	if ( a->Y > ComboY(b) ) return a->Y - ComboY(b);
	else return ComboY(b) - a->Y;
}


int ProximityY(item a, int b) {
	if ( a->Y > ComboY(b) ) return a->Y - ComboY(b);
	else return ComboY(b) - a->Y;
}

int ProximityY(int b, int a) {
	if ( ComboY(a) > ComboY(b) ) return ComboY(a) - ComboY(b);
	else return ComboY(b) - ComboY(a);
}

int ProximityY(ffc a) {
	if ( a->Y > Link->Y ) return a->Y - Link->Y;
	else return Link->Y - a->Y;
}

int ProximityY(lweapon a) {
	if ( a->Y > Link->Y ) return a->Y - Link->Y;
	else return Link->Y - a->Y;
}

int ProximityY(eweapon a) {
	if ( a->Y > Link->Y ) return a->Y - Link->Y;
	else return Link->Y - a->Y;
}

int ProximityY(npc a) {
	if ( a->Y > Link->Y ) return a->Y - Link->Y;
	else return Link->Y - a->Y;
}

int ProximityY(item a) {
	if ( a->Y > Link->Y ) return a->Y - Link->Y;
	else return Link->Y - a->Y;
}

int ProximityY(int a) {
	int ay = ComboY(a);
	if ( ay > Link->Y ) return ay - Link->Y;
	else return Link->Y - ay;
}

//ProximityX also needs a precise variation. 

//Proximity from centre of object's hitbox:
int ProximityX(ffc a, ffc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a);
		int bx = CenterX(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

//Rid these of varible declaration inefficiency?
int ProximityX(ffc a, lweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}


int ProximityX(ffc a, eweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}
	

int ProximityX(ffc a, npc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}


int ProximityX(ffc a, item b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}


int ProximityX(lweapon a, ffc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(lweapon a, lweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(lweapon a, eweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(lweapon a, npc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(lweapon a, item b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(eweapon a, ffc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(eweapon a, lweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(eweapon a, eweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(eweapon a, npc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(eweapon a, item b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(npc a, ffc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(npc a, lweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(npc a, eweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(npc a, npc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(npc a, item b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(item a, ffc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}
int ProximityX(item a, lweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(item a, eweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(item a, npc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(item a, item b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}



//Are multiple function calls less efficient than setting these once as local vars?
//int ProximityX(ffc a) {
//	if ( CenterX(a) > CenterLinkX() ) return CenterX(a) - CenterLinkX();
//	else return CenterLinkX() - CenterX(a);
//}




int ProximityY(ffc a, ffc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a);
		int bx = CenterY(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}


int ProximityY(ffc a, lweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}


int ProximityY(ffc a, eweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}
	

int ProximityY(ffc a, npc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(ffc a, item b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}


int ProximityY(lweapon a, ffc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(lweapon a, lweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(lweapon a, eweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(lweapon a, npc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(lweapon a, item b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(eweapon a, ffc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(eweapon a, lweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(eweapon a, eweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(eweapon a, npc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(eweapon a, item b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(npc a, ffc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}
int ProximityY(npc a, lweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(npc a, eweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(npc a, npc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}
int ProximityY(npc a, item b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}


int ProximityY(item a, ffc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(item a, lweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(item a, eweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(item a, npc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(item a, item b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(ffc a, bool fromcentre) {
	int ax = CenterX(a);
	int lx = CenterLinkX();
	if ( fromcentre ) {
		if ( ax > lx ) return ax - lx;
		else return lx - ax;
	}
	else {
		if ( a->X > lx ) return a->X - lx;
		else return lx - a->X;
	}
}

int ProximityX(lweapon a, bool fromcentre) {
	int ax = CenterX(a);
	int lx = CenterLinkX();
	if ( fromcentre ) {
		if ( ax > lx ) return ax - lx;
		else return lx - ax;
	}
	else {
		if ( a->X > lx ) return a->X - lx;
		else return lx - a->X;
	}
}


int ProximityX(eweapon a, bool fromcentre) {
	int ax = CenterX(a);
	int lx = CenterLinkX();
	if ( fromcentre ) {
		if ( ax > lx ) return ax - lx;
		else return lx - ax;
	}
	else {
		if ( a->X > lx ) return a->X - lx;
		else return lx - a->X;
	}
}


int ProximityX(npc a, bool fromcentre) {
	int ax = CenterX(a);
	int lx = CenterLinkX();
	if ( fromcentre ) {
		if ( ax > lx ) return ax - lx;
		else return lx - ax;
	}
	else {
		if ( a->X > lx ) return a->X - lx;
		else return lx - a->X;
	}
}


int ProximityX(item a, bool fromcentre) {
	int ax = CenterX(a);
	int lx = CenterLinkX();
	if ( fromcentre ) {
		if ( ax > lx ) return ax - lx;
		else return lx - ax;
	}
	else {
		if ( a->X > lx ) return a->X - lx;
		else return lx - a->X;
	}
}



int ProximityY(ffc a, bool fromcentre) {
	int ay = CenterY(a);
	int ly = CenterLinkY();
	if ( fromcentre ) {
		if ( ay > ly ) return ay - ly;
		else return ly - ay;
	}
	else { 
		if ( a->Y > ly ) return a->Y - ly;
		else return a->Y - ly;
	}
}

int ProximityY(lweapon a, bool fromcentre) {
	int ay = CenterY(a);
	int ly = CenterLinkY();
	if ( fromcentre ) {
		if ( ay > ly ) return ay - ly;
		else return ly - ay;
	}
	else { 
		if ( a->Y > ly ) return a->Y - ly;
		else return a->Y - ly;
	}
}


int ProximityY(eweapon a, bool fromcentre) {
	int ay = CenterY(a);
	int ly = CenterLinkY();
	if ( fromcentre ) {
		if ( ay > ly ) return ay - ly;
		else return ly - ay;
	}
	else { 
		if ( a->Y > ly ) return a->Y - ly;
		else return a->Y - ly;
	}
}


int ProximityY(npc a, bool fromcentre) {
	int ay = CenterY(a);
	int ly = CenterLinkY();
	if ( fromcentre ) {
		if ( ay > ly ) return ay - ly;
		else return ly - ay;
	}
	else { 
		if ( a->Y > ly ) return a->Y - ly;
		else return a->Y - ly;
	}
}


int ProximityY(item a, bool fromcentre) {
	int ay = CenterY(a);
	int ly = CenterLinkY();
	if ( fromcentre ) {
		if ( ay > ly ) return ay - ly;
		else return ly - ay;
	}
	else { 
		if ( a->Y > ly ) return a->Y - ly;
		else return a->Y - ly;
	}
}



///Proximity between *ptr and combo. 

int ProximityX(int a, ffc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboX(a);
		int bx = CenterX(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboX(a) > b->X ) return ComboX(a) - b->X;
		else return b->X - ComboX(a);
	}
}

int ProximityX(int a, lweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboX(a);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboX(a) > b->X ) return ComboX(a) - b->X;
		else return b->X - ComboX(a);
	}
}

int ProximityX(int a, eweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboX(a);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboX(a) > b->X ) return ComboX(a) - b->X;
		else return b->X - ComboX(a);
	}
}

int ProximityX(int a, npc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboX(a);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboX(a) > b->X ) return ComboX(a) - b->X;
		else return b->X - ComboX(a);
	}
}

int ProximityX(int a, item b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboX(a);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboX(a) > b->X ) return ComboX(a) - b->X;
		else return b->X - ComboX(a);
	}
}

int ProximityX(ffc b, int a, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboX(a);
		int bx = CenterX(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboX(a) > b->X ) return ComboX(a) - b->X;
		else return b->X - ComboX(a);
	}
}

int ProximityX(lweapon b, int a, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboX(a);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboX(a) > b->X ) return ComboX(a) - b->X;
		else return b->X - ComboX(a);
	}
}

int ProximityX(eweapon b, int a, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboX(a);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboX(a) > b->X ) return ComboX(a) - b->X;
		else return b->X - ComboX(a);
	}
}

int ProximityX(npc b, int a, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboX(a);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboX(a) > b->X ) return ComboX(a) - b->X;
		else return b->X - ComboX(a);
	}
}

int ProximityX(item b, int a, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboX(a);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboX(a) > b->X ) return ComboX(a) - b->X;
		else return b->X - ComboX(a);
	}
}

int ProximityX(int b, int a, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboX(a);
		int bx = CenterComboX(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboX(a) > ComboX(b) ) return ComboX(a) - ComboX(b);
		else return ComboX(b) - ComboX(a);
	}
}

int ProximityY(int a, ffc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboY(a);
		int bx = CenterY(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboY(a) > b->Y ) return ComboY(a) - b->Y;
		else return b->Y - ComboY(a);
	}
}

int ProximityY(int a, lweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboY(a);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboY(a) > b->Y ) return ComboY(a) - b->Y;
		else return b->Y - ComboY(a);
	}
}

int ProximityY(int a, eweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboY(a);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboY(a) > b->Y ) return ComboY(a) - b->Y;
		else return b->Y - ComboY(a);
	}
}

int ProximityY(int a, npc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboY(a);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboY(a) > b->Y ) return ComboY(a) - b->Y;
		else return b->Y - ComboY(a);
	}
}

int ProximityY(int a, item b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboY(a);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboY(a) > b->Y ) return ComboY(a) - b->Y;
		else return b->Y - ComboY(a);
	}
}

int ProximityY(ffc b, int a, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboY(a);
		int bx = CenterY(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboY(a) > b->Y ) return ComboY(a) - b->Y;
		else return b->Y - ComboY(a);
	}
}

int ProximityY(lweapon b, int a, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboY(a);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboY(a) > b->Y ) return ComboY(a) - b->Y;
		else return b->Y - ComboY(a);
	}
}

int ProximityY(eweapon b, int a, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboY(a);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboY(a) > b->Y ) return ComboY(a) - b->Y;
		else return b->Y - ComboY(a);
	}
}

int ProximityY(npc b, int a, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboY(a);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboY(a) > b->Y ) return ComboY(a) - b->Y;
		else return b->Y - ComboY(a);
	}
}

int ProximityY(item b, int a, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboY(a);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboY(a) > b->Y ) return ComboY(a) - b->Y;
		else return b->Y - ComboY(a);
	}
}


int ProximityY(int b, int a, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboY(a);
		int bx = CenterComboY(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboY(a) > ComboY(b) ) return ComboY(a) - ComboY(b);
		else return ComboY(b) - ComboY(a);
	}
}


//! Collision with hitbox constraints. 
//Check for collision between ffc 'f' and a combo at location 'cmb'. 
bool Collision(int cmb, ffc f, int a1, int b1, int c1, int d1, int a2, int b2, int c2, int d2){
	int c[8];
	c[0] = ComboX(cmb);
	c[1] = ComboY(cmb);
	c[2] = ComboX(cmb)+16;
	c[3] = ComboY(cmb)+16;
	c[4] = (f->X);
	c[5] = (f->Y);
	c[6] = c[4]+(f->EffectWidth);
	c[7] = c[5]+(f->EffectHeight);
	return RectCollision( c[0]+a1, c[1]+b1, c[2]+c1, c[3]+d1, c[4]+a2, c[5]+b2, c[6]+c2, c[7]+d2 );
}


//Check for collision between lweapon 'l' and a combo at location 'cmb'. 
bool Collision(int cmb, lweapon l, int a1, int b1, int c1, int d1, int a2, int b2, int c2, int d2){
	int c[8];
	c[0] = ComboX(cmb);
	c[1] = ComboY(cmb);
	c[2] = ComboX(cmb)+16;
	c[3] = ComboY(cmb)+16;
	c[4] = (l->X)+l->HitXOffset+l->DrawXOffset;
	c[5] = (l->Y)+l->HitYOffset+l->DrawYOffset;
	c[6] = c[4]+l->HitWidth;
	c[7] = c[5]+l->HitHeight;
	return RectCollision( c[0]+a1, c[1]+b1, c[2]+c1, c[3]+d1, c[4]+a2, c[5]+b2, c[6]+c2, c[7]+d2 );
}

//Check for collision between eweapon 'e' and a combo at location 'cmb'. 
bool Collision(int cmb, eweapon e,  int a1, int b1, int c1, int d1, int a2, int b2, int c2, int d2){
	int c[8];
	c[0] = ComboX(cmb);
	c[1] = ComboY(cmb);
	c[2] = ComboX(cmb)+16;
	c[3] = ComboY(cmb)+16;
	c[4] = (e->X)+e->HitXOffset+e->DrawXOffset;
	c[5] = (e->Y)+e->HitYOffset+e->DrawYOffset;
	c[5] = c[4]+e->HitWidth;
	c[7] = c[5]+e->HitHeight;
	return RectCollision( c[0]+a1, c[1]+b1, c[2]+c1, c[3]+d1, c[4]+a2, c[5]+b2, c[6]+c2, c[7]+d2 );
}

//Check for collision between npc 'n' and a combo at location 'cmb'. 
bool Collision(int cmb, npc n,  int a1, int b1, int c1, int d1, int a2, int b2, int c2, int d2){
	int c[8];
	c[0] = ComboX(cmb);
	c[1] = ComboY(cmb);
	c[2] = ComboX(cmb)+16;
	c[3] = ComboY(cmb)+16;
	c[4] = (n->X)+n->HitXOffset+n->DrawXOffset;
	c[5] = (n->Y)+n->HitYOffset+n->DrawYOffset;
	c[6] = c[4]+n->HitWidth;
	c[7] = c[5]+n->HitHeight;
	return RectCollision( c[0]+a1, c[1]+b1, c[2]+c1, c[3]+d1, c[4]+a2, c[5]+b2, c[6]+c2, c[7]+d2 );
}

//Check for collision between item 'i' and a combo at location 'cmb'. 
bool Collision(int cmb, item i,  int a1, int b1, int c1, int d1, int a2, int b2, int c2, int d2){
	int c[8];
	c[0] = ComboX(cmb);
	c[1] = ComboY(cmb);
	c[2] = ComboX(cmb)+16;
	c[3] = ComboY(cmb)+16;
	c[4] = (i->X)+i->HitXOffset+i->DrawXOffset;
	c[5] = (i->Y)+i->HitYOffset+i->DrawYOffset;
	c[6] = c[4]+i->HitWidth;
	c[7] = c[5]+i->HitHeight;
	return RectCollision( c[0]+a1, c[1]+b1, c[2]+c1, c[3]+d1, c[4]+a2, c[5]+b2, c[6]+c2, c[7]+d2 );
}


//Check for collision between Link and a combo at location 'cmb'. 
bool Collision(int cmb,  int a1, int b1, int c1, int d1, int a2, int b2, int c2, int d2){
	int c[8];
	c[0] = ComboX(cmb);
	c[1] = ComboY(cmb);
	c[2] = ComboX(cmb)+16;
	c[3] = ComboY(cmb)+16;
	c[4] = Link->X+Link->HitXOffset+Link->DrawXOffset;
	c[5] = Link->Y+Link->HitYOffset+Link->DrawYOffset;
	c[6] = c[0]+(Link->HitWidth);
	c[7] = c[1]+(Link->HitHeight);
	return RectCollision( c[0]+a1, c[1]+b1, c[2]+c1, c[3]+d1, c[4]+a2, c[5]+b2, c[6]+c2, c[7]+d2 );
}




//Returns collision between an lweapon and a combo, only if its direction is 'dir'.
//Set checkcoldetection true if you wish weapons without collision to automatically return false.
bool CollisionDir(int cmb, lweapon l, int dir, bool checkcoldetection) {
	int c[8];
	c[0] = ComboX(cmb);
	c[1] = ComboY(cmb);
	c[2] = ComboX(cmb)+16;
	c[3] = ComboY(cmb)+16;
	c[4] = (l->X)+l->HitXOffset+l->DrawXOffset;
	c[5] = (l->Y)+l->HitYOffset+l->DrawYOffset;
	c[6] = c[4]+l->HitWidth;
	c[7] = c[5]+l->HitHeight;
	if ( checkcoldetection && !l->CollDetection ) return false;
	if ( l->Dir != dir ) return false;
	return RectCollision( c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7] );
}

//Returns collision between an lweapon and a combo.
//Returns false base don direction:
//Set 'facingspecificdir' to true, to check only if a weapon is facing a specific direction.
//Set it false, if you want to check if a weapon is NOT facing a specific direction. 
//Set checkcoldetection true if you wish weapons without collision to automatically return false.
bool CollisionDir(int cmb, lweapon l, int dir, bool facingspecificdir, bool checkcoldetection) {
	int c[8];
	c[0] = ComboX(cmb);
	c[1] = ComboY(cmb);
	c[2] = ComboX(cmb)+16;
	c[3] = ComboY(cmb)+16;
	c[4] = (l->X)+l->HitXOffset+l->DrawXOffset;
	c[5] = (l->Y)+l->HitYOffset+l->DrawYOffset;
	c[6] = c[4]+l->HitWidth;
	c[7] = c[5]+l->HitHeight;
	if ( checkcoldetection && !l->CollDetection ) return false;
	if ( facingspecificdir && l->Dir != dir ) return false;
	if ( !facingspecificdir && l->Dir == dir ) return false;
	return RectCollision( c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7] );
}

//Feb 2016
bool Pos(int val){ return ( val > 0 ); }
bool Neg(int val){ return ( val < 0 ); }


//Returns the lesser of values passed as args. Overloaded for up to eight values.
int Lesser(int valA, int valB){
	if ( valA < valB ) return valA;
	else return valB;
}

int Lesser(int valA, int valB, int valC){
	if ( valA < valB && valA < valC ) return valA;
	else if ( valB < valA && valB < valC ) return valB;
	else return valC;
}

int Lesser(int valA, int valB, int valC, int valD){
	if ( valA < valB && valA < valC && valA < valD) return valA;
	else if ( valB < valA && valB < valC && valB < valD ) return valB;
	else if ( valC < valA && valC < valB && valC < valD ) return valC;
	else return valD;
}

int Lesser(int valA, int valB, int valC, int valD, int valE){
	if ( valA < valB && valA < valC && valA < valD && valA < valE) return valA;
	else if ( valB < valA && valB < valC && valB < valD && valB < valE ) return valB;
	else if ( valC < valA && valC < valB && valC < valD && valC < valE ) return valC;
	else if ( valD < valA && valD < valB && valD < valC && valD < valE ) return valD;
	else return valE;
}


int Lesser(int valA, int valB, int valC, int valD, int valE, int valF){
	if ( valA < valB && valA < valC && valA < valD && valA < valE && valA < valF) return valA;
	else if ( valB < valA && valB < valC && valB < valD && valB < valE && valB < valF ) return valB;
	else if ( valC < valA && valC < valB && valC < valD && valC < valE && valC < valF ) return valC;
	else if ( valD < valA && valD < valB && valD < valC && valD < valE && valD < valF ) return valD;
	else if ( valE < valA && valE < valB && valE < valC && valE < valD && valE < valF ) return valE;
	else return valF;
}

int Lesser(int valA, int valB, int valC, int valD, int valE, int valF, int valG){
	if ( valA < valB && valA < valC && valA < valD && valA < valE && valA < valF && valA < valG) return valA;
	else if ( valB < valA && valB < valC && valB < valD && valB < valE && valB < valF && valB < valG ) return valB;
	else if ( valC < valA && valC < valB && valC < valD && valC < valE && valC < valF && valC < valG ) return valC;
	else if ( valD < valA && valD < valB && valD < valC && valD < valE && valD < valF && valD < valG ) return valD;
	else if ( valE < valA && valE < valB && valE < valC && valE < valD && valE < valF && valE < valG ) return valE;
	else if ( valF < valA && valF < valB && valF < valC && valF < valD && valF < valE && valF < valG ) return valF;
	else return valG;
}

int Lesser(int valA, int valB, int valC, int valD, int valE, int valF, int valG, int valH){
	if ( valA < valB && valA < valC && valA < valD && valA < valE && valA < valF && valA < valG && valA < valH) return valA;
	else if ( valB < valA && valB < valC && valB < valD && valB < valE && valB < valF && valB < valG && valB < valH ) return valB;
	else if ( valC < valA && valC < valB && valC < valD && valC < valE && valC < valF && valC < valG && valC < valH) return valC;
	else if ( valD < valA && valD < valB && valD < valC && valD < valE && valD < valF && valD < valG && valD < valH ) return valD;
	else if ( valE < valA && valE < valB && valE < valC && valE < valD && valE < valF && valE < valG && valE < valH ) return valE;
	else if ( valF < valA && valF < valB && valF < valC && valF < valD && valF < valE && valF < valG && valF < valH ) return valF;
	else if ( valG < valA && valG < valB && valG < valC && valG < valD && valG < valE && valG < valF && valG < valH ) return valG;
	else return valH;
}

//Returns the greater of passed args. Overloaded for up to eight values.
int Greater(int valA, int valB){
	if ( valA > valB ) return valA;
	else return valB;
}

int Greater(int valA, int valB, int valC){
	if ( valA > valB && valA > valC ) return valA;
	else if ( valB > valA && valB > valC ) return valB;
	else return valC;
}

int Greater(int valA, int valB, int valC, int valD){
	if ( valA > valB && valA > valC && valA > valD) return valA;
	else if ( valB > valA && valB > valC && valB > valD ) return valB;
	else if ( valC > valA && valC > valB && valC > valD ) return valC;
	else return valD;
}

int Greater(int valA, int valB, int valC, int valD, int valE){
	if ( valA > valB && valA > valC && valA > valD && valA > valE) return valA;
	else if ( valB > valA && valB > valC && valB > valD && valB > valE ) return valB;
	else if ( valC > valA && valC > valB && valC > valD && valC > valE ) return valC;
	else if ( valD > valA && valD > valB && valD > valC && valD > valE ) return valD;
	else return valE;
}


int Greater(int valA, int valB, int valC, int valD, int valE, int valF){
	if ( valA > valB && valA > valC && valA > valD && valA > valE && valA > valF) return valA;
	else if ( valB > valA && valB > valC && valB > valD && valB > valE && valB > valF ) return valB;
	else if ( valC > valA && valC > valB && valC > valD && valC > valE && valC > valF ) return valC;
	else if ( valD > valA && valD > valB && valD > valC && valD > valE && valD > valF ) return valD;
	else if ( valE > valA && valE > valB && valE > valC && valE > valD && valE > valF ) return valE;
	else return valF;
}

int Greater(int valA, int valB, int valC, int valD, int valE, int valF, int valG){
	if ( valA > valB && valA > valC && valA > valD && valA > valE && valA > valF && valA > valG) return valA;
	else if ( valB > valA && valB > valC && valB > valD && valB > valE && valB > valF && valB > valG ) return valB;
	else if ( valC > valA && valC > valB && valC > valD && valC > valE && valC > valF && valC > valG ) return valC;
	else if ( valD > valA && valD > valB && valD > valC && valD > valE && valD > valF && valD > valG ) return valD;
	else if ( valE > valA && valE > valB && valE > valC && valE > valD && valE > valF && valE > valG ) return valE;
	else if ( valF > valA && valF > valB && valF > valC && valF > valD && valF > valE && valF > valG ) return valF;
	else return valG;
}

int Greater(int valA, int valB, int valC, int valD, int valE, int valF, int valG, int valH){
	if ( valA > valB && valA > valC && valA > valD && valA > valE && valA > valF && valA > valG && valA > valH) return valA;
	else if ( valB > valA && valB > valC && valB > valD && valB > valE && valB > valF && valB > valG && valB > valH ) return valB;
	else if ( valC > valA && valC > valB && valC > valD && valC > valE && valC > valF && valC > valG && valC > valH) return valC;
	else if ( valD > valA && valD > valB && valD > valC && valD > valE && valD > valF && valD > valG && valD > valH ) return valD;
	else if ( valE > valA && valE > valB && valE > valC && valE > valD && valE > valF && valE > valG && valE > valH ) return valE;
	else if ( valF > valA && valF > valB && valF > valC && valF > valD && valF > valE && valF > valG && valF > valH ) return valF;
	else if ( valG > valA && valG > valB && valG > valC && valG > valD && valG > valE && valG > valF && valG > valH ) return valG;
	else return valH;
}

//Returns if arg valA is less than all other values passed. Overloaded to work with two, to eight values.
bool IsLess(int valA, int valB){
	if ( valA < valB ) return true;
	else return false;
}

bool IsLess(int valA, int valB, int valC){
	if ( valA < valB && valA < valC ) return true;
	else return false;
}

bool IsLess(int valA, int valB, int valC, int valD){
	if ( valA < valB && valA < valC && valA < valD) return true;
	else return false;
}

bool IsLess(int valA, int valB, int valC, int valD, int valE){
	if ( valA < valB && valA < valC && valA < valD && valA < valE) return true;
	else return false;
}


bool IsLess(int valA, int valB, int valC, int valD, int valE, int valF){
	if ( valA < valB && valA < valC && valA < valD && valA < valE && valA < valF) return true;
	else return false;
}

bool IsLess(int valA, int valB, int valC, int valD, int valE, int valF, int valG){
	if ( valA < valB && valA < valC && valA < valD && valA < valE && valA < valF && valA < valG) return true;
	else return false;
}

bool IsLess(int valA, int valB, int valC, int valD, int valE, int valF, int valG, int valH){
	if ( valA < valB && valA < valC && valA < valD && valA < valE && valA < valF && valA < valG && valA < valH) return true;
	else return false;
}

//Returns if arg valA is greater than all other values passed. Overloaded for two, to eight values.
bool IsMore(int valA, int valB){
	if ( valA > valB ) return true;
	else return false;
}

bool IsMore(int valA, int valB, int valC){
	if ( valA > valB && valA > valC ) return true;
	else return false;
}

bool IsMore(int valA, int valB, int valC, int valD){
	if ( valA > valB && valA > valC && valA > valD) return true;
	else return false;
}

bool IsMore(int valA, int valB, int valC, int valD, int valE){
	if ( valA > valB && valA > valC && valA > valD && valA > valE) return true;
	else return false;
}


bool IsMore(int valA, int valB, int valC, int valD, int valE, int valF){
	if ( valA > valB && valA > valC && valA > valD && valA > valE && valA > valF) return true;
	else return false;
}

bool IsMore(int valA, int valB, int valC, int valD, int valE, int valF, int valG){
	if ( valA > valB && valA > valC && valA > valD && valA > valE && valA > valF && valA > valG) return true;
	else return false;
}

bool IsMore(int valA, int valB, int valC, int valD, int valE, int valF, int valG, int valH){
	if ( valA > valB && valA > valC && valA > valD && valA > valE && valA > valF && valA > valG && valA > valH) return true;
	else return false;
}

//Returns the lowest value in an array
int Least(int arr){
	int val = 214747.9999;
	for ( int q = 0; q < SizeOfArray(arr); q++ ) {
		if ( arr[q] < val ) val = arr[q];
	}
	return val;
}

//Returns the highest value in an array
int Greatest(int arr){
	int val = -214747.9999;
	for ( int q = 0; q < SizeOfArray(arr); q++ ) {
		if ( arr[q] > val ) val = arr[q];
	}
	return val;
}

//Returns the index holding the lowest value in an array
//If the lowest value is present in two or more indices, this will return the lowest-numbered index of the set.
int LeastIndex(int arr){
	int val = 214747.9999;
	int index;
	for ( int q = 0; q < SizeOfArray(arr); q++ ) {
		if ( arr[q] < val ) { 
			val = arr[q];
			index = q;
		}
	}
	return index;
}

//Returns the index holding the highest value in an array
//If the highest value is present in two or more indices, this will return the lowest-numbered index of the set.
int GreatestIndex(int arr){
	int val = -214747.9999;
	int index;
	for ( int q = 0; q < SizeOfArray(arr); q++ ) {
		if ( arr[q] > val ) {
			val = arr[q];
			index = q;
		}
	}
	return index;
}


//Creates an item ont he screen at link's 
//position, giving it to him,a nd running its pick-up script.
//itm_id is the item ID number
//if holdtype is set to a Link->Action for holding up an item
//then Link will hold the item up as desired.
void GiveLinkItem(int itm_id, int holdtype){
    item i = Screen->CreateItem(itm_id);
    i->X = Link->X;
    i->Y = Link->Y;
    i->Z = Link->Z;
    if ( holdtype == LA_HOLD1LAND || holdtype == LA_HOLD2LAND || holdtype == LA_HOLD1WATER || holdtype == LA_HOLD2WATER ) {
        Link->HeldItem = itm_id;
        Link->Action = holdtype;
    }
}

//Creates an item ont he screen at link's 
//position, giving it to him,a nd running its pick-up script.
//itm_id is the item ID number
//Link does not hold up this item.
void GiveLinkItem(int itm_id){
    GiveLinkItem(itm_id,0);
}



//Constants for AdjacentCombo()

//const int CMB_UPLEFT    = 0;
//const int CMB_UP        = 1;
//const int CMB_UPRIGHT   = 2;
//const int CMB_RIGHT     = 3;
//const int CMB_DOWNRIGHT = 4;
//const int CMB_DOWN      = 5;
//const int CMB_DOWNLEFT  = 6;
//const int CMB_LEFT      = 7;
//const int CMB_LEFTUP    = 0; //Not 8, as those are dir + shield

//Returns the Nuth combo index of a combo based on a central point, and a direction.
//For example, combo 22 + COMBO_UPRIGHT returns '7', 
//as combo 7 is to the upper-right of combo 22.
int AdjacentCombo(int cmb, int dir){
    int combooffsets[13]={-0x10,-0x0F,-0x0E,1,0x10,0x0F,0x0E,-1,-0x10};
    if ( cmb % 16 == 0 ) combooffsets[9] = 1;
    if ( (cmb & 15) == 1 ) combooffsets[10] = 1;
    if ( cmb < 0x10 ) combooffsets[11] = 1;
    if ( cmb < 0xAF ) combooffsets[12] = 1;
    if ( combooffsets[9] && ( dir == CMB_LEFT || dir == CMB_UPLEFT || dir == CMB_DOWNLEFT || dir == CMB_LEFTUP ) ) return 0;
    if ( combooffsets[10] && ( dir == CMB_RIGHT || dir == CMB_UPRIGHT || dir == CMB_DOWNRIGHT ) ) return 0;
    if ( combooffsets[11] && ( dir == CMB_UP || dir == CMB_UPRIGHT || dir == CMB_UPLEFT || dir == CMB_DOWNLEFT ) ) return 0;
    if ( combooffsets[12] && ( dir == CMB_DOWN || dir == CMB_DOWNRIGHT || dir == CMB_DOWNLEFT ) ) return 0;
    else if ( cmb > 0 && cmb < 177 ) return cmb + combooffsets[dir];
    else return 0;
}
        


//Returns if two pointers are within a proximity of 'distance' in pixels.
//Link and an object (X-Axis)
bool DistX(int a, int distance) {
    int dist;
	if ( ComboX(a) > Link->X ) dist = ComboX(a) - Link->X;
	else dist = Link->X - ComboX(a);
    return ( dist <= distance );
} 
bool DistX(ffc a, int distance) {
    int dist;
    if ( a->X > Link->X ) dist = a->X - Link->X;
	else dist = Link->X - a->X;
    return ( dist <= distance );
} //Link to ffc distance
bool DistX(lweapon a, int distance) {
    int dist;
    if ( a->X > Link->X ) dist = a->X - Link->X;
	else dist = Link->X - a->X;
    return ( dist <= distance );
}
bool DistX(eweapon a, int distance) {
    int dist;
    if ( a->X > Link->X ) dist = a->X - Link->X;
	else dist = Link->X - a->X;
    return ( dist <= distance );
}
bool DistX(npc a, int distance) {
    int dist;
    if ( a->X > Link->X ) dist = a->X - Link->X;
	else dist = Link->X - a->X;
    return ( dist <= distance );
}
bool DistX(item a, int distance) {
    int dist;
    if ( a->X > Link->X ) dist = a->X - Link->X;
	else dist = Link->X - a->X;
    return ( dist <= distance );
}

//! The signature of this will clash with ProximityX(int a, int b)
//Link and an object (Y-Axis)
bool DistY(int a, int distance) {
    int dist;
	if ( ComboY(a) > Link->Y ) dist = ComboY(a) - Link->Y;
	else dist = Link->Y - ComboY(a);
    return ( dist <= distance );

}
bool DistY(ffc a, int distance) {
    int dist;
    if ( a->Y > Link->Y ) dist = a->Y - Link->Y;
	else dist = Link->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(lweapon a, int distance) {
    int dist;
    if ( a->Y > Link->Y ) dist = a->Y - Link->Y;
	else dist = Link->Y - a->Y;
    return ( dist <= distance );
}
bool DistY(eweapon a, int distance) {
    int dist;
    if ( a->Y > Link->Y ) dist = a->Y - Link->Y;
	else dist = Link->Y - a->Y;
    return ( dist <= distance );
}
bool DistY(npc a, int distance) {
    int dist;
    if ( a->Y > Link->Y ) dist = a->Y - Link->Y;
	else dist = Link->Y - a->Y;
    return ( dist <= distance );
}
bool DistY(item a, int distance) {
    int dist;
    if ( a->Y > Link->Y ) dist = a->Y - Link->Y;
	else dist = Link->Y - a->Y;
    return ( dist <= distance );
}


//Returns if two pointers are within a proximity of 'distance' in pixels.
//Two objects (X-Axis)

//X (combo)
bool DistX(int a, int b, int distance) {
	int dist;
	if ( ComboX(a) > ComboX(b) ) dist = ComboX(a) - ComboX(b);
	else dist = ComboX(b) - ComboX(a);
	return ( dist <= distance );
}
bool DistX(int a, ffc b, int distance) {
    int dist;
    if ( b->X > ComboX(a) ) dist = b->X - ComboX(a);
	else dist = ComboX(a) - b->X;
    return ( dist <= distance );
}
bool DistX(int a, lweapon b, int distance) {
    int dist;
    if ( b->X > ComboX(a) ) dist = b->X - ComboX(a);
	else dist = ComboX(a) - b->X;
    return ( dist <= distance );
} 
bool DistX(int a, eweapon b, int distance) {
    int dist;
    if ( b->X > ComboX(a) ) dist = b->X - ComboX(a);
	else dist = ComboX(a) - b->X;
    return ( dist <= distance );
} 
bool DistX(int a, npc b, int distance) {
    int dist;
    if ( b->X > ComboX(a) ) dist = b->X - ComboX(a);
	else dist = ComboX(a) - b->X;
    return ( dist <= distance );
} 
bool DistX(int a, item b, int distance) {
    int dist;
    if ( b->X > ComboX(a) ) dist = b->X - ComboX(a);
	else dist = ComboX(a) - b->X;
    return ( dist <= distance );
}

//X (ffc)
bool DistX(ffc a, int b, int distance) {
    int dist;
    if ( a->X > ComboX(b) ) dist = a->X - ComboX(b);
	else dist = ComboX(b) - a->X;
    return ( dist <= distance );
}
bool DistX(ffc a, ffc b, int distance) {
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(ffc a, lweapon b, int distance) {
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(ffc a, eweapon b, int distance) {
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(ffc a, npc b, int distance) {
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(ffc a, item b, int distance) {
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 

//X (lweapon)
bool DistX(lweapon a, int b, int distance) {
    int dist;
    if ( a->X > ComboX(b) ) dist = a->X - ComboX(b);
	else dist = ComboX(b) - a->X;
    return ( dist <= distance );
} 
bool DistX(lweapon a, ffc b, int distance) {    
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(lweapon a, lweapon b, int distance) {    
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(lweapon a, eweapon b, int distance) {    
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(lweapon a, npc b, int distance) {    
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(lweapon a, item b, int distance) {    
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 

//X (eweapon)

bool DistX(eweapon a, int b, int distance) {    
    int dist;
    if ( a->X > ComboX(b) ) dist = a->X - ComboX(b);
	else dist = ComboX(b) - a->X;
    return ( dist <= distance );
}

bool DistX(eweapon a, ffc b, int distance) {    
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(eweapon a, lweapon b, int distance) {    
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(eweapon a, eweapon b, int distance) {    
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(eweapon a, npc b, int distance) {    
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(eweapon a, item b, int distance) {    
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 

//X (npc)
bool DistX(npc a, int b, int distance) {    
    int dist;
    if ( a->X > ComboX(b) ) dist = a->X - ComboX(b);
	else dist = ComboX(b) - a->X;
    return ( dist <= distance );
}
bool DistX(npc a, ffc b, int distance) {
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(npc a, lweapon b, int distance) {
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(npc a, eweapon b, int distance) {
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(npc a, npc b, int distance) {
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(npc a, item b, int distance) {
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 

//X (item)
bool DistX(item a, int b, int distance) {
    int dist;
    if ( a->X > ComboX(b) ) dist = a->X - ComboX(b);
	else dist = ComboX(b) - a->X;
    return ( dist <= distance );
}
bool DistX(item a, ffc b, int distance) {
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(item a, lweapon b, int distance) {
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(item a, eweapon b, int distance) {
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(item a, npc b, int distance) {    
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(item a, item b, int distance) {
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 

//Two objects (Y-Axis)

//Y (combo)
bool DistY(int a, int b, int distance) {
    int dist;
	if ( ComboY(a) > ComboY(b) ) dist = ComboY(a) - ComboY(b);
	else dist = ComboY(b) - ComboY(a);
    return ( dist <= distance );
}
bool DistY(int a, ffc b, int distance) {
    int dist;
    if ( b->Y > ComboY(a) ) dist = b->Y - ComboY(a);
	else dist = ComboY(a) - b->Y;
    return ( dist <= distance );
}
bool DistY(int a, lweapon b, int distance) {
    int dist;
    if ( b->Y > ComboY(a) ) dist = b->Y - ComboY(a);
	else dist = ComboY(a) - b->Y;
    return ( dist <= distance );
} 
bool DistY(int a, eweapon b, int distance) {
    int dist;
    if ( b->Y > ComboY(a) ) dist = b->Y - ComboY(a);
	else dist = ComboY(a) - b->Y;
    return ( dist <= distance );
} 
bool DistY(int a, npc b, int distance) {
    int dist;
    if ( b->Y > ComboY(a) ) dist = b->Y - ComboY(a);
	else dist = ComboY(a) - b->Y;
    return ( dist <= distance );
} 
bool DistY(int a, item b, int distance) {
    int dist;
    if ( b->Y > ComboY(a) ) dist = b->Y - ComboY(a);
	else dist = ComboY(a) - b->Y;
    return ( dist <= distance );
}

bool DistY(ffc a, int b, int distance) {
    int dist;
    if ( a->Y > ComboY(b) ) dist = a->Y - ComboY(b);
	else dist = ComboY(b) - a->Y;
    return ( dist <= distance );
}

//Y (ffc)
bool DistY(ffc a, ffc b, int distance) {
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(ffc a, lweapon b, int distance) {
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(ffc a, eweapon b, int distance) {
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(ffc a, npc b, int distance) {
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(ffc a, item b, int distance) {
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 

//Y (lweapon)
bool DistY(lweapon a, int b, int distance) {
    int dist;
    if ( a->Y > ComboY(b) ) dist = a->Y - ComboY(b);
	else dist = ComboY(b) - a->Y;
    return ( dist <= distance );
} 
bool DistY(lweapon a, ffc b, int distance) {    
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(lweapon a, lweapon b, int distance) {    
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(lweapon a, eweapon b, int distance) {    
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(lweapon a, npc b, int distance) {    
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(lweapon a, item b, int distance) {    
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 

//Y (eweapon)
bool DistY(eweapon a, int b, int distance) {    
    int dist;
    if ( a->Y > ComboY(b) ) dist = a->Y - ComboY(b);
	else dist = ComboY(b) - a->Y;
    return ( dist <= distance );
}
bool DistY(eweapon a, ffc b, int distance) {    
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(eweapon a, lweapon b, int distance) {    
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(eweapon a, eweapon b, int distance) {    
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(eweapon a, npc b, int distance) {    
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(eweapon a, item b, int distance) {    
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 

//Y (npc)
bool DistY(npc a, int b, int distance) {    
    int dist;
    if ( a->Y > ComboY(b) ) dist = a->Y - ComboY(b);
	else dist = ComboY(b) - a->Y;
    return ( dist <= distance );
}
bool DistY(npc a, ffc b, int distance) {
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(npc a, lweapon b, int distance) {
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(npc a, eweapon b, int distance) {
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(npc a, npc b, int distance) {
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(npc a, item b, int distance) {
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 

//Y (item)
bool DistY(item a, int b, int distance) {
int dist;
    if ( a->Y > ComboY(b) ) dist = a->Y - ComboY(b);
	else dist = ComboY(b) - a->Y;
    return ( dist <= distance );
}
bool DistY(item a, ffc b, int distance) {
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(item a, lweapon b, int distance) {
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(item a, eweapon b, int distance) {
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(item a, npc b, int distance) {    
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(item a, item b, int distance) {
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 

//21-March
//Advanced tracing

//Traces a float, or int; whether a variable, an internal variable, array index, or other
//along with a given string in one function.
void TraceStr(int string, int value){
    TraceNL(); TraceS(string); Trace(value); TraceNL();
}

//This is where having char would be nice.

//As TraceStr, but for boolean values.
void TraceStrB(int string, bool val){
    TraceNL(); TraceS(string); TraceB(val); TraceNL();
}

//June 2016

//Returns if Link is facing an object. 
bool LinkFacing(ffc f){
	if ( Link->Dir == DIR_UP && Link->Y < f->Y ) return true;
	if ( Link->Dir == DIR_DOWN && Link->Y > f->Y ) return true;
	if ( Link->Dir == DIR_RIGHT && Link->X < f->X ) return true;
	if ( Link->Dir == DIR_LEFT && Link->X > f->X ) return true;
	return false;
}


bool LinkFacing(npc f){
	if ( Link->Dir == DIR_UP && Link->Y < f->Y ) return true;
	if ( Link->Dir == DIR_DOWN && Link->Y > f->Y ) return true;
	if ( Link->Dir == DIR_RIGHT && Link->X < f->X ) return true;
	if ( Link->Dir == DIR_LEFT && Link->X > f->X ) return true;
	return false;
}


bool LinkFacing(lweapon f){
	if ( Link->Dir == DIR_UP && Link->Y < f->Y ) return true;
	if ( Link->Dir == DIR_DOWN && Link->Y > f->Y ) return true;
	if ( Link->Dir == DIR_RIGHT && Link->X < f->X ) return true;
	if ( Link->Dir == DIR_LEFT && Link->X > f->X ) return true;
	return false;
}


bool LinkFacing(eweapon f){
	if ( Link->Dir == DIR_UP && Link->Y < f->Y ) return true;
	if ( Link->Dir == DIR_DOWN && Link->Y > f->Y ) return true;
	if ( Link->Dir == DIR_RIGHT && Link->X < f->X ) return true;
	if ( Link->Dir == DIR_LEFT && Link->X > f->X ) return true;
	return false;
}


bool LinkFacing(item f){
	if ( Link->Dir == DIR_UP && Link->Y < f->Y ) return true;
	if ( Link->Dir == DIR_DOWN && Link->Y > f->Y ) return true;
	if ( Link->Dir == DIR_RIGHT && Link->X < f->X ) return true;
	if ( Link->Dir == DIR_LEFT && Link->X > f->X ) return true;
	return false;
}

bool LinkFacing(int combo_pos){
	int posX = ComboX(combo_pos);
	int posY = ComboY(combo_pos);
	if ( Link->Dir == DIR_UP && Link->Y < posY ) return true;
	if ( Link->Dir == DIR_DOWN && Link->Y > posY ) return true;
	if ( Link->Dir == DIR_RIGHT && Link->X < posX ) return true;
	if ( Link->Dir == DIR_LEFT && Link->X > posX ) return true;
	return false;
}

