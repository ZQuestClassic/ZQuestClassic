// std.zh
// Standard header for ZScript.
// Please don't edit this file. Instead, create a new header file for your
// quests' scripts,  add constants and procedures to that file,
// and import it separately.

const float PI						= 3.1416;
const float PI2						= 6.2832;
const float E						= 2.7183;

const int NULL						= 0;

const float MAX_CONSTANT			= 214747.9999;
//const float MAX_VARIABLE			= 214748.3648; Obviously this is truncated as a constant. Equal to ((2^31)-1)/10000
const int MAX_BITSPERVARIABLE		= 18;
const int MAX_SCRIPTDRAWINGCOMMANDS	= 1000;

const int HP_PER_HEART				= 16;
const int MP_PER_BLOCK				= 32;

const int MAX_MESSAGES				= 65535;
const int MAX_MESSAGELENGTH			= 145; //Pass an array of (at least) this size to Game->GetMessage

const int MAX_DMAPS					= 512;
const int MAX_DMAPNAMELENGTH		= 21; //Size of arrays to pass to Game->GetDMapX
const int MAX_DMAPTITLELENGTH		= 21;
const int MAX_DMAPINTROLENGTH		= 73;

//Defaults from Init Data
const float GRAVITY					= 0.16;
const float TERMINAL_VELOCITY		= 3.20;
const int JUMPING_LAYER_THRESHOLD	= 16;

//Sound effect IDs. To be used for PlaySound().
const int SFX_ARROW       = 1; // Arrow is fired.
const int SFX_BEAM        = 2; // Sword beam is fired.
const int SFX_BOMB        = 3; // Bomb explodes.
const int SFX_BRANG       = 4; // Boomerang spinning.
const int SFX_CHARGE1     = 35; // Sword powering up.
const int SFX_CHARGE2     = 36; // Sword powering up again (Hurricane Spin).
const int SFX_CURSOR      = 5; // Subscreen cursor.
const int SFX_CLINK       = 6; // Shield is hit.
const int SFX_CLEARED     = 7; // Chime when screen item appears.
const int SFX_DINSFIRE    = 37; // Din's Fire blast.
const int SFX_DODONGO     = 8; // Dodongo's roar.
const int SFX_SHUTTER     = 9; // Shutter bang.
const int SFX_EDEAD       = 10; // Enemy is killed.
const int SFX_EHIT        = 11; // Enemy is hit.
const int SFX_LOWHP       = 12; // Low hearts warning beep.
const int SFX_FALL        = 38; // Enemy falls from ceiling (unused).
const int SFX_FARORESWIND = 39; // Farore's Wind spell.
const int SFX_FIRE        = 13; // Flame roar.
const int SFX_FIREBALL    = 40; // Enemy fireball.
const int SFX_GANON       = 14; // Music when Ganon appears/dies.
const int SFX_GASP        = 15; // Boss is hit.
const int SFX_GRASSCUT    = 41; // Grass or bush slashed.
const int SFX_HAMMER      = 16; // Hammer pound.
const int SFX_HAMMERPOST  = 42; // Pounded a post.
const int SFX_HOOKSHOT    = 17; // Hookshot chain rattle.
const int SFX_HOVER       = 43; // Hover boots.
const int SFX_ICE         = 44; // Unused.
const int SFX_JUMP        = 45; // Jumping.
const int SFX_LENSOFF     = 46; // Lens of Truth off.
const int SFX_LENSON      = 47; // Lens of Truth on.
const int SFX_MSG         = 18; // Message typing.
const int SFX_NAYRUSLOVE1 = 48; // Nayru's Love shield hum.
const int SFX_NAYRUSLOVE2 = 49; // Nayru's Love shield running out.
const int SFX_OUCH        = 19; // Link is hit.
const int SFX_PICKUP      = 20; // Chime when item is held above head.
const int SFX_PLACE       = 21; // Bomb is placed.
const int SFX_PLINK       = 22; // Heart/Rupee is collected.
const int SFX_PUSHBLOCK   = 50; // Pushed a block.
const int SFX_REFILL      = 23; // Hearts being refilled.
const int SFX_ROAR        = 24; // Aquamentus, Gleeok and Ganon's roar.
const int SFX_ROCK        = 51; // Octorok rock is fired.
const int SFX_ROCKETDOWN  = 52; // Spell rocket descends.
const int SFX_ROCKETUP    = 53; // Spell rocket launched.
const int SFX_SCALE       = 25; // Chime when fairy appears/is picked up.
const int SFX_SEA         = 26; // "Ocean SFX" ambience.
const int SFX_SECRET      = 27; // Chime when secret is discovered.
const int SFX_SPINATTACK  = 54; // Sword spin.
const int SFX_SPIRAL      = 28; // Link dies.
const int SFX_SPLASH      = 55; // Splashing in shallow water.
const int SFX_STAIRS      = 29; // Link marches down stairs.
const int SFX_SUMMON      = 56; // Summoner magic.
const int SFX_SWORD       = 30; // Sword swipe.
const int SFX_TAP1        = 57; // Sword taps wall.
const int SFX_TAP2        = 58; // Sword taps bombable wall.
const int SFX_PATRA       = 31; // Patra and Manhandla's shriek.
const int SFX_WAND        = 32; // Magic is fired by Wizzrobes or Link.
const int SFX_WHIRLWIND   = 59; // Whistle whirlwind.
const int SFX_WHISTLE     = 33; // Whistle is played.
const int SFX_ZELDA       = 34; // Music when ending sequence begins.

//Item class ids. Use as comparisons with Itemdata->Family
const int IC_AMULET             = 11;
const int IC_ARROW              = 2;
const int IC_ARROWAMMO          = 40;
const int IC_BAIT               = 5;
const int IC_BOMB               = 27;
const int IC_BOMBAMMO           = 47;
const int IC_BOMBBAG            = 48;
const int IC_BOOK               = 16;
const int IC_BOOTS              = 20;
const int IC_BOSSKEY            = 35;
const int IC_BOW                = 13;
const int IC_BOWANDARROW        = 87;
const int IC_BRACELET           = 18;
const int IC_BRANG              = 1;
const int IC_CANDLE             = 3;
const int IC_CBYRNA             = 38;
const int IC_CHARGERING         = 55;
const int IC_CLOCK              = 29;
const int IC_COMPASS            = 34;
const int IC_CROSSSCROLL        = 52;
const int IC_DINSFIRE           = 24;
const int IC_FAIRY              = 41;
const int IC_FARORESWIND        = 25;
const int IC_FLIPPERS           = 19;
const int IC_HAMMER             = 23;
const int IC_HEART              = 43;
const int IC_HEARTCONTAINER     = 44;
const int IC_HEARTPIECE         = 45;
const int IC_HEARTRING          = 58;
const int IC_HOOKSHOT           = 21;
const int IC_HOVERBOOTS         = 50;
const int IC_HURRICANESCROLL    = 60;
const int IC_KEY                = 30;
const int IC_KILLALL            = 46;
const int IC_LADDER             = 15;
const int IC_LENS               = 22;
const int IC_LETTER             = 6;
const int IC_LETTERPOTION       = 88;
const int IC_LEVELKEY           = 37;
const int IC_MAGIC              = 42;
const int IC_MAGICCONTAINER     = 31;
const int IC_MAGICKEY           = 17;
const int IC_MAGICRING          = 59;
const int IC_MAP                = 33;
const int IC_MISC               = 66;
const int IC_NAYRUSLOVE         = 26;
const int IC_PERILRING          = 65;
const int IC_PERILSCROLL        = 56;
const int IC_POTION             = 7;
const int IC_QUAKESCROLL        = 53;
const int IC_QUIVER             = 36;
const int IC_RAFT               = 14;
const int IC_RING               = 9;
const int IC_ROCS               = 49;
const int IC_RUPEE              = 39;
const int IC_SBOMB              = 28;
const int IC_SHIELD             = 12;
const int IC_SPINSCROLL         = 51;
const int IC_SQUAKESCROLL       = 61;
const int IC_STOMPBOOTS         = 63;
const int IC_STONEAGONY         = 62;
const int IC_SWORD              = 0;
const int IC_TRIFORCE           = 32;
const int IC_WALLET             = 10;
const int IC_WAND               = 8;
const int IC_WEALTHMEDAL        = 57;
const int IC_WHIMSICALRING      = 64;
const int IC_WHISPRING          = 54;
const int IC_WHISTLE            = 4;

const int IC_CUSTOM1            = 67;
const int IC_CUSTOM2            = 68;
const int IC_CUSTOM3            = 69;
const int IC_CUSTOM4            = 70;
const int IC_CUSTOM5            = 71;
const int IC_CUSTOM6            = 72;
const int IC_CUSTOM7            = 73;
const int IC_CUSTOM8            = 74;
const int IC_CUSTOM9            = 75;
const int IC_CUSTOM10           = 76;
const int IC_CUSTOM11           = 77;
const int IC_CUSTOM12           = 78;
const int IC_CUSTOM13           = 79;
const int IC_CUSTOM14           = 80;
const int IC_CUSTOM15           = 81;
const int IC_CUSTOM16           = 82;
const int IC_CUSTOM17           = 83;
const int IC_CUSTOM18           = 84;
const int IC_CUSTOM19           = 85;
const int IC_CUSTOM20           = 86;


//Item IDs. Use with CreateItem() and Link->Item[].
//These are DEFAULT values, and may not be correct for custom quests which
//have overridden item action data.
const int I_AMULET1             = 50;
const int I_AMULET2             = 63;
const int I_ARROW1              = 13;
const int I_ARROW2              = 14;
const int I_ARROW3              = 57;
const int I_ARROWAMMO1          = 70;
const int I_ARROWAMMO10         = 72;
const int I_ARROWAMMO30         = 73;
const int I_ARROWAMMO5          = 71;
const int I_BAIT                = 16;
const int I_BOMB                = 3;
const int I_BOMBAMMO1           = 77;
const int I_BOMBAMMO30          = 80;
const int I_BOMBAMMO4           = 78;
const int I_BOMBAMMO8           = 79;
const int I_BOMBBAG1            = 81;
const int I_BOMBBAG2            = 82;
const int I_BOMBBAG3            = 83;
const int I_BOMBBAG4            = 106;
const int I_BOOK                = 32;
const int I_BOOTS               = 55;
const int I_BOSSKEY             = 67;
const int I_BOW1                = 15;
const int I_BOW2                = 68;
const int I_BRACELET1           = 107;
const int I_BRACELET2           = 19;
const int I_BRACELET3           = 56;
const int I_BRANG1              = 23;
const int I_BRANG2              = 24;
const int I_BRANG3              = 35;
const int I_CANDLE1             = 10;
const int I_CANDLE2             = 11;
const int I_CBYRNA              = 88;
const int I_CHARGERING1         = 101;
const int I_CHARGERING2         = 102;
const int I_CLOCK               = 4;
const int I_COMPASS             = 22;
const int I_CROSSSCROLL         = 95;
const int I_DINSFIRE            = 64;
const int I_DUST_PILE           = 43;
const int I_FAIRY               = 34;
const int I_FAIRYSTILL          = 69;
const int I_FARORESWIND         = 65;
const int I_FLIPPERS            = 51;
const int I_HAMMER              = 54;
const int I_HCPIECE             = 49;
const int I_HEART               = 2;
const int I_HEARTCONTAINER      = 28;
const int I_HEARTRING1          = 112;
const int I_HEARTRING2          = 113;
const int I_HEARTRING3          = 114;
const int I_HOOKSHOT1           = 52;
const int I_HOOKSHOT2           = 89;
const int I_HOVERBOOTS          = 92;
const int I_KEY                 = 9;
const int I_KILLALL             = 62;
const int I_LADDER1             = 27;
const int I_LADDER2             = 108;
const int I_LENS                = 53;
const int I_LETTER              = 12;
const int I_LETTERUSED          = 90;
const int I_LEVELKEY            = 84;
const int I_MAGICCONTAINER      = 58;
const int I_MAGICJAR1           = 59;
const int I_MAGICJAR2           = 60;
const int I_MAGICKEY            = 33;
const int I_MAGICRING1          = 115;
const int I_MAGICRING2          = 116;
const int I_MAGICRING3          = 117;
const int I_MAGICRING4          = 118;
const int I_MAP                 = 21;
const int I_MISC1               = 46;
const int I_MISC2               = 47;
const int I_NAYRUSLOVE          = 66;
const int I_PERILRING           = 121;
const int I_PERILSCROLL         = 103;
const int I_POTION1             = 29;
const int I_POTION2             = 30;
const int I_QUAKESCROLL1        = 96;
const int I_QUAKESCROLL2        = 97;
const int I_QUIVER1             = 74;
const int I_QUIVER2             = 75;
const int I_QUIVER3             = 76;
const int I_QUIVER4             = 105;
const int I_RAFT                = 26;
const int I_RING1               = 17;
const int I_RING2               = 18;
const int I_RING3               = 61;
const int I_ROCSFEATHER         = 91;
const int I_RUPEE1              = 0;
const int I_RUPEE10             = 86;
const int I_RUPEE100            = 87;
const int I_RUPEE20             = 38;
const int I_RUPEE200            = 40;
const int I_RUPEE5              = 1;
const int I_RUPEE50             = 39;
const int I_SBOMB               = 48;
const int I_SELECTA             = 45;
const int I_SELECTB             = 85;
const int I_SHIELD1             = 93;
const int I_SHIELD2             = 8;
const int I_SHIELD3             = 37;
const int I_SPINSCROLL1         = 94;
const int I_SPINSCROLL2         = 98;
const int I_STOMPBOOTS          = 120;
const int I_STONEAGONY          = 119;
const int I_SWORD1              = 5;
const int I_SWORD2              = 6;
const int I_SWORD3              = 7;
const int I_SWORD4              = 36;
const int I_TRIFORCE            = 20;
const int I_TRIFORCEBIG         = 44;
const int I_WALLET500           = 41;
const int I_WALLET999           = 42;
const int I_WALLETA             = 104;
const int I_WAND                = 25;
const int I_WEALTHMEDAL         = 109;
const int I_WEALTHMEDAL2        = 110;
const int I_WEALTHMEDAL3        = 111;
const int I_WHIMSICALRING       = 122;
const int I_WHISPRING1          = 99;
const int I_WHISPRING2          = 100;
const int I_WHISTLE             = 31;

//Link actions
const int LA_NONE               = 0;
const int LA_WALKING            = 1;
const int LA_ATTACKING          = 2;
const int LA_FROZEN             = 3;
const int LA_HOLD1LAND          = 4; // One hand.
const int LA_HOLD2LAND          = 5; // Both hands.
const int LA_RAFTING            = 6;
const int LA_GOTHURTLAND        = 7;
const int LA_INWIND             = 8;
const int LA_SCROLLING          = 9;
const int LA_WINNING            = 10;
const int LA_SWIMMING           = 11;
const int LA_HOPPING            = 12; // Leaving water.
const int LA_GOTHURTWATER       = 13;
const int LA_HOLD1WATER         = 14;
const int LA_HOLD2WATER         = 15;
const int LA_CASTING            = 16; // Casting a spell.
const int LA_CAVEWALKUP         = 17;
const int LA_CAVEWALKDOWN       = 18;
const int LA_DYING              = 19;
const int LA_DROWNING           = 20;
const int LA_CHARGING           = 22; // Charging the sword.
const int LA_SPINNING           = 23; // Spin attack.
const int LA_DIVING             = 24;

//NPC Types. Compare against npc->Type.
const int NPCT_GUY			= 0;
const int NPCT_WALK			= 1;
const int NPCT_TEKTITE			= 3;
const int NPCT_LEEVER			= 4;
const int NPCT_PEAHAT			= 5;
const int NPCT_ZORA			= 6;
const int NPCT_ROCK			= 7;
const int NPCT_GHINI			= 8;
const int NPCT_ARMOS			= 9;
const int NPCT_KEESE			= 10;
const int NPCT_TRAP			= 15;
const int NPCT_WALLMASTER		= 16;
const int NPCT_WIZZROBE			= 21;
const int NPCT_AQUAMENTUS		= 22;
const int NPCT_MOLDORM			= 23;
const int NPCT_DODONGO			= 24;
const int NPCT_MANHANDLA		= 25;
const int NPCT_GLEEOK			= 26;
const int NPCT_DIGDOGGER		= 27;
const int NPCT_GOHMA			= 28;
const int NPCT_LANMOLA			= 29;
const int NPCT_PATRA			= 30;
const int NPCT_GANON			= 31;
const int NPCT_PROJECTILE		= 32;
const int NPCT_SPINTILE			= 37;
const int NPCT_NONE			= 38;
const int NPCT_FAIRY			= 39;
const int NPCT_OTHERFLOAT		= 40;
const int NPCT_OTHER			= 41;

//Guy IDs. Use with CreateNPC().
const int NPC_ABEI              = 1;
const int NPC_AMA               = 2;
const int NPC_MERCHANT          = 3;
const int NPC_MOBLIN            = 4;
const int NPC_FIRE              = 5;
const int NPC_FAIRY             = 6;
const int NPC_GORIYA            = 7;
const int NPC_ZELDA             = 8;
const int NPC_ABEI2             = 9;

//Default enemy IDs. Use with CreateNPC().
const int NPC_AQUAMENTUSL       = 93;
const int NPC_AQUAMENTUSR       = 58;
const int NPC_ARMOS             = 37;
const int NPC_BAT               = 106;
const int NPC_BOMBCHU           = 160;
const int NPC_BOULDER           = 135;
const int NPC_BUBBLEITEMP       = 118;	// Permanently jinxes
const int NPC_BUBBLEITEMR       = 119;	// Restores item usage
const int NPC_BUBBLEITEMT       = 117;
const int NPC_BUBBLESWORDP      = 81;  // Permanently jinxes
const int NPC_BUBBLESWORDR      = 82;  // Restores sword usage
const int NPC_BUBBLESWORDT      = 51;
const int NPC_CEILINGMASTER     = 101; // This enemy isn't implemented
const int NPC_DARKNUT1          = 49;
const int NPC_DARKNUT2          = 50;
const int NPC_DARKNUT3          = 92;	// Splits when killed.
const int NPC_DARKNUT4          = 172;  // This enemy isn't implemented
const int NPC_DARKNUT5          = 87;   // Sword beams.
const int NPC_DIGDOGGER1        = 66; // Splits into 1
const int NPC_DIGDOGGER3        = 67; // Splits into 3
const int NPC_DIGKID1           = 68; // Spawned by NPC_DIGDOGGER1
const int NPC_DIGKID2           = 69; // Spawned by NPC_DIGDOGGER3
const int NPC_DIGKID3           = 70; // Spawned by NPC_DIGDOGGER3
const int NPC_DIGKID4           = 71; // Spawned by NPC_DIGDOGGER3
const int NPC_DODONGO           = 60; // Uses one tile when walking vertically
const int NPC_DODONGOBS         = 114; // Uses two tiles when walking vertically
const int NPC_DODONGOFIRE       = 115; // This enemy isn't implemented
const int NPC_ENEMYFIRE         = 85;  // The Fire enemy in Princess Zelda's screen
const int NPC_FLOORMASTER       = 102; // This enemy isn't implemented
const int NPC_GANON             = 78;
const int NPC_GEL               = 42;
const int NPC_GELFIRE           = 161;
const int NPC_GELFIRETRIB       = 163;
const int NPC_GELTRIB           = 88;
const int NPC_GHINI1            = 35;
const int NPC_GHINI2            = 36;
const int NPC_GHINIMGC          = 173; // This enemy isn't implemented
const int NPC_GIBDO             = 54;
const int NPC_GLEEOK1           = 62;
const int NPC_GLEEOK1FIRE       = 109;
const int NPC_GLEEOK2           = 63;
const int NPC_GLEEOK2FIRE       = 110;
const int NPC_GLEEOK3           = 64;
const int NPC_GLEEOK3FIRE       = 111;
const int NPC_GLEEOK4           = 65;
const int NPC_GLEEOK4FIRE       = 112;
const int NPC_GOHMA1            = 72;
const int NPC_GOHMA2            = 73;
const int NPC_GOHMA3            = 121;
const int NPC_GOHMAFIRE         = 122;
const int NPC_GORIYA1           = 45;
const int NPC_GORIYA2           = 46;
const int NPC_GORIYA3           = 136;
const int NPC_GRAPBUGHP         = 174; // This enemy isn't implemented
const int NPC_GRAPBUGMP         = 175; // This enemy isn't implemented
const int NPC_ITEMFAIRY         = 84;
const int NPC_KEESE1            = 38;
const int NPC_KEESE2            = 39;
const int NPC_KEESE3            = 40;
const int NPC_KEESETRIB         = 90;
const int NPC_LANMOLA1          = 74;
const int NPC_LANMOLA2          = 75;
const int NPC_LEEVER1           = 26;
const int NPC_LEEVER2           = 27;
const int NPC_LEEVER3           = 137;
const int NPC_LIKELIKE          = 53;
const int NPC_LYNEL1            = 30;
const int NPC_LYNEL2            = 31;
const int NPC_LYNEL3            = 168;
const int NPC_MANHANDLA         = 61;
const int NPC_MANHANDLA2        = 94;
const int NPC_MOBLIN1           = 28;
const int NPC_MOBLIN2           = 29;
const int NPC_MOLDORM           = 59;
const int NPC_OCTOROCK1F        = 22;
const int NPC_OCTOROCK1S        = 20;
const int NPC_OCTOROCK2F        = 23;
const int NPC_OCTOROCK2S        = 21;
const int NPC_OCTOROCKBOMBF     = 141;
const int NPC_OCTOROCKBOMBS     = 140;
const int NPC_OCTOROCKFIREF     = 139;
const int NPC_OCTOROCKFIRES     = 138;
const int NPC_OCTOROCKMGC       = 86;
const int NPC_PATRA1            = 76;
const int NPC_PATRA2            = 104;
const int NPC_PATRA3            = 105;
const int NPC_PATRABS           = 103;
const int NPC_PATRAOVAL         = 77;
const int NPC_PEAHAT            = 32;
const int NPC_PEAHATFIRE        = 169; // This enemy isn't implemented
const int NPC_POLSVOICE         = 55;
const int NPC_POLSVOICEBS       = 171; // This enemy isn't implemented
const int NPC_POLSVOICEMGC      = 170;
const int NPC_ROCK              = 34;
const int NPC_ROPE1             = 44;
const int NPC_ROPE2             = 80;
const int NPC_SHOOTFBALL        = 83;
const int NPC_SHOOTFLAME        = 158;
const int NPC_SHOOTFLAME2       = 159;
const int NPC_SHOOTMAGIC        = 154;
const int NPC_SHOOTROCK         = 155;
const int NPC_SHOOTSPEAR        = 156;
const int NPC_SHOOTSWORD        = 157;
const int NPC_SPINTILE          = 166;
const int NPC_SPINTILERND       = 167; // Random spin tile
const int NPC_STALFOS1          = 41;
const int NPC_STALFOS2          = 79;
const int NPC_STALFOS3          = 120;
const int NPC_TEKTITE1          = 24;
const int NPC_TEKTITE2          = 25;
const int NPC_TEKTITE3          = 165; // This enemy isn't implemented
const int NPC_TRAP              = 47;
const int NPC_TRAP8WAY          = 142;  // This enemy isn't implemented
const int NPC_TRAPBACKSLASHC    = 146;	// This enemy isn't implemented
const int NPC_TRAPBACKSLASHLOS  = 147; // This enemy isn't implemented
const int NPC_TRAPCCLOCKWISEC   = 150; // This enemy isn't implemented
const int NPC_TRAPCCLOCKWISELOS = 151; // This enemy isn't implemented
const int NPC_TRAPCLOCKWISEC    = 148; // This enemy isn't implemented
const int NPC_TRAPCLOCKWISELOS  = 149; // This enemy isn't implemented
const int NPC_TRAPDIAG          = 143; // This enemy isn't implemented
const int NPC_TRAPHORIZC        = 97;
const int NPC_TRAPHORIZLOS      = 95;
const int NPC_TRAPSLASHC        = 144;	// This enemy isn't implemented
const int NPC_TRAPSLASHLOS      = 145;
const int NPC_TRAPVERTC         = 98;
const int NPC_TRAPVERTLOS       = 96;
const int NPC_TRIGGER           = 116;
const int NPC_VIRE              = 52;
const int NPC_VIRETRIB          = 91;
const int NPC_WALLMASTER        = 48;
const int NPC_WIZZROBE1         = 56; // Teleports
const int NPC_WIZZROBE2         = 57; // Phases through blocks
const int NPC_WIZZROBEBAT       = 107;
const int NPC_WIZZROBEBAT2      = 108; // This enemy isn't implemented
const int NPC_WIZZROBEFIRE      = 99;
const int NPC_WIZZROBEICE       = 153; // This enemy isn't implemented
const int NPC_WIZZROBEMIRR      = 113;
const int NPC_WIZZROBESUMM      = 152;
const int NPC_WIZZROBEWIND      = 100;
const int NPC_ZOL               = 43;
const int NPC_ZOLFIRE           = 162;
const int NPC_ZOLFIRETRIB       = 164;
const int NPC_ZOLTRIB           = 89;
const int NPC_ZORA              = 33;

//NPC hit point values. Use with npc->HP to make the enemy die in a special manner.
const int HP_SILENT = -1000;  // The enemy will die without their Death Sound playing.

//LWeapon types. Use with Screen->CreateLWeapon() and Screen->LoadLWeapon().
const int LW_SWORD              = 1; // This cannot be created
const int LW_WAND               = 12; // This cannot be created
const int LW_CANDLE             = 12; // This cannot be created
const int LW_HAMMER             = 19; // This cannot be created
const int LW_HOOKSHOT           = 20; // This cannot be created
const int LW_CANEOFBYRNA        = 27; // This cannot be created
const int LW_ARROW              = 8;
const int LW_BEAM               = 2; // Sword beam
const int LW_BRANG              = 3;
const int LW_BOMB               = 6;
const int LW_BOMBBLAST          = 4; // Bomb explosion
const int LW_SBOMB              = 7;
const int LW_SBOMBBLAST         = 5; // Super Bomb explosion
const int LW_FIRE               = 9;
const int LW_WHISTLE            = 10; // Whistle music - kills Digdogger
const int LW_BAIT               = 11;
const int LW_MAGIC              = 13; // Wand magic
const int LW_WIND               = 15; // Whistle whirlwind
const int LW_REFMAGIC           = 16; // Reflected wand magic
const int LW_REFFIREBALL        = 17; // Reflected fireball
const int LW_REFROCK            = 18; // Reflected rock
const int LW_REFBEAM            = 28; // Reflected sword beam
const int LW_SPARKLE            = 23;
const int LW_FIRESPARKLE        = 24; // Damages enemies
// Dummy weapons, for use with scripts.
const int LW_SCRIPT1            = 31;
const int LW_SCRIPT2            = 32;
const int LW_SCRIPT3            = 33;
const int LW_SCRIPT4            = 34;
const int LW_SCRIPT5            = 35;
const int LW_SCRIPT6            = 36;
const int LW_SCRIPT7            = 37;
const int LW_SCRIPT8            = 38;
const int LW_SCRIPT9            = 39;
const int LW_SCRIPT10           = 40;

//EWeapon types. Use with Screen->CreateEWeapon() and Screen->LoadEWeapon().
const int EW_ARROW              = 130;
const int EW_BRANG              = 131;
const int EW_BEAM               = 132; // Sword beam
const int EW_ROCK               = 133;
const int EW_MAGIC              = 134;
const int EW_FIREBALL           = 129;
const int EW_FIREBALL2          = 145; // Arcing boss fireball
const int EW_BOMB               = 137; // Projectile bomb
const int EW_BOMBBLAST          = 135; // Bomb explosion
const int EW_SBOMB              = 138; // Projectile super bomb
const int EW_SBOMBBLAST         = 136; // Super bomb explosion
const int EW_FIRETRAIL          = 139;
const int EW_FIRE               = 140;
const int EW_WIND               = 141; // Wind wizzrobe magic
const int EW_FIRE2				= 142;
// Dummy weapons, for use with scripts.
const int EW_SCRIPT1            = 31;
const int EW_SCRIPT2            = 32;
const int EW_SCRIPT3            = 33;
const int EW_SCRIPT4            = 34;
const int EW_SCRIPT5            = 35;
const int EW_SCRIPT6            = 36;
const int EW_SCRIPT7            = 37;
const int EW_SCRIPT8            = 38;
const int EW_SCRIPT9            = 39;
const int EW_SCRIPT10           = 40;

//Weapon DeadState values. Use with Weapon->DeadState.
const int WDS_NOHIT             = -10; // This value switches collision detection off. Deprecated by weapon->CollDetection.
const int WDS_ALIVE		= -1; // Weapon is currently 'alive'.
const int WDS_DEAD              = 0;  // Use to dispose of most weapons.
const int WDS_BEAMSHARDS        = 23; // Use with LW_BEAMs to shatter it into shards.
const int WDS_ARROW             = 4;  // Use with LW_ARROWs to make them 'wink out' using tile 54.
const int WDS_BOUNCE            = 1;  // Use with LW_BRANGs or LW_HOOKSHOTs to
                                      // make it 'bounce off' and start returning to Link.

//FFC Flags. To be used as indices into ffc->Flags[].
const int FFCF_OVERLAY          = 0; // Draw Over (draw between layers 4 and 5)
const int FFCF_TRANS            = 1; // Translucent
const int FFCF_SOLID            = 2; // Unused
const int FFCF_CARRYOVER        = 3; // Carry Over
const int FFCF_STATIONARY       = 4; // Stationary
const int FFCF_CHANGER          = 5; // Is A Changer
const int FFCF_PRELOAD          = 6; // Run Script On Screen Init
const int FFCF_LENSVIS          = 7; // Only Visible to Lens of Truth
const int FFCF_RESET            = 8; // Script Resets When Carried Over
const int FFCF_ETHEREAL         = 9; // The FFC's Combo Type is ignored.
const int FFCF_IGNOREHOLDUP     = 10; // The FFC is updated while Link is holding up an item

//Directions. Use with Link->Dir, etc.
const int DIR_UP                = 0; //000b
const int DIR_DOWN              = 1; //001b
const int DIR_LEFT              = 2; //010b
const int DIR_RIGHT             = 3; //011b
const int DIR_LEFTUP            = 4; //100b
const int DIR_RIGHTUP           = 5; //101b
const int DIR_LEFTDOWN          = 6; //110b
const int DIR_RIGHTDOWN         = 7; //111b

//Combo flags. Use with Screen->ComboF[]
const int CF_NONE               = 0;
const int CF_PUSHUPDOWN         = 1;
const int CF_PUSH4WAY           = 2;
const int CF_WHISTLE            = 3;
const int CF_CANDLE1            = 4;
const int CF_ARROW              = 5;
const int CF_BOMB               = 6;
const int CF_FAIRY              = 7;
const int CF_RAFT               = 8;
const int CF_ARMOSSECRET        = 9;
const int CF_ARMOSITEM          = 10;
const int CF_SBOMB              = 11;
const int CF_RAFTBRANCH         = 12;
const int CF_DIVEITEM           = 13;
const int CF_ZELDA              = 15;
const int CF_SECRETS01          = 16;
const int CF_SECRETS02          = 17;
const int CF_SECRETS03          = 18;
const int CF_SECRETS04          = 19;
const int CF_SECRETS05          = 20;
const int CF_SECRETS06          = 21;
const int CF_SECRETS07          = 22;
const int CF_SECRETS08          = 23;
const int CF_SECRETS09          = 24;
const int CF_SECRETS10          = 25;
const int CF_SECRETS11          = 26;
const int CF_SECRETS12          = 27;
const int CF_SECRETS13          = 28;
const int CF_SECRETS14          = 29;
const int CF_SECRETS15          = 30;
const int CF_SECRETS16          = 31;
const int CF_TRAPH              = 32;
const int CF_TRAPV              = 33;
const int CF_TRAP4WAY           = 34;
const int CF_TRAPLR             = 35;
const int CF_TRAPUD             = 36;
const int CF_ENEMY0             = 37;
const int CF_ENEMY1             = 38;
const int CF_ENEMY2             = 39;
const int CF_ENEMY3             = 40;
const int CF_ENEMY4             = 41;
const int CF_ENEMY5             = 42;
const int CF_ENEMY6             = 43;
const int CF_ENEMY7             = 44;
const int CF_ENEMY8             = 45;
const int CF_ENEMY9             = 46;
const int CF_PUSHLR             = 47;
const int CF_PUSHUP             = 48;
const int CF_PUSHDOWN           = 49;
const int CF_PUSHLEFT           = 50;
const int CF_PUSHRIGHT          = 51;
const int CF_PUSHUPDOWNNS       = 52;
const int CF_PUSHLEFTRIGHTNS    = 53;
const int CF_PUSH4WAYNS         = 54;
const int CF_PUSHUPNS           = 55;
const int CF_PUSHDOWNNS         = 56;
const int CF_PUSHLEFTNS         = 57;
const int CF_PUSHRIGHTNS        = 58;
const int CF_PUSHUPDOWNINS      = 59;
const int CF_PUSHLEFTRIGHTINS   = 60;
const int CF_PUSH4WAYINS        = 61;
const int CF_PUSHUPINS          = 62;
const int CF_PUSHDOWNINS        = 63;
const int CF_PUSHLEFTINS        = 64;
const int CF_PUSHRIGHTINS       = 65;
const int CF_BLOCKTRIGGER       = 66;
const int CF_NOBLOCKS           = 67;
const int CF_BRANG1             = 68;
const int CF_BRANG2             = 69;
const int CF_BRANG3             = 70;
const int CF_ARROW2             = 71;
const int CF_ARROW3             = 72;
const int CF_CANDLE2            = 73;
const int CF_WANDFIRE           = 74;
const int CF_DINSFIRE           = 75;
const int CF_WANDMAGIC          = 76;
const int CF_REFMAGIC           = 77;
const int CF_REFFIREBALL        = 78;
const int CF_SWORD1             = 79;
const int CF_SWORD2             = 80;
const int CF_SWORD3             = 81;
const int CF_SWORD4             = 82;
const int CF_SWORD1BEAM         = 83;
const int CF_SWORD2BEAM         = 84;
const int CF_SWORD3BEAM         = 85;
const int CF_SWORD4BEAM         = 86;
const int CF_HOOKSHOT           = 87;
const int CF_WAND               = 88;
const int CF_HAMMER             = 89;
const int CF_STRIKE             = 90;
const int CF_BLOCKHOLE          = 91;
const int CF_MAGICFAIRY         = 92;
const int CF_ALLFAIRY           = 93;
const int CF_SINGLE             = 94;
const int CF_SINGLE16           = 95;
const int CF_NOENEMY            = 96;
const int CF_NOGROUNDENEMY      = 97;
const int CF_SCRIPT1            = 98;
const int CF_SCRIPT2            = 99;
const int CF_SCRIPT3            = 100;
const int CF_SCRIPT4            = 101;
const int CF_SCRIPT5            = 102;

//Combo types. Use with Screen->ComboT[]
const int CT_ARMOS              = 4;
const int CT_AWARPA             = 94;
const int CT_AWARPB             = 95;
const int CT_AWARPC             = 96;
const int CT_AWARPD             = 97;
const int CT_AWARPR             = 98;
const int CT_BLOCKALL           = 118;
const int CT_BLOCKARROW1        = 111;
const int CT_BLOCKARROW2        = 112;
const int CT_BLOCKARROW3        = 113;
const int CT_BLOCKBRANG1        = 114;
const int CT_BLOCKBRANG2        = 115;
const int CT_BLOCKBRANG3        = 116;
const int CT_BLOCKFIREBALL      = 119;
const int CT_BLOCKMAGIC         = 50;
const int CT_BLOCKSWORDBEAM     = 117;
const int CT_BOSSCHEST          = 69;
const int CT_BOSSCHEST2         = 70;
const int CT_BOSSLOCKBLOCK      = 61;
const int CT_BOSSLOCKBLOCK2     = 62;
const int CT_BSGRAVE            = 64;
const int CT_BUSH               = 55;
const int CT_BUSHC             = 134;
const int CT_BUSHNEXT           = 131;
const int CT_BUSHNEXTC             = 139;
const int CT_CAVE               = 2;
const int CT_CAVE2              = 51;
const int CT_CAVE2B             = 83;
const int CT_CAVE2C             = 84;
const int CT_CAVE2D             = 85;
const int CT_CAVEB              = 74;
const int CT_CAVEC              = 75;
const int CT_CAVED              = 76;
const int CT_CENTERSTATUE       = 35;
const int CT_CHEST              = 65;
const int CT_CHEST2             = 66;
const int CT_CVDOWN             = 15;
const int CT_CVLEFT             = 16;
const int CT_CVRIGHT            = 17;
const int CT_CVUP               = 14;
const int CT_DAMAGE1            = 31;
const int CT_DAMAGE2            = 32;
const int CT_DAMAGE3            = 33;
const int CT_DAMAGE4            = 34;
const int CT_DAMAGE5            = 120;
const int CT_DAMAGE6            = 121;
const int CT_DAMAGE7            = 122;
const int CT_DIVEWARP           = 19;
const int CT_DIVEWARPB          = 89;
const int CT_DIVEWARPC          = 90;
const int CT_DIVEWARPD          = 91;
const int CT_DOCK               = 6;
const int CT_EYEBALL4WAY        = 140;
const int CT_EYEBALLA           = 52;
const int CT_EYEBALLB           = 53;
const int CT_FLOWERS            = 56;
const int CT_FLOWERSC           = 135;
const int CT_GRAVE              = 5;
const int CT_HOOKSHOTONLY       = 42;
const int CT_HSBRIDGE           = 30;
const int CT_HSGRAB             = 29;
const int CT_LADDERHOOKSHOT     = 20;
const int CT_LADDERONLY         = 63;
const int CT_LEFTSTATUE         = 11;
const int CT_LOCKBLOCK          = 59;
const int CT_LOCKBLOCK2         = 60;
const int CT_LOCKEDCHEST        = 67;
const int CT_LOCKEDCHEST2       = 68;
const int CT_MAGICPRISM         = 48;
const int CT_MAGICPRISM4WAY     = 49;
const int CT_MIRROR             = 45;
const int CT_MIRRORBACKSLASH    = 47;
const int CT_MIRRORSLASH        = 46;
const int CT_NOENEMY            = 110;
const int CT_NOFLYZONE          = 44;
const int CT_NOGROUNDENEMY      = 128;
const int CT_NOJUMPZONE         = 54;
const int CT_NONE               = 0;
const int CT_OVERHEAD           = 43;
const int CT_PIT                = 41;
const int CT_PITB               = 80;
const int CT_PITC               = 81;
const int CT_PITD               = 82;
const int CT_PITR               = 93;
const int CT_POUND              = 28;
const int CT_PUSHHEAVY          = 9;
const int CT_PUSHHEAVY2         = 26;
const int CT_PUSHHEAVY2WAIT     = 27;
const int CT_PUSHHEAVYWAIT      = 10;
const int CT_PUSHWAIT           = 8;
const int CT_RESET              = 71;
const int CT_RIGHTSTATUE        = 12;
const int CT_SAVE               = 72;
const int CT_SAVE2              = 73;
const int CT_SCREENFREEZE       = 126;
const int CT_SCREENFREEZEFF     = 127;
const int CT_SCRIPT1		  = 142;
const int CT_SCRIPT2		  = 143;
const int CT_SCRIPT3		  = 144;
const int CT_SCRIPT4		  = 145;
const int CT_SCRIPT5		  = 146;
const int CT_SHALLOWWATER       = 58;
const int CT_SLASH              = 24;
const int CT_SLASHC             = 132;
const int CT_SLASHITEM          = 25;
const int CT_SLASHITEMC         = 133;
const int CT_SLASHNEXT          = 129;
const int CT_SLASHNEXTC             = 137;
const int CT_SLASHNEXTITEM      = 130;
const int CT_SLASHNEXTITEMC             = 138;
const int CT_SPINTILE1          = 124;
const int CT_SPINTILE2          = 125;
const int CT_STAIR              = 1;
const int CT_STAIRB             = 77;
const int CT_STAIRC             = 78;
const int CT_STAIRD             = 79;
const int CT_STAIRR             = 92;
const int CT_STEP               = 106;
const int CT_STEPALL            = 108;
const int CT_STEPCOPY           = 109;
const int CT_STEPSAME           = 107;
const int CT_STRIGFLAG          = 105;
const int CT_STRIGNOFLAG        = 104;
const int CT_SWARPA             = 99;
const int CT_SWARPB             = 100;
const int CT_SWARPC             = 101;
const int CT_SWARPD             = 102;
const int CT_SWARPR             = 103;
const int CT_SWIMWARP           = 18;
const int CT_SWIMWARPB          = 86;
const int CT_SWIMWARPC          = 87;
const int CT_SWIMWARPD          = 88;
const int CT_TALLGRASS          = 57;
const int CT_TALLGRASSC         = 136;
const int CT_TALLGRASSNEXT      = 141;
const int CT_TRAP4WAY           = 38;
const int CT_TRAPH              = 36;
const int CT_TRAPLEFTRIGHT      = 39;
const int CT_TRAPUPDOWN         = 40;
const int CT_TRAPV              = 37;
const int CT_TRIGFLAG           = 22;
const int CT_TRIGNOFLAG         = 21;
const int CT_WALKSLOW           = 13;
const int CT_WATER              = 3;
const int CT_ZELDA              = 23;


//Item pickup flags. OR (|) these together to use with item->Pickup
//Other values are reserved for internal usage, and have no effect
const int IP_HOLDUP				= 0x002; //Link holds it up when collecting it.
const int IP_ST_ITEM			= 0x004; //Sets the screen state "Item" when collected.
const int IP_DUMMY				= 0x008; //A 'dummy' item, such as rupee markers in shops. Can't be collected and ignores gravity.
const int IP_ENEMYCARRIED		= 0x080; //The item-carrying NPC carries it. If no NPC has an item, the most recently created NPC carries it.
const int IP_TIMEOUT			= 0x100; //Disappears after 512 frames. Can be collected by melee weapons if the related quest rule is not set.
const int IP_ST_SPECIALITEM		= 0x800; //Sets the screen state "Special Item" when collected.

//Screen Freeze Types
const int SFT_NONE       	     = 0;
const int SFT_FREEZE  		     = 1;
const int SFT_FREEZEFF		     = 2;

//Screen Flag categories. Flags from each category are ORed together, starting with the first flag
//See Screen Data dialog for what flags are contained in each category. Use in Screen->Flags
const int SF_ROOMTYPE			= 0;
const int SF_VIEW				= 1;
const int SF_SECRETS			= 2;
const int SF_WARP				= 3;
const int SF_ITEMS				= 4;
const int SF_COMBOS				= 5;
const int SF_SAVE				= 6;
const int SF_FFC				= 7;
const int SF_WHISTLE			= 8;
const int SF_MISC				= 9;

//Screen Enemy Flag categories, handled in the same way as the SF_ constants.
//Use in Screen->EFlags
const int SEF_SPAWN				= 0;
const int SEF_LIST1				= 1; //left-hand list
const int SEF_LIST2				= 2; //right-hand list

//Room types (Screen => Room Type)
//Use with Screen->RoomType
const int RT_DOORREPAIR         = 5;
const int RT_FEEDTHEGORIYA      = 7;
const int RT_GAMBLE             = 4;
const int RT_GANON              = 15;
const int RT_ITEMPOND           = 17; //doesn't work
const int RT_LEARNSLASH         = 19;
const int RT_LEVEL9ENTRANCE     = 8;
const int RT_MAGICUPGRADE       = 18;
const int RT_MONEYORLIFE        = 12;
const int RT_MOREARROWS         = 20;
const int RT_MOREBOMBS          = 11;
const int RT_NONE               = 0;
const int RT_PAYFORINFO         = 2;
const int RT_POTIONORHEART      = 6;
const int RT_POTIONSHOP         = 9;
const int RT_SECRETMONEY        = 3;
const int RT_SHOP               = 10;
const int RT_SPECIALITEM        = 1;
const int RT_STAIRWARP          = 14;
const int RT_TAKEONEITEM        = 21;
const int RT_TENRUPEES          = 13;
const int RT_ZELDA              = 16;

//DMap Flag constants. Use with Game->DMapFlags.
const int DMF_CAVESNOTCELLARS	= 0x0001; //Use caves instead of item cellars
const int DMF_3STAIRWARPS		= 0x0002; //Allow 3-stair warps
const int DMF_WWIND				= 0x0004; //Allow whistle whirlwinds
const int DMF_GUYCAVES			= 0x0008; //Special rooms and guys are in caves only
const int DMF_NOCOMPASS			= 0x0010; //Don't display compass marker in minimap
const int DMF_WAVY 				= 0x0020; //Underwater wave effect
const int DMF_WWINDRET			= 0x0040; //Whistle whirlwind returns Link to start
const int DMF_ALWAYSINTROMSG	= 0x0080; //Always display intro string
const int DMF_VIEWMAP       	= 0x0100; //View overworld map by pressing 'Map'
const int DMF_DMAPMAP         	= 0x0200; //...But only show screens marked in minimap
const int DMF_MINIMAPCOLORFIX 	= 0x0400; //Use minimap foreground colour 2
const int DMF_SCRIPT1 			= 0x0800;
const int DMF_SCRIPT2 			= 0x1000;
const int DMF_SCRIPT3 			= 0x2000;
const int DMF_SCRIPT4 			= 0x4000;
const int DMF_SCRIPT5 			= 0x8000;

//NPC Attribute 1 constants. Use with npc->Attributes.
const int NPCA1_1SHOT			= 0;
const int NPCA1_ENDHALT			= 1;
const int NPCA1_RAPIDFIRE		= 2;
const int NPCA1_1FAST			= 3;
const int NPCA1_1SLANT			= 4;
const int NPCA1_3SHOTS			= 5;
const int NPCA1_4SHOTS			= 6;
const int NPCA1_5SHOTS			= 7;
const int NPCA1_3FAST			= 8;
const int NPCA1_BREATH			= 9;
const int NPCA1_8SHOTS			= 10;
const int NPCA1_SUMMON			= 11;
const int NPCA1_SUMMONLAYER		= 12;

//NPC Attribute 2 constants. Use with npc->Attributes.
const int NPCA2_NORMAL			= 0;
const int NPCA2_SPLITHIT		= 1;
const int NPCA2_SPLIT			= 2;
const int NPCA2_8SHOTS			= 3;
const int NPCA2_EXPLODE			= 4;
const int NPCA2_TRIBBLE			= 5;

//NPC Attribute 7 constants. Use with npc->Attributes.
const int NPCA7_NORMAL			= 0;
const int NPCA7_TEMPJINX		= 1;
const int NPCA7_PERMJINX		= 2;
const int NPCA7_CUREJINX		= 3;
const int NPCA7_LOSEMAGIC		= 4;
const int NPCA7_LOSERUPEES		= 5;
const int NPCA7_DRUNK			= 6;
const int NPCA7_EATITEMS		= 7;
const int NPCA7_EATMAGIC		= 8;
const int NPCA7_EATRUPEES		= 9;

//NPC Attribute 9 constants. Use with npc->Attributes.
const int NPCA9_NORMAL			= 0;
const int NPCA9_ROPE			= 1;
const int NPCA9_VIRE			= 2;
const int NPCA9_POLSVOICE		= 3;

//NPC Defenses. Use as indices to npc->Defense[].
const int NPCD_ARROW			= 3;
const int NPCD_BEAM				= 10;
const int NPCD_BRANG			= 0;
const int NPCD_BOMB				= 1;
const int NPCD_BYRNA			= 16;
const int NPCD_FIRE				= 4;
const int NPCD_HAMMER			= 8;
const int NPCD_HOOKSHOT			= 7;
const int NPCD_MAGIC			= 6;
const int NPCD_REFBEAM			= 11;
const int NPCD_REFMAGIC			= 12;
const int NPCD_REFFIREBALL		= 13;
const int NPCD_REFROCK			= 14;
const int NPCD_SBOMB			= 2;
const int NPCD_SCRIPT			= 17;
const int NPCD_STOMP			= 15;
const int NPCD_SWORD			= 9;
const int NPCD_WAND				= 5;

//NPC Defense types. Use with npc->Defense[].
const int NPCDT_NONE			= 0;
const int NPCDT_HALFDAMAGE		= 1;
const int NPCDT_QUARTERDAMAGE	= 2;
const int NPCDT_STUN			= 3;
const int NPCDT_STUNORBLOCK		= 4;
const int NPCDT_STUNORIGNORE	= 5;
const int NPCDT_BLOCK1			= 6;
const int NPCDT_BLOCK2			= 7;
const int NPCDT_BLOCK4			= 8;
const int NPCDT_BLOCK6			= 9;
const int NPCDT_BLOCK8			= 10;
const int NPCDT_BLOCK			= 11;
const int NPCDT_IGNORE1			= 12;
const int NPCDT_IGNORE			= 13;
const int NPCDT_ONEHITKILL		= 14;

//Draw styles. Use with item->DrawStyle
const int DS_NORMAL             = 0;
const int DS_PHANTOM            = 1;
const int DS_CLOAKED            = 2;
const int DS_LINK               = 3;

//Warp types. Use with Screen->SetSideWarp
const int WT_CAVE				= 0;
const int WT_PASSAGE			= 1;
const int WT_ENTRANCEEXIT		= 2;
const int WT_SCROLLING			= 3;
const int WT_IAWARP				= 4;
const int WT_IWARPBLACKOUT		= 5;
const int WT_IWARPOPENWIPE		= 6;
const int WT_IWARPZAP			= 7;
const int WT_IWARPWAVE		  	= 8;
const int WT_NOWARP				= 9;

// Font types. Use with Screen->DrawCharacter *note -some of these fonts may not represent normal ascii characters,
//and all of these are completely undocumented. Use at your own peril
const int FONT_Z1               = 0;
const int FONT_Z3               = 1;
const int FONT_Z3SMALL          = 2;
const int FONT_DEF              = 3;
const int FONT_L                = 4;
const int FONT_L2               = 5;
const int FONT_P                = 6;
const int FONT_MATRIX           = 7;
const int FONT_ZTIME            = 8;
const int FONT_S                = 9;
const int FONT_S2               = 10;
const int FONT_SP               = 11;
const int FONT_SUBSCREEN1       = 12;
const int FONT_SUBSCREEN2       = 13;
const int FONT_SUBSCREEN3       = 14;
const int FONT_SUBSCREEN4       = 15;
const int FONT_GBLA             = 16;
const int FONT_GORON            = 17;
const int FONT_ZORAN            = 18;
const int FONT_HYLIAN1          = 19;
const int FONT_HYLIAN2          = 20;
const int FONT_HYLIAN3          = 21;
const int FONT_HYLIAN4          = 22;
const int FONT_GBORACLE         = 23;
const int FONT_GBORACLEP        = 24;
const int FONT_DSPHANTOM        = 25;
const int FONT_DSPHANTOMP       = 26;

// PrintString Text Formats. Use with Screen->DrawString.
const int TF_NORMAL             = 0; // treats the left-most char as (x)
const int TF_CENTERED           = 1; // prints the string centered on (x)
const int TF_RIGHT              = 2; // treats the right-most char as (x)

// Texture mapping rendering modes. Use with Screen->"Psuedo 3D" or "*3D" drawing routines. ie; Polygon, Quad, or Triangle
const int PT_FLAT               = 0; // single color shading
const int PT_FLATSHADED         = 1; // "" with flat shading (*3D only)
const int PT_COLSHADED          = 2; // "" with color shading (*3D only)
const int PT_TEXTURE            = 3; // texture mapped polygon using 2d linear interpolation
const int PT_PTEXTURE           = 4; // "" 
const int PT_MASKTEXTURE        = 5; // transparent texture mapped polygon using 2d linear interpolation
const int PT_MASKPTEXTURE       = 6; // "" 
const int PT_LITTEXTURE         = 7; // "" with lighting (*3D only)
const int PT_LITPTEXTURE        = 8; // "" (*3D only)
const int PT_MASKLITTEXTURE     = 9; // "" with transparency
const int PT_MASKLITPTEXTURE    = 10; // "" 
const int PT_TRANSTEXTURE       = 11; // translucent texture mapped polygon using 2d linear interpolation
const int PT_TRANSPTEXTURE      = 12; // "" 
const int PT_MASKTRANSTEXTURE   = 13; // translucent and transparent texture mapped polygon using 2d linear interpolation
const int PT_MASKTRANSPTEXTURE  = 14; // "" 

// Render Targets. Use with Screen->"*RenderTarget" and Screen->"Bitmap" drawing routines.
const int RT_SCREEN             = -1; // draws to screen
const int RT_BITMAP0            = 0; // draws to off-screen bitmap 0
const int RT_BITMAP1            = 1; // draws to off-screen bitmap 1
const int RT_BITMAP2            = 2; // draws to off-screen bitmap 2
const int RT_BITMAP3            = 3; // draws to off-screen bitmap 3
const int RT_BITMAP4            = 4; // draws to off-screen bitmap 4
const int RT_BITMAP5            = 5; // draws to off-screen bitmap 5
const int RT_BITMAP6            = 6; // draws to off-screen bitmap 6

//Sprite extending methods. Use with Link->Extend, item->Extend,
//npc->Extend, eweapon->Extend and lweapon->Extend.
const int EXT_NONE              = 0; // Not extended
const int EXT_NORMAL            = 3; // Extended
const int EXT_NOSHADOW          = 4; // Extended; NPC has no shadow.

//Generic counters. Use with itemclass->Counter, Game->Counter[], Game->MCounter[] and Game->DCounter[]
const int CR_LIFE               = 0;
const int CR_RUPEES             = 1;
const int CR_BOMBS              = 2;
const int CR_ARROWS             = 3;
const int CR_MAGIC              = 4;
const int CR_KEYS               = 5;
const int CR_SBOMBS             = 6;
const int CR_SCRIPT1            = 7;
const int CR_SCRIPT2            = 8;
const int CR_SCRIPT3            = 9;
const int CR_SCRIPT4            = 10;
const int CR_SCRIPT5            = 11;
const int CR_SCRIPT6            = 12;
const int CR_SCRIPT7            = 13;
const int CR_SCRIPT8            = 14;
const int CR_SCRIPT9            = 15;
const int CR_SCRIPT10           = 16;


//Generic data indices. Use this with Game->Generic[]
const int GEN_HEARTPIECES       = 0; // Heart Pieces currently possessed
const int GEN_MAGICDRAINRATE    = 1; // Link's magic usage equals n / 2.
const int GEN_CANSLASH          = 2; // Link can slash with the sword.
const int GEN_WARPLEVEL         = 3; // Warp Ring number that a Whirlwind warp will send Link to.
							  // It is set every time that Link uses the Whistle.
const int GEN_HCPPERHC          = 4; // How many Pieces of Heart form a complete Heart Container?
const int GEN_CONTINUEHEARTS    = 5; // Amount of life that Link continues with
const int GEN_CONTINUEISPERCENT = 6; // ...Or a percentage of his total life

//Level item flags. Or (|) these together and use with Game->LItems[]
const int LI_TRIFORCE           = 0x01; // The Triforce of this Level has been obtained
const int LI_MAP                = 0x02; // The Dungeon Map of this Level has been obtained
const int LI_COMPASS            = 0x04; // The Compass of this Level has been obtained
const int LI_BOSS               = 0x08; // A "Dungeon Boss" enemy has been slain
const int LI_BOSSKEY            = 0x10; // The Boss Key of this Level has been obtained

//Screen states. Use these with Screen->State[], etc.

const int ST_DOORUP				= 0; // The locked/bomb door has been permanently unlocked/bombed
const int ST_DOORDOWN			= 1; // The locked/bomb door has been permanently unlocked/bombed
const int ST_DOORLEFT			= 2; // The locked/bomb door has been permanently unlocked/bombed
const int ST_DOORRIGHT			= 3; // The locked/bomb door has been permanently unlocked/bombed
const int ST_SECRET				= 13; // Screen Secrets have been made permanent
const int ST_ITEM				= 4; // If set, the item is gone
const int ST_SPECIALITEM		= 5; // If set, the Cave/Item Cellar/Dive For Item/Armos item is gone
const int ST_ENEMYNORETURN		= 6; // If set, enemies won't return
const int ST_TEMPNORETURN		= 7; // If set, enemies won't return. This is automatically unset when you leave the DMap
const int ST_LOCKBLOCK			= 8; // The lock block on the screen has been triggered
const int ST_BOSSLOCKBLOCK		= 9; // The boss lock block on the screen has been triggered
const int ST_CHEST				= 10; // The unlocked chest on this screen has been opened
const int ST_LOCKEDCHEST		= 11; // The locked chest on this screen has been opened
const int ST_BOSSCHEST			= 12; // The boss chest on this screen has been opened
const int ST_VISITED			= 14; // If set, this screen will appear on the Overworld Map

//Door types. Use with Screen->Door[]
const int D_WALL                = 0;
const int D_OPEN                = 1;
const int D_LOCKED              = 2;
const int D_UNLOCKED            = 3; // A locked door that has been opened
const int D_SHUTTER             = 4; // Defeat enemies to unlock this door
const int D_BOMB                = 6; // A door that changes when bombed
const int D_BOMBED              = 7; // A door that has been bombed
const int D_WALKTHRU            = 8; // Push against the wall to pass through
const int D_BOSSLOCKED          = 10;
const int D_BOSSUNLOCKED        = 11; // A boss door that has been opened
const int D_OPENSHUTTER         = 12; // A shutter that has been opened
const int D_1WAYSHUTTER         = 14; // A shutter that locks behind you and never opens

//Enemy projectile weapon selections. Use with npc->Weapon.
//Note: Don't use these with Screen->CreateEWeapon! Use the EW_ constants instead.
const int WPN_NONE              = 0;
const int WPN_ENEMYFLAME        = 140;
const int WPN_ENEMYWIND         = 141;
const int WPN_ENEMYFIREBALL     = 129;
const int WPN_ENEMYARROW        = 130;
const int WPN_ENEMYBRANG        = 131;
const int WPN_ENEMYSWORD        = 132;
const int WPN_ENEMYROCK         = 133;
const int WPN_ENEMYMAGIC        = 134;
const int WPN_ENEMYBOMB         = 135;
const int WPN_ENEMYSBOMB        = 136;
const int WPN_ENEMYLITBOMB      = 137;
const int WPN_ENEMYLITSBOMB     = 138;
const int WPN_ENEMYFIRETRAIL    = 139;
const int WPN_ENEMYFLAME2       = 141;
const int WPN_ENEMYFLAME2TRAIL  = 143; // Not implemented
const int WPN_ENEMYICE          = 144; // Not implemented
const int WPN_ENEMYFIREBALL2    = 145; // A fireball that doesn't fly toward Link

//Default item drop sets. Use with npc->ItemSet
const int IS_NONE               = 0;
const int IS_DEFAULT            = 1;
const int IS_BOMBS              = 2;
const int IS_MONEY              = 3;
const int IS_LIFE               = 4;
const int IS_BOMB100            = 5; // Used by Dodongos
const int IS_SBOMB100           = 6; // Used by Dodongos
const int IS_MAGIC              = 7;
const int IS_MAGICBOMBS         = 8;
const int IS_MAGICMONEY         = 9;
const int IS_MAGICLIFE          = 10;
const int IS_MAGIC2             = 11;
const int IS_COMBOS				= 12; // Used by Tall Grass / Bush / Slash combos.

//Boss palettes. Use with npc->BossPal
const int BPAL_AQUA             = 0;
const int BPAL_GLEEOK           = 1;
const int BPAL_GANON            = 2;
const int BPAL_BROWN            = 3;
const int BPAL_PILE             = 4; // Used for the Dust Pile.
const int BPAL_BLUE             = 5;
const int BPAL_RED              = 6;
const int BPAL_GOLD             = 7;
const int BPAL_ICON1            = 8; // Used for Quest Icon 1.
const int BPAL_ICON2            = 9; // Used for Quest Icon 2.
const int BPAL_ICON3            = 10; // Used for Quest Icon 3.
const int BPAL_ICON4            = 11; // Used for Quest Icon 4.
const int BPAL_GLEEOKF          = 12;
const int BPAL_FROZEN           = 13; // Unused

//Sprite lists. Use with Screen->ClearSprites()
const int SL_GUYS               = 0; // Enemies
const int SL_ITEMS              = 1; // Items
const int SL_EWPNS              = 2; // Enemy weapons
const int SL_LWPNS              = 3; // Link's weapons
const int SL_DECORATIONS        = 4; // Grass clippings, Hover boots glow, etc.
const int SL_PARTICLES          = 5; // Farore's Wind particles

//Mouse buttons
const int MB_LEFTCLICK			= 0x1; //AND (&) these with Link->InputMouseB to get the current button state of the mouse
const int MB_RIGHTCLICK			= 0x2;
const int MB_MIDDLECLICK		= 0x4; //Keep in in mind that not all mice/touchpads have a middle mouse button

//
// Some utility routines
//

//Wait for n frames
void Waitframes(int n) {
 while(n-- > 0) Waitframe();
}

//Returns a if cond is true, else b. Overloaded.
float Cond(bool cond, float a, float b) {
  if (cond) return a;
  else return b;
}
bool Cond(bool cond, bool a, bool b) {
  if (cond) return a;
  else return b;
}
npc Cond(bool cond, npc a, npc b) {
  if (cond) return a;
  else return b;
}
item Cond(bool cond, item a, item b) {
  if (cond) return a;
  else return b;
}
lweapon Cond(bool cond, lweapon a, lweapon b) {
  if (cond) return a;
  else return b;
}
eweapon Cond(bool cond, eweapon a, eweapon b) {
  if (cond) return a;
  else return b;
}
ffc Cond(bool cond, ffc a, ffc b) {
  if (cond) return a;
  else return b;
}
itemdata Cond(bool cond, itemdata a, itemdata b) {
  if (cond) return a;
  else return b;
}

// Chooses one of the options randomly and fairly.
float Choose(float a, float b) {
  if (Rand(2)==0) return a;
  else return b;
}

float Choose(float a, float b, float c) {
  int r = Rand(3);
  if (r==0) return a;
  else if (r==1) return b;
  else return c;
}

float Choose(float a, float b, float c, float d) {
  int r = Rand(4);
  if (r==0) return a;
  else if (r==1) return b;
  else if (r==2) return c;
  else return d;
}

float Choose(float a, float b, float c, float d, float e) {
  int r = Rand(5);
  if (r==0) return a;
  else if (r==1) return b;
  else if (r==2) return c;
  else if (r==3) return d;
  else return e;
}

float Choose(float a, float b, float c, float d, float e, float f) {
  int r = Rand(6);
  if (r==0) return a;
  else if (r==1) return b;
  else if (r==2) return c;
  else if (r==3) return d;
  else if (r==4) return e;
  else return f;
}

//Returns the logarithm of x to the given base
float LogToBase(float x, float base){
	return Ln(x)/Ln(base);
}

//Truncates x to an integer
int Floor(float x) {
	if(x < 0)
		return (x-.9999)<<0;
	return x<<0;
}

//Raises x to the nearest integer
int Ceiling(float x) {
	if(x < 0)
		return x<<0;
	return (x+.9999)<<0;
}

//Rounds x to the nearest integer
int Round(float x) {
	return Floor(x + 0.5);
}

//Bounds x between two values
int VBound(int x, int high, int low){
    if(x<low) x=low;
    else if(x>high) x=high;
    return x;
}

//Returns the Quotient only of x divided by y
int Div(float x, float y) {
	return (x/y)<<0;
}

//Returns a random integer in the bounds of min and max
int Rand(int min, int max) {
    return min+(Rand((1+max)-min));
}

//Returns a random floating point number up to n
float Randf(float n) {
	return (Rand(0x7fff)/0x7fff)*n;
}

//Returns a random floating point number between min and max
float Randf(float n1, float n2) {
	return n1 + (Rand(0x7fff)/(0x7fff))*(n2-n1);
}

//Converts 'd' in degrees to radians
float DegtoRad(float d) {
    return d*0.0174;
}

//Converts 'r' in radians to degrees
float RadtoDeg(float r) {
    return r*57.2958;
}

//Returns the sign of n
int Sign(int n) {
	if (n > 0) return 1;
	else if (n < 0) return -1;
	else return 0;
}

//Finds the location of a combo, given its (x,y) coordinates on the screen
int ComboAt(int x, int y) {
  x = VBound(x,255,0);
  y = VBound(y,175,0);
  return (y & 240)+(x>>4);
}

//Snaps 'x' to the combo grid
//Equivalent to calling ComboX(ComboAt(x,foo));
int GridX(int x) {
    return (x >> 4) << 4;
}

//Snaps 'y' to the combo grid
//Equivalent to calling ComboY(ComboAt(foo,y));
int GridY(int y) {
    return (y >> 4) << 4;
}


//Returns the correct offset to be at the front of a sprite facing in the direction 'dir'
int AtFrontX(int dir) {

	int x = 0;
	if(dir == DIR_UP || dir == DIR_DOWN) x = 8;
	else if(dir == DIR_RIGHT) x = 16;
	return x;
}

int AtFrontY(int dir) {

	int y = 0;
	if(dir == DIR_DOWN) y = 16;
	else if(dir == DIR_LEFT || dir == DIR_RIGHT) y = 8;
	return y;
}

//Returns the correct offset to be 'dist' pixels away from the front of a sprite facing in the direction 'dir'
int InFrontX(int dir, int dist) {
	int x = 0;
	if(dir == DIR_LEFT) x = -16+dist;
	else if(dir == DIR_RIGHT) x = 16-dist;
	return x;
}

int InFrontY(int dir, int dist){
	int y = 0;
	if(dir == DIR_UP) y = -16+dist;
	else if(dir == DIR_DOWN) y = 16-dist;
	return y;
}

// Get the X and Y coordinates at the center of a sprite
int CenterX(ffc anFFC) { return anFFC->X+8*anFFC->TileWidth; }
int CenterY(ffc anFFC) { return anFFC->Y+8*anFFC->TileHeight; }
int CenterX(npc anNPC) { return anNPC->X+8*anNPC->TileWidth; }
int CenterY(npc anNPC) { return anNPC->Y+8*anNPC->TileHeight; }
int CenterX(eweapon anEWeapon) { return anEWeapon->X+8*anEWeapon->TileWidth; }
int CenterY(eweapon anEWeapon) { return anEWeapon->Y+8*anEWeapon->TileHeight; }
int CenterX(lweapon anLWeapon) { return anLWeapon->X+8*anLWeapon->TileWidth; }
int CenterY(lweapon anLWeapon) { return anLWeapon->Y+8*anLWeapon->TileHeight; }
int CenterLinkX() { return Link->X+8; }
int CenterLinkY() { return Link->Y+8; }

//Return the coordinates of a combo on the screen
int ComboX(int loc) {
	return loc%16*16;
}
int ComboY(int loc) {
    return loc&0xF0;
}

//Returns true if the combo at '(x, y)' has either an inherent or place flag of type 'flag'
bool ComboFI(int x, int y, int flag){

	int loc = ComboAt(x,y);

	return Screen->ComboF[loc] == flag || Screen->ComboI[loc] == flag;
}

//Returns true if the combo at 'loc' has either an inherent or place flag of type 'flag'
bool ComboFI(int loc, int flag){

	return Screen->ComboF[loc] == flag || Screen->ComboI[loc] == flag;
}

//Sets bit 'bit' of Screen->D[] register 'd' to 'state'
void SetScreenDBit(int dmap, int screen, int d, int bit, bool state){
	int curstate = Game->GetDMapScreenD(dmap, screen, d);
	if(state)	Game->SetDMapScreenD(dmap, screen, d, curstate |  (1 << bit));
	else 		Game->SetDMapScreenD(dmap, screen, d, curstate & ~(1 << bit));
}
void SetScreenDBit(int screen, int d, int bit, bool state){
	int curstate = Game->GetScreenD(screen, d);
	if(state)	Game->SetScreenD(screen, d, curstate |  (1 << bit));
	else 		Game->SetScreenD(screen, d, curstate & ~(1 << bit));
}
void SetScreenDBit(int d, int bit, bool state){
    if(state)	Screen->D[d] |= (1 << bit);
    else		Screen->D[d] &= ~(1 << bit);
}

//Returns the state of bit 'bit' of Screen->D[] register 'd'
bool GetScreenDBit(int dmap, int screen, int d, int bit){
	return ( Game->GetDMapScreenD(dmap, screen, d) & (1 << bit) ) != 0;
}
bool GetScreenDBit(int screen, int d, int bit){
	return ( Game->GetScreenD(screen, d) & (1 << bit) ) != 0;
}
bool GetScreenDBit(int d, int bit){
    return (Screen->D[d] & (1 << bit)) != 0;
}

//A shorthand way to get a combo on the current layer.
//Layer 0 is the screen itself.
int GetLayerComboD(int layer, int combo) {
  if (layer==0)
    return Screen->ComboD[combo];
  else
    return Game->GetComboData(Screen->LayerMap(layer), Screen->LayerScreen(layer), combo);
}

//A shorthand way to set a combo on the current layer.
//Layer 0 is the screen itself.
void SetLayerComboD(int layer, int combo, int d) {
  if (layer == 0)
    Screen->ComboD[combo] = d;
  else
    Game->SetComboData(Screen->LayerMap(layer), Screen->LayerScreen(layer), combo, d);
}

//A shorthand way to get a combo flag on the current layer.
//Layer 0 is the screen itself.
int GetLayerComboF(int layer, int flag) {
  if (layer==0)
    return Screen->ComboF[flag];
  else
    return Game->GetComboFlag(Screen->LayerMap(layer), Screen->LayerScreen(layer), flag);
}

//A shorthand way to set a combo flag on the current layer.
//Layer 0 is the screen itself.
void SetLayerComboF(int layer, int flag, int d) {
  if (layer == 0)
    Screen->ComboD[flag] = d;
  else
    Game->SetComboFlag(Screen->LayerMap(layer), Screen->LayerScreen(layer), flag, d);
}

//A shorthand way to get a combo type on the current layer.
//Layer 0 is the screen itself.
int GetLayerComboT(int layer, int combo) {
  if (layer==0)
    return Screen->ComboT[combo];
  else
    return Game->GetComboType(Screen->LayerMap(layer), Screen->LayerScreen(layer), combo);
}

//A shorthand way to set a combo type on the current layer.
//Layer 0 is the screen itself.
void SetLayerComboT(int layer, int combo, int d) {
  if (layer == 0)
    Screen->ComboT[combo] = d;
  else
    Game->SetComboType(Screen->LayerMap(layer), Screen->LayerScreen(layer), combo, d);
}

//A shorthand way to get a combo's solidity on the current layer.
//Layer 0 is the screen itself.
int GetLayerComboS(int layer, int combo) {
  if (layer==0)
    return Screen->ComboS[combo];
  else
    return Game->GetComboSolid(Screen->LayerMap(layer), Screen->LayerScreen(layer), combo);
}

//A shorthand way to set a combo's solidity on the current layer.
//Layer 0 is the screen itself.
void SetLayerComboS(int layer, int combo, int s) {
  if (layer == 0)
    Screen->ComboS[combo] = s;
  else
    Game->SetComboSolid(Screen->LayerMap(layer), Screen->LayerScreen(layer), combo, s);
}

//Copies the combos and csets from one screen to another.
//Only copies layer 0!
void ScreenCopy(int destmap, int destscr, int srcmap, int srcscr) {
  for (int i = 0; i < 176; i++) {
    Game->SetComboData(destmap,destscr, i, Game->GetComboData(srcmap,srcscr,i));
    Game->SetComboCSet(destmap,destscr, i, Game->GetComboCSet(srcmap,srcscr,i));
  }
}

//Swaps a row of tiles of length 'length' between positions 'first' and 'second'
void SwapTileRow(int first, int second, int length){
	for(int i=0;i<length;i++) SwapTile(first+i,second+i);
}

//Copies a row of tiles of length 'length' from 'source' onto 'dest'
void CopyTileRow(int source, int dest, int length){
	for(int i=0;i<length;i++) CopyTile(source+i,dest+i);
}

//Clears a row of tiles of length 'length' starting from tile 'ref'
void ClearTileRow(int ref, int length){
	for(int i=0;i<length;i++) ClearTile(ref+i);
}

//Swaps a block of tiles defined by diagonal corners 'first' and 'last'
//with the block starting with top left tile 'second'
void SwapTileBlock(int first, int last, int second){
	if(last < first){
		int swap = first;
		first = last;
		last = swap;
	}
	int w = last%20-first%20;
	if(w < 0){
		first -= w;
		last += w;
		w = -w;
	}
	for(int i=0;i<=last-first;i++) if(i%20 <= w) SwapTile(first+i,second+i);
}

//Copies a block of tiles defined by diagonal corners 'sourcefirst' and 'sourcelast'
//onto the block starting with top left tile 'destfirst'
void CopyTileBlock(int sourcefirst, int sourcelast, int destfirst){
	if(sourcelast < sourcefirst){
		int swap = sourcefirst;
		sourcefirst = sourcelast;
		sourcelast = swap;
	}
	int w = sourcelast%20-sourcefirst%20;
	if(w < 0){
		sourcefirst -= w;
		sourcelast += w;
		w = -w;
	}
	for(int i=0;i<=sourcelast-sourcefirst;i++) if(i%20 <= w) CopyTile(sourcefirst+i,destfirst+i);
}

//Clears a block of tiles defined by diagonal corners 'reffirst' and 'reflast'
void ClearTileBlock(int reffirst, int reflast){
	if(reflast < reffirst){
		int swap = reffirst;
		reffirst = reflast;
		reflast = swap;
	}
	int w = reflast%20-reffirst%20;
	if(w < 0){
		reffirst -= w;
		reflast += w;
		w = -w;
	}
	for(int i=0;i<=reflast-reffirst;i++) if(i%20 <= w) ClearTile(reffirst+i);
}


//Overload to Screen->DrawString which includes a position to start drawing from in the string
//Does not check for overflow
void DrawString(int layer, int x, int y, int font, int color, int background_color, int format, int opacity,
				int string, int start){
	int buffer[256];
	for(int i=start;string[i]!=0;i++) buffer[i-start] = string[i];
	Screen->DrawString(layer,x,y,font,color,background_color,format,opacity,buffer);
}

//Overload to Screen->DrawString which includes a start and end position to draw the string
//Does not check for overflow
void DrawString(int layer, int x, int y, int font, int color, int background_color, int format, int opacity,
				int string, int start, int end){
	int buffer[256];
	for(int i=start;i<end;i++) buffer[i-start] = string[i];
	Screen->DrawString(layer,x,y,font,color,background_color,format,opacity,buffer);
}


// A very simple layer 0 tile drawing routine.
void DrawTileSimple(int x, int y, int tile, int color)
{

	Screen->FastTile(0, x, y, tile, color, 128);
}


//Returns the distance between two sets of coordinates using Pythagoras' Theorem
float Distance(int x1, int y1, int x2, int y2) {
 int x = (x1-x2);
 int y = (y1-y2);
 return Sqrt(x*x+y*y);
}

//Returns the direction of the vector from point 1 to point 2, in degrees from -180 to 180. (0 = right)
float Angle(int x1, int y1, int x2, int y2) {
  return ArcTan(x2-x1, y2-y1)*57.2958;
}

//The above, but in radians.
float RadianAngle(int x1, int y1, int x2, int y2) {
  return ArcTan(x2-x1, y2-y1);
}

// Returns the X component of a vector with a degree angle.
// A length of 3 and angle of 0 returns 3.
// A length of 3 and angle of 45 returns approx. 1.57.
// A length of 3 and angle of 90 returns 0.
float VectorX(int len, float angle) {
  return Cos(angle)*len;
}

// Returns the Y component of a vector with a degree angle.
// A length of 3 and angle of 0 returns 0.
// A length of 3 and angle of 45 returns approx. 1.57.
// A length of 3 and angle of 90 returns 3.
float VectorY(int len, float angle) {
  return Sin(angle)*len;
}

//rotates X about a center point by an amount of degrees
float RotatePointX(float x, float y, float centerX, float centerY, float degrees) {
  float dx = x - centerX;
  float dy = y - centerY;
  return (Cos(degrees) * dx) - (Sin(degrees) * dy) + centerX;
}

//rotates Y about a center point by an amount of degrees
float RotatePointY(float x, float y, float centerX, float centerY, float degrees) {
  float dx = x - centerX;
  float dy = y - centerY;
  return (Sin(degrees) * dx) - (Cos(degrees) * dy) + centerY;
}

//scales X to centerX by a given scale
float ScalePointX(float x, float centerX, float scale) {
  return (scale * (x - centerX)) + centerX; 
}

//scales Y to centerY by a given scale
float ScalePointY(float y, float centerY, float scale) {
  return (scale * (y - centerY)) + centerY; 
}

//rotates and scales X about a center point by an amount of degrees
float RotateScalePointX(float x, float y, float centerX, float centerY, float degrees, float scaleX, float scaleY) {
  float dx = (x - centerX) * scaleX;
  float dy = (y - centerY) * scaleY;
  return (Cos(degrees) * dx) - (Sin(degrees) * dy) + centerX;
}

//rotates and scales Y about a center point by an amount of degrees
float RotateScalePointY(float x, float y, float centerX, float centerY, float degrees, float scaleX, float scaleY) {
  float dx = (x - centerX) * scaleX;
  float dy = (y - centerY) * scaleY;
  return (Sin(degrees) * dx) - (Cos(degrees) * dy) + centerY;
}


// Interpolates between p1 and p2 given 't' clamped within range 0,1.
float Lerp(float p1, float p2, float t) {
  return (p1 + (p2 - p1) * t);
}

// Returns the dot product of two vectors.
float DotProduct( float x1, float y1, float x2, float y2 ) {
  return (x1 * x2 + y1 * y2);
}

// Returns the cross product of two vectors.
float CrossProduct( float x1, float y1, float x2, float y2 ) {
  return (x1 * y2 - y1 * x2);
}

// Returns the squared distance of a vector.
float DistanceSquared( float x, float y ) {
  return (x * x + y * y);
}

// Finds the center of p1 and p2.
float Midpoint(float p1, float p2) {
  return Lerp(p1, p2, 0.5);
}

// Performs a "Smooth" Interpolation given 't' clamped within range 0,1.
float SmoothStep(float p1, float p2, float t) {
  t = (t * t) * (3.0 - (2.0 * t));
  return Lerp(p1, p2, t);
}

// Returns an angle pointing (t)percentage more accurate to the target than the specified radian_angle.
float TurnTowards( int X, int Y, int targetX, int targetY, float radian_angle, float t ) {
  float a = ArcTan( targetX - X, targetY - Y );
  float d = WrapAngle(a - radian_angle);
  if ( d > PI )
    d =-( PI2 - d );
  else if ( d < -PI )
    d = PI2 + d;
  return WrapAngle(radian_angle + d * t);
}

// Wraps radian value towards the range of -PI,PI.
float WrapAngle( float radians ) {
  while (radians <= -PI) radians += PI2;
  while (radians > PI) radians -= PI2;
  return radians;
}

// Wraps degree value towards the range of -180,180.
float WrapDegrees( float degrees ) {
  while (degrees <= -180) degrees += 360;
  while (degrees > 180) degrees -= 360;
  return degrees;
}

// Converts a counterclockwise degree angle (from -180 to 180) into one of the eight
// standard directions (DIR_UP etc.) used by ZC.
int AngleDir8(float angle) {
  if (angle <= 157.5 && angle > 112.5)
    return DIR_LEFTDOWN;
  else if (angle <= 112.5 && angle > 67.5)
    return DIR_DOWN;
  else if (angle <= 67.5 && angle > 22.5)
    return DIR_RIGHTDOWN;
  else if (angle <= 22.5 && angle > -22.5)
    return DIR_RIGHT;
  else if (angle <= -22.5 && angle > -67.5)
    return DIR_RIGHTUP;
  else if (angle <= -67.5 && angle > -112.5)
    return DIR_UP;
  else if (angle <= -112.5 && angle > -157.5)
    return DIR_LEFTUP;
  else
    return DIR_LEFT;
}

//The above, but for radian angles.
int RadianAngleDir8(float angle) {
  return AngleDir8(angle*57.2958);
}

// Converts a counterclockwise degree angle (from -180 to 180) into one of the four
// standard directions (DIR_UP, DIR_DOWN, DIR_LEFT, DIR_RIGHT) used by ZC.
int AngleDir4(float angle) {
  if (angle <= 135 && angle > 45)
    return DIR_DOWN;
  else if (angle <= 45 && angle > -45)
    return DIR_RIGHT;
  else if (angle <= -45 && angle > -135)
    return DIR_UP;
  else
    return DIR_LEFT;
}

//The above, but for radian angles.
int RadianAngleDir4(float angle) {
  return AngleDir4(angle*57.2958);
}

//Returns the opposite direction to angle 'dir'
int OppositeDir(int dir) {
	return Cond(dir < 4, dir^1b, dir^11b);
}

//Converts directions to go round in a circle rather than U, D, L, R
int SpinDir(int dir) {
	if(dir == DIR_DOWN || dir == DIR_RIGHT)
        return dir;
	else if(dir == DIR_LEFT)
		return DIR_UP;
	else if(dir == DIR_UP)
	    return DIR_LEFT;
	return -1;
}

//Draws an ffc to a given layer. If the ffc is larger than 1x1 its graphics must all be comboed
void DrawToLayer(ffc f, int layer, int opacity){
	Screen->DrawCombo(layer,f->X,f->Y,f->Data,f->TileWidth,f->TileHeight,f->CSet,-1,-1,0,0,0,-1,0,true,opacity);
}

//Draws an npc to a given layer
void DrawToLayer(npc n, int layer, int opacity){
	Screen->DrawTile(layer,n->X,n->Y,n->Tile,n->TileWidth,n->TileHeight,n->CSet,-1,-1,0,0,0,0,true,opacity);
}

//Draws an lweapon to a given layer
void DrawToLayer(lweapon l, int layer, int opacity){
	Screen->DrawTile(layer,l->X,l->Y,l->Tile,l->TileWidth,l->TileHeight,l->CSet,-1,-1,0,0,0,0,true,opacity);
}

//Draws an eweapon to a given layer
void DrawToLayer(eweapon e, int layer, int opacity){
	Screen->DrawTile(layer,e->X,e->Y,e->Tile,e->TileWidth,e->TileHeight,e->CSet,-1,-1,0,0,0,0,true,opacity);
}

//Draws an item to a given layer
void DrawToLayer(item i, int layer, int opacity){
	Screen->DrawTile(layer,i->X,i->Y,i->Tile,i->TileWidth,i->TileHeight,i->CSet,-1,-1,0,0,0,0,true,opacity);
}

//Generalized and optimized rectangle collision checking function.
//Returns true if the bounding box of box1 and box2 overlap.
bool RectCollision(int box1_x1, int box1_y1, int box1_x2, int box1_y2, int box2_x1, int box2_y1, int box2_x2, int box2_y2) {
  if( box1_y2 < box2_y1 ) return false;
  else if( box1_y1 > box2_y2 ) return false;
  else if( box1_x2 < box2_x1 ) return false;
  else if( box1_x1 > box2_x2 ) return false;
  return true;
}

//Check for collisions of two squares given upper-left coordinates and a side length for each.
bool SquareCollision(int c1x, int c1y, int side1, int c2x, int c2y, int side2) {
  return RectCollision(c1x, c1y, c1x+side1, c1y+side1, c2x, c2y, c2x+side1, c2y+side1);
}

//Check for collisions of two squares given center coordinates and a halved side length for each.
bool SquareCollision2(int c1x, int c1y, int radius1, int c2x, int c2y, int radius2) {
  if( c1y + radius1 < c2y - radius2 ) return false;
  else if( c1y - radius1 > c2y + radius2 ) return false;
  else if( c1x + radius1 < c2x - radius2 ) return false;
  else if( c1x - radius1 > c2x + radius2 ) return false;
  return true;
}

//Returns true if the two circles c1 and c2 overlap.
bool CircleCollision(int c1x, int c1y, int radius1, int c2x, int c2y, int radius2) {
  return (Distance(c1x,c1y,c2x,c2y) <= (radius1+radius2));
}

//Returns true if there is a collision between the hitboxes of an lweapon and an eweapon.
bool Collision(lweapon a, eweapon b) {
  int ax = a->X + a->HitXOffset;
  int bx = b->X + b->HitXOffset;
  int ay = a->Y + a->HitYOffset;
  int by = b->Y + b->HitYOffset;
  return RectCollision(ax, ay, ax+a->HitWidth, ay+a->HitHeight, bx, by, bx+b->HitWidth, by+b->HitHeight) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//A collision between an lweapon and an lweapon.
bool Collision(lweapon a, lweapon b) {
  int ax = a->X + a->HitXOffset;
  int bx = b->X + b->HitXOffset;
  int ay = a->Y + a->HitYOffset;
  int by = b->Y + b->HitYOffset;
  return RectCollision(ax, ay, ax+a->HitWidth, ay+a->HitHeight, bx, by, bx+b->HitWidth, by+b->HitHeight) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//A collision between an eweapon and an eweapon.
bool Collision(eweapon a, eweapon b) {
  int ax = a->X + a->HitXOffset;
  int bx = b->X + b->HitXOffset;
  int ay = a->Y + a->HitYOffset;
  int by = b->Y + b->HitYOffset;
  return RectCollision(ax, ay, ax+a->HitWidth, ay+a->HitHeight, bx, by, bx+b->HitWidth, by+b->HitHeight) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//A collision between an lweapon and an npc.
bool Collision(lweapon a, npc b) {
  int ax = a->X + a->HitXOffset;
  int bx = b->X + b->HitXOffset;
  int ay = a->Y + a->HitYOffset;
  int by = b->Y + b->HitYOffset;
  return RectCollision(ax, ay, ax+a->HitWidth, ay+a->HitHeight, bx, by, bx+b->HitWidth, by+b->HitHeight) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//A collision between an eweapon and an npc.
bool Collision(eweapon a, npc b) {
  int ax = a->X + a->HitXOffset;
  int bx = b->X + b->HitXOffset;
  int ay = a->Y + a->HitYOffset;
  int by = b->Y + b->HitYOffset;
  return RectCollision(ax, ay, ax+a->HitWidth, ay+a->HitHeight, bx, by, bx+b->HitWidth, by+b->HitHeight) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//A collision between an npc and an npc.
bool Collision(npc a, npc b) {
  int ax = a->X + a->HitXOffset;
  int bx = b->X + b->HitXOffset;
  int ay = a->Y + a->HitYOffset;
  int by = b->Y + b->HitYOffset;
  return RectCollision(ax, ay, ax+a->HitWidth, ay+a->HitHeight, bx, by, bx+b->HitWidth, by+b->HitHeight) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//A collision between an item and an lweapon.
bool Collision(item a, lweapon b) {
  int ax = a->X + a->HitXOffset;
  int bx = b->X + b->HitXOffset;
  int ay = a->Y + a->HitYOffset;
  int by = b->Y + b->HitYOffset;
  return RectCollision(ax, ay, ax+a->HitWidth, ay+a->HitHeight, bx, by, bx+b->HitWidth, by+b->HitHeight) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//A collision between an item and an eweapon.
bool Collision(item a, eweapon b) {
  int ax = a->X + a->HitXOffset;
  int bx = b->X + b->HitXOffset;
  int ay = a->Y + a->HitYOffset;
  int by = b->Y + b->HitYOffset;
  return RectCollision(ax, ay, ax+a->HitWidth, ay+a->HitHeight, bx, by, bx+b->HitWidth, by+b->HitHeight) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//A collision between an item and an npc.
bool Collision(item a, npc b) {
  int ax = a->X + a->HitXOffset;
  int bx = b->X + b->HitXOffset;
  int ay = a->Y + a->HitYOffset;
  int by = b->Y + b->HitYOffset;
  return RectCollision(ax, ay, ax+a->HitWidth, ay+a->HitHeight, bx, by, bx+b->HitWidth, by+b->HitHeight) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//A collision between an item and an item.
bool Collision(item a, item b) {
  int ax = a->X + a->HitXOffset;
  int bx = b->X + b->HitXOffset;
  int ay = a->Y + a->HitYOffset;
  int by = b->Y + b->HitYOffset;
  return RectCollision(ax, ay, ax+a->HitWidth, ay+a->HitHeight, bx, by, bx+b->HitWidth, by+b->HitHeight) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//A collision between an ffc and an lweapon. Uses TileWidth and TileHeight for the FFC's bounding box. Ignores the Z axis.
bool Collision(ffc f, lweapon b) {
  int bx = b->X + b->HitXOffset;
  int by = b->Y + b->HitYOffset;
  return RectCollision(f->X, f->Y, f->X+(f->TileWidth*16), f->Y+(f->TileHeight*16), bx, by, bx+b->HitWidth, by+b->HitHeight);
}

//A collision between an ffc and an eweapon. Uses TileWidth and TileHeight for the FFC's bounding box. Ignores the Z axis.
bool Collision(ffc f, eweapon b) {
  int bx = b->X + b->HitXOffset;
  int by = b->Y + b->HitYOffset;
  return RectCollision(f->X, f->Y, f->X+(f->TileWidth*16), f->Y+(f->TileHeight*16), bx, by, bx+b->HitWidth, by+b->HitHeight);
}

//A collision between an ffc and an npc. Uses TileWidth and TileHeight for the FFC's bounding box. Ignores the Z axis.
bool Collision(ffc f, npc b) {
  int bx = b->X + b->HitXOffset;
  int by = b->Y + b->HitYOffset;
  return RectCollision(f->X, f->Y, f->X+(f->TileWidth*16), f->Y+(f->TileHeight*16), bx, by, bx+b->HitWidth, by+b->HitHeight);
}

//A collision between an ffc and an item. Uses TileWidth and TileHeight for the FFC's bounding box. Ignores the Z axis.
bool Collision(ffc f, item b) {
  int bx = b->X + b->HitXOffset;
  int by = b->Y + b->HitYOffset;
  return RectCollision(f->X, f->Y, f->X+(f->TileWidth*16), f->Y+(f->TileHeight*16), bx, by, bx+b->HitWidth, by+b->HitHeight);
}

//A collision between an ffc and an ffc. Uses TileWidth and TileHeight for the FFCs' bounding boxes.
bool Collision(ffc f, ffc f2) {
  return RectCollision(f->X, f->Y, f->X+(f->TileWidth*16), f->Y+(f->TileHeight*16), f2->X, f2->Y, f2->X+f2->TileWidth*16, f2->Y+f2->TileHeight*16);
}

//A circular collision between an ffc and an ffc. Uses TileWidth and TileHeight to find the centre of the FFCs.
bool Collision(ffc f, int radius1, ffc f2, int radius2) {
    return CircleCollision(f->X+f->TileWidth/2, f->Y+f->TileHeight/2, radius1,f2->X+f2->TileWidth/2, f2->Y+f2->TileHeight/2, radius2);
}

// So that you don't have to remember the ordering of the args
bool Collision(eweapon a, lweapon b) {
  return Collision(b, a);
}

bool Collision(npc a, lweapon b) {
  return Collision(b, a);
}

bool Collision(npc a, eweapon b) {
  return Collision(b, a);
}

bool Collision(lweapon a, item b) {
  return Collision(b, a);
}

bool Collision(eweapon a, item b) {
  return Collision(b, a);
}

bool Collision(npc a, item b) {
  return Collision(b, a);
}

bool Collision(lweapon a, ffc b) {
  return Collision(b, a);
}

bool Collision(eweapon a, ffc b) {
  return Collision(b, a);
}

bool Collision(npc a, ffc b) {
  return Collision(b, a);
}

bool Collision(item a, ffc b) {
  return Collision(b, a);
}

// Returns true if there is a collision between Link's hitbox and the eweapon's.
// This only checks hitboxes.
bool LinkCollision(eweapon b) {
  int ax = Link->X + Link->HitXOffset;
  int bx = b->X + b->HitXOffset;
  int ay = Link->Y + Link->HitYOffset;
  int by = b->Y + b->HitYOffset;
  return RectCollision(ax, ay, ax+Link->HitWidth, ay+Link->HitHeight, bx, by, bx+b->HitWidth, by+b->HitHeight) && (Link->Z + Link->HitZHeight >= b->Z) && (Link->Z <= b->Z + b->HitZHeight);
}

// Returns true if there is a collision between Link's hitbox and the lweapon's.
// This only checks hitboxes.
bool LinkCollision(lweapon b) {
  int ax = Link->X + Link->HitXOffset;
  int bx = b->X + b->HitXOffset;
  int ay = Link->Y + Link->HitYOffset;
  int by = b->Y + b->HitYOffset;
  return RectCollision(ax, ay, ax+Link->HitWidth, ay+Link->HitHeight, bx, by, bx+b->HitWidth, by+b->HitHeight) && (Link->Z + Link->HitZHeight >= b->Z) && (Link->Z <= b->Z + b->HitZHeight);
}

// Returns true if there is a collision between Link's hitbox and the item's.
// This only checks hitboxes.
bool LinkCollision(item b) {
  int ax = Link->X + Link->HitXOffset;
  int bx = b->X + b->HitXOffset;
  int ay = Link->Y + Link->HitYOffset;
  int by = b->Y + b->HitYOffset;
  return RectCollision(ax, ay, ax+Link->HitWidth, ay+Link->HitHeight, bx, by, bx+b->HitWidth, by+b->HitHeight) && (Link->Z + Link->HitZHeight >= b->Z) && (Link->Z <= b->Z + b->HitZHeight);
}

// Returns true if there is a collision between Link's hitbox and the npc's.
// This only checks hitboxes.  Uses TileWidth and TileHeight to find the centre of the FFCs.
bool LinkCollision(npc b) {
  int ax = Link->X + Link->HitXOffset;
  int bx = b->X + b->HitXOffset;
  int ay = Link->Y + Link->HitYOffset;
  int by = b->Y + b->HitYOffset;
  return RectCollision(ax, ay, ax+Link->HitWidth, ay+Link->HitHeight, bx, by, bx+b->HitWidth, by+b->HitHeight) && (Link->Z + Link->HitZHeight >= b->Z) && (Link->Z <= b->Z + b->HitZHeight);
}

// Returns true if there is a collision between Link's hitbox and the FFC's.
// This only checks hitboxes.
bool LinkCollision(ffc f) {
  int ax = Link->X + Link->HitXOffset;
  int ay = Link->Y + Link->HitYOffset;
  return RectCollision(f->X, f->Y, f->X+(f->TileWidth*16), f->Y+(f->TileHeight*16), ax, ay, ax+Link->HitWidth, ay+Link->HitHeight);
}

// Returns the X coordinate of the left edge of the hitbox.
int HitboxLeft(eweapon a) {
  return (a->X + a->HitXOffset);
}

int HitboxLeft(lweapon a) {
  return (a->X + a->HitXOffset);
}

int HitboxLeft(item a) {
  return (a->X + a->HitXOffset);
}

int HitboxLeft(npc a) {
  return (a->X + a->HitXOffset);
}

int HitboxLeft(ffc a) {
  return a->X;
}

// Returns the X coordinate of the right edge of the hitbox.
int HitboxRight(eweapon a) {
  return (a->X + a->HitXOffset + a->HitWidth - 1);
}

int HitboxRight(lweapon a) {
  return (a->X + a->HitXOffset + a->HitWidth - 1);
}

int HitboxRight(item a) {
  return (a->X + a->HitXOffset + a->HitWidth - 1);
}

int HitboxRight(npc a) {
  return (a->X + a->HitXOffset + a->HitWidth - 1);
}

int HitboxRight(ffc a) {
  return a->X + a->TileWidth*16 - 1;
}

// Returns the Y coordinate of the top edge of the hitbox.
int HitboxTop(eweapon a) {
  return (a->Y + a->HitYOffset);
}

int HitboxTop(lweapon a) {
  return (a->Y + a->HitYOffset);
}

int HitboxTop(item a) {
  return (a->Y + a->HitYOffset);
}

int HitboxTop(npc a) {
  return (a->Y + a->HitYOffset);
}

int HitboxTop(ffc a) {
  return a->Y;
}

// Returns the Y coordinate of the bottom edge of the hitbox.
int HitboxBottom(eweapon a) {
  return (a->Y + a->HitYOffset + a->HitHeight - 1);
}

int HitboxBottom(lweapon a) {
  return (a->Y + a->HitYOffset + a->HitHeight - 1);
}

int HitboxBottom(item a) {
  return (a->Y + a->HitYOffset + a->HitHeight - 1);
}

int HitboxBottom(npc a) {
  return (a->Y + a->HitYOffset + a->HitHeight - 1);
}

//Uses TileWidth and TileHeight for the FFC's bounding box. 
int HitboxBottom(ffc a) {
  return a->Y + (a->TileHeight*16) - 1;
}

//Returns the number of an FFC, and -1 for a non-valid FFC (which should never happen)
int FFCNum(ffc f) {
    for(int i=1; i<=32; i++)
      if(f == Screen->LoadFFC(i))
        return i;
    return -1;
}

//Functions for those who are not comfortable with binary
//Returns true if the left mouse button is pressed
bool InputLeftClick() {
	return (Link->InputMouseB&MB_LEFTCLICK) != 0;
}

//Returns true if the right mouse button is pressed
bool InputRightClick() {
	return (Link->InputMouseB&MB_RIGHTCLICK) != 0;
}

//Returns the item ID of the item equipped to Link's A button
int GetEquipmentA() {
	return (Link->Equipment&0xFF);
}

//Returns the item ID of the item equipped to Link's B button
int GetEquipmentB() {
	return ((Link->Equipment&0xFF00)>>8);
}

//Returns true if Link is using item 'id'
bool UsingItem(int id){
	return (GetEquipmentA() == id && Link->InputA) || (GetEquipmentB() == id && Link->InputB);
}

//Returns the number of Triforce Pieces Link currently has
int NumTriforcePieces(){
    int ret = 0;
    for(int i=1;i<=8;i++)
        if(Game->LItems[i]&LI_TRIFORCE) ret++;
    return ret;
}

//Returns 1 if Screen Flag 'flag' is set from category 'category', 0 if it's not and -1 if an invalid flag is passed
//Flags are numbered starting from 0
int ScreenFlag(int category, int flag) {
	int catsizes[] = {3,7,5,3,2,4,4,2,3,7};
	if(flag < 0 || flag >= catsizes[category]) return -1;
	return Screen->Flags[category]&(1<<flag);
}

//Returns 1 if Screen Enemy Flag 'flag' is set from category 'category', 0 if it's not and -1 if an invalid flag is passed
//Flags are numbered starting from 0
int ScreenEFlag(int category, int flag) {
	int catsizes[] = {6,6,5};
	if(flag < 0 || flag >= catsizes[category]) return -1;
	return Screen->EFlags[category]&(1<<flag);
}

//Returns true if DMap Flag 'flag' is set on dmap 'dmap'
bool GetDMapFlag(int dmap, int flag){
	return Game->DMapFlags[dmap]&(1<<flag);
}

//Sets a certain DMap flag to 'state'
void SetDMapFlag(int dmap, int flag, bool state){
	if(state) Game->DMapFlags[dmap] |= flag;
	else Game->DMapFlags[dmap] &= ~flag;
}

//Returns true if an item's Pickup state is set
//Use the IP_ constants for the 'pickup' argument of this function
bool GetItemPickup(item i, int pickup) {
	return (i->Pickup&pickup) != 0;
}

//Sets an item's Pickup state to 'state'
void SetItemPickup(item i, int pickup, bool state) {
	if(state) i->Pickup |= pickup;
	else i->Pickup &= ~pickup;
}

//Returns true if an npc's Misc. flag is set.
bool GetNPCMiscFlag(npc e, int flag) {
	return (e->MiscFlags&flag) != 0;
}

//Returns true if Link has the level item 'itm' from level 'level'
//Overloaded to use the current level if no 'level' arg is entered
//Use the LI_ constants for the 'itm' argument
bool GetLevelItem(int level, int itm) {
	return (Game->LItems[level]&itm) != 0;
}
bool GetLevelItem(int itm) {
	return (Game->LItems[Game->GetCurLevel()]&itm) != 0;
}
//Gives or removes a level item from Link's inventory
void SetLevelItem(int level, int itm, bool state) {
	if(state) Game->LItems[level] |= itm;
	else Game->LItems[level] &= ~itm;
}
void SetLevelItem(int itm, bool state) {
	if(state) Game->LItems[Game->GetCurLevel()] |= itm;
	else Game->LItems[Game->GetCurLevel()] &= ~itm;
}

//Create an NPC and set its X and Y position in one command
npc CreateNPCAt(int id, int x, int y) {
  npc nme = Screen->CreateNPC(id);
  nme->X = x;
  nme->Y = y;
  return nme;
}

//Create an Item and set its X and Y position in one command
item CreateItemAt(int id, int x, int y) {
  item it = Screen->CreateItem(id);
  it->X = x;
  it->Y = y;
  return it;
}

//Create an LWeapon and set its X and Y position in one command
lweapon CreateLWeaponAt(int id, int x, int y) {
  lweapon lw = Screen->CreateLWeapon(id);
  lw->X = x;
  lw->Y = y;
  return lw;
}

//Create an EWeapon and set its X and Y position in one command
eweapon CreateEWeaponAt(int id, int x, int y) {
  eweapon ew = Screen->CreateEWeapon(id);
  ew->X = x;
  ew->Y = y;
  return ew;
}


//Creates an lweapon at 'distx,disty' away from where Link is facing
lweapon NextToLink(int id, int distx, int disty) {
	lweapon l = CreateLWeaponAt(id, Link->X+InFrontX(Link->Dir, distx), Link->Y+InFrontY(Link->Dir, disty));
	l->Dir = Link->Dir;
	return l;
}

//Creates an lweapon 'dist' pixels away from the front of Link
lweapon NextToLink(int id, int dist) {
	return NextToLink(id, dist, dist);
}

eweapon NextToNPC(npc n, int id, int distx, int disty) {
	eweapon e = CreateEWeaponAt(id, n->X+InFrontX(n->Dir, distx), n->Y+InFrontY(n->Dir, disty));
	e->Dir = n->Dir;
	return e;
}
eweapon NextToNPC(npc n, int id, int dist) {
	return NextToNPC(n, id, dist, dist);
}


//Aim-type constants, for use with AimEWeapon
const int AT_NONE			= 0;
const int AT_4DIR			= 1;
const int AT_8DIR			= 2;
const int AT_ANGULAR		= 3;
const int AT_RAND4DIR		= 4;
const int AT_RAND8DIR		= 5;
const int AT_RANDANGULAR	= 6;

//Various methods for shooting at Link and at random
void AimEWeapon(eweapon e, int aimtype)
{
	int angle = RadianAngle(e->X, e->Y, Link->X, Link->Y);
	if(aimtype == AT_4DIR)
	{
		e->Dir = RadianAngleDir4(angle);
	}
	else if(aimtype == AT_8DIR)
	{
		e->Dir = RadianAngleDir8(angle);
	}
	else if(aimtype == AT_ANGULAR)
	{
		e->Angular = true;
		e->Angle = angle;
		e->Dir = RadianAngleDir8(angle);
	}
	else if(aimtype == AT_RAND4DIR)
	{
		e->Dir = Rand(4);
	}
	else if(aimtype == AT_RAND8DIR)
	{
		e->Dir = Rand(8);
	}
	else if(aimtype == AT_RANDANGULAR)
	{
		e->Angular = true;
		e->Angle = Randf(PI2);
		e->Dir = RadianAngleDir8(e->Angle);
	}
}

//Aiming at enemies and at random
void AimLWeapon(lweapon l, npc n, int aimtype)
{
	int angle = RadianAngle(l->X, l->Y, n->X, n->Y);
	if(aimtype == AT_4DIR)
	{
		l->Dir = RadianAngleDir4(angle);
	}
	else if(aimtype == AT_8DIR)
	{
		l->Dir = RadianAngleDir8(angle);
	}
	else if(aimtype == AT_ANGULAR)
	{
		l->Angular = true;
		l->Angle = angle;
		l->Dir = RadianAngleDir8(angle);
	}
	else
		AimLWeapon(l, aimtype);
}
void AimLWeapon(lweapon l, int aimtype)
{
	if(aimtype == AT_RAND4DIR)
	{
		l->Dir = Rand(4);
	}
	else if(aimtype == AT_RAND8DIR)
	{
		l->Dir = Rand(8);
	}
	else if(aimtype == AT_RANDANGULAR)
	{
		l->Angular = true;
		l->Angle = Randf(PI2);
		l->Dir = RadianAngleDir8(l->Angle);
	}
}

//Turns a WPN_ constant to an EW_ constant
int WeaponTypeToID(int wpnt)
{
	if(wpnt == WPN_ENEMYFLAME) 		return EW_FIRE;
	else if(wpnt == WPN_ENEMYWIND)		return EW_WIND;
	else if(wpnt == WPN_ENEMYFIREBALL)	return EW_FIREBALL;
	else if(wpnt == WPN_ENEMYARROW)		return EW_ARROW;
	else if(wpnt == WPN_ENEMYBRANG)		return EW_BRANG;
	else if(wpnt == WPN_ENEMYSWORD)		return EW_BEAM;
	else if(wpnt == WPN_ENEMYROCK)		return EW_ROCK;
	else if(wpnt == WPN_ENEMYMAGIC)		return EW_MAGIC;
	else if(wpnt == WPN_ENEMYBOMB)		return EW_BOMB;
	else if(wpnt == WPN_ENEMYSBOMB)		return EW_SBOMB;
	else if(wpnt == WPN_ENEMYLITBOMB)	return EW_BOMBBLAST;
	else if(wpnt == WPN_ENEMYLITSBOMB)	return EW_SBOMBBLAST;
	else if(wpnt == WPN_ENEMYFIRETRAIL)	return EW_FIRETRAIL;
	else if(wpnt == WPN_ENEMYFLAME2)	return EW_FIRE2;
	else if(wpnt == WPN_ENEMYFIREBALL2)	return EW_FIREBALL2;
	return -1;
}


//Removes LWeapon 'l' from the screen
void Remove(lweapon l){
	if(!l->isValid()) return;
	l->DeadState = WDS_DEAD;
	l->X = 256;
}

//Removes EWeapon 'e' from the screen
void Remove(eweapon e){
	if(!e->isValid()) return;
	e->DeadState = WDS_DEAD;
	e->X = 256;
}

//Removes Item 'i' from the screen
void Remove(item i){
	if(!i->isValid()) return;
	i->X = 256;
}

//Removes NPC 'n' from the screen
void Remove(npc n){
	if(!n->isValid()) return;
	n->X = 256;
	n->HP = -1000;
}

//Creates a timeout item (like a rupee or heart)
item CreateTimeoutItem(int id, int x, int y) {
	item Spawn = Screen->CreateItem(id);
	SetItemPickup(Spawn, IP_TIMEOUT, true);
	Spawn->HitWidth = 16; Spawn->HitHeight = 16;
	Spawn->X = x; Spawn->Y = y;
}

// Use the I_ constants.
// Warning: these iterate over every onscreen item.
// Iterating over every onscreen lweapon multiple times per frame may
// cause slowdown in Zelda Classic.
int NumItemsOf(int type) {
 int ret = 0;
 item it;
 for (int i = Screen->NumItems(); i >0 ; i--) {
  it = Screen->LoadItem(i);
  if (it->ID == type)
   ret++;
 }
 return ret;
}


// Use the LW_ constants.
// Warning: these iterate over every onscreen lweapon.
// Iterating over every onscreen lweapon multiple times per frame may
// cause slowdown in Zelda Classic.
int NumLWeaponsOf(int type) {
 int ret = 0;
 lweapon w;
 for (int i = Screen->NumLWeapons(); i > 0; i--) {
  w = Screen->LoadLWeapon(i);
  if (w->ID == type)
   ret++;
 }
 return ret;
}

int NumEWeaponsOf(int type) {
 int ret = 0;
 eweapon w;
 for (int i = Screen->NumEWeapons(); i > 0; i--) {
  w = Screen->LoadEWeapon(i);
  if (w->ID == type)
   ret++;
 }
 return ret;
}

int NumNPCsOf(int type) {
 int ret = 0;
 npc n;
 for (int i = Screen->NumNPCs(); i > 0 ; i--) {
  n = Screen->LoadNPC(i);
  if (n->ID == type)
   ret++;
 }
 return ret;
}

// Returns the first LWeapon of the given type. Use the LW_ constants.
// If none exist, it returns an uninitialised pointer.
lweapon LoadLWeaponOf(int type) {
 lweapon w;
 for (int i=1; i <= Screen->NumLWeapons(); i++) {
  w = Screen->LoadLWeapon(i);
  if (w->ID == type) return w;
 }
 lweapon w2;
 return w2;
}

// Returns the first EWeapon of the given type. Use the EW_ constants.
// If none exist, it returns an uninitialised pointer.
eweapon LoadEWeaponOf(int type) {
 eweapon w;
 for (int i=1; i <= Screen->NumEWeapons(); i++) {
  w = Screen->LoadEWeapon(i);
  if (w->ID == type) return w;
 }
 eweapon w2;
 return w2;
}

// Returns the first NPC of the given type. Use the NPCT_ constants.
// If none exist, it returns an uninitialised pointer.
npc LoadNPCOfType(int type) {
 npc n;
 for (int i=1; i <= Screen->NumNPCs(); i++) {
  n = Screen->LoadNPC(i);
  if (n->Type == type) return n;
 }
 npc n2;
 return n2;
}

// Returns the first NPC of the given ID. Use the NPC_ constants.
// If none exist, it returns an uninitialised pointer.
npc LoadNPCOf(int type) {
 npc n;
 for (int i=1; i <= Screen->NumNPCs(); i++) {
  n = Screen->LoadNPC(i);
  if (n->ID == type) return n;
 }
 npc n2;
 return n2;
}

//Returns the position of the first instance of the given combo, or -1.
int FirstComboOf(int t, int layer) {
  for (int i = 0; i < 176; i++) {
    if (layer == 0) {
      if (Screen->ComboD[i] == t)
	return i;
    }
    else {
      if (GetLayerComboD(layer,i) == t)
        return i;
    }
  }
  return -1;
}

//Returns the position of the last instance of the given combo, or -1.
int LastComboOf(int t, int layer) {
  for (int i = 175; i >= 0; i--) {
    if (layer == 0) {
      if (Screen->ComboD[i] == t)
	return i;
    }
    else {
      if (GetLayerComboD(layer,i) == t)
        return i;
    }
  }
  return -1;
}

//Returns the position of the first instance of the given combo, or -1.
int FirstComboTypeOf(int t, int layer) {
  for (int i = 0; i < 176; i++) {
    if (layer == 0) {
      if (Screen->ComboT[i] == t)
	return i;
    }
    else {
      if (GetLayerComboT(layer,i) == t)
        return i;
    }
  }
  return -1;
}

//Returns the position of the last instance of the given combo, or -1.
int LastComboTypeOf(int t, int layer) {
  for (int i = 175; i >= 0; i--) {
    if (layer == 0) {
      if (Screen->ComboT[i] == t)
	return i;
    }
    else {
      if (GetLayerComboT(layer,i) == t)
        return i;
    }
  }
  return -1;
}

//Returns the position of the first instance of the given combo flag, or -1.
//Checks inherent flags too!
int FirstComboFlagOf(int t, int layer) {
  for (int i = 0; i < 176; i++) {
    if (layer == 0) {
      if (Screen->ComboF[i] == t || Screen->ComboI[i] == t) return i;
    }
    else {
      if (Game->GetComboFlag(Screen->LayerMap(layer), Screen->LayerScreen(layer),i) == t
	  || Game->GetComboInherentFlag(Screen->LayerMap(layer), Screen->LayerScreen(layer),i) == t)
        return i;
    }
  }
  return -1;
}

//Returns the position of the last instance of the given combo flag, or -1.
//Checks inherent flags too!
int LastComboFlagOf(int t, int layer) {
  for (int i = 175; i >= 0; i--) {
    if (layer == 0) {
      if (Screen->ComboF[i] == t || Screen->ComboI[i] == t) return i;
    }
    else {
      if (Game->GetComboFlag(Screen->LayerMap(layer), Screen->LayerScreen(layer),i) == t
	  || Game->GetComboInherentFlag(Screen->LayerMap(layer), Screen->LayerScreen(layer),i) == t)
        return i;
    }
  }
  return -1;
}

// Returns true if the combo at the given position is water.
bool IsWater(int position)
{
    int combo=Screen->ComboT[position];
    if(combo==CT_WATER || combo==CT_SWIMWARP || combo==CT_DIVEWARP || (combo>=CT_SWIMWARPB && combo<=CT_DIVEWARPD))
        return true;
    else
        return false;
}

// Returns true if the combo at the given position is a pit.
bool IsPit(int position)
{
    int combo=Screen->ComboT[position];
    if(combo==CT_PIT || combo==CT_PITR || (combo>=CT_PITB && combo<=CT_PITD))
        return true;
    else
        return false;
}

//Creates and returns an exact copy of the passed LWeapon. Assumes that the passed pointer is valid.
lweapon Duplicate(lweapon a) {
  lweapon b = Screen->CreateLWeapon(a->ID);
  b->X = a->X;
  b->Y = a->Y;
  b->Z = a->Z;
  b->Jump = a->Jump;
  b->Extend = a->Extend;
  b->TileWidth = a->TileWidth;
  b->TileHeight = a->TileHeight;
  b->HitWidth = a->HitWidth;
  b->HitHeight = a->HitHeight;
  b->HitZHeight = a->HitZHeight;
  b->HitXOffset = a->HitXOffset;
  b->HitYOffset = a->HitYOffset;
  b->DrawXOffset = a->DrawXOffset;
  b->DrawYOffset = a->DrawYOffset;
  b->DrawZOffset = a->DrawZOffset;
  b->Tile = a->Tile;
  b->CSet = a->CSet;
  b->DrawStyle = a->DrawStyle;
  b->Dir = a->Dir;
  b->OriginalTile = a->OriginalTile;
  b->OriginalCSet = a->OriginalCSet;
  b->FlashCSet = a->FlashCSet;
  b->NumFrames = a->NumFrames;
  b->Frame = a->Frame;
  b->ASpeed = a->ASpeed;
  b->Damage = a->Damage;
  b->Step = a->Step;
  b->Angle = a->Angle;
  b->Angular = a->Angular;
  b->CollDetection = a->CollDetection;
  b->DeadState = a->DeadState;
  b->Flash = a->Flash;
  b->Flip = a->Flip;
  for (int i = 0; i < 16; i++)
    b->Misc[i] = a->Misc[i];
  return b;
}

//Creates and returns an exact copy of the passed EWeapon. Assumes that the passed pointer is valid.
eweapon Duplicate(eweapon a) {
  eweapon b = Screen->CreateEWeapon(a->ID);
  b->X = a->X;
  b->Y = a->Y;
  b->Z = a->Z;
  b->Jump = a->Jump;
  b->Extend = a->Extend;
  b->TileWidth = a->TileWidth;
  b->TileHeight = a->TileHeight;
  b->HitWidth = a->HitWidth;
  b->HitHeight = a->HitHeight;
  b->HitZHeight = a->HitZHeight;
  b->HitXOffset = a->HitXOffset;
  b->HitYOffset = a->HitYOffset;
  b->DrawXOffset = a->DrawXOffset;
  b->DrawYOffset = a->DrawYOffset;
  b->DrawZOffset = a->DrawZOffset;
  b->Tile = a->Tile;
  b->CSet = a->CSet;
  b->DrawStyle = a->DrawStyle;
  b->Dir = a->Dir;
  b->OriginalTile = a->OriginalTile;
  b->OriginalCSet = a->OriginalCSet;
  b->FlashCSet = a->FlashCSet;
  b->NumFrames = a->NumFrames;
  b->Frame = a->Frame;
  b->ASpeed = a->ASpeed;
  b->Damage = a->Damage;
  b->Step = a->Step;
  b->Angle = a->Angle;
  b->Angular = a->Angular;
  b->CollDetection = a->CollDetection;
  b->DeadState = a->DeadState;
  b->Flash = a->Flash;
  b->Flip = a->Flip;
  for (int i = 0; i < 16; i++)
    b->Misc[i] = a->Misc[i];
  return b;
}

//This should allow any scripted object to easily mimic Link styled LOZ solidity collision
//checking, be it Link, FFCs, or enemies.
//Note - You should use full_tile=true if you don't want the upper eight pixels to overlap
//solid combos as per LOZ1 behavior.
bool CanWalk(int x, int y, int dir, int step, bool full_tile) {
    int c=8;
    int xx = x+15;
    int yy = y+15;
    if(full_tile) c=0;
    if(dir==0) return !(y-step<0||Screen->isSolid(x,y+c-step)||Screen->isSolid(x+8,y+c-step)||Screen->isSolid(xx,y+c-step));
    else if(dir==1) return !(yy+step>=176||Screen->isSolid(x,yy+step)||Screen->isSolid(x+8,yy+step)||Screen->isSolid(xx,yy+step));
    else if(dir==2) return !(x-step<0||Screen->isSolid(x-step,y+c)||Screen->isSolid(x-step,y+c+7)||Screen->isSolid(x-step,yy));
    else if(dir==3) return !(xx+step>=256||Screen->isSolid(xx+step,y+c)||Screen->isSolid(xx+step,y+c+7)||Screen->isSolid(xx+step,yy));
    return false; //invalid direction
}

//Returns true if Link is on a sideview screen
bool IsSideview() {
	return Screen->Flags[SF_ROOMTYPE] & 4;
}

//Returns true if the sprite at (x,y) is standing on a sideview platform on a sideview screen, as worked out
//by ZC's internal code.
//For 16 pixel high sprites only.
bool OnSidePlatform(int x, int y) {
    return (Screen->isSolid(x+4,y+16) && Screen->isSolid(x+12,y+16) && Screen->Flags[SF_ROOMTYPE]&4);
}

//Returns true if a sprite of height 'h' at position (x,y) with an offset of (xOff,yOff) is standing
//on a sideview platform on a sideview screen.
bool OnSidePlatform(int x, int y, int xOff, int yOff, int h) {
    return (Screen->isSolid((x+xOff)+4,(y+yOff)+h) && Screen->isSolid((x+xOff)+12,(y+yOff)+h) && Screen->Flags[SF_ROOMTYPE]&4);
}

//Kills all of Link's inputs
void NoAction()
{
	Link->InputUp = false; Link->PressUp = false;
	Link->InputDown = false; Link->PressDown = false;
	Link->InputLeft = false; Link->PressLeft = false;
	Link->InputRight = false; Link->PressRight = false;
	Link->InputR = false; Link->PressR = false;
	Link->InputL = false; Link->PressL = false;
	Link->InputA = false; Link->PressA = false;
	Link->InputB = false; Link->PressB = false;
	Link->InputEx1 = false; Link->PressEx1 = false;
	Link->InputEx2 = false; Link->PressEx2 = false;
	Link->InputEx3 = false; Link->PressEx3 = false;
	Link->InputEx4 = false; Link->PressEx4 = false;
}

//NoAction, then Waitframe or (equivalent of) Waitframes
void WaitNoAction()
{
	NoAction();
	Waitframe();
}
void WaitNoAction(int frames)
{
	for(int i = 0; i < frames; i++)
		WaitNoAction();
}

//Get an NPC's name from an ID
void GetNPCName(int ID, int string)
{
	npc n = Screen->CreateNPC(ID);
	n->GetName(string);
	Remove(n);
}

void GetMessage(int ID, int string)
{
	Game->GetMessage(ID, string);
	int i;
	for(i = MAX_MESSAGELENGTH-1; string[i] == ' '; i--);
	string[i+1] = 0;
}

itemdata GetItemData(item i)
{
	return Game->LoadItemData(i->ID);
}

int GetHighestLevelItem(int itemclass)
{
	itemdata id;
	int ret = -1;
	int curlevel = -1000;
	//143 is default max items, increase if you add lots of your own
	for(int i = 0; i < 143; i++)
	{
		id = Game->LoadItemData(i);
		if(id->Family != itemclass)
			continue;
		if(id->Level > curlevel)
		{
			curlevel = id->Level;
			ret = i;
		}
	}
	return ret;
}

int GetHighestLevelItem(item i)
{
	itemdata argid = GetItemData(i);
	int ret = i->ID;
	int curlevel = argid->Level;
	itemdata id;
	//143 is max items, decrease to improve speed if you need to
	for(int i = 0; i < 256; i++)
	{
		id = Game->LoadItemData(i);
		if(id->Family != argid->Family)
			continue;
		if(id->Level > curlevel)
		{
			curlevel = id->Level;
			ret = i;
		}
	}
	return ret;
}
