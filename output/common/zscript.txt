================================================
--- ZScript built-in functions and variables ---
================================================

Functions and variables other than global functions are properties
of objects. The syntax for using them is [object name]->[property]
where "[object name]" is the object's name and "[property]" is the
property. "Link", "Screen" and "Game" are Link, Screen and Game
objects that are always available and don't need to be instantiated.

In the following, "int" indicates that a parameter is truncated
by a function to an integer, or that the return value will always
be an integer. ZScript itself makes no distinction between int and
float.

========================
--- Global Functions ---
========================

int Rand(int maxvalue)
 * Computes and returns a random integer i such that 0 <= i < maxvalue.
 * The return value is undefined if maxvalue is 0 or negative.

void Quit()
 * Terminates execution of the current script. Does not return.

void Waitframe()
 * Temporarily halts execution of the current script. This function returns at the beginning of the next frame of gameplay.
 * Slots 1, 3 and 4 Global scripts and item scripts only execute for one frame, so in those scripts Waitframe() is essentially Quit().
 * It is safe to call Waitframe in global script slot 2.

void Waitdraw()
 * Halts execution of the script until ZC's internal code has been run (movement, collision detection, etc.),
 * but before the screen is draw.

void Trace(float val)
 * Prints a line containing a string representation of val to allegro.log.
 * Useful for debugging scripts.

void TraceB(bool state)
 * Prints a boolean state to allegro.log

void TraceS(int[] s)
 * Takes the array pointer as its argument, and prints it as a string to allegro.log
 * Maximum 512 characters. Functions from string.zh can be used to split larger strings.

void TraceToBase(int val, int base, int mindigits)
 * Prints a line in allegro.log representing 'val' in numerical base 'base',
 * where 2 <= base <= 36, with minimum digits 'mindigits'.
 * Can be useful for checking hex values or flags ORed together, or just to trace
 * an integer value, as Trace() always traces to four decimal places.

void TraceNL()
 * Traces a newline to allegro.log

void ClearTrace()
 * Clears allegro.log of all current traces and messages from Zelda Classic/ZQuest.

float Sin(float deg)
 * Returns the trigonometric sine of the parameter, which is interpreted
 * as a degree value.

float Cos(float deg)
 * Returns the trigonometric cosine of the parameter, which is
 * interpreted as a degree value.

float Tan(float deg)
 * Returns the trigonometric tangent of the parameter, which is
 * interpreted as a degree value. The return value is undefined if
 * deg is of the form 90 + 180n for an integral value of n.

float RadianSin(float rad)
 * Returns the trigonometric sine of the parameter, which is interpreted
 * as a radian value.

float RadianCos(float rad)
 * Returns the trigonometric cosine of the parameter, which is
 * interpreted as a radian value.

float RadianTan(float rad)
 * Returns the trigonometric tangent of the parameter, which is
 * interpreted as a radian value. The return value is undefined for
 * values of rad near (pi/2) + n*pi, for n an integer.

float ArcTan(int x, int y)
 * Returns the trigonometric arctangent of the coordinates, which is
 * interpreted as a radian value.

float ArcSin(float x)
 * Returns the trigonometric arcsine of x, which is
 * interpreted as a radian value.

float ArcCos(float x)
 * Returns the trigonometric arccosine of x, which is
 * interpreted as a radian value.

float Max(float a, float b)
 * Returns the greater of a and b.

float Min(float a, float b)
 * Returns the lesser of a and b.

int Pow(int base, int exp)
 * Returns base^exp. The return value is undefined for base=exp=0. Note
 * also negative values of exp may not be useful, as the return value is
 * truncated to the nearest integer.

int InvPow(int base, int exp)
 * Returns base^(1/exp). The return value is undefined for exp=0, or
 * if exp is even and base is negative. Note also that negative values
 * of exp may not be useful, as the return value is truncated to the
 * nearest integer.

float Log10(float val)
 * Returns the log of val to the base 10. Any value <= 0 will return 0.

float Ln(float val)
 * Returns the natural logarithm of val (to the base e). Any value <= 0 will return 0.

int Factorial(int val)
 * Returns val!. val < 0 returns 0.

float Abs(float val)
 * Return the absolute value of the parameter, if possible. If the
 * absolute value would overflow the parameter, the return value is
 * undefined.

float Sqrt(float val)
 * Computes the square root of the parameter. The return value is
 * undefined for val < 0.

void CopyTile(int srctile, int desttile)
 * Copies the tile specified by scrtile onto the tile space
 * specified by desttile.

void SwapTile(int firsttile, int secondtile)
 * Swaps the two tiles specified by firsttile and secondtile.

void ClearTile(int tileref)
 * Erases the tile specified by tileref.

int SizeOfArray(int array[])
 * Returns the size of the array pointed by 'array'



===================================
--- FFC Functions and Variables ---
===================================

int Data
 * The number of the combo associated with this FFC.

int Script
 * The number of the script assigned to the FFC. This will be automatically
 * set to 0 when the FFC's script halts. A script cannot change the script of
 * the FFC running it; in other words, anFFC->Script is read-only when anFFC==this.
 * When an FFC's script is changed, its arguments, Misc[], and registers will all
 * be set to 0, and it will start running from the beginning. Set ffc->InitD[]
 * before the script starts running to pass arguments to it.

int CSet
 * The cset of the FFC.

int Delay
 * The FFC's animation delay, in frames.

float X
 * The FFC's X position on the screen.

float Y
 * The FFC's Y position on the screen.

float Vx
 * The FFC's velocity's X-component.

float Vy
 * The FFC's velocity's Y-component.

float Ax
 * The FFC's acceleration's X-component.

float Ay
 * The FFC's acceleration's Y-component.

bool Flags[]
 * The FFC's set of flags. Use the FFCF_ constants in std.zh as the
 * index to access a particular flag.

int TileWidth
 * The number of tile columns composing the FFC.

int TileHeight
 * The number of tile rows composing the FFC.

int EffectWidth
 * The width of the area of effect of the combo associated with the FFC,
 * in pixels.

int EffectHeight
 * The height of the area of effect of the combo associated with the FFC,
 * in pixels.

int Link
 * The number of the FFC linked to by this FFC.

float InitD[]
 * The original values of the FFC's 8 D input values are they are stored in the
 * .qst file, regardles of whether they have been modified by ZScript.

float Misc[]
 * An array of 16 miscellaneous variables for you to use as you please.
 * These variables are not saved with the ffc.


====================================
--- Link Functions and Variables ---
====================================

int X
 * Link's X position on the screen, in pixels. Float values passed to this will be cast to int.

int Y
 * Link's Y position on the screen, in pixels. Float values passed to this will be cast to int.

int Z
 * Link's Z position on the screen, in pixels. Float values passed to this will be cast to int.

bool Invisible
 * Whether Link is currently being draw to the screen. Set true to remove him from view.

bool CollDetection
 * If true, Link's collision detection with npcs and eweapons is currently turned off.
 * This variable works on a different system to clocks and the level 4 cheat, so it will not
 * necessarily return true if they are set.

int Jump
 * Link's upward velocity, in pixels. If negative, Link will fall.
 * The downward acceleration of Gravity (in Init Data) modifies this value every frame.

int SwordJinx
 * The time, in frames, until Link regains use of his sword. -1 signifies
 * a permanent loss of the sword.

int ItemJinx
 * The time, in frames, until Link regains use of his items. -1 signifies
 * a permanent loss of his items.

int Drunk
 * The time, in frames, that Link will be 'drunk'. If positive, the player's
 * controls are randomly interfered with, causing Link to move erratically.
 * This value is decremented once per frame. As the value of Drunk approaches 0,
 * the intensity of the effect decreases.

int Dir
 * The direction Link is facing. Use the DIR_ constants in std.zh to set
 * or compare this variable. Note: even though Link can move diagonally if the
 * quest allows it, his sprite doesn't ever use any of the diagonal directions,
 * which are intended for enemies only.
 
int HitDir
 * The direction Link should bounce in when he is hit. This is mostly useful for
 * simulating getting hit by setting Link->Action to LA_GOTHURTLAND.

int HP
 * Link's current hitpoints, in 16ths of a heart.

int MP
 * Link's current amount of magic, in 32nds of a magic block.

int MaxHP
 * Link's maximum hitpoints, in 16ths of a heart.

int MaxMP
 * Link's maximum amount of magic, in 32nds of a magic block.

int Action
 * Link's current action. Use the LA_ constants in std.zh to set or
 * compare this value. The effect of writing to this field is currently
 * undefined.

int HeldItem
 * The item that Link is currently holding up; reading or setting this
 * field is undefined if Link's action is not current a hold action.
 * Use the I_ constants in std.zh to specify the item, or -1 to show
 * no item. Setting HeldItem to values other than -1 or a valid item
 * ID is undefined.

int LadderX
 * The X position of Link's stepladder, or 0 if no ladder is onscreen.
 * This is read-only; while setting it is not syntactically incorrect, it does nothing.

int LadderY
 * The Y position of Link's stepladder, or 0 if no ladder is onscreen.
 * This is read-only; while setting it is not syntactically incorrect, it does nothing.

*** Input Functions ***
 * The following Input* boolean values return true if the player is pressing
 * the corresponding button, analog stick, or key. Writing to this variable simulates
 * the press or release of that referenced button, analog stick, or key.

bool InputStart
bool InputMap
bool InputUp
bool InputDown
bool InputLeft
bool InputRight
bool InputA
bool InputB
bool InputL
bool InputR
bool InputEx1
bool InputEx2
bool InputEx3
bool InputEx4
bool InputAxisUp
bool InputAxisDown
bool InputAxisLeft
bool InputAxisRight

*** Press Functions ***
 * The following Press* boolean values return true if the player activated
 * the corresponding button, analog stick, or key this frame. Writing to this
 * variable simulates the press or release of that referenced button, analog stick,
 * or keys input press state.

bool PressStart
bool PressMap
bool PressUp
bool PressDown
bool PressLeft
bool PressRight
bool PressA
bool PressB
bool PressL
bool PressR
bool PressEx1
bool PressEx2
bool PressEx3
bool PressEx4
bool PressAxisUp
bool PressAxisDown
bool PressAxisLeft
bool PressAxisRight

int InputMouseX
 * The mouse's in-game X position. This value is undefined if
 * the mouse pointer is outside the Zelda Classic window.

int InputMouseY
 * The mouse's in-game Y position. This value is undefined if
 * the mouse pointer is outside the Zelda Classic window.

int InputMouseB
 * Whether the left or right mouse buttons are pressed, as two flags OR'd (|) together;
 * use the MB_ constants or the Input'X'Click functions in std.zh to check the button states.
 * InputMouseB is read only; while setting it is not syntactically incorrect, it does nothing
 * If you are not comfortable with binary, you can use the InputMouse'x' functions in std.zh

int InputMouseZ
 * The current state of the mouse's scroll wheel, negative for scrolling down and positive for scrolling up.

bool Item[]
 * True if Link's inventory contains the item whose ID is the index of
 * the array access. Use the I_ constants in std.zh as an index into this array.

int Equipment
 * Contains the item IDs of what is currently equiped to Link's A and B buttons.
 * The first 8 bits contain the A button item, and the second 8 bits contain the B button item.
 * Currently it is only possible to retrieve this value and not to set it.
 * If you are not comfortable with performing binary operations,
 * you can use the GetLinkEquipment'X' functions from std.zh.

int TileWidth
 * The number of tile columns composing the sprite.
 * Writing to this is ignored unless Extend is set to values >=3.

int TileHeight
 * The number of tile rows composing the sprite.
 * Writing to this is ignored unless Extend is set to values >=3.

int HitWidth
 * The width of Link's hitbox, or collision rectangle.
 * Writing to this is ignored unless Extend is set to values >=3.

int HitHeight
 * The height of Link's hitbox, or collision rectangle.
 * Writing to this is ignored unless Extend is set to values >=3.

int HitZHeight
 * The Z-axis height of Link's hitbox, or collision rectangle.
 * The lower it is, the lower a flying or jumping enemy must fly in order to hit Link.
 * Writing to this is ignored unless Extend is set to values >=3.

int HitXOffset
 * The X offset of Link's hitbox, or collision rectangle.
 * Setting it to positive or negative values will move Link's hitbox left or right.
 * Writing to this is ignored unless Extend is set to values >=3.

int HitYOffset
 * The Y offset of Link's hitbox, or collision rectangle.
 * Setting it to positive or negative values will move Link's hitbox up or down.
 * Writing to this is ignored unless Extend is set to values >=3.

int DrawXOffset
 * The X offset of Link's sprite.
 * Setting it to positive or negative values will move the sprite's tiles left or right relative to its position.
 * Writing to this is ignored unless Extend is set to values >=3.

int DrawYOffset
 * The Y offset of Link's sprite.
 * Setting it to positive or negative values will move the sprite's tiles up or down relative to its position.
 * Writing to this is ignored unless Extend is set to values >=3.

int DrawZOffset
 * The Z offset of Link's sprite.
 * Writing to this is ignored unless Extend is set to values >=3.

float Misc[]
 * An array of 16 miscellaneous variables for you to use as you please.
 * These variables are not saved with Link.

void Warp(int DMap, int screen)
 * Warps link to the given screen in the given DMap, just like if he'd
 * triggered an 'Insta-Warp'-type warp.

void PitWarp(int DMap, int screen)
 * This is identical to Warp, but Link's X and Y positions are preserved
 * when he enters the destination screen, rather than being set to the
 * Warp Return square.

======================================
--- Screen Functions and Variables ---
======================================

float D[]
 * Each screen has 8 general purpose registers for use by script
 * programmers. These values are recorded in the save file when the
 * player saves their game. Do with these as you will.
 * Note that these registers are tied to screen/DMap combinations.
 * Encountering the same screen in a different DMap will result in a
 * different D[] array.

int Flags[]
 * An array of ten integers containing the states of the flags in the
 * 10 categories on the Screen Data tabs 1 and 2. Each flag is ORed into the
 * Flags[x] value, starting with the top flag as the smallest bit.
 * Use the SF_ constants as the array acces for this value, and the
 * GetScreenFlags function if you are not comfortable with binary.
 * This is read-only; while setting it is not syntactically incorrect, it does nothing.

int EFlags[]
 * An array of 3 integers containing the states of the flags in the
 * E.Flags tab of the Screen Data dialog. Each flag is ORed into the
 * EFlags[x] value, starting with the top flag as the smallest bit.
 * Use the SEF_ constants as the array acces for this value, and the
 * GetScreenEFlags function if you are not comfortable with binary.
 * This is read-only; while setting it is not syntactically incorrect, it does nothing.

int ComboD[]
 * The combo ID of the ith combo on the screen, where i is the index
 * used to access this array. Combos are counted left to right, top to
 * bottom.

int ComboC[]
 * The CSet of the tile used by the ith combo on the screen, where i is
 * the index used to access this array. Combos are counted left to right,
 * top to bottom.

int ComboF[]
 * The placed flag of the ith combo on the screen, where i is the index
 * used to access this array. Combos are counted left to right, top to
 * bottom. Use the CF_ constants in std.zh to set or compare these values.

int ComboI[]
 * The inherent flag of the ith combo on the screen, where i is the index
 * used to access this array. Combos are counted left to right, top to
 * bottom. Use the CF_ constants in std.zh to set or compare these values.

int ComboT[]
 * The combo type of the ith combo on the screen, where i is the index
 * used to access this array. Combos are counted left to right, top to
 * bottom. Use the CT_ constants in std.zh to set or compare these values.

int ComboS[]
 * The walkability mask of the ith combo on the screen, where i is the
 * index used to access this array. Combos are counted left to right, top
 * to bottom. The least signficant bit is true if the top-left of the combo
 * is solid, the second-least signficant bit is true if the bottom-left
 * of the combo is is solid, the third-least significant bit is true if the
 * top-right of the combo is solid, and the fourth-least significant bit is
 * true if the bottom-right of the combo is solid.

bool State[]
 * An array of miscellaneous status data associated with the current
 * screen.
 * Screen states involve such things as permanent screen secrets, the
 * status of lock blocks and treasure chest combos, and whether items have
 * been collected.
 * These values are recorded in the save file when the player saves their
 * game. Use the ST_ constants in std.zh as indices into this array.

int Door[]
 * The door type for each of the four doors on a screen. Doors are counted
 * using the first four DIR_ constants in std.zh. Use the D_ constants in
 * std.zh to compare these values.

int RoomType
 * The type of room this screen is (Special Item, Bomb Upgrade, etc)
 * This is currently read-only.
 * Use the RT_* constants in std.zh
 
int RoomData
 * This is the data associated with the room type above. What it means depends
   on the room type. For Special Item, it will be the item ID, for a Shop, it
   will be the Shop Number, etc.
 * Basically, this is what's in the "Catch-all" menu item underneath Room Type.
 * If the room type has no data (eg, Ganon's room), this will be undefined.

void TriggerSecrets()
 * Triggers screen secrets temporarily. Set Screen->State[ST_SECRET]
 * to true beforehand or afterward if you would like them to remain
 * permanent.

bool Lit
 * Whether or not the screen is lit. Setting this variable will change the
 * lighting setting of the screen until you change screens.

int Wavy
 * The time, in frames, that the 'wave' screen effect will be in effect.
 * This value is decremented once per frame. As the value of Wavy approaches 0,
 * the intensity of the waves decreases.

int Quake
 * The time, in frames, that the screen will shake. This value is decremented
 * once per frame. As the value of Quake approaches 0, the intensity of the
 * screen shaking decreases.

void SetSideWarp(int warp, int screen, int dmap, int type)
 * Sets the current screen's side warp 'warp' to the destination screen, dmap and type.
 * If any of the parameters screen, dmap or type are equal to -1, they will remain unchanged.
 * If warp is not between 0 and 3 the function does nothing.

void SetTileWarp(int warp, int screen, int dmap, int type)
 * Sets the current screen's tile warp 'warp' to the destination screen, dmap and type.
 * If any of the parameters screen, dmap or type are equal to -1, they will remain unchanged.
 * If warp is not between 0 and 3 the function does nothing.

int LayerMap(int n)
 * Returns the map of the screen currently being used as the nth layer.
 * Values of n less than 1 or greater than 6, or layers that are not set up, return -1.

int LayerScreen(int n)
 * Returns the number of the screen currently being used as the nth layer.
 * Values of n less than 1 or greater than 6, or layers that are not set up, return -1.

int NumItems()
 * Returns the number of items currently present on the screen. Screen
 * items, shop items, and items dropped by enemies are counted; Link's
 * weapons, such as lit bombs, or enemy weapons are not counted.
 * Note that this value is only correct up until the next call to
 * Waitframe().

item LoadItem(int num)
 * Returns a pointer to the numth item on the current screen. The return
 * value is undefined unless 1 <= num <= NumItems().

item CreateItem(int id)
 * Creates an item of the given type at (0,0). Use the I_ constants in
 * std.zh to pass into this method. The return value is a pointer to the
 * new item.

ffc LoadFFC(int num)
 * Returns a pointer to the numth FFC on the current screen. The return
 * value is undefined unless 1 <= num <= ffcs, where ffcs is the number
 * of FFCs active on the screen.

int NumNPCs()
 * Returns the number of NPCs (enemies and guys) on the screen.
 * Note that this value is only correct up until the next call to
 * Waitframe().

npc LoadNPC(int num)
 * Returns a pointer to the numth NPC on the current screen. The return
 * value is undefined unless 1 <= num <= NumNPCs().

npc CreateNPC(int id)
 * Creates an npc of the given type at (0,0). Use the NPC_ constants in
 * std.zh to pass into this method. The return value is a pointer to the
 * new NPC.

int NumLWeapons()
 * Returns the number of Link weapon projectiles currently present on the screen.
 * This includes things like Link's arrows, bombs, magic, etc. Note that this
 * value is only correct up until the next call of Waitframe()

lweapon LoadLWeapon(int num)
 * Returns a pointer to the numth lweapon on the current screen. The return
 * value is undefined unless 1 <= num <= NumLWeapons().

lweapon CreateLWeapon(int type)
 * Creates an lweapon of the given type at (0,0). Use the LW_ constants in
 * std.zh to pass into this method. The return value is a pointer to the
 * new lweapon.

int NumEWeapons()
 * Returns the number of Enemy weapon projectiles currently present on the screen.
 * This includes things like Enemy arrows, bombs, magic, etc. Note that this
 * value is only correct up until the next call of Waitframe()

eweapon LoadEWeapon(int num)
 * Returns a pointer to the numth eweapon on the current screen. The return
 * value is undefined unless 1 <= num <= NumEWeapons().

eweapon CreateEWeapon(int type)
 * Creates an eweapon of the given type at (0,0). Use the EW_ constants in
 * std.zh to pass into this method. The return value is a pointer to the
 * new lweapon.

bool isSolid(int x, int y)
 * Returns true if the screen position (x, y) is solid - that is, if it
 * is within the solid portion of a combo on layers 0, 1 or 2. If either
 * x or y exceed the screen's bounds, then it will return false.
 * It will also return false if the only applicable solid combo is a solid
 * water combo that has recently been 'dried' by the whistle.

void ClearSprites(int spritelist)
 * Clears all of a certain kind of sprite from the screen. Use the SL_
 * constants in std.zh to pass into this method.

*Please note:
For all draw primitives, if the quest rule 'Subscreen Appears Above Sprites' is set,
passing the layer argument as 7 will allow drawing on top of the subscreen

void Rectangle(int layer, int x, int y, int x2, int y2, int color,
               float scale, int rx, int ry, int rangle, bool fill,
		   int opacity)
 * Draws a rectangle on the specified layer of the current screen, using
 * (x,y) as the top-left corner and (x2,y2) as the bottom-right corner.
 * Then scales the rectangle uniformly about its center by the given
 * factor.
 * Lastly, a rotation, centered about the point (rx, ry), is performed
 * counterclockwise using an angle of rangle degrees.
 * A filled rectangle is drawn if fill is true; otherwise, this method
 * draws a wireframe.
 * The rectangle is drawn using the specified index into the entire
 * 256-element palette: for instance, passing in a color of 17 would
 * use color 1 of cset 1.
 * Opacity controls how transparent the rectangle will be. Values other
 * than 128 (solid) and 64 (translucent) are currently undefined.

void Circle(int layer, int x, int y, int radius, int color,
               float scale, int rx, int ry, int rangle, bool fill,
		   int opacity)
 * Draws a circle on the specified layer of the current screen with
 * center (x,y) and radius scale*radius.
 * Then performs a rotation counterclockwise, centered about the point
 * (rx, ry), using an angle of rangle degrees.
 * A filled circle is drawn if fill is true; otherwise, this method
 * draws a wireframe.
 * The circle is drawn using the specified index into the entire
 * 256-element palette: for instance, passing in a color of 17 would
 * use color 1 of cset 1.
 * Opacity controls how transparent the circle will be. Values other
 * than 128 (solid) and 64 (translucent) are currently undefined.

void Arc(int layer, int x, int y, int radius, int startangle,
		   int endangle, int color, float scale, int rx, int ry,
		   int rangle, bool closed, bool fill, int opacity)
 * Draws an arc of a circle on the specified layer of the current
 * screen. The circle in question has center (x,y) and radius
 * scale*radius.
 * The arc beings at startangle degrees counterclockwise from standard
 * position, and ends at endangle degress counterclockwise from standard
 * position. The behavior of this function is undefined unless
 * 0 <= endangle-startangle < 360.
 * The arc is then rotated about the point (rx, ry) using an angle of
 * rangle radians.
 * If closed is true, a line is drawn from the center of the circle to
 * each endpoint of the arc, forming a sector of the circle. If fill
 * is also true, a filled sector is drawn instead.
 * The arc or sector is drawn using the specified index into the entire
 * 256-element palette: for instance, passing in a color of 17 would
 * use color 1 of cset 1.
 * Opacity controls how transparent the arc will be. Values other
 * than 128 (solid) and 64 (translucent) are currently undefined.

void Ellipse(int layer, int x, int y, int xradius, int yradius,
		   int color, float scale, int rx, int ry, int rangle,
		   bool fill, int opacity)
 * Draws an ellipse on the specified layer of the current screen with
 * center (x,y), x-axis radius xradius, and y-axis radius yradius.
 * Then performs a rotation counterclockwise, centered about the point
 * (rx, ry), using an angle of rangle degrees.
 * A filled ellipse is drawn if fill is true; otherwise, this method
 * draws a wireframe.
 * The ellipse is drawn using the specified index into the entire
 * 256-element palette: for instance, passing in a color of 17 would
 * use color 1 of cset 1.
 * Opacity controls how transparent the ellipse will be. Values other
 * than 128 (solid) and 64 (translucent) are currently undefined.

void Spline(int layer, int x1, int y1, int x2, int y2, int x3, int y3,
			int x4, int y4, int color, int opacity)
 * Draws a cardinal spline on the specified layer of the current screen
 * between (x1,y1) and (x4,y4)
 * The spline is drawn using the specified index into the entire
 * 256-element palette: for instance, passing in a color of 17 would
 * use color 1 of cset 1.
 * Opacity controls how transparent the ellipse will be. Values other
 * than 128 (solid) and 64 (translucent) are currently undefined.

void Line(int layer, int x, int y, int x2, int y2, int color, float scale,
			   int rx, int ry, int rangle, int opacity)
 * Draws a line on the specified layer of the current screen between
 * (x,y) and (x2,y2).
 * Then scales the line uniformly by a factor of scale about the line's
 * midpoint.
 * Finally, performs a rotation counterclockwise, centered about the
 * point (rx, ry), using an angle of rangle degrees.
 * The line is drawn using the specified index into the entire
 * 256-element palette: for instance, passing in a color of 17 would
 * use color 1 of cset 1.
 * Opacity controls how transparent the line will be. Values other
 * than 128 (solid) and 64 (translucent) are currently undefined.

void PutPixel(int layer, int x, int y, int color, int rx, int ry,
			   int rangle, int opacity)
 * Draws a raw pixel on the specified layer of the current screen
 * at (x,y).
 * Then performs a rotation counterclockwise, centered about the point
 * (rx, ry), using an angle of rangle degrees.
 * The point is drawn using the specified index into the entire
 * 256-element palette: for instance, passing in a color of 17 would
 * use color 1 of cset 1.
 * Opacity controls how transparent the point will be. Values other
 * than 128 (solid) and 64 (translucent) are currently undefined.

void DrawTile(int layer, int x, int y, int tile, int blockw, int blockh,
			   int cset, int xscale, int yscale, int rx, int ry, int rangle,
			   int flip, bool transparency, int opacity)
 * Draws a block of tiles on the specified layer of the current screen,
 * starting at (x,y), using the specified cset.
 * Starting with the specified tile, this method copies a block of size
 * blockh x blockw from the tile sheet to the screen. This method's
 * behavior is undefined unless 1 <= blockh, blockw <= 20.
 * Scale specifies the actual size in pixels! So scale 1 would mean it is
 * only one pixel in size. To use the default sizes of block w,h you must
 * set xscale and yscale to -1. These values are not independant of one another,
 * so you cannot set xscale and leave yscale at -1.
 * rx, ry : these work now, just like the other primitives.
 * rangle performs a rotation clockwise using an angle of rangle degrees.
 * Flip specifies how the tiles should be flipped when drawn:
 * 0: No flip
 * 1: Horizontal flip
 * 2: Vertical flip
 * 3: Both (180 degree rotation)
 * If transparency is true, the tiles' transparent regions will be
 * respected.
 * Opacity controls how transparent the solid portions of the tiles will
 * be. Values other than 128 (solid) and 64 (translucent) are currently
 * undefined.

void FastTile( int layer, int x, int y, int tile, int cset, int opacity )
 * Optimized and simpler version of DrawTile()
 * Draws a single tile on the current screen much in the same way as DrawTile().
 * See DrawTile() for an explanation on what these arguments do.

void DrawCombo(int layer, int x, int y, int combo, int w, int h,
			   int cset, int xscale, int yscale, int rx, int ry, int rangle,
			   int frame, int flip, bool transparency, int opacity)
 * Draws a combo on the specified layer of the current screen,
 * starting at (x,y), using the specified cset.
 * Starting with the specified tile referenced by the combo,
 * this method copies a block of size
 * blockh x blockw from the tile sheet to the screen. This method's
 * behavior is undefined unless 1 <= blockh, blockw <= 20.
 * Scale specifies the actual size in pixels! So scale 1 would mean it is
 * only one pixel in size. To use the default sizes of block w,h you must
 * set xscale and yscale to -1. These values are not independant of one another,
 * so you cannot set xscale and leave yscale at -1.
 * rx, ry : works now :
 * rangle performs a rotation clockwise using an angle of rangle degrees.
 * Flip specifies how the tiles should be flipped when drawn:
 * 0: No flip
 * 1: Horizontal flip
 * 2: Vertical flip
 * 3: Both (180 degree rotation)
 * If transparency is true, the tiles' transparent regions will be
 * respected.
 * Opacity controls how transparent the solid portions of the tiles will
 * be. Values other than 128 (solid) and 64 (translucent) are currently
 * undefined.

void FastCombo( int layer, int x, int y, int combo, int cset, int opacity )
 * Optimized and simpler version of DrawCombo()
 * Draws a single combo on the current screen much in the same way as DrawCombo().
 * See DrawCombo() for an explanation on what these arguments do.

void Message(int string)
 * Prints the message string with given ID onto the screen.
 * If string is 0, the currently displayed message is removed.
 * This method's behavior is undefined if string is less than 0
 * or greater than the total number of messages in the quest.

void DrawCharacter(	int layer, int x, int y, int font,
			int color, int background_color,
			int width, int height, int glyph, int opacity )
 * Draws a single ASCII character 'glyph' on the specified layer of the current screen,
 * using the specified font index (see std.zh for FONT_* list to pass to this method),
 * starting at (x,y), using the specified color as the foreground color
 * and background_color as the background color. * NOTE * Use -1 for a transparent background.
 * The arguments width and height may be used to draw the glyph
 * of any arbitrary size begining at 1 pixel up to 512 pixels large. (more than four times the size of the screen)
 * Passing 0 or negative values to this will use the default fonts w and h.
 * Opacity controls how transparent the is.
 * Values other than 128 (solid) and 64 (translucent) are currently undefined.

 void DrawInteger(	int layer, int x, int y, int font,
			int color, int background_color,
			int width, int height, int number, int number_decimal_places, int opacity)
 * Draws a zscript 'int' or 'float' on the specified layer of the current screen,
 * using the specified font index (see std.zh for FONT_* list to pass to this method),
 * starting at (x,y), using the specified color as the foreground color
 * and background_color as the background color. * NOTE * Use -1 for a transparent background.
 * The arguments width and height may be used to draw the number
 * of any arbitrary size begining at 1 pixel up to 512 pixels large.
 * Passing 0 or negative values to this will use the default fonts w and h.
 * The number can be rendered as type 'int' or 'float' by setting the argument
 * "number_decimal_places", which is only valid if set to 0 or <= 4.
 * Opacity controls how transparent the is.
 * Values other than 128 (solid) and 64 (translucent) are currently undefined.

void DrawString( int layer, int x, int y, int font,
			int color, int background_color,
			int format, int[] ptr, int opacity )
 * Prints a NULL terminated string up to 256 characters from an int array
 * containing ASCII data (*ptr) on the specified layer of the current screen,
 * using the specified font index (see std.zh for FONT_* list to pass to this method),
 * using the specified color as the foreground color
 * and background_color as the background color. * NOTE * Use -1 for a transparent background.
 * The array pointer should be passed as the argument for '*ptr', ie.
 * int string[] = "Example String"; Screen->DrawString(l,x,y,f,c,b_c,fo,o,string);
 * int format tells the engine how to format the string. (see std.zh for TF_* list to pass to this method)
 * Opacity controls how transparent the message is.
 * Values other than 128 (solid) and 64 (translucent) are currently undefined.


// (Psuedo) 3D drawing

void Quad( int layer, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4,
		int w, int h, int cset, int flip, int texture, int render_mode
		)
 * Draws a quad on the specified layer with the corners x1,y1 through x4,y4.
 * Corners are drawn in a counterclockwise order starting from x1,y1. ( So
 * if you draw a "square" for example starting from the bottom-right corner
 * instead of the usual top-left, the the image will be textured onto the
 * quad so it appears upside-down. -yes, these are rotatable. )
 * From there a single or block of tiles or combos is then texture mapped
 * onto the quad using the arguments w, h, cset, flip, and render_mode.
 * A positive vale in texture will draw the image from the tilesheet pages,
 * whereas a negative value will be drawn from the combo page. 0 will draw combo number 0.
 * Both w and h are undefined unless 1 <= blockh, blockw <= 16, and it is a power of
 * two. ie: 1, 2 are acceptable, but 2, 15 are not.
 * Flip specifies how the tiles/combos should be flipped when drawn:
 * 0: No flip
 * 1: Horizontal flip
 * 2: Vertical flip
 * 3: Both (180 degree rotation)
 *** See std.zh for a list of all available render_mode arguments.

void Triangle( int layer, int x1, int y1, int x2, int y2, int x3, int y3,
		int w, int h, int cset, int flip, int texture, int render_mode
		)
 * Draws a triangle on the specified layer with the corners x1,y1 through x4,y4.
 * Corners are drawn in a counterclockwise order starting from x1,y1.
 * From there a single or block of tiles or combos is then texture mapped
 * onto the triangle using the arguments w, h, cset, flip, and render_mode.
 * A positive vale in texture will draw the image from the tilesheet pages,
 * whereas a negative value will be drawn from the combo page. 0 will draw combo number 0.
 * Both w and h are undefined unless 1 <= blockh, blockw <= 16, and it is a power of
 * two. ie: 1, 2 are acceptable, but 2, 15 are not.
 * Flip specifies how the tiles/combos should be flipped when drawn:
 * 0: No flip
 * 1: Horizontal flip
 * 2: Vertical flip
 * 3: Both (180 degree rotation)
 *** See std.zh for a list of all available render_mode arguments.

// Bitmap Drawing


void SetRenderTarget( int bitmap_id )
 * Sets the target bitmap for all succesive drawing commands.
 * These can be directly to the screen or any one of the available off-screen bitmaps,
 * which are generally categorized as -1(screen) or 0-bitmapNumber(off-screen).
 *** See std.zh for a complete list of valid render targets (RT_*).

void Bitmap( int layer, int bitmap_id, int source_x, int source_y, int source_w, int source_h, 
               int dest_x, int dest_y, int dest_w, int dest_h, bool mask
		)
 * Draws a source rect from off-screen Bitmap with id of bitmap_id onto
 * an area of the screen described by dest rect at the given layer.
 * *Example:
 *   Screen->Bitmap( 6, myBitmapId, 0, 0, 16, 16, 79, 57, 32, 32, true );
 *   //Would draw a 16x16 area starting at the upper-left corner of source bitmap to
 *   //layer 6 of the current screen at coordinates 79,57 with a width and height of 32.

 ***Note* Script drawing functions are enqueued and executed in a frame-by-frame basis 
          based on the order of which layer they need to be drawn to. Drawing to or from
          seperate render tagets or bitmaps is no exception! So keep in mind in order to 
          eliminate unwanted drawing orders or bugs.

====================================
--- Item Functions and Variables ---
====================================

bool isValid()
 * Returns whether this item pointer is still valid. An item pointer
 * becomes invalid when Link picks up the item, the item fades away,
 * or Link leaves the screen. Accessing any variables using an
 * invalid item pointer prints an error message to allegro.log and
 * does nothing.

int X
 * The item's X position on the screen, in pixels.  Float values passed to this will be cast to int.

int Y
 * The item's Y position on the screen, in pixels.  Float values passed to this will be cast to int.

int Jump
 * The item's upward velocity, in pixels. If negative, the item will fall.
 * The downward acceleration of Gravity (in Init Data) modifies this value every frame.

int DrawStyle
 * An integer representing how the item is to be drawn. Use one of the
 * DS_ constants in std.zh to set or compare this value.

int ID
 * This item's ID number. Use the I_ constants to compare this value. The effect of writing to this field is currently undefined.

int OriginalTile
 * The starting tile of the item's animation.

int Tile
 * The current tile associated with this item.

int CSet
 * This item's CSet.

int FlashCSet
 * The CSet used during this item's flash frames, if this item flashes.

int NumFrames
 * The number of frames in this item's animation.

int Frame
 * The tile that is this item's current animation frame.

int ASpeed
 * The speed at which this item animates, in screen frames.

int Delay
 * The amount of time the animation is suspended after the last frame,
 * before the animation restarts, in item frames. That is, the total
 * number of screen frames of extra wait is Delay*ASpeed.

bool Flash
 * Whether or not the item flashes. A flashing item alternates between
 * its CSet and its FlashCSet.

int Flip
 * Whether and how the item's tiles should be flipped.
 * 0: No flip
 * 1: Horizontal flip
 * 2: Vertical flip
 * 3: Both (180 degree rotation)

int Pickup
 * The pickup flags of the item, which determine what happens when Link
 * picks up the item. Its value consists of flags OR'd (|) together; use
 * the IP_ constants in std.zh to set or compare these values.
 * A special note about IP_ENEMYCARRIED: if the Quest Rule "Hide Enemy-
 * Carried Items" is set, then an item carried by an enemy will have its
 * X and Y values set to -128 while the enemy is carrying it. If this
 * flag is removed from such an item, then it will be moved to the enemy's
 * on-screen location.
 * If you are not comfortable with performing binary operations, use the ItemPickup functions from std.zh.

int Extend
 * Whether to extend the sprite of the item.

int TileWidth
 * The number of tile columns composing the sprite.
 * Writing to this is ignored unless Extend is set to values >=3.

int TileHeight
 * The number of tile rows composing the sprite.
 * Writing to this is ignored unless Extend is set to values >=3.

int HitWidth
 * The width of the sprite's hitbox, or collision rectangle.

int HitHeight
 * The height of the sprite's hitbox, or collision rectangle.

int HitZHeight
 * The Z-axis height of the sprite's hitbox, or collision rectangle.
 * The greater it is, the higher Link must jump or fly over the sprite to avoid picking up the item.

int HitXOffset
 * The X offset of the sprite's hitbox, or collision rectangle.
 * Setting it to positive or negative values will move the sprite's hitbox left or right.

int HitYOffset
 * The Y offset of the sprite's hitbox, or collision rectangle.
 * Setting it to positive or negative values will move the sprite's hitbox up or down.

int DrawXOffset
 * The X offset of the sprite.
 * Setting it to positive or negative values will move the sprite's tiles left or right relative to its position.

int DrawYOffset
 * The Y offset of the sprite.
 * Setting it to positive or negative values will move the sprite's tiles up or down relative to its position.

int DrawZOffset
 * The Z offset of the sprite.

float Misc[]
 * An array of 16 miscellaneous variables for you to use as you please.

======================================
--- Weapon Functions and Variables ---
======================================

 * Note that lweapons and eweapons possess exactly the same attributes,
 * although their designation affects how they are treated by the engine.
 * The values here correspond to both the lweapon and eweapon type.

bool isValid()
 * Returns whether this weapon pointer is still valid. A weapon pointer
 * becomes invalid when the weapon fades away or disappears
 * or Link leaves the screen. Accessing any variables using an
 * invalid weapon pointer prints an error message to allegro.log and
 * does nothing.

void UseSprite(int id)
 * Reads a 'Weapons/Misc' sprite entry in your quest file, and assigns
 * the OriginalTile, Tile, OriginalCSet, CSet, FlashCSet, NumFrames,
 * Frame, ASpeed, Flip and Flash variables of this weapon based on
 * this entry's data. Passing negative values, and values greater than
 * 255, will do nothing.

bool Behind
 * Ensures that the weapon's graphic is drawn behind Link and enemies.

int ID
 * The weapon's ID number. Use the LW_ or EW_ constants to compare
 * this value. The effect of writing to this field is currently undefined.

int X
 * The weapon's X position on the screen, in pixels.  Float values passed
 * to this will be cast to int.

int Y
 * The weapon's Y position on the screen, in pixels.  Float values passed
 * to this will be cast to int.

int Z
 * The weapon's Z position on the screen, in pixels.  Float values passed
 * to this will be cast to int.

int Jump
 * The weapon's falling speed on the screen. Bombs, Bait and
 * Fire obey gravity.

int DrawStyle
 * An integer representing how the weapon is to be drawn. Use one of the
 * DS_ constants in std.zh to set or compare this value.

int Dir
 * The direction that the weapon is facing. Used by certain weapon types
 * to determine movement, shield deflection and such.

int OriginalTile
 * The starting tile of the weapon's animation.

int Tile
 * The current tile associated with this weapon.

int OriginalCSet
 * The starting CSet of the weapon's animation.

int CSet
 * This weapon's current CSet.

int FlashCSet
 * The CSet used during this weapon's flash frames, if this weapon flashes.

int NumFrames
 * The number of frames in this weapon's animation.

int Frame
 * The weapon's current animation frame.

int ASpeed
 * The speed at which this weapon animates, in screen frames.

int Damage
 * The amount of damage that this weapon causes to Link/an enemy upon contact.

int Step
 * Usually associated with the weapon's velocity. A Step of 100
 * typically means that the weapon moves at approximately one pixel
 * per animation frame.

int Angle
 * The weapon's current angle in clockwise radians; used by certain weapon
 * types with angular movement. 0 = right, PI/2 = down, etc. Note: if you
 * want Link's shield to interact with the weapon correctly, you must set
 * its Dir to a direction that approximates this angle.

bool Angular
 * Specifies whether a weapon has angular movement.

bool CollDetection
 * Whether the weapon will use the system's code to work out collisions with
 * Link and/or enemies (depending on weapon type). Initialised as 'true'.

int DeadState
 * The current state of the weapon. Important to keep track of. A value of
 * -1 indicates that it is active, and moves according to the weapon's
 * Dir, Step, Angular, and Angle values. Use -1 if you want the engine to
 * handle movement and collision. Use any value below -1 if you want a
 * dummy weapon that you can control on your own.
 * Given a deadstate value of -10, a weapon will turn of its collision
 * detection and movement. If it has a positive value, it will
 * decrement once per frame until it equals 0, whereupon the weapon is
 * removed. If you want to remove the weapon, write one of the WDS_
 * constants in std.zh (appropriate for the weapon) to this variable.

bool Flash
 * Whether or not the weapon flashes. A flashing weapon alternates between
 * its CSet and its FlashCSet.

int Flip
 * Whether and how the weapon's tiles should be flipped.
 * 0: No flip
 * 1: Horizontal flip
 * 2: Vertical flip
 * 3: Both (180 degree rotation)

int Extend
 * Whether to extend the sprite of the weapon.

int TileWidth
 * The number of tile columns composing the sprite.
 * Writing to this is ignored unless Extend is set to values >=3.

int TileHeight
 * The number of tile rows composing the sprite.
 * Writing to this is ignored unless Extend is set to values >=3.

int HitWidth
 * The width of the sprite's hitbox, or collision rectangle.

int HitHeight
 * The height of the sprite's hitbox, or collision rectangle.

int HitZHeight
 * The Z-axis height of the sprite's hitbox, or collision rectangle.
 * The greater it is, the higher Link must jump or fly over the sprite
 * to avoid taking damage.

int HitXOffset
 * The X offset of the sprite's hitbox, or collision rectangle.
 * Setting it to positive or negative values will move the sprite's
 * hitbox left or right.

int HitYOffset
 * The Y offset of the sprite's hitbox, or collision rectangle.
 * Setting it to positive or negative values will move the sprite's
 * hitbox up or down.

int DrawXOffset
 * The X offset of the sprite.
 * Setting it to positive or negative values will move the sprite's
 * tiles left or right relative to its position.

int DrawYOffset
 * The Y offset of the sprite.
 * Setting it to positive or negative values will move the sprite's
 * tiles up or down relative to its position.

int DrawZOffset
 * The Z offset of the sprite.

float Misc[]
 * An array of 16 miscellaneous variables for you to use as you please.


=========================================
--- Itemdata Functions and Variables ---
=========================================

void GetName(int buffer[])
 * Loads the item this itemdata is attributed to's name into 'buffer'

int Family
 * The kind of item to which this class belongs (swords, boomerangs,
 * potions, etc.) Use the IC_ constants in std.zh to set or compare this
 * value.

int Level
 * The level of this item. Higher-level items replace lower-level items
 * when they are picked up.

int Power
 * The item's power, for most items this is amount of damage dealt but is
 * used for other values in some items (ie. Roc's Feather)

int Amount
 * Corresponds to the "Increase Amount" entry in the Item Editor.
 * The value of this data member can have two meanings:
 * If Amount & 0x8000 is 1, the drain counter for this item is set
 * to Amount & 0x3FFF. The game then slowly fills the counter of this item
 * (see Counter below) out of the drain counter. Gaining rupees uses the
 * drain counter, for example.
 * is set to Amount when the item is picked up.
 * If Amount & 0x8000 is 0, the counter of this item is increased, if
 * Amount & 0x4000 is 1, or decreased, if Amount & 0x4000 is 0, by
 * Amount & 0x3FFF when the item is picked up.

int Max
 * Corresponds to the "Full Max" entry in the Item Editor.
 * In conjunction with MaxIncrement (see below) this value controls how
 * the maximum value of the counter of this item (see Counter below) is
 * modified when the item is picked up. If MaxIncrement is nonzero at that
 * time, the counter's new maximum value is at that time set to the
 * minimum of its current value plus MaxIncrement, Max.
 * If Max is less than the current maximum of the counter, Max is ignored
 * and that maximum is used instead.
 * Notice that as a special case, if Max = MaxIncrement, the counter's
 * maximum value will be forced equal to Max.

int MaxIncrement
 * Corresponds to the "+Max" entry in the Item Editor.
 * In conjunction with Max (see above) this value controls how the
 * maximum value of the counter of this item (see Counter below) is
 * modified when the item is picked up. If MaxIncrement is nonzero at that
 * time, the counter's new maximum value is at that time set to the
 * minimum of its current value plus MaxIncrement, and Max.
 * If Max is less than the current maximum of the counter, Max is ignored
 * and that maximum is used instead.

bool Keep
 * Corresponds to the "Equipment Item" checkbox in the Item Editor.
 * If true, Link will keep the item, and it will show up as an item or
 * equipment in the subscreen. If false, it may modify the current value
 * or maximum value of its counter (see Counter below), then disappear.
 * The White Sword and Raft, for instance, have Keep true, and keys and
 * rupees have Keep false.

int Counter
 * Corresponds to the "Counter Reference" entry in the Item Editor.
 * The game counter whose current and modified values might be modified
 * when the item is picked up (see Amount, Max, and MaxIncrement above.)
 * Use the CT_  constants in std.zh to set or compare this value.

int UseSound
 * Corresponds to the "Sound" entry on the action tab in the Item Editor.

float InitD[]
 * The original values of the item's 8 D input values are they are stored in the
 * .qst file, regardles of whether they have been modified by ZScript.

====================================
--- Game Functions and Variables ---
====================================

int GetCurScreen()
 * Retrieves the number of the current screen within the current map.

int GetCurDMapScreen()
 * Retrieves the number of the current screen within the current DMap.

int GetCurLevel()
 * Retrieves the number of the dungeon level of the current DMap. Multiple
 * DMaps can have the same dungeon level - this signifies that they share
 * a map, compass, level keys and such.

int GetCurMap()
 * Retrieves the number of the current map.

int GetCurDMap()
 * Returns the number of the current DMap.

int DMapFlags[]
 * An array of 512 integers, containing the DMap's flags ORed (|) together.
 * Use the 'DMF_' constants, or the 'DMapFlag()' functions from std.zh if you are not comfortable with binary.

int DMapLevel[]
 * An array of 512 integers containing each DMap's level

int DMapCompass[]
 * An array of 512 integers containing each DMap's compass screen

int DMapContinue[]
 * An array of 512 integers containing each DMap's continue screen

int DMapMIDI[]
 * An array of 512 integers containing each DMap's MIDI.
 * Positive numbers are for custom MIDIs, and negative values are used for the built-in game MIDIs.
 * Because of the way DMap MIDIs are handled internally, however, built-in MIDIs besides the
 * overworld, dungeon, and level 9 songs won't match up with Game->PlayMIDI() and Game->GetMIDI().

void GetDMapName(int DMap, int buffer[])
 * Loads DMap with ID 'DMap's name into 'buffer'.
 * See std.zh for appropriate buffer size.

void GetDMapTitle(int DMap, int buffer[])
 * Loads DMap with ID 'DMap's title into 'buffer'.
 * See std.zh for appropriate buffer size.

void GetDMapIntro(int DMap, int buffer[])
 * Loads DMap with ID 'DMap's intro string into 'buffer'.
 * See std.zh for appropriate buffer size.

int NumDeaths
 * The number of times Link has perished during this quest.

int Cheat
 * The current cheat level of the quest player.

int Time
 * Returns the time elapsed in this quest, in 60ths of a second. The
 * return value is undefined if TimeValid is false (see below).

bool HasPlayed
 * This value is true if the current quest session was loaded from a saved
 * game, false if the quest was started fresh.

bool TimeValid
 * True if the elapsed quest time can be determined for the current quest.

int GuyCount[]
 * The number of NPCs (enemies and guys) on screen i of this map, where
 * i is the index used to access this array. This array is exclusively used
 * to determine which enemies had previously been killed, and thus won't
 * return, when you re-enter a screen.

int ContinueDMap
 * The DMap where Link will be respawned after dying and continuing.

int ContinueScreen
 * The map screen where Link will be respawned after dying and continuing.

int Counter[]
 * The current value of the game counters. Use the CR_ constants in
 * std.zh to index into this array.

int MCounter[]
 * The current maximum value of the game counters. Use the CR_ constants
 * in std.zh to index into this array.

int DCounter[]
 * The current value of the game drain counters. Use the CR_ constants
 * in std.zh to index into this array.
 * Note that if the player hasn't acquired the '1/2 Magic Upgrade' yet,
 * then setting the CR_MAGIC drain counter to a negative value will
 * drain the magic counter by 2 per frame rather than 1.

int Generic[]
 * An array of miscellaneous game values, such as number of heart
 * containers and magic drain rate. Use the GEN_ constants in std.zh
 * to index into this array.

int LItems[]
 * The exploration items (map, compass, boss key etc.) of dungeon level i
 * currently under the possession of the player, where i is
 * the index used to access this array. Each element of this
 * array consists of flags OR'd (|) together; use the LI_ constants in
 * std.zh to set or compare these values.

int LKeys[]
 * The number of level keys of level i currently under the possession of
 * the player, where i is the index used to access this array.

int GetScreenFlags(int map, int screen, int flagset)
 * Returns the screen flags from screen 'screen' on map 'map',
 * interpreted in the same way as Screen->Flags

int GetScreenEFlags(int map, int screen, int flagset)
 * Returns the enemy flags from screen 'screen' on map 'map',
 * interpreted in the same way as Screen->EFlags

bool GetScreenState(int map, int screen, int flag)
 * As with State, but retrieves the miscellaneous flags of any screen,
 * not just the current one. This function is undefined if map is less
 * than 1 or greater than the maximum map number of your quest, or if
 * screen is greater than 135.
 * Note: Screen numbers in ZQuest are usually displayed in hexadecimal.
 * Use the ST_ constants in std.zh for the flag parameter.

void SetScreenState(int map, int screen, int flag, bool value)
 * As with State, but sets the miscellaneous flags of any screen, not
 * just the current one. This function is undefined if map is less than
 * 1 or greater than the maximum map number of your quest, or if
 * screen is greater than 135.
 * Note: Screen numbers in ZQuest are usually displayed in hexadecimal.
 * Use the ST_ constants in std.zh for the flag parameter.

float GetScreenD(int screen, int reg)
 * Retrieves the value of D[reg] on the given screen of the current
 * DMap.

void SetScreenD(int screen, int reg, float value)
 * Sets the value of D[reg] on the given screen of the current DMap.

float GetDMapScreenD(int dmap, int screen, int reg)
 * Retrieves the value of D[reg] on the given screen of the given
 * DMap.

void SetDMapScreenD(int dmap, int screen, int reg, float value)
 * Sets the value of D[reg] on the given screen of the given DMap.

itemdata LoadItemData(int item)
 * Retrieves the itemdata pointer corresponding to the given item.
 * Use the item pointer ID variable or I_ constants in std.zh as values.

void PlaySound(int soundid)
 * Plays one of the quest's sound effects. Use the SFX_ constants in
 * std.zh as values of soundid.

void PlayMIDI(int MIDIid)
 * Changes the current screen MIDI to MIDIid.
 * Will revert to the DMap (or screen) MIDI upon leaving the screen.

int GetMIDI()
 * Returns the current screen MIDI that is playing.
 * Positive numbers are for custom MIDIs, and negative values are used for the built-in game MIDIs.

int GetComboData(int map, int screen, int position)
 * Grabs a particular combo reference from anywhere in the game
 * world, based on map (NOT DMap), screen number, and position.
 * Don't forget that the screen index should be in hexadecimal,
 * and that maps are counted from 1 upwards.
 * Position is considered an index, treated the same way as in
 * Screen->ComboD[].

void SetComboData(int map, int screen, int position, int value)
 * Sets a particular combo reference anywhere in the game world,
 * based on map (NOT DMap), screen number, and position.
 * Don't forget that the screen index should be in hexadecimal,
 * and that maps are counted from 1 upwards.
 * Position is considered an index, treated the same way as in
 * Screen->ComboD[].

int GetComboCSet(int map, int screen, int position)
 * Grabs a particular combo's CSet from anywhere in the game
 * world, based on map (NOT DMap), screen number, and position.
 * Position is considered an index, treated the same way as in
 * Screen->ComboC[].

void SetComboCSet(int map, int screen, int position, int value)
 * Sets a particular combo's CSet anywhere in the game world,
 * based on map (NOT DMap), screen number, and position. Position
 * is considered an index, treated the same way as in Screen->ComboC[].

int GetComboFlag(int map, int screen, int position)
 * Grabs a particular combo's placed flag from anywhere in the game
 * world, based on map (NOT DMap), screen number, and position.
 * Position is considered an index, treated the same way as in
 * Screen->ComboF[].

void SetComboFlag(int map, int screen, int position, int value)
 * Sets a particular combo's placed flag anywhere in the game world,
 * based on map (NOT DMap), screen number, and position. Position
 * is considered an index, treated the same way as in Screen->ComboF[].

int GetComboType(int map, int screen, int position)
 * Grabs a particular combo's type from anywhere in the game
 * world, based on map (NOT DMap), screen number, and position.
 * Position is considered an index, treated the same way as in
 * Screen->ComboT[]. Note that you are grabbing an actual combo
 * attribute as referenced by the combo on screen you're
 * referring to.

void SetComboType(int map, int screen, int position, int value)
 * Sets a particular combo's type anywhere in the game world,
 * based on map (NOT DMap), screen number, and position. Position
 * is considered an index, treated the same way as in Screen->ComboT[].
 * Note that you are grabbing an actual combo attribute as referenced
 * by the combo on screen you're referring to, which means that
 * setting this attribute will affect ALL references to this combo
 * throughout the quest.

int GetComboInherentFlag(int map, int screen, int position)
 * Grabs a particular combo's inherent flag from anywhere in the game
 * world, based on map (NOT DMap), screen number, and position.
 * Position is considered an index, treated the same way as in
 * Screen->ComboI[]. Note that you are grabbing an actual combo
 * attribute as referenced by the combo on screen you're
 * referring to.

void SetComboInherentFlag(int map, int screen, int position, int value)
 * Sets a particular combo's inherent flag anywhere in the game world,
 * based on map (NOT DMap), screen number, and position. Position
 * is considered an index, treated the same way as in Screen->ComboI[].
 * Note that you are grabbing an actual combo attribute as referenced
 * by the combo on screen you're referring to, which means that
 * setting this attribute will affect ALL references to this combo
 * throughout the quest.

int GetComboSolid(int map, int screen, int position)
 * Grabs a particular combo's solidity flag from anywhere in the game
 * world, based on map (NOT DMap), screen number, and position.
 * Position is considered an index, treated the same way as in
 * Screen->ComboS[]. Note that you are grabbing an actual combo
 * attribute as referenced by the combo on screen you're
 * referring to.

void SetComboSolid(int map, int screen, int position, int value)
 * Sets a particular combo's solidity anywhere in the game world,
 * based on map (NOT DMap), screen number, and position. Position
 * is considered an index, treated the same way as in Screen->ComboS[].
 * Note that you are grabbing an actual combo attribute as referenced
 * by the combo on screen you're referring to, which means that
 * setting this attribute will affect ALL references to this combo
 * throughout the quest.

int ComboTile(int combo)
 * Returns the tile used by combo 'combo'

void GetSaveName(int buffer[])
 * Loads the current save file's name into 'buffer'
 * Buffer should be at least 9 elements long

void SetSaveName(int name[])
 * Sets the current file's save name to 'name'
 * Buffer should be no more than 9 elements

void End()
 * Ends the current game and returns to the file select screen

void Save()
 * Saves the current game

void GetMessage(int string, int buffer[])
 * Loads 'string' into 'buffer'. Use the function from std.zh
 * to remove trailing ' ' characters whilst loading.

===================================
--- NPC Functions and Variables ---
===================================

bool isValid()
 * Returns whether or not this NPC pointer is still valid. A pointer
 * becomes invalid if the enemy dies or Link leaves the screen.
 * Trying to access any variable of an invalid NPC pointer prints
 * an error to allegro.log and does nothing.

void GetName(int buffer[])
 * Loads the npc's name into 'buffer'. To load an NPC from an ID rather than a pointer,
 * use 'GetNPCName' from std.zh

int ID
 * The NPC's enemy ID number.
 * npc->ID is read-only; while setting it is not syntactically incorrect, it does nothing.

int Type
 * The NPC's Type. Use the NPCT_ constants in std.zh to compare this value.
 * npc->Type is read-only; while setting it is not syntactically incorrect, it does nothing.

int X
 * The NPC's current X coordinate, in pixels.  Float values passed to this will be cast to int.

int Y
 * The NPC's current Y coordinate, in pixels.  Float values passed to this will be cast to int.

int Z
 * The NPC's current Z coordinate, in pixels.  Float values passed to this will be cast to int.

int Jump
 * The NPC's upward velocity, in pixels. If negative, the NPC will fall.
 * The downward acceleration of Gravity (in Init Data) modifies this value every frame.

int Dir
 * The direction the NPC is facing. Use the DIR_ constants in std.zh to
 * set and compare this value.

int Rate
 * The rate at which the NPC changes direction. For a point of reference,
 * the "Octorok (Magic)" enemy has a rate of 16. The effect of writing to
 * this field is currently undefined.

int Haltrate
 * The extent to which the NPC stands still while moving around the
 * screen. As a point of reference, the Zols and Gels have haltrate of
 * 16. The effect of writing to this field is currently undefined.

int Homing
 * How likely the NPC is to move towards Link.
 * THe effect of writing to this field is currently undefined.

int Step
 * The NPC's movement speed. A Step of 100 usually means that
 * the enemy moves at approximately one pixel per animation frame.
 * As a point of reference, the "Octorok (Magic)" enemy has
 * a step of 200. The effect of writing to this field is
 * currently undefined.

bool CollDetection
 * Whether the NPC will use the system's code to work out collisions with Link
 * Initialised as 'true'.

int ASpeed
 * The the NPC's animation frame rate, in screen frames. The effect of
 * writing to this field is currently undefined.

int DrawStyle
 * The way the NPC is animated. Use the DS_ constants in std.zh to set or
 * compare this value. The effect of writing to this field is currently undefined.

int HP
 * The NPC's current hitpoints. A weapon with a Power of 1 removes 2
 * hitpoints.

int Damage
 * The amount of damage dealt to an unprotected Link when he touches this NPC, in
 * quarter-hearts.

int WeaponDamage
 * The amount of damage dealt to an unprotected Link by this NPC's weapon, in
 * quarter-hearts.

int Stun
 * The time, in frames, that the NPC will be stunned. Some types of enemies cannot be stunned.

int OriginalTile
 * The number of the starting tile used by this NPC.

int Tile
 * The current tile associated with this NPC. The effect of writing to this variable is undefined.

int Weapon
 * The weapon used by this enemy. Use the WPN_ constants (NOT the EW_ constants)
 * in std.zh to set or compare this value.

int ItemSet
 * The items that the NPC might drop when killed. Use the IS_ constants
 * in std.zh to set or compare this value.

int CSet
 * The CSet used by this NPC.

int BossPal
 * The boss pallete used by this NPC; this pallete is only used if CSet
 * is 14 (the reserved boss cset). Use the BPAL_ constants in std.zh to
 * set or compare this value.

int SFX
 * The sound effects emitted by the enemy. Use the SFX_ constants in
 * std.zh to set or compare this value.

int Extend
 * Whether to extend the sprite of the enemy.

int TileWidth
 * The number of tile columns composing the sprite.
 * Writing to this is ignored unless Extend is set to values >=3.

int TileHeight
 * The number of tile rows composing the sprite.
 * Writing to this is ignored unless Extend is set to values >=3.

int HitWidth
 * The width of the sprite's hitbox, or collision rectangle.

int HitHeight
 * The height of the sprite's hitbox, or collision rectangle.

int HitZHeight
 * The Z-axis height of the sprite's hitbox, or collision rectangle.
 * The greater it is, the higher Link must jump or fly over the sprite to avoid taking damage.

int HitXOffset
 * The X offset of the sprite's hitbox, or collision rectangle.
 * Setting it to positive or negative values will move the sprite's hitbox left or right.

int HitYOffset
 * The Y offset of the sprite's hitbox, or collision rectangle.
 * Setting it to positive or negative values will move the sprite's hitbox up or down.

int DrawXOffset
 * The X offset of the sprite.
 * Setting it to positive or negative values will move the sprite's tiles left or right relative to its position.

int DrawYOffset
 * The Y offset of the sprite. In non-sideview screens, this is usually -2.
 * Setting it to positive or negative values will move the sprite's tiles up or down relative to its position.

int DrawZOffset
 * The Z offset of the sprite. This is ignored unless Extend is set to values >=3.

int Defense[]
 * The npc's Defense values, as an array of 18 integers. Use the NPCD_ and NPCDT_ constants
 * in std.zh to set or compare these values.

int Attributes[]
 * The npc's Miscellaneous Attributes, as an array of ten integers.
 * They are read-only; while setting them is not syntactically incorrect, it does nothing.

int MiscFlags
 * The npc's Misc. Flags as 14 bits ORed together, starting with 'Damaged by Power 0 Weapons',
 * and working down the flags in the order they are shown in the Enemy Editor.
 * npc->MiscFlags is read-only; while setting it is not syntactically incorrect, it does nothing.
 * If you are not comfortable with binary operations, you can use 'GetNPCMiscFlag' from std.zh

float Misc[]
 * An array of 16 miscellaneous variables for you to use as you please.

