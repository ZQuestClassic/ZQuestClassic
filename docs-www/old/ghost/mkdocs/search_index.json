{
    "docs": [
        {
            "location": "/index.html",
            "text": "ghost.zh\n\n\nghost.zh is used to create \"ghosted enemy\" FFC scripts. These combine an FFC\nand a built-in enemy to create what seems to be a scripted enemy. The enemy\nhandles collision detection, defense. The FFC runs the script and,typically,\nis what is actually visible on the screen.\n\n\nMost of this documentation is meant for users who want to write scripts.\nIf you just want to use existing enemy scripts, see \nthis page\n.",
            "title": "About"
        },
        {
            "location": "/index.html#ghostzh",
            "text": "ghost.zh is used to create \"ghosted enemy\" FFC scripts. These combine an FFC\nand a built-in enemy to create what seems to be a scripted enemy. The enemy\nhandles collision detection, defense. The FFC runs the script and,typically,\nis what is actually visible on the screen.  Most of this documentation is meant for users who want to write scripts.\nIf you just want to use existing enemy scripts, see  this page .",
            "title": "ghost.zh"
        },
        {
            "location": "/autoGhost/index.html",
            "text": "AutoGhost setup\n\n\nFirst of all, extract ghost.zh and the ghost_zh folder from the zip file.\n\n\n\n\nWindows or Linux: These should go in the same folder as ZC itself.\n\n\nMac: Right-click the ZQuest application and select \nShow Package Contents\n.\n    The files should go in \nContents/Resources\n. To be sure you're in\n    the right place, look for \nstd.zh\n and \nstring.zh\n.\n\n\n\n\nIf you want to use ghost.zh in multiple quests with different settings, you can\nmake copies of the file with a different filename or in a different folder.\nYou only need to copy the file ghost.zh itself.\n\n\nGeneral setup\n\n\nThis part only needs done once per quest.\n\n\nBlank tiles and combo\n\n\nFirst, you'll need to set aside a 4x4 block of tiles to leave blank.\n\n\n\n\nSet up a combo that uses the top-left tile of that block and has its type\nand flag both set to \n(None)\n. Remember the tile and combo numbers for later.\n\n\nYou should also modify the \nMISC: Spawn\n sprite in\n\nQuest > Graphics > Sprites > Weapons/Misc.\n It needs to have the animation\nspeed and number of frames set; 3 frames at a speed of 5 will best match the\nbuilt-in enemies.\n\n\n\n\nConstants\n\n\nYou'll have to set some constants in ghost.zh. Open it in a text editor. Use\na basic one, like Notepad; more advanced word processors sometimes modify\npunctuation marks, which can make scripts unusable.\n\n\nThe constants look similar to this:\n\n\nconst int CONSTANT_NAME = ###; // And sometimes there's a note here\n\n\n\n\nThe ### part is what you need to change. Be careful to leave the semicolon in place. \n\n\nThese are the standard settings:\n\n\n\n\nGH_SHADOW_TILE\n\n\nGH_SHADOW_CSET\n\n\nGH_SHADOW_FRAMES\n\n\nGH_SHADOW_ANIM_SPEED\n\n\nGH_SHADOW_TRANSLUCENT\n\n\nGH_SHADOW_FLICKER\n\n\nIf a shadow needs to be drawn by the script, it will use these settings.\nIf you want shadows to have multiple frames, they must be consecutive tiles,\nand \nGH_SHADOW_TILE\n should be the number of the first one. For the\ntranslucency and flickering settings, set the number to 1 (yes) or 0 (no).\n\n\nGH_LARGE_SHADOW_TILE\n\n\nGH_LARGE_SHADOW_CSET\n\n\nGH_LARGE_SHADOW_FRAMES\n\n\nGH_LARGE_SHADOW_ANIM_SPEED\n\n\nLarge enemies may have 2x2 tile shadows using these settings. This only\napplies when built-in shadows are not used. This is the case only if\n\nGH_PREFER_GHOST_ZH_SHADOWS\n or \nGH_FAKE_Z\n are used or if a specific enemy\nuses fake Z movement. If \nGH_LARGE_SHADOW_TILE\n is 0, large shadows will never\nbe used.\n\n\nGH_LARGE_SHADOW_MIN_WIDTH\n\n\nGH_LARGE_SHADOW_MIN_HEIGHT\n\n\nAn enemy must be at least this large in tiles to have a large shadow.\nThese are tile sizes; set them between 1 and 4.\n\n\nGH_PREFER_GHOST_ZH_SHADOWS\n\n\nghost.zh's shadows will be used instead of built-in ones whenever possible.\nSet the number to 1 (yes) or 0 (no).\n\n\nAUTOGHOST_MIN_FFC\n\n\nAUTOGHOST_MAX_FFC\n\n\n\n\nEvery scripted enemy uses at least one FFC. Set these to limit the range of\nFFCs they will use automatically. Use these if you want to reserve some FFCs\nfor other purposes. Both must be between 1 and 32.\n\n\n\n\nAttention\n\n\nIf all FFCs in this range are in use when an enemy appears, the script\nwon't be able to run, so you shouldn't limit the range more than necessary.\n\n\n\n\n\n\nAUTOGHOST_MIN_ENEMY_ID\n\n\nAUTOGHOST_MAX_ENEMY_ID\n\n\nThese allow you to limit the range of enemy IDs that can be set up\nautomatically by AutoGhost. Any enemy whose ID is below the minimum or\nabove the maximum will be ignored. This is useful when other scripts use\nmisc. attributes 11 and 12 for other purposes.\n\n\nGH_DRAW_OVER_THRESHOLD\n\n\nSome scripts set the FFC's \nDraw Over\n flag automatically as the enemy moves\nup and down. This determines the Z value at which it changes. This is similar\nto the setting \nJumping Sprite Layer Threshold\n in the quest's initialization data.\n\n\nGH_GRAVITY\n\n\nGH_TERMINAL_VELOCITY\n\n\nThese should match the numbers set for gravity and terminal velocity in\nthe initialization data.\n\n\nGH_SPAWN_SPRITE\n\n\nThis is the number of the sprite used by spawningenemies, found in\n\nQuest > Graphics > Sprites > Weapons/Misc.\n Scripted enemies don't use\nthe normal spawn animations. This sprite is used to fake it. If you use\nthe default sprite, 22, make sure its animation frames and speed are set.\n\n\nGH_FAKE_Z\n\n\nIf enabled, enemies won't move through the Z axis. Similar to unchecking the\nquest rule \nEnemies Jump/Fly Through Z-Axis\n. Set this to 1 (yes) or 0 (no).\n\n\n__GH_FAKE_EWEAPON_Z\n\n\nThe same, but for weapons. Set this to 1 (yes) or 0 (no).\n\n\nGH_ENEMIES_FLICKER\n\n\nIf enabled, enemies will flicker instead of flashing. Similar to checking\nthe quest rule \nEnemies Flicker When Hit\n. Set this to 1 (yes) or 0 (no).\n\n\nGH_BLANK_TILE\n\n\nSet this to the tile number of the top-left of your 4x4 block of blank tiles.\n\n\nGH_INVISIBLE_COMBO\n\n\nSet this to the number of the combo that uses the blank tile.\n\n\n__GH_ALWAYS_USE_NAME\n\n\nIf this is set to 0, the enemy's script and combo will be taken from misc.\nattributes 11 and 12. If it's set to 1, they'll be read from the name,\nfreeing up those attributes for other scripts to use. See the section\non setting up the script and combo below for more details.\n\n\n\n\nIf you're making multiple quests at once that use different settings, you\nshould use a different copy of ghost.zh for each one. You only need to copy\nghost.zh itself, not the ghost_zh folder.\n\n\nLoading the scripts\n\n\nIn \nZQuest, go to Quest > Scripts > Compile ZScript... > Edit\n. These three lines\nneed to appear once each. Enter any line that isn't already there.\n\n\nimport \"std.zh\"\nimport \"string.zh\"\nimport \"ghost.zh\"\n\n\n\n\nThis assumes that all these files are in the default location. If you put ghost.zh\nin a different folder, you'll have to specify that, for instance:\n\n\nimport \"MyQuest\\Scripts\\ghost.zh\"\n\n\n\n\nClose the window, save the changes, and click \nCompile\n. In the \nGlobal\n tab,\nload \nGhostZHActiveScript\n into the Active script slot. If you want to use clocks,\nin the \nItem\n tab, load \nGhostZHClockScript\n into any slot.\n\n\nIf your quest uses clocks, set the clock's pickup script to \nGhostZHClockScript\n\nand set D0 to the same number as the clock's duration.\n\n\nIndividual enemies\n\n\nImporting the script\n\n\nFirst, the script needs to be imported. In the script buffer, add another line\nto import the file. For instance:\n\n\nimport \"GoriyaLttP.z\"\n\n\n\n\nSome scripts might require that you import additional files, but don't include\nany file more than once. Compile and load the FFC script into a slot.\n\n\nExactly what needs done varies from one enemy to the next, but a few things are\ncommon. Many scripted enemies need at least one combo set up, but some use the\ninvisible one. Every enemy needs its type (usually \nOther\n), HP, damage, tile,\nand CSet set. The enemy must also have a script and combo set. There are a few\ndifferent ways of doing this, described below.\n\n\n\n\nMany enemies require more than one combo. In these cases, assume that all combos\nmust be consecutive in the list and the enemy's combo set to the first one\nunless the instructions say otherwise. Also, some scripts require that multiple\nenemies be set up. Unless instructed otherwise, you only need to place the\nprimary enemy on the screen.\n\n\nSome enemies use the invisible combo (\nGH_INVISIBLE_COMBO\n). In these cases, you\ncan set the combo to -1. A few enemies also specify -2, another special value.\n\n\nSetting the script and combo\n\n\nIf \n__GH_ALWAYS_USE_NAME\n is 0:\n\n\n\n\nMisc. attributes 11 and 12 are used to identify the enemy as scripted and set\nup an FFC to run the script. Attribute 11 indicates which combo the enemy\nshould use, and attribute 12 determines what script it runs. If either of these\nis 0, the enemy will not be recognized as scripted and will not function.\nIf attribute 12 is set to -1, the script name will be read from the enemy's\nname as described below.\n\n\nIf \n__GH_ALWAYS_USE_NAME\n is 1:\n\n\n\n\nMisc. attributes 11 and 12 are not used. The script and combo will be always be\nread from the enemy's name. The combo can be omitted, in which case it will\ndefault to \nGH_INVISIBLE_COMBO\n.\n\n\nWhen reading a script from the enemy's name, whether because misc. attribute 12\nis -1 or \n__GH_ALWAYS_USE_NAME\n is enabled, the script name must go in the\nenemy's name immediately following the character @. The script name must appear\nexactly as shown after it is compiled, including capitalization.\n\n\nFor example, using the Armos_LttP script, these names will work:\n\n\n\n\nArmos (LttP)   @Armos_LttP\n\n\nArmos (L1, @Armos_LttP)\n\n\n\n\nThese names will not work:\n\n\n\n\nArmos  @armos_lttp\n\n\nIncorrect capitalization\n\n\n\n\n\n\nArmos @ Armos_LttP\n\n\nSpace after @\n\n\n\n\n\n\n\n\nWhen using \n__GH_ALWAYS_USE_NAME\n, the combo number is read in the same way.\nThe order does not matter. Spaces or other characters between the two\nare not required, but they're allowed as long as they wouldn't be mistaken\nfor part of the name or number.\n\n\nUsing the Goriya_LttP script with combo 5888, these names will work:\n\n\n\n\nGoriya (LttP)  (@Goriya_LttP, @5888)\n\n\nGoriya (LttP)   @5888@Goriya_LttP\n\n\n\n\nThese will not work:\n\n\n\n\nGoriya (LttP)   @Goriya_LttP_@5888\n\n\n_ looks like part of the script name\n\n\n\n\n\n\nGoriya (LttP)   @ 5888 @ Goriya_LttP\n\n\nSpace after @ is not allowed",
            "title": "AutoGhost setup"
        },
        {
            "location": "/autoGhost/index.html#autoghost-setup",
            "text": "First of all, extract ghost.zh and the ghost_zh folder from the zip file.   Windows or Linux: These should go in the same folder as ZC itself.  Mac: Right-click the ZQuest application and select  Show Package Contents .\n    The files should go in  Contents/Resources . To be sure you're in\n    the right place, look for  std.zh  and  string.zh .   If you want to use ghost.zh in multiple quests with different settings, you can\nmake copies of the file with a different filename or in a different folder.\nYou only need to copy the file ghost.zh itself.",
            "title": "AutoGhost setup"
        },
        {
            "location": "/autoGhost/index.html#general-setup",
            "text": "This part only needs done once per quest.",
            "title": "General setup"
        },
        {
            "location": "/autoGhost/index.html#blank-tiles-and-combo",
            "text": "First, you'll need to set aside a 4x4 block of tiles to leave blank.   Set up a combo that uses the top-left tile of that block and has its type\nand flag both set to  (None) . Remember the tile and combo numbers for later.  You should also modify the  MISC: Spawn  sprite in Quest > Graphics > Sprites > Weapons/Misc.  It needs to have the animation\nspeed and number of frames set; 3 frames at a speed of 5 will best match the\nbuilt-in enemies.",
            "title": "Blank tiles and combo"
        },
        {
            "location": "/autoGhost/index.html#constants",
            "text": "You'll have to set some constants in ghost.zh. Open it in a text editor. Use\na basic one, like Notepad; more advanced word processors sometimes modify\npunctuation marks, which can make scripts unusable.  The constants look similar to this:  const int CONSTANT_NAME = ###; // And sometimes there's a note here  The ### part is what you need to change. Be careful to leave the semicolon in place.   These are the standard settings:   GH_SHADOW_TILE  GH_SHADOW_CSET  GH_SHADOW_FRAMES  GH_SHADOW_ANIM_SPEED  GH_SHADOW_TRANSLUCENT  GH_SHADOW_FLICKER  If a shadow needs to be drawn by the script, it will use these settings.\nIf you want shadows to have multiple frames, they must be consecutive tiles,\nand  GH_SHADOW_TILE  should be the number of the first one. For the\ntranslucency and flickering settings, set the number to 1 (yes) or 0 (no).  GH_LARGE_SHADOW_TILE  GH_LARGE_SHADOW_CSET  GH_LARGE_SHADOW_FRAMES  GH_LARGE_SHADOW_ANIM_SPEED  Large enemies may have 2x2 tile shadows using these settings. This only\napplies when built-in shadows are not used. This is the case only if GH_PREFER_GHOST_ZH_SHADOWS  or  GH_FAKE_Z  are used or if a specific enemy\nuses fake Z movement. If  GH_LARGE_SHADOW_TILE  is 0, large shadows will never\nbe used.  GH_LARGE_SHADOW_MIN_WIDTH  GH_LARGE_SHADOW_MIN_HEIGHT  An enemy must be at least this large in tiles to have a large shadow.\nThese are tile sizes; set them between 1 and 4.  GH_PREFER_GHOST_ZH_SHADOWS  ghost.zh's shadows will be used instead of built-in ones whenever possible.\nSet the number to 1 (yes) or 0 (no).  AUTOGHOST_MIN_FFC  AUTOGHOST_MAX_FFC   Every scripted enemy uses at least one FFC. Set these to limit the range of\nFFCs they will use automatically. Use these if you want to reserve some FFCs\nfor other purposes. Both must be between 1 and 32.   Attention  If all FFCs in this range are in use when an enemy appears, the script\nwon't be able to run, so you shouldn't limit the range more than necessary.    AUTOGHOST_MIN_ENEMY_ID  AUTOGHOST_MAX_ENEMY_ID  These allow you to limit the range of enemy IDs that can be set up\nautomatically by AutoGhost. Any enemy whose ID is below the minimum or\nabove the maximum will be ignored. This is useful when other scripts use\nmisc. attributes 11 and 12 for other purposes.  GH_DRAW_OVER_THRESHOLD  Some scripts set the FFC's  Draw Over  flag automatically as the enemy moves\nup and down. This determines the Z value at which it changes. This is similar\nto the setting  Jumping Sprite Layer Threshold  in the quest's initialization data.  GH_GRAVITY  GH_TERMINAL_VELOCITY  These should match the numbers set for gravity and terminal velocity in\nthe initialization data.  GH_SPAWN_SPRITE  This is the number of the sprite used by spawningenemies, found in Quest > Graphics > Sprites > Weapons/Misc.  Scripted enemies don't use\nthe normal spawn animations. This sprite is used to fake it. If you use\nthe default sprite, 22, make sure its animation frames and speed are set.  GH_FAKE_Z  If enabled, enemies won't move through the Z axis. Similar to unchecking the\nquest rule  Enemies Jump/Fly Through Z-Axis . Set this to 1 (yes) or 0 (no).  __GH_FAKE_EWEAPON_Z  The same, but for weapons. Set this to 1 (yes) or 0 (no).  GH_ENEMIES_FLICKER  If enabled, enemies will flicker instead of flashing. Similar to checking\nthe quest rule  Enemies Flicker When Hit . Set this to 1 (yes) or 0 (no).  GH_BLANK_TILE  Set this to the tile number of the top-left of your 4x4 block of blank tiles.  GH_INVISIBLE_COMBO  Set this to the number of the combo that uses the blank tile.  __GH_ALWAYS_USE_NAME  If this is set to 0, the enemy's script and combo will be taken from misc.\nattributes 11 and 12. If it's set to 1, they'll be read from the name,\nfreeing up those attributes for other scripts to use. See the section\non setting up the script and combo below for more details.   __GH_CLEAR_FFC_LINK  If this is set to 1, the ffc->Link value will clear when ghost.zh cleans\nup the script. ZC 2.50.2 and earlier do not support this as it is not legal\nto write ffc->Link = 0, however 2.53.0 and later support clearing linked ffcs.\nSet this to 0 to disable clearing it.  __GH_ETHEREAL  If this is set to 1, then autoghost enemies will set their controlling ffc\nto use the Ethereal flag. This ensures that the ffc does not override the properties\nof the normal screen comno, or any other ffc underneath it. Set this to 0 if you\nare using legacy scripts that are incompatible with this option.  __GH_FIX_255_ANONE  If you are using 2.53.1 or 2.55.0, set this to `1` to ensure that the ->Tile attribute is \nupdated along with ->OriginalTile for enemies that use the Animation Style 'None'.  __GH_FIX_EWM_FALL  This is a bugfix setting that prevents inappropriate removal of falling weapons\non sideview screens.\nSet this to 0 if you are using legacy scripts that are incompatible with this option.  __GH_FIX_EWM_THROW  This is a bugfix setting that prevents inappropriate removal of thrown weapons\non sideview screens.\nSet this to 0 if you are using legacy scripts that are incompatible with this option.  __GH_WEAPONS_HIT_PLATFORMS  If this is set to 1, then weapons thrown or falling on sideview screens, that are\ncontrolled by ghost.zh, will die when they strike solid combos (e.g. sideview platforms).\nSet this to 0 if you are using legacy scripts that are incompatible with this option.\nThis relies on  __GH_FIX_EWM_FALL  and  __GH_FIX_EWM_THROW  .  If you're making multiple quests at once that use different settings, you\nshould use a different copy of ghost.zh for each one. You only need to copy\nghost.zh itself, not the ghost_zh folder.",
	    "title": "Constants"
        },
        {
            "location": "/autoGhost/index.html#loading-the-scripts",
            "text": "In  ZQuest, go to Quest > Scripts > Compile ZScript... > Edit . These three lines\nneed to appear once each. Enter any line that isn't already there.  import \"std.zh\"\nimport \"string.zh\"\nimport \"ghost.zh\"  This assumes that all these files are in the default location. If you put ghost.zh\nin a different folder, you'll have to specify that, for instance:  import \"MyQuest\\Scripts\\ghost.zh\"  Close the window, save the changes, and click  Compile . In the  Global  tab,\nload  GhostZHActiveScript  into the Active script slot. If you want to use clocks,\nin the  Item  tab, load  GhostZHClockScript  into any slot.  If your quest uses clocks, set the clock's pickup script to  GhostZHClockScript \nand set D0 to the same number as the clock's duration.",
            "title": "Loading the scripts"
        },
        {
            "location": "/autoGhost/index.html#individual-enemies",
            "text": "",
            "title": "Individual enemies"
        },
        {
            "location": "/autoGhost/index.html#importing-the-script",
            "text": "First, the script needs to be imported. In the script buffer, add another line\nto import the file. For instance:  import \"GoriyaLttP.z\"  Some scripts might require that you import additional files, but don't include\nany file more than once. Compile and load the FFC script into a slot.  Exactly what needs done varies from one enemy to the next, but a few things are\ncommon. Many scripted enemies need at least one combo set up, but some use the\ninvisible one. Every enemy needs its type (usually  Other ), HP, damage, tile,\nand CSet set. The enemy must also have a script and combo set. There are a few\ndifferent ways of doing this, described below.   Many enemies require more than one combo. In these cases, assume that all combos\nmust be consecutive in the list and the enemy's combo set to the first one\nunless the instructions say otherwise. Also, some scripts require that multiple\nenemies be set up. Unless instructed otherwise, you only need to place the\nprimary enemy on the screen.  Some enemies use the invisible combo ( GH_INVISIBLE_COMBO ). In these cases, you\ncan set the combo to -1. A few enemies also specify -2, another special value.",
            "title": "Importing the script"
        },
        {
            "location": "/autoGhost/index.html#setting-the-script-and-combo",
            "text": "If  __GH_ALWAYS_USE_NAME  is 0:   Misc. attributes 11 and 12 are used to identify the enemy as scripted and set\nup an FFC to run the script. Attribute 11 indicates which combo the enemy\nshould use, and attribute 12 determines what script it runs. If either of these\nis 0, the enemy will not be recognized as scripted and will not function.\nIf attribute 12 is set to -1, the script name will be read from the enemy's\nname as described below.  If  __GH_ALWAYS_USE_NAME  is 1:   Misc. attributes 11 and 12 are not used. The script and combo will be always be\nread from the enemy's name. The combo can be omitted, in which case it will\ndefault to  GH_INVISIBLE_COMBO .  When reading a script from the enemy's name, whether because misc. attribute 12\nis -1 or  __GH_ALWAYS_USE_NAME  is enabled, the script name must go in the\nenemy's name immediately following the character @. The script name must appear\nexactly as shown after it is compiled, including capitalization.  For example, using the Armos_LttP script, these names will work:   Armos (LttP)   @Armos_LttP  Armos (L1, @Armos_LttP)   These names will not work:   Armos  @armos_lttp  Incorrect capitalization    Armos @ Armos_LttP  Space after @     When using  __GH_ALWAYS_USE_NAME , the combo number is read in the same way.\nThe order does not matter. Spaces or other characters between the two\nare not required, but they're allowed as long as they wouldn't be mistaken\nfor part of the name or number.  Using the Goriya_LttP script with combo 5888, these names will work:   Goriya (LttP)  (@Goriya_LttP, @5888)  Goriya (LttP)   @5888@Goriya_LttP   These will not work:   Goriya (LttP)   @Goriya_LttP_@5888  _ looks like part of the script name    Goriya (LttP)   @ 5888 @ Goriya_LttP  Space after @ is not allowed",
            "title": "Setting the script and combo"
        },
        {
            "location": "/usage/index.html",
            "text": "General usage\n\n\nEnemy scripts\n\n\nA ghost.zh script should begin by calling one of the \nGhost_Init\n functions to\nfind the enemy the FFC should be associated with and set up internal data.\nAfterward, \nGhost_Waitframe()\n should be used instead of \nWaitframe()\n.\nThis is necessary to keep data consistent and to provide standard enemy behavior,\nsuch as reacting to damage. Most of the standard enemy data is manipulated by\nusing the global variables and functions \nhere\n, but some things\n- particularly defenses and draw offsets - must still be accessed via the npc pointer.\n\n\nThe enemy used can be of any type and with any settings. Its HP, damage, and\ndefenses will be used normally. Its regular tiles and animation will be used\nif the FFC is set to use \nGH_INVISIBLE_COMBO\n; otherwise, it will be made\ninvisible. Other enemy data can be used as you see fit.\n\n\nThere are also a number of functions used to create and control eweapons. They\ncan be assigned a number of simple movements and can be made to vanish and\nspawn additional eweapons. These behaviors require support from the global script.\n\n\nFor scripted enemies to be susceptible to clocks, \nStartClock()\n and \nUpdateClock()\n\nmust be called in the global script, and the included item script\n\nGhostZHClockScript\n must be set as any clock items' pickup script, with D0 set\nto match the clock's duration.\n\n\nTo prevent conflicts with ghost.zh, scripts should avoid using\n\nnpc->Misc[__GHI_NPC_DATA]\n and \neweapon->Misc[__EWI_FLAGS]\n. Both indices\nare set to 15 by default.\n\n\nFunctions, variables, and constants whose names start with \n__\n are for internal\nuse and may be changed or removed in future versions without warning.\n\n\nAutoGhost\n\n\nWith appropriately written scripts, it is possible to place scripted enemies\nwithout any manual FFC setup. The \nAutoGhost()\n function will scan the screen for\nenemies that should be handled by scripts and set up FFCs automatically when\nit finds them. \nAutoGhost()\n should come after \nWaitDraw()\n in the global script.\n\n\nAn AutoGhost FFC script's run function should take an enemy ID as argument D0,\nwhich should be passed to the \nGhost_InitAutoGhost\n function. \nAutoGhost()\n will not set\nany other arguments, but they can be used if your script runs additional\ninstances of the same script.\n\n\nThe corresponding enemy needs to be set up to identify the script and combo\nit will use, as described \nhere\n.",
            "title": "General usage"
        },
        {
            "location": "/usage/index.html#general-usage",
            "text": "",
            "title": "General usage"
        },
        {
            "location": "/usage/index.html#enemy-scripts",
            "text": "A ghost.zh script should begin by calling one of the  Ghost_Init  functions to\nfind the enemy the FFC should be associated with and set up internal data.\nAfterward,  Ghost_Waitframe()  should be used instead of  Waitframe() .\nThis is necessary to keep data consistent and to provide standard enemy behavior,\nsuch as reacting to damage. Most of the standard enemy data is manipulated by\nusing the global variables and functions  here , but some things\n- particularly defenses and draw offsets - must still be accessed via the npc pointer.  The enemy used can be of any type and with any settings. Its HP, damage, and\ndefenses will be used normally. Its regular tiles and animation will be used\nif the FFC is set to use  GH_INVISIBLE_COMBO ; otherwise, it will be made\ninvisible. Other enemy data can be used as you see fit.  There are also a number of functions used to create and control eweapons. They\ncan be assigned a number of simple movements and can be made to vanish and\nspawn additional eweapons. These behaviors require support from the global script.  For scripted enemies to be susceptible to clocks,  StartClock()  and  UpdateClock() \nmust be called in the global script, and the included item script GhostZHClockScript  must be set as any clock items' pickup script, with D0 set\nto match the clock's duration.  To prevent conflicts with ghost.zh, scripts should avoid using npc->Misc[__GHI_NPC_DATA]  and  eweapon->Misc[__EWI_FLAGS] . Both indices\nare set to 15 by default.  Functions, variables, and constants whose names start with  __  are for internal\nuse and may be changed or removed in future versions without warning.",
            "title": "Enemy scripts"
        },
        {
            "location": "/usage/index.html#autoghost",
            "text": "With appropriately written scripts, it is possible to place scripted enemies\nwithout any manual FFC setup. The  AutoGhost()  function will scan the screen for\nenemies that should be handled by scripts and set up FFCs automatically when\nit finds them.  AutoGhost()  should come after  WaitDraw()  in the global script.  An AutoGhost FFC script's run function should take an enemy ID as argument D0,\nwhich should be passed to the  Ghost_InitAutoGhost  function.  AutoGhost()  will not set\nany other arguments, but they can be used if your script runs additional\ninstances of the same script.  The corresponding enemy needs to be set up to identify the script and combo\nit will use, as described  here .",
            "title": "AutoGhost"
        },
        {
            "location": "/globalScript/index.html",
            "text": "Global script functions\n\n\nMany features of ghost.zh require global script support. If you don't want\nto use the provided \nGhostZHActiveScript\n, you just need to add a few functions\ninto whatever global script you do use.\n\n\nCombined\n\n\nThe simpler option is to use these three functions. These provide all\nfunctionality and will continue to work if more functions are ever added\nin the future.\n\n\n\n\nvoid StartGhostZH()\n\n\nCall this before the global script's main loop.\n\n\nvoid UpdateGhostZH1()\n\n\nCall this in the global script's main loop before \nWaitdraw()\n.\n\n\nvoid UpdateGhostZH2()\n\n\nCall this in the global script's main loop after \nWaitdraw()\n.\n\n\n\n\nSeparate\n\n\nThese are the functions used internally by those listed above. Calling these\nindividually lets you leave out functionality you don't need, but it's possible\na future ghost.zh update will require updating the script.\n\n\n\n\nvoid InitializeGhostZHData()\n\n\n\n\nInitializes internal counters and data.\n\n\nCall before the main loop of the global script.\n\n\n\n\nvoid UpdateGhostZHData1()\n\n\nvoid UpdateGhostZHData2()\n\n\n\n\nUpdates counters and internal data.\n\n\nCall \nUpdateGhostZHData1()\n in the main loop before \nWaitdraw()\n and\n\nUpdateGhostZHData2()\n after \nWaitdraw()\n.\n\n\n\n\nvoid UpdateEWeapon(eweapon wpn)\n\n\n\n\nThis must be called on eweapons each frame to enable the special behaviors\nprovided by ghost.zh.\n\n\nCall in the main loop before \nWaitdraw()\n.\n\n\n\n\nvoid UpdateEWeapons()\n\n\n\n\nRuns \nUpdateEWeapon()\n on all eweapons onscreen.\n\n\nCall in the main loop before \nWaitdraw()\n.\n\n\n\n\nvoid CleanUpGhostFFCs()\n\n\n\n\nHides enemy FFCs when Link dies. If \n__GH_USE_DRAWCOMBO\n is enabled, this function does nothing.\n\n\nCall in the main loop before \nWaitdraw()\n and after anything that would save\nLink from dying when \nLink->HP<=0\n.\n\n\n\n\nvoid DrawGhostFFCs()\n\n\n\n\nDraws enemy combos if \n__GH_USE_DRAWCOMBO\n is enabled and draws additional\ncombos regardless. If \n__GH_USE_DRAWCOMBO\n is disabled and no scripts use\n\nGhost_AddCombo()\n, this function does nothing.\n\n\nCall in the main loop after \nWaitdraw()\n.\n\n\n\n\nvoid AutoGhost()\n\n\n\n\nDetects AutoGhost enemies and sets up FFCs for them.\n\n\nCall in the main loop after \nWaitdraw()\n.",
            "title": "Global script"
        },
        {
            "location": "/globalScript/index.html#global-script-functions",
            "text": "Many features of ghost.zh require global script support. If you don't want\nto use the provided  GhostZHActiveScript , you just need to add a few functions\ninto whatever global script you do use.",
            "title": "Global script functions"
        },
        {
            "location": "/globalScript/index.html#combined",
            "text": "The simpler option is to use these three functions. These provide all\nfunctionality and will continue to work if more functions are ever added\nin the future.   void StartGhostZH()  Call this before the global script's main loop.  void UpdateGhostZH1()  Call this in the global script's main loop before  Waitdraw() .  void UpdateGhostZH2()  Call this in the global script's main loop after  Waitdraw() .",
            "title": "Combined"
        },
        {
            "location": "/globalScript/index.html#separate",
            "text": "These are the functions used internally by those listed above. Calling these\nindividually lets you leave out functionality you don't need, but it's possible\na future ghost.zh update will require updating the script.   void InitializeGhostZHData()   Initializes internal counters and data.  Call before the main loop of the global script.   void UpdateGhostZHData1()  void UpdateGhostZHData2()   Updates counters and internal data.  Call  UpdateGhostZHData1()  in the main loop before  Waitdraw()  and UpdateGhostZHData2()  after  Waitdraw() .   void UpdateEWeapon(eweapon wpn)   This must be called on eweapons each frame to enable the special behaviors\nprovided by ghost.zh.  Call in the main loop before  Waitdraw() .   void UpdateEWeapons()   Runs  UpdateEWeapon()  on all eweapons onscreen.  Call in the main loop before  Waitdraw() .   void CleanUpGhostFFCs()   Hides enemy FFCs when Link dies. If  __GH_USE_DRAWCOMBO  is enabled, this function does nothing.  Call in the main loop before  Waitdraw()  and after anything that would save\nLink from dying when  Link->HP<=0 .   void DrawGhostFFCs()   Draws enemy combos if  __GH_USE_DRAWCOMBO  is enabled and draws additional\ncombos regardless. If  __GH_USE_DRAWCOMBO  is disabled and no scripts use Ghost_AddCombo() , this function does nothing.  Call in the main loop after  Waitdraw() .   void AutoGhost()   Detects AutoGhost enemies and sets up FFCs for them.  Call in the main loop after  Waitdraw() .",
            "title": "Separate"
        },
        {
            "location": "/enemyScript/index.html",
            "text": "Enemy variables and functions\n\n\nGlobal variables\n\n\nMany aspects of the enemy are controlled by these global variables. They're set\nby a \nGhost_Init\n function and kept consistent between frames by the\n\nGhost_Waitframe\n functions.\n\n\n\n\nfloat Ghost_X\n\n\nfloat Ghost_Y\n\n\nfloat Ghost_Z\n\n\nThe X, Y and Z position of the enemy.\n\n\nfloat Ghost_Vx\n\n\nfloat Ghost_Vy\n\n\nfloat Ghost_Jump\n\n\n\n\nThe X, Y, and Z velocity of the enemy.\n\n\nGhost_Vx\n and \nGhost_Vy\n are handled by \nGhost_MoveXY()\n, so they will respect\nsolidity, water, pits, and screen edges.\n\n\n\n\nfloat Ghost_Ax\n\n\nfloat Ghost_Ay\n\n\nThe X and Y acceleration of the enemy.\n\n\nint Ghost_Dir\n\n\nThe direction the enemy is facing.\n\n\nint Ghost_Data\n\n\nint Ghost_CSet\n\n\n\n\nThe current combo and CSet of the enemy.\n\n\nIf \nGhost_InitAutoGhost()\n is used, \nGhost_CSet\n will be set to the enemy's CSet.\nAll other initializion functions will use the FFC's CSet.\n\n\nIf the \nGHF_4WAY\n or \nGHF_8WAY\n flags are used, \nGhost_Data\n should always be set to\nthe upward-facing combo.\n\n\n\n\nint Ghost_TileWidth\n\n\nint Ghost_TileHeight\n\n\n\n\nThe width and height of the enemy in tiles, which must be between 1 and 4.\n\n\n\n\nCaution\n\n\nIf these variables are set, the change will not fully take effect until\nthe next Waitframe. It's better to use \nGhost_SetSize()\n instead and\nconsider these variables read-only.\n\n\n\n\n\n\nint Ghost_HP\n\n\nThe enemy's current HP.\n\n\n\n\nInitialization\n\n\nCall one of the init functions at the start of the script. It will set\nthe ffc's and npc's properties and initialize the global variables.\nNormally, \nghost->OriginalTile\n will be set to \nGH_BLANK_TILE\n to make the enemy\ninvisible, \nghost->Extend\n will be set to 3, and \nGhost_TileWidth\n and\n\nGhost_TileHeight\n will be set to the size of the FFC. These will not happen\nif the FFC's combo is \nGH_INVISIBLE_COMBO\n, or, in the case of AutoGhost\nenemies, if that's the combo they're set to use.\n\n\n\n\nvoid Ghost_Init(ffc this, npc ghost)\n\n\nThe basic initialization function. Provide your own npc.\n\n\nnpc Ghost_InitCreate(ffc this, int enemyID)\n\n\nThis will create an npc of type \nenemyID\n and return a pointer to it.\n\n\nnpc Ghost_InitWait(ffc this, int enemyIndex, bool useEnemyPos)\n\n\n\n\nThis function will select an enemy on the screen as the ghost.\n\n\nenemyIndex\n is the number to pass to \nScreen->LoadNPC()\n, normally the npc's\nposition in the screen's enemy list.\n\n\nIf \nuseEnemyPos\n is true, the FFC will be moved to the enemy's position.\nOtherwise, the FFC's current position will be used.\n\n\nThe function will only wait 4 frames for the enemy to appear to minimize\nthe possibility of incorrectly using an enemy that is spawned later on. If\nthe expected enemy does not appear in that time, it will call \nQuit()\n.\n\n\n\n\nnpc Ghost_InitWait2(ffc this, int enemyID, bool useEnemyPos)\n\n\nSimilar to \nGhost_InitWait()\n, except this loads the first enemy of type\n\nenemyID\n that is not already in use by another ghost.zh script. This is\nespecially helpful if enemies are present other than those placed by\n\nScreen > Enemies\n, since you can't always be certain what index an enemy\nwill be assigned.\n\n\nnpc Ghost_InitSpawn(ffc this, int enemyID)\n\n\nThis will create the ghosted enemy in a random location.\n\n\nnpc Ghost_InitAutoGhost(ffc this, int enemyID)\n\n\nThis should only be used with a script that is meant to be set up\nautomatically by the \nAutoGhost()\n function. Similar to \nGhost_InitWait2()\n,\nthis will load the first unused enemy of the given type. The enemy must\nalready be on the screen when the function is called, or it will log\nan error and call \nQuit()\n.\n\n\n\n\nFlags\n\n\nThere are a number of flags you can apply to an enemy to control its behavior\nand appearance. This is typically done just after initialization, but flags\ncan be changed at any time while the enemy is alive.\n\n\nNote that these flags cannot be combined with bitwise OR.\n\n\n\n\nvoid Ghost_SetFlag(int flag)\n\n\nvoid Ghost_UnsetFlag(int flag)\n\n\n\n\nSet or unset a flag that controls details of the enemy's behavior.\n\n\nValid arguments are:\n\n\n\n\nGHF_KNOCKBACK\n\n\nThe enemy can be knocked back when hit.\n\n\nGHF_KNOCKBACK_4WAY\n\n\n\n\nThe enemy will be knocked back when hit, even if its direction and\nLink's are not suitably aligned.\n\n\n\n\nNote\n\n\nIt is not necessary to use \nGHF_KNOCKBACK\n along with this flag.\n\n\n\n\n\n\nGHF_REDUCED_KNOCKBACK\n\n\n\n\nThe enemy will be knocked back 2 pixels per frame instead of 4.\n\n\n\n\nNote\n\n\nIt is not necessary to use \nGHF_KNOCKBACK\n along with this flag.\n\n\n\n\n\n\nGHF_STUN\n\n\nStunning will be handled automatically. \nGhost_Waitframe\n functions will not\nreturn while the enemy is stunned.\n\n\nGHF_CLOCK\n\n\nThe enemy will be affected by clocks. \nGhost_Waitframe\n functions will not\nreturn while a clock is active.\n\n\nGHF_NO_FALL\n\n\nghost->Jump\n will be set to 0 each frame and \nGhost_Jump\n will be ignored.\nIf \nGHF_NO_FALL\n is not used, \nGhost_CanMove(DIR_UP)\n will always be false\non sideview screens.\n\n\nGHF_SET_DIRECTION\n\n\nThe enemy's direction will automatically be set based on which way\nit moves. Unless \nGHF_8WAY\n is set, this will only use up, down, left,\nand right.\n\n\nGHF_SET_OVERLAY\n\n\nSet or unset the \nDraw Over\n flag each frame based on Z position. The\nheight at which it changes is determined by \nGH_DRAW_OVER_THRESHOLD\n.\n\n\nGHF_FAKE_Z\n\n\n\n\nGhost_Z\n and \nGhost_Jump\n will affect the enemy's position on the Y axis\nrather than Z. A shadow will be drawn under it according to the\n\nGH_SHADOW_\n settings.\n\n\n\n\nNote\n\n\nIf the global setting \nGH_FAKE_Z\n is enabled, all Z movement\nwill behave this way, and this flag will have no effect.\n\n\n\n\n\n\nGHF_4WAY\n\n\nChange the FFC's combo based on \nGhost_Dir\n. This requires a particular\nsetup. There must be four consecutive combos in the list, one for each\ndirection: up, down, left, and right, in order. Set \nGhost_Data\n to the\nupward-facing combo.\n\n\nGHF_8WAY\n\n\nSet the FFC's combo based on direction, inclusing diagonals. This will\nalso cause \nGHF_SET_DIRECTION\n to use all eight directions. The combo\norder is up, down, left, right, up-left, up-right, down-left, down-right.\n\n\nGHF_MOVE_OFFSCREEN\n\n\nMovement functions will not stop the enemy at the screen edges.\n\n\nGHF_NORMAL\n\n\nCombines \nGHF_KNOCKBACK\n, \nGHF_STUN\n, \nGHF_CLOCK\n, and \nGHF_SET_DIRECTION\n.\n\n\nGHF_IGNORE_SOLIDITY\n\n\n\n\nThe enemy can move over solid combos, as long as they are not pits or water.\n\n\n\n\nNote\n\n\nThis and the following walkability control flags only affect movement\nvia the \nGhost_Move\n functions and \nGhost_Vx\n and \nGhost_Vy\n.\nIf \nGhost_X\n and \nGhost_Y\n are set directly, the enemy can move anywhere.\n\n\n\n\n\n\nGHF_IGNORE_WATER\n\n\nThe enemy can move over water, regardless of solidity.\n\n\nGHF_IGNORE_PITS\n\n\nThe enemy can move over direct warps, regardless of solidity.\n\n\nGHF_IGNORE_ALL_TERRAIN\n\n\nCombines \nGHF_IGNORE_SOLIDITY\n, \nGHF_IGNORE_WATER\n, and \nGHF_IGNORE_PITS\n.\n\n\nGHF_WATER_ONLY\n\n\nThe enemy can only move in water (including shallow water). This overrides\nthe above terrain flags.\n\n\nGHF_DEEP_WATER_ONLY\n\n\nThe enemy can only move in deep water. This overrides the above\nterrain flags.\n\n\nGHF_FULL_TILE_MOVEMENT\n\n\nThe enemy will not walk onto a tile unless the entire tile is walkable.\nThis is particularly useful for enemies using walking functions along\nwith other movement.\n\n\nGHF_FLYING_ENEMY\n\n\n\n\nThe enemy will be blocked by the \nNo Flying Enemies\n combo type.\nIf this flag is not set, it will be blocked by \nNo Ground Enemies\n if\n\nGhost_Z==0\n or \nNo Jumping Enemies\n if \nGhost_Z>0\n.\n\n\n\n\nNote\n\n\nThis flag does not imply any others that a flying enemy would likely use,\nsuch as \nGHF_IGNORE_PITS\n or \nGHF_NO_FALL\n. Those must be set separately.\n\n\n\n\n\n\nGHF_IGNORE_NO_ENEMY\n\n\nThe enemy will ignore all enemy blocking flags and combos.\n\n\nGHF_STATIC_SHADOW\n\n\nThe enemy's shadow will not animate. This only applies if Z movement is\nfaked due to either by \nGH_FAKE_Z\n or \nGHF_FAKE_Z\n.\n\n\n\n\n\n\nvoid Ghost_ClearFlags()\n\n\nUnsets all flags.\n\n\nbool Ghost_FlagIsSet(int flag)\n\n\nReturns true if the given flag is set and false if not.\n\n\n\n\nWaitframe\n\n\nAfter the enemy is initialized and until it dies, use the \nGhost_Waitframe\n\nfunctions below instead of \nWaitframe()\n to keep the global variables\nconsistent and maintain the illusion of a real enemy. Failure to do so may\ncause the global variables to become incorrect, completely breaking your script.\n\n\n\n\nbool Ghost_Waitframe(ffc this, npc ghost, bool clearOnDeath, bool quitOnDeath)\n\n\n\n\nThis is a replacement function for \nWaitframe()\n. In addition to waiting a frame,\nit will handle the necessary routine updates. These include setting the npc's\nand ffc's positions and movement and dealing with clocks, stunning, flashing,\nknockback, and death. If the enemy is stunned or frozen by a clock, or if\nscripts are suspended, \nGhost_Waitframe()\n will not return until the enemy dies\nor the blocking condition ends.\n\n\nIf \nclearOnDeath\n is true, when the npc dies, \nthis->Data\n will be set to 0,\n\nGhost_ClearAttachedFFCs()\n will be called, and the npc will be moved so that\nits death animation and dropped item are centered.\n\n\nIf \nquitOnDeath\n is true, \nQuit()\n will be called when the npc dies.\nIf it's false, the function will return true if the npc is alive and false otherwise.\n\n\n\n\nbool Ghost_Waitframe2(ffc this, npc ghost, bool clearOnDeath, bool quitOnDeath)\n\n\nLike the above, except this ignores the position and movement variables and\nuses the npc's instead. Use this if you want to use built-in enemy movement.\n\n\nvoid Ghost_WaitframeLight(ffc this, npc ghost)\n\n\nMinimal waitframe function. Aside from waiting a frame, this only keeps the\nglobal variables consistent, positions attached FFCs, and sets up drawing.\nIf scripts are suspended, this function will not return until they are resumed.\n\n\nbool Ghost_Waitframes(ffc this, npc ghost, bool clearOnDeath, bool quitOnDeath, int numFrames)\n\n\nbool Ghost_Waitframes2(ffc this, npc ghost, bool clearOnDeath, bool quitOnDeath, int numFrames)\n\n\nvoid Ghost_WaitframesLight(ffc this, npc ghost, int numFrames)\n\n\nThese simply call the corresponding \nGhost_Waitframe\n function \nnumFrames\n times.\n\n\nvoid Ghost_Waitframe(ffc this, npc ghost)\n\n\nvoid Ghost_Waitframe2(ffc this, npc ghost)\n\n\nvoid Ghost_Waitframes(ffc this, npc ghost, int numFrames)\n\n\nvoid Ghost_Waitframes2(ffc this, npc ghost, int numFrames)\n\n\nSimpler variants of the Waitframe functions. These are equivalent to calling\nthe regular functions with \nclearOnDeath\n and \nquitOnDeath\n both true. The\nscript will quit if the enemy dies, so there is no return value from these.\n\n\nbool Ghost_Waitframe(ffc this, npc ghost, int deathAnimation, bool quitOnDeath)\n\n\nbool Ghost_Waitframe2(ffc this, npc ghost, int deathAnimation, bool quitOnDeath)\n\n\nThese will call \nGhost_DeathAnimation()\n with the specified animation if the\nenemy dies. See \nGhost_DeathAnimation()\n for \ndeathAnimation\n arguments.\n\n\n\n\nModification\n\n\n\n\nvoid Ghost_SetSize(ffc this, npc ghost, int tileWidth, int tileHeight)\n\n\nSets the tile size of the enemy. The new width and height are given\nin tiles and must be between 1 and 4. If -1 is given for either dimension,\nit will not be changed. If you called \nGhost_SetHitOffsets()\n previously,\nit will be undone; the enemy's size and position will be set to match\nthe FFC's.\n\n\nvoid Ghost_Transform(ffc this, npc ghost, int combo, int cset, int tileWidth, int tileHeight)\n\n\nChange the FFC to a new combo and CSet and resize the FFC and npc. The FFC's\nand npc's positions will be adjusted so that they're centered on the same\nspotas before. For all four numeric arguments, pass in -1 if you don't want to change\nthe existing value. If you called \nGhost_SetHitOffsets()\n previously, it will\nbe undone. Attached FFCs will not be affected.\n\n\nvoid Ghost_SetHitOffsets(npc ghost, float top, float bottom, float left, float right)\n\n\nIf you want the enemy's hitbox to be smaller than the FFC, use this function\nto adjust it. Each argument will cause the hitbox to shrink away from the\ncorresponding edge. This applies to both collision detection and movement.\nFor each argument, if the number is 1 or greater, it will be interpreted as\nthe difference in pixels; if the number is between 0 and 1, it will be\ntreated as a fraction of the FFC's full size. So, for instance, a \ntop\n\nargument of 0.25 would shrink the hitbox by 1/4 of the FFC's height.\n\n\nvoid Ghost_SwapNPC(npc oldGhost, npc newGhost, bool copyHP)\n\n\nCopies size, position, Misc[], and HP (optionally) from the old ghost to the\nnew one, then moves the old one out of the way.\n\n\nvoid Ghost_ReplaceNPC(npc oldGhost, npc newGhost, bool copyHP)\n\n\nCopies data from the old ghost to the new one, then silently kills the old one.\n\n\nvoid Ghost_StoreDefenses(npc ghost, int storedDefense[])\n\n\nCopies \nghost->Defense[]\n into \nstoredDefense\n. The array size must be at least 18.\n\n\nvoid Ghost_SetDefenses(npc ghost, int defense[])\n\n\nCopies \ndefense\n into \nghost->Defense[]\n. The array size must be at least 18.\n\n\nvoid Ghost_SetAllDefenses(npc ghost, int defType)\n\n\nSets all of the enemy's defenses to \ndefType\n, which should be an NPCDT constant.\n\n\n\n\nMovement\n\n\n\n\nvoid Ghost_Move(int dir, float step, int imprecision)\n\n\nvoid Ghost_MoveXY(float xStep, float yStep, int imprecision)\n\n\nvoid Ghost_MoveAtAngle(float angle, float step, int imprecision)\n\n\nvoid Ghost_MoveTowardLink(float step, int imprecision)\n\n\n\n\nMakes the enemy move. \nGhost_CanMove()\n will be checked automatically.\nIf the \nGHF_SETDIRECTION\n flag is set, the npc's direction will be changed\naccordingly unless \nGhost_ForceDir()\n was called beforehand. \n\n\nstep\n is given in pixels.\n\n\nGhost_MoveAtAngle()\n's \nangle\n argument is in degrees.\n\n\nimprecision\n makes the function ignore a couple of pixels at the\nedges of the enemy's hitbox so that it doesn't get stuck on corners.\n\n\n\n\nbool Ghost_CanMove(int dir, float step, int imprecision)\n\n\nbool Ghost_CanMove(int dir, float step, int imprecision, bool inAir)\n\n\n\n\nDetermines whether the enemy can move in the given direction and distance.\nstep is given in pixels.\n\n\nOn sideview screens, a direction of \nDIR_UP\n will always return false unless\nthe \nGHF_NO_FALL\n flag is set.\n\n\ninAir\n determines whether non-flying enemies check for \nNo Ground Enemies\n or\n\nNo Jumping Enemies\n. If it is not specified, \ninAir\n is true if \nGhost_Z>0\n.\n\n\n\n\nbool Ghost_CanMovePixel(int x, int y)\n\n\nbool Ghost_CanMovePixel(int x, int y, bool inAir)\n\n\nUsed internally by \nGhost_CanMove()\n. Returns true if the enemy can move onto\nthe given pixel.\n\n\nfloat Ghost_HaltingWalk4(int counter, int step, int rate, int homing, int hunger, int haltRate, int haltTime)\n\n\n\n\nThis function mimics the built-in movement function used by walking enemies.\n\n\nstep\n corresponds to \nnpc->Step\n. It represents speed in hundredths of a pixel\nper frame.\n\n\nrate\n corresponds to \nnpc->Rate\n and should be between 0 and 16.\n\n\nhoming\n corresponds to \nnpc->Homing\n and should be between 0 and 256.\n\n\nhunger\n corresponds to \nnpc->Hunger\n and should be between 0 and 4.\n\n\nhaltRate\n corresponds to \nnpc->Haltrate\n and should be between 0 and 16.\n\n\nhaltTime\n determines how long the enemy will stand still when it\nhalts. Zols use \nRand(8)<<4\n, Gels use \n(Rand(8)<<3)+2\n, Goriyas use 1, and all\nothers use 48.\n\n\ncounter\n should initially be -1, then set to the function's\nreturn value each frame. While the enemy is halted, the return value will be\nthe remaining halt time, which you can use to determine when to fire. So:\n\n\nint counter = -1;\nwhile(true)\n{\n    counter=Ghost_HaltingWalk4(counter, step, rate, homing, hunger, haltRate, 48);\n    if(counter==16) // Fire after halted for 32 frames\n        FireEWeapon(...);\n    Ghost_Waitframe(...);\n}\n\n\n\n\nThis function depends on \nGhost_Dir\n and will set it even if \nGHF_SET_DIRECTION\n\nis not used. It will also set \nGhost_Dir\n to -1 if the enemy is trapped.\n\n\n\n\nint Ghost_ConstantWalk4(int counter, int step, int rate, int homing, int hunger)\n\n\n\n\nThis is the movement function used by Dodongos and Lanmolas. The arguments\nare the same as above.\n\n\nThis function depends on \nGhost_Dir\n and will set it\neven if \nGHF_SET_DIRECTION\n is not used. It will also set \nGhost_Dir\n to -1 if\nthe enemy is trapped.\n\n\n\n\nint Ghost_ConstantWalk8(int counter, int step, int rate, int homing, int hunger)\n\n\n\n\nThis is the movement function used by Moldorms. The arguments are the same as above.\n\n\nThis function depends on \nGhost_Dir\n and will set it even if \nGHF_SET_DIRECTION\n\nis not used. It will also set \nGhost_Dir\n to -1 if the enemy is trapped.\n\n\n\n\nint Ghost_VariableWalk8(int counter, int step, int rate, int homing, int hunger, int turnCheckTime)\n\n\n\n\nThis is the movement function used by Digdoggers, Manhandlas, Patras, and\nfairies.\n\n\nturnCheckTime\n deterines how many frames the enemy moves before checking\nwhether it should change direction.\n\n\nThe other arguments are the same as above.\n\n\nThis function depends on \nGhost_Dir\n and will set it even if \nGHF_SET_DIRECTION\n\nis not used. It will also set \nGhost_Dir\n to -1 if the enemy is trapped.\n\n\n\n\nfloat Ghost_FloaterWalk(float counter, int normalStep, int accelTime, float accelAmount, int accelSteps, int rate, int homing, int hunger, int turnCheckTime, int restTime)\n\n\n\n\nThis is the movement function used by Peahats, Keese, and Ghinis. It works\nlike \nGhost_VariableWalk8()\n, plus the enemy will periodically stop moving.\nWhen the enemy is moving at full speed, there is a 1 in 768 chance each frame\nthat it will stop.\n\n\nWhen the enemy starts or stops moving, its speed will change in discrete\nincrements of \naccelAmount\n. \naccelSteps\n is the number of times this will\nhappen, and \naccelTime\n is the time in frames between each step.\n\n\nrestTime\n is how long the enemy stays stopped. Peahats use 80, while\nGhinis and Keese use 120.\n\n\n\n\n\n\nOther\n\n\n\n\nfloat Ghost_GetAttribute(npc ghost, int index, float defaultVal)\n\n\nfloat Ghost_GetAttribute(npc ghost, int index, float defaultVal, float min, float max)\n\n\nRetrieves the value of \nghost->Attribute[index]\n bound to the range \nmin\n - \nmax\n.\nIf the value is 0, \ndefaultVal\n will be returned. \ndefaultVal\n does not need to be\nbetween \nmin\n and \nmax\n.\n\n\nvoid Ghost_SpawnAnimationPuff(ffc this, npc ghost)\n\n\nThe initialization functions interrupt the normal enemy spawning animation;\nthis function fakes it. It draws a sprite (lweapon) using sprite number\n\nGH_SPAWN_SPRITE\n at the enemy's position and returns after the animation completes.\n\n\nvoid Ghost_SpawnAnimationFlicker(ffc this, npc ghost)\n\n\nDraws the other spawn animation, in which the enemy flickers for 64 frames.\nWith a visible enemy and invisible FFC, the timing won't be quite right\nunless the enemy's spawn type is \nInstant\n.\n\n\nvoid Ghost_DeathAnimation(ffc this, npc ghost, int anim)\n\n\n\n\nDisplays a death animation based on \nanim\n, then clears the enemy. This does\nnot call \nQuit()\n.\n\n\nanim\n should be one of these:\n\n\n\n\nGHD_EXPLODE\n\n\nA series of explosions appear randomly around the enemy.\n\n\nGHD_EXPLODE_FLASH\n\n\nThe same, plus the enemy flashes.\n\n\nGHD_SHRINK\n\n\nThe enemy grows slightly and then shrinks away to nothing. This does not\nwork with enemies that use additional combos.\n\n\n\n\nAny other value will simply cause the enemy to disappear.\n\n\n\n\nvoid Ghost_AddCombo(int combo, float x, float y)\n\n\nvoid Ghost_AddCombo(int combo, float x, float y, int width, int height)\n\n\nAdd another combo to the enemy. It will move, flash, and flicker along with\nthe enemy. \nx\n and \ny\n are offsets from \nGhost_X\n and \nGhost_Y\n. Up to four combos\nmay be added in this way.\n\n\nvoid Ghost_ClearCombos\n\n\nClears all combos added by \nGhost_AddCombo()\n.\n\n\nbool Ghost_GotHit()\n\n\nReturns true if the enemy was hit in the last frame.\n\n\nbool Ghost_WasFrozen()\n\n\nReturns true if the enemy was stunned or frozen by a clock in the last frame.\nThis only works if \nGHF_STUN\n or \nGHF_CLOCK\n is used.\n\n\nvoid Ghost_ForceDir(int dir)\n\n\nSets \nGhost_Dir\n and stops it from being changed automatically until the next frame.\n\n\nvoid Ghost_ForceCSet(int cset)\n\n\n\n\nSets \nGhost_CSet\n and stops flashing until the next frame.\n\n\nThis won't work with scripts that use a visible enemy and invisible FFC.\n\n\n\n\nvoid Ghost_StartFlashing()\n\n\nvoid Ghost_StartFlashing(int time)\n\n\n\n\nMakes the enemy start flashing or flickering as though it had been hit.\n\n\nIf \ntime\n is specified, the enemy will flash for that many frames\ninstead of the standard 32.\n\n\nThis won't work with scripts that use a visible enemy and invisible FFC.\n\n\n\n\nvoid Ghost_StopFlashing()\n\n\n\n\nMakes the enemy stop flashing or flickering.\n\n\nThis won't work with scripts that use a visible enemy and invisible FFC.\n\n\n\n\nvoid Ghost_StopKnockback()\n\n\nStops the enemy from being knocked back.\n\n\nvoid Ghost_CheckHit(ffc this, npc ghost)\n\n\n\n\nThis will cause the enemy to flash and be knocked back when it is damaged.\n\n\nThis is used internally by the \nGhost_Waitframe\n functions. If you use\none of those, you don't need to use this as well.\n\n\n\n\nbool Ghost_CheckFreeze(ffc this, npc ghost)\n\n\n\n\nChecks whether the npc has been stunned or frozen by a clock. If so, the\nfunction does not return until the npc either recovers or dies. \nGhost_CheckHit()\n\nwill be called each frame during that time. The return value is true if the\nnpc is still alive and false if it's dead.\n\n\nThis is used internally by the \nGhost_Waitframe\n functions. If you use\none of those, you don't need to use this as well.\n\n\n\n\nvoid Ghost_SetPosition(ffc this, npc ghost)\n\n\nPositions the NPC and FFC according to the position variables and\n\nghost->Draw*Offset\n. This is done automatically in the \nGhost_Waitframe\n\nfunctions, so you generally will never need to use this.",
            "title": "Enemy scripts"
        },
        {
            "location": "/enemyScript/index.html#enemy-variables-and-functions",
            "text": "",
            "title": "Enemy variables and functions"
        },
        {
            "location": "/enemyScript/index.html#global-variables",
            "text": "Many aspects of the enemy are controlled by these global variables. They're set\nby a  Ghost_Init  function and kept consistent between frames by the Ghost_Waitframe  functions.   float Ghost_X  float Ghost_Y  float Ghost_Z  The X, Y and Z position of the enemy.  float Ghost_Vx  float Ghost_Vy  float Ghost_Jump   The X, Y, and Z velocity of the enemy.  Ghost_Vx  and  Ghost_Vy  are handled by  Ghost_MoveXY() , so they will respect\nsolidity, water, pits, and screen edges.   float Ghost_Ax  float Ghost_Ay  The X and Y acceleration of the enemy.  int Ghost_Dir  The direction the enemy is facing.  int Ghost_Data  int Ghost_CSet   The current combo and CSet of the enemy.  If  Ghost_InitAutoGhost()  is used,  Ghost_CSet  will be set to the enemy's CSet.\nAll other initializion functions will use the FFC's CSet.  If the  GHF_4WAY  or  GHF_8WAY  flags are used,  Ghost_Data  should always be set to\nthe upward-facing combo.   int Ghost_TileWidth  int Ghost_TileHeight   The width and height of the enemy in tiles, which must be between 1 and 4.   Caution  If these variables are set, the change will not fully take effect until\nthe next Waitframe. It's better to use  Ghost_SetSize()  instead and\nconsider these variables read-only.    int Ghost_HP  The enemy's current HP.",
            "title": "Global variables"
        },
        {
            "location": "/enemyScript/index.html#initialization",
            "text": "Call one of the init functions at the start of the script. It will set\nthe ffc's and npc's properties and initialize the global variables.\nNormally,  ghost->OriginalTile  will be set to  GH_BLANK_TILE  to make the enemy\ninvisible,  ghost->Extend  will be set to 3, and  Ghost_TileWidth  and Ghost_TileHeight  will be set to the size of the FFC. These will not happen\nif the FFC's combo is  GH_INVISIBLE_COMBO , or, in the case of AutoGhost\nenemies, if that's the combo they're set to use.   void Ghost_Init(ffc this, npc ghost)  The basic initialization function. Provide your own npc.  npc Ghost_InitCreate(ffc this, int enemyID)  This will create an npc of type  enemyID  and return a pointer to it.  npc Ghost_InitWait(ffc this, int enemyIndex, bool useEnemyPos)   This function will select an enemy on the screen as the ghost.  enemyIndex  is the number to pass to  Screen->LoadNPC() , normally the npc's\nposition in the screen's enemy list.  If  useEnemyPos  is true, the FFC will be moved to the enemy's position.\nOtherwise, the FFC's current position will be used.  The function will only wait 4 frames for the enemy to appear to minimize\nthe possibility of incorrectly using an enemy that is spawned later on. If\nthe expected enemy does not appear in that time, it will call  Quit() .   npc Ghost_InitWait2(ffc this, int enemyID, bool useEnemyPos)  Similar to  Ghost_InitWait() , except this loads the first enemy of type enemyID  that is not already in use by another ghost.zh script. This is\nespecially helpful if enemies are present other than those placed by Screen > Enemies , since you can't always be certain what index an enemy\nwill be assigned.  npc Ghost_InitSpawn(ffc this, int enemyID)  This will create the ghosted enemy in a random location.  npc Ghost_InitAutoGhost(ffc this, int enemyID)  This should only be used with a script that is meant to be set up\nautomatically by the  AutoGhost()  function. Similar to  Ghost_InitWait2() ,\nthis will load the first unused enemy of the given type. The enemy must\nalready be on the screen when the function is called, or it will log\nan error and call  Quit() .",
            "title": "Initialization"
        },
        {
            "location": "/enemyScript/index.html#flags",
            "text": "There are a number of flags you can apply to an enemy to control its behavior\nand appearance. This is typically done just after initialization, but flags\ncan be changed at any time while the enemy is alive.  Note that these flags cannot be combined with bitwise OR.   void Ghost_SetFlag(int flag)  void Ghost_UnsetFlag(int flag)   Set or unset a flag that controls details of the enemy's behavior.  Valid arguments are:   GHF_KNOCKBACK  The enemy can be knocked back when hit.  GHF_KNOCKBACK_4WAY   The enemy will be knocked back when hit, even if its direction and\nLink's are not suitably aligned.   Note  It is not necessary to use  GHF_KNOCKBACK  along with this flag.    GHF_REDUCED_KNOCKBACK   The enemy will be knocked back 2 pixels per frame instead of 4.   Note  It is not necessary to use  GHF_KNOCKBACK  along with this flag.    GHF_STUN  Stunning will be handled automatically.  Ghost_Waitframe  functions will not\nreturn while the enemy is stunned.  GHF_CLOCK  The enemy will be affected by clocks.  Ghost_Waitframe  functions will not\nreturn while a clock is active.  GHF_NO_FALL  ghost->Jump  will be set to 0 each frame and  Ghost_Jump  will be ignored.\nIf  GHF_NO_FALL  is not used,  Ghost_CanMove(DIR_UP)  will always be false\non sideview screens.  GHF_SET_DIRECTION  The enemy's direction will automatically be set based on which way\nit moves. Unless  GHF_8WAY  is set, this will only use up, down, left,\nand right.  GHF_SET_OVERLAY  Set or unset the  Draw Over  flag each frame based on Z position. The\nheight at which it changes is determined by  GH_DRAW_OVER_THRESHOLD .  GHF_FAKE_Z   Ghost_Z  and  Ghost_Jump  will affect the enemy's position on the Y axis\nrather than Z. A shadow will be drawn under it according to the GH_SHADOW_  settings.   Note  If the global setting  GH_FAKE_Z  is enabled, all Z movement\nwill behave this way, and this flag will have no effect.    GHF_4WAY  Change the FFC's combo based on  Ghost_Dir . This requires a particular\nsetup. There must be four consecutive combos in the list, one for each\ndirection: up, down, left, and right, in order. Set  Ghost_Data  to the\nupward-facing combo.  GHF_8WAY  Set the FFC's combo based on direction, inclusing diagonals. This will\nalso cause  GHF_SET_DIRECTION  to use all eight directions. The combo\norder is up, down, left, right, up-left, up-right, down-left, down-right.  GHF_MOVE_OFFSCREEN  Movement functions will not stop the enemy at the screen edges.  GHF_NORMAL  Combines  GHF_KNOCKBACK ,  GHF_STUN ,  GHF_CLOCK , and  GHF_SET_DIRECTION .  GHF_IGNORE_SOLIDITY   The enemy can move over solid combos, as long as they are not pits or water.   Note  This and the following walkability control flags only affect movement\nvia the  Ghost_Move  functions and  Ghost_Vx  and  Ghost_Vy .\nIf  Ghost_X  and  Ghost_Y  are set directly, the enemy can move anywhere.    GHF_IGNORE_WATER  The enemy can move over water, regardless of solidity.  GHF_IGNORE_PITS  The enemy can move over direct warps, regardless of solidity.  GHF_IGNORE_ALL_TERRAIN  Combines  GHF_IGNORE_SOLIDITY ,  GHF_IGNORE_WATER , and  GHF_IGNORE_PITS .  GHF_WATER_ONLY  The enemy can only move in water (including shallow water). This overrides\nthe above terrain flags.  GHF_DEEP_WATER_ONLY  The enemy can only move in deep water. This overrides the above\nterrain flags.  GHF_FULL_TILE_MOVEMENT  The enemy will not walk onto a tile unless the entire tile is walkable.\nThis is particularly useful for enemies using walking functions along\nwith other movement.  GHF_FLYING_ENEMY   The enemy will be blocked by the  No Flying Enemies  combo type.\nIf this flag is not set, it will be blocked by  No Ground Enemies  if Ghost_Z==0  or  No Jumping Enemies  if  Ghost_Z>0 .   Note  This flag does not imply any others that a flying enemy would likely use,\nsuch as  GHF_IGNORE_PITS  or  GHF_NO_FALL . Those must be set separately.    GHF_IGNORE_NO_ENEMY  The enemy will ignore all enemy blocking flags and combos.  GHF_STATIC_SHADOW  The enemy's shadow will not animate. This only applies if Z movement is\nfaked due to either by  GH_FAKE_Z  or  GHF_FAKE_Z .    void Ghost_ClearFlags()  Unsets all flags.  bool Ghost_FlagIsSet(int flag)  Returns true if the given flag is set and false if not.",
            "title": "Flags"
        },
        {
            "location": "/enemyScript/index.html#waitframe",
            "text": "After the enemy is initialized and until it dies, use the  Ghost_Waitframe \nfunctions below instead of  Waitframe()  to keep the global variables\nconsistent and maintain the illusion of a real enemy. Failure to do so may\ncause the global variables to become incorrect, completely breaking your script.   bool Ghost_Waitframe(ffc this, npc ghost, bool clearOnDeath, bool quitOnDeath)   This is a replacement function for  Waitframe() . In addition to waiting a frame,\nit will handle the necessary routine updates. These include setting the npc's\nand ffc's positions and movement and dealing with clocks, stunning, flashing,\nknockback, and death. If the enemy is stunned or frozen by a clock, or if\nscripts are suspended,  Ghost_Waitframe()  will not return until the enemy dies\nor the blocking condition ends.  If  clearOnDeath  is true, when the npc dies,  this->Data  will be set to 0, Ghost_ClearAttachedFFCs()  will be called, and the npc will be moved so that\nits death animation and dropped item are centered.  If  quitOnDeath  is true,  Quit()  will be called when the npc dies.\nIf it's false, the function will return true if the npc is alive and false otherwise.   bool Ghost_Waitframe2(ffc this, npc ghost, bool clearOnDeath, bool quitOnDeath)  Like the above, except this ignores the position and movement variables and\nuses the npc's instead. Use this if you want to use built-in enemy movement.  void Ghost_WaitframeLight(ffc this, npc ghost)  Minimal waitframe function. Aside from waiting a frame, this only keeps the\nglobal variables consistent, positions attached FFCs, and sets up drawing.\nIf scripts are suspended, this function will not return until they are resumed.  bool Ghost_Waitframes(ffc this, npc ghost, bool clearOnDeath, bool quitOnDeath, int numFrames)  bool Ghost_Waitframes2(ffc this, npc ghost, bool clearOnDeath, bool quitOnDeath, int numFrames)  void Ghost_WaitframesLight(ffc this, npc ghost, int numFrames)  These simply call the corresponding  Ghost_Waitframe  function  numFrames  times.  void Ghost_Waitframe(ffc this, npc ghost)  void Ghost_Waitframe2(ffc this, npc ghost)  void Ghost_Waitframes(ffc this, npc ghost, int numFrames)  void Ghost_Waitframes2(ffc this, npc ghost, int numFrames)  Simpler variants of the Waitframe functions. These are equivalent to calling\nthe regular functions with  clearOnDeath  and  quitOnDeath  both true. The\nscript will quit if the enemy dies, so there is no return value from these.  bool Ghost_Waitframe(ffc this, npc ghost, int deathAnimation, bool quitOnDeath)  bool Ghost_Waitframe2(ffc this, npc ghost, int deathAnimation, bool quitOnDeath)  These will call  Ghost_DeathAnimation()  with the specified animation if the\nenemy dies. See  Ghost_DeathAnimation()  for  deathAnimation  arguments.",
            "title": "Waitframe"
        },
        {
            "location": "/enemyScript/index.html#modification",
            "text": "void Ghost_SetSize(ffc this, npc ghost, int tileWidth, int tileHeight)  Sets the tile size of the enemy. The new width and height are given\nin tiles and must be between 1 and 4. If -1 is given for either dimension,\nit will not be changed. If you called  Ghost_SetHitOffsets()  previously,\nit will be undone; the enemy's size and position will be set to match\nthe FFC's.  void Ghost_Transform(ffc this, npc ghost, int combo, int cset, int tileWidth, int tileHeight)  Change the FFC to a new combo and CSet and resize the FFC and npc. The FFC's\nand npc's positions will be adjusted so that they're centered on the same\nspotas before. For all four numeric arguments, pass in -1 if you don't want to change\nthe existing value. If you called  Ghost_SetHitOffsets()  previously, it will\nbe undone. Attached FFCs will not be affected.  void Ghost_SetHitOffsets(npc ghost, float top, float bottom, float left, float right)  If you want the enemy's hitbox to be smaller than the FFC, use this function\nto adjust it. Each argument will cause the hitbox to shrink away from the\ncorresponding edge. This applies to both collision detection and movement.\nFor each argument, if the number is 1 or greater, it will be interpreted as\nthe difference in pixels; if the number is between 0 and 1, it will be\ntreated as a fraction of the FFC's full size. So, for instance, a  top \nargument of 0.25 would shrink the hitbox by 1/4 of the FFC's height.  void Ghost_SwapNPC(npc oldGhost, npc newGhost, bool copyHP)  Copies size, position, Misc[], and HP (optionally) from the old ghost to the\nnew one, then moves the old one out of the way.  void Ghost_ReplaceNPC(npc oldGhost, npc newGhost, bool copyHP)  Copies data from the old ghost to the new one, then silently kills the old one.  void Ghost_StoreDefenses(npc ghost, int storedDefense[])  Copies  ghost->Defense[]  into  storedDefense . The array size must be at least 18.  void Ghost_SetDefenses(npc ghost, int defense[])  Copies  defense  into  ghost->Defense[] . The array size must be at least 18.  void Ghost_SetAllDefenses(npc ghost, int defType)  Sets all of the enemy's defenses to  defType , which should be an NPCDT constant.",
            "title": "Modification"
        },
        {
            "location": "/enemyScript/index.html#movement",
            "text": "void Ghost_Move(int dir, float step, int imprecision)  void Ghost_MoveXY(float xStep, float yStep, int imprecision)  void Ghost_MoveAtAngle(float angle, float step, int imprecision)  void Ghost_MoveTowardLink(float step, int imprecision)   Makes the enemy move.  Ghost_CanMove()  will be checked automatically.\nIf the  GHF_SETDIRECTION  flag is set, the npc's direction will be changed\naccordingly unless  Ghost_ForceDir()  was called beforehand.   step  is given in pixels.  Ghost_MoveAtAngle() 's  angle  argument is in degrees.  imprecision  makes the function ignore a couple of pixels at the\nedges of the enemy's hitbox so that it doesn't get stuck on corners.   bool Ghost_CanMove(int dir, float step, int imprecision)  bool Ghost_CanMove(int dir, float step, int imprecision, bool inAir)   Determines whether the enemy can move in the given direction and distance.\nstep is given in pixels.  On sideview screens, a direction of  DIR_UP  will always return false unless\nthe  GHF_NO_FALL  flag is set.  inAir  determines whether non-flying enemies check for  No Ground Enemies  or No Jumping Enemies . If it is not specified,  inAir  is true if  Ghost_Z>0 .   bool Ghost_CanMovePixel(int x, int y)  bool Ghost_CanMovePixel(int x, int y, bool inAir)  Used internally by  Ghost_CanMove() . Returns true if the enemy can move onto\nthe given pixel.  float Ghost_HaltingWalk4(int counter, int step, int rate, int homing, int hunger, int haltRate, int haltTime)   This function mimics the built-in movement function used by walking enemies.  step  corresponds to  npc->Step . It represents speed in hundredths of a pixel\nper frame.  rate  corresponds to  npc->Rate  and should be between 0 and 16.  homing  corresponds to  npc->Homing  and should be between 0 and 256.  hunger  corresponds to  npc->Hunger  and should be between 0 and 4.  haltRate  corresponds to  npc->Haltrate  and should be between 0 and 16.  haltTime  determines how long the enemy will stand still when it\nhalts. Zols use  Rand(8)<<4 , Gels use  (Rand(8)<<3)+2 , Goriyas use 1, and all\nothers use 48.  counter  should initially be -1, then set to the function's\nreturn value each frame. While the enemy is halted, the return value will be\nthe remaining halt time, which you can use to determine when to fire. So:  int counter = -1;\nwhile(true)\n{\n    counter=Ghost_HaltingWalk4(counter, step, rate, homing, hunger, haltRate, 48);\n    if(counter==16) // Fire after halted for 32 frames\n        FireEWeapon(...);\n    Ghost_Waitframe(...);\n}  This function depends on  Ghost_Dir  and will set it even if  GHF_SET_DIRECTION \nis not used. It will also set  Ghost_Dir  to -1 if the enemy is trapped.   int Ghost_ConstantWalk4(int counter, int step, int rate, int homing, int hunger)   This is the movement function used by Dodongos and Lanmolas. The arguments\nare the same as above.  This function depends on  Ghost_Dir  and will set it\neven if  GHF_SET_DIRECTION  is not used. It will also set  Ghost_Dir  to -1 if\nthe enemy is trapped.   int Ghost_ConstantWalk8(int counter, int step, int rate, int homing, int hunger)   This is the movement function used by Moldorms. The arguments are the same as above.  This function depends on  Ghost_Dir  and will set it even if  GHF_SET_DIRECTION \nis not used. It will also set  Ghost_Dir  to -1 if the enemy is trapped.   int Ghost_VariableWalk8(int counter, int step, int rate, int homing, int hunger, int turnCheckTime)   This is the movement function used by Digdoggers, Manhandlas, Patras, and\nfairies.  turnCheckTime  deterines how many frames the enemy moves before checking\nwhether it should change direction.  The other arguments are the same as above.  This function depends on  Ghost_Dir  and will set it even if  GHF_SET_DIRECTION \nis not used. It will also set  Ghost_Dir  to -1 if the enemy is trapped.   float Ghost_FloaterWalk(float counter, int normalStep, int accelTime, float accelAmount, int accelSteps, int rate, int homing, int hunger, int turnCheckTime, int restTime)   This is the movement function used by Peahats, Keese, and Ghinis. It works\nlike  Ghost_VariableWalk8() , plus the enemy will periodically stop moving.\nWhen the enemy is moving at full speed, there is a 1 in 768 chance each frame\nthat it will stop.  When the enemy starts or stops moving, its speed will change in discrete\nincrements of  accelAmount .  accelSteps  is the number of times this will\nhappen, and  accelTime  is the time in frames between each step.  restTime  is how long the enemy stays stopped. Peahats use 80, while\nGhinis and Keese use 120.",
            "title": "Movement"
        },
        {
            "location": "/enemyScript/index.html#other",
            "text": "float Ghost_GetAttribute(npc ghost, int index, float defaultVal)  float Ghost_GetAttribute(npc ghost, int index, float defaultVal, float min, float max)  Retrieves the value of  ghost->Attribute[index]  bound to the range  min  -  max .\nIf the value is 0,  defaultVal  will be returned.  defaultVal  does not need to be\nbetween  min  and  max .  void Ghost_SpawnAnimationPuff(ffc this, npc ghost)  The initialization functions interrupt the normal enemy spawning animation;\nthis function fakes it. It draws a sprite (lweapon) using sprite number GH_SPAWN_SPRITE  at the enemy's position and returns after the animation completes.  void Ghost_SpawnAnimationFlicker(ffc this, npc ghost)  Draws the other spawn animation, in which the enemy flickers for 64 frames.\nWith a visible enemy and invisible FFC, the timing won't be quite right\nunless the enemy's spawn type is  Instant .  void Ghost_DeathAnimation(ffc this, npc ghost, int anim)   Displays a death animation based on  anim , then clears the enemy. This does\nnot call  Quit() .  anim  should be one of these:   GHD_EXPLODE  A series of explosions appear randomly around the enemy.  GHD_EXPLODE_FLASH  The same, plus the enemy flashes.  GHD_SHRINK  The enemy grows slightly and then shrinks away to nothing. This does not\nwork with enemies that use additional combos.   Any other value will simply cause the enemy to disappear.   void Ghost_AddCombo(int combo, float x, float y)  void Ghost_AddCombo(int combo, float x, float y, int width, int height)  Add another combo to the enemy. It will move, flash, and flicker along with\nthe enemy.  x  and  y  are offsets from  Ghost_X  and  Ghost_Y . Up to four combos\nmay be added in this way.  void Ghost_ClearCombos  Clears all combos added by  Ghost_AddCombo() .  bool Ghost_GotHit()  Returns true if the enemy was hit in the last frame.  bool Ghost_WasFrozen()  Returns true if the enemy was stunned or frozen by a clock in the last frame.\nThis only works if  GHF_STUN  or  GHF_CLOCK  is used.  void Ghost_ForceDir(int dir)  Sets  Ghost_Dir  and stops it from being changed automatically until the next frame.  void Ghost_ForceCSet(int cset)   Sets  Ghost_CSet  and stops flashing until the next frame.  This won't work with scripts that use a visible enemy and invisible FFC.   void Ghost_StartFlashing()  void Ghost_StartFlashing(int time)   Makes the enemy start flashing or flickering as though it had been hit.  If  time  is specified, the enemy will flash for that many frames\ninstead of the standard 32.  This won't work with scripts that use a visible enemy and invisible FFC.   void Ghost_StopFlashing()   Makes the enemy stop flashing or flickering.  This won't work with scripts that use a visible enemy and invisible FFC.   void Ghost_StopKnockback()  Stops the enemy from being knocked back.  void Ghost_CheckHit(ffc this, npc ghost)   This will cause the enemy to flash and be knocked back when it is damaged.  This is used internally by the  Ghost_Waitframe  functions. If you use\none of those, you don't need to use this as well.   bool Ghost_CheckFreeze(ffc this, npc ghost)   Checks whether the npc has been stunned or frozen by a clock. If so, the\nfunction does not return until the npc either recovers or dies.  Ghost_CheckHit() \nwill be called each frame during that time. The return value is true if the\nnpc is still alive and false if it's dead.  This is used internally by the  Ghost_Waitframe  functions. If you use\none of those, you don't need to use this as well.   void Ghost_SetPosition(ffc this, npc ghost)  Positions the NPC and FFC according to the position variables and ghost->Draw*Offset . This is done automatically in the  Ghost_Waitframe \nfunctions, so you generally will never need to use this.",
            "title": "Other"
        },
        {
            "location": "/eweapon/index.html",
            "text": "Eweapon functions\n\n\n\n\neweapon FireEWeapon(int weaponID, int x, int y, float angle, int step, int damage, int sprite, int sound, int flags)\n\n\neweapon FireAimedEWeapon(int weaponID, int x, int y, float angle, int step, int damage, int sprite, int sound, int flags)\n\n\neweapon FireNonAngularEWeapon(int weaponID, int x, int y, int direction, int step, int damage, int sprite, int sound, int flags)\n\n\neweapon FireBigEWeapon(int weaponID, int x, int y, float angle, int step, int damage, int sprite, int sound, int flags, int width, int height)\n\n\neweapon FireBigAimedEWeapon(int weaponID, int x, int y, float angle, int step, int damage, int sprite, int sound, int flags, int width, int height)\n\n\neweapon FireBigNonAngularEWeapon(int weaponID, int x, int y, int direction, int step, int damage, int sprite, int sound, int flags, int width, int height)\n\n\n\n\nCreate an eweapon with the given properties.\n\n\nangle\n is given in radians. If the weapon is aimed, this is an offset from\nthe base angle. So, for instance, an \nangle\n of 0.2 will always aim slightly\naway from Link.\n\n\nsprite\n should be the ID of a sprite from \nQuest > Graphics > Sprites > Weapons/Misc.\n \nIf this is -1, the standard sprite for the weapon type will be used.\n\n\nsound\n specifies a sound to play. If this is 0, no sound will be played.\nIf it's -1, a sound will be chosen automatically based on the type of weapon.\n\n\nflags\n argument should be one or more \nEWF_\n constants ORed together, or 0 for none.\n\n\n\n\nEWF_UNBLOCKABLE\n\n\nThe weapon is unblockable.\n\n\nEWF_ROTATE\n\n\nThe weapon's sprite will be rotated and flipped according to the weapon's direction.\n\n\nEWF_ROTATE_360\n\n\n\n\nThe weapon will be drawn using Screen->DrawTile(), allowing the sprite\nto rotate in whichever direction the weapon is moving.\n\n\n\n\nTip\n\n\nThe base sprite set in \nQuest > Graphics > Sprites > Weapons/Misc.\n\nshould be pointing to the right.\n\n\n\n\n\n\nEWF_SHADOW\n\n\nThe weapon will cast a shadow if its Z position is greater than 0.\n\n\nEWF_FLICKER\n\n\nThe weapon will be invisible every other frame.\n\n\nEWF_NO_COLLISION\n\n\nThe weapon's collision detection will be disabled.\n\n\nEWF_FAKE_Z\n\n\n\n\nThe weapon's hitbox will always be on the ground.\n\n\n\n\nNote\n\n\nThis does not actually keep the weapon on the ground; it only\nsimulates this by setting the weapon's hit and draw offsets.\n\n\n\n\n\n\n\n\n\n\neweapon CreateDummyEWeapon(int weaponID, int step, int damage, int sprite, int sound, int flags)\n\n\neweapon CreateBigDummyEWeapon(int weaponID, int step, int damage, int sprite, int sound, int flags, int width, int height)\n\n\n\n\nThese will create a dummy eweapon to be used as a prototype for\n\nSetEWeaponDeathEffect()\n. The dummy weapon will be invisible and will have\ncollision detection disabled. It can have a movement, lifespan, and death\neffect set, but the dummy weapon itself will not make use of them - only\nits copies will.\n\n\nA dummy weapon will never be removed automatically. If reaching the weapon\nlimit is a concern, you should destroy the weapon yourself when it's no\nlonger needed.\n\n\n\n\nvoid SetEWeaponMovement(eweapon wpn, int type, float arg, float arg2)\n\n\n\n\nThis sets an eweapon's movement pattern. The type argument should be one of\nthe \nEWM_\n constants below. The effect of \narg\n and \narg2\n vary depending on\nthe type of movement.\n\n\n\n\nEWM_SINE_WAVE\n\n\n\n\nMove in a sine wave.\n\n\narg\n: Amplitude\n\n\narg2\n: Angular frequency in degrees per frame\n\n\n\n\nEWM_HOMING\n\n\n\n\nTurn toward Link each frame.\n\n\narg\n: Maximum rotation per frame in radians\n\n\narg2\n: Homing time in frames - after this many frames, the weapon\nwill die. Use -1 to home indefinitely.\n\n\n\n\nEWM_HOMING_REAIM\n\n\n\n\nMove in straight lines, stopping and re-aiming at Link.\n\n\narg\n: Number of re-aims\n\n\narg2\n: Time between re-aims\n\n\n\n\nEWM_RANDOM\n\n\n\n\nTurn randomly each frame.\n\n\narg\n: Maximum rotation per frame in radians\n\n\narg2\n: Rotation time in frames - after this many frames, the weapon\nwill die. Use -1 to keep moving indefinitely.\n\n\n\n\nEWM_RANDOM_REAIM\n\n\n\n\nStop frequently and aim in a random direction\n\n\narg\n: Number of re-aims\n\n\narg2\n: Time between re-aims\n\n\n\n\nEWM_VEER\n\n\n\n\nAccelerate in a given direction.\n\n\narg\n: Direction of acceleration\n\n\narg2\n: Rate of acceleration\n\n\n\n\nEWM_DRIFT\n\n\n\n\nDrift in the given direction at a constant speed.\n\n\narg\n: Drift direction\n\n\narg2\n: Drift speed\n\n\n\n\nEWM_DRIFT_WAIT\n\n\n\n\nDrift in the given direction at a constant speed and wait 16 frames before\nbeginning normal movement. This mimics the behavior of boss fireballs.\n\n\narg\n: Drift direction\n\n\narg2\n: Drift speed\n\n\n\n\nEWM_THROW\n\n\n\n\nArc through the air as if thrown. The weapon stops moving when it hits\nthe ground.\n\n\narg\n: Initial upward velocity; use -1 to make the weapon travel the\ndistance to Link\n\n\narg2\n: OR together these flags, or use 0 for none:\n\n\n\n\nEWMF_BOUNCE\n\n\nThe weapon will bounce on impact.\n\n\nEWMF_DIE\n\n\nThe weapon will die on impact rather than simply stopping.\n\n\n\n\n\n\nEWM_FALL\n\n\n\n\nFall straight down. The weapon stops moving when it hits the ground.\n\n\narg\n: Initial height\n\n\narg2\n: OR together these flags, or use 0 for none:\n\n\n\n\nEWMF_BOUNCE\n\n\nThe weapon will bounce on impact.\n\n\nEWMF_DIE\n\n\nThe weapon will die on impact rather than simply stopping.\n\n\n\n\n\n\n\n\n\n\nvoid SetEWeaponLifespan(eweapon wpn, int type, int arg)\n\n\n\n\nThis controls the conditions under which a weapon dies. \"Dying\" does not mean\nthe weapon is removed, but that its scripted movement is no longer handled,\nand, optionally, a death effect is activated. Use one of the EWL_ constants\nfor the type argument. The effect of arg depends on the type.\n\n\n\n\nEWL_TIMER\n\n\n\n\nDie after a certain amount of time.\n\n\narg\n: Time in frames\n\n\n\n\nEWL_NEAR_LINK\n\n\n\n\nDie when within a certain distance of Link.\n\n\narg\n: Distance in pixels\n\n\n\n\nEWL_SLOW_TO_HALT\n\n\n\n\nSlow down until stopped, then die. This can behave oddly if movement is set.\n\n\narg\n: Step per frame\n\n\n\n\n\n\n\n\nvoid SetEWeaponDeathEffect(eweapon wpn, int type, int arg)\n\n\n\n\nThis determines what happens when the weapon dies. The type argument should\nbe one of the \nEWD_\n constants below. The effect of arg depends on the type.\n\n\n\n\nEWD_VANISH\n\n\n\n\nThe weapon is removed.\n\n\narg\n: No effect\n\n\n\n\nEWD_AIM_AT_LINK\n\n\n\n\nThe weapon pauses for a moment, then aims at Link.\n\n\narg\n: Delay\n\n\n\n\nEWD_EXPLODE\n\n\n\n\nThe weapon explodes.\n\n\narg\n: Explosion damage\n\n\n\n\nEWD_SBOMB_EXPLODE\n\n\n\n\nThe weapon explodes like a super bomb.\n\n\narg\n: Explosion damage\n\n\n\n\nEWD_4_FIREBALLS_HV\n\n\n\n\nShoots fireballs horizontally and vertically.\n\n\narg\n: Fireball sprite\n\n\n\n\nEWD_4_FIREBALLS_DIAG\n\n\n\n\nShoots fireballs at 45-degree angles.\n\n\narg\n: Fireball sprite\n\n\n\n\nEWD_4_FIREBALLS_RANDOM\n\n\n\n\nRandomly shoots fireballs either vertically and horizontally or at\n45-degree angles.\n\n\narg\n: Fireball sprite\n\n\n\n\nEWD_8_FIREBALLS\n\n\n\n\nShoots fireballs horizontally, vertically, and at 45-degree angles\n\n\narg\n: Fireball sprite\n\n\n\n\nEWD_FIRE\n\n\n\n\nLeaves a single, immobile fire\n\n\narg\n: Fire sprite\n\n\n\n\nEWD_4_FIRES_HV\n\n\n\n\nShoots fires horizontally and vertically.\n\n\narg\n: Fire sprite\n\n\n\n\nEWD_4_FIRES_DIAG\n\n\n\n\nShoots fires at 45-degree angles.\n\n\narg\n: Fire sprite\n\n\n\n\nEWD_4_FIRES_RANDOM\n\n\n\n\nRandomly shoots fires either vertically and horizontally or at\n45-degree angles.\n\n\narg\n: Fire sprite\n\n\n\n\nEWD_8_FIRES\n\n\n\n\nShoots fires horizontally, vertically, and at 45-degree angles\n\n\narg\n: Fire sprite\n\n\n\n\nEWD_SPAWN_NPC\n\n\n\n\nCreates an npc at the weapon's location. This is done without regard for\nthe suitability of the location.\n\n\narg\n: npc to spawn\n\n\n\n\nEWD_RUN_SCRIPT\n\n\n\n\nLoads an unused FFC, positions it at the weapons position, and runs a\nscript. The weapon will not be removed; it should be loaded by the script\nwith \nGetAssociatedEWeapon()\n. The number to pass into it will be given to\nthe script as argument D0. If no FFC is free, the weapon will simply be removed.\n\n\narg\n: Script to run. If this is not a valid script, \nEWD_VANISH\n will be\nset instead\n\n\n\n\n\n\n\n\nvoid SetEWeaponDeathEffect(eweapon wpn, eweapon prototype, int numShots, int spreadType, float angle)\n\n\n\n\nThis will make a weapon spawn copies of a prototype weapon when it dies.\nThe prototype must be a dummy eweapon.\n\n\nspreadType\n is one of the following:\n\n\n\n\nEWD_EVEN\n\n\n\n\nWeapons are evenly spaced\n\n\nangle\n: First weapon's offset from 0 in radians\n\n\n\n\nEWD_AIMED\n\n\n\n\nWeapons are aimed at Link\n\n\nangle\n: Angle range of spawned weapons in radians\n\n\n\n\nEWD_RANDOM\n\n\n\n\nWeapons are fired at random angles\n\n\nangle\n: No effect\n\n\n\n\n\n\n\n\nvoid SetEWeaponDir(eweapon wpn)\n\n\nSet the direction of an angled eweapon so that it interacts correctly\nwith shields. This is normally handled automatically, but you may need\nto use it if you script a weapon's movement yourself.\n\n\nvoid SetEWeaponRotation(eweapon wpn)\n\n\nvoid SetEWeaponRotation(eweapon wpn, int direction)\n\n\nRotate the weapon's sprite. If \ndirection\n is not given,\nthis is done according to the weapon's direction.\n\n\nvoid KillEWeapon(eweapon wpn)\n\n\nKill the eweapon, stopping scripted movement and activating any\ndeath effects.\n\n\nvoid DrawEWeaponShadow(eweapon wpn)\n\n\nDraws a shadow under the eweapon according to the \nGH_SHADOW_\n constants. This\nis used internally when \nEWF_SHADOW\n is set.\n\n\nint GetDefaultEWeaponSprite(int weaponID)\n\n\nReturns the sprite normally used by the given weapon type.\n\n\nint GetDefaultEWeaponSound(int weaponID)\n\n\nReturns the sound normally used by the given weapon type.\n\n\neweapon GetAssociatedEWeapon(int weaponID)\n\n\nFinds an eweapon using an internal ID number. This should be used by scripts\nlaunched by \nEWD_RUN_SCRIPT\n, and the weaponID argument should be the number\npassed to the script as D0. If the requested weapon is not found, an\nuninitialized pointer will be returned.\n\n\nbool IsGhostZHEWeapon(eweapon wpn)\n\n\nReturns true if the weapon is one created or handled by ghost.zh.\n\n\nbool IsDummyEWeapon(eweapon wpn)\n\n\nReturns true if the eweapon is a dummy.",
            "title": "Eweapons"
        },
        {
            "location": "/eweapon/index.html#eweapon-functions",
            "text": "eweapon FireEWeapon(int weaponID, int x, int y, float angle, int step, int damage, int sprite, int sound, int flags)  eweapon FireAimedEWeapon(int weaponID, int x, int y, float angle, int step, int damage, int sprite, int sound, int flags)  eweapon FireNonAngularEWeapon(int weaponID, int x, int y, int direction, int step, int damage, int sprite, int sound, int flags)  eweapon FireBigEWeapon(int weaponID, int x, int y, float angle, int step, int damage, int sprite, int sound, int flags, int width, int height)  eweapon FireBigAimedEWeapon(int weaponID, int x, int y, float angle, int step, int damage, int sprite, int sound, int flags, int width, int height)  eweapon FireBigNonAngularEWeapon(int weaponID, int x, int y, int direction, int step, int damage, int sprite, int sound, int flags, int width, int height)   Create an eweapon with the given properties.  angle  is given in radians. If the weapon is aimed, this is an offset from\nthe base angle. So, for instance, an  angle  of 0.2 will always aim slightly\naway from Link.  sprite  should be the ID of a sprite from  Quest > Graphics > Sprites > Weapons/Misc.  \nIf this is -1, the standard sprite for the weapon type will be used.  sound  specifies a sound to play. If this is 0, no sound will be played.\nIf it's -1, a sound will be chosen automatically based on the type of weapon.  flags  argument should be one or more  EWF_  constants ORed together, or 0 for none.   EWF_UNBLOCKABLE  The weapon is unblockable.  EWF_ROTATE  The weapon's sprite will be rotated and flipped according to the weapon's direction.  EWF_ROTATE_360   The weapon will be drawn using Screen->DrawTile(), allowing the sprite\nto rotate in whichever direction the weapon is moving.   Tip  The base sprite set in  Quest > Graphics > Sprites > Weapons/Misc. \nshould be pointing to the right.    EWF_SHADOW  The weapon will cast a shadow if its Z position is greater than 0.  EWF_FLICKER  The weapon will be invisible every other frame.  EWF_NO_COLLISION  The weapon's collision detection will be disabled.  EWF_FAKE_Z   The weapon's hitbox will always be on the ground.   Note  This does not actually keep the weapon on the ground; it only\nsimulates this by setting the weapon's hit and draw offsets.      eweapon CreateDummyEWeapon(int weaponID, int step, int damage, int sprite, int sound, int flags)  eweapon CreateBigDummyEWeapon(int weaponID, int step, int damage, int sprite, int sound, int flags, int width, int height)   These will create a dummy eweapon to be used as a prototype for SetEWeaponDeathEffect() . The dummy weapon will be invisible and will have\ncollision detection disabled. It can have a movement, lifespan, and death\neffect set, but the dummy weapon itself will not make use of them - only\nits copies will.  A dummy weapon will never be removed automatically. If reaching the weapon\nlimit is a concern, you should destroy the weapon yourself when it's no\nlonger needed.   void SetEWeaponMovement(eweapon wpn, int type, float arg, float arg2)   This sets an eweapon's movement pattern. The type argument should be one of\nthe  EWM_  constants below. The effect of  arg  and  arg2  vary depending on\nthe type of movement.   EWM_SINE_WAVE   Move in a sine wave.  arg : Amplitude  arg2 : Angular frequency in degrees per frame   EWM_HOMING   Turn toward Link each frame.  arg : Maximum rotation per frame in radians  arg2 : Homing time in frames - after this many frames, the weapon\nwill die. Use -1 to home indefinitely.   EWM_HOMING_REAIM   Move in straight lines, stopping and re-aiming at Link.  arg : Number of re-aims  arg2 : Time between re-aims   EWM_RANDOM   Turn randomly each frame.  arg : Maximum rotation per frame in radians  arg2 : Rotation time in frames - after this many frames, the weapon\nwill die. Use -1 to keep moving indefinitely.   EWM_RANDOM_REAIM   Stop frequently and aim in a random direction  arg : Number of re-aims  arg2 : Time between re-aims   EWM_VEER   Accelerate in a given direction.  arg : Direction of acceleration  arg2 : Rate of acceleration   EWM_DRIFT   Drift in the given direction at a constant speed.  arg : Drift direction  arg2 : Drift speed   EWM_DRIFT_WAIT   Drift in the given direction at a constant speed and wait 16 frames before\nbeginning normal movement. This mimics the behavior of boss fireballs.  arg : Drift direction  arg2 : Drift speed   EWM_THROW   Arc through the air as if thrown. The weapon stops moving when it hits\nthe ground.  arg : Initial upward velocity; use -1 to make the weapon travel the\ndistance to Link  arg2 : OR together these flags, or use 0 for none:   EWMF_BOUNCE  The weapon will bounce on impact.  EWMF_DIE  The weapon will die on impact rather than simply stopping.    EWM_FALL   Fall straight down. The weapon stops moving when it hits the ground.  arg : Initial height  arg2 : OR together these flags, or use 0 for none:   EWMF_BOUNCE  The weapon will bounce on impact.  EWMF_DIE  The weapon will die on impact rather than simply stopping.      void SetEWeaponLifespan(eweapon wpn, int type, int arg)   This controls the conditions under which a weapon dies. \"Dying\" does not mean\nthe weapon is removed, but that its scripted movement is no longer handled,\nand, optionally, a death effect is activated. Use one of the EWL_ constants\nfor the type argument. The effect of arg depends on the type.   EWL_TIMER   Die after a certain amount of time.  arg : Time in frames   EWL_NEAR_LINK   Die when within a certain distance of Link.  arg : Distance in pixels   EWL_SLOW_TO_HALT   Slow down until stopped, then die. This can behave oddly if movement is set.  arg : Step per frame     void SetEWeaponDeathEffect(eweapon wpn, int type, int arg)   This determines what happens when the weapon dies. The type argument should\nbe one of the  EWD_  constants below. The effect of arg depends on the type.   EWD_VANISH   The weapon is removed.  arg : No effect   EWD_AIM_AT_LINK   The weapon pauses for a moment, then aims at Link.  arg : Delay   EWD_EXPLODE   The weapon explodes.  arg : Explosion damage   EWD_SBOMB_EXPLODE   The weapon explodes like a super bomb.  arg : Explosion damage   EWD_4_FIREBALLS_HV   Shoots fireballs horizontally and vertically.  arg : Fireball sprite   EWD_4_FIREBALLS_DIAG   Shoots fireballs at 45-degree angles.  arg : Fireball sprite   EWD_4_FIREBALLS_RANDOM   Randomly shoots fireballs either vertically and horizontally or at\n45-degree angles.  arg : Fireball sprite   EWD_8_FIREBALLS   Shoots fireballs horizontally, vertically, and at 45-degree angles  arg : Fireball sprite   EWD_FIRE   Leaves a single, immobile fire  arg : Fire sprite   EWD_4_FIRES_HV   Shoots fires horizontally and vertically.  arg : Fire sprite   EWD_4_FIRES_DIAG   Shoots fires at 45-degree angles.  arg : Fire sprite   EWD_4_FIRES_RANDOM   Randomly shoots fires either vertically and horizontally or at\n45-degree angles.  arg : Fire sprite   EWD_8_FIRES   Shoots fires horizontally, vertically, and at 45-degree angles  arg : Fire sprite   EWD_SPAWN_NPC   Creates an npc at the weapon's location. This is done without regard for\nthe suitability of the location.  arg : npc to spawn   EWD_RUN_SCRIPT   Loads an unused FFC, positions it at the weapons position, and runs a\nscript. The weapon will not be removed; it should be loaded by the script\nwith  GetAssociatedEWeapon() . The number to pass into it will be given to\nthe script as argument D0. If no FFC is free, the weapon will simply be removed.  arg : Script to run. If this is not a valid script,  EWD_VANISH  will be\nset instead     void SetEWeaponDeathEffect(eweapon wpn, eweapon prototype, int numShots, int spreadType, float angle)   This will make a weapon spawn copies of a prototype weapon when it dies.\nThe prototype must be a dummy eweapon.  spreadType  is one of the following:   EWD_EVEN   Weapons are evenly spaced  angle : First weapon's offset from 0 in radians   EWD_AIMED   Weapons are aimed at Link  angle : Angle range of spawned weapons in radians   EWD_RANDOM   Weapons are fired at random angles  angle : No effect     void SetEWeaponDir(eweapon wpn)  Set the direction of an angled eweapon so that it interacts correctly\nwith shields. This is normally handled automatically, but you may need\nto use it if you script a weapon's movement yourself.  void SetEWeaponRotation(eweapon wpn)  void SetEWeaponRotation(eweapon wpn, int direction)  Rotate the weapon's sprite. If  direction  is not given,\nthis is done according to the weapon's direction.  void KillEWeapon(eweapon wpn)  Kill the eweapon, stopping scripted movement and activating any\ndeath effects.  void DrawEWeaponShadow(eweapon wpn)  Draws a shadow under the eweapon according to the  GH_SHADOW_  constants. This\nis used internally when  EWF_SHADOW  is set.  int GetDefaultEWeaponSprite(int weaponID)  Returns the sprite normally used by the given weapon type.  int GetDefaultEWeaponSound(int weaponID)  Returns the sound normally used by the given weapon type.  eweapon GetAssociatedEWeapon(int weaponID)  Finds an eweapon using an internal ID number. This should be used by scripts\nlaunched by  EWD_RUN_SCRIPT , and the weaponID argument should be the number\npassed to the script as D0. If the requested weapon is not found, an\nuninitialized pointer will be returned.  bool IsGhostZHEWeapon(eweapon wpn)  Returns true if the weapon is one created or handled by ghost.zh.  bool IsDummyEWeapon(eweapon wpn)  Returns true if the eweapon is a dummy.",
            "title": "Eweapon functions"
        },
        {
            "location": "/other/index.html",
            "text": "Miscellaneous functions\n\n\n\n\nvoid SetEnemyProperty(npc enemy, int property, float newValue)\n\n\nfloat GetEnemyProperty(npc enemy, int property)\n\n\n\n\nThese functions allow some of the properties of ghost.zh scripts to be read\nand set from other scripts. property must be one of the following:\n\n\n\n\nENPROP_X\n\n\nENPROP_Y\n\n\nENPROP_Z\n\n\nENPROP_JUMP\n\n\nENPROP_DIR\n\n\nENPROP_HP\n\n\nENPROP_CSET\n\n\n\n\nThese work for all enemies, not just scripted ones, so there's no need\nto check that beforehand.\n\n\n\n\nint FindSpawnPoint(bool landOK, bool wallsOK, bool waterOK, bool pitsOK)\n\n\n\n\nFinds a random combo position meeting the given criteria some distance away\nfrom Link and enemies. This can be useful if you want the enemy to spawn in\na random position that ZC would not select itself. The result is undefined\nif no suitable location exists, but that will not happen unless there is\nalmost no space abailable on the screen.\n\n\nlandOK\n: Walkable, non-water, non-pit combos are okay\n\n\nwallsOK\n: Unwalkable, non-water, non-pit combos are okay\n\n\nwaterOK\n: All deep water combos are okay\n\n\npitsOK\n: Direct warps are okay\n\n\n\n\nint FindSpawnPoint(int type, int flag)\n\n\nLike the above, but finds a combo with the given combo type or flag,\nregardless of solidity. Only layer 0 is checked. Use -1 for either argument\nto ignore it.\n\n\nnpc SpawnNPC(int id)\n\n\nSpawns an npc with the given ID in a random location and returns a pointer to it.\n\n\nint FindUnusedFFC()\n\n\nint FindUnusedFFC(int startingFrom)\n\n\nReturns the ID number of an FFC that is not currently in use in the range\n\nAUTOGHOST_MIN_FFC\n to \nAUTOGHOST_MAX_FFC\n. Returns 0 if no FFC is available in\nthat range. If \nstartingFrom\n is given, the ID returned will be at least\n\nstartingFrom+1\n.\n\n\nvoid Ghost_MarkAsInUse(npc ghost)\n\n\nMark an enemy as being in use by a script. This allows you to create\nadditional enemies without \nAutoGhost()\n or \nGhost_InitWait2()\n trying to use them.\n\n\nbool Ghost_IsInUse(npc ghost)\n\n\nReturns true if the given enemy is in use by a ghost.zh script.\n\n\nbool ClockIsActive()\n\n\nReturns true if a clock is currently in effect.\n\n\nvoid SuspendGhostZHScripts()\n\n\nSuspends the execution of all ghost.zh scripts. Until scripts are resumed,\n\nGhost_Waitframe\n functions will not return and \nUpdateEWeapon()\n will not\ndo anything. This also stops \nAutoGhost()\n from running, so any new enemies\nwill not have scripts launched until \nResumeGhostZHScripts()\n is called.\n\n\nvoid ResumeGhostZHScripts()\n\n\nResumes execution of ghost.zh scripts.",
            "title": "Miscellaneous"
        },
        {
            "location": "/other/index.html#miscellaneous-functions",
            "text": "void SetEnemyProperty(npc enemy, int property, float newValue)  float GetEnemyProperty(npc enemy, int property)   These functions allow some of the properties of ghost.zh scripts to be read\nand set from other scripts. property must be one of the following:   ENPROP_X  ENPROP_Y  ENPROP_Z  ENPROP_JUMP  ENPROP_DIR  ENPROP_HP  ENPROP_CSET   These work for all enemies, not just scripted ones, so there's no need\nto check that beforehand.   int FindSpawnPoint(bool landOK, bool wallsOK, bool waterOK, bool pitsOK)   Finds a random combo position meeting the given criteria some distance away\nfrom Link and enemies. This can be useful if you want the enemy to spawn in\na random position that ZC would not select itself. The result is undefined\nif no suitable location exists, but that will not happen unless there is\nalmost no space abailable on the screen.  landOK : Walkable, non-water, non-pit combos are okay  wallsOK : Unwalkable, non-water, non-pit combos are okay  waterOK : All deep water combos are okay  pitsOK : Direct warps are okay   int FindSpawnPoint(int type, int flag)  Like the above, but finds a combo with the given combo type or flag,\nregardless of solidity. Only layer 0 is checked. Use -1 for either argument\nto ignore it.  npc SpawnNPC(int id)  Spawns an npc with the given ID in a random location and returns a pointer to it.  int FindUnusedFFC()  int FindUnusedFFC(int startingFrom)  Returns the ID number of an FFC that is not currently in use in the range AUTOGHOST_MIN_FFC  to  AUTOGHOST_MAX_FFC . Returns 0 if no FFC is available in\nthat range. If  startingFrom  is given, the ID returned will be at least startingFrom+1 .  void Ghost_MarkAsInUse(npc ghost)  Mark an enemy as being in use by a script. This allows you to create\nadditional enemies without  AutoGhost()  or  Ghost_InitWait2()  trying to use them.  bool Ghost_IsInUse(npc ghost)  Returns true if the given enemy is in use by a ghost.zh script.  bool ClockIsActive()  Returns true if a clock is currently in effect.  void SuspendGhostZHScripts()  Suspends the execution of all ghost.zh scripts. Until scripts are resumed, Ghost_Waitframe  functions will not return and  UpdateEWeapon()  will not\ndo anything. This also stops  AutoGhost()  from running, so any new enemies\nwill not have scripts launched until  ResumeGhostZHScripts()  is called.  void ResumeGhostZHScripts()  Resumes execution of ghost.zh scripts.",
            "title": "Miscellaneous functions"
        }
    ]
}