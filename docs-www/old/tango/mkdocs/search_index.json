{
    "docs": [
        {
            "location": "/index.html",
            "text": "tango.zh\n\n\ntango.zh is a ZScript library for displaying text and creating menus. It offers\nfar more options for strings, including custom fonts, the ability to print\nmultiple strings at once, and even simple scripting capabilities.",
            "title": "About"
        },
        {
            "location": "/index.html#tangozh",
            "text": "tango.zh is a ZScript library for displaying text and creating menus. It offers\nfar more options for strings, including custom fonts, the ability to print\nmultiple strings at once, and even simple scripting capabilities.",
            "title": "tango.zh"
        },
        {
            "location": "/usage/index.html",
            "text": "Usage\n\n\nBasic usage\n\n\nThere are three functions, listed listed \nhere\n,\nthat need to be added to the active global script, or you can use the provided\n\nTangoActiveScript\n.\n\n\nDisplaying a string involves working with two data structures: styles and\ntext slots. Styles determines how strings look and behave. Text slots are\nwhere the text and processing state are stored. To display a string, you must\nset up a style, load the text into a text slot, apply the style to the slot,\nand then activate it.\n\n\nAll it takes to set up a style is a call to \nTango_SetStyleAttribute()\n for\neach attribute you want to set. Most attributes are optional, but you must\nat least set a font and text color. The regular \nFONT\n constants from std.zh\ncan't be used; you'll need to import one of the font definitions in the\n\ntango/font\n folder and use the \nTANGO_FONT\n constant defined there.\n\n\nOnce a style is set up, displaying text requires six steps:\n\n\n\n\nFind a free text slot (\nTango_GetFreeSlot()\n)\n\n\nClear any data already in the slot (\nTango_ClearSlot()\n)\n\n\nLoad text into the slot (\nTango_LoadString()\n or \nTango_LoadMessage()\n)\n\n\nSet a style (\nTango_SetSlotStyle()\n)\n\n\nSet the position (\nTango_SetSlotPosition()\n)\n\n\nActivate the text slot (\nTango_ActivateSlot()\n)\n\n\n\n\nIf you want to try it out without learning all the details, or if you'd\njust like a simple, straightforward example, check out tangoQuickStart.zh.\nIt provides a few simple functions and a minimal global script. There are\na few constants to set for colors, combos, and sounds; the defaults are\nset up for the classic tileset.\n\n\nFor more information on text slots and styles, see the page on \ndata structures\nand formats\n.\n\n\nTango code\n\n\nTango implements a simple scripting language with functions embedded\nin strings. Code is identified by the character \n@\n (by default;\nset \n__TANGO_CODE_DELIMITER\n to change this).\n\n\n@\n is followed immediately by a function name, then up to two arguments\nin parentheses, separated by spaces. Parentheses are needed even if\na function takes no arguments. For example, the string\n\n\"@playsfx(64)Hello, @savename()!\"\n would play sound 64 and print (possibly)\n\n\"Hello, Link!\"\n.\n\n\nVariables are also available. These can be used to set the properties of\nthe text. For instance, \n@speed\n controls how quickly the text is drawn.\nEach slot has two variables, \n@a0\n and \n@a1\n, used to store arbitrary data or\ncommunicate with ZScript. You can also create your own variables for\nthe same purposes.\n\n\nIt's also possible to use \n@##\n or \n@(##)\n to insert a character directly into\nthe text. The string \n\"@90@69@76@68@65\"\n is equivalent to \n\"ZELDA\"\n This is\nuseful for inserting line breaks (\n@26\n) and font characters beyond the\nASCII range. Also, \n@0\n can be used to terminate the text early; anything after\n\n@0\n won't be printed.\n\n\nFinally, it's possible to highlight text using double brackets. For example,\nin the string \nYou got the ((Wooden Sword))!\n, the text \"Wooden Sword\" would\nbe printed in a different color than the rest of the text. \n(( ))\n, \n[[ ]]\n,\n\n<< >>\n, and \n{{ }}\n each have style settings allowing them to produce\ndifferent colors. This feature can be disabled by setting\n\n__TANGO_ENABLE_BRACKET_HIGHLIGHT\n to 0.\n\n\nMenus\n\n\nTango code can be used to set up simple menus in strings using a few simple\nfunction calls. It's also necessary to set the \nTANGO_STYLE_MENU_CURSOR\n\nstyle attributes so the cursor will be drawn correctly.\n\n\nTo create a menu, add a call to \n@choice()\n for each choice followed by the\ncorresponding text. Each call to \n@choice()\n needs an argument - a number that\nwill be the value of that choice. The choices should be followed by a call to\n\n@domenu()\n, which will run until the user makes a selection or cancels.\nAfterward, the value of the selected choice will be stored in \n@chosen\n, or 0\nif the user cancelled.\n\n\nFor example:\n\n\"Pick one!@26@choice(1)Option A@26@choice(2)Option B@domenu()@26@if(@equal(@chosen 1) @append(2))@else(@append(3))\"\n\n\n@26\n represents a line break; their use here indicates that a new line should\nbe started before each option and after the user picks an option. This menu\nwill look like this:\n\n\nPick one!\n> Option A\n  Option B\n\n\n\n\n\nIt will be followed by message 2 if the option A is selected or message 3 if\noption B is selected.\n\n\nUsing ZScript functions, a menu can be created with cursor stops at arbitrary\nlocations on the screen. Creating a menu this way takes four or five steps:\n\n\n\n\nInitialize menu data (\nTango_InitializeMenu()\n)\n\n\nAdd choices (\nTango_AddChoice()\n)\n\n\nSet the cursor's appearance (\nTango_SetMenuCursor()\n)\n\n\n(optional) Set the menu sound effects (\nTango_SetMenuSFX()\n)\n\n\nActivate the menu (\nTango_ActivateMenu()\n)\n\n\n\n\n\n\nNote\n\n\nTango only draws and moves the cursor. If you wish to display any other\ngraphics, you'll have to draw them yourself. You may wish to do this\nin a \nwhile(Tango_MenuIsActive())\n loop.\n\n\n\n\nExtending Tango code\n\n\nIt's possible to create your own variables and functions to use in Tango code.\n\n\nThe name of the new function or variable must be a series of lower-case\nletters and numbers, and the first character must be a letter. There's no\nset limit on length, but the name must convert to a number small enough\nto be represented in ZScript (no greater than 214747.9999).\n\n\nThe name of the function or variable needs to be converted to a number.\n\nTango_ConvertFunctionName()\n and \nTango_ConvertVariableName()\n will do this\nfor you; they'll even write the result to allegro.log in a form suitable\nto copy and paste directly into a script. The conversion process is described\n\nhere\n.\n\n\nUser-defined functions can be numeric, effect, or condition functions.\nTo make Tango handle a function, add the implementation to\n\n__Tango_RunCustomFunction()\n. The \nfunction\n argument is the function ID.\n\nargs\n is an array containing the arguments. A function can take up to four\narguments; any unused arguments will be 0. For debugging purposes, you may\nwant to call \nTango_LogUndefinedFunction()\n if the function is not recognized.\n\n\nA simple example:\n\n\nconst\n \nfloat\n \nFUNC_DOSTUFF2\n \n=\n \n543.3828\n;\n \n// @dostuff2()\n\n\n\nfloat\n \n__Tango_RunCustomFunction\n(\nfloat\n \nfunction\n,\n \nfloat\n \nargs\n)\n\n\n{\n\n    \nif\n(\nfunction\n==\nFUNC_DOSTUFF2\n)\n\n    \n{\n\n        \n// This will just return the sum of the arguments.\n\n        \nreturn\n \nargs\n[\n0\n]\n+\nargs\n[\n1\n];\n\n    \n}\n\n    \nelse\n\n    \n{\n\n        \n// Unknown function\n\n        \nTango_LogUndefinedFunction\n(\nfunction\n);\n\n    \n}\n\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nTo implement a variable, use \nTango_GetCustomVar()\n and \nTango_SetCustomVar()\n.\nThe \nvar\n argument is the variable id.\n\n\nA trivial example of a custom variable:\n\n\nint\n \nmyVar\n;\n\n\nconst\n \nfloat\n \nVAR_MYVAR\n \n=\n \n4.0891\n;\n \n// @myvar\n\n\n\nfloat\n \nTango_GetCustomVar\n(\nfloat\n \nvar\n)\n\n\n{\n\n    \nif\n(\nvar\n==\nVAR_MYVAR\n)\n\n        \nreturn\n \nmyVar\n;\n\n    \nelse\n \n// Unknown\n\n    \n{\n\n        \nTango_LogInvalidVariable\n(\nvar\n);\n\n        \nreturn\n \n0\n;\n\n    \n}\n\n\n}\n\n\n\nvoid\n \nTango_SetCustomVar\n(\nfloat\n \nvar\n,\n \nfloat\n \nvalue\n)\n\n\n{\n\n    \nif\n(\nvar\n==\nVAR_MYVAR\n)\n\n        \nmyVar\n=\nvalue\n;\n\n    \nelse\n \n// Unknown\n\n        \nTango_LogInvalidVariable\n(\nvar\n);\n\n\n}\n\n\n\n\n\n\nNote that it's possible, although very unlikely, for two function or variable\nnames to convert to the same number. In that case, you'll just have to rename\none of them. It's okay for a variable and a function to have the same name.\n\n\nString control codes\n\n\nString control codes are supported only in ZC messages, not ZScript strings.\nThey're enabled by default, but they can be disabled if you don't need them.\nTo disable them, import stringControlCodeDisabled.zh instead of\nstringControlCode.zh.\n\n\nControl codes can be used alongside Tango code, but they cannot be combined.\nSomething like \n\\20\\@rand(61, 63)\n or \n@if(@a0 \\16\\6)\n will not work.\n\n\nNote that codes 16 and 17 (add or remove item) don't work quite the same\nas they normally do. The item is simply added to or removed from the inventory;\nno changes are made to any counters.",
            "title": "Usage"
        },
        {
            "location": "/usage/index.html#usage",
            "text": "",
            "title": "Usage"
        },
        {
            "location": "/usage/index.html#basic-usage",
            "text": "There are three functions, listed listed  here ,\nthat need to be added to the active global script, or you can use the provided TangoActiveScript .  Displaying a string involves working with two data structures: styles and\ntext slots. Styles determines how strings look and behave. Text slots are\nwhere the text and processing state are stored. To display a string, you must\nset up a style, load the text into a text slot, apply the style to the slot,\nand then activate it.  All it takes to set up a style is a call to  Tango_SetStyleAttribute()  for\neach attribute you want to set. Most attributes are optional, but you must\nat least set a font and text color. The regular  FONT  constants from std.zh\ncan't be used; you'll need to import one of the font definitions in the tango/font  folder and use the  TANGO_FONT  constant defined there.  Once a style is set up, displaying text requires six steps:   Find a free text slot ( Tango_GetFreeSlot() )  Clear any data already in the slot ( Tango_ClearSlot() )  Load text into the slot ( Tango_LoadString()  or  Tango_LoadMessage() )  Set a style ( Tango_SetSlotStyle() )  Set the position ( Tango_SetSlotPosition() )  Activate the text slot ( Tango_ActivateSlot() )   If you want to try it out without learning all the details, or if you'd\njust like a simple, straightforward example, check out tangoQuickStart.zh.\nIt provides a few simple functions and a minimal global script. There are\na few constants to set for colors, combos, and sounds; the defaults are\nset up for the classic tileset.  For more information on text slots and styles, see the page on  data structures\nand formats .",
            "title": "Basic usage"
        },
        {
            "location": "/usage/index.html#tango-code",
            "text": "Tango implements a simple scripting language with functions embedded\nin strings. Code is identified by the character  @  (by default;\nset  __TANGO_CODE_DELIMITER  to change this).  @  is followed immediately by a function name, then up to two arguments\nin parentheses, separated by spaces. Parentheses are needed even if\na function takes no arguments. For example, the string \"@playsfx(64)Hello, @savename()!\"  would play sound 64 and print (possibly) \"Hello, Link!\" .  Variables are also available. These can be used to set the properties of\nthe text. For instance,  @speed  controls how quickly the text is drawn.\nEach slot has two variables,  @a0  and  @a1 , used to store arbitrary data or\ncommunicate with ZScript. You can also create your own variables for\nthe same purposes.  It's also possible to use  @##  or  @(##)  to insert a character directly into\nthe text. The string  \"@90@69@76@68@65\"  is equivalent to  \"ZELDA\"  This is\nuseful for inserting line breaks ( @26 ) and font characters beyond the\nASCII range. Also,  @0  can be used to terminate the text early; anything after @0  won't be printed.  Finally, it's possible to highlight text using double brackets. For example,\nin the string  You got the ((Wooden Sword))! , the text \"Wooden Sword\" would\nbe printed in a different color than the rest of the text.  (( )) ,  [[ ]] , << >> , and  {{ }}  each have style settings allowing them to produce\ndifferent colors. This feature can be disabled by setting __TANGO_ENABLE_BRACKET_HIGHLIGHT  to 0.",
            "title": "Tango code"
        },
        {
            "location": "/usage/index.html#menus",
            "text": "Tango code can be used to set up simple menus in strings using a few simple\nfunction calls. It's also necessary to set the  TANGO_STYLE_MENU_CURSOR \nstyle attributes so the cursor will be drawn correctly.  To create a menu, add a call to  @choice()  for each choice followed by the\ncorresponding text. Each call to  @choice()  needs an argument - a number that\nwill be the value of that choice. The choices should be followed by a call to @domenu() , which will run until the user makes a selection or cancels.\nAfterward, the value of the selected choice will be stored in  @chosen , or 0\nif the user cancelled.  For example: \"Pick one!@26@choice(1)Option A@26@choice(2)Option B@domenu()@26@if(@equal(@chosen 1) @append(2))@else(@append(3))\"  @26  represents a line break; their use here indicates that a new line should\nbe started before each option and after the user picks an option. This menu\nwill look like this:  Pick one!\n> Option A\n  Option B  It will be followed by message 2 if the option A is selected or message 3 if\noption B is selected.  Using ZScript functions, a menu can be created with cursor stops at arbitrary\nlocations on the screen. Creating a menu this way takes four or five steps:   Initialize menu data ( Tango_InitializeMenu() )  Add choices ( Tango_AddChoice() )  Set the cursor's appearance ( Tango_SetMenuCursor() )  (optional) Set the menu sound effects ( Tango_SetMenuSFX() )  Activate the menu ( Tango_ActivateMenu() )    Note  Tango only draws and moves the cursor. If you wish to display any other\ngraphics, you'll have to draw them yourself. You may wish to do this\nin a  while(Tango_MenuIsActive())  loop.",
            "title": "Menus"
        },
        {
            "location": "/usage/index.html#extending-tango-code",
            "text": "It's possible to create your own variables and functions to use in Tango code.  The name of the new function or variable must be a series of lower-case\nletters and numbers, and the first character must be a letter. There's no\nset limit on length, but the name must convert to a number small enough\nto be represented in ZScript (no greater than 214747.9999).  The name of the function or variable needs to be converted to a number. Tango_ConvertFunctionName()  and  Tango_ConvertVariableName()  will do this\nfor you; they'll even write the result to allegro.log in a form suitable\nto copy and paste directly into a script. The conversion process is described here .  User-defined functions can be numeric, effect, or condition functions.\nTo make Tango handle a function, add the implementation to __Tango_RunCustomFunction() . The  function  argument is the function ID. args  is an array containing the arguments. A function can take up to four\narguments; any unused arguments will be 0. For debugging purposes, you may\nwant to call  Tango_LogUndefinedFunction()  if the function is not recognized.  A simple example:  const   float   FUNC_DOSTUFF2   =   543.3828 ;   // @dostuff2()  float   __Tango_RunCustomFunction ( float   function ,   float   args )  { \n     if ( function == FUNC_DOSTUFF2 ) \n     { \n         // This will just return the sum of the arguments. \n         return   args [ 0 ] + args [ 1 ]; \n     } \n     else \n     { \n         // Unknown function \n         Tango_LogUndefinedFunction ( function ); \n     } \n\n     return   0 ;  }   To implement a variable, use  Tango_GetCustomVar()  and  Tango_SetCustomVar() .\nThe  var  argument is the variable id.  A trivial example of a custom variable:  int   myVar ;  const   float   VAR_MYVAR   =   4.0891 ;   // @myvar  float   Tango_GetCustomVar ( float   var )  { \n     if ( var == VAR_MYVAR ) \n         return   myVar ; \n     else   // Unknown \n     { \n         Tango_LogInvalidVariable ( var ); \n         return   0 ; \n     }  }  void   Tango_SetCustomVar ( float   var ,   float   value )  { \n     if ( var == VAR_MYVAR ) \n         myVar = value ; \n     else   // Unknown \n         Tango_LogInvalidVariable ( var );  }   Note that it's possible, although very unlikely, for two function or variable\nnames to convert to the same number. In that case, you'll just have to rename\none of them. It's okay for a variable and a function to have the same name.",
            "title": "Extending Tango code"
        },
        {
            "location": "/usage/index.html#string-control-codes",
            "text": "String control codes are supported only in ZC messages, not ZScript strings.\nThey're enabled by default, but they can be disabled if you don't need them.\nTo disable them, import stringControlCodeDisabled.zh instead of\nstringControlCode.zh.  Control codes can be used alongside Tango code, but they cannot be combined.\nSomething like  \\20\\@rand(61, 63)  or  @if(@a0 \\16\\6)  will not work.  Note that codes 16 and 17 (add or remove item) don't work quite the same\nas they normally do. The item is simply added to or removed from the inventory;\nno changes are made to any counters.",
            "title": "String control codes"
        },
        {
            "location": "/zscriptFuncs/index.html",
            "text": "ZScript functions\n\n\nGlobal script\n\n\n\n\nvoid Tango_Start()\n\n\n\n\nClears the menu and all text slots.\n\n\nCall this in the active global script before the main loop.\n\n\n\n\nvoid Tango_Update1()\n\n\n\n\nProcesses each text slot and the menu.\n\n\nAfter calling this function, the render target will be set to \nRT_SCREEN\n.\n\n\nCall this in the active global script's main loop before \nWaitdraw()\n.\nIt is recommended that it be called before any other functions so that\nthe \nTANGO_FLAG_BLOCK_INPUT\n can be handled as soon as possible.\n\n\n\n\nvoid Tango_Update2()\n\n\n\n\nDraws all active text slots to the screen.\n\n\nAfter calling this function, the render target will be set to \nRT_SCREEN\n.\n\n\nCall this in the active global script's main loop after \nWaitdraw()\n.\nThis should generally come after everything else that does any drawing,\nsince you probably want text boxes drawn on top of everything else.\n\n\n\n\nbool Tango_ValidateConfiguration()\n\n\n\n\nThis function will check the arrays and text slot definitions for errors\nand print a report to allegro.log. It can't catch all possible errors,\nbut it should get the most common ones. Returns true if no errors were found.\n\n\nNote that not all potential problems are necessarily invalid; some, such as\noverlapping text slots, may be okay. These will be logged, but not\nconsidered errors.\n\n\nThis function should not be used in published quests. It only exists to\nhelp you configure tango.zh correctly.\n\n\n\n\n\n\nText slot management\n\n\n\n\nint Tango_GetFreeSlot()\n\n\nint Tango_GetFreeSlot(int slotType)\n\n\nGet the number of a slot not currently in use. You can specify a slot type;\nif you don't care, pass in \nTANGO_SLOT_ANY\n or leave out the argument.\n\n\nvoid Tango_ClearSlot(int slot)\n\n\nClear all data for the given slot. If the slot is active, it will be\ndeactivated.\n\n\nbool Tango_ReserveSlot(int slot)\n\n\n\n\nMark a slot as reserved, preventing \nTango_GetFreeSlot()\n from returning it.\nUse this if you get a free slot and don't plan to use it immediately.\nReturns true if the reservation succeeded (i.e. the slot wasn't already\nreserved or active).\n\n\nThe reserved state will be cleared if \nTango_ClearSlot()\n is called or Link\nmoves to a new screen.\n\n\n\n\nvoid Tango_LoadString(int slot, int string[])\n\n\nLoads a ZScript string (\nint[]\n) into the given slot.\n\n\nvoid Tango_LoadMessage(int slot, int messageID)\n\n\nLoads a ZC message (\nQuest->Strings\n) into the given slot.\n\n\nvoid Tango_AppendString(int slot, int string[])\n\n\nvoid Tango_AppendMessage(int slot, int messageID)\n\n\nLoads a string or message into the given slot, appending it to the end of\nwhatever text is already there.\n\n\nvoid Tango_LoadString(int slot, int string[], int startChar)\n\n\nvoid Tango_LoadMessage(int slot, int messageID, int startChar)\n\n\nvoid Tango_AppendString(int slot, int string[], int startChar)\n\n\nvoid Tango_AppendMessage(int slot, int messageID, int startChar)\n\n\n\n\nLike the above, but specifies a starting point in the string to load.\n\n\nLoading will start from the first character after \nstartChar\n. For instance:\n\n\nint str[]=\"abcd%efg\";\nTango_LoadString(0, str, '%');\n\n\n\n\n\nwill load \"efg\" into slot 0.\n\n\nIf the character specified is not in the string, the entire string\nwill be loaded. The string must contain the actual character, not\na character code (@##).\n\n\n\n\nvoid Tango_SetSlotStyle(int slot, int style)\n\n\nint Tango_GetSlotStyle(int slot)\n\n\nSet or get the style used by the given slot.\n\n\nvoid Tango_SetSlotPosition(int slot, int x, int y)\n\n\nint Tango_GetSlotX(int slot)\n\n\nint Tango_GetSlotY(int slot)\n\n\nSet or get the position where the text slot will be shown on the screen.\n\n\nvoid Tango_ActivateSlot(int slot)\n\n\nDisplay the current slot on the screen. Do this only after setting\nthe slot's text, style, and position. The render target will be set to\n\nRT_SCREEN\n after calling this function.\n\n\nbool Tango_SlotIsActive(int slot)\n\n\nReturns true if the slot is currently being displayed on the screen.\nA suspended slot is still considered active.\n\n\nbool Tango_AnySlotIsActive()\n\n\nReturns true if any slot is currently being displayed.\n\n\nbool Tango_SlotIsFinished(int slot)\n\n\nReturns true if the given slot is finished printing and is still\nbeing displayed.\n\n\n\n\nStyle setup\n\n\n\n\nvoid Tango_ClearStyle(int style)\n\n\nClear all data for the given style.\n\n\nvoid Tango_SetStyleAttribute(int style, int attribute, int value)\n\n\nint Tango_GetStyleAttribute(int style, int attribute)\n\n\n\n\nSet or get an attribute of the given style. See \nthe style attributes\nsection\n for the available attributes\nand expected values.\n\n\n\n\nWarning\n\n\nModifying a style in use by an active text slot\nis not guaranteed to work correctly.\n\n\n\n\n\n\nint Tango_GetSlotStyleAttribute(int slot, int attribute)\n\n\nGet the value of an attribute from whatever style the given text slot\nis using.\n\n\nint Tango_GetStringWidth(int str[], int font)\n\n\nReturns the width of the given string when printed in the given font.\nTango code will not be evaluated and line breaks will be ignored.\nThis should be used for centering text when using \nTANGO_DRAW_TEXT\n\nin a complex backdrop.\n\n\n\n\nMenu\n\n\n\n\nvoid Tango_InitializeMenu()\n\n\nClear all menu data and deactivate the menu if one is active.\n\n\nvoid Tango_AddMenuChoice(int value, int x, int y)\n\n\nAdd a menu choice with the given value at the specified position.\nThe value should be greater than 0.\n\n\nvoid Tango_MoveMenuChoice(int choice, int x, int y)\n\n\nReposition a menu choice on the screen.\n\n\nvoid Tango_SetMenuCursor(int combo, int cset)\n\n\nvoid Tango_SetMenuCursor(int combo, int cset, int width, int height)\n\n\nSet the appearance of the menu cursor. If width and height are not\nspecified, they will default to 1.\n\n\nvoid Tango_SetMenuSFX(int moveSound, int selectSound, int cancelSound)\n\n\nSet the sounds to be used by the menu.\n\n\nvoid Tango_SetMenuFlags(int flags)\n\n\nSet flags for the menu. The value is 0 or one or more menu flags\nORed together. See \nthe menu flags section\n for\navailable flags.\n\n\nvoid Tango_ActivateMenu()\n\n\nActivate a menu set up using the above functions.\n\n\nvoid Tango_DeactivateMenu()\n\n\nDeactivate the active menu. This is typically only needed for\npersistent menus.\n\n\nint Tango_GetLastMenuChoice()\n\n\n\n\nReturns the value of the last selection made in a menu. Returns 0 if\na non-persistent menu is currently active, no menu has been shown yet,\nor the user cancelled in the last menu.\n\n\nIf the menu is persistent, this function will only return each selection\nfor a single frame before returning to 0.\n\n\n\n\nint Tango_GetCurrentMenuChoice()\n\n\nReturns the value if the currently selected choice in the menu.\nReturns 0 if no menu is active or the current cursor position is invalid.\n\n\nbool Tango_MenuIsActive()\n\n\n\n\nReturns true if a menu is currently active.\n\n\n\n\nCaution\n\n\nIf you display a string that creates a menu, the menu will not\nbe active until at least the next call to \nTango_Update1()\n, even if\n\nTANGO_FLAG_INSTANTANEOUS\n is used.\n\n\nThis is not the case for menus created by scripts. The menu will be\nactive as soon as \nTango_ActivateMenu()\n is called.\n\n\n\n\n\n\nvoid Tango_SaveMenuState(int state[])\n\n\n\n\nStore the current state of the menu into output. This will store the\nvalues and positions of the options, the cursor and sound settings, and\nthe currently selected option.\n\n\nThe size of output must be at least \n20 + 3 * __TANGO_MAX_MENU_ITEMS\n.\nLater versions of tango.zh are likely to use more data; you may\nwant to use a larger array for future-proofing.\n\n\n\n\nvoid Tango_SetMenuAutosaveDest(int state[])\n\n\n\n\nSets an array in which the menu state will automatically be saved\nwhen a selection is made or the player cancels. The state will not\nbe saved if the menu is closed for another reason. After setting\nthe autosave array, you can call this again with an argument of \nNULL\n\nto clear it.\n\n\n\n\nNote\n\n\nThe data to be saved includes the autosave destination, so restoring\nthe menu state with this array will set it up to autosave again.\n\n\n\n\n\n\nvoid Tango_RestoreMenuState(int oldState[])\n\n\nRestore the state saved with \nTango_SaveMenuState()\n.\n\n\nint Tango_GetMenuCursorPosition()\n\n\nReturns the current position of the menu cursor. Choices are numbered\nfrom 0. Setting the cursor position to an invalid number is allowed,\nso the position is not guaranteed to be valid.\n\n\nvoid Tango_SetMenuCursorPosition(int pos)\n\n\nSets the cursor position to pos. If pos is invalid, no item will be\nselected, and the cursor will be hidden.\n\n\n\n\nOther\n\n\n\n\nvoid Tango_Sync(int value)\n\n\nUsed to synchronize a script and a text slot. See \n@sync()\n for details.\n\n\nvoid Tango_SetSlotVar(int slot, int what, float value)\n\n\nfloat Tango_GetSlotVar(int slot, int what)\n\n\nUse these to set and get a text slot's \n@a0\n and \n@a1\n. Use either\n\nTANGO_VAR_A0\n or \nTANGO_VAR_A1\n as the \nwhat\n argument.\n\n\nvoid Tango_SuspendSlot(int slot)\n\n\nSuspends processing of an active text slot. The slot will remain visible,\nbut it will not advance.\n\n\nvoid Tango_ResumeSlot(int slot)\n\n\nResumes processing of a suspended text slot.\n\n\nfloat Tango_GetSlotScrollPos(int slot)\n\n\nfloat Tango_GetSlotMaxScrollPos(int slot)\n\n\nIf the text is too long to be displayed all at once, it will scroll down.\nThese functions get the current and maximum scroll positions. The minimum\nposition is always 0, and the maximum is 0 or greater. The scroll amount\nis given in pixels.\n\n\nvoid Tango_ScrollSlot(int slot, float amount)\n\n\nScrolls the text slot up or down. As above, the amount is in pixels.\nPoitive numbers scroll down, and negative numbers scroll up. The slot\nwill not scroll beyond the beginning or end of the text.\n\n\nint Tango_GetCurrentSlot()\n\n\nReturns the ID of the slot currently being processed. This should only\nbe used in \n__Tango_RunCustomFunction()\n, \nTango_GetCustomVar()\n, and \n\nTango_SetCustomVar()\n. At any other time, the value is meaningless.\n\n\nvoid Tango_SaveSlotState(int slot, int output[], int bitmap)\n\n\nvoid Tango_SaveSlotState(int slot, int output[])\n\n\n\n\nStore the state of a text slot into aoutputa. The current text, style,\nposition, state, and variables will be saved. The style's data\nwill not be saved.\n\n\nIf \nbitmap\n is specified, the text already rendered will be copied to \nthat bitmap, and the render target will be set to \nRT_SCREEN\n afterward.\n\n\nThe size of \noutput\n must be at least the slot's length in the buffer + 21.\nLater versions of tango.zh are likely to use more data; you may\nwant to use a larger array for future-proofing.\n\n\n\n\nvoid Tango_RestoreSlotState(int slot, int oldState[], int bitmap)\n\n\nvoid Tango_RestoreSlotState(int slot, int oldState[])\n\n\n\n\nRestore the state of a slot saved with \nTango_SaveSlotState()\n. The slot\nnumber should be the same, as it will be assumed that the position\non the bitmap is the same.\n\n\nIf a bitmap is specified, the render target will be set to \nRT_SCREEN\n\nafterward.\n\n\n\n\nfloat Tango_ConvertFunctionName(int name[])\n\n\nfloat Tango_ConvertVariableName(int name[])\n\n\n\n\nReturns the converted value of the given name and prints a constant\ndefinition to allegro.log. Do not include \n@\n in the name.\n\n\nint name[] = \"dostuff2\";\nfloat value = Tango_ConvertFunctionName(name);\n\n\n\n\n\nvalue\n will be equal to 543.3828, and allegro.log will contain\n\nconst float FUNC_DOSTUFF2 = 543.3828;\n.\n\n\n\n\nvoid Tango_LogUndefinedFunction(float function)\n\n\nThis will log an error indicating the use of an unknown function.\nThis is meant to be called from \n__Tango_RunCustomFunction()\n if\nthe function is not recognized. It's only useful for debugging,\nso it can be considered optional.\n\n\nvoid Tango_LogUndefinedVariable(float var)\n\n\nThis will log an error indicating the use of an unknown variable.\nIt's meant to be called from \nTango_GetCustomVar()\n and \nTango_SetCustomVar()\n\nand is useful only for debugging.",
            "title": "ZScript functions"
        },
        {
            "location": "/zscriptFuncs/index.html#zscript-functions",
            "text": "",
            "title": "ZScript functions"
        },
        {
            "location": "/zscriptFuncs/index.html#global-script",
            "text": "void Tango_Start()   Clears the menu and all text slots.  Call this in the active global script before the main loop.   void Tango_Update1()   Processes each text slot and the menu.  After calling this function, the render target will be set to  RT_SCREEN .  Call this in the active global script's main loop before  Waitdraw() .\nIt is recommended that it be called before any other functions so that\nthe  TANGO_FLAG_BLOCK_INPUT  can be handled as soon as possible.   void Tango_Update2()   Draws all active text slots to the screen.  After calling this function, the render target will be set to  RT_SCREEN .  Call this in the active global script's main loop after  Waitdraw() .\nThis should generally come after everything else that does any drawing,\nsince you probably want text boxes drawn on top of everything else.   bool Tango_ValidateConfiguration()   This function will check the arrays and text slot definitions for errors\nand print a report to allegro.log. It can't catch all possible errors,\nbut it should get the most common ones. Returns true if no errors were found.  Note that not all potential problems are necessarily invalid; some, such as\noverlapping text slots, may be okay. These will be logged, but not\nconsidered errors.  This function should not be used in published quests. It only exists to\nhelp you configure tango.zh correctly.",
            "title": "Global script"
        },
        {
            "location": "/zscriptFuncs/index.html#text-slot-management",
            "text": "int Tango_GetFreeSlot()  int Tango_GetFreeSlot(int slotType)  Get the number of a slot not currently in use. You can specify a slot type;\nif you don't care, pass in  TANGO_SLOT_ANY  or leave out the argument.  void Tango_ClearSlot(int slot)  Clear all data for the given slot. If the slot is active, it will be\ndeactivated.  bool Tango_ReserveSlot(int slot)   Mark a slot as reserved, preventing  Tango_GetFreeSlot()  from returning it.\nUse this if you get a free slot and don't plan to use it immediately.\nReturns true if the reservation succeeded (i.e. the slot wasn't already\nreserved or active).  The reserved state will be cleared if  Tango_ClearSlot()  is called or Link\nmoves to a new screen.   void Tango_LoadString(int slot, int string[])  Loads a ZScript string ( int[] ) into the given slot.  void Tango_LoadMessage(int slot, int messageID)  Loads a ZC message ( Quest->Strings ) into the given slot.  void Tango_AppendString(int slot, int string[])  void Tango_AppendMessage(int slot, int messageID)  Loads a string or message into the given slot, appending it to the end of\nwhatever text is already there.  void Tango_LoadString(int slot, int string[], int startChar)  void Tango_LoadMessage(int slot, int messageID, int startChar)  void Tango_AppendString(int slot, int string[], int startChar)  void Tango_AppendMessage(int slot, int messageID, int startChar)   Like the above, but specifies a starting point in the string to load.  Loading will start from the first character after  startChar . For instance:  int str[]=\"abcd%efg\";\nTango_LoadString(0, str, '%');  will load \"efg\" into slot 0.  If the character specified is not in the string, the entire string\nwill be loaded. The string must contain the actual character, not\na character code (@##).   void Tango_SetSlotStyle(int slot, int style)  int Tango_GetSlotStyle(int slot)  Set or get the style used by the given slot.  void Tango_SetSlotPosition(int slot, int x, int y)  int Tango_GetSlotX(int slot)  int Tango_GetSlotY(int slot)  Set or get the position where the text slot will be shown on the screen.  void Tango_ActivateSlot(int slot)  Display the current slot on the screen. Do this only after setting\nthe slot's text, style, and position. The render target will be set to RT_SCREEN  after calling this function.  bool Tango_SlotIsActive(int slot)  Returns true if the slot is currently being displayed on the screen.\nA suspended slot is still considered active.  bool Tango_AnySlotIsActive()  Returns true if any slot is currently being displayed.  bool Tango_SlotIsFinished(int slot)  Returns true if the given slot is finished printing and is still\nbeing displayed.",
            "title": "Text slot management"
        },
        {
            "location": "/zscriptFuncs/index.html#style-setup",
            "text": "void Tango_ClearStyle(int style)  Clear all data for the given style.  void Tango_SetStyleAttribute(int style, int attribute, int value)  int Tango_GetStyleAttribute(int style, int attribute)   Set or get an attribute of the given style. See  the style attributes\nsection  for the available attributes\nand expected values.   Warning  Modifying a style in use by an active text slot\nis not guaranteed to work correctly.    int Tango_GetSlotStyleAttribute(int slot, int attribute)  Get the value of an attribute from whatever style the given text slot\nis using.  int Tango_GetStringWidth(int str[], int font)  Returns the width of the given string when printed in the given font.\nTango code will not be evaluated and line breaks will be ignored.\nThis should be used for centering text when using  TANGO_DRAW_TEXT \nin a complex backdrop.",
            "title": "Style setup"
        },
        {
            "location": "/zscriptFuncs/index.html#menu",
            "text": "void Tango_InitializeMenu()  Clear all menu data and deactivate the menu if one is active.  void Tango_AddMenuChoice(int value, int x, int y)  Add a menu choice with the given value at the specified position.\nThe value should be greater than 0.  void Tango_MoveMenuChoice(int choice, int x, int y)  Reposition a menu choice on the screen.  void Tango_SetMenuCursor(int combo, int cset)  void Tango_SetMenuCursor(int combo, int cset, int width, int height)  Set the appearance of the menu cursor. If width and height are not\nspecified, they will default to 1.  void Tango_SetMenuSFX(int moveSound, int selectSound, int cancelSound)  Set the sounds to be used by the menu.  void Tango_SetMenuFlags(int flags)  Set flags for the menu. The value is 0 or one or more menu flags\nORed together. See  the menu flags section  for\navailable flags.  void Tango_ActivateMenu()  Activate a menu set up using the above functions.  void Tango_DeactivateMenu()  Deactivate the active menu. This is typically only needed for\npersistent menus.  int Tango_GetLastMenuChoice()   Returns the value of the last selection made in a menu. Returns 0 if\na non-persistent menu is currently active, no menu has been shown yet,\nor the user cancelled in the last menu.  If the menu is persistent, this function will only return each selection\nfor a single frame before returning to 0.   int Tango_GetCurrentMenuChoice()  Returns the value if the currently selected choice in the menu.\nReturns 0 if no menu is active or the current cursor position is invalid.  bool Tango_MenuIsActive()   Returns true if a menu is currently active.   Caution  If you display a string that creates a menu, the menu will not\nbe active until at least the next call to  Tango_Update1() , even if TANGO_FLAG_INSTANTANEOUS  is used.  This is not the case for menus created by scripts. The menu will be\nactive as soon as  Tango_ActivateMenu()  is called.    void Tango_SaveMenuState(int state[])   Store the current state of the menu into output. This will store the\nvalues and positions of the options, the cursor and sound settings, and\nthe currently selected option.  The size of output must be at least  20 + 3 * __TANGO_MAX_MENU_ITEMS .\nLater versions of tango.zh are likely to use more data; you may\nwant to use a larger array for future-proofing.   void Tango_SetMenuAutosaveDest(int state[])   Sets an array in which the menu state will automatically be saved\nwhen a selection is made or the player cancels. The state will not\nbe saved if the menu is closed for another reason. After setting\nthe autosave array, you can call this again with an argument of  NULL \nto clear it.   Note  The data to be saved includes the autosave destination, so restoring\nthe menu state with this array will set it up to autosave again.    void Tango_RestoreMenuState(int oldState[])  Restore the state saved with  Tango_SaveMenuState() .  int Tango_GetMenuCursorPosition()  Returns the current position of the menu cursor. Choices are numbered\nfrom 0. Setting the cursor position to an invalid number is allowed,\nso the position is not guaranteed to be valid.  void Tango_SetMenuCursorPosition(int pos)  Sets the cursor position to pos. If pos is invalid, no item will be\nselected, and the cursor will be hidden.",
            "title": "Menu"
        },
        {
            "location": "/zscriptFuncs/index.html#other",
            "text": "void Tango_Sync(int value)  Used to synchronize a script and a text slot. See  @sync()  for details.  void Tango_SetSlotVar(int slot, int what, float value)  float Tango_GetSlotVar(int slot, int what)  Use these to set and get a text slot's  @a0  and  @a1 . Use either TANGO_VAR_A0  or  TANGO_VAR_A1  as the  what  argument.  void Tango_SuspendSlot(int slot)  Suspends processing of an active text slot. The slot will remain visible,\nbut it will not advance.  void Tango_ResumeSlot(int slot)  Resumes processing of a suspended text slot.  float Tango_GetSlotScrollPos(int slot)  float Tango_GetSlotMaxScrollPos(int slot)  If the text is too long to be displayed all at once, it will scroll down.\nThese functions get the current and maximum scroll positions. The minimum\nposition is always 0, and the maximum is 0 or greater. The scroll amount\nis given in pixels.  void Tango_ScrollSlot(int slot, float amount)  Scrolls the text slot up or down. As above, the amount is in pixels.\nPoitive numbers scroll down, and negative numbers scroll up. The slot\nwill not scroll beyond the beginning or end of the text.  int Tango_GetCurrentSlot()  Returns the ID of the slot currently being processed. This should only\nbe used in  __Tango_RunCustomFunction() ,  Tango_GetCustomVar() , and  Tango_SetCustomVar() . At any other time, the value is meaningless.  void Tango_SaveSlotState(int slot, int output[], int bitmap)  void Tango_SaveSlotState(int slot, int output[])   Store the state of a text slot into aoutputa. The current text, style,\nposition, state, and variables will be saved. The style's data\nwill not be saved.  If  bitmap  is specified, the text already rendered will be copied to \nthat bitmap, and the render target will be set to  RT_SCREEN  afterward.  The size of  output  must be at least the slot's length in the buffer + 21.\nLater versions of tango.zh are likely to use more data; you may\nwant to use a larger array for future-proofing.   void Tango_RestoreSlotState(int slot, int oldState[], int bitmap)  void Tango_RestoreSlotState(int slot, int oldState[])   Restore the state of a slot saved with  Tango_SaveSlotState() . The slot\nnumber should be the same, as it will be assumed that the position\non the bitmap is the same.  If a bitmap is specified, the render target will be set to  RT_SCREEN \nafterward.   float Tango_ConvertFunctionName(int name[])  float Tango_ConvertVariableName(int name[])   Returns the converted value of the given name and prints a constant\ndefinition to allegro.log. Do not include  @  in the name.  int name[] = \"dostuff2\";\nfloat value = Tango_ConvertFunctionName(name);  value  will be equal to 543.3828, and allegro.log will contain const float FUNC_DOSTUFF2 = 543.3828; .   void Tango_LogUndefinedFunction(float function)  This will log an error indicating the use of an unknown function.\nThis is meant to be called from  __Tango_RunCustomFunction()  if\nthe function is not recognized. It's only useful for debugging,\nso it can be considered optional.  void Tango_LogUndefinedVariable(float var)  This will log an error indicating the use of an unknown variable.\nIt's meant to be called from  Tango_GetCustomVar()  and  Tango_SetCustomVar() \nand is useful only for debugging.",
            "title": "Other"
        },
        {
            "location": "/constants/index.html",
            "text": "ZScript constants\n\n\nStyle attributes\n\n\nThese are the attributes that can be set with \nTango_SetStyleAttribute()\n.\nAttributes associated with specific backdrop types are excluded here;\nthey're listed with the relevant \nTANGO_BACKDROP\n constants in the\n\nbackdrop types\n section.\n\n\n\n\nTANGO_STYLE_BACKDROP_TYPE\n\n\nThe type of backdrop to display behind the text; this should be\n\none of the \nTANGO_BACKDROP\n constants below\n. There are\nalso several more attributes associated with each backdrop type.\n\n\nTANGO_STYLE_TEXT_FONT\n\n\nThe default font used to render the text. This must be a Tango font\ndefinition, not a ZC font.\n\n\nTANGO_STYLE_TEXT_X\n\n\nTANGO_STYLE_TEXT_Y\n\n\nThe position of the text. These are offsets from the values set with\n\nTango_SetSlotPosition()\n.\n\n\nTANGO_STYLE_TEXT_WIDTH\n\n\nTANGO_STYLE_TEXT_HEIGHT\n\n\nThe size of the area in which text will be displayed.\n\n\nTANGO_STYLE_TEXT_CSET\n\n\nTANGO_STYLE_TEXT_COLOR\n\n\nThe default color of the text. \nTANGO_STYLE_TEXT_COLOR\n is used to select\ncolor 0-15 in the given CSet; this only applies to characters in\nbuilt-in fonts.\n\n\nTANGO_STYLE_TEXT_SPEED\n\n\nThe delay before each character is printed. A speed of 0 means there is\nno delay between characters; this is similar to \nTANGO_FLAG_INSTANTANEOUS\n,\nbut differs in that the speed can be changed mid-text. The flag requires\nless processing, so it should be preferred whenever possible.\n\n\nTANGO_STYLE_TEXT_SFX\n\n\nThe default sound played when printing a character.\n\n\nTANGO_STYLE_TEXT_END_SFX\n\n\nThe sound played when the end of the text is reached.\n\n\nTANGO_STYLE_MORE_COMBO\n\n\nTANGO_STYLE_MORE_CSET\n\n\nThe appearance of the \"more...\" icon.\n\n\nTANGO_STYLE_MORE_X\n\n\nTANGO_STYLE_MORE_Y\n\n\nThe position of the \"more...\" icon. These are offsets from the values\nset with \nTango_SetSlotPosition()\n.\n\n\nTANGO_STYLE_FLAGS\n\n\nFlags controlling various aspects of the text slot's appearance and\nbehavior. These are \nTANGO_FLAG\n constants\n, which can be\nORed together.\n\n\nTANGO_STYLE_ALT_CSET_1\n\n\nTANGO_STYLE_ALT_CSET_2\n\n\nTANGO_STYLE_ALT_CSET_3\n\n\nTANGO_STYLE_ALT_CSET_4\n\n\nTANGO_STYLE_ALT_COLOR_1\n\n\nTANGO_STYLE_ALT_COLOR_2\n\n\nTANGO_STYLE_ALT_COLOR_3\n\n\nTANGO_STYLE_ALT_COLOR_4\n\n\n\n\nSet highlight colors to use for double-bracketed text.\n\n\n1 is \n(( ))\n\n\n2 is \n[[ ]]\n\n\n3 is \n{{ }}\n\n\n4 is \n<< >>\n\n\n\n\nTANGO_STYLE_ALT_OFFSET_1\n\n\nTANGO_STYLE_ALT_OFFSET_2\n\n\nTANGO_STYLE_ALT_OFFSET_3\n\n\nTANGO_STYLE_ALT_OFFSET_4\n\n\nSimilar to the above, this sets a tile offset for double-bracketed text.\nThis adds a number to the base tile of custom and extended fonts; this is\napplied in addition to the color change. It's meant for 8-bit tiles,\nas those can't simply be recolored.\n\n\nTANGO_STYLE_MENU_CHOICE_INDENT\n\n\nHow much extra space to add before each menu choice to make room for\nthe cursor, in pixels.\n\n\nTANGO_STYLE_MENU_CURSOR_COMBO\n\n\nTANGO_STYLE_MENU_CURSOR_CSET\n\n\nTANGO_STYLE_MENU_CURSOR_WIDTH\n\n\nTANGO_STYLE_MENU_CURSOR_HEIGHT\n\n\nThe appearance of the menu cursor. Width and height are in tiles.\n\n\nTANGO_STYLE_MENU_CURSOR_MOVE_SFX\n\n\nTANGO_STYLE_MENU_SELECT_SFX\n\n\nTANGO_STYLE_MENU_CANCEL_SFX\n\n\nThe sounds to play in the menu.\n\n\nTANGO_STYLE_MENU_SCROLL_UP_COMBO\n\n\nTANGO_STYLE_MENU_SCROLL_UP_CSET\n\n\nTANGO_STYLE_MENU_SCROLL_UP_X\n\n\nTANGO_STYLE_MENU_SCROLL_UP_Y\n\n\nTANGO_STYLE_MENU_SCROLL_DOWN_COMBO\n\n\nTANGO_STYLE_MENU_SCROLL_DOWN_CSET\n\n\nTANGO_STYLE_MENU_SCROLL_DOWN_X\n\n\nTANGO_STYLE_MENU_SCROLL_DOWN_Y\n\n\nIf a menu is too large to fit in the text area, these combos will be drawn\nto indicate that it can scroll up or down.\n\n\n\n\nStyle flags\n\n\nConstants to be used with \nTANGO_STYLE\n flags. These can be combined\nwith bitwise OR.\n\n\n\n\nTANGO_FLAG_ENABLE_SPEEDUP\n\n\nThe text can be sped up by holding down A.\n\n\nTANGO_FLAG_ENABLE_SUPER_SPEED\n\n\nThe text can be printed instantly by pressing B.\n\n\nTANGO_FLAG_AUTO_ADVANCE\n\n\nThe player will not be prompted to press A when the text finishes;\nit will advance or disappear automatically.\n\n\nTANGO_FLAG_CARRY_OVER\n\n\nThe slot will not be deactivated when the screen changes.\n\n\nTANGO_FLAG_BLOCK_INPUT\n\n\n\n\nWhile the slot is active, all keys will be unpressed.\n\n\n\n\nCaution\n\n\nUnpressing keys is handled by \nTango_Update1()\n. FFC scripts and\nanything earlier in the global script will see the unmodified input.\n\n\n\n\n\n\nTANGO_FLAG_LINE_BY_LINE\n\n\nText is printed one line at a time instead of one character at a time.\n\n\nTANGO_FLAG_INSTANTANEOUS\n\n\nThe text is printed all at once, regardless of the nominal speed.\n\n@while()\n still runs only once per frame and holds up further processing\nuntil its condition is false. \n@delay()\n and \n@waituntil()\n still work.\n\n\nTANGO_FLAG_PERSISTENT\n\n\nWhen the text is finished printing, the player is not prompted\nto press A and the text does not disappear.\n\n\nTANGO_FLAG_CENTERED\n\n\nText is centered in the printable area.\n\n\nTANGO_FLAG_FREEZE_SCREEN\n\n\n\n\nThe game is frozen while the slot is active.\n\n\n\n\nNote\n\n\nIn order for this flag to work, you must implement the functions\n\n__Tango_FreezeScreen()\n and \n__Tango_UnfreezeScreen()\n.\n\n\n\n\n\n\n\n\nBackdrop types\n\n\nThese are the different backdrop types used with \nTANGO_STYLE_BACKDROP_TYPE\n\nand related attributes used to configure them.\n\n\n\n\nTANGO_BACKDROP_CLEAR\n\n\nNo backdrop.\n\n\nTANGO_BACKDROP_COLOR\n\n\nTANGO_BACKDROP_COLOR_TRANS\n\n\n\n\nA rectangle of a single color, either opaque or transparent.\n\n\nRelated attributes:\n\n\n\n\nTANGO_STYLE_TEXT_CSET\n\n\nTANGO_STYLE_TEXT_COLOR\n\n\nThe rectangle's CSet and color. The color is 0-15 within the CSet.\n\n\nTANGO_STYLE_BACKDROP_WIDTH\n\n\nTANGO_STYLE_BACKDROP_HEIGHT\n\n\nThe size of the rectangle in pixels.\n\n\n\n\n\n\nTANGO_BACKDROP_TILE\n\n\nTANGO_BACKDROP_TILE_TRANS\n\n\n\n\nA block of tiles, either opaque or transparent.\n\n\nRelated attributes:\n\n\n\n\nTANGO_STYLE_BACKDROP_TILE\n\n\nThe top-left tile of the block.\n\n\nTANGO_STYLE_BACKDROP_CSET\n\n\nThe CSet of the backdrop.\n\n\nTANGO_STYLE_BACKDROP_WIDTH\n\n\nTANGO_STYLE_BACKDROP_HEIGHT\n\n\nThe size of the backdrop in tiles.\n\n\n\n\n\n\nTANGO_BACKDROP_COMBO\n\n\nTANGO_BACKDROP_COMBO_TRANS\n\n\n\n\nA block of tiles drawn from a combo, either opaque or transparent.\n\n\nRelated attributes:\n\n\n\n\nTANGO_STYLE_BACKDROP_COMBO\n\n\nThe combo using the top-left tile of the block.\n\n\nTANGO_STYLE_BACKDROP_CSET\n\n\nThe CSet of the backdrop.\n\n\nTANGO_STYLE_BACKDROP_WIDTH\n\n\nTANGO_STYLE_BACKDROP_HEIGHT\n\n\nThe size of the backdrop in tiles.\n\n\n\n\n\n\nTANGO_BACKDROP_COMPLEX\n\n\n\n\nA backdrop made up of multiple drawing commands.\n\n\nRelated attributes:\n\n\n\n\nTANGO_STYLE_BACKDROP_DATA\n\n\nThe array of data from which to draw the backdrop. For details, see\n\nthe complex backdrops section\n.\n\n\n\n\n\n\n\n\nMenu flags\n\n\nThese should be used as arguments to \nTango_SetMenuFlags()\n.\n\n\n\n\nTANGO_MENU_CAN_CANCEL\n\n\nThe user can cancel out of the menu instead of making a selection.\n\n\nTANGO_MENU_PERSISTENT\n\n\nThe menu is persistent, meaning it will not close when a selection is made.\nIt will still close if the user cancels.",
            "title": "ZScript constants"
        },
        {
            "location": "/constants/index.html#zscript-constants",
            "text": "",
            "title": "ZScript constants"
        },
        {
            "location": "/constants/index.html#style-attributes",
            "text": "These are the attributes that can be set with  Tango_SetStyleAttribute() .\nAttributes associated with specific backdrop types are excluded here;\nthey're listed with the relevant  TANGO_BACKDROP  constants in the backdrop types  section.   TANGO_STYLE_BACKDROP_TYPE  The type of backdrop to display behind the text; this should be one of the  TANGO_BACKDROP  constants below . There are\nalso several more attributes associated with each backdrop type.  TANGO_STYLE_TEXT_FONT  The default font used to render the text. This must be a Tango font\ndefinition, not a ZC font.  TANGO_STYLE_TEXT_X  TANGO_STYLE_TEXT_Y  The position of the text. These are offsets from the values set with Tango_SetSlotPosition() .  TANGO_STYLE_TEXT_WIDTH  TANGO_STYLE_TEXT_HEIGHT  The size of the area in which text will be displayed.  TANGO_STYLE_TEXT_CSET  TANGO_STYLE_TEXT_COLOR  The default color of the text.  TANGO_STYLE_TEXT_COLOR  is used to select\ncolor 0-15 in the given CSet; this only applies to characters in\nbuilt-in fonts.  TANGO_STYLE_TEXT_SPEED  The delay before each character is printed. A speed of 0 means there is\nno delay between characters; this is similar to  TANGO_FLAG_INSTANTANEOUS ,\nbut differs in that the speed can be changed mid-text. The flag requires\nless processing, so it should be preferred whenever possible.  TANGO_STYLE_TEXT_SFX  The default sound played when printing a character.  TANGO_STYLE_TEXT_END_SFX  The sound played when the end of the text is reached.  TANGO_STYLE_MORE_COMBO  TANGO_STYLE_MORE_CSET  The appearance of the \"more...\" icon.  TANGO_STYLE_MORE_X  TANGO_STYLE_MORE_Y  The position of the \"more...\" icon. These are offsets from the values\nset with  Tango_SetSlotPosition() .  TANGO_STYLE_FLAGS  Flags controlling various aspects of the text slot's appearance and\nbehavior. These are  TANGO_FLAG  constants , which can be\nORed together.  TANGO_STYLE_ALT_CSET_1  TANGO_STYLE_ALT_CSET_2  TANGO_STYLE_ALT_CSET_3  TANGO_STYLE_ALT_CSET_4  TANGO_STYLE_ALT_COLOR_1  TANGO_STYLE_ALT_COLOR_2  TANGO_STYLE_ALT_COLOR_3  TANGO_STYLE_ALT_COLOR_4   Set highlight colors to use for double-bracketed text.  1 is  (( ))  2 is  [[ ]]  3 is  {{ }}  4 is  << >>   TANGO_STYLE_ALT_OFFSET_1  TANGO_STYLE_ALT_OFFSET_2  TANGO_STYLE_ALT_OFFSET_3  TANGO_STYLE_ALT_OFFSET_4  Similar to the above, this sets a tile offset for double-bracketed text.\nThis adds a number to the base tile of custom and extended fonts; this is\napplied in addition to the color change. It's meant for 8-bit tiles,\nas those can't simply be recolored.  TANGO_STYLE_MENU_CHOICE_INDENT  How much extra space to add before each menu choice to make room for\nthe cursor, in pixels.  TANGO_STYLE_MENU_CURSOR_COMBO  TANGO_STYLE_MENU_CURSOR_CSET  TANGO_STYLE_MENU_CURSOR_WIDTH  TANGO_STYLE_MENU_CURSOR_HEIGHT  The appearance of the menu cursor. Width and height are in tiles.  TANGO_STYLE_MENU_CURSOR_MOVE_SFX  TANGO_STYLE_MENU_SELECT_SFX  TANGO_STYLE_MENU_CANCEL_SFX  The sounds to play in the menu.  TANGO_STYLE_MENU_SCROLL_UP_COMBO  TANGO_STYLE_MENU_SCROLL_UP_CSET  TANGO_STYLE_MENU_SCROLL_UP_X  TANGO_STYLE_MENU_SCROLL_UP_Y  TANGO_STYLE_MENU_SCROLL_DOWN_COMBO  TANGO_STYLE_MENU_SCROLL_DOWN_CSET  TANGO_STYLE_MENU_SCROLL_DOWN_X  TANGO_STYLE_MENU_SCROLL_DOWN_Y  If a menu is too large to fit in the text area, these combos will be drawn\nto indicate that it can scroll up or down.",
            "title": "Style attributes"
        },
        {
            "location": "/constants/index.html#style-flags",
            "text": "Constants to be used with  TANGO_STYLE  flags. These can be combined\nwith bitwise OR.   TANGO_FLAG_ENABLE_SPEEDUP  The text can be sped up by holding down A.  TANGO_FLAG_ENABLE_SUPER_SPEED  The text can be printed instantly by pressing B.  TANGO_FLAG_AUTO_ADVANCE  The player will not be prompted to press A when the text finishes;\nit will advance or disappear automatically.  TANGO_FLAG_CARRY_OVER  The slot will not be deactivated when the screen changes.  TANGO_FLAG_BLOCK_INPUT   While the slot is active, all keys will be unpressed.   Caution  Unpressing keys is handled by  Tango_Update1() . FFC scripts and\nanything earlier in the global script will see the unmodified input.    TANGO_FLAG_LINE_BY_LINE  Text is printed one line at a time instead of one character at a time.  TANGO_FLAG_INSTANTANEOUS  The text is printed all at once, regardless of the nominal speed. @while()  still runs only once per frame and holds up further processing\nuntil its condition is false.  @delay()  and  @waituntil()  still work.  TANGO_FLAG_PERSISTENT  When the text is finished printing, the player is not prompted\nto press A and the text does not disappear.  TANGO_FLAG_CENTERED  Text is centered in the printable area.  TANGO_FLAG_FREEZE_SCREEN   The game is frozen while the slot is active.   Note  In order for this flag to work, you must implement the functions __Tango_FreezeScreen()  and  __Tango_UnfreezeScreen() .",
            "title": "Style flags"
        },
        {
            "location": "/constants/index.html#backdrop-types",
            "text": "These are the different backdrop types used with  TANGO_STYLE_BACKDROP_TYPE \nand related attributes used to configure them.   TANGO_BACKDROP_CLEAR  No backdrop.  TANGO_BACKDROP_COLOR  TANGO_BACKDROP_COLOR_TRANS   A rectangle of a single color, either opaque or transparent.  Related attributes:   TANGO_STYLE_TEXT_CSET  TANGO_STYLE_TEXT_COLOR  The rectangle's CSet and color. The color is 0-15 within the CSet.  TANGO_STYLE_BACKDROP_WIDTH  TANGO_STYLE_BACKDROP_HEIGHT  The size of the rectangle in pixels.    TANGO_BACKDROP_TILE  TANGO_BACKDROP_TILE_TRANS   A block of tiles, either opaque or transparent.  Related attributes:   TANGO_STYLE_BACKDROP_TILE  The top-left tile of the block.  TANGO_STYLE_BACKDROP_CSET  The CSet of the backdrop.  TANGO_STYLE_BACKDROP_WIDTH  TANGO_STYLE_BACKDROP_HEIGHT  The size of the backdrop in tiles.    TANGO_BACKDROP_COMBO  TANGO_BACKDROP_COMBO_TRANS   A block of tiles drawn from a combo, either opaque or transparent.  Related attributes:   TANGO_STYLE_BACKDROP_COMBO  The combo using the top-left tile of the block.  TANGO_STYLE_BACKDROP_CSET  The CSet of the backdrop.  TANGO_STYLE_BACKDROP_WIDTH  TANGO_STYLE_BACKDROP_HEIGHT  The size of the backdrop in tiles.    TANGO_BACKDROP_COMPLEX   A backdrop made up of multiple drawing commands.  Related attributes:   TANGO_STYLE_BACKDROP_DATA  The array of data from which to draw the backdrop. For details, see the complex backdrops section .",
            "title": "Backdrop types"
        },
        {
            "location": "/constants/index.html#menu-flags",
            "text": "These should be used as arguments to  Tango_SetMenuFlags() .   TANGO_MENU_CAN_CANCEL  The user can cancel out of the menu instead of making a selection.  TANGO_MENU_PERSISTENT  The menu is persistent, meaning it will not close when a selection is made.\nIt will still close if the user cancels.",
            "title": "Menu flags"
        },
        {
            "location": "/tangoCode/index.html",
            "text": "Tango code variables and functions\n\n\nVariables\n\n\n\n\n@a0, @a1\n\n\n\n\nRead/write\n\n\nUse these to access the slot's \na[0]\n and \na[1]\n.\n\n\n\n\n@x, @y\n\n\n\n\nRead/write\n\n\nThe slot's position on the screen.\n\n\n\n\n@cset, @color\n\n\n\n\nRead/write\n\n\nThe slot's current text color. \n@color\n refers to color 0-15 within\nthe CSet and only applies to built-in font characters.\n\n\n\n\n@speed\n\n\n\n\nRead/write\n\n\nThe current text speed.\n\n\n\n\n@sfx\n\n\n\n\nRead/write\n\n\nThe current text sound.\n\n\n\n\n@style\n\n\n\n\nRead/write\n\n\nThe slot's current style. You should only write to this at\nthe beginning of a string, before any text is printed; changing\nstyles mid-text may cause problems.\n\n\n\n\n@next\n\n\n\n\nRead/write\n\n\nThe next message to be shown after the current one finishes.\n\n\n\n\n@chosen\n\n\n\n\nRead-only\n\n\nThe last option chosen in a menu. This is 0 if a menu is currently active,\nif no menu has been displayed yet, or if the player canceled in\nthe last menu.\n\n\n\n\n@default\n\n\n\n\nRead-only\n\n\nThis is a pseudo-variable used to reset style variables to the default.\nThere are only four valid uses:\n\n\n@set(@cset @default)\n\n\n@set(@color @default)\n\n\n@set(@speed @default)\n\n\n@set(@sfx @default)\n\n\nThe result of any other use is undefined.\n\n\n\n\n\n\nSetter functions\n\n\n\n\n@set(a1 a2)\n\n\n\n\na1\n: Writable variable\n\n\na2\n: Number or condition\n\n\nSets the value of a variable.\n\n\n\n\n@inc(a1 a2)\n\n\n\n\na1\n: Writable variable\n\n\na2\n: Number or condition\n\n\nAdds a value to a variable.\n\n\n\n\n\n\nControl functions\n\n\nThese functions affect the text display in ways not covered by other functions.\n\n\n\n\n@append(a1)\n\n\n\n\na1\n: Number\n\n\nAppends message \na1\n to the end of the current text.\n\n\n\n\n@delay(a1)\n\n\n\n\na1\n: Number\n\n\nSuspends processing of the slot for \na1\n frames. If the text is sped up\n(by holding down A), the delay will be reduced accordingly.\n\n\n\n\n@pressa()\n\n\nPrompts the player to press the the advance button (A by default)\nbefore continuing.\n\n\n@suspend()\n\n\nSuspends the current slot until a script calls \nTango_ResumeSlot()\n.\n\n\n@next(a1)\n\n\n\n\na1\n: Number\n\n\nSets message \na1\n to follow the current text. Equivalent to \n@set(@next a1)\n.\n\n\n\n\n@goto(a1)\n\n\n\n\na1\n: Number\n\n\nImmediately terminates the current text and loads message \na1\n.\n\n\n\n\n@tab(a1)\n\n\n\n\na1\n: Number\n\n\nIndents the text to \na1\n pixels. This may be left of the current position,\ncausing the following text to be printed over earlier text.\n\n\nThe behavior of this function with centered text is currently undefined.\n\n\n\n\n@close()\n\n\nImmediately deactivates the current slot.\n\n\n@sync(a1)\n\n\n@sync(a1 a2)\n\n\n\n\na1\n: Number\n\n\na2\n: Number\n\n\nThis can be used to synchronize multiple text slots or to synchronize\na slot and script.\n\n\nThe first string to call \n@sync()\n with one argument is suspended.\nWhen \n@sync()\n is called with the same argument from a second\nslot, both slots resume processing. For example, when two slots are\nactive simultaneously and both call \n@sync(5)\n, the first one to reach\nthat function will stop and wait for the other to catch up.\n\n\nIf two arguments are used, any slots waiting for \na1\n will be resumed,\nbut the current slot will not stop if no other is waiting for it. It will\ntreat the second argument the same way it would a single one. This is\nalmost the same as calling \n@sync(a1)@sync(a2)\n, except the first call\nwould never hang. This is convenient for synchronizing multiple strings,\nsuch as if two characters are talking to each other. Think of it this way:\n\n@sync(5 6)\n means \"tell the other string I've reached point 5, then wait\nfor it to reach point 6.\"\n\n\nTango_Sync()\n works in much the same way. A call to \nTango_Sync()\n\nwill not return until a string calls \n@sync()\n with the same value.\nDo not count on this coordination being precisely timed, as there may be\na discrepancy of a frame or two. Also, \nTango_Sync()\n cannot be used\non its own to synchronize multiple scripts; there must be at least\none call to \n@sync()\n involved.\n\n\n\n\n\n\nNumeric functions\n\n\n\n\n@add(a1 a2)\n\n\n\n\na1\n: Number\n\n\na2\n: Number\n\n\nReturns a1+a2\n\n\n\n\n@rand(a1 a2)\n\n\n\n\na1\n: Number\n\n\na2\n: Number\n\n\nReturns a random integer between \na1\n and \na2\n, inclusive.\n\n\n\n\n\n\nText functions\n\n\nThese functions are replaced with text when they run.\n\n\n\n\n@char(a1)\n\n\n\n\na1\n: Number\n\n\nInserts the character with the given number. This is similar to\ninserting character codes; \n@26\n and \n@char(26)\n are essentially the same.\nThe main difference is that \n@char()\n allows variables and functions\nto be used. \n@char(@a0)\n is legal; \n@(@a0)\n is not.\n\n\n\n\n@number(a1)\n\n\n\n\na1\n: Number\n\n\nInserts a number as text.\n\n\n\n\n@ordinal(a1)\n\n\n\n\na1\n: Number\n\n\nInserts a number as text followed by \"st\", \"nd\", \"rd\", or \"th\".\n\n\n\n\n@savename()\n\n\nInserts the save file name.\n\n\n@string(a1)\n\n\n\n\na1\n: Number (ZScript string pointer)\n\n\nInserts an arbitrary ZScript string. Code in this string will not\nbe evaluated. The maximum length of the string is determined by\nthe constant \n__TANGO_MAX_STRING_FUNC_LENGTH\n.\n\n\n\n\n\n\nFlow functions\n\n\n\n\n@while(a1 a2)\n\n\n\n\na1\n: Condition or number\n\n\na2\n: Setter or effect function\n\n\nExecutes \na2\n as long as \na1\n is nonzero. Runs once per frame while\nthe condition is true.\n\n\n\n\n@if(a1 a2)\n\n\n@elseif(a1 a2)\n\n\n@else(a2)\n\n\n\n\na1\n: Condition or number\n\n\na2\n: Setter or effect function\n\n\nExecute \na2\n if \na1\n is nonzero.\n\n\n\n\n@waituntil(a1)\n\n\n\n\na1\n: Condition or number function\n\n\nSupends processing of the slot until \na1\n is nonzero.\n\n\n\n\n\n\nCondition functions\n\n\nThese functions should be used as the first argument to \n@if()\n, \n@elseif()\n,\n\n@while()\n, and \n@waituntil()\n, but they can also be used as numeric functions.\nThey return 1 if the condition is true and 0 if it's false.\n\n\n\n\n@equal(a1 a2)\n\n\n\n\na1\n: Number or condition\n\n\na2\n: Number or condition\n\n\nTrue if \na1\n and \na2\n are equal.\n\n\n\n\n@notequal(a1 a2)\n\n\n\n\na1\n: Number or condition\n\n\na2\n: Number or condition\n\n\nTrue if \na1\n and \na2\n are not equal.\n\n\n\n\n@greater(a1 a2)\n\n\n\n\na1\n: Number\n\n\na2\n: Number\n\n\nTrue if \na1\n is greater than \na2\n.\n\n\n\n\n@less(a1 a2)\n\n\n\n\na1\n: Number\n\n\na2\n: Number\n\n\nTrue if \na1\n is less than \na2\n.\n\n\n\n\n@and(a1 a2)\n\n\n\n\na1\n: Condition or number\n\n\na2\n: Condition or number\n\n\nTrue if \na1\n and \na2\n are both nonzero.\n\n\n\n\n@or(a1 a2)\n\n\n\n\na1\n: Condition or number\n\n\na2\n: Condition or number\n\n\nTrue if at least one of \na1\n and \na2\n is nonzero.\n\n\n\n\n@not(a1)\n\n\n\n\na1\n: Condition or number\n\n\nTrue if \na1\n is 0, false otherwise.\n\n\n\n\n\n\nMenu functions\n\n\n\n\n@choice(a1)\n\n\n\n\na1\n: number\n\n\nCreates a menu option with value \na1\n. \na1\n should be greater than 0.\nThe maximum number of choices is determined by the constant\n\n__TANGO_MAX_MENU_ITEMS\n.\n\n\n\n\n@domenu()\n\n\n@domenu(a1)\n\n\n@domenu(a1 a2)\n\n\n\n\na1\n: Number\n\n\na2\n: Number\n\n\nActivates the menu and suspends further processing until a selection\nis made.\n\n\nFor argument \na1\n, add the following values to enable the corresponding\nfeature or use 0 to disable both.\n\n\n1\n: The player can cancel instead of making a selection\n\n\n2\n: The menu is persistent (doesn't close after a selection is made)\n\n\nThese correspond to the \nZScript \nMENU\n constants\n.\n\n\n\n\nNote\n\n\nA persistent menu is only useful when a script is running and\nwatching for each selection.\n\n\n\n\na2\n specifies the initially selected choice, counting from 0. If an invalid\nnumber is given, no choice will be selected initially; this is sometimes\nuseful to prevent the player from making a selection accidentally.\n\n\n\n\n@menuwait()\n\n\nSuspends processing of the slot until a menu selection is made.\nDon't use this together with \n@domenu()\n; it should be used when\na script or another string will create the menu.\n\n\n\n\nEffect functions\n\n\nThese functions perform functions in the game. They do not return useful values.\n\n\n\n\n@playsfx(a1)\n\n\n\n\na1\n: Number\n\n\nPlay a sound.",
            "title": "Tango variables and functions"
        },
        {
            "location": "/tangoCode/index.html#tango-code-variables-and-functions",
            "text": "",
            "title": "Tango code variables and functions"
        },
        {
            "location": "/tangoCode/index.html#variables",
            "text": "@a0, @a1   Read/write  Use these to access the slot's  a[0]  and  a[1] .   @x, @y   Read/write  The slot's position on the screen.   @cset, @color   Read/write  The slot's current text color.  @color  refers to color 0-15 within\nthe CSet and only applies to built-in font characters.   @speed   Read/write  The current text speed.   @sfx   Read/write  The current text sound.   @style   Read/write  The slot's current style. You should only write to this at\nthe beginning of a string, before any text is printed; changing\nstyles mid-text may cause problems.   @next   Read/write  The next message to be shown after the current one finishes.   @chosen   Read-only  The last option chosen in a menu. This is 0 if a menu is currently active,\nif no menu has been displayed yet, or if the player canceled in\nthe last menu.   @default   Read-only  This is a pseudo-variable used to reset style variables to the default.\nThere are only four valid uses:  @set(@cset @default)  @set(@color @default)  @set(@speed @default)  @set(@sfx @default)  The result of any other use is undefined.",
            "title": "Variables"
        },
        {
            "location": "/tangoCode/index.html#setter-functions",
            "text": "@set(a1 a2)   a1 : Writable variable  a2 : Number or condition  Sets the value of a variable.   @inc(a1 a2)   a1 : Writable variable  a2 : Number or condition  Adds a value to a variable.",
            "title": "Setter functions"
        },
        {
            "location": "/tangoCode/index.html#control-functions",
            "text": "These functions affect the text display in ways not covered by other functions.   @append(a1)   a1 : Number  Appends message  a1  to the end of the current text.   @delay(a1)   a1 : Number  Suspends processing of the slot for  a1  frames. If the text is sped up\n(by holding down A), the delay will be reduced accordingly.   @pressa()  Prompts the player to press the the advance button (A by default)\nbefore continuing.  @suspend()  Suspends the current slot until a script calls  Tango_ResumeSlot() .  @next(a1)   a1 : Number  Sets message  a1  to follow the current text. Equivalent to  @set(@next a1) .   @goto(a1)   a1 : Number  Immediately terminates the current text and loads message  a1 .   @tab(a1)   a1 : Number  Indents the text to  a1  pixels. This may be left of the current position,\ncausing the following text to be printed over earlier text.  The behavior of this function with centered text is currently undefined.   @close()  Immediately deactivates the current slot.  @sync(a1)  @sync(a1 a2)   a1 : Number  a2 : Number  This can be used to synchronize multiple text slots or to synchronize\na slot and script.  The first string to call  @sync()  with one argument is suspended.\nWhen  @sync()  is called with the same argument from a second\nslot, both slots resume processing. For example, when two slots are\nactive simultaneously and both call  @sync(5) , the first one to reach\nthat function will stop and wait for the other to catch up.  If two arguments are used, any slots waiting for  a1  will be resumed,\nbut the current slot will not stop if no other is waiting for it. It will\ntreat the second argument the same way it would a single one. This is\nalmost the same as calling  @sync(a1)@sync(a2) , except the first call\nwould never hang. This is convenient for synchronizing multiple strings,\nsuch as if two characters are talking to each other. Think of it this way: @sync(5 6)  means \"tell the other string I've reached point 5, then wait\nfor it to reach point 6.\"  Tango_Sync()  works in much the same way. A call to  Tango_Sync() \nwill not return until a string calls  @sync()  with the same value.\nDo not count on this coordination being precisely timed, as there may be\na discrepancy of a frame or two. Also,  Tango_Sync()  cannot be used\non its own to synchronize multiple scripts; there must be at least\none call to  @sync()  involved.",
            "title": "Control functions"
        },
        {
            "location": "/tangoCode/index.html#numeric-functions",
            "text": "@add(a1 a2)   a1 : Number  a2 : Number  Returns a1+a2   @rand(a1 a2)   a1 : Number  a2 : Number  Returns a random integer between  a1  and  a2 , inclusive.",
            "title": "Numeric functions"
        },
        {
            "location": "/tangoCode/index.html#text-functions",
            "text": "These functions are replaced with text when they run.   @char(a1)   a1 : Number  Inserts the character with the given number. This is similar to\ninserting character codes;  @26  and  @char(26)  are essentially the same.\nThe main difference is that  @char()  allows variables and functions\nto be used.  @char(@a0)  is legal;  @(@a0)  is not.   @number(a1)   a1 : Number  Inserts a number as text.   @ordinal(a1)   a1 : Number  Inserts a number as text followed by \"st\", \"nd\", \"rd\", or \"th\".   @savename()  Inserts the save file name.  @string(a1)   a1 : Number (ZScript string pointer)  Inserts an arbitrary ZScript string. Code in this string will not\nbe evaluated. The maximum length of the string is determined by\nthe constant  __TANGO_MAX_STRING_FUNC_LENGTH .",
            "title": "Text functions"
        },
        {
            "location": "/tangoCode/index.html#flow-functions",
            "text": "@while(a1 a2)   a1 : Condition or number  a2 : Setter or effect function  Executes  a2  as long as  a1  is nonzero. Runs once per frame while\nthe condition is true.   @if(a1 a2)  @elseif(a1 a2)  @else(a2)   a1 : Condition or number  a2 : Setter or effect function  Execute  a2  if  a1  is nonzero.   @waituntil(a1)   a1 : Condition or number function  Supends processing of the slot until  a1  is nonzero.",
            "title": "Flow functions"
        },
        {
            "location": "/tangoCode/index.html#condition-functions",
            "text": "These functions should be used as the first argument to  @if() ,  @elseif() , @while() , and  @waituntil() , but they can also be used as numeric functions.\nThey return 1 if the condition is true and 0 if it's false.   @equal(a1 a2)   a1 : Number or condition  a2 : Number or condition  True if  a1  and  a2  are equal.   @notequal(a1 a2)   a1 : Number or condition  a2 : Number or condition  True if  a1  and  a2  are not equal.   @greater(a1 a2)   a1 : Number  a2 : Number  True if  a1  is greater than  a2 .   @less(a1 a2)   a1 : Number  a2 : Number  True if  a1  is less than  a2 .   @and(a1 a2)   a1 : Condition or number  a2 : Condition or number  True if  a1  and  a2  are both nonzero.   @or(a1 a2)   a1 : Condition or number  a2 : Condition or number  True if at least one of  a1  and  a2  is nonzero.   @not(a1)   a1 : Condition or number  True if  a1  is 0, false otherwise.",
            "title": "Condition functions"
        },
        {
            "location": "/tangoCode/index.html#menu-functions",
            "text": "@choice(a1)   a1 : number  Creates a menu option with value  a1 .  a1  should be greater than 0.\nThe maximum number of choices is determined by the constant __TANGO_MAX_MENU_ITEMS .   @domenu()  @domenu(a1)  @domenu(a1 a2)   a1 : Number  a2 : Number  Activates the menu and suspends further processing until a selection\nis made.  For argument  a1 , add the following values to enable the corresponding\nfeature or use 0 to disable both.  1 : The player can cancel instead of making a selection  2 : The menu is persistent (doesn't close after a selection is made)  These correspond to the  ZScript  MENU  constants .   Note  A persistent menu is only useful when a script is running and\nwatching for each selection.   a2  specifies the initially selected choice, counting from 0. If an invalid\nnumber is given, no choice will be selected initially; this is sometimes\nuseful to prevent the player from making a selection accidentally.   @menuwait()  Suspends processing of the slot until a menu selection is made.\nDon't use this together with  @domenu() ; it should be used when\na script or another string will create the menu.",
            "title": "Menu functions"
        },
        {
            "location": "/tangoCode/index.html#effect-functions",
            "text": "These functions perform functions in the game. They do not return useful values.   @playsfx(a1)   a1 : Number  Play a sound.",
            "title": "Effect functions"
        },
        {
            "location": "/dataFormats/index.html",
            "text": "Data structures and formats\n\n\nText slots\n\n\nA text slot represents the state of a string being displayed in much\nthe same way as an \nnpc\n pointer represents the state of an enemy.\nIt stores the text, its style, and its position on the screen. A text slot\nis said to be \"active\" if the text is currently being displayed. The data in\na text slot is mostly internal; most of the time, all you'll care about is\nits style, its position, and whether it's active.\n\n\nText slots have definitions separate from the slots themselves. They are\ndefined in \n__Tango_SlotDefs[]\n. The slot definition controls the slot type,\nwhere in the buffer text is stored, and where it's rendered on the offscreen\nbitmap.\n\n\nFor more advanced uses, you may want to customize the available text slots.\nIf you want to display multiple strings at once, you'll need at least one slot\nfor each string. You may want to set up slots of different types to ensure\none is always available for a certain use when you need it or to ensure that\nsome strings are never covered up by others.\n\n\nThere are only a couple of properties to set in a slot definition: each slot\nhas a type and a certain amount of space allocated. The order in which they're\ndefined is also significant.\n\n\nA slot's type has no direct impact on how it works; the only thing it affects\nis what is returned by \nTango_GetFreeSlot()\n. Any difference beyond that comes\ndown to how you choose to define and use them.\n\n\nThe ordering of slots is significant because they are drawn in order. Slot 0\nis drawn first, then slot 1, and so on. That means that if multiple slots\nare active at once, higher-numbered slots will appear in front of\nlower-numbered ones.\n\n\nThere are two slots and one slot type defined by default. This should be plenty\nfor most quests, but you can add as many slots and types as you like. Slots are\nintegers from 0 to \n__TANGO_NUM_SLOTS - 1\n, and type IDs should be 0 or greater.\n\n\nTo control the number of slots, set \n__TANGO_NUM_SLOTS\n, set the size of\n\n__Tango_SlotData[]\n, and add definitions to \n__Tango_SlotDefs[]\n. You may\nalso want to set the size of \n__Tango_Buffer[]\n to control the total amount of\nspace available for text.\n\n\nEach slot is defined by seven numbers in \n__Tango_SlotDefs[]\n. These are,\nin order:\n\n\n\n\nSlot type\n\n\nStarting index in \n__Tango_Buffer[]\n\n\nMaximum length in \n__Tango_Buffer[]\n\n\nX position in offscreen bitmap\n\n\nY position in offscreen bitmap\n\n\nWidth in offscreen bitmap\n\n\nHeight in offscreen bitmap\n\n\n\n\nIt is permissible for slots to overlap in both the buffer and the bitmap, but\nbe careful about this; using overlapping slots simultaneously is likely to\ncause problems.\n\n\nStyles\n\n\nBefore any text can be displayed, the slot must have a style set. The style\ndefines how the text will be displayed - the font, the backdrop, the sound\neffects, and so forth. Style IDs are integers 0 and up.\n\n\nA style is simply a collection of settings. These are mostly cosmetic, but\nthere are also a few behavioral flags. These control whether the text can be\nsped up by holding a button and whether the screen is frozen while it's\ndisplayed, among other things.\n\n\nUse \nTango_SetStyleAttribute()\n to set each style attribute. You must at least\nset the font and color; every other setting has a valid default. See the\n\nconstants\n page for the available attributes and expected values.\nMost of the constants defined by Tango are style-related. Once an attribute\nis set, it won't change unless you change it yourself, so it's okay to set up\nstyles in the \nInit\n script and never touch them again.\n\n\nTo control the number of styles available, set \n__TANGO_NUM_STYLES\n and the\nsize of \n__Tango_Styles[]\n.\n\n\nComplex backdrops\n\n\nTo use a complex backdrop, you must create a properly formatted array\nand provide a pointer to it with \nTANGO_BACKDROP_DATA\n. The array must exist\nfor as long as the slot is active.\n\n\nThe array must consist of a series of drawing commands followed by\n\nTANGO_DRAW_END\n. A drawing command, in this context, means a \nTANGO_DRAW\n\nconstant followed by six numbers. The meanings of these numbers depends on\nwhat is being drawn.\n\n\n\n\nTANGO_DRAW_RECT\n\n\nTANGO_DRAW_RECT_TRANS\n\n\n\n\nA plain rectangle, either opaque or transparent.\n\n\nData:\n\n\n\n\nCSet\n\n\nColor (0-15 within the CSet)\n\n\nX position\n\n\nY position\n\n\nWidth in pixels\n\n\nHeight in pixels\n\n\n\n\n\n\nTANGO_DRAW_TILE\n\n\nTANGO_DRAW_TILE_TRANS\n\n\n\n\nA block of tiles, either opaque or transparent.\n\n\nData:\n\n\n\n\nStarting tile\n\n\nCSet\n\n\nX position\n\n\nY position\n\n\nWidth in tiles\n\n\nHeight in tiles\n\n\n\n\n\n\nTANGO_DRAW_COMBO\n\n\nTANGO_DRAW_COMBO_TRANS\n\n\n\n\nA block of tiles drawn from a combo, either opaque or transparent.\n\n\nData:\n\n\n\n\nStarting combo\n\n\nCSet\n\n\nX position\n\n\nY position\n\n\nWidth in tiles\n\n\nHeight in tiles\n\n\n\n\n\n\nTANGO_DRAW_TEXT\n\n\n\n\nA string of text. This is a ZScript string, which must exist as long as\nthe slot is active. The font must be a Tango font, not a built-in one.\nIf you want to center the text, you can use \nTango_GetStringWidth()\n\nto find its width.\n\n\nData:\n\n\n\n\nString pointer\n\n\nFont\n\n\nCSet\n\n\nColor (0-15 within the CSet)\n\n\nX position\n\n\nY position\n\n\n\n\n\n\n\n\nAs an example, a backdrop consisting of a transparent rectangle with a block\nof tiles over it might look like this:\n\n\nint\n \nsampleBackdrop\n[]\n=\n \n{\n\n    \nTANGO_DRAW_RECT_TRANS\n,\n\n        \n0\n,\n       \n// CSet\n\n        \n4\n,\n       \n// Color\n\n        \n4\n,\n \n5\n,\n    \n// X, Y (pixels)\n\n        \n184\n,\n \n72\n,\n \n// Width, height (pixels)\n\n    \nTANGO_DRAW_TILE\n,\n\n        \n400\n,\n   \n// Tile\n\n        \n5\n,\n     \n// CSet\n\n        \n0\n,\n \n0\n,\n  \n// X, Y (pixels)\n\n        \n12\n,\n \n5\n,\n \n// Width, height (tiles)\n\n    \nTANGO_DRAW_END\n\n\n};\n\n\n\n\n\n\nFonts\n\n\nTango can't use ZC's built-in fonts directly; it needs additional data about\nspacing to position everything correctly. Tango font definitions are arrays\nthat provide the necessary information.\n\n\nDefinitions for most built-in fonts are included, but they're not imported\nby default. The files are in the tango/font directory. Although they aren't\nconstants (since ZScript doesn't allow constant arrays), the names are\nwritten in all caps to indicate that they should be used as though they were.\n\n\nYou can create your own fonts, too. Using characters made from tiles, you can\nextend built-in fonts with additional characters or create completely original\nones. The drawback of tile-based characters is that they have fewer color\noptions; they only have a CSet, not a CSet and a color. On the other hand,\ntile-based characters can use multiple colors, and they can even be 8-bit.\n\n\nA font definition is an array consisting of the following data, in order:\n\n\n\n\n\n\nFont type\n\n\nThis must be one of:\n\n\n\n\nTANGO_FONT_BUILTIN\n\n\nTANGO_FONT_EXTENDED\n\n\nTANGO_FONT_CUSTOM\n\n\n\n\n\n\n\n\nWidth type\n\n\nThis must be one of:\n\n\n\n\nTANGO_FONT_MONOSPACE\n\n\nTANGO_FONT_PROPORTIONAL\n\n\n\n\n\n\n\n\nFont ID\n\n\nFor built-in and extended fonts, this is the value of the built-in font;\nuse one of std.zh's \nFONT\n constants. Custom fonts ignore this value.\n\n\n\n\n\n\nTile start\n\n\nThis is the tile used by the first extended character (256) in extended\nfonts or the first printable character (33, '!') in custom fonts. Built-in\nfonts ignore this value.\n\n\n\n\n\n\nCharacter height in pixels\n\n\nIn tile-based fonts, this is the distance from the top of a tile to the\nbottom of the lowest character. Built-in fonts often include some space\nabove each character; in that case, this is the distance from the top of\nthat space to the bottom of the lowest character.\n\n\n\n\n\n\nSpace between lines in pixels\n\n\nThis is the space from the bottom of one line to the top of the next,\nnot the total line height.\n\n\n\n\n\n\n(and up) Character widths in pixels\n\n\nThe width of each character, including any trailing space. In monospaced\nfonts, this is a single value. For proportional fonts, this is a list of\nwidths for each character starting from space (32). Characters 32-126\nfollow ASCII order; characters 127 and up are arbitrary and vary by font.\n\n\n\n\n\n\nIf you want to create an extended font, it's easiest to copy one of\nthe included built-in font definitions, change \nTANGO_FONT_BUILTIN\n to\n\nTANGO_FONT_EXTENDED\n, then add the starting tile and extra character widths.\nBe aware that many built-in fonts leave some space above the glyphs. Extended\ncharacters will need to account for this.\n\n\nIdentifier conversion\n\n\nTango_ConvertFunctionName()\n and \nTango_ConvertVariableName()\n will convert\nnames to numbers for you. But if you want to do it yourself, here's how.\nStart by converting each character in the name to a number:\n\n\n\na  b  c ... x  y  z  0  1  2  ... 7  8  9\n1  2  3 ... 24 25 26 27 28 29 ... 34 35 36\n\n\n\n\nMultiply each number by 7\nn\n according to its position, add them up, and\ndivide by 10000.\n\n\nFor example, for a function called @dostuff2:\n\n\n\nd   4   x7 x7 x7 x7 x7 x7 x7 = 3294172 +\no   15  x7 x7 x7 x7 x7 x7    = 1764735 +\ns   19  x7 x7 x7 x7 x7       =  319333 +\nt   20  x7 x7 x7 x7          =   48020 +\nu   21  x7 x7 x7             =    7203 +\nf   6   x7 x7                =     294 +\nf   6   x7                   =      42 +\n2   29                       =      29\n                               -------\n                               5433828 / 10000 = 543.3828\n\n\n\n\nNote that this may change in future versions.",
            "title": "Data structures and formats"
        },
        {
            "location": "/dataFormats/index.html#data-structures-and-formats",
            "text": "",
            "title": "Data structures and formats"
        },
        {
            "location": "/dataFormats/index.html#text-slots",
            "text": "A text slot represents the state of a string being displayed in much\nthe same way as an  npc  pointer represents the state of an enemy.\nIt stores the text, its style, and its position on the screen. A text slot\nis said to be \"active\" if the text is currently being displayed. The data in\na text slot is mostly internal; most of the time, all you'll care about is\nits style, its position, and whether it's active.  Text slots have definitions separate from the slots themselves. They are\ndefined in  __Tango_SlotDefs[] . The slot definition controls the slot type,\nwhere in the buffer text is stored, and where it's rendered on the offscreen\nbitmap.  For more advanced uses, you may want to customize the available text slots.\nIf you want to display multiple strings at once, you'll need at least one slot\nfor each string. You may want to set up slots of different types to ensure\none is always available for a certain use when you need it or to ensure that\nsome strings are never covered up by others.  There are only a couple of properties to set in a slot definition: each slot\nhas a type and a certain amount of space allocated. The order in which they're\ndefined is also significant.  A slot's type has no direct impact on how it works; the only thing it affects\nis what is returned by  Tango_GetFreeSlot() . Any difference beyond that comes\ndown to how you choose to define and use them.  The ordering of slots is significant because they are drawn in order. Slot 0\nis drawn first, then slot 1, and so on. That means that if multiple slots\nare active at once, higher-numbered slots will appear in front of\nlower-numbered ones.  There are two slots and one slot type defined by default. This should be plenty\nfor most quests, but you can add as many slots and types as you like. Slots are\nintegers from 0 to  __TANGO_NUM_SLOTS - 1 , and type IDs should be 0 or greater.  To control the number of slots, set  __TANGO_NUM_SLOTS , set the size of __Tango_SlotData[] , and add definitions to  __Tango_SlotDefs[] . You may\nalso want to set the size of  __Tango_Buffer[]  to control the total amount of\nspace available for text.  Each slot is defined by seven numbers in  __Tango_SlotDefs[] . These are,\nin order:   Slot type  Starting index in  __Tango_Buffer[]  Maximum length in  __Tango_Buffer[]  X position in offscreen bitmap  Y position in offscreen bitmap  Width in offscreen bitmap  Height in offscreen bitmap   It is permissible for slots to overlap in both the buffer and the bitmap, but\nbe careful about this; using overlapping slots simultaneously is likely to\ncause problems.",
            "title": "Text slots"
        },
        {
            "location": "/dataFormats/index.html#styles",
            "text": "Before any text can be displayed, the slot must have a style set. The style\ndefines how the text will be displayed - the font, the backdrop, the sound\neffects, and so forth. Style IDs are integers 0 and up.  A style is simply a collection of settings. These are mostly cosmetic, but\nthere are also a few behavioral flags. These control whether the text can be\nsped up by holding a button and whether the screen is frozen while it's\ndisplayed, among other things.  Use  Tango_SetStyleAttribute()  to set each style attribute. You must at least\nset the font and color; every other setting has a valid default. See the constants  page for the available attributes and expected values.\nMost of the constants defined by Tango are style-related. Once an attribute\nis set, it won't change unless you change it yourself, so it's okay to set up\nstyles in the  Init  script and never touch them again.  To control the number of styles available, set  __TANGO_NUM_STYLES  and the\nsize of  __Tango_Styles[] .",
            "title": "Styles"
        },
        {
            "location": "/dataFormats/index.html#complex-backdrops",
            "text": "To use a complex backdrop, you must create a properly formatted array\nand provide a pointer to it with  TANGO_BACKDROP_DATA . The array must exist\nfor as long as the slot is active.  The array must consist of a series of drawing commands followed by TANGO_DRAW_END . A drawing command, in this context, means a  TANGO_DRAW \nconstant followed by six numbers. The meanings of these numbers depends on\nwhat is being drawn.   TANGO_DRAW_RECT  TANGO_DRAW_RECT_TRANS   A plain rectangle, either opaque or transparent.  Data:   CSet  Color (0-15 within the CSet)  X position  Y position  Width in pixels  Height in pixels    TANGO_DRAW_TILE  TANGO_DRAW_TILE_TRANS   A block of tiles, either opaque or transparent.  Data:   Starting tile  CSet  X position  Y position  Width in tiles  Height in tiles    TANGO_DRAW_COMBO  TANGO_DRAW_COMBO_TRANS   A block of tiles drawn from a combo, either opaque or transparent.  Data:   Starting combo  CSet  X position  Y position  Width in tiles  Height in tiles    TANGO_DRAW_TEXT   A string of text. This is a ZScript string, which must exist as long as\nthe slot is active. The font must be a Tango font, not a built-in one.\nIf you want to center the text, you can use  Tango_GetStringWidth() \nto find its width.  Data:   String pointer  Font  CSet  Color (0-15 within the CSet)  X position  Y position     As an example, a backdrop consisting of a transparent rectangle with a block\nof tiles over it might look like this:  int   sampleBackdrop [] =   { \n     TANGO_DRAW_RECT_TRANS , \n         0 ,         // CSet \n         4 ,         // Color \n         4 ,   5 ,      // X, Y (pixels) \n         184 ,   72 ,   // Width, height (pixels) \n     TANGO_DRAW_TILE , \n         400 ,     // Tile \n         5 ,       // CSet \n         0 ,   0 ,    // X, Y (pixels) \n         12 ,   5 ,   // Width, height (tiles) \n     TANGO_DRAW_END  };",
            "title": "Complex backdrops"
        },
        {
            "location": "/dataFormats/index.html#fonts",
            "text": "Tango can't use ZC's built-in fonts directly; it needs additional data about\nspacing to position everything correctly. Tango font definitions are arrays\nthat provide the necessary information.  Definitions for most built-in fonts are included, but they're not imported\nby default. The files are in the tango/font directory. Although they aren't\nconstants (since ZScript doesn't allow constant arrays), the names are\nwritten in all caps to indicate that they should be used as though they were.  You can create your own fonts, too. Using characters made from tiles, you can\nextend built-in fonts with additional characters or create completely original\nones. The drawback of tile-based characters is that they have fewer color\noptions; they only have a CSet, not a CSet and a color. On the other hand,\ntile-based characters can use multiple colors, and they can even be 8-bit.  A font definition is an array consisting of the following data, in order:    Font type  This must be one of:   TANGO_FONT_BUILTIN  TANGO_FONT_EXTENDED  TANGO_FONT_CUSTOM     Width type  This must be one of:   TANGO_FONT_MONOSPACE  TANGO_FONT_PROPORTIONAL     Font ID  For built-in and extended fonts, this is the value of the built-in font;\nuse one of std.zh's  FONT  constants. Custom fonts ignore this value.    Tile start  This is the tile used by the first extended character (256) in extended\nfonts or the first printable character (33, '!') in custom fonts. Built-in\nfonts ignore this value.    Character height in pixels  In tile-based fonts, this is the distance from the top of a tile to the\nbottom of the lowest character. Built-in fonts often include some space\nabove each character; in that case, this is the distance from the top of\nthat space to the bottom of the lowest character.    Space between lines in pixels  This is the space from the bottom of one line to the top of the next,\nnot the total line height.    (and up) Character widths in pixels  The width of each character, including any trailing space. In monospaced\nfonts, this is a single value. For proportional fonts, this is a list of\nwidths for each character starting from space (32). Characters 32-126\nfollow ASCII order; characters 127 and up are arbitrary and vary by font.    If you want to create an extended font, it's easiest to copy one of\nthe included built-in font definitions, change  TANGO_FONT_BUILTIN  to TANGO_FONT_EXTENDED , then add the starting tile and extra character widths.\nBe aware that many built-in fonts leave some space above the glyphs. Extended\ncharacters will need to account for this.",
            "title": "Fonts"
        },
        {
            "location": "/dataFormats/index.html#identifier-conversion",
            "text": "Tango_ConvertFunctionName()  and  Tango_ConvertVariableName()  will convert\nnames to numbers for you. But if you want to do it yourself, here's how.\nStart by converting each character in the name to a number:  \na  b  c ... x  y  z  0  1  2  ... 7  8  9\n1  2  3 ... 24 25 26 27 28 29 ... 34 35 36  Multiply each number by 7 n  according to its position, add them up, and\ndivide by 10000.  For example, for a function called @dostuff2:  \nd   4   x7 x7 x7 x7 x7 x7 x7 = 3294172 +\no   15  x7 x7 x7 x7 x7 x7    = 1764735 +\ns   19  x7 x7 x7 x7 x7       =  319333 +\nt   20  x7 x7 x7 x7          =   48020 +\nu   21  x7 x7 x7             =    7203 +\nf   6   x7 x7                =     294 +\nf   6   x7                   =      42 +\n2   29                       =      29\n                               -------\n                               5433828 / 10000 = 543.3828  Note that this may change in future versions.",
            "title": "Identifier conversion"
        },
        {
            "location": "/errors/index.html",
            "text": "Error codes\n\n\nIf you use loggingMinimal.zh instead of loggingFull.zh, error messages\nwill be logged only as ID numbers. These are all the possible error codes:\n\n\n101\n: Attempted to load an invalid message\n\n\n102\n: Attempted to load an invalid string\n\n\n103\n: The text to be loaded would not fit in the buffer\n\n\n104\n: The text contained an invalid or incomplete function call\n\n\n105\n: The text contained an invalid function argument\n\n\n106\n: The text contained an invalid character code\n\n\n107\n: The message contained an incomplete string control code\n\n\n108\n: The message contained a string control code, but they're disabled\n\n\n201\n: The text contained an invalid character\n\n\n202\n: An undefined function was called (you must call\n\nTango_LogUndefinedFunction()\n for this error to be reported)\n\n\n203\n: An undefined variable was referenced (you must call\n\nTango_LogUndefinedVariable()\n for this error to be reported)\n\n\n204\n: More than 4 arguments were passed to a function\n\n\n205\n: An invalid argument was given to \n@string()\n\n\n301\n: A menu with no choices was activated\n\n\n302\n: Too many choices were added to a menu\n\n\n303\n: Tried to move an invalid menu choice\n\n\n401\n: An invalid style ID was used\n\n\n402\n: A slot was activated using a style with no font set\n\n\n403\n: An invalid slot ID was used\n\n\n404\n: The array passed to \nTango_SaveSlotState()\n or \nTango_RestoreSlotState()\n was too small\n\n\n405\n: The array passed to \nTango_SaveMenuState()\n or \nTango_RestoreMenuState()\n was too small",
            "title": "Error codes"
        },
        {
            "location": "/errors/index.html#error-codes",
            "text": "If you use loggingMinimal.zh instead of loggingFull.zh, error messages\nwill be logged only as ID numbers. These are all the possible error codes:  101 : Attempted to load an invalid message  102 : Attempted to load an invalid string  103 : The text to be loaded would not fit in the buffer  104 : The text contained an invalid or incomplete function call  105 : The text contained an invalid function argument  106 : The text contained an invalid character code  107 : The message contained an incomplete string control code  108 : The message contained a string control code, but they're disabled  201 : The text contained an invalid character  202 : An undefined function was called (you must call Tango_LogUndefinedFunction()  for this error to be reported)  203 : An undefined variable was referenced (you must call Tango_LogUndefinedVariable()  for this error to be reported)  204 : More than 4 arguments were passed to a function  205 : An invalid argument was given to  @string()  301 : A menu with no choices was activated  302 : Too many choices were added to a menu  303 : Tried to move an invalid menu choice  401 : An invalid style ID was used  402 : A slot was activated using a style with no font set  403 : An invalid slot ID was used  404 : The array passed to  Tango_SaveSlotState()  or  Tango_RestoreSlotState()  was too small  405 : The array passed to  Tango_SaveMenuState()  or  Tango_RestoreMenuState()  was too small",
            "title": "Error codes"
        },
        {
            "location": "/faq/index.html",
            "text": "FAQ\n\n\nWhy isn't my script working correctly?\n\n\nWhenever something doesn't work, you should look at allegro.log to see\nif any errors have been reported. You'll get more helpful messages using\nfull logging, which is enabled by importing loggingFull.zh instead of\nloggingMinimal.zh. These are found near the bottom of the main file.\n\n\nSome common errors:\n\n\n\n\n\n\nUsing more styles than alloted\n\n\n\n\nFixed by increasing \n__TANGO_NUM_STYLES\n and the size of \n__Tango_Styles[]\n\n\n\n\n\n\n\n\nUsing more menu options than alloted\n\n\n\n\nFixed by increasing \n__TANGO_MAX_MENU_ITEMS\n and the size of \n__Tango_Data[]\n\n\n\n\n\n\n\n\nIncorrect constants for custom functions\n\n\n\n\nUse \nTango_ConvertFunctionName()\n to make sure you've got them right\n\n\n\n\n\n\n\n\nYou can also try calling the function \nTango_ValidateConfiguration()\n. This will\nanalyze your settings and report any errors it finds in allegro.log.\n\n\nHow do I display a string?\n\n\n\n\nFind a free text slot (\nTango_GetFreeSlot()\n)\n\n\nClear all data in the slot (\nTango_ClearSlot()\n)\n\n\nLoad text into the slot (\nTango_LoadString()\n or \nTango_LoadMessage()\n)\n\n\nSet a style (\nTango_SetSlotStyle()\n)\n\n\nSet the position on the screen (\nTango_SetSlotPosition()\n)\n\n\nActivate the text slot (\nTango_ActivateSlot()\n)\n\n\n\n\nTango_LoadString()\n loads a ZScript string (an \nint\n array);\n\nTango_LoadMessage()\n loads a ZC message (\nQuest > Strings\n). All built-in\nfunction names follow this naming convention.\n\n\nYou'll probably want to combine these into a single function for simplicity.\ntangoQuickStart.zh provides examples in the \nShowString()\n and \nShowMessage()\n\nfunctions.\n\n\nWhat is a text slot?\n\n\nText slots are where strings are stored for processing and display. They store\nthe text, the style, and the position on the screen, as well as some internal\ndata. Before any text can be shown on the screen, it must be loaded into\none of the available slots.\n\n\nSlot IDs are integers counting up from 0. Most often, you'll want to find\na free slot automatically, but you can also use hardcoded slot numbers.\nEach slot has its own definition, which determines how long a string can be and\nhow much space is available for drawing it.\n\n\nWhat is a style?\n\n\nA style determines the appearance and behavior of displayed text. For instance,\nthe font, the backdrop, and whether the text can be sped up by holding A\nare all controlled by the style.\n\n\nStyle IDs are integers counting up from 0. Every text slot using the same style\nwill have the same appearance and behavior.\n\n\nHow many text slots do I need?\n\n\nYou need at least as many slots as will ever be active at once. If you want\nfifty strings onscreen at once, you need fifty slots. If you only want one\nstring active at a time, just one slot will suffice.\n\n\nFor more advanced uses, you may want more slots than are strictly necessary.\nFor instance, you might want to reserve certain slots for specific purposes,\neven if they'll never all be in use at once.\n\n\nHow do I add more text slots?\n\n\nSet \n__TANGO_NUM_SLOTS\n to the number of slots you want and change the size of\n\n__Tango_Buffer[]\n so that it's large enough to hold the text for all of them.\n\n\nThe slot definitions go in \n__Tango_SlotDefs[]\n. The first seven numbers define\nslot 0, the next seven define slot 1, and so on. In order, these numbers are\nthe slot type, the starting index and size in \n__Tango_Buffer[]\n, the X and Y\ncoordinates on the bitmap, and the width and height on the bitmap. For example:\n\n\nint\n \n__Tango_SlotDefs\n[]\n \n=\n \n{\n\n    \n// Slot 0\n\n    \nTANGO_SLOT_NORMAL\n,\n \n// The slot type\n\n    \n0\n,\n \n512\n,\n   \n// Occupies __Tango_Buffer[0] to __Tango_Buffer[511]\n\n    \n0\n,\n \n0\n,\n     \n// Draws to a region at 0, 0 on the bitmap\n\n    \n192\n,\n \n128\n,\n \n// Drawing region is 192x128 pixels\n\n\n    \n// Slot 1\n\n    \nTANGO_SLOT_SMALL\n,\n\n    \n512\n,\n \n64\n,\n \n// Occupies __Tango_Buffer[512] to __Tango_Buffer[575]\n\n    \n0\n,\n \n128\n,\n  \n// Draws to a region at 0, 128 (just below slot 0)\n\n    \n128\n,\n \n32\n  \n// Drawing region is 128x32\n\n\n    \n// Slot 2\n\n    \nTANGO_SLOT_SMALL\n,\n\n    \n576\n,\n \n64\n,\n \n// Occupies __Tango_Buffer[576] to __Tango_Buffer[639]\n\n    \n0\n,\n \n160\n,\n  \n// Draws to a region at 0, 160 (just below slot 1)\n\n    \n128\n,\n \n32\n  \n// Drawing region is 128x32\n\n\n};\n\n\n\n\n\n\nThe slot type is arbitrary. It can be any non-negative number. The default\nslot type, \nTANGO_SLOT_NORMAL\n, can safely be renamed or deleted.\n\n\nGenerally, you shouldn't let slots overlap in the buffer or the bitmap.\nIf they won't be in use at the same time, however, it won't cause problems.\nIf you use a very large number of slots, it may even be necessary for them\nto share some space on the bitmap.\n\n\nWhat is the purpose of slot types?\n\n\nA slot's type makes no difference to how it's handled internally. The only\nthing it actually affects is what's returned by \nTango_GetFreeSlot()\n. Slot\ntypes exist for users to create their own distictions. There are three reasons\nyou might use different slot types:\n\n\n\n\n\n\nReservation\n\n\nIn order to display a string, you must first have a free slot. If no slots\nare free, you can't show any text without clearing one out. If there's\nsomething you need to be able to display, you can create a dedicated slot\ntype for it, so there will always be a slot free when you need it.\n\n\nFor instance, suppose you want NPCs to spout random lines of dialog in the\nbackground. You might define several slots of type \nSLOT_BG\n to use for this\npurpose, and one of type \nSLOT_FG\n for the text box when Link talks to\nsomeone. This way, you can have the NPCs use as many \nSLOT_BG\n slots as they\nlike, and the main \nSLOT_FG\n will always be available when you need it.\n\n\n\n\n\n\nDrawing order\n\n\nText slots are drawn to the screen in order from first to last. If you want\ncertain strings to be drawn above or below others, you can enforce this by\nusing different slot types.\n\n\nGoing back to the same example, you wouldn't want your NPCs' random lines\nto appear on top of the main text box. If slots 0-4 are \nSLOT_BG\n and\nslot 5 is \nSLOT_FG\n, you can be sure the most important text will always\nbe on top.\n\n\n\n\n\n\nEfficient use of space\n\n\nIf you plan to have one or two long strings appear alongside a lot of\nshort ones, you can use different slot types to avoid wasting space\nin \n__Tango_Buffer[]\n. Because \n__Tango_Buffer[]\n is a global array,\nit is part of the quest's save data. Making it larger than necessary\ncauses useless data to be saved and loaded, making both take a little\nlonger (though only slightly). More importantly, there's limited space\nfor drawing on the offscreen bitmap. If you have ten slots all using\n192x128 pixels, they'll have to overlap, potentially causing graphical\nerrors.\n\n\nIf your random NPC dialog will only ever be a line or two, you can give\n\nSLOT_BG\n a small amount of space in the buffer and bitmap, while \nSLOT_FG\n\nmight have room for several hundred characters and space to draw a large\ntext box.\n\n\n\n\n\n\nOrdinarily, it is expected that all slots of the same type have the same amount\nof space allocated in the buffer and on the bitmap, but this is not enforced.\nIf you want to make some \nSLOT_BG\ns small and some large, you can do that, but\nit's up to you to ensure they're used correctly.\n\n\nHow do I create a style?\n\n\nWith a series of calls to \nTango_SetStyleAttribute()\n. Each call will set\na single attribute of the style. At a minimum, you must set a font and color\nfor the text. See \nthe constants page\n for the available settings.\nCheck out tangoQuickStart.zh for an example.\n\n\nIf you want to unload a style after it's been set up, use \nTango_ClearStyle()\n.\nThis is only necessary if you want to reuse an ID for a different style,\nwhich is rarely done.\n\n\nWhen should I set up a style?\n\n\nAny time before it's actually used is fine. The most common method is to set up\nall of your styles at the beginning of the active global script. It's also okay\nto do it in the \nInit\n script. Styles will stay set up until you clear them or\nchange them.\n\n\nAnother approach is to set a style up immediately before displaying a string\nthat uses it; this may be preferable when using a large number of different\nstyles.\n\n\nA combination of those two methods is also possible. If you want multiple\nstyles that are mostly the same, you might set the common attributes\nin advance and set the distinct ones on demand.\n\n\nChanging a style while it's in use is permitted, but changes to the text color\nand font will not affect any text that has already been printed.\n\n\nWhy isn't the screen freeze style flag working?\n\n\nThere are two functions in the main file, \n__Tango_FreezeScreen()\n and\n\n__Tango_UnfreezeScreen()\n, that are blank by default. In order for the\nscreen freeze style flag to work, you must implement these functions.\n\n\nThe reason that they're blank is that there isn't a reasonable default\nimplementation; they're too dependent on the quest. Grabbing arbitrary FFCs\nor changing combo definitions in an unknown quest might cause serious problems.\n\n\nThe recommended method is to set two unused FFCs to combos of type\n\nScreen Freeze (Except FFCs)\n and \nScreen Freeze (FFCs Only)\n. Be aware,\nhowever, that if an FFC script triggers this, that script will freeze, too.\nIf you're using ghost.zh, \nSuspendGhostZHScripts()\n and \nResumeGhostZHScripts()\n\nshould be used as well. Other headers may have similar suspend functions that\nshould also be included.",
            "title": "FAQ"
        },
        {
            "location": "/faq/index.html#faq",
            "text": "",
            "title": "FAQ"
        },
        {
            "location": "/faq/index.html#why-isnt-my-script-working-correctly",
            "text": "Whenever something doesn't work, you should look at allegro.log to see\nif any errors have been reported. You'll get more helpful messages using\nfull logging, which is enabled by importing loggingFull.zh instead of\nloggingMinimal.zh. These are found near the bottom of the main file.  Some common errors:    Using more styles than alloted   Fixed by increasing  __TANGO_NUM_STYLES  and the size of  __Tango_Styles[]     Using more menu options than alloted   Fixed by increasing  __TANGO_MAX_MENU_ITEMS  and the size of  __Tango_Data[]     Incorrect constants for custom functions   Use  Tango_ConvertFunctionName()  to make sure you've got them right     You can also try calling the function  Tango_ValidateConfiguration() . This will\nanalyze your settings and report any errors it finds in allegro.log.",
            "title": "Why isn't my script working correctly?"
        },
        {
            "location": "/faq/index.html#how-do-i-display-a-string",
            "text": "Find a free text slot ( Tango_GetFreeSlot() )  Clear all data in the slot ( Tango_ClearSlot() )  Load text into the slot ( Tango_LoadString()  or  Tango_LoadMessage() )  Set a style ( Tango_SetSlotStyle() )  Set the position on the screen ( Tango_SetSlotPosition() )  Activate the text slot ( Tango_ActivateSlot() )   Tango_LoadString()  loads a ZScript string (an  int  array); Tango_LoadMessage()  loads a ZC message ( Quest > Strings ). All built-in\nfunction names follow this naming convention.  You'll probably want to combine these into a single function for simplicity.\ntangoQuickStart.zh provides examples in the  ShowString()  and  ShowMessage() \nfunctions.",
            "title": "How do I display a string?"
        },
        {
            "location": "/faq/index.html#what-is-a-text-slot",
            "text": "Text slots are where strings are stored for processing and display. They store\nthe text, the style, and the position on the screen, as well as some internal\ndata. Before any text can be shown on the screen, it must be loaded into\none of the available slots.  Slot IDs are integers counting up from 0. Most often, you'll want to find\na free slot automatically, but you can also use hardcoded slot numbers.\nEach slot has its own definition, which determines how long a string can be and\nhow much space is available for drawing it.",
            "title": "What is a text slot?"
        },
        {
            "location": "/faq/index.html#what-is-a-style",
            "text": "A style determines the appearance and behavior of displayed text. For instance,\nthe font, the backdrop, and whether the text can be sped up by holding A\nare all controlled by the style.  Style IDs are integers counting up from 0. Every text slot using the same style\nwill have the same appearance and behavior.",
            "title": "What is a style?"
        },
        {
            "location": "/faq/index.html#how-many-text-slots-do-i-need",
            "text": "You need at least as many slots as will ever be active at once. If you want\nfifty strings onscreen at once, you need fifty slots. If you only want one\nstring active at a time, just one slot will suffice.  For more advanced uses, you may want more slots than are strictly necessary.\nFor instance, you might want to reserve certain slots for specific purposes,\neven if they'll never all be in use at once.",
            "title": "How many text slots do I need?"
        },
        {
            "location": "/faq/index.html#how-do-i-add-more-text-slots",
            "text": "Set  __TANGO_NUM_SLOTS  to the number of slots you want and change the size of __Tango_Buffer[]  so that it's large enough to hold the text for all of them.  The slot definitions go in  __Tango_SlotDefs[] . The first seven numbers define\nslot 0, the next seven define slot 1, and so on. In order, these numbers are\nthe slot type, the starting index and size in  __Tango_Buffer[] , the X and Y\ncoordinates on the bitmap, and the width and height on the bitmap. For example:  int   __Tango_SlotDefs []   =   { \n     // Slot 0 \n     TANGO_SLOT_NORMAL ,   // The slot type \n     0 ,   512 ,     // Occupies __Tango_Buffer[0] to __Tango_Buffer[511] \n     0 ,   0 ,       // Draws to a region at 0, 0 on the bitmap \n     192 ,   128 ,   // Drawing region is 192x128 pixels \n\n     // Slot 1 \n     TANGO_SLOT_SMALL , \n     512 ,   64 ,   // Occupies __Tango_Buffer[512] to __Tango_Buffer[575] \n     0 ,   128 ,    // Draws to a region at 0, 128 (just below slot 0) \n     128 ,   32    // Drawing region is 128x32 \n\n     // Slot 2 \n     TANGO_SLOT_SMALL , \n     576 ,   64 ,   // Occupies __Tango_Buffer[576] to __Tango_Buffer[639] \n     0 ,   160 ,    // Draws to a region at 0, 160 (just below slot 1) \n     128 ,   32    // Drawing region is 128x32  };   The slot type is arbitrary. It can be any non-negative number. The default\nslot type,  TANGO_SLOT_NORMAL , can safely be renamed or deleted.  Generally, you shouldn't let slots overlap in the buffer or the bitmap.\nIf they won't be in use at the same time, however, it won't cause problems.\nIf you use a very large number of slots, it may even be necessary for them\nto share some space on the bitmap.",
            "title": "How do I add more text slots?"
        },
        {
            "location": "/faq/index.html#what-is-the-purpose-of-slot-types",
            "text": "A slot's type makes no difference to how it's handled internally. The only\nthing it actually affects is what's returned by  Tango_GetFreeSlot() . Slot\ntypes exist for users to create their own distictions. There are three reasons\nyou might use different slot types:    Reservation  In order to display a string, you must first have a free slot. If no slots\nare free, you can't show any text without clearing one out. If there's\nsomething you need to be able to display, you can create a dedicated slot\ntype for it, so there will always be a slot free when you need it.  For instance, suppose you want NPCs to spout random lines of dialog in the\nbackground. You might define several slots of type  SLOT_BG  to use for this\npurpose, and one of type  SLOT_FG  for the text box when Link talks to\nsomeone. This way, you can have the NPCs use as many  SLOT_BG  slots as they\nlike, and the main  SLOT_FG  will always be available when you need it.    Drawing order  Text slots are drawn to the screen in order from first to last. If you want\ncertain strings to be drawn above or below others, you can enforce this by\nusing different slot types.  Going back to the same example, you wouldn't want your NPCs' random lines\nto appear on top of the main text box. If slots 0-4 are  SLOT_BG  and\nslot 5 is  SLOT_FG , you can be sure the most important text will always\nbe on top.    Efficient use of space  If you plan to have one or two long strings appear alongside a lot of\nshort ones, you can use different slot types to avoid wasting space\nin  __Tango_Buffer[] . Because  __Tango_Buffer[]  is a global array,\nit is part of the quest's save data. Making it larger than necessary\ncauses useless data to be saved and loaded, making both take a little\nlonger (though only slightly). More importantly, there's limited space\nfor drawing on the offscreen bitmap. If you have ten slots all using\n192x128 pixels, they'll have to overlap, potentially causing graphical\nerrors.  If your random NPC dialog will only ever be a line or two, you can give SLOT_BG  a small amount of space in the buffer and bitmap, while  SLOT_FG \nmight have room for several hundred characters and space to draw a large\ntext box.    Ordinarily, it is expected that all slots of the same type have the same amount\nof space allocated in the buffer and on the bitmap, but this is not enforced.\nIf you want to make some  SLOT_BG s small and some large, you can do that, but\nit's up to you to ensure they're used correctly.",
            "title": "What is the purpose of slot types?"
        },
        {
            "location": "/faq/index.html#how-do-i-create-a-style",
            "text": "With a series of calls to  Tango_SetStyleAttribute() . Each call will set\na single attribute of the style. At a minimum, you must set a font and color\nfor the text. See  the constants page  for the available settings.\nCheck out tangoQuickStart.zh for an example.  If you want to unload a style after it's been set up, use  Tango_ClearStyle() .\nThis is only necessary if you want to reuse an ID for a different style,\nwhich is rarely done.",
            "title": "How do I create a style?"
        },
        {
            "location": "/faq/index.html#when-should-i-set-up-a-style",
            "text": "Any time before it's actually used is fine. The most common method is to set up\nall of your styles at the beginning of the active global script. It's also okay\nto do it in the  Init  script. Styles will stay set up until you clear them or\nchange them.  Another approach is to set a style up immediately before displaying a string\nthat uses it; this may be preferable when using a large number of different\nstyles.  A combination of those two methods is also possible. If you want multiple\nstyles that are mostly the same, you might set the common attributes\nin advance and set the distinct ones on demand.  Changing a style while it's in use is permitted, but changes to the text color\nand font will not affect any text that has already been printed.",
            "title": "When should I set up a style?"
        },
        {
            "location": "/faq/index.html#why-isnt-the-screen-freeze-style-flag-working",
            "text": "There are two functions in the main file,  __Tango_FreezeScreen()  and __Tango_UnfreezeScreen() , that are blank by default. In order for the\nscreen freeze style flag to work, you must implement these functions.  The reason that they're blank is that there isn't a reasonable default\nimplementation; they're too dependent on the quest. Grabbing arbitrary FFCs\nor changing combo definitions in an unknown quest might cause serious problems.  The recommended method is to set two unused FFCs to combos of type Screen Freeze (Except FFCs)  and  Screen Freeze (FFCs Only) . Be aware,\nhowever, that if an FFC script triggers this, that script will freeze, too.\nIf you're using ghost.zh,  SuspendGhostZHScripts()  and  ResumeGhostZHScripts() \nshould be used as well. Other headers may have similar suspend functions that\nshould also be included.",
            "title": "Why isn't the screen freeze style flag working?"
        }
    ]
}