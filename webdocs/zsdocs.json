{"vals":[[{"name":"--","val":"<h3>ZScript Web Documentation</h3>\n\nUse the <span id=\"debug\">panel</span> at the left to navigate."},{"name":"Data / Functions ;; function_root","val":"$-1$1"},{"name":"ZScript Mechanics ;; zsmechanics ;; ZScript Mechanics","val":"$ZSMechanics"},{"name":"ZQ Docs","val":"$-1$2"},{"name":"Changelogs","val":"$Versions"}],[{"name":"&lt;-- Top ;; top","val":"$0$0"},{"name":"--","val":""},{"name":"Global Functions ;; function_global ;; Global Functions","val":"$Global"},{"name":"Global Pointers ;; function_globalptr ;; Global Pointers","val":"$0$3"},{"name":"Data Pointers ;; function_data ;; Data Pointers","val":"$0$4"}],[{"name":"&lt;-- Top","val":"$0$0"},{"name":"--","val":""},{"name":"Output Console ;; allegro.log / console ;; Output Console","val":"<h3>Output Console</h3>\n\nThe term 'output console' can refer to multiple things. Generally, it refers to the actual zscript debugger console that can be opened in ZC via \"ZC -> Show ZScript Debugger\"; though it could also refer to the general log output, which is logged to \"allegro.log\".\n\nErrors and debug information are logged to the Output Console (some of which is only logged if certain quest rules are enabled), which the user can use to debug their scripts.\n\n${Logging Functions} can be used to directly output to the console."},{"name":"Message Strings ;; message string / message ;; Message Strings","val":"<h3>Message Strings</h3>\n\nEdited in 'Quest->Strings' in ZQuest, message strings represent messages that can be displayed on-screen to the player, including not only text, but also various formatting options, and ${SCCs|String Control Codes}.\n\nZScript can use ${messagedata} pointers to modify message strings directly."},{"name":"String Control Codes ;; SCCs ;; String Control Codes","val":"<h3>String Control Codes</h3> [[v|Rev July 17th, 2022 for 2.55 A107]] \n\nSpecial effects can be created when ${message strings} are displayed by inserting special control codes into the string. All valid codes are listed below.\n\n<h3>Formatting Codes</h3>\nThese codes have formatting effects on the string being displayed, such as changing the font, text color, or inserting characters or tiles into the message.\n#{<ul><li>`\\1\\cset\\color` : Changes the text color to the specified color.</li>\n<li>`\\26\\cset\\color` : Changes the shadow color to the specified color.</li>\n<li>`\\27\\[[shadow_type|$Shadow Type]]` : Changes the shadow type to the specified style.</li>\n<li>`\\2\\speed` : Changes the text speed. 'speed' is the number of frames between each character, where '0' is instantaneous.</li>\n<li>`\\25` : New Line - breaks to the next line</li>\n<li>`\\22` : Inserts the save file name as text</li>\n<li>`\\28\\tile\\cset\\[[width|In pixels]]\\[[height|In pixels]]\\flip` : Draws a tile block inline with the text, as though it were a custom font character.</li>\n<li>`\\32` through `\\126` : Inserts the corresponding ASCII character. Ex: `\\91` shows `\\`</li>\n<li>`\\24\\???` : Unimplemented; reserved for changing portrait</li></ul>}\n\n<h3>Menu Codes</h3>\nThese codes relate to popping up a menu for the player to select a choice from.\n#{<ul><li>`\\128\\tile\\cset\\width\\height\\flip` : Sets the menu cursor, args same as '\\28' above.</li>\n<li>`\\129\\pos\\up_pos\\down_pos\\left_pos\\right_pos` : Creates a menu cursor position. 'pos' is the index of this position, while the 4 directional values are the position that will be moved to when that direction is pressed. If a directional pos is the same as 'pos', that direction will be disabled.</li>\n<li>`\\130` : Start running menu. If no '\\129' codes have been run, the menu instantly exitswith the '0' pos selected.</li>\n<li>`\\131\\pos\\newstring` : Goto if menu selection. Switches to the new string if 'pos' is the selected menu position.</li></ul>}\n\n<h3>Switch Codes</h3>\nThese codes change from the current string immediately to a different string. If you attempt to switch to a string that does not exist, it will instead act as though you switched to a string that is entirely empty.\n#{<ul><li>`\\3\\register\\value\\newstring` : if `Screen->D[register] &gt;= value`, switches to `newstring`.</li>\n<li>`\\23\\dmap\\screen\\register\\value\\newstring` : Same as `\\3`, but for any screen.</li>\n<li>`\\4\\factor\\newstring` : Randomly has a `1/factor` chance to switch to `newstring`.</li>\n<li>`\\5\\itemid\\newstring` : Goes to `newstring` if the specified item is owned.</li>\n<li>`\\6\\counter\\value\\newstring` : Goto `newstring` if the specified counter is `>= value`.</li>\n<li>`\\7\\counter\\percent\\newstring` : Goto `newstring` if the specified counter is at least `percent` full.</li>\n<li>`\\8\\levelid\\newstring` : Goto `newstring` if the triforce from the specified level is owned.</li>\n<li>`\\9\\numtriforce\\newstring` : Goto `newstring` if at least `numtriforce` triforce pieces are owned.</li>\n<li>`\\131\\pos\\newstring` : Goto if menu selection. Switches to the new string if 'pos' is the selected menu position.</li></ul>}\n\n<h3>Counter Mod Codes</h3>\nThese codes all center around modifying counter values.\n#{<ul><li>`\\10\\ctr\\val` : Adds 'val' to 'ctr'.</li>\n<li>`\\11\\ctr\\val` : Subtracts 'val' from 'ctr'.</li>\n<li>`\\12\\ctr\\val` : Sets 'ctr' to 'val'.</li>\n<li>`\\13\\ctr\\percent` : Adds 'percent' % to 'ctr'.</li>\n<li>`\\14\\ctr\\percent` : Subtracts 'percent' % from 'ctr'.</li>\n<li>`\\15\\ctr\\percent` : Sets 'ctr' to 'percent' % full.</li>\n<li>`\\16\\itemid` : Gives the player 'itemid', silently. The item is not held up, nor does its' pickup script run; though its' counter effects will.</li>\n<li>`\\17\\itemid` : Takes 'itemid' from the player, silently. Its' pickup counter modifications will be reversed when removed.</li></ul>}\n\n<h3>Misc Codes</h3>\n#{<ul><li>`\\18\\dmap\\screen\\[[x\\y|<block>If `x &lt; 0`, then y is treated as a return square(0-3 for return squares A-D, 5 for pit warp).\nIf `x &gt;= 0`, then x+y act as destination coordinates.</block>]]\\[[effect|$WARPEFFECT_]]\\sound` : Warps the player to 'dmap,screen'.</li>\n<li>`\\19\\dmap\\screen\\register\\value` : Sets `Screen->D[register] = value;` for the specified screen.</li>\n<li>`\\20\\sfxid` : Plays a specified sfx</li>\n<li>`\\21\\MIDIid` : Plays a specified quest midi (cannot play the built-in midis)</li>\n<li>`\\29` : Immediately exits the current string. If there is a 'next string', it will begin immediately. The prompt to press 'A' to continue will be skipped.</li>\n<li>`\\30` : Pauses the string and prompts the player to press A to continue (as normally occurs at the end of a string)</li>\n<li>`\\132\\perm` : Triggers secrets, which are permanent unless 'perm' is '0'</li>\n<li>`\\133\\[[flag|Use the 'ST_' constants from 'std_constants.zh']]\\[[state|1 for on, 0 for off]]` : Sets a screen state on the current screen.</li>\n<li>`\\134\\map\\screen\\[[flag|Use the 'ST_' constants from 'std_constants.zh']]\\[[state|1 for on, 0 for off]]` : Same as \\133 above, for a remote map/screen</li></ul>}"}],[{"name":"&lt;-- Data / Functions ;; function_root","val":"$0$1"},{"name":"--","val":"Global Pointers have a single global instance which can be referenced anywhere."},{"name":"Game Pointer ;; gameptr ;; Game Pointer","val":"$Game"},{"name":"Hero Pointer ;; heroptr ;; Hero Pointer","val":"$Hero"},{"name":"Screen Pointer ;; screenptr ;; Screen Pointer","val":"$Screen"},{"name":"Input Pointer ;; inputptr ;; Input Pointer","val":"$Input"},{"name":"Audio Pointer ;; audioptr ;; Audio Pointer","val":"$Audio"},{"name":"Text Pointer ;; textptr ;; Text Pointer","val":"$Text"},{"name":"Graphics Pointer ;; graphicsptr ;; Graphics Pointer","val":"$Graphics"},{"name":"FileSystem Pointer ;; filesystemptr ;; FileSystem Pointer","val":"$FileSystem"}],[{"name":"&lt;-- Data / Functions ;; function_root","val":"$0$1"},{"name":"--","val":"Data Pointers must be loaded before they can be used. Each has its' own pointer type of which variables can be declared."},{"name":"FFC Pointers ;; ffcptr ;; FFC Pointers","val":"$FFC"},{"name":"Sprite Pointers ;; function_data_sprite ;; Sprite Pointers","val":"$-1$5"},{"name":"Misc Data Pointers ;; function_data_misc ;; Misc Data Pointers","val":"$-1$6"},{"name":"Managed Pointers ;; function_data_managed ;; Managed Pointers","val":"$-1$7"}],[{"name":"&lt;-- Data Pointers ;; function_data","val":"$0$4"},{"name":"--","val":"Sprite objects are a subset of object types which share a variety of attributes. These include weapons, npcs, items, etc."},{"name":"NPC Pointers ;; npcptr","val":"$NPC"}],[{"name":"&lt;-- Data Pointers ;; function_data","val":"$0$4"},{"name":"MapData Pointers ;; mapdataptr","val":"$MapData"},{"name":"BottleData Pointers ;; bottledataptr","val":"$BottleData"},{"name":"BottleShopData Pointers ;; bottleshopdataptr","val":"$BottleShopData"},{"name":"ComboData Pointers ;; comboptr","val":"$Combodata"},{"name":"DropsetData Pointers ;; dropsetdataptr","val":"$DropsetData"},{"name":"MessageData Pointers ;; messagedataptr","val":"$MessageData"},{"name":"ShopData Pointers ;; shopdataptr","val":"$ShopData"},{"name":"GenericData Pointers ;; genericdataptr ;; GenericData Pointers","val":"$GenericData"}],[{"name":"&lt;-- Data Pointers ;; function_data","val":"$0$4"},{"name":"--","val":"Managed Pointers all have a total maximum that can be in use at a time, and are only freed for re-use using `Free()` and `Own()` functions."},{"name":"RandGen Pointers ;; randgenptr ;; RandGen Pointers","val":"$RandGen"},{"name":"File Pointers ;; fileptr ;; File Pointers","val":"$File"},{"name":"Directory Pointers ;; directoryptr ;; Directory Pointers","val":"$Directory"},{"name":"Bitmap Pointers ;; bitmapptr ;; Bitmap Pointers","val":"$Bitmap"},{"name":"Stack Pointers ;; stackptr ;; Stack Pointers","val":"$Stack"}],[{"name":"&lt;-- Top ;; top","val":"$0$0"},{"name":"<em>Mechanics</em>","val":"This section is dedicated to the underlying mechanics of ZScript. This section will cover everything from the basics of `if`, `else`, `while`, `for`, etc all the way up to `class`, `namespace`, etc.\n\n<todo>Under construction!</todo>"}],[{"name":"&lt;-- Top ;; top","val":"$0$0"},{"name":"<em>Versions</em>","val":"<todo>Version Info</todo>"},{"name":"2.53 -&gt; 2.55 ;; changelog_253_255 / Changelog: 2.53 to 2.55","val":"<todo>Update changelog</todo>"}],[{"name":"&lt;-- Misc Data Pointers ;; function_data_misc","val":"$0$6"},{"name":"<em>combodata</em>","val":"<h3>ComboData Pointers</h3>   `combodata`\n\nThese pointers represent a combo ID, and all its' associated attributes.\n\nSee: ${LoadComboData}"},{"name":"ID ;; combodata::ID","val":"<h3>int ID;</h3>\nRead-only, the combo ID this combodata points to."},{"name":"Script Data ;; combodata::InitD / combodata::Script","val":"<h3>int Script;</h3>\nThe combo script that this combo runs.\n\n<h3>untyped InitD[2];</h3>\nThe 2 InitD[] values for the combo script."},{"name":"Graphics ;; combodata::Tile / combodata::OriginalTile / combodata::Frame / combodata::AClk / combodata::ASpeed / combodata::Frames / combodata::Flip / combodata::CSet2 / combodata::CSet2Flags / combodata::SkipAnimX / combodata::SkipAnimY / combodata::AnimFlags","val":"<h3>int Tile;</h3>\nThe tile currently being displayed by the combo. This is automatically overwritten each frame by the engine.\n\n<h3>int Frame;</h3>\nThe current animation frame the combo is on in its' animation. Set to 0 to reset to start of animation.\n\n<h3>int AClk;</h3>\nThe animation clock of the combo. Set to 0 to reset the timer.\n\n<h3>int OriginalTile;</h3>\nThe 'Original Tile' of the combo, used as the start of its' animation.\n\n<h3>int Frames;</h3>\nThe number of frames in the combo animation before it loops.\n\n<h3>int ASpeed;</h3>\nThe combo animation speed.\n\n<h3>int SkipAnimX;</h3>\nThe number of extra tiles to move horizontally between each frame.\n\n<h3>int SkipAnimY;</h3>\nThe number of extra tiles to move vertically, when the horizontal movement goes past the end of a tile row.\n\n<h3>int AnimFlags;</h3>\nBitwise access to the combo's animation flags. Use the [[`AF_` constants|$AF_]] to access.\n\n<h3>int Flip;</h3>\nThe combo's flip value. Use the `FLIP_` or `ROT_` constants from `std_constants.zh` for this value.\n\n<h3>int CSet2;</h3>\nThe CSet2 offset for this combo.\n\n<h3>int CSet2Flags;</h3>\nBitwise access to the 4 corners of the cset2 square. <todo>Untested!</todo>"},{"name":"Script-Specific ;; combodata::X / combodata::Y / combodata::Pos / combodata::Layer","val":"These attributes are ONLY usable on the `this` pointer in a `combodata script`.\n\n<h3>int X;\nint Y;\nint Layer;\nint Pos;</h3>\nRead-only. Gives the X, Y, Layer, and Combo Pos of the combo running this script."},{"name":"Effects ;; combodata::Walk / combodata::Effect / combodata::Type / combodata::Flag","val":"<h3>int Walk;</h3>\nThe solidity bitmask of the combo (same as ${Screen::ComboS[]|Screen-&gt;ComboS[]})\n\n<h3>int Effect;</h3>\nThe effect bitmask of the combo (same as ${Screen::ComboE[]|Screen-&gt;ComboE[]})\n\n<h3>int Type;</h3>\nThe ${combotypes|combo type} of the combo. Use the `CT_` constants from `std_constants.zh`.\n\n<h3>int Flag;</h3>\nThe ${mapflags|inherent flag} of the combo. Use the `CF_` constants from `std_constants.zh`."},{"name":"Cycling ;; combodata::NextData / combodata::NextCSet","val":"<h3>int NextData;</h3>\nIf `&gt; 0`, cycling is enabled for this combo. When the combo's animation would normally loop, instead the combo will change to the `NextData` combo.\n\n<h3>int NextCSet;</h3>\nIf the ${combodata::AnimFlags|animation flag} `AF_CYCLENOCSET` is NOT set, the combo will change to this cset when it cycles."},{"name":"Attributes / Flags ;; combodata::Attributes / combodata::Attrishorts / combodata::Attribytes / combodata::Flags / combodata::GenFlags","val":"<h3>untyped Attribytes[8];</h3>\nThe 8 combo attribytes. These have a byte-sized range, `0 to 255`. Their effect depends on the combo type.\n\n<h3>untyped Attrishorts[8];</h3>\nThe 8 combo attrishorts. These have a short-sized range, `-32768 to 32767`. Their effect depends on the combo type.\n\n<h3>untyped Attributes[4];</h3>\nThe 4 combo attributes. These have a full range (all zscript values, including decimal). Their effect depends on the combo type.\n\n<h3>bool Flags[16];</h3>\nThe 16 combo flags. Their effect depends on the combo type.\n\n<h3>bool GenFlags[];</h3>\nThe combo generic flags, specified by the [[`GENFLAG_` constants|$GENFLAG_]]."},{"name":"Combo Triggers ;; combodata::TrigCSetChange / combodata::TrigSpawnItem / combodata::TrigSpawnEnemy / combodata::TrigExState / combodata::TrigSpawnItemPickup / combodata::TrigCopycat / combodata::TrigCooldown / combodata::TriggerCtrAmount / combodata::TriggerCounter / combodata::TriggerLightBeam / combodata::TriggerProximity / combodata::TriggerChange / combodata::TriggerSFX / combodata::TriggerTimer / combodata::TriggerItem / combodata::TriggerLevel / combodata::TriggerButton[] / combodata::TrigFlags[] ;; Combo Triggers","val":"<h3>bool TrigFlags[];</h3>\nThe combo's Trigger Flags, accessed with the `TRIGFLAG_` constants.\n#{TRIGFLAG_ constants|$[TRIGFLAG_]}\n\n<h3>bool TriggerButton[];</h3>\n[[Which buttons|$INTBTN_]] will trigger this combo (Which directions this works from is determined by `TRIGFLAG_BTN_` triggerflags)\n\n<h3>int TriggerLevel;</h3>\nThe min level (or max, if `TRIGFLAG_INVERT_MIN_MAX` is set) of Weapon that can trigger this combo.\n\n<h3>int TriggerItem;</h3>\nNote: This is a [[$Trigger Requirement]], not a trigger.\nThe required item ID for triggering the combo. If `0`, no item is required.\nIf `TRIGFLAG_INVERT_ITEMREQ` is set, the item must NOT be owned to trigger instead.\nIf `TRIGFLAG_CONSUME_ITEMREQ` is set, the item will be consumed upon triggering.\n\n<h3>int TriggerTimer;</h3>\nThe trigger timer. If `&gt; 0`, the combo triggers every this many frames.\n\n<h3>int TriggerSFX;</h3>\nThe SFX to play when triggering the combo.\n\n<h3>int TriggerChange;</h3>\nThe amount the combo will change by when triggered.\n\n<h3>int TrigCSetChange;</h3>\nThe amount the cset will change by when triggered.\n\n<h3>int TriggerProximity;</h3>\nNote: This is a [[$Trigger Requirement]], not a trigger.\nThe combo will only trigger if the player's distance from the combo is `&lt;=` this distance.\nIf 0, proximity requirement is disabled.\nIf `TRIGFLAG_INVERT_PROXIMITY` is set, the player's distance must be `&gt;` this distance instead.\n\n<h3>int TriggerLightBeam;</h3>\nThe light beam ID that this combo interacts with. 0 interacts with all beams, 1 to 32 interact only with matching beams.\nThis only has any effect if `TRIGFLAG_LIGHTON` or `TRIGFLAG_LIGHTOFF` is set.\n\n<h3>int TriggerCounter;</h3>\nThe counter used for counter-based trigger flags.\n<h3>int TriggerCtrAmount;</h3>\nThe counter amount used for counter-based trigger flags.\n\n<h3>int TrigCooldown;</h3>\nThe combo (assuming it does not change on trigger) will be unable to trigger again for this many frames after triggering.\n\n<h3>int TrigCopycat;</h3>\nIf `&gt; 0`, when this combo is triggered, it will trigger all other combos on screen with the same `TrigCopycat` value.\n\n<h3>int TrigExState;</h3>\nIf `&gt; -1`, the ExState this combo is linked to.\n\n<h3>int TrigSpawnEnemy;</h3>\nIf `&gt; 0`, this enemy ID will be spawned when the combo triggers.\n\n<h3>int TrigSpawnItem;</h3>\nIf `&gt; 0`, this item ID will be spawned when the combo triggers.\nIf `&lt; 0`, an item from this dropset ID will be chosen to be spawned when the combo triggers.\n\n<h3>int TrigSpawnItemPickup;</h3>\nThe `-&gt;Pickup` flags for the spawned item.\nOnly `IP_HOLDUP`, `IP_TIMEOUT`, `IP_TRIGGERSECRETS`, and `IP_ALWAYSGRAB` are valid."},{"name":"Lifting ;; combodata::LiftTime / combodata::LiftHeight / combodata::LiftBreakSFX / combodata::LiftBreakSprite / combodata::LiftSFX / combodata::LiftGFXSprite / combodata::LiftGFXType / combodata::LiftFlags[] / combodata::LiftItem / combodata::LiftLevel / combodata::LiftDamage / combodata::LiftUnderCSet / combodata::LiftUnderCombo / combodata::LiftGFXCSet / combodata::LiftGFXCombo ;; Combo Lifting","val":"<h3>int LiftGFXType;</h3>\nWhat GFX to use to display the lifted object.\n#{LIFTGFX_ constants|$[LIFTGFX_]}\n\n<h3>int LiftGFXCombo;\nint LiftGFXCSet;</h3>\nThe GFX combo/cset used to display the object, if 'Other Combo GFX' is the GFX mode.\nThe combo's CSet is used instead if `LF_NOWPNCMBCSET` is set.\n\n<h3>int LiftGFXSprite;</h3>\nThe GFX sprite used to display the object, if 'Sprite Data GFX' is the GFX mode.\n\n<h3>int LiftBreakSprite;</h3>\nThe Sprite Data sprite displayed when the object breaks.\n\n<h3>int LiftUnderCombo;\nint LiftUnderCSet;</h3>\nThe combo/cset that will be left behind when this combo is lifted.\nIf `LF_NOUCSET` is set, the undercset will not be used, instead leaving the combo's cset.\n\n<h3>int LiftDamage;</h3>\nThe weapon damage of the thrown object.\n\n<h3>int LiftLevel;</h3>\nThe minimum lift glove level required to lift this object.\n\n<h3>int LiftItem;</h3>\nIf `&gt; 0`, drops this item ID.\nDrops the item upon breaking, unless `LF_DROPONLIFT` is set, in which case it drops upon lifting.\nIf `LF_DROPSET` is set, this number is a dropset to choose an item from, instead of an item ID.\nIf `LF_SPECIALITEM` is set, this item is treated as the room's Special Item.\n\n<h3>int LiftSFX;</h3>\nThe SFX played on lifting.\n<h3>int LiftBreakSFX;</h3>\nThe SFX played on breaking.\n\n<h3>int LiftHeight;</h3>\nThe height above the player's head to lift the object.\n\n<h3>int LiftTime;</h3>\nThe number of frames it takes to lift the object to its' full height.\n\n<h3>int LiftFlags[];</h3>\nThe combo lift flags.\n#{LF_ constants|$[LF_]}"}],[{"name":"&lt;-- Sprite Pointers ;; function_data_sprite","val":"$0$5"},{"name":"<em>npc</em>","val":"<h3>NPC Pointers</h3>   `npc`\n\nThese pointers represent an enemy on the screen, and its' various attributes and functions.\nUsing these pointers, you can move them, damage them, make them move, make them invincible, etc.\n\nSee: ${LoadNPC}, ${CreateNPC}"},{"name":"Position","val":"<h3>int X; int Y; int Z;</h3>\n\nRead/Write; These values store the enemy's position on each of the three axes.\nIf the quest rule [['Sprite Coordinates are Float'|at \"ZScript->Quest Script Settings->Object\"]] is checked, these values can include up to 4 decimal places; otherwise values are truncated to int."},{"name":"Movement ;; npcMovement","val":"$-1$1"},{"name":"More Under Construction....","val":""}],[{"name":"&lt;-- NPC Pointers","val":"$-1$0"},{"name":"--","val":"<h3>NPC Movement</h3>\n\nThese functions relate to npc movement."},{"name":"<u>Script Movement</u>","val":""},{"name":"MoveXY","val":"<h3>bool MoveXY(float dx, float dy, int special);\nbool CanMoveXY(float dx, float dy, int special);</h3>\n\nAttempts to move the enemy by 'dx' in the x direction and 'dy' in the y direction, failing if it is blocked by something it cannot walk through.\n\nUse the 'SPW_' constants for 'int special'; i.e. 'SPW_FLOATER' to indicate a flying enemy.\n\nReturns true if the enemy moves the full distance, false if the enemy was blocked at all.\n\nThe 'CanMoveXY' variant will not actually move the enemy at all, but will run the collision checks and return true if it <em>CAN</em> move the full distance, or false if it <em>WOULD</em> be blocked."},{"name":"Move","val":"<h3>bool Move(int dir, float pxamnt, int special);\nbool CanMove(int dir, float pxamnt, int special);</h3>\n\nAttempts to move the enemy by 'pxamnt' pixels in the 'dir' direction, failing if it is blocked by something it cannot walk through.\n\nUse the 'SPW_' constants for 'int special'; i.e. 'SPW_FLOATER' to indicate a flying enemy.\n\nReturns true if the enemy moves the full distance, false if the enemy was blocked at all.\n\nThe 'CanMove' variant will not actually move the enemy at all, but will run the collision checks and return true if it <em>CAN</em> move the full distance, or false if it <em>WOULD</em> be blocked."},{"name":"MoveAtAngle","val":"<h3>bool MoveAtAngle(float degrees, float pxamnt, int special);\nbool CanMoveAtAngle(float degrees, float pxamnt, int special);</h3>\n\nAttempts to move the enemy by 'pxamnt' pixels in the 'degrees' angle, failing if it is blocked by something it cannot walk through.\n\nUse the 'SPW_' constants for 'int special'; i.e. 'SPW_FLOATER' to indicate a flying enemy.\n\nReturns true if the enemy moves the full distance, false if the enemy was blocked at all.\n\nThe 'CanMoveAtAngle' variant will not actually move the enemy at all, but will run the collision checks and return true if it <em>CAN</em> move the full distance, or false if it <em>WOULD</em> be blocked."},{"name":"MovePaused","val":"<h3>bool MovePaused();</h3>\n\nReturns true if the enemy is in a state in which it should not be allowed to move (ex. spawning, dying, stunned, time frozen by clock)\nReturns false otherwise."},{"name":"Knockback","val":"<h3>bool Knockback(int time, int dir, int speed);</h3>\n\nAttempt to knock back the npc in 'dir' direction, for 'time' frames, at a rate of 'speed' pixels per frame.\n\nReturns true if successful, false if the enemy could not be knocked back.\n\nRelated: ${NoScriptKnockback|bool npc->NoScriptKnockback;}"},{"name":"<u>Variables</u>","val":""},{"name":"NoScriptKnockback","val":"<h3>bool NoScriptKnockback;</h3>\n\nFalse by default. If set to 'true', scripted knockback via '${Knockback|npc->Knockback()}' is ignored."}],[{"name":"&lt;-- Global Pointers ;; function_globalptr","val":"$0$3"},{"name":"<em>Game</em>","val":"The `Game->` pointer holds many general internal functions and variables."},{"name":"Current Position ;; Game::CurLevel / Game::CurDMap / Game::CurMap / Game::CurDMScreen / Game::CurDMapScreen / Game::CurScreen / Game::GetCurLevel / Game::GetCurDMap / Game::GetCurMap / Game::GetCurDMapScreen / Game::GetCurScreen","val":"<h3>int CurScreen;\nint GetCurScreen();</h3>\nReturns the screen the player is currently on.\n\n<h3>int CurDMapScreen;\nint CurDMScreen;\nint GetCurDMapScreen();</h3>\nReturns the screen the player is currently on, offset by the current dmap offset.\n\n<h3>int CurMap;\nint GetCurMap();</h3>\nReturns the map the player is currently on.\n\n<h3>int CurDMap;\nint GetCurDMap();</h3>\nReturns the dmap the player is currently on.\n\n<h3>int CurLevel;\nint GetCurLevel();</h3>\nReturns the level the player is currently on."},{"name":"Counters ;; Game::Counter / Game::MCounter / Game::DCounter","val":"<h3>int Counter[NUM_COUNTERS];</h3>\n\nThe value of each of the game's counters (using [[`CR_`|$Counter]] constants). Values `0 to 65535`.\n\n<h3>int MCounter[NUM_COUNTERS];</h3>\n\nThe max value of each of the game's counters (using [[`CR_`|$Counter]] constants). Values `0 to 65535`.\n\n<h3>int DCounter[NUM_COUNTERS];</h3>\n\nThe value of each of the game's drain counters (using [[`CR_`|$Counter]] constants). Values `-32768 to 32767`.\nThese will approach 0 each frame, adding or subtracting from the matching `Counter[]`."},{"name":"Misc Arrays ;; Game::Misc / Game::Misc2 / Game::Misc3","val":"<h3>untyped Misc[32];\nuntyped Misc2[256];\nuntyped Misc3[256];</h3>\n\n3 misc data arrays."},{"name":"Basic Loaders ;; Game::LoadGenericData / Game::LoadBottleShopData / Game::LoadBottleData / Game::LoadDropset / Game::LoadDMapData / Game::LoadMessageData / Game::LoadInfoShopData / Game::LoadShopData / Game::LoadSpriteData / Game::LoadComboData / Game::LoadNPCData / Game::LoadItemData ;; LoadItemData / LoadNPCData / LoadComboData / LoadSpriteData / LoadShopData / LoadInfoShopData / LoadMessageData / LoadDMapData / LoadDropset / LoadBottleData / LoadBottleShopData / LoadGenericData","val":"<h3>${itemdata} LoadItemData(int item_id);</h3>\n<h3>${npcdata} LoadNPCData(int npc_id);</h3>\n<h3>${combodata} LoadComboData(int combo_id);</h3>\n<h3>${spritedata} LoadSpriteData(int misc_spr_id);</h3>\n<h3>${shopdata} LoadShopData(int shop_id);</h3>\n<h3>${shopdata} LoadInfoShopData(int shop_id);</h3>\n<h3>${messagedata} LoadMessageData(int string_id);</h3>\n<h3>${dmapdata} LoadDMapData(int dmap_id);</h3>\n<h3>${dropsetdata} LoadDropset(int dropset_id);</h3>\n<h3>${bottledata} LoadBottleData(int bottle_type_id);</h3>\n<h3>${bottleshopdata} LoadBottleShopData(int bottleshop_id);</h3>\n<h3>${genericdata} LoadGenericData(int generic_script_id);</h3>\n\nThese functions load the specified pointer, returning `NULL` on a failure."},{"name":"Other Loaders ;; Game::LoadStack / Game::LoadRNG / Game::LoadBitmapID / Game::CreateBitmap / Game::AllocateBitmap / Game::LoadScrollingScreen / Game::LoadTempScreen / Game::LoadMapData ;; LoadMapData / LoadTempScreen / LoadScrollingScreen / LoadBitmapID / CreateBitmap / AllocateBitmap / LoadRNG / LoadStack","val":"<h3>${mapdata} LoadMapData(int map, int screen);</h3>\n\nLoads the mapdata pointer for the screen at `(map,screen)`. Edits to these pointers do not persist through quest exit. Edits to these pointers will NOT affect the \"current screen\", even if the current map/screen is supplied; see `LoadTempScreen()` below for that.\n\n<h3>${mapdata} LoadTempScreen(int layer);</h3>\n\nLoads the temp mapdata pointer for the specified layer. `LoadTempScreen(0)` gives a pointer that works mostly the same as `Screen->`, while passing 1 through 6 will give equal access to the other layers of the screen. Modifications to these pointers are reset when the screen changes.\n\n<h3>${mapdata} LoadScrollingScreen(int layer);</h3>\n\nLoads the temp mapdata pointer for the specified layer's *scrolling screen*. This is only used during scrolling, for drawing the screen you just came from during the scrolling animation. Writing to this at any time other than during scrolling will have no effect.\n\n<h3>${bitmap} CreateBitmap(int width = 256, int height = 256);</h3>\n\nAllocates a new bitmap pointer, creating a `width by height` canvas (cleared to color 0). Be sure to `Free()` it when you are done, or `Own()` it to attach it to a script!\n\nIf [[\"Old Args for CreateBitmap and bitmap->Create()\"|at \"ZScript->Quest Script Settings->Instructions\"]] is enabled, then `width` and `height` are swapped with each other.\n\n<h3>${bitmap} AllocateBitmap();</h3>\n\nAllocates a new bitmap pointer, but does not create a canvas on it. ${bitmap::Create|bitmap->Create()} can later be used to create a canvas on the pointer. Be sure to `Free()` it when you are done, or `Own()` it to attach it to a script!\n\n<h3>${bitmap} LoadBitmapID([[int render_target|`RT_` constants]]);</h3>\n\nLoads a `bitmap` pointer for one of the old-style render target `RT_` bitmaps.\n<todo>Unsure if these have been tested to work properly?</todo>\n\n<h3>${randgen} LoadRNG();</h3>\n\nLoads an unused `randgen` pointer. Be sure to `Free()` it when you are done, or `Own()` it to attach it to a script!\n\n<h3>${stack} LoadStack();</h3>\n\nLoads an unused `stack` pointer. Be sure to `Free()` it when you are done, or `Own()` it to attach it to a script!"},{"name":"String Getters ;; Game::GetDMap / Game::GetCombo / Game::GetItem / Game::GetNPC / Game::GetGenericScript / Game::GetItemSpriteScript / Game::GetScreenScript / Game::GetDMapScript / Game::GetGlobalScript / Game::GetPlayerScript / Game::GetEWeaponScript / Game::GetLWeaponScript / Game::GetNPCScript / Game::GetItemScript / Game::GetComboScript / Game::GetFFCScript ;; GetFFCScript / GetComboScript / GetItemScript / GetNPCScript / GetLWeaponScript / GetEWeaponScript / GetPlayerScript / GetGlobalScript / GetDMapScript / GetScreenScript / GetItemSpriteScript / GetGenericScript / GetNPC / GetItem / GetCombo / GetDMap","val":"<h3>int GetFFCScript(char32 name[]);</h3>\n<h3>int GetComboScript(char32 name[]);</h3>\n<h3>int GetItemScript(char32 name[]);</h3>\n<h3>int GetNPCScript(char32 name[]);</h3>\n<h3>int GetLWeaponScript(char32 name[]);</h3>\n<h3>int GetEWeaponScript(char32 name[]);</h3>\n<h3>int GetPlayerScript(char32 name[]);</h3>\n<h3>int GetGlobalScript(char32 name[]);</h3>\n<h3>int GetDMapScript(char32 name[]);</h3>\n<h3>int GetScreenScript(char32 name[]);</h3>\n<h3>int GetItemSpriteScript(char32 name[]);</h3>\n<h3>int GetGenericScript(char32 name[]);</h3>\n\nGets the script of the specified type with a name exactly matching `name`. If no such script exists, returns `-1`.\n\n<h3>int GetNPC(char32 name[]);</h3>\n<h3>int GetItem(char32 name[]);</h3>\n<h3>int GetCombo(char32 name[]);</h3>\n<h3>int GetDMap(char32 name[]);</h3>\n\nGets the ID of the npc/item/combo/dmap whose name exactly matches `name`. If no such object exists, returns `-1`."},{"name":"Version Checking ;; Game::ZScriptVersion / Game::Version / Game::Build / Game::Beta / Game::BetaType","val":"<h3>int Version;</h3>\n\nRead-only. The current version of ZC that the quest is being played in (ex: \"2.55\" for 2.55)\n\n<h3>int Build;</h3>\n\nRead-only. The current Build ID of ZC that the quest is being played in.\n\n<h3>int Beta;</h3>\n\nRead-only. The current detailed version; this can be the current Alpha, Beta, Gamma, or Release number, depending on the version of the program.\nFor nightlies, returns a half-measure; ex. \"Nightly A111/A112\" would return \"111.5\".\n\n<h3>int BetaType;</h3>\n\nRead-only. What type of detailed version the program is in. `0 = Alpha`, `1 = Beta`, `2 = Gamma`, `3 = Release`, `-1 = error`.\n\n<h3>int ZScriptVersion;</h3>\n\nThe ZScript version number the quest was last compiled in."},{"name":"Level Items ;; Game::LItems / Game::LKeys","val":"<h3>int LKeys[NUM_LEVELS];</h3>\n\nHow many level-specific keys are owned for each level.\n\n<h3>int LItems[NUM_LEVELS];</h3>\n\nContains a bitwise flagset of the \"Level Items\".\n<ul>\r\n<li>LI_TRIFORCE = 0x01</li>\r\n<li>LI_MAP = 0x02</li>\r\n<li>LI_COMPASS = 0x04</li>\r\n<li>LI_BOSS = 0x08</li>\r\n<li>LI_BOSSKEY = 0x10</li>\n</ul>"},{"name":"--&gt; Next ;;gameptr2","val":"$-1$1"},{"name":"--&gt;&gt; End ;;gameptr3","val":"$-1$2"}],[{"name":"&lt;-- Global Pointers ;; function_globalptr","val":"$0$3"},{"name":"Switches ;; Game::LSwitches / Game::GSwitches","val":"<h3>long LSwitches[NUM_LEVELS];</h3>\n\nThe level-specific switch states for each level. Each level has a single `long`, representing 32 bitwise states. Ex: `(Game-&gt;LSwitches[Game-&gt;CurLevel] & (1Lb &lt;&lt; (5)))` will get the switch state indexed '5'.\n\n<h3>int GSwitch[256];</h3>\n\nThe 256 global switch timers.\nA value of `0` represents an \"off\" switch.\nA value of `-1` represents an \"on\" switch.\nA value `&gt; 0` represents a \"timed\" switch, which will remain on for that many more frames."},{"name":"Game Arrays ;; Game::BottleState / Game::Generic / Game::Suspend / Game::Gravity / Game::Scrolling / Game::MiscSFX / Game::MiscSprites","val":"<h3>int MiscSprites[MISCSPR_MAX]</h3>\nThe `Quest->Graphics->Sprites->Misc Sprites` values, accessed with the `MISCSPR_` constants.\n\n<h3>int MiscSFX[MISCSFX_MAX]</h3>\nThe `Quest->Audio->Misc SFX` values, accessed with the `MISCSFX_` constants.\n\n<h3>int BottleState[256]</h3>\nThe contents of the player's fillable bottles. Use bottle type IDs for the values, and slots (set in the bottle item's attributes) as the indexes.\n\n<h3>int Scrolling[5]</h3>\nRead-only; values related to scrolling.\n#{Values|<ol start=\"0\">\n<li>SCROLL_DIR: The direction the screen is scrolling, -1 while not scrolling.</li>\n<li>SCROLL_NX: The top-left X offset of the 'new' screen during scrolling.</li>\n<li>SCROLL_NY: The top-left Y offset of the 'new' screen during scrolling.</li>\n<li>SCROLL_OX: The top-left X offset of the 'old' screen during scrolling.</li>\n<li>SCROLL_OY: The top-left Y offset of the 'old' screen during scrolling.</li>\n</ol>}\n\n<h3>int Gravity[3]</h3>\nValues related to gravity.\n#{Values|<ol start=\"0\">\n<li>GR_STRENGTH: The strength of gravity.</li>\n<li>GR_TERMINALV: The terminal velocity.</li>\n<li>GR_SPRLAYER: The sprite layer threshold.</li>\n</ol>}\n\n<h3>untyped Generic[GEN_MAX]</h3>\nGeneric values related to the game.\n#{Values|<ol start=\"0\">\n<li>GEN_HEARTPIECES: The number of heart pieces currently owned.</li>\n<li>GEN_MAGICDRAINRATE: The magic drain multiplier. Lowered when half magic is acquired.</li>\n<li>GEN_CANSLASH: Bool, whether or not the player can slash with swords.</li>\n<li>GEN_WARPLEVEL: The current whistle warp ring. This is set every time the whistle is used.</li>\n<li>GEN_HCPPERHC: How many heart pieces make a heart container.</li>\n<li>GEN_CONTINUEHEARTS: The [[amount of life|Either in HP, or in percentage of max HP out of 100, depending on the value of `GEN_CONTINUEISPERCENT`]] the player `Continue`'s with.</li>\n<li>GEN_CONTINUEISPERCENT: Bool, whether the [[above|`GEN_CONTINUEHEARTS`]] value is a percentage of max life or not.</li>\n<li>GEN_HP_PER_HEART: The number of HP per heart.</li>\n<li>GEN_MP_PER_BLOCK: The number of MP per block.</li>\n<li>GEN_HERO_DMG_MULT: The damage multiplier for damage dealt by the player.</li>\n<li>GEN_ENEM_DMG_MULT: The damage multiplier for damage dealt by enemies.</li>\n<li>GEN_DITHER_TYPE: The dither type used by ${Dark Rooms|engine dark rooms}.</li>\n<li>GEN_DITHER_ARG: The dither arg used by ${Dark Rooms|engine dark rooms}.</li>\n<li>GEN_DITHER_PERCENT: The percentage of light circles taken up by dithering in ${Dark Rooms|engine dark rooms}.</li>\n<li>GEN_DEFAULT_LIGHT_RAD: The default light radius of enemies in ${Dark Rooms|engine dark rooms}.</li>\n<li>GEN_TRANS_PERCENT: The percentage of light circles taken up by transparency in ${Dark Rooms|engine dark rooms}.</li>\n<li>GEN_DARKNESS_COLOR: The color index of darkness in ${Dark Rooms|engine dark rooms}.</li>\n<li>GEN_WATERGRAVITY: The gravity when not moving while in sideview swimming water. Can be negative.</li>\n<li>GEN_SIDESWIM_STEP_UP: The hero's sideswim step speed in the up direction.</li>\n<li>GEN_SIDESWIM_STEP_SIDE: The hero's sideswim step speed in the side directions.</li>\n<li>GEN_SIDESWIM_STEP_DOWN: The hero's sideswim step speed in the down direction.</li>\n<li>GEN_SIDESWIM_EXITJUMP: The jump value given when exiting sideview water from the top. If 0, can only leave water via a ladder.</li>\n<li>GEN_BUNNY_TILEMOD: The player tile modifier added when the ${Hero::BunnyClk|bunny status effect} is active.</li>\n<li>GEN_SWITCHHOOK_STYLE: Which `SW_EFF` style to use by [[default|Used for the enemy defense 'Switch w/ Player']] for switch hook effects.</li>\n</ol>}\n\n<h3>bool Suspend[susptLAST]</h3>\nAn array of suspend states, all false by default. By writing these true, certain game operations may be paused until the state is written false again.\n#{Values|<ol start=\"0\">\n<li>susptCOMBOANIM</li>\n<li>susptGUYS</li>\n<li>susptLWEAPONS</li>\n<li>susptEWEAPONS</li>\n<li>susptITEMS</li>\n<li>susptLINK</li>\n<li>susptUPDATEFFC</li>\n<li>susptDECORATIONS</li>\n<li>susptPARTICLES</li>\n<li>susptPALCYCLE</li>\n<li>susptLAKES</li>\n<li>susptCOLLISIONS</li>\n<li>susptCONTROLSTATE</li>\n<li>susptONEFRAMECONDS</li>\n<li>susptSCRIPDRAWCLEAR</li>\n<li>susptQUAKE</li>\n<li>susptGLOBALGAME</li>\n<li>susptNPCSCRIPTS</li>\n<li>susptLWEAPONSCRIPTS</li>\n<li>susptEWEAPONSCRIPTS</li>\n<li>susptITEMSPRITESCRIPTS</li>\n<li>susptFFCSCRIPTS</li>\n<li>susptLINKACTIVE</li>\n<li>susptITEMSCRIPTENGINE</li>\n<li>susptDMAPSCRIPT</li>\n<li>susptSCREENSCRIPTS</li>\n<li>susptSUBSCREENSCRIPTS</li>\n<li>susptCOMBOSCRIPTS</li>\n<li value=\"60\">susptCONVEYORSITEMS</li>\n<li>susptDRAGGINGITEM</li>\n<li>susptROAMINGITEM</li>\n<li>susptLENS</li>\n<li>susptHOOKSHOT</li>\n<li>susptMOVINGBLOCKS</li>\n<li>susptMAGICCAST</li>\n<li>susptSCREENDRAW</li>\n</ol>}"},{"name":"FFRules ;; Game::FFRules ;; FFRules","val":"<h3>bool FFRules[qr_MAX];</h3>\nThe values of all Quest Rules. Access this array using the `qr_` constants in `include/std_zh/ffrules.zh`.\nAccessing indexes that do not have constants is undefined."},{"name":"EventData ;; Game::Eventdata ;; EventData","val":"<h3>untyped EventData[];</h3>\nA variably-sized array containing information about the current event. This should be accessed from ${genericdata|Generic Scripts} after returning from ${WaitEvent|WaitEvent()}. Depending on what event WaitEvent() returns, a different set of constants should be used to access this array.\n\nValid events and their index constants:\n\n#{'GENSCR_EVENT_HERO_HIT_1' or 'GENSCR_EVENT_HERO_HIT_2'|Player hit, before/after ring defense applied.\n<ol start=\"0\">\n<li>GENEV_HEROHIT_DAMAGE: An int, amount of damage to be taken.</li>\n<li>GENEV_HEROHIT_HITDIR: An int, the dir to be knocked in.</li>\n<li>GENEV_HEROHIT_NULLIFY: A bool, false by default. Write true to nullify the hit.</li>\n<li>GENEV_HEROHIT_NAYRUON: A bool, if the shield spell is currently protecting the player from damage.</li>\n<li>GENEV_HEROHIT_IFRAMES: An int, the number of Invincibility Frames to give the player after the hit.</li>\n<li>GENEV_HEROHIT_HITTYPE: An [[`OBJTYPE_`|$OBJTYPE_]] value representing the type of the next value.</li>\n<li>GENEV_HEROHIT_HITOBJ: The object that hit the player. The `_HITTYPE` above tells you what type of object pointer this should be cast to.</li>\n</ol>}\n#{'GENSCR_EVENT_COLLECT_ITEM'|Item collected by player\n<ol start=\"0\">\n<li>GENEV_ITEMCOL_ID: The item ID to be picked up</li>\n<li>GENEV_ITEMCOL_PICKUP: The item's 'pickup' flags</li>\n<li>GENEV_ITEMCOL_PSTR: The item's 'pickup string'</li>\n<li>GENEV_ITEMCOL_PSTRFLAGS: The item's 'pickup string flags'</li>\n<li>GENEV_ITEMCOL_NULLIFY: bool, set to true to cancel the item pickup</li>\n<li>GENEV_ITEMCOL_ITEMPTR: The `itemsprite` pointer of the item being collected</li>\n<li>GENEV_ITEMCOL_TYPE: A [[GENEVT_ICTYPE_|<ol start = \"0\">\n<li>GENEVT_ICTYPE_COLLECT: The player touched the item</li>\n<li>GENEVT_ICTYPE_MELEE: A melee lweapon collected the item</li>\n<li>GENEVT_ICTYPE_MELEE_EW: A melee eweapon collected the item</li>\n<li>GENEVT_ICTYPE_RANGED_DRAG: A ranged weapon is about to drag this item (only editing `nullify` has any effect for this type)</li>\n</ol>]] value</li>\n<li>GENEV_ITEMCOL_WPNPTR: The ${lweapon} or ${eweapon} pointer (or null) depending on the above type.</li>\n</ol>}\n#{'GENSCR_EVENT_ENEMY_DROP_ITEM_1'|Enemy drops an item (before creating the item)\n<ol start=\"0\">\n<li>GENEV_EDI1_NPC: The ${npc} pointer</li>\n<li>GENEV_EDI1_ITEMID: The chosen item ID, [[or...|Use `-1` as an item ID to drop no item, or use `-2` to drop an item rolled from the specified dropset.]]</li>\n<li>GENEV_EDI1_DROPSET: The dropset the ID was chosen from.</li>\n</ol>}\n#{'GENSCR_EVENT_ENEMY_DROP_ITEM_2'|Enemy drops an item (after the item exists)\n<ol start=\"0\">\n<li>GENEV_EDI2_NPC: The ${npc} pointer</li>\n<li>GENEV_EDI2_ITM: The ${itemsprite} pointer</li>\n</ol>}\n#{'GENSCR_EVENT_ENEMY_DEATH'|An enemy is dying\n<ol start=\"0\">\n<li>GENEV_EDEATH_DYING: If the enemy is dying (write false to cancel death)</li>\n<li>GENEV_EDEATH_NPC: The ${npc} pointer</li>\n</ol>}\n#{'GENSCR_EVENT_ENEMY_HIT1' or 'GENSCR_EVENT_ENEMY_HIT2'|An enemy is hit, before/after ${npc::Defense|Defense[]} is applied.\n<ol start=\"0\">\n<li>GENEV_EHIT_POWER: The damage amount</li>\n<li>GENEV_EHIT_DEFENSETYPE: The defense type</li>\n<li>GENEV_EHIT_UNBLOCKABLE: The [[unblockable|$Unblockable]] flagset</li>\n<li>GENEV_EHIT_WEAPONID: The weapon's ID</li>\n<li>GENEV_EHIT_NULLIFY: A bool, false by default. Write true to nullify the hit.</li>\n<li>GENEV_EHIT_NPCPTR: The NPC pointer</li>\n<li>GENEV_EHIT_LWPNPTR: The LWeapon pointer</li>\n</ol>}"},{"name":"Saving / Exiting ;; Game::Save / Game::End / Game::Reload / Game::Continue / Game::SaveAndQuit / Game::SaveAndContinue / Game::ShowSaveScreen / Game::ShowSaveQuitScreen / Game::ShowContinueScreen","val":"<h3>void Save();</h3>\nSaves the game. Can only run once per script per frame.\n\n<h3>void End();</h3>\nCloses the quest, returning to the title screen.\n\n<h3>void Reload();</h3>\nExits the quest without saving, then reloads the previous save.\n\n<h3>void Continue();</h3>\nContinue's the quest, as 'F6->Continue'.\n\n<h3>void SaveAndQuit();</h3>\nSaves the game, then exits.\n\n<h3>void SaveAndContinue();</h3>\nSaves the game, then continues.\n\n<h3>bool ShowSaveScreen();</h3>\nDisplays the Save screen, as Save Point combos use. Returns true if the player saved, false otherwise.\n\n<h3>void ShowSaveQuitScreen();</h3>\nDisplays the Save/Quit screen.\n\n<h3>void ShowContinueScreen();</h3>\nDisplays the engine Continue/Save/Retry screen."},{"name":"Object Counts ;; Game::MaxItemsprites / Game::MaxEWeapons / Game::MaxLWeapons / Game::MaxNPCs ;; MaxNPCs / MaxLWeapons / MaxEWeapons / MaxItemsprites","val":"<h3>int MaxNPCs();\nint MaxLWeapons();\nint MaxEWeapons();\nint MaxItemsprites();</h3>\nReturns the current max sprite count for each sprite type.\n\n<h3>void MaxNPCs(int newmax);\nvoid MaxLWeapons(int newmax);\nvoid MaxEWeapons(int newmax);\nvoid MaxItemsprites(int newmax);</h3>\nSets the max sprite count for a sprite type to the given new value. Max must be between 1 and 1024, inclusive."},{"name":"Last Locations ;; Game::LastEntranceDMap / Game::LastEntranceScreen / Game::ContinueDMap / Game::ContinueScreen ;; ContinueScreen / ContinueDMap / LastEntranceScreen / LastEntranceDMap","val":"<h3>int LastEntranceScreen;\nint LastEntranceDMap;</h3>\nThe last entrance point the player used, and will be reset to by some mechanics.\n\n<h3>int ContinueScreen;\nint ContinueDMap;</h3>\nThe continue point the player will be reset to when continuing."},{"name":"Save File Status ;; Game::SetSaveName / Game::GetSaveName / Game::Standalone / Game::HasPlayed / Game::MaxCheat / Game::Cheat / Game::NumDeaths / Game::TimeValid / Game::Time ;; Time / TimeValid / NumDeaths / Cheat / MaxCheat / HasPlayed / Standalone / GetSaveName / SetSaveName","val":"<h3>int MaxCheat;</h3>\nThe highest cheat level that is enabled for the player. The player can change their cheat level in the cheat menu to any value <= this value (range 0-4). Updates when the player enters a cheat code.\n\n<h3>int Cheat;</h3>\nThe current activated cheat level. (range 0-4)\n\n<h3>int NumDeaths;</h3>\nThe number of times the player has died.\n\n<h3>bool HasPlayed;</h3>\nRead-only. Returns true if the current save file was loaded, false if it was a freshly created save.\n\n<h3>bool TimeValid;</h3>\nIf 'false', `Game->Time` does not contain accurate time information.\n\n<h3>long Time;</h3>\nThe number of frames passed on the save file, as a `long`. `include/time.zh` has several functions that help manage this value.\n\n<h3>bool Standalone;</h3>\nTrue if the game is running in `Standalone` mode.\n\n<h3>void GetSaveName(char32 buf[]);</h3>\nLoads the save file name into the buffer.\n\n<h3>void SetSaveName(char32 buf[]);</h3>\nSets the save file name to the contents of the buffer, limit 8 characters."},{"name":"Global Settings ;; Game::DisableActiveSubscreen / Game::SkipF6 / Game::SkipCredits / Game::ClickToFreezeEnabled / Game::TypingMode / Game::SubscreenSpeed ;; SubscreenSpeed / TypingMode / ClickToFreezeEnabled / SkipCredits / SkipF6 / DisableActiveSubscreen","val":"<h3>int SubscreenSpeed;</h3>\nSpeed multiplier for the engine subscreen rise/fall. Default 1. Max 85.\n\n<h3>bool TypingMode;</h3>\nIf true, keyboard input is disabled except for scripts reading it.\n\n<h3>bool ClickToFreezeEnabled;</h3>\nWriting this to 'false' forcibly disables the \"Click To Freeze\" setting, allowing the user to click without pausing the game (ex. for scripted mouse interaction)\n\n<h3>bool SkipCredits;</h3>\nIf true, the end credits will not be shown.\n\n<h3>bool SkipF6;</h3>\nIf true, the F6 menu will not appear when F6 is pressed. The prompt to exit the game will still be shown.\n\n<h3>bool DisableActiveSubscreen;</h3>\nIf true, pressing the Start button will no longer open the active subscreen."},{"name":"--&gt; Next ;;gameptr3","val":"$-1$2"},{"name":"&lt;-- Prev ;;gameptr","val":"$-1$0"}],[{"name":"&lt;-- Global Pointers ;; function_globalptr","val":"$0$3"},{"name":"IncrementQuest ;; Game::IncrementQuest ;; IncrementQuest","val":"<h3>void IncrementQuest();</h3>\nEnds the current quest in victory, resetting to the title screen (without showing the normal end credits), and if this quest is part of a module, increment to the next quest in the module."},{"name":"Screen->D[] ;; Game::GetScreenD / Game::SetScreenD / Game::GetDMapScreenD / Game::SetDMapScreenD","val":"<h3>untyped GetScreenD(int screen, int reg);</h3>\nGets the `Screen->D[reg]` for the screen `screen` on the current dmap.\n\n<h3>untyped SetScreenD(int screen, int reg, untyped val);</h3>\nSets the `Screen->D[reg]` for the screen `screen` on the current dmap to `val`.\n\n<h3>untyped GetDMapScreenD(int dmap, int screen, int reg);</h3>\nGets the `Screen->D[reg]` for the screen `screen` on the specified dmap.\n\n<h3>untyped SetDMapScreenD(int dmap, int screen, int reg, untyped val);</h3>\nSets the `Screen->D[reg]` for the screen `screen` on the specified dmap to `val`."},{"name":"GuyCount ;; Game::GuyCount","val":"<h3>int GuyCount[256];</h3>\nThe count of enemies remaining alive for each screen on the current map."},{"name":"DisableItem[] ;; Game::DisableItem","val":"<h3>bool DisabledItem[NUM_ITEMDATA];</h3>\n\nWhether each item is disabled or not on the current dmap."},{"name":"Misc ;; Game::MapCount / Game::NumMessages","val":"<h3>int MapCount();</h3>\nThe number of maps in the quest.\n\n<h3>int NumMessages;</h3>\nThe number of message strings in the quest.\n\n<h3>int GetMidi();</h3>\nReturns the current MIDI playing."},{"name":"--","val":""},{"name":"--","val":""},{"name":"--","val":""},{"name":"--","val":""},{"name":"&lt;&lt;-- Start ;;gameptr","val":"$-1$0"},{"name":"&lt;-- Prev ;;gameptr2","val":"$-1$1"}],[{"name":"&lt;-- Data / Functions ;; function_root","val":"$0$1"},{"name":"--","val":"<h3>Global Functions</h3>\n\nGlobal functions are a member of no pointer type, and instead are simply able to be called from anywhere."},{"name":"Misc Functions","val":"$-1$1"},{"name":"Math Functions","val":"$-1$2"},{"name":"Logging Functions","val":"$-1$3"},{"name":"String Functions","val":"$-1$4"},{"name":"Array Functions","val":"$-1$5"}],[{"name":"&lt;-- Global Functions","val":"$-1$0"},{"name":"--","val":"Functions that don't fit a particular category."},{"name":"Quit","val":"<h3>void Quit();</h3>\n\nExits the current script entirely. Has the same effect as reaching the end of 'void run()', or 'return'ing from the 'void run()'."},{"name":"Waiting ;; Waitframe / Waitdraw / WaitTo / WaitEvent","val":"<h3>void Waitframe();</h3>\n\nWhen called, the script ends running for the current frame. The engine will proceed with one frame of gameplay before resuming this script at this position.\n\n<h3>void Waitdraw();</h3>\n\nWhen called the first time in a frame, the script ends running for a portion of time. The engine will proceed with <em>part</em> of a frame of gameplay, allowing other engine activities to occur, before resuming this script.\n\nIf called again, the additional call will act as a call to 'Waitframe()', as it cannot wait any more of the frame without the frame ending.\n\n<h3>void WaitTo(int timing, bool at_least = false);</h3>\nCan only be used in a passively-running ${genericdata|Generic Script}.\nWaits until it is the specified timing. If 'at_least == true', will not wait if it is already past that timing for the frame.\n\n#{Available Timings|\n<ol start=\"-1\">\n<li>SCR_TIMING_INIT</li>\n<li>SCR_TIMING_START_FRAME</li>\n<li>SCR_TIMING_POST_COMBO_ANIM</li>\n<li>SCR_TIMING_POST_POLL_INPUT</li>\n<li>SCR_TIMING_POST_FFCS</li>\n<li>SCR_TIMING_POST_GLOBAL_ACTIVE</li>\n<li>SCR_TIMING_POST_PLAYER_ACTIVE</li>\n<li>SCR_TIMING_POST_DMAPDATA_ACTIVE</li>\n<li>SCR_TIMING_POST_DMAPDATA_PASSIVESUBSCREEN</li>\n<li>SCR_TIMING_POST_COMBOSCRIPT</li>\n<li>SCR_TIMING_POST_PUSHBLOCK</li>\n<li>SCR_TIMING_POST_ITEMSPRITE_SCRIPT</li>\n<li>SCR_TIMING_POST_ITEMSPRITE_ANIMATE</li>\n<li>SCR_TIMING_POST_NPC_ANIMATE</li>\n<li>SCR_TIMING_POST_EWPN_ANIMATE</li>\n<li>SCR_TIMING_POST_EWPN_SCRIPT</li>\n<li>SCR_TIMING_POST_OLD_ITEMDATA_SCRIPT</li>\n<li>SCR_TIMING_POST_PLAYER_ANIMATE</li>\n<li>SCR_TIMING_POST_NEW_ITEMDATA_SCRIPT</li>\n<li>SCR_TIMING_POST_CASTING</li>\n<li>SCR_TIMING_POST_LWPN_ANIMATE</li>\n<li>SCR_TIMING_POST_DECOPARTICLE_ANIMATE</li>\n<li>SCR_TIMING_POST_COLLISIONS_PALETTECYCLE</li>\n<li>SCR_TIMING_WAITDRAW</li>\n<li>SCR_TIMING_POST_GLOBAL_WAITDRAW</li>\n<li>SCR_TIMING_POST_PLAYER_WAITDRAW</li>\n<li>SCR_TIMING_POST_DMAPDATA_ACTIVE_WAITDRAW</li>\n<li>SCR_TIMING_POST_DMAPDATA_PASSIVESUBSCREEN_WAITDRAW</li>\n<li>SCR_TIMING_POST_SCREEN_WAITDRAW</li>\n<li>SCR_TIMING_POST_FFC_WAITDRAW</li>\n<li>SCR_TIMING_POST_COMBO_WAITDRAW</li>\n<li>SCR_TIMING_POST_ITEM_WAITDRAW</li>\n<li>SCR_TIMING_POST_NPC_WAITDRAW</li>\n<li>SCR_TIMING_POST_EWPN_WAITDRAW</li>\n<li>SCR_TIMING_POST_LWPN_WAITDRAW</li>\n<li>SCR_TIMING_POST_ITEMSPRITE_WAITDRAW</li>\n<li>SCR_TIMING_PRE_DRAW</li>\n<li>SCR_TIMING_POST_DRAW</li>\n<li>SCR_TIMING_POST_STRINGS</li>\n<li>SCR_TIMING_END_FRAME</li>\n</ol>\n}\n\n<h3>int WaitEvent();</h3>\nCan only be used in a passively-running ${genericdata|Generic Script}.\nIs only used in conjunction with ${genericdata::EventListen|'EventListen[]'}. Waits until any event the script is listening to via ${genericdata::EventListen|`EventListen[] = true`} occurs. When such an event occurs, the function will return the event type, and ${EventData|Game->EventData[]} will be filled with information about the current event, much of which is modifiable."},{"name":"Tile Functions ;; CopyTile / SwapTile / OverlayTile / ClearTile","val":"<h3>void CopyTile(int src, int dest);</h3>\nCopies tile 'src' to tile 'dest'.\n\n<h3>void OverlayTile(int src, int dest);<span class=\"vers\">   Since 2.53</span></h3>\nOverlays tile 'src' over tile 'dest'.\n\n<h3>void SwapTile(int a, int b);</h3>\nSwaps the tiles 'a' and 'b'.\n\n<h3>void ClearTile(int tile);</h3>\nClears the tile 'tile' to be blank.\n\n<h3>Note</h3>\nAll tile modifications are temporary, and will be reset when the quest is exited."},{"name":"Distance / LongDistance","val":"<h3>float Distance(float x1, float y1, float x2, float y2);</h3>\n<h3>float Distance(float x1, float y1, float x2, float y2, int scale);</h3>\n\nCalculates the distance between two points, optionally using a scale divisor to handle distances that would otherwise overflow.\n\n<h3>long LongDistance(long x1, long y1, long x2, long y2);</h3>\n<h3>long LongDistance(long x1, long y1, long x2, long y2, long scale);</h3>\n\nSame as 'Distance()', but takes distances as 'long' coordinates, returning a 'long' distance value."},{"name":"GetSystemTime ;; RTC ;; System Clock / Real Clock","val":"<h3>int GetSystemTime(int index);</h3>\n\nReturns information from the real-time clock of the system.\nValid values:\n<ol start=0>\n<li>RTC_YEAR: Returns the year</li>\n<li>RTC_MONTH: Returns the month, with 1 = January</li>\n<li>RTC_DAYOFMONTH: Returns the day of the month, 1-31</li>\n<li>RTC_DAYOFWEEK: Returns the day of the week, 1 = Sunday</li>\n<li>RTC_HOUR: Returns the current hour, 0-23</li>\n<li>RTC_MINUTE: Returns the current minute, 0-59</li>\n<li>RTC_SECOND: Returns the current second, 0-60 (only 60 for leap seconds on certain systems)</li>\n<li>RTC_DAYOFYEAR: Returns the day of the year, 0-365</li>\n<li>RTC_DAYLIGHTTIME: Returns a value based on DST. 0 indicates DST is not in effect, &gt;0 indicates it is, and &lt;0 indicates that the system does not know.</li>\n</ol>"},{"name":"SRAM","val":"<h3>void SaveSRAM(char32[] [[filename|.zcsram]], int flags);\nvoid LoadSRAM(char32[] [[filename|.zcsram]], int flags);</h3>\n\nSaves/loads internal data (which is normally <em>temporarily</em> altered by scripts) of the types specified in 'flags'.\n\nFlags:\n<ul>\n<li>npcdata: 0x01</li>\n<li>itemdata: 0x02</li>\n<li>spritedata: 0x04</li>\n<li>combodata: 0x08</li>\n<li>dmapdata: 0x10</li>\n<li>mapdata: 0x20</li>\n</ul>\n\nFlags are OR'd together (ex. `0x01 | 0x02 | 0x04`). Passing '0' will use ALL flags.\n\nRelated: ${OnSaveLoad}, ${OnSave}"},{"name":"OwnObject / GlobalObject","val":"<h3>void OwnObject([Object] obj);</h3>\nTakes an ${objects|Object} parameter. Grants ownership of the object to the currently running script.\nWhen the owning script dies, the owned object will be deleted.\n\nNote: Objects are already owned by the script that created them automatically, without needing to call this function.\n\n<h3>void GlobalObject([Object] obj);</h3>\nTakes an ${objects|Object} parameter. Globalizes the object, making it no longer owned by any script.\nGlobalized objects will be saved to the save file, and remain intact upon reloading.\nCalling 'OwnObject()' on a globalized object will undo this, returning it to script ownership."}],[{"name":"&lt;-- Global Functions","val":"$-1$0"},{"name":"<u>Math Functions</u> ;;GlobalMath;; Math Functions","val":"These functions relate to various mathematical operations."},{"name":"Abs","val":"<h3>float Abs(float val);</h3>\n\nReturns the absolute value of the parameter."},{"name":"Ceiling / Floor","val":"<h3>int Ceiling(float val);</h3>\nReturns 'val' rounded up to the next higher integer.\n\n<h3>int Floor(float val);</h3>\nReturns 'val' rounded down to the next lower integer."},{"name":"Factorial","val":"<h3>int Factorial(int val);</h3>\n\nReturns 'val!'. Returns '0' for negative values."},{"name":"Log10 / Ln","val":"<h3>float Log10(float val);</h3>\nReturns the log<sub>10</sub> of the value. Values &lt;= 0 return 0.\n\n<h3>float Ln(float val);</h3>\nReturns the natural log (log<sub>e</sub>) of the value. Values &lt;= 0  return 0."},{"name":"Min / Max / Choose","val":"<h3>untyped Min([[...untyped args|Takes 2+ untyped args]]);</h3>\nReturns the <em>lowest</em> parameter.\n\n<h3>untyped Max([[...untyped args|Takes 2+ untyped args]]);</h3>\nReturns the <em>highest</em> parameter.\n\n<h3>untyped Choose([[...untyped args|Takes 1+ untyped args]]);</h3>\nReturns a random parameter, using the global RandGen."},{"name":"Pow / InvPow","val":"<h3>int Pow(int base, int exp);</h3>\nReturns 'base<sup>exp</sup>', with '0<sup>0</sup>==1'. Negative values of 'exp' work, though may not be useful, as the return value is truncated to the nearest integer.\n\n<h3>int LPow(long base, long exp);</h3>\nReturns 'base<sup>exp</sup>', with '0<sup>0</sup>==1'. Negative values of 'exp' work, though may not be useful, as the return value is truncated to the nearest long.\n\n<h3>int InvPow(int base, int exp);</h3>\nReturns 'base<sup>(1/exp)</sup>', undefined if 'exp' is 0, or if 'exp' is even and 'base' is negative. Negative values of 'exp' work, though may not be useful, as the return value is truncated to the nearest integer."},{"name":"Sqrt","val":"<h3>float Sqrt(float val);</h3>\n\nReturns the square root of the value. Undefined for negative values, and will return an error."},{"name":"Trig Functions ;; Sin / Cos / Tan / ArcSin / ArcCos / ArcTan / RadianSin / RadianCos / RadianTan ;; Trig Functions","val":"<h3>float Sin(float deg);\nfloat Cos(float deg);\nfloat Tan(float deg);</h3>\nReturns the trig Sin/Cos/Tan of the degree value given.\n\n<h3>float RadianSin(float rad);\nfloat RadianCos(float rad);\nfloat RadianTan(float rad);</h3>\nReturns the trig Sin/Cos/Tan of the radian value given.\n\n<h3>float ArcSin(float x);\nfloat ArcCos(float x);\nfloat ArcTan(float x, float y);</h3>\nReturns the trig ArcSin/ArcCos/ArcTan of the value(s) given."},{"name":"Angle Conversion ;; RadtoDeg / DegtoRad","val":"<h3>float DegtoRad(float deg);\nfloat RadtoDeg(float rad);</h3>\nConverts between degrees and radians."}],[{"name":"&lt;-- Global Functions","val":"$-1$0"},{"name":"<u>Logging</u>;;GlobalLogging ;; Logging Functions","val":"These functions all relate to the ${Output Console}, and printing data to it."},{"name":"Trace","val":"<h3>void Trace(untyped val);\nvoid Trace(long val);</h3>\n\nPrints the passed value to the ${Output Console|output console}. Includes a newline character after the value.\n\nIf a `long` val is passed, it prints the number with no decimal place (long format). Otherwise, it prints the number with 4 decimal places. "},{"name":"TraceB","val":"<h3>void TraceB(untyped val);</h3>\n\nPrints the passed value to the ${Output Console|output console}, as \"true\" if the value is nonzero, or \"false\" if the value is 0. Includes a newline character after the value."},{"name":"TraceS","val":"<h3>void TraceS(char32[] string);</h3>\n\nPrints the passed string to the ${Output Console|output console}. Does not include a newline character after the string."},{"name":"TraceNL","val":"<h3>void TraceNL();</h3>\n\nPrints a newline character to the ${Output Console|output console}."},{"name":"TraceToBase","val":"<h3>void TraceToBase(int val, int base, int mindigits);</h3>\n\nPrints the passed value to the ${Output Console|output console}, in the specified base, where \"2 &lt;= base &lt;= 36\". Value will be floored before print, so decimal values are not printed. Will print at least 'mindigits' digits, using leading 0s as needed. Includes a newline character after the value."},{"name":"ClearTrace","val":"<h3>void ClearTrace();</h3>\n\nClears the logs from ${allegro.log}, and clears the ${output console}."},{"name":"printf","val":"<h3>void printf(char32[] format_string, [[...untyped args|Takes 0+ untyped args]]);</h3>\n\nPrints the specified format_string to the ${Output Console|output console}, using the given args to fill in parts of the string that are specially marked. Does not include a newline character after the string.\n\nValid patterns:\n<ul>\n<li>'%i' or '%p': Inserts the value as an integer (no decimal places).</li>\n<li>'%f': Inserts the value as a float number (decimal places included)</li>\n<li>'%d': Acts as '%i' if all decimal places are '0', as '%f' otherwise.</li>\n<li>'%l': Inserts the value as a long (decimal places included, but no decimal point)</li>\n<li>'%s': Inserts the value as a string (must be a valid array pointer)</li>\n<li>'%c': Inserts the value as a character.</li>\n<li>'%x' or '%X': Inserts the value as a hexadecimal integer (no decimal places). Capitalization of letters matches the capitalization of the 'x'.</li>\n<li>'%b' or '%B': Inserts the value in Binary. 'b' has no decimal included, while 'B' uses all 32 bits as a long.</li>\n<li>'%a?': Inserts an array. Must be followed by another letter from this list, which will be used as the format for each element in the array. Ex: '%aB' inserts an array, where each index is inserted in long binary. '%04ad' inserts an array, where each element is a number of at least 4 digits.</li>\n<li>'%%': Inserts a single '%', does not act as a pattern.</li>\n</ul>\n\nAlso, by including numbers between the '%' and letter for patterns (excluding '%s', '%c', '%%'), it will take a minimum of that many digits, adding leading 0's as needed. Example: '%5i' given a value of '253' would display as '00253', filling up 5 digits of space. The max number of digits is 10, except in Binary ('%b','%B'), where it is 32.\n\nRelated: ${sprintf|sprintf()}"}],[{"name":"&lt;-- Global Functions","val":"$-1$0"},{"name":"<u>String Functions</u> ;; GlobalString ;; String Functions","val":"These functions relate to the manipulation of strings."},{"name":"Case Conversion ;; utol / ltou / convcase","val":"<h3>char32[] utol(char32[] string);\nchar32[] ltou(char32[] string);\nchar32[] convcase(char32[] string);</h3>\n\nReturns the string passed.\nConverts the capitalization of every letter in the string. Respectively, converting all to upper, all to lower, or inverting the case."},{"name":"ilen","val":"<h3>int ilen(char32[] string);</h3>\n\nReturns the number of characters in the string that are taken up by a number (as would be read by ${atoi}, including negative sign);"},{"name":"itoacat","val":"<h3>int itoacat(char32[] dest, int val);</h3>\n\nAppends the value 'val' on the end of the 'dest' string; combining ${itoa} with ${strcat}"},{"name":"sprintf","val":"<h3>void sprintf(char32[] dest, char32[] format_string, [[...untyped args|Takes 0+ untyped args]]);</h3>\n\nActs exactly as ${printf}, except instead of printing the result to the ${Output Console|output console}, it is instead placed in the 'dest' buffer."},{"name":"strcat","val":"<h3>char32[] strcat(char32[] dest, char32[] src);</h3>\n\nAppends 'src' to the end of 'dest'. Returns 'dest'."},{"name":"strcpy","val":"<h3>void strcpy(char32[] dest, char32[] src);</h3>\n\nCopies the string 'src' to 'dest'."},{"name":"strcspn","val":"<h3>int strcspn(char32[] str, char32[] chars);</h3>\n\nReturns the length in 'str' before any character in 'chars' is found.\n\nRelated: ${strspn}"},{"name":"String Comparison ;; strcmp / strncmp / stricmp / strnicmp","val":"<h3>int strcmp(char32[] str1, char32[] str2);\nint strncmp(char32[] str1, char32[] str2, int num_chars);\nint stricmp(char32[] str1, char32[] str2);\nint strnicmp(char32[] str1, char32[] str2, int num_chars);</h3>\n\nCompares the contents of the two strings.\nReturns '0' if the strings are equal. Otherwise, compares the first character that is different between the strings, returning &gt;0 if it is larger in str1, and &lt;0 if it is larger in str2.\n'strncmp' and 'strnicmp' only compares the first 'num_chars' characters.\n'stricmp' and 'strnicmp' compare case-insensitively."},{"name":"String Searching ;; strchr / strrchr / strstr","val":"<h3>int strchr(char32[] str, char32 c);</h3>\n\nReturns the first index of 'str' that contains the character 'c'.\n\n<h3>int strrchr(char32[] str, char32 c);</h3>\n\nReturns the last index of 'str' that contains the character 'c'.\n\n<h3>int strstr(char32[] str, char32[] tofind);</h3>\n\nReturns the index of the first instance of the string 'tofind' within 'str'."},{"name":"String to Value ;; atoi / xtoi","val":"<h3>int atoi(char32[] str);</h3>\n\nConverts a string containing a number to its' numeric value.\nEx. `atoi(\"0526\"); == 526`\n\n<h3>int xtoi(char32[] str);</h3>\n\nConverts a string containing a hexadecimal number to its' numeric value.\nEx. `xtoi(\"0x15\"); == 21`"},{"name":"strlen","val":"<h3>int strlen(char32[] str);</h3>\n\nReturns the length of the string in characters."},{"name":"strspn","val":"<h3>int strcspn(char32[] str, char32[] chars);</h3>\n\nReturns the length in 'str' until any character NOT in 'chars' is found.\n\nRelated: ${strcspn}"},{"name":"Value to String ;; itoa / xtoa","val":"<h3>int itoa(char32[] dest, int val);</h3>\n\nConverts the value 'val' to a string, and places it in the 'dest'.\nEx. `itoa(dest, 72);` leaves the buffer holding `\"72\"`.\n\n<h3>int xtoa(char32[] dest, int val);</h3>\n\nConverts the value 'val' to a string, as hexadecimal, and places it in the 'dest'.\nEx. `xtoa(dest, 21);` leaves the buffer holding `\"0x15\"`."}],[{"name":"&lt;-- Global Functions","val":"$-1$0"},{"name":"<u>Array Functions</u> ;; GlobalArray ;; Array Functions","val":"These functions relate to arrays."},{"name":"ArrayCopy","val":"<h3>void ArrayCopy(untyped[] dest, untyped[] src);</h3>\n\nCopies all data from 'src' to 'dest'. If the arrays are not the same size, the smaller size is used, and the excess in the larger array is ignored."},{"name":"IsValidArray","val":"<h3>bool IsValidArray(untyped[] arr);</h3>\n\nReturns true if the value 'arr' points to a valid array."},{"name":"SizeOfArray","val":"<h3>int SizeOfArray(untyped[] arr);</h3>\n\nReturns the size of the array"},{"name":"ResizeArray","val":"<h3>void ResizeArray(untyped[] arr, int size);</h3>\n\nResizes the array 'arr' to size 'size'. If 'size' is &lt;1, the array becomes size 1 instead."},{"name":"OwnArray / DestroyArray","val":"<h3>void OwnArray(untyped[] arr);</h3>\nGrants ownership of the target array to the currently running script.\nIf this array is not a local array, nothing happens.\nIf it is a local array, the array will no longer be destroyed when it reaches the end of its' declaring scope- it will last until the owning script ends, at which point it will be freed.\n\n<h3>void DestroyArray(untyped[] arr);</h3>\nIf 'arr' is a local array, destroys it immediately. Otherwise does nothing."}],[{"name":"&lt;-- Data Pointers ;; function_data","val":"$0$4"},{"name":"<em>ffc</em>","val":"<h3>FFC Pointers</h3>   `ffc`\n\nThese pointers represent the 32 Freeform Combos on the current screen, and their various attributes and functions.\nUsing these pointers, you can move them, change their combo, change their script, etc.\n\nSee: ${LoadFFC}"},{"name":"Position ;; ffcPosition / ffc::X / ffc::Y","val":"<h3>int X; int Y;</h3>\n\nRead/Write; These values store the ffc's position on each of the two axes; FFCs do not have a 'Z' position.\nValues may contain up to 4 decimal places, regardless of QRs."},{"name":"Data / CSet ;; ffc::Data / ffc::CSet","val":"<h3>int Data;</h3>\nThe combo used by the FFC for its' visuals and type.\n\n<h3>int CSet;</h3>\nThe CSet the FFC displays in."},{"name":"Size ;; ffc::TileHeight / ffc::TileWidth / ffc::EffectHeight / ffc::EffectWidth","val":"<h3>int TileHeight; int TileWidth;</h3>\nThe visual size, in tiles (1 to 4), of the FFC. The tile set by its' combo will be the upper-left tile, with the rest drawn as a tile block from there.\n\n<h3>int EffectHeight; int EffectWidth;</h3>\nThe hitbox size, in pixels (1 to 64), of the FFC. Unless the FFC is ${FFC::Flags|Ethereal}, the type of its' combo will affect this area. NOTE: Not all combo types function when placed on FFCs."},{"name":"Scripts ;; ffc::Script / ffc::InitD / ffc::Misc","val":"<h3>int Script;</h3>\nThe FFC script ID running on this FFC.\n\n<h3>untyped InitD[8];</h3>\nThe 8 InitD[] parameters for the FFC's script.\n\n<h3>untyped Misc[16];</h3>\nA miscellaneous data array, for script use."},{"name":"Movement ;; ffcMovement / ffc::Vx / ffc::Vy / ffc::Ax / ffc::Ay / ffc::Delay","val":"<h3>int Vx; int Vy;</h3>\nThe FFC's current X and Y axis velocities.\n\n<h3>int Ax; int Ay;</h3>\nThe FFC's current X and Y axis accelerations.\n\n<h3>int Delay;</h3>\nThe time in frames before the FFC will begin moving.\n\n"},{"name":"Flags ;; ffc::Flags","val":"<h3>int Flags[14];</h3>\nThe FFC's flags.\n\nValues representing FFC flags:\n<ol start='0'><li>[[FFCF_OVERLAY|Draws between layers 4 and 5 if enabled]]</li>\n<li>[[FFCF_TRANS|Draws transparently if enabled]]</li>\n<li>[[FFCF_SOLID|Makes the FFC behave as entirely solid. [NOT FULLY IMPLEMENTED]]</li>\n<li>[[FFCF_CARRYOVER|If enabled, the FFC will carry between screens, replacing the FFC that is of the same index on any screen it is brought to.]]</li>\n<li>[[FFCF_STATIONARY|Ignores movement attributes if enabled.]]</li>\n<li>[[FFCF_CHANGER|Changes other FFCs that come into contact with this one]]</li>\n<li>[[FFCF_PRELOAD|The FFC's script will run for one frame before scrolling onto its' screen.]]</li>\n<li>[[FFCF_LENSVIS|The FFC is invisible unless you are using a Lens of Truth.]]</li>\n<li>[[FFCF_RESET|When the FFC is carried over to a new screen, its' script will restart.]]</li>\n<li>[[FFCF_ETHEREAL|The FFC will not apply its' combo's 'Type' effects, nor block the types of combos under it.]]</li>\n<li>[[FFCF_IGNOREHOLDUP|The FFC continues to run while the player is holding an item up.]]</li>\n<li>[[FFCF_IGNORECHANGER|The FFC will ignore changer FFCs.]]</li>\n<li>[[FFCF_IMPRECISIONCHANGER|The FFC will collide with changer FFCs when it is on the same whole pixel to them, rather than requiring the exact same subpixel.]]</li>\n<li>[[FFCF_LENSINVIS|The FFC is invisible while using the lens of truth.]]</li></ol>"},{"name":"Link ;; ffc::Link","val":"<h3>int Link;</h3>\nRepresents the ID of another FFC this one is 'linked' to."},{"name":"ID ;; ffc::ID","val":"<h3>int ID;</h3>\nRead-only: the screen index of the FFC."}],[{"name":"&lt;-- Misc Data Pointers ;; function_data_misc","val":"$0$6"},{"name":"<em>genericdata</em>","val":"<h3>GenericData Pointers</h3>   `genericdata`\n\n`genericdata` pointers allow interacting with and running `generic` scripts.\n\nSee: ${LoadGenericData}, ${WaitTo}, ${WaitEvent}"},{"name":"Script Running ;; genericdata::Running / genericdata::RunFrozen / genericdata::ExitState / genericdata::ReloadState","val":"<h3>bool Running;</h3>\nWhen read, returns true if the script is currently running passively.\nIf written false, kills the script. If written true, launches (or restarts) the script.\n\n<h3>bool RunFrozen();</h3>\nAttempt to run the generic script in frozen mode.\nReturns true if successful, false otherwise.\nIf successful, the script will run until it exits, with everything else in the engine frozen, including all other scripts.\n\n<h3>bool ExitState[GENSCR_NUMST];\nbool ReloadState[GENSCR_NUMST];</h3>\nArrays of exit and reload conditions. All states default to 'false'.\nIf an exitstate is true, when the associated condition is met, the script will exit entirely.\nIf a reloadstate is true, when the associated condition is met, the script will restart from the start if it was already running.\n\nAvailable states:\n<ol start=\"0\"><li>[[GENSCR_ST_RELOAD|Will exit or reload on starting from the title screen if true. NOTE: Even if reload is false, scripts will reload on this condition.]]</li>\n<li>[[GENSCR_ST_CONTINUE|Will exit or reload upon 'F6->Continue', or an effect which mimics 'F6->Continue'.]]</li>\n<li>[[GENSCR_ST_CHANGE_SCREEN|Will exit or reload upon changing screens]]</li>\n<li>[[GENSCR_ST_CHANGE_DMAP|Will exit or reload upon changing dmaps]]</li>\n<li>[[GENSCR_ST_CHANGE_LEVEL|Will exit or reload upon changing dmap levels]]</li></ol>"},{"name":"Event Listening ;; genericdata::EventListen","val":"<h3>bool EventListen[GENSCR_NUMEVENT];</h3>\nArray of event listener conditions. When ${WaitEvent|WaitEvent()} is called, the script will wait until any event which has a value of 'true' in this array occurs.\nDefaults to all false.\n\nSee: ${WaitEvent}, ${EventData}\n\nAvailable states:\n<ol start=\"0\"><li>[[GENSCR_EVENT_INIT|When loading from a save or starting a new quest]]</li>\n<li>[[GENSCR_EVENT_CONTINUE|When 'F6->Continue' occurs, before conditions have been reset.]]</li>\n<li>[[GENSCR_EVENT_FFC_PRELOAD|The 'FFC runs on Screen Init' timing]]</li>\n<li>[[GENSCR_EVENT_CHANGE_SCREEN|When the screen changes]]</li>\n<li>[[GENSCR_EVENT_CHANGE_DMAP|When the dmap changes]]</li>\n<li>[[GENSCR_EVENT_CHANGE_LEVEL|When the level changes]]</li>\n<li>[[GENSCR_EVENT_HERO_HIT_1|When the player is hit, before ring defense is applied]]</li>\n<li>[[GENSCR_EVENT_HERO_HIT_2|When the player is hit, after ring defense is applied]]</li>\n<li>[[GENSCR_EVENT_COLLECT_ITEM|When an item is collected]]</li>\n<li>[[GENSCR_EVENT_ENEMY_DROP_ITEM_1|When an enemy drops an item, before it creates an item]]</li>\n<li>[[GENSCR_EVENT_ENEMY_DROP_ITEM_2|When an enemy drops an item, after the item is created (only if 'Nothing' isn't chosen)]]</li>\n<li>[[GENSCR_EVENT_ENEMY_DEATH|An enemy dies]]</li>\n<li>[[GENSCR_EVENT_ENEMY_HIT1|When an enemy is hit, before defenses]]</li>\n<li>[[GENSCR_EVENT_ENEMY_HIT2|When an enemy is hit, after defenses]]</li></ol>"},{"name":"Data Storage ;; genericdata::InitD / genericdata::Data / genericdata::DataSize","val":"<h3>untyped InitD[8];</h3>\nThe 8 InitD[] parameters for the generic script. Shared by passive and frozen run modes.\n\n<h3>int DataSize;</h3>\nRead/write; the size of the script's Data array (see below). Writing this resizes the array, where any area above the previous maximum is cleared to '0'.\nDefaults to size '0'.\n\n<h3>untyped Data[DataSize];</h3>\nA misc data array, resizable by writing to DataSize (see above). All indexes are saved with the save file, including any resizing."}],[{"name":"&lt;-- Managed Pointers ;; function_data_managed","val":"$0$7"},{"name":"<em>file</em>","val":"<h3>File Pointers</h3>   `file`\n\n`file` pointers allow directly interacting with files on the user's system.\nEach quest has a directory created at `[zc root]/files/[quest name]/`, and ONLY files within this directory are accessible. All paths are relative to this directory.\n\nThere is no 'LoadFile' function. To load a file, declare a variable of type 'file', and call ${file::Open|Open()}, ${file::Create|Create()}, or ${file::OpenMode|OpenMode()} to open a file to it.\n\nGeneral info about filesystem access:\nFiles opened with '${file::Open|Open()}' or '${file::Create|Create()}', as well as some modes passed to '${file::OpenMode|OpenMode()}', can be Read/Write. In a Read/Write mode, you must call one of a few certain functions between a read call and a write call. These functions will list this effect in their description.\n\nWriting to files does not write directly to disk, but to a buffer. It is guaranteed that the contents of this buffer will be written to disk upon a successful call to '${file::Flush|Flush()}', or upon the closing of the file. Upon exiting the quest, all open files are closed.\n\nThere is a limit of 256 file pointers. A pointer does not need to have a file open to count against this limit. Any pointer that returns true from '${file::isAllocated|isAllocated()}' counts against this limit. Calling '${file::Free|Free()}' will deallocate a pointer, thus no longer counting against this limit. If you open many files without calling '${file::Free|Free()}', you may run out of pointers, and be unable to open further files (until you call '${file::Free|Free()}' on some existing pointers).\n\nFiles are NOT automatically freed if they fall out of scope. You should be sure to manually call '${file::Free|Free()}' before this happens, or you may lose the pointer, and be unable to free it later. Using ${file::Own|Own()}, you can set a file pointer to automatically free when the calling script exits.\n\nRemember: POSIX filesystems are Case-SenSitive. "},{"name":"File Opening ;; file::Open / file::Create / file::OpenMode","val":"<h3>bool Open(char32[] \"filepath\");\nbool Create(char32[] \"filepath\");</h3>\nIf the file pointer is not allocated, these will allocate it. Also closes any file that is already open on the pointer.\nAttempts to open \"[zc root]/files/[questname]/[filepath]\", in mode 'rb+' for 'Open()' or 'wb+' for 'Create()'.\nOpen will fail if the file does not exist; Create will create it if it does not exist, and wipe the file clean if it does exist.\n\n<h3>bool OpenMode(char32[] \"filepath\", char32[] \"mode_string\");</h3>\nIf the file pointer is not allocated, this will allocate it. Also closes any file that is already open on the pointer.\nSame as 'Open()', but the file is opened with the specified mode.\nValid modes (details taken from <a href=http://www.cplusplus.com/reference/cstdio/fopen target = \"_blank\">http://www.cplusplus.com/reference/cstdio/fopen/</a>):\n    \"r\"  | read: Open file for input operations. The file must exist.\n    \"w\"  | write: Create an empty file for output operations. If a file\n           with the same name already exists, its contents are discarded\n           and the file is treated as a new empty file.\n    \"a\"  | append: Open file for output at the end of a file. Output operations\n           always write data at the end of the file, expanding it. Repositioning\n           operations ('${file::Seek|Seek()}', '${file::Rewind|Rewind()}') are ignored. The file is created if\n           it does not exist.\n    \"r+\" | read/update: Open a file for update (both for input and output). The\n           file must exist.\n    \"w+\" | write/update: Create an empty file and open it for update (both for\n           input and output). If a file with the same name already exists its\n           contents are discarded and the file is treated as a new empty file.\n    \"a+\" | append/update: Open a file for update (both for input and output)\n           with all output operations writing data at the end of the file.\n           Repositioning operations (fseek, fsetpos, rewind) affects the next\n           input operations, but output operations move the position back to the\n           end of file. The file is created if it does not exist.\n\nThe letter \"b\" can be added to the end of any of these (or before the \"+\", for update modes)\n    to specify a binary file mode. Not doing this will specify a text file mode.\nText files are files containing sequences of lines of text. Depending on the environment\n    where the application runs, some special character conversion may occur in input/output\n    operations in text mode to adapt them to a system-specific text file format. Although\n    on some environments no conversions occur and both text files and binary files are\n    treated the same way, using the appropriate mode improves portability."},{"name":"Remove ;; file::Remove","val":"<h3>bool Remove();</h3>\nDeletes the file. This will close it, as with ${file::Close|Close()}, and then delete it from the filesystem.\nReturns true if successful. The file will be closed, even if the removal fails."},{"name":"File Pointer Management ;; file::Flush / file::Close / file::Free / file::Own / file::isAllocated / file::isValid","val":"<h3>bool Flush();</h3>\nFlushes the buffer of the file being written to.\nWrites to a file do not actually write to the file immediately; they instead go to a buffer. Calling this function will force the buffer to be written to disk.\n\n<h3>void Close();</h3>\nCloses any open file connected to the file pointer (which also includes 'Flush()'). Does *NOT* deallocate the pointer, it is still reserved to open new files on.\n\n<h3>void Free();</h3>\nCloses any file as 'Close()', then deallocates the file pointer so it may be re-used.\n\n<h3>void Own();</h3>\nGrants 'Ownership' of the file pointer to the script that calls this function. When the script with 'Ownership' terminates (at the same time its' local arrays are deallocated), this file pointer will automatically be 'Free()'d.\n\n<h3>bool isAllocated();</h3>\nReturns true if this pointer is allocated. This does not necessarily mean a file is open, just that the pointer has a reserved ID.\n<h3>bool isValid();</h3>\nReturns true if a file is open on the pointer.\n\n<h3>bool Allocate();</h3>\nAttempts to allocate the file pointer. If it was already allocated, this will re-allocate it without freeing it!\nReturns true if successful, false if the max number of files is already allocated."},{"name":"File Reading ;; file::ReadString / file::ReadChars / file::ReadBytes / file::ReadInts / file::GetChar / file::UngetChar","val":"<h3>int ReadString(char32[] buf);</h3>\nReads a section of characters from the file.\nWill read either until 'buf' is full, an error occurs, End of File is reached, or a newline character is reached.\nIf it ends due to reaching a newline character, the newline character will be included at the end of the string.\nReturns the length of the string read into 'buf'.\n\n<h3>int ReadChars(char32[] buf, int count = -1, int pos = 0);</h3>\nReads a section of characters from the file.\nStarts placing characters at 'buf[pos]'. If 'pos' is negative, starts at 'buf[0]'.\nIf 'count' is 0, does nothing and returns 0.\nIf 'count' is negative, reads until it fills 'buf', an error occurs, or End of File is reached.\nIf 'count' is positive, reads 'count' characters into 'buf'.\nWill always add a null character at the end of the read characters.\nReturns the number of characters read, excluding the added null character.\n\n<h3>int ReadBytes(untyped[] buf, int count = -1, int pos = 0);</h3>\nReads a section of binary data from the file.\nStarts placing data at 'buf[pos]'. If 'pos' is negative, starts at 'buf[0]'.\nIf 'count' is 0, does nothing and returns 0.\nIf 'count' is negative, reads until it fills 'buf', an error occurs, or End of File is reached.\nIf 'count' is positive, reads 'count' characters into 'buf'.\nThe binary data read will be 8b; such that reading '1' will place '1' into buf. This means that the binary data cannot contain decimal places.\nReturns the number of bytes read.\n\n<h3>int ReadInts(untyped[] buf, int count = -1, int pos = 0);</h3>\nReads a section of binary data from the file.\nStarts placing data at 'buf[pos]'. If 'pos' is negative, starts at 'buf[0]'.\nIf 'count' is 0, does nothing and returns 0.\nIf 'count' is negative, reads until it fills 'buf', an error occurs, or End of File is reached.\nIf 'count' is positive, reads 'count' characters into 'buf'.\nThe binary data read will be 32b; such that reading '1' will place '0.0001' into buf. This means that the binary data can contain decimal places.\nReturns the number of ints read.\n\n<h3>char32 GetChar();</h3>\nReads and returns the next character in the file.\nReturns -1 if it fails; check 'EOF' and 'Error' to see why.\n<h3>char32 UngetChar(char32 c);</h3>\nUn-reads 'c' to the input stream.\nReturns -1 if it fails; otherwise returns 'c'.\nThis is a READ operation, not a WRITE operation. The file will not actually be modified; but further read operations will find this as the next character to be read.\nUseful if you read a character, then realize you don't want it."},{"name":"File Writing ;; file::WriteString / file::WriteChars / file::WriteBytes / file::WriteInts / file::PutChar","val":"<h3>int WriteString(char32[] str);</h3>\nWrites the string stored in 'str' to the file.\nReturns the number of characters successfully written.\n\n<h3>int WriteChars(char32[] buf, int count = -1, int pos = 0);</h3>\nWrites characters from 'buf' to file.\nStarts at 'buf[pos]'. If 'pos' is negative, starts at 'buf[0]'.\nIf 'count' is 0, does nothing and returns 0.\nIf 'count' is negative, writes from 'buf' until it finds a null character, or reaches the end of 'buf'.\nIf 'count' is positive, writes 'count' characters from buf.\nReturns the number of characters successfully written.\n\n<h3>int WriteBytes(untyped[] arr, int count = -1, int pos = 0);</h3>\nWrites 8b binary data from 'arr' to file.\nThe binary data written will be 8b; such that writing '1' will write '1' to file. This means that the binary data cannot contain decimal places.\nStarts at 'arr[pos]'. If 'pos' is negative, starts at 'arr[0]'.\nIf 'count' is 0, does nothing and returns 0.\nIf 'count' is negative, writes from 'arr' until it reaches the end of 'arr'.\nIf 'count' is positive, writes 'count' ints from arr.\nReturns the number of bytes successfully written.\n\n<h3>int WriteInts(untyped[] arr, int count = -1, int pos = 0);</h3>\nWrites 32b binary data from 'arr' to file.\nThe binary data written will be 32b; such that writing '1' will write '10000' to file. This means that the binary data can contain decimal places; writing '0.0001' will write '1' to file.\nStarts at 'arr[pos]'. If 'pos' is negative, starts at 'arr[0]'.\nIf 'count' is 0, does nothing and returns 0.\nIf 'count' is negative, writes from 'arr' until it reaches the end of 'arr'.\nIf 'count' is positive, writes 'count' ints from arr.\nReturns the number of 32b integers successfully written.\n\n<h3>char32 PutChar(char32 c);</h3>\nWrites 'c' to file.\nReturns -1 if it fails; otherwise returns 'c'."},{"name":"File Position ;; file::Pos / file::Seek / file::Rewind","val":"<h3>long Pos;</h3>\nRead-only. This represents the current position in the file.\nIn binary modes ('Open()', 'Create()', or 'OpenMode()' including \"b\"), this is the number of bytes into the file, as a long; i.e. '10L' == 10 bytes.\nIn text modes ('OpenMode()' not including \"b\"), the numerical value may not be meaningful but can still be used to restore the position to the same position later using 'Seek()' (if there are characters put back using 'UngetChar()' still pending of being read, the behavior is undefined).\n\n<h3>bool Seek(long pos, bool from_current = false);</h3>\nMoves the current position of the file.\n'pos' is a 32b value, where '1L' represents 1 byte; similar to 'Pos'.\nIf 'from_current' is true, it moves forward from the current position.\nOtherwise, it moves so that 'Pos' is equal to 'pos'.\nUsing 'from_current'==true in a file open in text mode ('OpenMode()' not including \"b\") is undefined.\nReturns true if successful, false otherwise.\nIf successful, this function has the following side-effects:\n<ul><li>All previous calls to 'UngetChar()' are dropped.</li>\n<li>The 'EOF' indicator is set to false.</li>\n<li>Allows switching between reading and writing on a read/write file.</li></ul>\n\n<h3>void Rewind();</h3>\nRewinds to the beginning of the file.\nThis function has the following side-effects:\n<ul><li>All previous calls to 'UngetChar()' are dropped.</li>\n<li>The 'EOF' indicator is set to false.</li>\n<li>The 'Error' indicator is set to 0.</li>\n<li>Allows switching between reading and writing on a read/write file.</li></ul>"},{"name":"File Status ;; file::EOF / file::Error / file::ClearError / file::GetError","val":"<h3>bool EOF;</h3>\nRead-Only. Returns true if a read call attempted to read past the end of the file.\nIf true, no further read calls will succeed until the position has been changed; i.e. 'Seek()' or 'Rewind()'.\n\n<h3>int Error;</h3>\r\nRead-Only. Returns 0 if the file has not enountered an error.\r\nIf an error was encountered, returns an error code number.\n\n<h3>void ClearError();</h3>\r\nClears the active EOF and Error indicators.\r\ni.e. this writes 'EOF = false;' and 'Error = 0;'.\n\n<h3>void GetError(char32[] buf);</h3>\r\nStores a string describing the current error into the buffer provided.\r\nStores an empty string if 'Error == 0'."}],[{"name":"&lt;-- Managed Pointers ;; function_data_managed","val":"$0$7"},{"name":"<em>directory</em>","val":"<h3>Directory Pointers</h3>   `directory`\n\n`directory` pointers allow interacting with directories on the user's system.\nEach quest has a directory created at \"[zc root]/files/[quest name]/\", and ONLY directories within this directory are accessible. All paths are relative to this directory.\n\nSee: ${LoadDirectory}"},{"name":"Access ;; directory::Size / directory::GetFilename / directory::Reload","val":"<h3>int Size;</h3>\nRead-only. The number of files/folders contained in the directory.\n\n<h3>bool GetFilename(int index, char32[] buf);</h3>\nLoads the name of the 'index' file (0 <= index < Size)\nThe name will be placed in the buffer\nReturns true if successful, false if it fails.\n\n<h3>void Reload();</h3>\nRefreshes the directory, updating the 'Size' and results of 'GetFilename()' to reflect any changes."},{"name":"Pointer Management ;; directory::Free / directory::Own","val":"<h3>void Free();</h3>\nThis will deallocate the directory pointer, so that the pointer ID may be re-used.\nThere is a limit to how many directory pointers may be allocated at once, so be sure to free them when you are no longer using them.\n\n<h3>void Own();</h3>\nGrants 'Ownership' of the directory pointer to the script that calls this function. When the script with 'Ownership' terminates (at the same time its' local arrays are deallocated), this directory pointer will automatically be 'Free()'d."}],[{"name":"&lt;-- Global Pointers ;; function_globalptr","val":"$0$3"},{"name":"<em>Hero</em>","val":"The `Hero->` pointer holds various data and functions related to the player character.\n\n`Player->` is an alternate token, which accesses the same functions."},{"name":"State ;; Hero::Position / Hero::Jump / Hero::Dir / Hero::Action / Hero::Climbing / Hero::JumpCount","val":"<h3>int X; int Y; int Z;</h3>\nRead/Write; These values store the player's position on each of the three axes.\nIf the quest rule [['Sprite Coordinates are Float'|at \"ZScript->Quest Script Settings->Object\"]] is checked, these values can include up to 4 decimal places; otherwise values are truncated to int.\n\n<h3>int Jump;</h3>\nThe speed, in pixels per frame, that the Hero is moving upwards along the Z axis.\n\nUnless on the ground, the quest's Gravity is subtracted from this each frame (until it is lower than the terminal velocity value).\n\n<h3>int Dir;</h3>\nThe direction the Hero is facing. The Hero may not face diagonally.\n\n<h3>int HitDir;</h3>\nThe direction the Hero is currently being knocked back, if they are being knocked back.\n\n<h3>int Action;</h3>\nRepresents the Hero's current action state. Writing to this may cause various effects to occur, depending on what the value was previously, and what the new value is.\n\nUse the `LA_` constants to access this.\n\n<h3>int FakeZ;</h3>\nThe Hero's current FakeZ axis position. This value is treated as a second, separate Z axis;\nSprites will be offset upwards by this amount when drawn just like the Z axis and shadows will draw if applicable; however, the sprite's hitbox will not be moved upwards into the Z Axis; instead it will be moved upwards on the Y axis, mimicking how Vires and Pols Voice worked in the original Zelda.\nThis value is affected by 'FakeJump' instead of 'Jump'.\n \n<h3>int FakeJump;</h3>\nThe current velocity on the FakeZ axis. This value is added to FakeZ every frame; and this value is decreased by the gravity value until it is lower than the terminal velocity value.\n\n<h3>bool Climbing;</h3>\nIf true, the Hero is currently holding onto a Sideview Ladder.\n\n<h3>bool JumpCount;</h3>\nThe number of jumps the player has jumped in mid-air since the last time they landed.\nIf positive, resets to 0 when landing.\nRoc's Feathers allow you to jump in mid-air if this is less than the Extra Jumps count of the feather item.\n\n<h3>bool Standing;</h3>\nRead-only. Returns true if the Hero is standing on the ground.\n\n<h3>int CoyoteTime;</h3>\nThe number of frames the Hero has been off the ground, max 65535.\nIf the Hero jumps, immediately sets this value to 65535.\nIf this value is not 65535 and is less than a Feather item's Coyote Time value, that feather can be used to jump, even in mid-air."},{"name":"Equipped Items ;; Hero::ItemA / Hero::ItemB / Hero::ItemX / Hero::ItemY / HeroButtonItems / Hero::SetEquipmentA / Hero::SetEquipmentB / Hero::SetEquipmentX / Hero::SetEquipmentY","val":"<h3>int ItemA;\nint ItemB;\nint ItemX;\nint ItemY;</h3>\nWhen reading these values, returns the item ID currently equipped to the given button. Returns '-1' if no item is equipped.\nWhen writing a value other than '-1', forcibly equips the given item to the given button (force-equip may or may not play nicely with engine active subscreens?).\nWriting '-1' will un-force-equip an item.\n\n<h3>void SelectAWeapon(int dir);\nvoid SelectBWeapon(int dir);\nvoid SelectXWeapon(int dir);\nvoid SelectYWeapon(int dir);</h3>\nChanges the item equipped to the given button, as though the engine subscreen selection was moved in the specified direction. DIR_RIGHT and DIR_LEFT for this work the same way as the engine's item quickswap right/left."},{"name":"Status Effects ;; Hero::SwordJinx / Hero::ItemJinx / Hero::Stun / Hero::Drunk / Hero::Eaten / Hero::ClockActive / Hero::ClockTimer / Hero::Grabbed / Hero::BunnyClk","val":"<h3>int SwordJinx; int ItemJinx;</h3>\nRepresents the duration of the Jinx status effects. The sword jinx prevents the Hero from using their sword, while the Item jinx prevents using all other items.\n\nIf the value is '-1', the jinx is currently active, with no timer.\nIf the value is '> 0', the jinx is currently active, with that many frames remaining until it wears off on its' own.\n\n<h3>int Stun;</h3>\nRepresents the remaining duration of the Stun effect on the player. While stunned, the player cannot do almost anything.\n\n<h3>int BunnyClk;</h3>\nRepresents the duration of the Bunny effect.\n\nIf the value is '>0', the player is a Bunny for that many frames.\nIf the value is '-1', the bunny effect is based on the current dmap being a bunny dmap, and the player not having a Pearl item.\nValues '-2' to '-99' are reserved for future engine use.\nIf the value is '<= -100', the player will remain a bunny until a script changes this.\n\n<h3>bool ClockActive;</h3>\nIf true, a 'Clock' item is active, rendering the player invincible and freezing all enemies.\n<h3>int ClockTimer;</h3>\nThe remaining time on the 'Clock' effect. If this is 0, but 'ClockActive' is true, then the effect lasts until screen change.\n\n<h3>int Drunk;</h3>\nThe value represents the duration of the Drunk status affect, and also affects the intensity of the effect. While active, messes with the players controls, randomly toggling their input (either pressing buttons they did not press, or un-pressing buttons they did press). The longer duration remaining, the higher the rate of input interference.\n\n<h3>int Eaten;</h3>\nThe duration the player has been eaten (i.e. LikeLike) for, 0 if not eaten.\n\n<h3>bool Grabbed;</h3>\nTrue if the player has been grabbed (i.e. Wallmaster)"},{"name":"HP / MP ;; Hero::HP / Hero::MP / Hero::MaxHP / Hero::MaxMP","val":"<h3>int HP; int MP;\nint MaxHP; int MaxMP;</h3>\nRepresents the Hero's health, magic, and the maxes for each of these."},{"name":"TileMod ;; Hero::TileMod","val":"<h3>int TileMod;</h3>\nRead-only. Returns the current total 'Player Tile Modifier'.\nThis is calculated by summing the PTM of [[all owned items|'Active Use' shields only apply their PTM if they are in-use, instead applying a separate 'inactive PTM' if they are not in use.\nIf the Hero is currently a Bunny, PTMs for items that are not 'Usable As Bunny' will not be applied, though the global 'Bunny PTM' will be.]]."},{"name":"Graphics ;; Hero::Tile / Hero::Flip / Hero::ScriptTile / Hero::ScriptFlip / Hero::ScriptCSet / Hero::Scale / Hero::Rotation","val":"<h3>int Tile;</h3>\nThe tile the engine animation has selected to display this frame for the player.\n\n<h3>int Flip;</h3>\nThe flip value the engine animation has selected to display this frame for the player.\n\n<h3>int CSet;</h3>\nThe cset value the engine animation has selected to display this frame for the player.\n\n<h3>int ScriptTile;</h3>\nIf not '-1', this tile will override the engine's selected tile for the player.\n\n<h3>int ScriptFlip;</h3>\nIf not '-1', this tile will override the engine's selected flip for the player.\n\n<h3>int ScriptCSet;</h3>\nIf not '-1', this CSet will override the engine's selected cset for the player.\n\n<h3>int Scale;</h3>\nA scale that will be applied to the player's drawn size (does not affect hitbox)\n\n<h3>int Rotation;</h3>\nA rotation angle (in Degrees) that will be applied to the player's draw (does not affect hitbox)\n\n<h3>int ShadowXOffset;\nint ShadowYOffset;</h3>\nOffsets to the draw position of the Hero's shadow."},{"name":"Warping ;; Hero::Warp / Hero::WarpEx / Hero::PitWarp / Hero::IsWarping","val":"<h3>void Warp(int dmap, int screen);</h3>\nWarps the player to the specified dmap/screen. Uses an 'Insta-Warp' type, and uses the 'A' return square.\n\n<h3>void PitWarp(int dmap, int screen);</h3>\nSame as 'Warp()', but instead of positioning the Hero at the 'A' return square, instead the Hero stays in the exact same position.\n\n<h3>bool IsWarping;</h3>\nRead-only, true if a warp is currently in progress.\n\n<h3>void WarpEx(int[] ptr);</h3>\nWarpEX takes an array pointer containing parameters, instead of a set of parameters.\nValid parameter sets:\n<ul><li>Hero->WarpEx({type, dmap, screen, x, y, effect, sound, flags});</li>\n<li>Hero->WarpEx({type, dmap, screen, x, y, effect, sound, flags, forcedir});</li></ul>\n\nParameter descriptions:\n<ul><li>type: The warp type to use. Uses the `WT_` constants. All insta-warp types act the same, and do not provide their warp effect.</li>\n<li>dmap / screen: the location to warp to</li>\n<li>x / y: These represent the position to spawn at, either using a [[return square|If 'x &lt; 0', use the `WARP_` constants for 'y' to specify one of the 4 return squares.]], [[pitwarp|Setting both x and y '&lt; 0', or 'x &lt; 0' and 'y == 5', causes the player to stay in place.]], or [[coordinates|If 'x &gt; 0' and 'y &gt; 0', the Hero will spawn on the new screen at those coordinates.]].</li>\n<li>effect: What warp effect to display (uses [[`WARPEFFECT_`|$WARPEFFECT_]] constants)</li>\n<li>sound: An SFX to play during the warp.</li>\n<li>flags: See flag details below</li>\n<li>forcedir: If a direction is supplied for 'forcedir', the Hero will face that direction after the warp.</li></ul>\n\nWarp flags use the `WARP_FLAG_` constants, OR'd (`|`) together.\n<ul><li>[[WARP_FLAG_PLAYSOUNDS|If enabled, SFX will not be killed during the warp.]]</li>\n<li>[[WARP_FLAG_PLAYMUSIC|If enabled, Music will not be killed during the warp.]]</li>\n<li>[[WARP_FLAG_SCRIPTDRAW|If enabled, script draws will remain during the warp.]]</li>\n<li>[[WARP_FLAG_SETENTRANCESCREEN|If enabled, the 'last entrance screen' will be set by the warp.]]</li>\n<li>[[WARP_FLAG_SETENTRANCEDMAP|If enabled, the 'last entrance dmap' will be set by the warp.]]</li>\n<li>[[WARP_FLAG_SETCONTINUESCREEN|If enabled, the 'continue screen' will be set by the warp.]]</li>\n<li>[[WARP_FLAG_SETCONTINUEDMAP|If enabled, the 'continue dmap' will be set by the warp.]]</li>\n<li>[[WARP_FLAG_DONTCLEARSPRITES|If enabled, sprite type objects (such as weapons, items, enemies) will not be destroyed, and will warp to the new screen with you.]]</li>\n<li>[[WARP_FLAG_CLEARITEMS|Clears items from the screen, even with WARP_FLAG_DONTCLEARSPRITES enabled.]]</li>\n<li>[[WARP_FLAG_CLEARGUYS|Clears enemies from the screen, even with WARP_FLAG_DONTCLEARSPRITES enabled.]]</li>\n<li>[[WARP_FLAG_CLEARLWEAPONS|Clears lweapons from the screen, even with WARP_FLAG_DONTCLEARSPRITES enabled.]]</li>\n<li>[[WARP_FLAG_CLEAREWEAPONS|Clears eweapons from the screen, even with WARP_FLAG_DONTCLEARSPRITES enabled.]]</li>\n<li>[[WARP_FLAG_CLEARHOOKSHOT|Clears hookshot weapons from the screen, even with WARP_FLAG_DONTCLEARSPRITES enabled.]]</li>\n<li>[[WARP_FLAG_CLEARDECORATIONS|Clears decorations from the screen, even with WARP_FLAG_DONTCLEARSPRITES enabled.]]</li>\n<li>[[WARP_FLAG_CLEARPARTICLES|Clears particles from the screen, even with WARP_FLAG_DONTCLEARSPRITES enabled.]]</li>\n<li>[[WARP_FLAG_NOSTEPFORWARD|Prevents the 'step forward' animation that occurs on entering a dungeon screen from occurring after the warp.]]</li></ul>"},{"name":"Explode ;; Hero::Explode","val":"<h3>void Explode(int mode);</h3>\nCreates an effect of the Hero's sprite 'Exploding'. This creates a particle for each pixel of the Hero's visual sprite, which will move in a pattern based on the selected 'mode'.\n\nModes:\n<ol start=\"0\"><li>Twilight</li>\n<li>Sand of Hours</li>\n<li>Farore's Wind</li></ol>"},{"name":"--&gt; Next ;; heroptr2","val":"$-1$1"},{"name":"--&gt;&gt; End ;; heroptr3","val":"$-1$2"}],[{"name":"&lt;-- Global Pointers ;; function_globalptr","val":"$0$3"},{"name":"Invunlerability ;; Hero::InvFrames / Hero::InvFlicker","val":"<h3>int InvFrames;</h3>\nThe number of frames the player is currently invulnerable (after being hit). Read/write.\n\n<h3>bool InvFlicker;</h3>\nIf set false, the player with neither flash nor flicker when invincible."},{"name":"Defense ;; Hero::Defense","val":"<h3>int Defense[MAX_DEFENSE];</h3>\nRepresents the player's weapon defenses.\nAccess using the 'NPCD_' constants for indexes, and the 'NPCDT_' constants for the values."},{"name":"HitBy ;; Hero::HitBy","val":"<h3>untyped HitBy[];</h3>\nAccess the following data indexes:\n<ul><li>HIT_BY_NPC - the Screen Index of the NPC that hit the player this frame.</li>\n<li>HIT_BY_NPC_UID - the UID of the NPC that hit the player this frame.</li>\n<li>HIT_BY_EWEAPON - the Screen Index of the EWEAPON that hit the player this frame.</li>\n<li>HIT_BY_EWEAPON_UID - the UID of the EWEAPON that hit the player this frame.</li>\n<li>HIT_BY_LWEAPON - the Screen Index of the LWEAPON that hit the player this frame.</li>\n<li>HIT_BY_LWEAPON_UID - the UID of the LWEAPON that hit the player this frame.</li></ul>"},{"name":"Item ;; Hero::Item","val":"<h3>bool Item[NUM_ITEMDATA];</h3>\nAccess using Item IDs as indexes. Represents if the item is currently owned by the player. Read/Write."},{"name":"Movespeed ;; Hero::Steps / Hero::Step / HeroMovement","val":"<h3>int Step;</h3>\nIf the quest rule [['New Hero Movement'|at \"Quest->Options->Player\"]] is enabled, this represents the move rate of the player, in 100ths pixel per frame (Default 150, i.e. 1.5 pixels per frame; changable in 'Init Data')\n\n<h3>int Steps[8];</h3>\nIf the quest rule [['New Hero Movement'|at \"Quest->Options->Player\"]] is NOT enabled, this array is used to move the player.\nWhen moving horizontally/vertically, the x/y modulo 8 determines which index is used, and that many pixels will be moved.\nModifying this array requires care to actually accomplish anything, and it is highly recommended to enable the 'New Hero Movement' quest rule and use 'Hero->Step' above instead."},{"name":"HeldItem ;; Hero::HeldItem","val":"<h3>int HeldItem;</h3>\nThe item displayed above the Hero's head (requires them to be in an item holding ${Hero::Action|Action})."},{"name":"HealthBeep ;; Hero::HealthBeep","val":"<h3>int HealthBeep;</h3>\nNormally between 70 and -1, representing the timer for a non-constant low health beep.\nWriting '-2' to this prevents the engine from stopping the SFX that is set as the health beep.\nWriting '-4' to this prevents the engine from both stopping and starting the SFX."},{"name":"Flags ;; Hero::Flags / Hero::Invisible / Hero::NoStepForward / Hero::Animation / Hero::CollDetection / Hero::Diagonal / Hero::BigHitbox / Hero::Gravity","val":"<h3>bool Invisible;</h3>\nIf set true, will prevent the player from being drawn.\n\n<h3>bool NoStepForward;</h3>\nIf set true, prevents the 'step forward' that occurs when entering a dungeon room.\n\n<h3>bool Animation;</h3>\nIf set false, disables the player's engine animation.\n\n<h3>bool CollDetecton;</h3>\nIf set false, the player's engine collision will be disabled (i.e. player is invincible)\n\n<h3>bool Diagonal;</h3>\nIf true, the Hero can move diagonally.\n\n<h3>bool BigHitbox;</h3>\nIf true, the Hero's hitbox is 16x16 instead of 16x8.\n\n<h3>bool Gravity;</h3>\nIf false, the player ignores gravity."},{"name":"Misc ;; Hero::Misc","val":"<h3>untyped Misc[32];</h3>\nAn array of 32 misc values for script use."},{"name":"&lt;-- Prev ;; heroptr","val":"$-1$0"},{"name":"--&gt; Next ;; heroptr3","val":"$-1$2"}],[{"name":"&lt;-- Global Pointers ;; function_globalptr","val":"$0$3"},{"name":"Ladder Position ;; Hero::LadderX / Hero::LadderY","val":"<h3>int LadderX; int LadderY;</h3>\nThe position the ladder is currently placed at."},{"name":"SFX ;; Hero::HurtSound","val":"<h3>int HurtSound;</h3>\nThe SFX played when the player is hurt."},{"name":"Pushing ;; Hero::Pushing","val":"<h3>int Pushing;</h3>\nThe number of frames the Hero has been pushing against something for."},{"name":"Pit / Water States ;; Hero::PitPullDir / Hero::PitPullTimer / Hero::Falling / Hero::FallCombo","val":"<h3>int PitPullDir;</h3>\nThe direction the player is being pulled into a pit in.\n<h3>int PitPullTimer;</h3>\nThe timer related to pit pulling\n\n<h3>int Falling;</h3>\nIf >0, the player is falling down a pit. Decreases each frame. Max value 70.\n<h3>int FallCombo;</h3>\nThe combo ID of the pit the player is currently falling into.\n\n<h3>int Drowning;</h3>\n<todo>needs docs</todo>\n<h3>int DrownCombo;</h3>\nThe combo ID of the water the player is currently drowning in."},{"name":"MoveFlags ;; Hero::MoveFlags","val":"<h3>bool MoveFlags[];</h3>\nAccess the following flags:\n<ul><li>HEROMV_OBEYS_GRAVITY - If false, the player ignores gravity.</li>\n<li>HEROMV_CAN_PITFALL - If false, the player floats over pitfalls.</li>\n<li>HEROMV_NO_FAKE_Z - The player's Fake Z axis is disabled if true</li>\n<li>HEROMV_NO_REAL_Z - The player's Z axis is disabled if true</li></ul>"},{"name":"Respawn Position ;; Hero::RespawnX / Hero::RespawnY / Hero::RespawnDMap / Hero::RespawnScreen","val":"<h3>int RespawnX;\nint RespawnY;\nint RespawnDMap;\nint RespawnScreen;</h3>\nThe position, dmap, and screen that the player will respawn at when they drown or fall in a bottomless pit.\nDoes nothing if [['Classic Respawn Points'|at \"Quest->Options->Combo\"]] is enabled."},{"name":"SwitchHook values ;; Hero::SwitchTimer / Hero::SwitchMaxTimer / Hero::SwitchCombo","val":"<h3>int SwitchTimer;\nint SwitchMaxTimer;</h3>\nTimer values for the current switchhook effect.\nIf 'SwitchTimer' is '>0', then a switchhook effect is currently active. When 'SwitchTimer' == 'SwitchMaxTimer / 2', the player will swap with the target object.\nRead-only.\n\n<h3>bool SwitchCombo(int pos, int effect);</h3>\nSwitch the player with the given combo position. A hookable combo must be present at that position (on any valid layer) for this to succeed.\nUse the `SW_EFF_` constants for 'effect' to select a visual style for the switch.\nReturns true if it succeeds, and false otherwise."},{"name":"Death Effects ;; Hero::Immortal / Hero::Kill","val":"<h3>int Immortal;</h3>\nIf not 0, the player will not die, even when they have 0 hp. Effects such as bottled fairies will not trigger.\nIf '>0', automatically decrements by 1 each frame.\nIf this value becomes 0 while the player is at 0 hp, the death effect will trigger, including any bottled fairies.\n\n<h3>void Kill(bool bypass_revive);</h3>\nImmediately kills the player, setting their HP to 0, and ignoring 'Immortal'.\nIf 'bypass_revive' is true, revival effects such as bottled fairies will not trigger, and the 'one frame before death' that scripts would use to revive will also be skipped."},{"name":"&lt;&lt;-- Start ;; heroptr","val":"$-1$0"},{"name":"&lt;-- Prev ;; heroptr2","val":"$-1$1"}],[{"name":"&lt;-- Managed Pointers ;; function_data_managed","val":"$0$7"},{"name":"<em>randgen</em>","val":"<h3>RandGen Pointers</h3>   `randgen`\n\n`randgen` pointers reference specific random number generators. You can create and seed them yourself.\nAny randgen pointer with a value of `NULL` can be used to reference the engine's RNG. The global pointer `RandGen->` is available as a null `randgen` pointer.\n\nSee: ${LoadRNG}"},{"name":"Rand ;; randgen::Rand ;; Rand","val":"<h3>int Rand();</h3>\nReturns a random number `-214748 to 214748`, inclusive.\n\n<h3>int Rand(int bound);</h3>\nReturns a random number `0 to bound`, inclusive.\n\n<h3>int Rand(int bound1, int bound2);</h3>\nReturns a random number `bound1 to bound2`, inclusive.\n\n<h3>Note</h3>\nAll of these functions return integer values, with no decimal places."},{"name":"LRand ;; randgen::LRand ;; LRand","val":"<h3>long LRand();</h3>\nReturns a random long number `-2147483648L to 2147483647L`, inclusive.\n\n<h3>long LRand(long bound);</h3>\nReturns a random long number `0L to bound`, inclusive.\n\n<h3>long LRand(long bound1, long bound2);</h3>\nReturns a random long number `bound1 to bound2`, inclusive.\n\n<h3>Note</h3>\nAll of these functions return long values. If you treat them as integer values, they will have decimal places."},{"name":"SRand ;; randgen::SRand ;; SRand","val":"<h3>void SRand(long seed);</h3>\nSeeds the RNG with the given seed.\n\n<h3>long SRand();</h3>\nSeeds the RNG with a randomly-determined seed, based off of the system clock and the previous RNG.\nReturns the random seed."},{"name":"Pointer Management ;; randgen::Free / randgen::Own","val":"<h3>void Free();</h3>\nDe-allocates this `randgen` pointer, so that its' pointer ID may be re-used. You may only have a limited number of randgen pointers active at a time; freeing them when you are done with them helps not reach the limit.\n\n<h3>void Own();</h3>\r\nGrants 'Ownership' of the randgen pointer to the script that calls this function. When the script with 'Ownership' terminates (at the same time its' local arrays are deallocated), this randgen pointer will automatically be 'Free()'d."}],[{"name":"&lt;-- Managed Pointers ;; function_data_managed","val":"$0$7"},{"name":"<em>stack</em>","val":"<h3>Stack Pointers</h3>   `stack`\n\n`stack` pointers allow storing and managing large sets of data, similar to arrays. The max storage of a stack is `2,147,483,647` elements, compared to arrays which have a maximum of `214,748` elements. Stacks also have various functions for accessing the data.\n\nSee: ${LoadStack}"},{"name":"Size ;; stack::Size / stack::Full","val":"<h3>long Size;</h3>\nRead-only. The size of the stack, given as a LONG. This means that a stack with 5 items will have a size of '5L'.\n\n<h3>bool Full;</h3>\nRead-only. Returns true if the stack cannot hold any more elements."},{"name":"Push ;; stack::PushBack / stack::PushFront","val":"If the stack is ${stack::Full|full}, Push functions will do nothing.\n\n<h3>void PushBack(untyped val);</h3>\nAdds the element 'val' to the end of the stack.\n\n<h3>void PushFront(untyped val);</h3>\nAdds the element 'val' to the beginning of the stack."},{"name":"Pop / Peek ;; stack::PopBack / stack::PopFront / stack::PeekBack / stack::PeekFront","val":"If the stack is empty, Pop and Peek functions will return '0', doing nothing else.\n\n<h3>untyped PopBack();</h3>\nReturns the last element in the stack, removing it from the stack in the process.\n\n<h3>untyped PopFront();</h3>\nReturns the first element in the stack, removing it from the stack in the process.\n\n<h3>untyped PeekBack();</h3>\nReturns the last element in the stack, without removing it.\n\n<h3>untyped PeekFront();</h3>\nReturns the first element in the stack, without removing it."},{"name":"Other Access ;; stack::Get / stack::Set / stack::Clear","val":"<h3>void Clear();</h3>\nRemoves every element from the stack.\n\n<h3>untyped Get(long ind);</h3>\nReturns the element at the index 'ind', which is a LONG value. This means that '0L' is the first element, '1L' is the second, etc.\nIf an invalid index is given, '0' is returned.\n\n<h3>void Set(long ind, untyped val);</h3>\nOverwrites the element at the index 'ind' (which is a LONG value) with 'val'. This means that '0L' is the first element, '1L' is the second, etc.\nIf an invalid index is given, nothing happens."},{"name":"Pointer Management ;; stack::Free / stack::Own","val":"<h3>void Free();</h3>\nDe-allocates this `stack` pointer, so that its' pointer ID may be re-used. You may only have a limited number of stack pointers active at a time; freeing them when you are done with them helps not reach the limit.\n\n<h3>void Own();</h3>\nGrants 'Ownership' of the stack pointer to the script that calls this function. When the script with 'Ownership' terminates (at the same time its' local arrays are deallocated), this stack pointer will automatically be 'Free()'d."}],[{"name":"&lt;-- Misc Data Pointers ;; function_data_misc","val":"$0$6"},{"name":"<em>bottledata</em>","val":"<h3>BottleData Pointers</h3>   `bottledata`\n\n`bottledata` pointers allow accessing data relating to 'Bottle Types'.\n\nSee: ${LoadBottleData}"},{"name":"Name ;; bottledata::name / bottledata::GetName / bottledata::SetName","val":"<h3>void GetName(char32[] str);</h3>\nLoads the name of the bottledata into the provided string buffer.\n\n<h3>void SetName(char32[] str);</h3>\nSets the name of the bottledata to the provided string.\n"},{"name":"Counter ;; bottledata::Counter","val":"<h3>int Counter[3];</h3>\n\nThe refill counters of this bottle type.\n\nUse the `CR_` constants for these values."},{"name":"Amount ;; bottledata::Amount","val":"<h3>int Amount[3];</h3>\n\nThe amount to refill each counter (0-65535)"},{"name":"IsPercent ;; bottledata::IsPercent","val":"<h3>bool IsPercent[3];</h3>\n\nWhether the given counter refill is a percentage of max, instead of a direct value."},{"name":"Flags ;; bottledata::Flags","val":"<h3>bool Flags[4];</h3>\n\nA set of flags. Use the `BTF_` constants to access this."},{"name":"NextType ;; bottledata::NextType","val":"<h3>int NextType;</h3>\n\nWhat bottle type will remain in the bottle after drinking the current type."}],[{"name":"&lt;-- Misc Data Pointers ;; function_data_misc","val":"$0$6"},{"name":"<em>bottleshopdata</em>","val":"<h3>BottleShopData Pointers</h3>   `bottleshopdata`\n\n`bottleshopdata` pointers allow accessing data relating to 'Bottle Shop Types'.\n\nSee: ${LoadBottleShopData}\n\nRelated: ${bottledata}"},{"name":"Name ;; bottleshopdata::GetName / bottleshopdata::SetName","val":"<h3>void GetName(char32[] str);</h3>\nLoads the name of the bottleshopdata into the provided string buffer.\n\n<h3>void SetName(char32[] str);</h3>\nSets the name of the bottleshopdata to the provided string.\n"},{"name":"Fill ;; bottleshopdata::Fill","val":"<h3>int Fill[3];</h3>\n\nWhich bottle type each index fills a bottle with.\n\nRelated: ${bottledata}"},{"name":"Combo ;; bottleshopdata::Combo","val":"<h3>int Combo[3];</h3>\n\nWhat combo to display as a visual for each index."},{"name":"CSet ;; bottleshopdata::CSet","val":"<h3>int CSet[3];</h3>\n\nWhat CSet to use for the combo for each index."},{"name":"Price ;; bottleshopdata::Price","val":"<h3>int Price[3];</h3>\n\nThe price, in rupees (0-65535) to purchase each index."},{"name":"InfoString ;; bottleshopdata::InfoString","val":"<h3>int InfoString[3];</h3>\n\nThe ${message string} to display upon purchasing each index."}],[{"name":"&lt;-- Misc Data Pointers ;; function_data_misc","val":"$0$6"},{"name":"<em>dropsetdata</em>","val":"<h3>DropsetData Pointers</h3>   `dropsetdata`\n\n`dropsetdata` pointers allow accessing dropsets, and using them to pick random items.\n\nSee: ${LoadDropset}"},{"name":"Choose ;; dropsetdata::Choose","val":"<h3>int Choose();</h3>\n\nRandomly selects an item from the dropset, and returns its' ID.\nReturns `-1` if ${dropsetdata::NothingChance|nothing} is chosen."},{"name":"Items ;; dropsetdata::Items","val":"<h3>int Items[10];</h3>\n\nThe item IDs stored in this dropset."},{"name":"Chances ;; dropsetdata::Chances","val":"<h3>int Chances[10];</h3>\n\nThe chances for each item to appear. These are <em>not</em> percentages, but weights; changing one will affect the odds of all of them."},{"name":"NothingChance ;; dropsetdata::NothingChance","val":"<h3>int NothingChance;</h3>\n\nThe weighted value for no item being chosen at all."}],[{"name":"&lt;-- Misc Data Pointers ;; function_data_misc","val":"$0$6"},{"name":"<em>messagedata</em>","val":"<h3>MessageData Pointers</h3>   `messagedata`\n\n`messagedata` pointers allow accessing and editing ${message strings}.\n\nSee: ${LoadMessageData}"},{"name":"Message ;; messagedata::Get / messagedata::Set / messagedata::Length","val":"<h3>void Get(char32[] str);</h3>\nLoads the message into the provided string buffer.\n\n<h3>void Set(char32[] str);</h3>\nSets the message to the provided string.\n\n<h3>int Length;</h3>\nThe length, in characters, of the message. Read-only."},{"name":"Positioning ;; messagedata::X / messagedata::Y / messagedata::Width / messagedata::Height","val":"<h3>int X;\nint Y;</h3>\n\nThe X/Y position of the message box.\n\n<h3>int Width;\nint Height;</h3>\n\nThe width/height of the message box, in pixels.\nIf [[Old String Frame Width/Height|at Quest->Options->Compat]] is checked, the box will actually be 16 pixels wider and taller than is set here."},{"name":"Text Display ;; messagedata::Font / messagedata::VSpace / messagedata::HSpace / messagedata::Margins","val":"<h3>int Font;</h3>\nThe font to display the message in. Use the `FONT_` constants for this value.\n\n<h3>int VSpace;\nint HSpace;</h3>\nThe spacing between lines/characters, in pixels.\n\n<h3>int Margins[4];</h3>\n\nThe margins, in pixels, from each edge of the text box. Use the `DIR_` constants to access this.\nIf [[Old String Margins|at Quest->Options->Compat]] is checked, these will not apply."},{"name":"Background Graphics ;; messagedata::Tile / messagedata::CSet","val":"<h3>int Tile;</h3>\nThe tile used for the background.\nIf the ${messagedata::Flags|'Full Tiled Background' flag} is set, this is the top-left tile of a tile block the size of the message box.\nOtherwise, it is the top-left of a 2x2 square of tiles in a 'frame' style.\n\n<h3>int CSet;</h3>\nThe CSet to draw the background in."},{"name":"Portraits ;; messagedata::PortraitTile / messagedata::PortraitCSet / messagedata::PortraitX / messagedata::PortraitY / messagedata::PortraitTileWidth / messagedata::PortraitTileHeight","val":"<h3>int PortraitTile;</h3>\nThe upper-left corner tile of the portrait. If set to 0, no portrait will be displayed.\n\n<h3>int PortraitCSet;</h3>\nThe CSet to draw the portrait in\n\n<h3>int PortraitX;\nint PortraitY;</h3>\nThe X/Y position of the portrait.\n\n<h3>int PortraitTileWidth;\nint PortraitTileHeight;</h3>\nThe tile width/height of the portrait. Max 16 and 14 respectively. If either is '0', no portrait will be displayed."},{"name":"Next ;; messagedata::Next","val":"<h3>int Next;</h3>\n\nThe 'next' message, which will be automatically displayed when this message finishes.\nIf set to 0, no message will automatically follow this one."},{"name":"Sound ;; messagedata::Sound","val":"<h3>int Sound;</h3>\n\nThe SFX to play when a new character is drawn (including spaces).\nIf 0, no sound is played."},{"name":"ListPosition ;; messagedata::ListPosition","val":"<h3>int ListPosition;</h3>\n\nThe list position of the messagedata as it is displayed in ZQ."},{"name":"Flags ;; messagedata::Flags","val":"<h3>bool Flags[7];</h3>\n\nA set of flags for the messagedata.\n<ol start=\"0\">\n<li>MSGFLAG_WRAP: If the text wraps around the bounding box</li>\n<li>MSGFLAG_CONT: If the message is a continuation of the previous one</li>\n<li value=\"4\">MSGFLAG_FULLTILE: If the ${messagedata::Tile|background} is 'Full Tiled'</li>\n<li>MSGFLAG_TRANS_BG: If the background is transparent</li>\n<li>MSGFLAG_TRANS_FG: If the text is transparent</li>\n</ol>"},{"name":"TextWidth / TextHeight ;; messagedata::TextWidth / messagedata::TextHeight","val":"<h3>int TextWidth();\nint TextHeight();</h3>\n\nReturns the width/height, in pixels, of the message text - <em>not</em> including line wrap / breaks.\nThis is the width/height that would be used to call ${Screen::DrawString|DrawString} with this message string and font.\n\nTextHeight() is effectively the same as calling ${Text::FontHeight|Text->FontHeight()} using ${messagedata::Font|the message's font}.\nTextWidth() is effectively the same as using ${messagedata::Get|messagedata->Get()} to get the text into a ZScript string, and then passing that with ${messagedata::Font|the message's font} to ${Text::StringWidth|Text->StringWidth()}."},{"name":"Shadow Graphics ;; messagedata::ShadowType / messagedata::ShadowColor","val":"<todo>Shadow effects are not yet accessible!</todo>"}],[{"name":"&lt;-- Misc Data Pointers ;; function_data_misc","val":"$0$6"},{"name":"<em>shopdata</em>","val":"<h3>ShopData Pointers</h3>   `shopdata`\n\n`shopdata` pointers allow accessing data relating to 'Bottle Shop Types'.\n\nSee: ${LoadShopData}, ${LoadInfoShopData}"},{"name":"Type ;; shopdata::Type","val":"<h3>int Type;</h3>\n\nRead-only. Returns the type of the shop, where:\n<ol start=\"0\">\n<li>Invalid</li>\n<li>Item Shop</li>\n<li>Info Shop</li>\n</ol>"},{"name":"Item ;; shopdata::Item / shopdata::HasItem","val":"<h3>int Item[3];</h3>\n\nThe 3 items available in the shop.\n\n<h3>bool HasItem[3];</h3>\n\nWhether a given position should have an item.\n\n<h3>Note:</h3>\nThese values are only valid for ${shopdata::Type|item shops}."},{"name":"Price ;; shopdata::Price","val":"<h3>int Price[3];</h3>\n\nThe price, in rupees (0-65535) to purchase each index."},{"name":"String ;; shopdata::String","val":"<h3>int String[3];</h3>\n\nThe ${message string} to display upon purchasing each index."}],[{"name":"&lt;-- Global Pointers ;; function_globalptr","val":"$0$3"},{"name":"<em>Screen</em> ;;screeninfo","val":"The `Screen->` pointer holds various data pertaining to how each screen is made up, as well as various functions which draw to the screen, or create/load pointers to objects present on the screen."},{"name":"Shared with 'mapdata' ;; mapscrShare","val":"$MapData$1"},{"name":"Shared with 'bitmap' ;;bitscrShare","val":"$Bitmap$2"},{"name":"Effects ;; Screen::Lit / Screen::Wavy / Screen::Quake","val":"<h3>bool Lit;</h3>\nWhether or not the screen is 'lit'. Applies to Classic Darkrooms.\nDoes nothing if [['New Dark Rooms'|at \"Quest->Options->Misc\"]] is enabled.\n\n<h3>int Wavy;</h3>\nThe remaining time, in frames, of the 'Wavy' visual effect. Decrements by 1 each frame.\nThe wavy effect is more intense the higher the value is.\n\n<h3>int Quake;</h3>\nThe remaining time, in frames, of the 'Quake' visual effect. Decrements by 1 each frame.\nThe quake effect is more intense the higher the value is."},{"name":"Screen Objects ;; Screen::LoadFFC / Screen::CreateEWeapon / Screen::LoadEWeapon / Screen::NumEWeapons / Screen::CreateLWeapon / Screen::LoadLWeapon / Screen::NumLWeapons / Screen::CreateNPC / Screen::LoadNPC / Screen::NumNPCs / Screen::CreateItem / Screen::LoadItem / Screen::NumItems / LoadFFC / LoadNPC / LoadLWeapon / LoadEWeapon / LoadItem / CreateNPC / CreateLWeapon / CreateEWeapon / CreateItem / NumFFCs / NumNPCs / NumLWeapons / NumEWeapons / NumItems","val":"<h3>int NumItems();\nint NumNPCs();\nint NumLWeapons();\nint NumEWeapons();\nint NumFFCs();</h3>\nReturns the number of the given object type that are present on the current screen.\n\n<h3>${itemsprite} CreateItem(int id);\n${npc} CreateNPC(int id);\n${lweapon} CreateLWeapon(int id);\n${eweapon} CreateEWeapon(int id);</h3>\nCreates a new sprite object, with the given ID. Use the `LW_` and `EW_` constants for `CreateLWeapon()`/`CreateEWeapon()`. Use the item editor IDs and enemy editor IDs for `CreateItem()`/`CreateNPC()`.\n\n<h3>${itemsprite} LoadItem(int n);\n${npc} LoadNPC(int n);\n${lweapon} LoadLWeapon(int n);\n${eweapon} LoadEWeapon(int n);</h3>\nWhere `1 &lt;= n &lt;= NumObjects`, returns a pointer to the nth object on the screen.\nUsed to access itemsprites, npcs, lweapons, and eweapons that currently exist on the screen.\n\n<h3>${ffc} LoadFFC(int n);</h3>\nReturns a pointer to the nth FFC on the screen, where `1 &lt;= n &lt;= MAX_FFC`.\nUsed to access ffcs that currently exist on the screen.\n\n<h3>${itemsprite} Items[];\n${npc} NPCs[];\n${lweapon} LWeapons[];\n${eweapon} EWeapons[];\n${ffc} FFCs[];</h3>\n${Internal Arrays|Internal Array pointers} to arrays containing all of each respective type of object on the screen. These arrays are 0-indexed."},{"name":"Moving Blocks ;; Screen::MovingBlockX / Screen::MovingBlockY / Screen::MovingBlockLayer / Screen::MovingBlockCombo / Screen::MovingBlockCSet","val":"This data is all related to the current block being pushed on the screen.\n\n<h3>int MovingBlockX;\nint MovingBlockY;</h3>\nThe X/Y position of the block. If no block is being moved, these will both return '-1'.\n\n<h3>int MovingBlockLayer;</h3>\nThe layer of the block. Depending on some QRs, this may affect what combos the block interacts with.\nWhen the block 'clicks into place' after moving, it will be placed on this layer.\n\n<h3>int MovingBlockCombo;\nint MovingBlockCSet;</h3>\nThe combo/cset used by the moving block. These affect how it is drawn during movement, and what combo/cset will be placed on the screen when movement ends."},{"name":"D[] ;; Screen::D","val":"<h3>untyped D[8];</h3>\nA set of 8 misc values for each screen."},{"name":"Screen Open/Close Effects ;; Screen::ClosingWipe / Screen::OpeningWipe / Screen::WavyOut / Screen::WavyIn / Screen::ZapOut / Screen::ZapIn","val":"<h3>void WavyIn();\nvoid WavyOut();</h3>\nPlays the warping screen 'wave' effect.\n\n<h3>void ZapIn();\nvoid ZapOut();</h3>\nPlays the warping screen 'zap' effect.\n\n<h3>void OpeningWipe();\nvoid ClosingWipe();</h3>\nPlays the warping screen 'wipe' effect, respecting the wipe-related QRs.\n\n<h3>void OpeningWipe(int shape);\nvoid ClosingWipe(int shape);</h3>\nPlays the warping screen 'wipe' effect with the specified shape, using the `WIPE_` constants for the shape."},{"name":"Message Strings ;; Screen::Message / Screen::ShowingMessage","val":"Related: ${messagedata}, ${Message Strings}\n\n<h3>int ShowingMessage;</h3>\nRead-only. The message ID of the messagestring currently showing on-screen.\nReads 0 if no message is being displayed.\n\n<h3>void Message(int msgID);</h3>\nDisplays the specified messagestring on the screen.\nIf '0' is passed, closes any message that is already open on the screen."},{"name":"Misc ;; Screen::TriggerSecrets / Screen::SecretsTriggered / Screen::ClearSprites / Screen::SpawnScreenEnemies / Screen::TriggerCombo","val":"<h3>bool SecretsTriggered();</h3>\nReturns true if secrets have been triggered on this screen (including temp).\n\n<h3>void TriggerSecrets();</h3>\nTriggers secrets on this screen (temp only, write ${Screen::State|`Screen->State[ST_SECRET] = true;`} to set the perm secret state)\nDoes not play the screen's ${Screen::SecretSFX|SecretSFX} as part of the trigger.\n\n<h3>void ClearSprites(int spritelist);</h3>\r\nKills all sprite objects of the specified type, using the `SL_` constants.\r\nEx: `Screen->ClearSprites(SL_GUYS);` will delete all enemies on the screen.\r\n\r\n<h3>bool SpawnScreenEnemies();</h3>\r\nImmediately attempts to spawn the ${Screen::Enemy|screen's enemies}, using the ${Screen::Pattern|screen's pattern}.\r\nReturns true on success, false on failure.\r\nFails if enemies are still in the middle of entering from the sides, or if the screen's pattern is `PATTERN_NO_SPAWNING`.\r\n\r\n<h3>bool TriggerCombo(int layer, int pos);</h3>\r\nAttempts to trigger the combo at 'layer,pos'. Returns true on success, false on failure.\r\n\r\nFails in special cases depending on the combo, as well as if either layer or pos is invalid.\r\n\r\nIf no 'Triggers' tab behaviors are set, won't do anything."},{"name":"Render Targets ;; Screen::GetRenderTarget / Screen::SetRenderTarget","val":"<h3>int GetRenderTarget();\nvoid SetRenderTarget(int rt);</h3>\n\nGets/sets the current \"Render Target\". Most times this should be 'RT_SCREEN', though versions older than 2.55 required using this for bitmap drawing. 2.55's ${bitmapptr|`bitmap` pointers} effectively obsolete the render target system, and should be used instead of this.\n\nUses the constants `RT_SCREEN` for the screen, and `RT_BITMAP0` through `RT_BITMAP6` for the 6 old-style bitmap targets."},{"name":"Drawing ;; Screen::PutPixels / Screen::DrawTiles / Screen::DrawCombos / Screen::Lines / Screen::DrawBitmap / Screen::DrawBitmapEx / Screen Drawing Funcs","val":"<h3>void DrawBitmap(int layer, int bitmap_id,\n        int source_x, int source_y, int source_w, int source_h,\n        int dest_x, int dest_y, int dest_w, int dest_h,\n        float rotation, bool mask);</h3>\n\nDraws an area from the old-style render target bitmap indicated by `bitmap_id` to the current render target.\n\n<h3>void DrawBitmapEx(int layer, int bitmap_id,\n        int source_x, int source_y, int source_w, int source_h, \n        int dest_x, int dest_y, int dest_w, int dest_h, \n        float rotation = 0, int cx = 0, int cy = 0,\n        int mode = 0, int lit = 0,  bool mask = true);</h3>\n\nSimilar to 'DrawBitmap', but offers some extra mode options- using the 'BITDX_' constants.\n\n<h2>Array Drawing Functions</h2>\nThese take a repeating-array of parameters.\n\n<h3>void PutPixels(int layer, int arr[]);</h3>\nPuts multiple pixels to the screen in one function call. PutPixels() expects an array as its arg, with the array in the format of repeating blocks of `{ x, y, color, trans }`.\n\n<h3>void DrawTiles(int layer, int arr[]);</h3>\nSimilar to FastTile(), but it draws multiple tiles in one call. The array arg should be an array with repeating sets of `{x,y,tile,color,opacity}`\n\n<h3>void DrawCombos(int layer, int arr[]);</h3>\nSimilar to FastCombo(), but it draws multiple combos in one call. The array arg should be an array with repeating sets of `{x,y,combo,color,opacity}`\n\n<h3>void Lines(int layer, int arr[]);</h3>\nSimilar to Line(), but it draws multiple lines in one call. The array arg should be an array with repeating sets of `{x,y,x2,y2,color,scale,rx,ry,rangle,opacity}`"}],[{"name":"&lt;-- Misc Data Pointers ;; function_data_misc","val":"$0$6"},{"name":"<em>mapdata</em>","val":"<h3>MapData Pointers</h3>   `mapdata`\n\n`mapdata` pointers allow accessing data from any screen.\nDepending on how a mapdata pointer is loaded, it may represent a ${LoadTempScreen|temporary current screen}, a ${LoadScrollingScreen|temporary scrolling screen}, or a ${LoadMapData|permanent screen}.\n\nMany parts of `mapdata` are shared with `Screen->`.\n\nSee: ${LoadTempScreen}, ${LoadScrollingScreen}, ${LoadMapData}"},{"name":"Shared w/ Screen-> ;; mapscrShare","val":"$MapData$1"},{"name":"Map / Screen ;; mapdata::Map / mapdata::Screen","val":"<h3>int Map;</h3>\nRead-only. Returns the map this mapdata points to.\n\n<h3>int Screen;</h3>\nRead-only. Returns the screen this mapdata points to."},{"name":"FFC Info ;; mapdata::FFCRunning[] / mapdata::FFCScript[] / mapdata::FFCLink[] / mapdata::FFCTileHeight[] / mapdata::FFCTileWidth[] / mapdata::FFCEffectHeight[] / mapdata::FFCEffectWidth[] / mapdata::FFCFlags[] / mapdata::FFCAy[] / mapdata::FFCAx[] / mapdata::FFCVy[] / mapdata::FFCVx[] / mapdata::FFCY[] / mapdata::FFCX[] / mapdata::FFCDelay[] / mapdata::FFCCSet[] / mapdata::FFCData[] / mapdata::GetFFCInitA / mapdata::SetFFCInitA / mapdata::GetFFCInitD / mapdata::SetFFCInitD","val":"<h4>int ${ffc::Data|FFCData}[MAX_FFC];\nint ${ffc::CSet|FFCCSet}[MAX_FFC];\nint ${ffc::Delay|FFCDelay}[MAX_FFC];\nint ${ffc::X|FFCX}[MAX_FFC]; int ${ffc::Y|FFCY}[MAX_FFC];\nint ${ffc::Vx|FFCVx}[MAX_FFC]; int ${ffc::Vy|FFCVy}[MAX_FFC];\nint ${ffc::Ax|FFCAx}[MAX_FFC]; int ${ffc::Ay|FFCAy}[MAX_FFC];\nint ${ffc::Flags|FFCFlags}[MAX_FFC];\nint ${ffc::EffectWidth|FFCEffectWidth}[MAX_FFC]; int ${ffc::EffectHeight|FFCEffectHeight}[MAX_FFC];\nint ${ffc::TileWidth|FFCTileWidth}[MAX_FFC]; int ${ffc::TileHeight|FFCTileHeight}[MAX_FFC];\nint ${ffc::Link|FFCLink}[MAX_FFC];\nint ${ffc::Script|FFCScript}[MAX_FFC];</h4>\nAccess various properties of the FFCs on the screen, remotely. See ${ffc|ffc} for more information on each value.\nFor `int FFCFlags[];`, instead of being an array of boolean flags, each index is a bitwise flagset. To access, use bitwise operators and the `FFCBF_` constants (which represent the same thing as their matching `FFCF_` counterparts)\n\n<h3>untyped GetFFCInitD(int ffc_index, int n);\nvoid SetFFCInitD(int ffc_index, int n, untyped value);</h3>\nAccess the ${ffc::InitD|`InitD[n]`} for the specified FFC on the screen."}],[{"name":"&lt;-- MapData Pointers ;; mapdataptr","val":"$MapData"},{"name":"&lt;-- Screen Pointer ;; screenptr","val":"$Screen"},{"name":"Info","val":"These functions and variables are shared between `Screen->` and `mapdata->` pointers. For `Screen->`, the 'current screen' is the screen the player is presently on, as a temporary screen. For `mapdata->`, it is whatever screen was loaded to create the mapdata pointer."},{"name":"Solidity Checks ;; mapdata::isSolid / Screen::isSolid / mapdata::isSolidLayer / Screen::isSolidLayer","val":"<h3>bool isSolid(int x, int y);\nbool isSolidLayer(int x, int y, int layer);</h3>\n\nReturns true if the given x,y position on the screen is 'solid'.\n`isSolid` returns true if either layer 0,1, or 2 is solid\n`isSolidLayer` returns true only for the specified layer."},{"name":"Combo / Flag Data ;; mapdata::ComboE[] / Screen::ComboE[] / mapdata::ComboS[] / Screen::ComboS[] / mapdata::ComboT[] / Screen::ComboT[] / mapdata::ComboI[] / Screen::ComboI[] / mapdata::ComboF[] / Screen::ComboF[] / mapdata::ComboC[] / Screen::ComboC[] / mapdata::ComboD[] / Screen::ComboD[]","val":"<h3>int ComboD[176];</h3>\nThe Combo ID placed at each position on the screen.\n\n<h3>int ComboC[176];</h3>\nThe CSet of the combo placed at each position on the screen.\n\n<h3>int ComboF[176];</h3>\nThe mapflag placed at each position on the screen.\n\n<h3>int ComboI[176];</h3>\nThe inherent flag of the combo placed at each position on the screen.\nWriting to this changes the inherent flag for EVERY combo of that combo ID.\n\n<h3>int ComboT[176];</h3>\nThe combo type of the combo placed at each position on the screen.\nWriting to this changes the combo type for EVERY combo of that combo ID.\n\n<h3>int ComboS[176];</h3>\nThe solidity map of the combo placed at each position on the screen.\nWriting to this changes the solidity map for EVERY combo of that combo ID.\n\n<h3>int ComboE[176];</h3>\nThe effect map of the combo placed at each position on the screen.\nWriting to this changes the effect map for EVERY combo of that combo ID."},{"name":"Secret Combos ;; mapdata::SecretFlags / Screen::SecretFlags / mapdata::SecretCSet / Screen::SecretCSet / mapdata::SecretCombo / Screen::SecretCombo","val":"<h3>Secret Combos</h3>\nSecret combos are the combos that replace certain screen flags when ${secrets} are triggered. When they replace, it replaces the Combo, Placed Flag, and CSet of the given location.\nSecret Combo data is indexed using the `SECCMB_` constants.\n\n<h3>int SecretCombo[SECCMB_MAX];</h3>\nThe combo that will be placed for each secret type.\n\n<h3>int SecretCSet[SECCMB_MAX];</h3>\nThe cset that will be placed for each secret type.\n\n<h3>int SecretFlags[SECCMB_MAX];</h3>\nThe screen flags that will be placed for each secret type.\n\n<h3>Notes:</h3>\nThe index `SECCMB_SECRETSNEXT` is used for `Secrets->Next` flags, and does not make use of `SecretCombo[]` or `SecretCSet[]`; though it does make use of `SecretFlags[]`."},{"name":"SFX / Music ;; mapdata::ItemSFX / Screen::ItemSFX / mapdata::SecretSFX / Screen::SecretSFX / mapdata::BossSFX / Screen::BossSFX / mapdata::AmbientSFX / Screen::AmbientSFX / mapdata::MIDI / Screen::MIDI","val":"<h3>int ItemSFX;</h3>\nThe SFX that will play when an item is held up on this screen.\n\n<h3>int SecretSFX;</h3>\nThe SFX that will play when secrets are triggered on this screen.\n\n<h3>int BossSFX;</h3>\nThe SFX for the boss roar on this screen.\n\n<h3>int AmbientSFX;</h3>\nThe SFX for the ambient sound of the screen.\n\n<h3>int MIDI;</h3>\nThe 'Screen MIDI' to play for this screen."},{"name":"Room Data ;; mapdata::Guy / Screen::Guy / mapdata::String / Screen::String / mapdata::RoomType / Screen::RoomType / mapdata::Catchall / Screen::Catchall","val":"<h3>int Guy;</h3>\nThe screen guy.\n\n<h3>int String;</h3>\nThe screen string.\n\n<h3>int RoomType;</h3>\nThe screen room type. Use the `RT_` constants for this value.\n\n<h3>int Catchall;</h3>\nThe screen's 'catchall' value. This is the roomtype-specific data, such as the 'Special Item' in a 'Special Item' room."},{"name":"Screen Item ;; mapdata::Item / Screen::Item / mapdata::ItemX / Screen::ItemX / mapdata::ItemY / Screen::ItemY","val":"<h3>int Item;</h3>\nThe item placed on the screen. -1 if no item placed.\n\n<h3>int ItemX;\nint ItemY;</h3>\nThe X/Y position the screen's item spawns at."},{"name":"Warp Data ;; screen_warp_data / mapdata::TileWarpType / Screen::TileWarpType / mapdata::SideWarpType / Screen::SideWarpType / mapdata::TileWarpOverlay / Screen::TileWarpOverlay / mapdata::SideWarpOverlay / Screen::SideWarpOverlay / mapdata::TileWarpDMap / Screen::TileWarpDMap / mapdata::TileWarpScreen / Screen::TileWarpScreen / mapdata::SideWarpDMap / Screen::SideWarpDMap / mapdata::SideWarpScreen / Screen::SideWarpScreen / mapdata::TileWarpReturnSquare / Screen::TileWarpReturnSquare / mapdata::SideWarpReturnSquare / Screen::SideWarpReturnSquare / mapdata::SideWarpID / Screen::SideWarpID / mapdata::WarpReturnX / Screen::WarpReturnX / mapdata::WarpReturnY / Screen::WarpReturnY / mapdata::WarpArrivalX / Screen::WarpArrivalX / mapdata::WarpArrivalY / Screen::WarpArrivalY / mapdata::TimedWarpTimer / Screen::TimedWarpTimer","val":"<h3>Note:</h3>\nMost of these arrays are indexed via the `WARP_` constants; where `WARP_A` is 0, through `WARP_D` as 3.\n\n<h3>int TileWarpType[4];\nint SideWarpType[4];</h3>\nThe warp type of the given warp. Use the `WT_` constants for these values.\n\n<h3>bool TileWarpOverlay[4];\nbool SideWarpOverlay[4];</h3>\nThe state of the `Combos Carry Over` checkbox for each warp.\n\n<h3>int TileWarpDMap[4];\nint TileWarpScreen[4];\nint SideWarpDMap[4];\nint SideWarpScreen[4];</h3>\nThe DMap and Screen that make up the destination of each warp.\n\n<h3>int TileWarpReturnSquare[4];\nint SideWarpReturnSquare[4];</h3>\nThe return square set as the destination for each warp. 0 = A, 3 = D.\n\n<h3>int SideWarpID[4];</h3>\nThis array is indexed via the `DIR_` constants, with the `WARP_` constants as the values.\nEx: `SideWarpID[DIR_UP] = WARP_A;` sets the Up sidewarp to use Side Warp A.\n\n<h3>int WarpReturnX[4];\nint WarpReturnY[4];</h3>\nThe X/Y coordinates of the 4 blue return squares\n\n<h3>int WarpArrivalX;\nint WarpArrivalY;</h3>\nThe X/Y coordinates of the old green arrival square.\n\n<h3>int TimedWarpTimer;</h3>\nThe timer used for executing a timed warp."},{"name":"State / ExState ;; mapdata::State / Screen::State / mapdata::ExState / Screen::ExState","val":"<h3>bool State[32];</h3>\nThe screen states used for this screen. Use the `ST_` constants to access this.\n\n<h3>bool ExState[32];</h3>\nThe 32 'Extra States' used for this screen."},{"name":"--&gt; Next ;;mapscrShare2","val":"$-1$2"},{"name":"--&gt;&gt; End ;;mapscrShare3","val":"$-1$3"}],[{"name":"&lt;-- MapData Pointers ;; mapdataptr","val":"$MapData"},{"name":"&lt;-- Screen Pointer ;; screenptr","val":"$Screen"},{"name":"Script Data ;; mapdata::Script / mapdata::InitD / Screen::Script / Screen::InitD","val":"<h3>int Script;</h3>\nThe screen script that runs on this screen.\n\n<h3>untyped InitD[8];</h3>\nThe 8 script arguments for the script that runs on this screen."},{"name":"Palette ;; mapdata::Palette / Screen::Palette","val":"<h3>int Palette;</h3>\nThe palette set in the F4 menu in ZQuest for this screen. Has no effect during play, but can be read and written."},{"name":"Door ;; mapdata::Door / Screen::Door","val":"<h3>int Door[4];</h3>\nThe 4 door states of the screen, indexed with the `DIR_` constants.\nUse the `D_` constants for the values."},{"name":"Maze Paths ;; mapdata::MazePath / mapdata::ExitDir / Screen::MazePath / Screen::ExitDir","val":"<h3>int MazePath[4];</h3>\nThe four directions you must go for the maze path. Use the `DIR_` constants for the values.\n\n<h3>int Exitdir;</h3>\nThe direction that exits the maze path instantly. Use the `DIR_` constants for the value."},{"name":"Screen Enemies ;; mapdata::Enemy / mapdata::Pattern / Screen::Enemy / Screen::Pattern","val":"<h3>int Enemy[10];</h3>\nThe 10 enemies that appear on this screen.\n\n<h3>int Pattern;</h3>\nThe spawn pattern for the screen enemies. Use the `PATTERN_` constants for the value.\n\nRelated: ${Screen::SpawnScreenEnemies|Screen->SpawnScreenEnemies}"},{"name":"UnderCombo / UnderCSet ;; mapdata::UnderCombo / mapdata::UnderCSet / Screen::UnderCombo / Screen::UnderCSet","val":"<h3>int UnderCombo;</h3>\nThe screen's undercombo, which will appear as a result of various combo interactions, such as pushing blocks, awakening armos, etc.\n\n<h3>int UnderCSet;</h3>\nThe CSet associated with the undercombo."},{"name":"CSensitive","val":"<h3>int CSensitive;</h3>\nThe value of damage combo sensitivity for the screen."},{"name":"Carry Flags ;; mapdata::NoReset / mapdata::NoCarry / Screen::NoReset / Screen::NoCarry / mapdata::NextMap / Screen::NextMap / mapdata::NextScreen / Screen::NextScreen","val":"<h3>int NoReset;</h3>\nThe `No Reset` carryover flags.\n#{Values|<ul><li>NORESET_B_SECRET: 0x2000</li>\n<li>NORESET_B_ITEM: 0x0010</li>\n<li>NORESET_B_SPECIALITEM: 0x0020</li>\n<li>NORESET_B_LOCKBLOCK: 0x0100</li>\n<li>NORESET_B_BOSSLOCKBLOCK: 0x0200</li>\n<li>NORESET_B_CHEST: 0x0400</li>\n<li>NORESET_B_LOCKEDCHEST: 0x0800</li>\n<li>NORESET_B_BOSSCHEST: 0x1000</li>\n<li>NORESET_B_DOOR_B_UP: 0x0001</li>\n<li>NORESET_B_DOOR_B_DOWN: 0x0002</li>\n<li>NORESET_B_DOOR_B_LEFT: 0x0004</li>\n<li>NORESET_B_DOOR_B_RIGHT: 0x0008</li></ul>}\n\n<h3>int NoCarry;</h3>\nThe `No Carry Over` carryover flags.\n#{Values|<ul><li>NOCARRY_B_SECRET: 0x2000</li>\n<li>NOCARRY_B_ITEM: 0x0010</li>\n<li>NOCARRY_B_SPECIALITEM: 0x0020</li>\n<li>NOCARRY_B_LOCKBLOCK: 0x0100</li>\n<li>NOCARRY_B_BOSSLOCKBLOCK: 0x0200</li>\n<li>NOCARRY_B_CHEST: 0x0400</li>\n<li>NOCARRY_B_LOCKEDCHEST: 0x0800</li>\n<li>NOCARRY_B_BOSSCHEST: 0x1000</li></ul>}\n\n<h3>int NextMap;\nint NextScreen;</h3>\n\nThe map and screen that screen states carry over to."},{"name":"Layer Info ;; mapdata::LayerMap / mapdata::LayerScreen / Screen::LayerMap / Screen::LayerScreen / mapdata::LayerInvisible / Screen::LayerInvisible / mapdata::LayerOpacity / Screen::LayerOpacity","val":"<h3>int LayerMap[7];\nint LayerScreen[7];</h3>\nThe map and screen for each layer. Index [0] of these arrays does nothing, and is invalid to access.\n\n<h3>int LayerOpacity[7];</h3>\nThe opacity value (`OP_OPAQUE` or `OP_TRANS`) for each layer. Index [0] does nothing, and is invalid to access.\n\n<h3>bool LayerInvisible[7];</h3>\nIf true, the given layer is invisible and will not be drawn.\n"},{"name":"&lt;-- Prev ;;mapscrShare","val":"$-1$1"},{"name":"--&gt; Next ;;mapscrShare3","val":"$-1$3"}],[{"name":"&lt;-- MapData Pointers ;; mapdataptr","val":"$MapData"},{"name":"&lt;-- Screen Pointer ;; screenptr","val":"$Screen"},{"name":"ScriptDraws ;; mapdata::ScriptDraws / Screen::ScriptDraws","val":"<h3>bool ScriptDraws[8];</h3>\nIf false, the given layer of script draws will be disabled on this screen."},{"name":"Valid ;; mapdata::Valid / Screen::Valid","val":"<h3>bool Valid</h3>\nReturns true if the screen is 'valid'. Screens that appear with the default blue background in ZQuest are 'invalid'. Modifying a combo on a screen makes it become 'valid'. If a layer is 'invalid', it will not be drawn."},{"name":"DoorComboSet ;; mapdata::DoorComboSet / Screen::DoorComboSet","val":"<h3>int DoorComboSet;</h3>\nThe Door Set used for the NES dungeon doors on this screen."},{"name":"Stairs ;; mapdata::StairsX / mapdata::StairsY / Screen::StairsX / Screen::StairsY","val":"<h3>int StairsX;\nint StairsY;</h3>\n\nThe X/Y position of the 'Stairs' secret on the screen."},{"name":"Flags ;; mapdata::EFlags[] / Screen::EFlags[] / mapdata::SFlags[] / Screen::SFlags[] / mapdata::Flags[] / Screen::Flags[]","val":"<h3>int Flags[];</h3>\nArrays containing flag data for each screen.\nTo access these, use the following std_zh functions:\n`int ScreenFlag(int category, int flag);`\n`int ScreenFlag(mapdata m, int category, int flag);`\nUse the `SF_` constants for `category`, and the matching set of either the `SFR_`, `SFV_`, `SFS_`, `SFW_`, `SFI_`, `SFC_`, `SFSV_`, `SFF_`, `SFWH_`, or `SFM_` constants for `flag`.\n\n<h3>int EFlags[];</h3>\nArrays containing flag data for each screen.\nTo access these, use the following std_zh functions:\n`int ScreenEFlag(int category, int flag);`\n`int ScreenEFlag(mapdata md, int category, int flag)`\nUse the `SEF_` constants for `category`, and the matching set of either the `SEFSP_`, `SEFL1_`, or `SEFL2_` constants for `flag`."},{"name":"LensLayer ;; mapdata::LensLayer / Screen::LensLayer","val":"<h3>int LensLayer;</h3>\nContains the special info for how the Lens of Truth affects layers of the screen.\nThe lower 3 bits (`LensLayer&amp;111b`) represent the layer, from 1 to 6, to affect.\nThe 4th bit (`LensLayer&amp;1000b`) indicates that the layer should be HIDDEN when the lens is active.\nThe 5th bit (`LensLayer&amp;10000b`) indicates that the layer should be HIDDEN when the lens is active."},{"name":"&lt;&lt;-- Start","val":"$-1$1"},{"name":"&lt;-- Prev ;;mapscrShare2","val":"$-1$2"}],[{"name":"&lt;-- Managed Pointers ;; function_data_managed","val":"$0$7"},{"name":"<em>bitmap</em>","val":"<h3>Bitmap Pointers</h3>   `bitmap`\n\n`bitmap` pointers allow creating, manipulating, and storing visual data.\n\nA number of drawing commands from `bitmap` are shared with `Screen->`.\n\nSee: ${CreateBitmap}, ${bitmap::Create|Create}"},{"name":"Shared w/ Screen-> ;; bitscrShare","val":"$Bitmap$2"},{"name":"Width / Height ;; bitmap::Width / bitmap::Height","val":"<h3>int Width;\nint Height;</h3>\n\nRead-only. The width/height of the bitmap *at the start of this frame* in pixels."},{"name":"Pointer Management ;; bitmap::isAllocated / bitmap::isValid / bitmap::Free / bitmap::Own","val":"<h3>bool isAllocated();</h3>\nReturns true if the bitmap pointer has been allocated for use.\n\n<h3>bool isValid();</h3>\nReturns true if the bitmap pointer has been created to be drawn to.\n\n<h3>void Free();</h3>\nDe-allocates this `bitmap` pointer, so that its' pointer ID may be re-used. You may only have a limited number of bitmap pointers active at a time; freeing them when you are done with them helps not reach the limit.\n\n<h3>void Own();</h3>\nGrants 'Ownership' of the bitmap pointer to the script that calls this function. When the script with 'Ownership' terminates (at the same time its' local arrays are deallocated), this bitmap pointer will automatically be 'Free()'d."},{"name":"File IO ;; bitmap::Read / bitmap::Write","val":"<h3>void Read(int layer, char32 filename[]);</h3>\n\nReads from the specified image file into the bitmap.  Read() will fail if:\n<ul>\n<li>The file is corrupt:</li>\n<ul>\n<li>PNG, JPEG, or other 'compressed' formats may abort if the file is corrupt.</li>\n<li>Formats such as .BMP or .TGA may read up until missing data, as they are linear.</li>\n</ul>\n<li>The file is missing.</li>\n<li>The filename is incorrect. Remember that POSIX filesystems are Case-SenSitive.</li>\n</ul>\n\nIf [[\"All bitmap-> and FileSystem-> paths relative to quest 'Files' folder\"|at \"ZScript->Quest Script Settings->Instructions\"]] is enabled, paths are relative to the quest's specific directory; otherwise they are relative to the ZC folder.\n\n<h3>void Write(int layer, char32 filename[], bool allow_overwrite = false);</h3>\n\nWrites from the bitmap to the specified image file. Requires one of: `.png`,`.gif`,`pcx`,`.tgx`,`.bmp`. Fails otherwise.\n\nWill not replace an existing file, unless `allow_overwrite` is true. Will automatically create missing directories on the specified path.\n\nIf [[\"All bitmap-> and FileSystem-> paths relative to quest 'Files' folder\"|at \"ZScript->Quest Script Settings->Instructions\"]] is enabled, paths are relative to the quest's specific directory; otherwise they are relative to the ZC folder."},{"name":"WriteTile ;; bitmap::WriteTile","val":"<h3>void WriteTile(int layer, int x, int y, int tile, bool is8bit = true, bool mask = false);</h3>\nWrites a 16x16 area from the bitmap to the tile `tile`. The tile's 8-bit status will be set to the value of `is8bit`. If `mask` is true, the draw will be an `Overlay`- otherwise it will overwrite."},{"name":"Creating / Clearing ;; bitmap::Create / bitmap::Clear / bitmap::ClearToColor","val":"<h3>void Create(int layer = 0, int width = 256, int height = 256);</h3>\nCreates a bitmap on the pointer of `width by height`, destroying any data that was previously on the pointer.\n\nIf [[\"Old Args for CreateBitmap and bitmap->Create()\"|at \"ZScript->Quest Script Settings->Instructions\"]] is enabled, then `width` and `height` are swapped with each other.\n\n<h3>void Clear(int layer = 0);</h3>\nClears the bitmap to color 0 on the specified layer timing.\n\n<h3>void ClearToColor(int layer, int color);</h3>\nClears the bitmap to the specified color on the specified layer timing."},{"name":"--&gt; Next ;;bitmapptr2","val":"$-1$1"}],[{"name":"&lt;-- Managed Pointers ;; function_data_managed","val":"$0$7"},{"name":"Pixel Checking ;; bitmap::GetPixel / bitmap::CountColor","val":"<h3>int GetPixel(int x, int y);</h3>\nReturns the palette index at the given position on the bitmap *at the start of the frame*. This does not account for this frame's draws that have yet to happen.\n\n<h3>int CountColor(bitmap mask, int x, int y, int checkColor, int maskColor = -1);</h3>\nChecks the area of this bitmap specified by the area on the `mask` bitmap which matches the `maskColor`. For a `maskColor` of `-1`, all non-zero values will match.\n\nReturns the number of pixels in said area that match the `checkColor` on this bitmap. For a `checkColor` of `-1`, all non-zero values will match.\n\nThe area checked is from `x,y` to `x+mask->Width,y+mask->Height`. If this goes out of bounds, the out of bounds area is ignored.\n\nThis does not account for this frame's draws that have yet to happen."},{"name":"Masked Draws ;; bitmap::MaskedDraw / bitmap::MaskedBlit","val":"<h3>void Dither(int layer, bitmap mask, int color, int ditherType, int ditherArg);</h3>\nDraws `color` onto the bitmap on pixels that are non-color-0 on the `mask` bitmap, based on the [[`ditherType`|`DITH_` constants]]\n\n<h3>void MaskedDraw(int layer, bitmap mask, int color);\nvoid MaskedDraw(int layer, bitmap mask, int color, int maskColor);\nvoid MaskedDraw(int layer, bitmap mask, int color, int startMaskColor, int endMaskColor);</h3>\n\nDraws `color` to this bitmap, in the area specified by the `mask`. Any pixel on the `mask` which matches the `maskColor` will be drawn.\n\nIf no `maskColor` is specified, all non-zero pixels will be considered matching. If a `startMaskColor`+`endMaskColor` are defined, colors between them, inclusive, will be considered matching.\n\n<h3>void MaskedBlit(int layer, bitmap mask, bitmap pattern, bool repeatPattern);\nvoid MaskedBlit(int layer, bitmap mask, bitmap pattern, bool repeatPattern, int maskColor);\nvoid MaskedBlit(int layer, bitmap mask, bitmap pattern, bool repeatPattern, int startMaskColor, int endMaskColor);</h3>\n\nSame as `MaskedDraw`, except instead of drawing a specified `color` to this bitmap, it draws from a `pattern` bitmap.\n\nIf `repeatPattern` is false, the area from `0,0` to `pattern->Width-1`,`pattern->Height-1` will be drawn.\n\nIf `repeatPattern` is true, the entire bitmap will be drawn, repeating the `pattern` both horizontally and vertically tiled."},{"name":"<h3>void ReplaceColors(int layer, int color, int startCol, int endCol);</h3>\nReplaces colors that are &gt;= startCol and &lt;= endCol with `color`.\n\n<h3>void ShiftColors(int layer, int shift, int startCol, int endCol);</h3>\nShifts colors that are &gt;= startCol and &lt;= endCol by adding `shift` to them.","val":"<h3>void ReplaceColors(int layer, int color, int startCol, int endCol);</h3>\nReplaces colors that are &gt;= startCol and &lt;= endCol with `color`.\n\n<h3>void ShiftColors(int layer, int shift, int startCol, int endCol);</h3>\nShifts colors that are &gt;= startCol and &lt;= endCol by adding `shift` to them."},{"name":"Blitting ;; bitmap::Blit / bitmap::BlitTo","val":"<h3>void Blit(int layer, bitmap target,\n        int sx, int sy, int sw, int sh,\n        int dx, int dy, int dw, int dh,\n        [[float rotation = 0|Degrees]], int cx = 0, int cy = 0,\n        [[int mode = 0|`BITDX_` constants]], int lit = 0,  bool mask = true);</h3>\n\nDraws an area specified by the (sx,sy,sw,sh) from this bitmap to the destination area (dx,dy,dw,dh) of the target bitmap.\n\nIf 'rotation' is non-zero, rotates the draw around the (cx,cy) point.\n\n'lit', if non-zero, will attempt to tint the draw based on that palette index.\n\nIf 'mask' is false, color 0 will draw as color 0 instead of transparent.\n\n<h3>void BlitTo(int layer, bitmap source,\n        int sx, int sy, int sw, int sh,\n        int dx, int dy, int dw, int dh,\n        [[float rotation = 0|Degrees]], int cx = 0, int cy = 0,\n        [[int mode = 0|`BITDX_` constants]], int lit = 0,  bool mask = true);</h3>\n\nAs `Blit()`, but draws from (sx,sy,sw,sh) of the `source` bitmap to (dx,dy,dw,dh) of this bitmap."},{"name":"DrawPlane ;; bitmap::DrawPlane","val":"<h3>void DrawPlane(int layer, bitmap src, int sx, int sy, int dx,\r\n\tint dy, int dw, int dh, int space_z, int horizon, \r\n\tfloat scale_x = 1, float scale_y = 1, bool mask = true);</h3>\n\nDraws a scaled 'Mode 7' style effect, line-by-line, where each raster is scaled down toward a horizon point."},{"name":"Specialized DrawScreen ;; bitmap::DrawScreenSolid / bitmap::DrawScreenSolidity / bitmap::DrawScreenComboTypes / bitmap::DrawScreenComboFlags / bitmap::DrawScreenComboIFlags","val":"<h3>void DrawScreenSolid(int layer, \n        int map, int source_screen, \n        int x, int y, float rotation = 0);</h3>\n\nDraws the solidity mask entire screen from screen on map on the specified layer of the bitmap at (x,y) in colour index 1. If rotation is not zero, it(the entire screen) will rotate about its center.\n\n<h3>void DrawScreenSolidity(int layer, \n        int map, int source_screen, \n        int x, int y, float rotation = 0);</h3>\n\nDraws the solidity value for each combo position of an entire screen from screen on map on the specified layer of the bitmap at (x,y). Each combo position will be drawn in the palette index equal to its value as ComboS[]. If rotation is not zero, it(the entire screen) will rotate about its center.\n\n<h3>void DrawScreenComboTypes(int layer, \n        int map, int source_screen, \n        int x, int y, float rotation = 0);</h3>\n\nDraws the combo type value for each combo position of an entire screen from screen on map on the specified layer of the bitmap at (x,y). Each combo position will be drawn in the palette index equal to its value as ComboT[]. If rotation is not zero, it(the entire screen) will rotate about its center.\n\n<h3>void DrawScreenComboIFlags(int layer, \n        int map, int source_screen, \n        int x, int y, float rotation = 0);</h3>\n\nAs `DrawScreenComboTypes`, but `ComboI[]` instead of `ComboT[]`\n\n<h3>void DrawScreenComboFlags(int layer, \n        int map, int source_screen, \n        int x, int y, float rotation = 0);</h3>\n\nAs `DrawScreenComboTypes`, but `ComboF[]` instead of `ComboT[]`"},{"name":"--","val":""},{"name":"&lt;-- Prev ;;bitmapptr","val":"$-1$0"}],[{"name":"&lt;-- Bitmap Pointers ;; bitmapptr","val":"$Bitmap"},{"name":"&lt;-- Screen Pointer ;; screenptr","val":"$Screen"},{"name":"Info","val":"These functions and variables are shared between `Screen->` and `bitmap->` pointers. For `Screen->`, draws go to the visible screen itself; while for `bitmap->`, draws go to the bitmap's stored pixels."},{"name":"Rectangle ;; bitmap::Rectangle / Screen::Rectangle ;; Rectangle","val":"<h3>void Rectangle(int layer, int x, int y, int x2, int y2, int color,\n        float scale = 1, int rx = 0, int ry = 0, [[int rangle = 0|Degrees]],\n        bool fill = true, int opacity = OP_OPAQUE);</h3>\n\nDraws a rectangle from the (x,y) corner to the (x2,y2) corner. If 'fill' is true, the rectangle will be filled with the color, otherwise it will be a 1-pixel outline of the color.\n\nIf scale is not '1', it will scale the size of the rectangle.\nIf 'rangle' is not 0, it will rotate the draw around the (rx,ry) point."},{"name":"Circle ;; Screen::Circle / bitmap::Circle ;; Circle","val":"<h3>void Circle(int layer, int x, int y, int radius, int color,\n        float scale = 1, int rx = 0, int ry = 0, [[int rangle = 0|Degrees]],\n        bool fill = true, int opacity = OP_OPAQUE);</h3>\n\nDraws a circle of radius `radius` centered on the point (x,y). If 'fill' is true, the circle will be filled with the color, otherwise it will be a 1-pixel outline of the color.\n\nIf scale is not '1', it will scale the size of the circle.\nIf 'rangle' is not 0, it will rotate the draw around the (rx,ry) point."},{"name":"Arc ;; Screen::Arc / bitmap::Arc ;; Arc","val":"<h3>void Arc(int layer, int x, int y, int radius,\n        [[int startangle, int endangle|Degrees]], int color,\n        float scale = 1, int rx = 0, int ry = 0, [[int rangle = 0|Degrees]],\n        bool closed = true, bool fill = true, int opacity = OP_OPAQUE);</h3>\n\nDraws an arc from 'startangle' to 'endangle' degrees of a circle of radius `radius` centered on the point (x,y). If 'closed' is true, the ends of the arc will be connected to the point (x,y), creating a slice of a pie chart shape. If 'fill' is true, the arc will be filled with the color, otherwise it will be a 1-pixel outline of the color.\n\nThis function is undefined unless `0 &lt;= (endangle-startangle) &lt; 360`.\n\nIf scale is not '1', it will scale the size of the arc.\nIf 'rangle' is not 0, it will rotate the draw around the (rx,ry) point."},{"name":"Ellipse ;; Screen::Ellipse / bitmap::Ellipse ;; Ellipse","val":"<h3>void Ellipse(int layer, int x, int y, int xradius,\n        int yradius, int color, float scale = 1,\n        int rx = 0, int ry = 0, [[int rangle = 0|Degrees]],\n        bool fill = true, int opacity = OP_OPAQUE);</h3>\n\nDraws an ellipse of radii `xradius, yradius` centered on the point (x,y). If 'fill' is true, the ellipse will be filled with the color, otherwise it will be a 1-pixel outline of the color.\n\nIf scale is not '1', it will scale the size of the ellipse.\nIf 'rangle' is not 0, it will rotate the draw around the (rx,ry) point."},{"name":"Line ;; Screen::Line / bitmap::Line ;; Line","val":"<h3>void Line(int layer, int x, int y, int x2, int y2, int color,\n        float scale = 1, int rx = 0, int ry = 0, [[int rangle = 0|Degrees]],\n        int opacity = OP_OPAQUE);</h3>\n\nDraws a line from the (x,y) point to the (x2,y2) point.\n\nIf scale is not '1', it will scale the size of the line.\nIf 'rangle' is not 0, it will rotate the draw around the (rx,ry) point."},{"name":"Spline ;; Screen::Spline / bitmap::Spline ;; Spline","val":"<h3>void Spline(int layer, int x1, int y1, int x2, int y2,\n        int x3, int y3, int x4, int y4, int color,\n        int opacity = OP_OPAQUE);</h3>\n\nDraws a cardinal spline on the screen."},{"name":"PutPixel ;; Screen::PutPixel / bitmap::PutPixel ;; PutPixel","val":"<h3>void PutPixel(int layer, int x, int y, int x2, int y2, int color,\n        int rx = 0, int ry = 0, [[int rangle = 0|Degrees]],\n        int opacity = OP_OPAQUE);</h3>\n\nDraws a pixel at (x,y).\n\nIf 'rangle' is not 0, it will rotate the draw around the (rx,ry) point."},{"name":"DrawInteger / DrawCharacter ;; Screen::DrawInteger / bitmap::DrawInteger / Screen::DrawCharacter / bitmap::DrawCharacter ;; DrawInteger / DrawCharacter","val":"<h3>void DrawInteger(int layer, int x, int y, int font, int color,\n        int background_color, int width, int height, int val, int num_decimal_places = 0,\n        int opacity = OP_OPAQUE);</h3>\n\nDraws a number, in the font specified using `FONT_` constants, with the top-left at (x,y). The number will be exactly width by height pixels, in the `color`. If `background_color` is not `-1`, it will be drawn behind the number in a rectangle. Up to 'num_decimal_places' places after the decimal point will be shown.\n\n<h3>void DrawCharacter(int layer, int x, int y, int font, int color,\r\n        int background_color, int width, int height, char32 char,\r\n        int opacity = OP_OPAQUE);</h3>\r\n\r\nDraws a single character, in the font specified using `FONT_` constants, with the top-left at (x,y). The character will be exactly width by height pixels, in the `color`. If `background_color` is not `-1`, it will be drawn behind the character in a rectangle."},{"name":"DrawString ;; Screen::DrawString / bitmap::DrawString ;; DrawString","val":"<h3>void DrawString(int layer, int x, int y, int font, int color, int format,\n        int background_color, char32 str[], int opacity = OP_OPAQUE);</h3>\n\nDraws a string, in the font specified using `FONT_` constants, in the 'color'. If `background_color` is not `-1`, it will be drawn behind the string in a rectangle. Where the string is drawn depends on the `format`:\n<ul>\n<li>TF_NORMAL: Top-left of string is at (x,y)</li>\n<li>TF_CENTERED: Top-center of string is at (x,y)</li>\n<li>TF_RIGHT: Top-right of string is at (x,y)</li>\n</ul>\n\n<h3>void DrawString(int layer, int x, int y, int font, int color, int format,\n        int background_color, char32 str[], int opacity,\n        int shadow_type, int shadow_color);</h3>\n\nSame as the above version of DrawString(), except the string is drawn with a shadow. The shadow's style is defined as `SHD_` constants, and the shadow will be drawn in the specified `shadow_color`."},{"name":"--&gt; Next ;;bitscrShare2","val":"$-1$3"}],[{"name":"&lt;-- Bitmap Pointers ;; bitmapptr","val":"$Bitmap"},{"name":"&lt;-- Screen Pointer ;; screenptr","val":"$Screen"},{"name":"Tile Draws ;; Screen::DrawTileCloaked / bitmap::DrawTileCloaked / Screen::DrawTile / bitmap::DrawTile / Screen::FastTile / bitmap::FastTile ;; FastTile / DrawTile / DrawTileCloaked","val":"<h3>void FastTile(int layer, int x, int y, int tile, int cset, int opacity = OP_OPAQUE);</h3>\n\nDraws the specified tile in the specified cset, with the upper-left at (x,y).\n\n<h3>void DrawTile(int layer, int x, int y, int tile, int blockw, int blockh,\n        int cset, int xscale = -1, int yscale = -1, int rx = 0, int ry = 0, [[int rangle = 0|Degrees]],\n        int flip = 0, bool transparency = true, int opacity = OP_OPAQUE);</h3>\n\nDraws a block of tiles starting from the specified tile, in the specified cset, with the upper-left at (x,y).\nThe size of the tile block is determined by `blockw` and `blockh`, which must be integers from 1 to 20 inclusive.\nIf `xscale` and `yscale` are both >0, the draw will be stretched to be `xscale by yscale` pixels. Otherwise, the draw will be `16*blockw by 16*blockh` pixels.\nIf `transparency` is false, color 0 in the tile will be drawn as color 0 instead of transparent.\nThe draw will be flipped based on `flip`, using the `FLIP_` constants.\nIf 'rangle' is not 0, it will rotate the draw around the (rx,ry) point.\n\n<h3>void DrawTileCloaked(int layer, int x, int y, int tile, int blockw, int blockh, int flip = 0);</h3>\n\nSimilar to `DrawTile()`, but draws with a \"cloaked\" effect. This means that it does not actually draw the tiles, but instead it distorts the destination bitmap in the draw area based on the pixels in the tiles."},{"name":"Combo Draws ;; Screen::DrawComboCloaked / bitmap::DrawComboCloaked / Screen::DrawCombo / bitmap::DrawCombo / Screen::FastCombo / bitmap::FastCombo ;; FastCombo / DrawCombo / DrawComboCloaked","val":"<h3>void FastCombo(int layer, int x, int y, int combo, int cset, int opacity = OP_OPAQUE);</h3>\n\nAs ${FastTile|FastTile()}, for the current tile of `combo`.\n\n<h3>void DrawCombo(int layer, int x, int y, int combo, int blockw, int blockh,\n        int cset, int xscale = -1, int yscale = -1, int rx = 0, int ry = 0, [[int rangle = 0|Degrees]],\n        int flip = 0, bool transparency = true, int opacity = OP_OPAQUE);</h3>\n\nAs ${DrawTile|DrawTile()}, but for the current tile of the combos.\n\n<h3>void DrawComboCloaked(int layer, int x, int y, int combo, int blockw, int blockh, int flip = 0);</h3>\n\nAs ${DrawTileCloaked|DrawTileCloaked()}, but for the current tile of the combos."},{"name":"Quad ;; Screen::Quad / bitmap::Quad ;; Quad","val":"<h3>void Quad(int layer, int x1, int y1, int x2, int y2, int x3, int y3,\n        int x4, int y4, int w, int h, int cset, int flip,\n        int texture, [[int render_mode|`PT_` constants]], bitmap render_source = NULL);</h3>\n\nNOTE: the `bitmap render_source` parameter is only available for `bitmap-&gt;Quad()`, not `Screen-&gt;Quad()`.\n\nDraws a quad with the 4 specified corners, drawn counterclockwise from (x1,y1).\n\nThe texture is mapped from a tile or tile block if `texture &gt; 0`, or a combo/combo block if `texture &lt;= 0`. (Ex: texture = -32 will use combo 32 as a texture). `w, h` must be values from 1 to 16, and must be powers of 2.\n\nFor `bitmap-&gt;Quad()`, if `render_source` is a valid bitmap, a section of it (based on `w, h`) will be used as the texture instead."},{"name":"Triangle ;; Screen::Triangle / bitmap::Triangle ;; Triangle","val":"<h3>void Triangle(int layer, int x1, int y1, int x2, int y2, int x3, int y3,\n        int w, int h, int cset, int flip, int texture,\n        [[int render_mode|`PT_` constants]], bitmap render_source = NULL);</h3>\n\nNOTE: the `bitmap render_source` parameter is only available for `bitmap-&gt;Triangle()`, not `Screen-&gt;Triangle()`.\n\nDraws a triangle with the 3 specified corners, drawn counterclockwise from (x1,y1).\n\nThe texture is mapped from a tile or tile block if `texture &gt; 0`, or a combo/combo block if `texture &lt;= 0`. (Ex: texture = -32 will use combo 32 as a texture). `w, h` must be values from 1 to 16, and must be powers of 2.\n\nFor `bitmap-&gt;Triangle()`, if `render_source` is a valid bitmap, a section of it (based on `w, h`) will be used as the texture instead."},{"name":"Quad3D ;; Screen::Quad3D / bitmap::Quad3D ;; Quad3D","val":"<h3>void Quad3D(int layer, int pos[12], uv[8], csets[4], size[2], int flip,\n        int texture, [[int render_mode|`PT_` constants]], bitmap render_source = NULL);</h3>\n\nNOTE: the `bitmap render_source` parameter is only available for `bitmap-&gt;Quad3D()`, not `Screen-&gt;Quad3D()`.\n\nDraws a 3d quad with the 4 corners specified in `pos` as `{x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4}`. `uv` specifies texture coordinates as `{x1,y1,x2,y2,x3,y3,x4,y4}`. `size` specifies the texture's `{w,h}`.\n\nThe texture is mapped from a tile or tile block if `texture &gt; 0`, or a combo/combo block if `texture &lt;= 0`. (Ex: texture = -32 will use combo 32 as a texture).\n\nFor `bitmap-&gt;Quad3D()`, if `render_source` is a valid bitmap, a section of it (based on `{w, h}` in `size`) will be used as the texture instead."},{"name":"Triangle3D ;; Screen::Triangle3D / bitmap::Triangle3D ;; Triangle3D","val":"<h3>void Triangle3D(int layer, int pos[9], uv[6], csets[3], size[2], int flip,\n        int texture, [[int render_mode|`PT_` constants]], bitmap render_source = NULL);</h3>\n\nNOTE: the `bitmap render_source` parameter is only available for `bitmap-&gt;Triangle3D()`, not `Screen-&gt;Triangle3D()`.\n\nDraws a 3d quad with the 4 corners specified in `pos` as `{x1,y1,z1,x2,y2,z2,x3,y3,z3}`. `uv` specifies texture coordinates as `{x1,y1,x2,y2,x3,y3}`. `size` specifies the texture's `{w,h}`.\n\nThe texture is mapped from a tile or tile block if `texture &gt; 0`, or a combo/combo block if `texture &lt;= 0`. (Ex: texture = -32 will use combo 32 as a texture).\n\nFor `bitmap-&gt;Triangle3D()`, if `render_source` is a valid bitmap, a section of it (based on `{w, h}` in `size`) will be used as the texture instead."},{"name":"DrawLayer ;; Screen::DrawLayer / bitmap::DrawLayer ;; DrawLayer","val":"<h3>void DrawLayer(int layer, \n        int source_map, int source_screen, int source_layer, \n        int x, int y, float rotation = 0, int opacity = OP_OPAQUE);</h3>\n\nDraws the entire layer `source_layer` from the screen `source_map, source_screen`.\nIf `rotation` isn't 0, the layer will be rotated around its' centerpoint."},{"name":"DrawScreen ;; Screen::DrawScreen / bitmap::DrawScreen ;; DrawScreen","val":"<h3>void DrawScreen(int layer, \n        int source_map, int source_screen, int source_layer, \n        int x, int y, float rotation = 0);</h3>\n\nDraws the entire screen `source_map, source_screen`.\nIf `rotation` isn't 0, the screen will be rotated around its' centerpoint."},{"name":"DrawFrame ;; Screen::DrawFrame / bitmap::DrawFrame ;; DrawFrame","val":"<h3>void DrawFrame(int layer,\n        int x, int y, int tile, int cset,\n        int width, int height, bool overlay = true,\n        int opacity = OP_OPAQUE);</h3>\n\nDraws a frame using a 2x2 block of tiles, the upper-left tile specified as `tile`. This works the same way as the default \"blue frame\" on engine subscreens.\n`width, height` indicate how many 8x8 pixel squares the frame is wide/high- so `4,4` would give a 32x32 pixel frame.\nIf `overlay` is false, color 0 in the frame tiles will be drawn as color 0 instead of transparent."},{"name":"Polygon ;; Screen::Polygon / bitmap::Polygon ;; Polygon","val":"<h3>void Polygon(int layer, int num_points, int vertices[],\n        int colour, int opacity = OP_OPAQUE);</h3>\n\nDraws a polygon, where `vertices` is an array, of which the first `num_points*2` indexes are made up of `num_points` `x,y` pairs. (ex for `num_points = 4`, `vertices = {x1,y1,x2,y2,x3,y3,x4,y4}`)."},{"name":"&lt;-- Prev ;;bitscrShare","val":"$-1$2"}],[{"name":"&lt;-- Global Pointers ;; function_globalptr","val":"$0$3"},{"name":"<em>Audio</em>","val":"The `Audio->` pointer holds various functions relating to SFX, MIDI, and Enhanced Music."},{"name":"SFX ;; audio_sfx / Audio::PlaySound / Audio::EndSound / Audio::PauseSound / Audio::ResumeSound / Audio::ContinueSound ;; PlaySound / EndSound / PauseSound / ResumeSound / ContinueSound","val":"<h3>void PlaySound(int sfx);</h3>\nPlays the quest SFX 'sfx'.\n\n<h3>void EndSound(int sfx);</h3>\nIf 'sfx' is playing, immediately stop it.\n\n<h3>void PauseSound(int sfx);</h3>\nIf 'sfx' is playing, pause it (so that it may be resumed later).\n\n<h3>void ResumeSound(int sfx);\nvoid ContinueSound(int sfx);</h3>\nResume 'sfx' from where it was paused."},{"name":"MIDI ;; audio_midi / Audio::PlayMIDI / Audio::PauseCurMIDI / Audio::ResumeCurMIDI ;; PlayMIDI / PauseCurMIDI / ResumeCurMIDI","val":"<h3>void PlayMIDI(int midi);</h3>\nPlays the MIDI 'midi'. Will revert upon changing screens.\n\n<h3>void PauseCurMIDI();</h3>\nPauses the currently playing MIDI so that it may be resumed later.\n\n<h3>void ResumeCurMIDI();</h3>\nResumes the previously paused MIDI."},{"name":"Enhanced Music ;; audio_enh / Audio::PlayEnhancedMusic ;; PlayEnhancedMusic","val":"<h3>bool PlayEnhancedMusic(char32[] [[filename|Max 255 characters\nValid Extensions: ogg, mp3, spc, gbs, vgm, gym, nsf, it, xm, s3m, mod]], int track);</h3>\n\nPlays the specified enhanced music, if it's available. If the music format does not support tracks, the track argument is ignored.\nIf the music cannot be played, the current music will continue. The music will revert to normal upon leaving the screen.\nReturns true if the music file was loaded successfully."},{"name":"Volume ;; audio_vol / Audio::adjustsfxvolume / Audio::adjustmusicvolume ;; adjustsfxvolume / adjustmusicvolume","val":"<h3>void AdjustMusicVolume(int percent);</h3>\nAdjusts the music volume (MIDI and Enhanced Music) to 'percent'% of the user's setting.\n\n<h3>void AdjustSFXVolume(int percent);</h3>\nAdjusts the SFX volume to 'percent'% of the user's setting.\n\n<h3>Note:</h3>\nThese <em>set</em> the volume relative to the user's original setting. If the user has a slider set to 0, no amount of calls will make it play sound. If the user has the slider at max, no amount of calls can make it any louder.\nExample: Assume the user has SFX volume at '32', and MIDI volume at '128'.\n```Audio->AdjustSFXVolume(200); //SFX volume is now '64'\nAudio->AdjustMusicVolume(50); //MIDI volume is now '64'\nAudio->AdjustSFXVolume(150); //SFX volume is now '48'\nAudio->AdjustMusicVolume(100); //MIDI volume is now '128'```"},{"name":"PanStyle ;; Audio::PanStyle","val":"<h3>int PanStyle;</h3>\nThe audio panning style. Use the `PAN_` constants for this value."}],[{"name":"&lt;-- Global Pointers ;; function_globalptr","val":"$0$3"},{"name":"<em>FileSystem</em>","val":"The `FileSystem->` pointer holds misc functions related to files and directories.\n\nPaths are often relative to a 'quest specific directory', which is at \"[zc root]/files/[quest name]/\"\n\nRelated: ${fileptr|file}, ${directoryptr|directory}"},{"name":"FileExists / DirExists","val":"<h3>bool FileExists(char32[] \"filepath\");\nbool DirExists(char32[] \"dirpath\");</h3>\nReturns true if the file/dir specified by the given path exists.\nIf [[\"All bitmap-> and FileSystem-> paths relative to quest 'Files' folder\"|at \"ZScript->Quest Script Settings->Instructions\"]] is enabled, paths are relative to the quest's specific directory; otherwise they are relative to the ZC folder."},{"name":"Remove ;; FileSystem::Remove","val":"<h3>bool Remove(char32[] \"filepath\");</h3>\nDeletes the file pointed to by 'filepath'. Path is relative to the quest's specific directory."},{"name":"LoadDirectory ;; FileSystem::LoadDirectory / LoadDirectory","val":"<h3>directory LoadDirectory(char32[] dirpath);</h3>\nOpens the directory pointed to by 'dirpath'"}],[{"name":"&lt;-- Global Pointers ;; function_globalptr","val":"$0$3"},{"name":"<em>Text</em>","val":"The `Text->` pointer holds various functions relating to text/fonts."},{"name":"Font Height ;; text_hei / text::fontheight / text::charheight / text::stringheight / text::messageheight ;; fontheight / charheight / stringheight / messageheight","val":"<h3>int FontHeight(int font);\nint CharHeight(char32 c, int font);\nint StringHeight(char32[] s, int font);</h3>\n\nReturns the height of 'font', in pixels.\n\n<h3>int MessageHeight(int msg);</h3>\n\nReturns the height of the font assigned to the 'msg' ${messagedata}."},{"name":"Font Width ;; text_wid / Text::charwidth / Text::stringwidth / Text::messagewidth ;; charwidth / stringwidth / messagewidth","val":"<h3>int CharWidth(char32 c, int font);\nint StringWidth(char32[] s, int font);</h3>\n\nReturns the width of the character 'c' or string 's', in the given font, as '${DrawString}' would draw it.\n\n<h3>int MessageWidth(int msg);</h3>\n\nReturns the width of the ${messagedata} 'msg', as '${DrawString}' would draw it."}],[{"name":"&lt;-- Global Pointers ;; function_globalptr","val":"$0$3"},{"name":"<em>Graphics</em>","val":"The `Graphics->` pointer holds various functions relating to visual effects."},{"name":"Tinting ;; Graphics::Tint / Graphics::MonochromeHue / Graphics::ClearTint ;; Tint / MonochromeHue / ClearTint","val":"<h3>void Tint(int red, int green, int blue);\nvoid MonochromeHue(int red, int green, int blue, bool distributed = true);</h3>\n\nTints the palette by adding `red`, `green`, and `blue` to the respective values of every palette swatch. Subsequent calls to these functions will SUM the tint with all previous tints.\nIf `MonochromeHue` is used, the palette will be greyscaled (either via a `uniform` or `distributed` greyscale, based on the 'distributed' bool) before the tint is applied.\n\n<h3>void ClearTint();</h3>\n\nClears all tint effects."},{"name":"Draw Count ;; Graphics::NumDraws / Graphics::MaxDraws","val":"<h3>int NumDraws();</h3>\n\nReturns the number of script drawing commands that are currently waiting in the draw queue.\n\n<h3>int MaxDraws();</h3>\r\n\r\nReturns the limit of the drawing queue. If ${Graphics::NumDraws|NumDraws()} returns the same as this, no further drawing commands will work until the queue has been cleared (i.e. the next frame)"},{"name":"GetPixel ;; Graphics::GetPixel","val":"<h3>int GetPixel(bitmap b, int x, int y);</h3>\n\nSame as ${bitmap::GetPixel|'b->GetPixel(x,y)'}"},{"name":"Wavy ;; Graphics::Wavy","val":"<h3>void Wavy(bool style_in);</h3>\n\nCreates a 'wave' effect, as a 'Wavy' warp type uses.\nThere are both 'in' and 'out' styles; if `style_in` is true, then the 'in' style is used; else the 'out' style is used."},{"name":"Zap ;; Graphics::Zap","val":"<h3>void Zap(bool style_in);</h3>\n\nCreates a 'zap' effect, as a 'Zap' warp type uses.\nThere are both 'in' and 'out' styles; if `style_in` is true, then the 'in' style is used; else the 'out' style is used."},{"name":"IsBlankTile ;; Graphics::IsBlankTile","val":"<h3>bool IsBlankTile[214500];</h3>\n\nRead-only. True if the given tile is entirely blank (all color 0)."},{"name":"Greyscale ;; Graphics::Greyscale / Graphics::Grayscale","val":"<h3>void Greyscale(bool enable);</h3>\n\nEnables or disables 'greyscale' mode. ${Graphics::MonochromeHue|MonochromeHue()} works similarly, but with more options."},{"name":"Monochrome ;; Graphics::Monochrome","val":"<h3>void Monochrome(int preset);</h3>\n\nActivates a monochrome preset.\n<ol start=\"0\">\n<li>TINT_NONE</li>\n<li>TINT_GREY</li>\n<li>TINT_RED</li>\n<li>TINT_GREEN</li>\n<li>TINT_BLUE</li>\n<li>TINT_VIOLET</li>\n<li>TINT_TEAL</li>\n<li>TINT_AMBER</li>\n<li>TINT_CYAN</li>\n</ol>\n\nTo use a distributed monochrome mode, add `TINT_MODE_DISTRIBUTED` to the preset."},{"name":"CreatePalData ;; Graphics::CreatePalData","val":"<h3>paldata CreatePalData();\npaldata CreatePalData(rgb color);</h3>\n\nCreates a new paldata. If 'color' is specified, fills the palette with that rgb color."},{"name":"MixColor ;; Graphics::MixColor","val":"<h3>rgb MixColor(rgb start, rgb end, float percent, int color_space = CSPACE_RGB);</h3>\nInterpolates a color between start and end and then returns the resulting rgb.\nThe value of percent should range from 0-1, with 0 representing the starting color.\n\nColor space specifies a color space to interpolate through, changing the resulting average.\n<ol start=\"0\">\n<li>CSPACE_RGB</li>\n<li>CSPACE_CMYK</li>\n<li>CSPACE_HSV</li>\n<li>CSPACE_HSV_CW</li>\n<li>CSPACE_HSV_CCW</li>\n<li>CSPACE_HSL</li>\n<li>CSPACE_HSL_CW</li>\n<li>CSPACE_HSL_CCW</li>\n<li>CSPACE_LAB</li>\n<li>CSPACE_LCH</li>\n<li>CSPACE_LCH_CW</li>\n<li>CSPACE_LCH_CCW</li>\n</ol>"},{"name":"CreateRGB ;; Graphics::CreateRGB / rgb","val":"<h3>rgb CreateRGB(int r, int g, int b);\nrgb CreateRGB(long hexcode);</h3>\nTakes either an (r,g,b) ranging 0 &lt;= n &lt;= 63, or takes a long hexcode (0xRRGGBBL), with each rgb section 0 &lt;= n &lt;= 255.\nConverts whichever is passed into an 'rgb' value, representing a color with 0-63 rgb values, which is used by paldata functions."}],[{"name":"&lt;-- Global Pointers ;; function_globalptr","val":"$0$3"},{"name":"<em>Input</em>","val":"The `Input->` pointer holds various values relating to button, mouse, and keyboard input."},{"name":"KeyBindings ;; Input::keybindings","val":"<h3>int KeyBindings[14];</h3>\n\nFor each index (using `CB_` constants to access), the keyboard key (`KEY_` constants) that is bound to that button."},{"name":"Button Input ;; Input::press / Input::button","val":"<h3>bool Button[CB_MAX];\nbool Press[CB_MAX];</h3>\n\nWhether the given button (`CB_` constants) is down (or 'pressed').\n\n'Press' indicates this was the first frame the button is down, while 'Button' indicates only that the button <em>is</em> down, with no regard for how long it has been down.\n\nThese are the same as the old `Hero->InputBUTTON` and `Hero->PressBUTTON` values, but as arrays."},{"name":"Keyboard Input ;; Input::key / Input::keypress / Input::modifierkeys","val":"<h3>bool Key[KEY_MAX];</h3>\nReturns true if the respective key is down this frame (similar to ${Input::button|Button[]}, but for keys instead of buttons).\n\n<h3>bool KeyPress[KEY_MAX];</h3>\nReturns true if the respective key was just pressed this frame (similar to ${Input::press|Press[]}, but for keys instead of buttons).\n\n<h3>int ModifierKeys;</h3>\nReturns the modifier keys as a bitwise flagset.\n#{Flag Constants|<ul><li>KB_SHIFT_FLAG: 0x0001</li>\n<li>KB_CTRL_FLAG: 0x0002</li>\n<li>KB_ALT_FLAG: 0x0004</li>\n<li>KB_LWIN_FLAG: 0x0008</li>\n<li>KB_RWIN_FLAG: 0x0010</li>\n<li>KB_MENU_FLAG: 0x0020</li>\n<li>KB_COMMAND_FLAG: 0x0040</li>\n<li>0x0080 unused flag</li></ul><ul>\n<li>KB_SCROLOCK_FLAG: 0x0100</li>\n<li>KB_NUMLOCK_FLAG: 0x0200</li>\n<li>KB_CAPSLOCK_FLAG: 0x0400</li>\n<li>KB_INALTSEQ_FLAG: 0x0800</li>\n<li>KB_ACCENT1_FLAG: 0x1000</li>\n<li>KB_ACCENT2_FLAG: 0x2000</li>\n<li>KB_ACCENT3_FLAG: 0x4000</li>\n<li>KB_ACCENT4_FLAG: 0x8000</li></ul>\n}"},{"name":"Mouse Input ;; Input::mouse","val":"<h3>int Mouse[6];</h3>\n\n<ol start=\"0\">\n<li>MOUSE_X: the X position of the mouse</li>\n<li>MOUSE_Y: the Y position of the mouse</li>\n<li>MOUSE_Z: the Z position of the mouse (scrollwheel)</li>\n<li>MOUSE_LEFT: bool, true if the left mouse button is down.</li>\n<li>MOUSE_RIGHT: bool, true if the right mouse button is down.</li>\n<li>MOUSE_MIDDLE: bool, true if the middle mouse button is down.</li>\n</ol>"},{"name":"Disabling ;; Input::disablebutton / Input::disablekey","val":"<h3>bool DisableButton[CB_MAX];</h3>\n\nWhether a given button (`CB_` constants) is disabled from having any in-engine effect.\n\n<h3>bool DisableKey[KEY_MAX];</h3>\n\nWhether a given keyboard key (`KEY_` constants) is disabled from having any in-engine effect.\nCertain keys, such as F9 for `reset system`, will work regardless of this setting."}],[{"name":"&lt;-- Sprite Pointers ;; function_data_sprite","val":"$0$5"}],[]],"cur_tab":51,"sheet_sz":[8,1,1,0,1,0,0,2,3,6,1,1,1,1,3,1,1,1,1,1,1,1,1,4,4,1,1,1,1,1,1],"sheet_nm":["Base Data","ZSMechanics","Versions","__NIL","Combodata","__NIL","__NIL","NPC","Game","Global","FFC","GenericData","File","Directory","Hero","RandGen","Stack","BottleData","BottleShopData","DropsetData","MessageData","ShopData","Screen","MapData","Bitmap","Audio","FileSystem","Text","Graphics","Input","Weapon"],"named":[{"name":"TTIPS","val":[{"name":"Shadow Type","val":"<ol start=\"0\"><li>No Shadow</li>\n<li>Basic shadow, no text</li>\n<li>'U' shadow, no text</li>\n<li>Full outline shadow, no text</li>\n<li>'+' outline shadow, no text</li>\n<li>'X' outline shadow, no text</li>\n<li>Basic shadow, behind text</li>\n<li>'U' shadow, behind text</li>\n<li>Full outline shadow, behind text</li>\n<li>'+' outline shadow, behind text</li>\n<li>'X' outline shadow, behind text</li></ol>"},{"name":"Counter","val":"<iblock><ol start=\"-1\">\n<li>CR_NONE</li>\n<li>CR_LIFE</li>\n<li>CR_RUPEES</li>\n<li>CR_BOMBS</li>\n<li>CR_ARROWS</li>\n<li>CR_MAGIC</li>\n<li>CR_KEYS</li>\n<li>CR_SBOMBS</li>\n<li>CR_CUSTOM1</li>\n<li>CR_CUSTOM2</li>\n<li>CR_CUSTOM3</li>\n<li>CR_CUSTOM4</li>\n<li>CR_CUSTOM5</li>\n<li>CR_CUSTOM6</li>\n<li>CR_CUSTOM7</li>\n<li>CR_CUSTOM8</li>\n<li>CR_CUSTOM9</li></ol></iblock>  <iblock><ol start=\"16\">\n<li>CR_CUSTOM10</li>\n<li>CR_CUSTOM11</li>\n<li>CR_CUSTOM12</li>\n<li>CR_CUSTOM13</li>\n<li>CR_CUSTOM14</li>\n<li>CR_CUSTOM15</li>\n<li>CR_CUSTOM16</li>\n<li>CR_CUSTOM17</li>\n<li>CR_CUSTOM18</li>\n<li>CR_CUSTOM19</li>\n<li>CR_CUSTOM20</li>\n<li>CR_CUSTOM21</li>\n<li>CR_CUSTOM22</li>\n<li>CR_CUSTOM23</li>\n<li>CR_CUSTOM24</li>\n<li>CR_CUSTOM25</li></ol></iblock>"},{"name":"OBJTYPE_","val":"<ol start=\"0\"><li>OBJTYPE_NPC</li>\r\n<li>OBJTYPE_LWPN</li>\r\n<li>OBJTYPE_EWPN</li>\r\n<li>OBJTYPE_ITSPR</li>\r\n<li>OBJTYPE_COMBODATA</li></ol>"},{"name":"Unblockable","val":"<ul>\r\n<li>UNBLOCK_NONE = 0000b</li>\r\n<li>UNBLOCK_NORM = 0001b - Bypasses normal 'block' defenses</li>\r\n<li>UNBLOCK_IGNR = 0010b - Bypasses 'ignore' defenses</li>\r\n<li>UNBLOCK_SHLD = 0100b - Bypasses enemy/hero 'shields'</li>\r\n<li>UNBLOCK_REFL = 1000b - Bypasses hero 'reflect' on shields</li>\r\n<li>UNBLOCK_ALL = 1111b</li>\n</ul>"},{"name":"Trigger Requirement","val":"This condition does not trigger the combo itself- instead, when something tries to trigger this combo, it must ALSO pass this condition.\nTo make this act as a trigger in itself, combine with the 'Always Triggered' (`TRIGFLAG_AUTO`) flag."}]},{"name":"MISC","val":[{"name":"WARPEFFECT_","val":"Values representing various warp transition effects.\n<ol start='0'><li>WARPEFFECT_NONE</li>\n<li>WARPEFFECT_ZAP</li>\n<li>WARPEFFECT_WAVE</li>\n<li>WARPEFFECT_INSTANT</li>\n<li>WARPEFFECT_OPENWIPE</li></ol>"},{"name":"AF_","val":"Bitwise values used to access `combodata-&gt;AnimFlags`\n<ul><li>AF_FRESH: Refresh Animation on Room Entry</li>\n<li>AF_CYCLE: Refresh Animation When Cycled To</li>\n<li>AF_CYCLENOCSET: Cycle ignores CSet</li>\n<li>AF_TRANSPARENT: Toggle Transparent</li></ul>"},{"name":"GENFLAG_","val":"Indexes for `combodata-&gt;GenFlags[]`\n<ol start='0'><li>GENFLAG_HOOKSHOTTABLE: Hook-Grabbable</li>\n<li>GENFLAG_SWITCHHOOKABLE: Switch-Hookable</li></ol>"},{"name":"TRIGFLAG_","val":"Indexes for `combodata-&gt;TrigFlags[]`\n<ol start='0'><li>[[TRIGFLAG_SWORD|Triggered by Sword LWeapons]]</li>\n<li>[[TRIGFLAG_SWORDBEAM|Triggered by Sword Beam LWeapons]]</li>\n<li>[[TRIGFLAG_BRANG|Triggered by Boomerang LWeapons]]</li>\n<li>[[TRIGFLAG_BOMB|Triggered by Bomb (explosion) LWeapons]]</li>\n<li>[[TRIGFLAG_SBOMB|Triggered by Super Bomb (explosion) LWeapons]]</li>\n<li>[[TRIGFLAG_LITBOMB|Triggered by Bomb (placed) LWeapons]]</li>\n<li>[[TRIGFLAG_LITSBOMB|Triggered by Super Bomb (placed) LWeapons]]</li>\n<li>[[TRIGFLAG_ARROW|Triggered by Arrow LWeapons]]</li>\n<li>[[TRIGFLAG_FIRE|Triggered by Fire LWeapons]]</li>\n<li>[[TRIGFLAG_WHISTLE|Triggered by Whistle LWeapons (whistle played)]]</li>\n<li>[[TRIGFLAG_BAIT|Triggered by Bait LWeapons]]</li>\n<li>[[TRIGFLAG_WAND|Triggered by Wand Handle LWeapon]]</li>\n<li>[[TRIGFLAG_MAGIC|Triggered by Magic LWeapons]]</li>\n<li>[[TRIGFLAG_WIND|Triggered by Wind LWeapons]]</li>\n<li>[[TRIGFLAG_REFMAGIC|Triggered by Reflected Magic LWeapons]]</li>\n<li>[[TRIGFLAG_REFFIREBALL|Triggered by Reflected Fireball LWeapons]]</li>\n<li>[[TRIGFLAG_REFROCK|Triggered by Reflected Rock LWeapons]]</li>\n<li>[[TRIGFLAG_HAMMER|Triggered by Hammer LWeapon]]</li>\n<li>[[TRIGFLAG_RESET_ANIM|On trigger, reset the animation of the combo.]]</li>\n<li>[[TRIGFLAG_INVERT_PROXIMITY|Proximity requirement is reversed]]</li>\n<li>[[TRIGFLAG_BTN_TOP|Triggered by button press from above]]</li>\n<li>[[TRIGFLAG_BTN_BOTTOM|Trigger by button press from below]]</li>\n<li>[[TRIGFLAG_BTN_LEFT|Trigger by button press from left]]</li>\n<li>[[TRIGFLAG_BTN_RIGHT|Trigger by button press from right]]</li>\n<li>[[TRIGFLAG_INVERT_MIN_MAX|Treat the 'TriggerLevel' as a max instead of a min]]</li>\n<li>[[TRIGFLAG_STEP|Triggered by 'Step-&gt;']]</li>\n<li>[[TRIGFLAG_STEP_SENS|Triggered by 'Step-&gt;Sensitive']]</li>\n<li>[[TRIGFLAG_SHUTTER|Triggered by 'Shutter-&gt;']]</li>\n<li>[[TRIGFLAG_CTYPE_EFFECTS|On trigger, cause the combo's type-related effects to occur. (ex: opening a chest)]]</li>\n<li>[[TRIGFLAG_ONLY_GENTRIG|Don't allow the combo to trigger via it's normal trigger methods (ex: bush via slashing)]]</li>\n<li>[[TRIGFLAG_KILL_WEAPON|If triggered by a weapon, kill the weapon.]]</li>\n<li>[[TRIGFLAG_EW_FIREBALL|Triggered by Fireball EWeapons]]</li>\n<li>[[TRIGFLAG_HOOKSHOT|Triggered by Hookshot LWeapons]]</li>\n<li>[[TRIGFLAG_SPARKLE|Triggered by Sparkle LWeapons]]</li>\n<li>[[TRIGFLAG_BYRNA|Triggered by Byrna LWeapons]]</li>\n<li>[[TRIGFLAG_REFBEAM|Triggered by Reflected Beam LWeapons]]</li>\n<li>[[TRIGFLAG_STOMP|Triggered by Stomp Boot LWeapons]]</li>\n<li>[[TRIGFLAG_SCRIPT1|Triggered by 'Custom Weapon 01' LWeapons]]</li>\n<li>[[TRIGFLAG_SCRIPT2|Triggered by 'Custom Weapon 02' LWeapons]]</li>\n<li>[[TRIGFLAG_SCRIPT3|Triggered by 'Custom Weapon 03' LWeapons]]</li>\n<li>[[TRIGFLAG_SCRIPT4|Triggered by 'Custom Weapon 04' LWeapons]]</li>\n<li>[[TRIGFLAG_SCRIPT5|Triggered by 'Custom Weapon 05' LWeapons]]</li>\n<li>[[TRIGFLAG_SCRIPT6|Triggered by 'Custom Weapon 06' LWeapons]]</li>\n<li>[[TRIGFLAG_SCRIPT7|Triggered by 'Custom Weapon 07' LWeapons]]</li>\n<li>[[TRIGFLAG_SCRIPT8|Triggered by 'Custom Weapon 08' LWeapons]]</li>\n<li>[[TRIGFLAG_SCRIPT9|Triggered by 'Custom Weapon 09' LWeapons]]</li>\n<li>[[TRIGFLAG_SCRIPT10|Triggered by 'Custom Weapon 10' LWeapons]]</li>\n<li>[[TRIGFLAG_AUTO|Triggered automatically, every frame.]]</li>\n<li>[[TRIGFLAG_TRIG_SECRETS|Triggered by 'Secrets-&gt;']]</li>\n<li>[[TRIGFLAG_INVERT_ITEMREQ|Invert the item requirement (require NOT having the item)]]</li>\n<li>[[TRIGFLAG_CONSUME_ITEMREQ|On trigger, consume the required item.]]</li>\n<li>[[TRIGFLAG_COUNTER_GE|Only trigger if the counter has &gt;= the specified amount]]</li>\n<li>[[TRIGFLAG_COUNTER_LT|Only trigger if the counter has &lt; the specified amount]]</li>\n<li>[[TRIGFLAG_COUNTER_EAT|Consume the specified amount from the counter. Negative amounts add.]]</li>\n<li>[[TRIGFLAG_COUNTER_NOT_ONLY_TRIG_EAT|Consume the specified amount from the counter even if the combo failed to trigger.]]</li>\n<li>[[TRIGFLAG_LIGHTON|Triggered by a lightbeam.]]</li>\n<li>[[TRIGFLAG_LIGHTOFF|Triggered by lack of a lightbeam.]]</li>\n<li>[[TRIGFLAG_PUSH|Triggered when the player pushes into the combo.]]</li>\n<li>[[TRIGFLAG_LENS_ON|Triggered when the lens is revealing.]]</li>\n<li>[[TRIGFLAG_LENS_OFF|Triggered when the lens is not revealing.]]</li>\n<li>[[TRIGFLAG_EW_ARROW|Triggered by Arrow EWeapons]]</li>\n<li>[[TRIGFLAG_EW_BRANG|Triggered by Boomerang EWeapons]]</li>\n<li>[[TRIGFLAG_EW_SWORD|Triggered by Sword EWeapons]]</li>\n<li>[[TRIGFLAG_EW_ROCK|Triggered by Rock EWeapons]]</li>\n<li>[[TRIGFLAG_EW_SCRIPT1|Triggered by 'Custom Weapon 01' EWeapons]]</li>\n<li>[[TRIGFLAG_EW_SCRIPT2|Triggered by 'Custom Weapon 02' EWeapons]]</li>\n<li>[[TRIGFLAG_EW_SCRIPT3|Triggered by 'Custom Weapon 03' EWeapons]]</li>\n<li>[[TRIGFLAG_EW_SCRIPT4|Triggered by 'Custom Weapon 04' EWeapons]]</li>\n<li>[[TRIGFLAG_EW_SCRIPT5|Triggered by 'Custom Weapon 05' EWeapons]]</li>\n<li>[[TRIGFLAG_EW_SCRIPT6|Triggered by 'Custom Weapon 06' EWeapons]]</li>\n<li>[[TRIGFLAG_EW_SCRIPT7|Triggered by 'Custom Weapon 07' EWeapons]]</li>\n<li>[[TRIGFLAG_EW_SCRIPT8|Triggered by 'Custom Weapon 08' EWeapons]]</li>\n<li>[[TRIGFLAG_EW_SCRIPT9|Triggered by 'Custom Weapon 09' EWeapons]]</li>\n<li>[[TRIGFLAG_EW_SCRIPT10|Triggered by 'Custom Weapon 10' EWeapons]]</li>\n<li>[[TRIGFLAG_EW_MAGIC|Triggered by Magic EWeapons]]</li>\n<li>[[TRIGFLAG_EW_BBLAST|Triggered by Bomb (explosion) EWeapons]]</li>\n<li>[[TRIGFLAG_EW_SBBLAST|Triggered by Super Bomb (explosion) EWeapons]]</li>\n<li>[[TRIGFLAG_EW_LITBOMB|Triggered by Bomb (unexploded) EWeapons]]</li>\n<li>[[TRIGFLAG_EW_LITSBOMB|Triggered by Super Bomb (unexploded) EWeapons]]</li>\n<li>[[TRIGFLAG_EW_FIRETRAIL|Triggered by Fire Trail EWeapons]]</li>\n<li>[[TRIGFLAG_EW_FLAME|Triggered by Flame EWeapons]]</li>\n<li>[[TRIGFLAG_EW_WIND|Triggered by Wind EWeapons]]</li>\n<li>[[TRIGFLAG_EW_FLAME2|Triggered by Flame 2 EWeapons]]</li></ol>"},{"name":"INTBTN_","val":"<ol start='0'><li>INTBTN_A</li>\n<li>INTBTN_B</li>\n<li>INTBTN_L</li>\n<li>INTBTN_R</li>\n<li>INTBTN_EX1</li>\n<li>INTBTN_EX2</li>\n<li>INTBTN_EX3</li>\n<li>INTBTN_EX4</li></ol>"},{"name":"LIFTGFX_","val":"Values for `combodata-&gt;LiftGFXType`\n<ol start='0'><li>[[LIFTGFX_THISCOMBO|Uses the combo's graphics directly.]]</li>\n<li>[[LIFTGFX_OTHERCOMBO|Uses the graphics of another combo/cset, specified as `LiftGFXCombo`/`LiftGFXCSet`]]</li>\n<li>[[LIFTGFX_SPRITEDATA|Uses a Sprite Data sprite as the graphics, specified as `LiftGFXSprite`.]]</li></ol>"},{"name":"LF_","val":"Indexes for `combodata-&gt;LiftFlags[]`\n<ol start='0'><li>[[LF_LIFTABLE|Combo can be lifted]]</li>\n<li>[[LF_DROPSET|The `LiftItem` is a dropset instead of an item ID]]</li>\n<li>[[LF_DROPONLIFT|The `LiftItem` is dropped on lift, instead of break.]]</li>\n<li>[[LF_SPECIALITEM|The `LiftItem` is the room's special item.]]</li>\n<li>[[LF_NOUCSET|Leaves the combo's CSet behind, instead of the UnderCSet.]]</li>\n<li>[[LF_NOWPNCMBCSET|Uses the combo's CSet, instead of the `LiftGFXCSet`]]</li>\n<li>[[LF_BREAKONSOLID|The weapon breaks upon colliding with a solid object, instead of going through solids.]]</li></ol>"}]}]}
