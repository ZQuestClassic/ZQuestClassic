{
    "key": "zs_docjson_py",
    "ver": 1,
    "sheets": [
        {
            "name": "Base Data",
            "tabs": [
                {
                    "name": "ROOT (HTML home)",
                    "lines": [
                        {
                            "name": "--",
                            "val": "<h3>ZScript Web Documentation</h3>\n\nUse the <span id=\"debug\">panel</span> at the left to navigate."
                        },
                        {
                            "name": "Data / Functions ;; function_root",
                            "val": "$-1$1"
                        },
                        {
                            "name": "ZScript Mechanics ;; Mechanics",
                            "val": "$ZSMechanics"
                        },
                        {
                            "name": "ZQ Docs",
                            "val": "$-1$2"
                        },
                        {
                            "name": "Changelogs",
                            "val": "$Versions"
                        }
                    ]
                },
                {
                    "name": "Data / Functions",
                    "lines": [
                        {
                            "name": "&lt;-- Top ;; top",
                            "val": "$0$0"
                        },
                        {
                            "name": "--",
                            "val": ""
                        },
                        {
                            "name": "Global Functions ;; function_global ;; Global Functions",
                            "val": "$Global"
                        },
                        {
                            "name": "Global Pointers ;; function_globalptr ;; Global Pointers",
                            "val": "$0$3"
                        },
                        {
                            "name": "Data Pointers ;; function_data ;; Data Pointers",
                            "val": "$0$4"
                        }
                    ]
                },
                {
                    "name": "ZQ Docs",
                    "lines": [
                        {
                            "name": "&lt;-- Top",
                            "val": "$0$0"
                        },
                        {
                            "name": "--",
                            "val": ""
                        },
                        {
                            "name": "Output Console ;; allegro.log / console",
                            "val": "<h3>Output Console</h3>\n\nThe term 'output console' can refer to multiple things. Generally, it refers to the actual zscript debugger console that can be opened in ZC via \"ZC -&gt; Show ZScript Debugger\"; though it could also refer to the general log output, which is logged to \"allegro.log\".\n\nErrors and debug information are logged to the Output Console (some of which is only logged if certain quest rules are enabled), which the user can use to debug their scripts.\n\n${Logging Functions} can be used to directly output to the console."
                        },
                        {
                            "name": "Message Strings ;; message string / message ;; Message Strings",
                            "val": "<h3>Message Strings</h3>\n\nEdited in 'Quest->Strings' in ZQuest, message strings represent messages that can be displayed on-screen to the player, including not only text, but also various formatting options, and ${SCCs|String Control Codes}.\n\nZScript can use ${messagedata} pointers to modify message strings directly."
                        },
                        {
                            "name": "String Control Codes ;; SCCs",
                            "val": "<h3>String Control Codes</h3> [[v|Rev April 16th, 2023 for 2.55 A114]] \n\nSpecial effects can be created when ${message strings} are displayed by inserting special control codes into the string. All valid codes are listed below.\n\n<h3>Formatting Codes</h3>\nThese codes have formatting effects on the string being displayed, such as changing the font, text color, or inserting characters or tiles into the message.\n#{<ul><li>`\\1\\cset\\color` : Changes the text color to the specified color.</li>\n<li>`\\26\\cset\\color` : Changes the shadow color to the specified color.</li>\n<li>`\\27\\[[shadow_type|$Shadow Type]]` : Changes the shadow type to the specified style.</li>\n<li>`\\2\\speed` : Changes the text speed. 'speed' is the number of frames between each character, where '0' is instantaneous.</li>\n<li>`\\135\\font` : Changes the text font. 'font' is the ID number of the new font to use.</li>\n<li>`\\25` : New Line - breaks to the next line</li>\n<li>`\\22` : Inserts the save file name as text</li>\n<li>`\\28\\tile\\cset\\[[width|In pixels]]\\[[height|In pixels]]\\flip` : Draws a tile block inline with the text, as though it were a custom font character.</li>\n<li>`\\32` through `\\126` : Inserts the corresponding ASCII character. Ex: `\\91` shows `\\`</li>\n<li>`\\24\\???` : Unimplemented; reserved for changing portrait</li></ul>}\n\n<h3>Menu Codes</h3>\nThese codes relate to popping up a menu for the player to select a choice from.\n#{<ul><li>`\\128\\tile\\cset\\width\\height\\flip` : Sets the menu cursor, args same as '\\28' above.</li>\n<li>`\\129\\pos\\up_pos\\down_pos\\left_pos\\right_pos` : Creates a menu cursor position. 'pos' is the index of this position, while the 4 directional values are the position that will be moved to when that direction is pressed. If a directional pos is the same as 'pos', that direction will be disabled.</li>\n<li>`\\130` : Start running menu. If no '\\129' codes have been run, the menu instantly exitswith the '0' pos selected.</li>\n<li>`\\131\\pos\\newstring` : Goto if menu selection. Switches to the new string if 'pos' is the selected menu position.</li></ul>}\n\n<h3>Switch Codes</h3>\nThese codes change from the current string immediately to a different string. If you attempt to switch to a string that does not exist, it will instead act as though you switched to a string that is entirely empty.\n#{<ul><li>`\\3\\register\\value\\newstring` : if `Screen->D[register] &gt;= value`, switches to `newstring`.</li>\n<li>`\\23\\dmap\\screen\\register\\value\\newstring` : Same as `\\3`, but for any screen.</li>\n<li>`\\4\\factor\\newstring` : Randomly has a `1/factor` chance to switch to `newstring`.</li>\n<li>`\\5\\itemid\\newstring` : Goes to `newstring` if the specified item is owned.</li>\n<li>`\\6\\counter\\value\\newstring` : Goto `newstring` if the specified counter is `>= value`.</li>\n<li>`\\7\\counter\\percent\\newstring` : Goto `newstring` if the specified counter is at least `percent` full.</li>\n<li>`\\8\\levelid\\newstring` : Goto `newstring` if the triforce from the specified level is owned.</li>\n<li>`\\9\\numtriforce\\newstring` : Goto `newstring` if at least `numtriforce` triforce pieces are owned.</li>\n<li>`\\131\\pos\\newstring` : Goto if menu selection. Switches to the new string if 'pos' is the selected menu position.</li></ul>}\n\n<h3>Counter Mod Codes</h3>\nThese codes all center around modifying counter values.\n#{<ul><li>`\\10\\ctr\\val` : Adds 'val' to 'ctr'.</li>\n<li>`\\11\\ctr\\val` : Subtracts 'val' from 'ctr'.</li>\n<li>`\\12\\ctr\\val` : Sets 'ctr' to 'val'.</li>\n<li>`\\13\\ctr\\percent` : Adds 'percent' % to 'ctr'.</li>\n<li>`\\14\\ctr\\percent` : Subtracts 'percent' % from 'ctr'.</li>\n<li>`\\15\\ctr\\percent` : Sets 'ctr' to 'percent' % full.</li>\n<li>`\\16\\itemid` : Gives the player 'itemid', silently. The item is not held up, nor does its' pickup script run; though its' counter effects will.</li>\n<li>`\\17\\itemid` : Takes 'itemid' from the player, silently. Its' pickup counter modifications will be reversed when removed.</li></ul>}\n\n<h3>Misc Codes</h3>\n#{<ul><li>`\\18\\dmap\\screen\\[[x\\y|<block>If `x &lt; 0`, then y is treated as a return square(0-3 for return squares A-D, 5 for pit warp).\nIf `x &gt;= 0`, then x+y act as destination coordinates.</block>]]\\[[effect|$WARPEFFECT_]]\\sound` : Warps the player to 'dmap,screen'.</li>\n<li>`\\19\\dmap\\screen\\register\\value` : Sets `Screen->D[register] = value;` for the specified screen.</li>\n<li>`\\20\\sfxid` : Plays a specified sfx</li>\n<li>`\\21\\MIDIid` : Plays a specified quest midi (cannot play the built-in midis)</li>\n<li>`\\29` : Immediately exits the current string. If there is a 'next string', it will begin immediately. The prompt to press 'A' to continue will be skipped.</li>\n<li>`\\30` : Pauses the string and prompts the player to press A to continue (as normally occurs at the end of a string)</li>\n<li>`\\132\\perm` : Triggers secrets, which are permanent unless 'perm' is '0'</li>\n<li>`\\133\\[[flag|Use the 'ST_' constants from 'std_constants.zh']]\\[[state|1 for on, 0 for off]]` : Sets a screen state on the current screen.</li>\n<li>`\\134\\map\\screen\\[[flag|Use the 'ST_' constants from 'std_constants.zh']]\\[[state|1 for on, 0 for off]]` : Same as \\133 above, for a remote map/screen</li>\n<li>`\\136\\generic_script_id\\[[force_redraw|If !=0, force the entire screen to redraw before running the frozen script.]]` : Run the specified generic script, in the ${genericdata::RunFrozen|RunFrozen} mode.</li></ul>}"
                        },
                        {
                            "name": "Quest Rules ;; quest_rules / qrs",
                            "val": "<h3>Quest Rules</h3>\nQuest Rules are global settings configurable in ZQuest. Scripts can read and modify these settings using ${Game::FFRules|Game-&gt;FFRules}.\n\nTo find a QR by name, go to `Quest-&gt;Options-&gt;Search QRs` in ZQuest.\n"
                        },
                        {
                            "name": "Itemclasses ;; itemclass",
                            "val": "<todo>Add `IC_` constant infopage</todo>\n"
                        }
                    ]
                },
                {
                    "name": "Global Pointers",
                    "lines": [
                        {
                            "name": "&lt;-- Data / Functions ;; function_root",
                            "val": "$0$1"
                        },
                        {
                            "name": "--",
                            "val": "Global Pointers have a single global instance which can be referenced anywhere."
                        },
                        {
                            "name": "Game Pointer ;; gameptr ;; Game Pointer",
                            "val": "$Game"
                        },
                        {
                            "name": "Hero Pointer ;; heroptr ;; Hero Pointer",
                            "val": "$Hero"
                        },
                        {
                            "name": "Screen Pointer ;; screenptr ;; Screen Pointer",
                            "val": "$Screen"
                        },
                        {
                            "name": "Input Pointer ;; inputptr ;; Input Pointer",
                            "val": "$Input"
                        },
                        {
                            "name": "Audio Pointer ;; audioptr ;; Audio Pointer",
                            "val": "$Audio"
                        },
                        {
                            "name": "Text Pointer ;; textptr ;; Text Pointer",
                            "val": "$Text"
                        },
                        {
                            "name": "Graphics Pointer ;; graphicsptr ;; Graphics Pointer",
                            "val": "$Graphics"
                        },
                        {
                            "name": "FileSystem Pointer ;; filesystemptr ;; FileSystem Pointer",
                            "val": "$FileSystem"
                        },
                        {
                            "name": "Debug Pointer ;; debugptr",
                            "val": "$Debug"
                        },
                        {
                            "name": "ZInfo Pointer ;; zinfoptr",
                            "val": "$ZInfo"
                        }
                    ]
                },
                {
                    "name": "Data Pointers",
                    "lines": [
                        {
                            "name": "&lt;-- Data / Functions ;; function_root",
                            "val": "$0$1"
                        },
                        {
                            "name": "--",
                            "val": "Data Pointers must be loaded before they can be used. Each has its' own pointer type of which variables can be declared."
                        },
                        {
                            "name": "FFC Pointers ;; ffcptr ;; FFC Pointers",
                            "val": "$FFC"
                        },
                        {
                            "name": "Sprite Pointers ;; function_data_sprite ;; Sprite Pointers",
                            "val": "$-1$5"
                        },
                        {
                            "name": "Misc Data Pointers ;; function_data_misc ;; Misc Data Pointers",
                            "val": "$-1$6"
                        },
                        {
                            "name": "Managed Pointers ;; function_data_managed ;; Managed Pointers",
                            "val": "$-1$7"
                        }
                    ]
                },
                {
                    "name": "Sprite Pointers",
                    "lines": [
                        {
                            "name": "&lt;-- Data Pointers ;; function_data",
                            "val": "$0$4"
                        },
                        {
                            "name": "--",
                            "val": "Sprite objects are a subset of object types which share a variety of attributes. These include weapons, npcs, items, etc."
                        },
                        {
                            "name": "NPC Pointers ;; npcptr",
                            "val": "$NPC"
                        },
                        {
                            "name": "Itemsprite Pointers ;; itemspriteptr",
                            "val": "$Itemsprite"
                        },
                        {
                            "name": "Weapon Pointers ;; wpnptr",
                            "val": "$Weapon"
                        }
                    ]
                },
                {
                    "name": "Misc Data Pointers",
                    "lines": [
                        {
                            "name": "&lt;-- Data Pointers ;; function_data",
                            "val": "$0$4"
                        },
                        {
                            "name": "MapData Pointers ;; mapdataptr",
                            "val": "$MapData"
                        },
                        {
                            "name": "BottleData Pointers ;; bottledataptr",
                            "val": "$BottleData"
                        },
                        {
                            "name": "BottleShopData Pointers ;; bottleshopdataptr",
                            "val": "$BottleShopData"
                        },
                        {
                            "name": "ComboData Pointers ;; comboptr",
                            "val": "$Combodata"
                        },
                        {
                            "name": "DMapData Pointers ;; dmapdataptr",
                            "val": "$DMapData"
                        },
                        {
                            "name": "DropsetData Pointers ;; dropsetdataptr",
                            "val": "$DropsetData"
                        },
                        {
                            "name": "Itemdata Pointers ;; itemdataptr",
                            "val": "$Itemdata"
                        },
                        {
                            "name": "MessageData Pointers ;; messagedataptr",
                            "val": "$MessageData"
                        },
                        {
                            "name": "ShopData Pointers ;; shopdataptr",
                            "val": "$ShopData"
                        },
                        {
                            "name": "SpriteData Pointers ;; spritedataptr",
                            "val": "$SpriteData"
                        },
                        {
                            "name": "GenericData Pointers ;; genericdataptr ;; GenericData Pointers",
                            "val": "$GenericData"
                        }
                    ]
                },
                {
                    "name": "Managed Pointers",
                    "lines": [
                        {
                            "name": "&lt;-- Data Pointers ;; function_data",
                            "val": "$0$4"
                        },
                        {
                            "name": "--",
                            "val": "Managed Pointers all have a total maximum that can be in use at a time, and are only freed for re-use using `Free()` and `Own()` functions."
                        },
                        {
                            "name": "RandGen Pointers ;; randgenptr ;; RandGen Pointers",
                            "val": "$RandGen"
                        },
                        {
                            "name": "File Pointers ;; fileptr ;; File Pointers",
                            "val": "$File"
                        },
                        {
                            "name": "Directory Pointers ;; directoryptr ;; Directory Pointers",
                            "val": "$Directory"
                        },
                        {
                            "name": "Bitmap Pointers ;; bitmapptr ;; Bitmap Pointers",
                            "val": "$Bitmap"
                        },
                        {
                            "name": "Stack Pointers ;; stackptr ;; Stack Pointers",
                            "val": "$Stack"
                        },
                        {
                            "name": "Paldata Pointers ;; paldataptr",
                            "val": "$PalData"
                        }
                    ]
                }
            ]
        },
        {
            "name": "Portals",
            "tabs": [
                {
                    "name": "Portals ROOT",
                    "lines": [
                        {
                            "name": "&lt;-- Sprite Pointers ;; function_data_sprite",
                            "val": "$0$5"
                        },
                        {
                            "name": "<em>portal</em>",
                            "val": "<h3>Portal Pointers</h3>   `portal`\n\n`portal` pointers allow accessing the on-screen 'portals', objects which warp the player to a specific destination when touched. Portals can be saved if they are created from a ${savedportal} object, in which case they will be re-created every time the screen is entered until they are used.\n\nSee: ${LoadPortal}, ${savedportal::Generate|savedportal->Generate}"
                        },
                        {
                            "name": "Pos & Graphics ;; portal::X / portal::Y / portal::AClk / portal::AFrame / portal::OriginalTile / portal::ASpeed / portal::Frames / portal::UseSprite",
                            "val": "<h3>int X;\nint Y;</h3>\nThe portal's X/Y position.\n\n<h3>int AFrame</h3>\nWhich frame of the portal's animation is currently showing. Add this to the OriginalTile to get the current tile.\n\n<h3>int OriginalTile;</h3>\nThe starting tile of the portal's animation.\n\n<h3>int ASpeed;</h3>\nThe duration, in frames, that each tile shows for.\n\n<h3>int AClk;</h3>\nThe animation clock used for the portal's animation timing. The tile advances when this reaches the ASpeed.\n\n<h3>int Frames;</h3>\nThe total number of tiles in the portal's animation.\n\n<h3>void UseSprite(int sprite);</h3>\nSet the graphics of the portal to a sprite data sprite."
                        },
                        {
                            "name": "Warping ;; portal::DMap / portal::Screen / portal::WarpSFX / portal::WarpEffect / portal::CloseDisabled",
                            "val": "<h3>int DMap;\nint Screen;</h3>\nThe destination of the warp. (The portal's X/Y doubles as the destination X/Y).\n\n<h3>int WarpSFX;</h3>\nThe SFX to play when warping.\n\n<h3>int WarpEffect;</h3>\nThe warp effect to use for the warp. Use the [[WARPEFFECT_|$WARPEFFECT_]] constants.\n\n<h3>bool CloseDisabled;</h3>\nIf the portal is disabled due to the player being too close after entering the screen. If true, the portal will not warp the player. Automatically becomes false if the player is not touching the portal."
                        },
                        {
                            "name": "Misc ;; portal::Remove / portal::SavedPortal",
                            "val": "<h3>${savedportal} SavedPortal;</h3>\nThe savedportal object linked to this portal, if one exists. NULL otherwise. (Read/Write)\n\n<h3>void Remove();</h3>\nDeletes the portal outright. Does NOT affect a linked ${savedportal}, that would need to be deleted separately."
                        }
                    ]
                }
            ]
        },
        {
            "name": "SavedPortals",
            "tabs": [
                {
                    "name": "SavedPortals ROOT",
                    "lines": [
                        {
                            "name": "&lt;-- Misc Data Pointers ;; function_data_misc",
                            "val": "$0$6"
                        },
                        {
                            "name": "<em>savedportal</em>",
                            "val": "<h3>SavedPortal Pointers</h3>   `savedportal`\n\n`savedportal` pointers allow accessing all portals currently active in a quest, which are saved to the save file.\n\nSee: ${LoadSavedPortal}, ${portal}"
                        },
                        {
                            "name": "Pos & Graphics ;; savedportal::X / savedportal::Y / savedportal::SrcDMap / savedportal::SrcScreen / savedportal::Sprite",
                            "val": "<h3>int X;\nint Y;</h3>\nThe portal's X/Y position.\n\n<h3>int SrcDMap;\nint SrcScreen;</h3>\nThe dmap/screen that the portal spawns on.\n\n<h3>int Sprite;</h3>\nThe sprite data sprite used for the portal's graphics."
                        },
                        {
                            "name": "Warping ;; savedportal::DestDMap / savedportal::DestScreen / savedportal::WarpSFX / savedportal::WarpEffect",
                            "val": "<h3>int DestDMap;\nint DestScreen;</h3>\nThe destination of the warp. (The portal's X/Y doubles as the destination X/Y).\n\n<h3>int WarpSFX;</h3>\nThe SFX to play when warping.\n\n<h3>int WarpEffect;</h3>\nThe warp effect to use for the warp. Use the [[WARPEFFECT_|$WARPEFFECT_]] constants."
                        },
                        {
                            "name": "Misc ;; savedportal::Remove / savedportal::Portal / savedportal::Generate",
                            "val": "<h3>${portal} Portal;</h3>\nThe portal object linked to this savedportal, if one exists. NULL otherwise. (Read/Write)\n\n<h3>void Remove();</h3>\nDeletes the savedportal outright. Does NOT affect a linked ${portal}, that would need to be deleted separately.\n\n<h3>${portal} Generate();</h3>\nIf a portal object is already linked, returns it.\nOtherwise, if the current DMap matches the portal's SrcDMap AND the current Screen matches the portal's SrcScreen, creates a new ${portal} object using this savedportal's data, and returns that.\nOtherwise, returns NULL."
                        }
                    ]
                }
            ]
        },
        {
            "name": "ZSMechanics",
            "tabs": [
                {
                    "name": "Base",
                    "lines": [
                        {
                            "name": "<em>Mechanics</em> ;; Mechanics",
                            "val": "This section is dedicated to the underlying mechanics of ZScript. This section will cover everything from the basics of `if`, `else`, `while`, `for`, etc all the way up to `class`, `namespace`, etc.\n\n<todo>Under construction!</todo>"
                        },
                        {
                            "name": "Operators",
                            "val": "$-1$1"
                        },
                        {
                            "name": "&lt;-- Top ;; top",
                            "val": "$0$0"
                        }
                    ]
                },
                {
                    "name": "Operators",
                    "lines": [
                        {
                            "name": "Operators ;; Operators / zsoperators",
                            "val": "<h2>Operators</h2>\nThis section contains information on the various operators that can be used in expressions in ZScript."
                        },
                        {
                            "name": "Arithmetic",
                            "val": "<h3>Addition `+`</h3>\nex. `2 + 2` gives `4`\n\n<h3>Subtraction `-`</h3>\nex. `10 - 5` gives `5`\n\n<h3>Multiplication `*`</h3>\nex. `5 * 7` gives `35`\n\n<h3>Division `/`</h3>\nex. `7 / 2` gives `3.5`\nDivision truncates everything beyond 4 decimal places.\n\n<h3>Modulo `%`</h3>\nModular division, gives the remainder of a division\nex. `10 % 3` gives 1, `5 % 3` gives 2, `16 % 2` gives 0, `5.5 % 3` gives `2.5`\n\n<h3>Power/Exponentiation `^^^`</h3>\nBehaves differently if the `long` type is involved.\nex. `5 ^^^ 2` gives `25`, `5L ^^^ 2L` gives `25L`\n\n<h3>Assignment Operators</h3>\nWith a variable (`x` in this example), you can use some assignment operators.\n<ul><li>`x = 5;`, sets the value of variable `x` to `5`</li>\n<li>`x += 5;` same as `x = x + 5;`</li>\n<li>`x -= 5;` same as `x = x - 5;`</li>\n<li>`x *= 5;` same as `x = x * 5;`</li>\n<li>`x /= 5;` same as `x = x / 5;`</li>\n<li>`x %= 5;` same as `x = x % 5;`</li></ul>\n\n<h3>Increment Operators</h3>\n`++x`, `x++` are the same as `x = x + 1`, and `--x`, `x--` are the same as `x = x - 1`. With one small exception, which rarely matters.\nIf you use these in an expression, the expression value is different. Example:\n```\nx = 5;\ny = ++x; //y is 6, x is 6\nx = 5;\ny = x++; //y is 5, x is 6```\nIf you are NOT using it in an expression, it is best to use the pre- version (`++x` or `--x`), such as in for loops `for(int q = 0; q < 10; ++q)`."
                        },
                        {
                            "name": "Under Construction...",
                            "val": ""
                        },
                        {
                            "name": "&lt;-- Back ;; zsmechanics",
                            "val": "$-1"
                        }
                    ]
                }
            ],
            "todo": true
        },
        {
            "name": "Versions",
            "tabs": [
                {
                    "name": "0",
                    "lines": [
                        {
                            "name": "&lt;-- Top ;; top",
                            "val": "$0$0"
                        },
                        {
                            "name": "<em>Versions</em>",
                            "val": "<todo>Version Info</todo>"
                        },
                        {
                            "name": "2.53 -&gt; 2.55 ;; changelog_253_255 / Changelog: 2.53 to 2.55",
                            "val": "<todo>Update changelog</todo>"
                        }
                    ]
                }
            ],
            "todo": true
        },
        {
            "name": "Debug",
            "tabs": [
                {
                    "name": "Debug ROOT",
                    "lines": [
                        {
                            "name": "&lt;-- Global Pointers ;; function_globalptr",
                            "val": "$Base Data$3"
                        },
                        {
                            "name": "<em>Debug</em> ;; Debug",
                            "val": "The `Debug->` pointer holds some internal debug variables.\n\nYou probably won't need to use it."
                        }
                    ],
                    "todo": true
                }
            ],
            "todo": true
        },
        {
            "name": "NPCData",
            "tabs": [],
            "todo": true
        },
        {
            "name": "NPC",
            "tabs": [
                {
                    "name": "NPC ROOT",
                    "lines": [
                        {
                            "name": "&lt;-- Sprite Pointers ;; function_data_sprite",
                            "val": "$0$5"
                        },
                        {
                            "name": "<em>npc</em>",
                            "val": "<h3>NPC Pointers</h3>   `npc`\n\nThese pointers represent an enemy on the screen, and its' various attributes and functions.\nUsing these pointers, you can move them, damage them, make them move, make them invincible, etc.\n\nSee: ${LoadNPC}, ${CreateNPC}"
                        },
                        {
                            "name": "Basic Info ;; npc::ID / npc::Type / npc::Family / npc::isValid / npc::Dir / npc::Animation",
                            "val": "<h3>int ID;</h3>\nThe enemy ID of the enemy, read-only.\n\n<h3>int Type;\nint Family;</h3>\nThe type, or 'enemy class' of the enemy. Use the `NPCT_` constants.\n<todo>NPCT_ constant info, copyright-neutral names</todo>\n\n<h3>bool isValid();</h3>\nReturns true if this pointer points to a valid npc. If this returns false, using any other value of this pointer will error.\n\n<h3>int Dir;</h3>\nThe npc's direction.\n\n<h3>bool Animation;</h3>\nIf the engine should animate the npc's graphics."
                        },
                        {
                            "name": "Position ;; npc::X / npc::Y / npc::Z / npc::Jump / npc::Gravity / npc::MoveFlags / npc::FakeZ / npc::FakeJump",
                            "val": "<h3>int X; int Y; int Z;</h3>\n\nRead/Write; These values store the npc's position on each of the three axes.\nIf the ${QRS|quest rule} `Sprite Coordinates are Float` is checked, these values can include up to 4 decimal places; otherwise values are truncated.\n\n<h3>int Jump;</h3>\nThe npc's upward velocity, in pixels per frame. Affected by gravity each frame, if gravity is enabled for this npc.\n\n<h3>bool Gravity;</h3>\nIf false, gravity will not affect this npc.\n\n<h3>bool MoveFlags[];</h3>\nThe movement flags of the npc. See `NPCMV_` constants.\n#{NPCMV_ constants|$[NPCMV_]}\n<h3>int FakeZ;</h3>\nThe position of the npc on the FakeZ axis.\n\n<h3>int FakeJump;</h3>\nThe velocity of the npc in the FakeZ axis.\n"
                        },
                        {
                            "name": "Sprite Limit ;; npc::Max",
                            "val": "<h3>int Max();</h3>\nReturns the max number of npcs currently allowed.\n\n<h3>void Max(int newmax);</h3>\nSets the max number of npcs allowed to a new value. Range `1-1024`.\n"
                        },
                        {
                            "name": "Owning ;; npc::Own / npc::OwnArray / npc::OwnObject",
                            "val": "<h3>void Own(bitmap b);\nvoid Own(paldata pd);\nvoid Own(stack st);\nvoid Own(file f);\nvoid Own(directory dir);\nvoid Own(randgen rnd);\nvoid OwnArray(untyped[] array);\nvoid OwnObject([Object] object);</h3>\n\nGrants 'Ownership' of the parameter object to the npc."
                        },
                        {
                            "name": "Movement ;; npcMovement",
                            "val": "$-1$2"
                        },
                        {
                            "name": "Next -&gt; ;; weaponptr2",
                            "val": "$-1$1"
                        }
                    ]
                },
                {
                    "name": "NPC 2",
                    "lines": [
                        {
                            "name": "&lt;-- Sprite Pointers ;; function_data_sprite",
                            "val": "$0$5"
                        },
                        {
                            "name": "Size Info ;; npc::Extend / npc::HitWidth / npc::HitHeight / npc::HitZHeight / npc::TileWidth / npc::TileHeight / npc::DrawXOffset / npc::DrawYOffset / npc::TotalDYOffset / npc::DrawZOffset / npc::HitXOffset / npc::HitYOffset",
                            "val": "<h3>int Extend;</h3>\nIf the sprite should be extended (large). Set to 3 to extend, 0 otherwise.\n\n<h3>int HitWidth;\nint HitHeight;</h3>\nThe width/height of the hitbox, in pixels.\n\n<h3>int HitZHeight;</h3>\nThe height of the hitbox in the Z-axis, in pixels.\n\n<h3>int TileWidth;\nint TileHeight;</h3>\nThe width/height of the sprite's graphic, in tiles.\n\n<h3>int DrawXOffset;\nint DrawYOffset;</h3>\nThe visual offset, in pixels.\n\n<h3>int TotalDYOffset;</h3>\nRead-only, the weapon's total visual Y-offset.\n\n<h3>int DrawZOffset;</h3>\nThe Z offset, in pixels.\n\n<h3>int HitXOffset;\nint HitYOffset;</h3>\nThe hitbox offset, in pixels."
                        },
                        {
                            "name": "Script Info ;; npc::Script / npc::InitD / npc::Misc",
                            "val": "<h3>int Script;</h3>\nThe npc script running on this npc.\n\n<h3>int InitD[8];</h3>\nThe 8 InitD[] arguments for the npc script.\n\n<h3>int Misc[32];</h3>\nAn array of misc values for script use."
                        },
                        {
                            "name": "Status ;; npc::Falling / npc::FallCombo / npc::Drowning / npc::DrownCombo / npc::SwitchHooked / npc::Switch / npc::Stun / npc::Submerged / npc::Ringleader / npc::HasItem / npc::Shield / npc::FlashingCSet / npc::isFlickerFrame / npc::FlickerColor / npc::FlickerTransparencyPasses",
                            "val": "<h3>int Falling;</h3>\nThe timer indicating how long left the sprite will be falling. If 0, the sprite is not falling. Max value of 70, which is the value at the start of falling.\n\n<h3>int FallCombo;</h3>\nThe pitfall combo the sprite is falling into, if it is falling.\n\n<h3>int Drowning;</h3>\nThe timer indicating how long left the sprite will be drowning. If 0, the sprite is not drowning. Max value of 64, which is the value at the start of drowning.\n\n<h3>int DrownCombo;</h3>\nThe liquid combo the sprite is drowning in, if it is drowning.\n\n<h3>bool SwitchHooked;</h3>\nIf the sprite is currently being switch-hooked.\n\n<h3>bool Switch(int effect);</h3>\nSwitch the player with this sprite. Use the `SW_EFF_` constants for 'effect' to select a visual style for the switch.\nReturns true if it succeeds, and false otherwise.\n\n<h3>int Stun;</h3>\nThe duration the npc is stunned for. If 0, the npc is not stunned.\n\n<h3>bool Submerged();</h3>\nReturns true if the npc is submerged (ex. underground/underwater)\n\n<h3>bool Ringleader;</h3>\nIf true, the enemy is a Ringleader, and killing this npc will kill every npc in the room.\n\n<h3>bool HasItem;</h3>\nTrue if the enemy is carrying an item.\n\n<h3>bool Shield[5];</h3>\nFlags related to the enemy's shield. Use the `SHLD_` constants to access.\n#{SHLD_ constants|$[SHLD_]}\n\n<h3>int FlashingCSet;</h3>\nThis returns the enemy's current displayed cset when taking damage or invincible. If not in one of these states, will return its normal cset.\nIf called before Waitdraw() / enemy update, results may be off by a frame.\nIf the quest rule 'Enemies Flicker When Hit' is checked, this is unused.\n\n<h3>bool isFlickerFrame();</h3>\nThis returns true if the enemy is currently in a flicker frame (either invisible or color masked).\nIf called before Waitdraw() / enemy update, results may be off by a frame.\nIf the quest rule 'Enemies Flicker When Hit' is unchecked, this is unused.\n\n<h3>int FlickerColor;</h3>\nThis sets what color the enemy is drawn when flickering.\nIf -1, will use the default from Init Data.\nIf the quest rule 'Enemies Flicker When Hit' is unchecked, this is unused.\n\n<h3>int FlickerTransparencyPasses;</h3>\nThis sets how many times the transparency effect is applied to the enemy's flicker effect.\nIf -1, will use the default from Init Data. If 0, will use a solid color.\nIf the quest rule 'Enemies Flicker When Hit' is unchecked, this is unused."
                        },
                        {
                            "name": "&lt;-- Prev ;; weaponptr",
                            "val": "$-1"
                        }
                    ]
                },
                {
                    "name": "NPC Movement",
                    "lines": [
                        {
                            "name": "&lt;-- NPC Pointers",
                            "val": "$-1$0"
                        },
                        {
                            "name": "MoveXY ;; npc::MoveXY / npc::CanMoveXY",
                            "val": "<h3>bool MoveXY(float dx, float dy, int special);\nbool CanMoveXY(float dx, float dy, int special);</h3>\n\nAttempts to move the enemy by 'dx' in the x direction and 'dy' in the y direction, failing if it is blocked by something it cannot walk through.\n\nUse the 'SPW_' constants for 'int special'; i.e. 'SPW_FLOATER' to indicate a flying enemy.\n\nReturns true if the enemy moves the full distance, false if the enemy was blocked at all.\n\nThe 'CanMoveXY' variant will not actually move the enemy at all, but will run the collision checks and return true if it <em>CAN</em> move the full distance, or false if it <em>WOULD</em> be blocked.\n"
                        },
                        {
                            "name": "Move ;; npc::Move / npc::CanMove",
                            "val": "<h3>bool Move(int dir, float pxamnt, int special);\nbool CanMove(int dir, float pxamnt, int special);</h3>\n\nAttempts to move the enemy by 'pxamnt' pixels in the 'dir' direction, failing if it is blocked by something it cannot walk through.\n\nUse the 'SPW_' constants for 'int special'; i.e. 'SPW_FLOATER' to indicate a flying enemy.\n\nReturns true if the enemy moves the full distance, false if the enemy was blocked at all.\n\nThe 'CanMove' variant will not actually move the enemy at all, but will run the collision checks and return true if it <em>CAN</em> move the full distance, or false if it <em>WOULD</em> be blocked.\n"
                        },
                        {
                            "name": "MoveAtAngle ;; npc::MoveAtAngle / npc::CanMoveAtAngle",
                            "val": "<h3>bool MoveAtAngle(float degrees, float pxamnt, int special);\nbool CanMoveAtAngle(float degrees, float pxamnt, int special);</h3>\n\nAttempts to move the enemy by 'pxamnt' pixels in the 'degrees' angle, failing if it is blocked by something it cannot walk through.\n\nUse the 'SPW_' constants for 'int special'; i.e. 'SPW_FLOATER' to indicate a flying enemy.\n\nReturns true if the enemy moves the full distance, false if the enemy was blocked at all.\n\nThe 'CanMoveAtAngle' variant will not actually move the enemy at all, but will run the collision checks and return true if it <em>CAN</em> move the full distance, or false if it <em>WOULD</em> be blocked.\n"
                        },
                        {
                            "name": "CanPlace ;; npc::CanPlace",
                            "val": "<h3>bool CanPlace(float dx, float dy, [[int special = SPW_NONE|Use the 'SPW_' constants to provide a special value; i.e. 'SPW_FLOATER' for flying enemies. Use 'SPW_NONE' if you don't know what to use.]],\n\t[[bool knockback = false|Some enemies treat pits/liquid as solid, EXCEPT if they are being knocked back. 'bool knockback' here affects this for the placement checks.]], [[int nw = -1, int nh = -1|If 'nw' or 'nh' are > -1, they will be used as the width/height of the enemy for the check. Otherwise, the enemy's hitwidth/hitheight are used.\n]]);</h3>\n\nReturns true if the enemy could be arbitrarily placed at (ex. teleported to) the position 'nx,ny'."
                        },
                        {
                            "name": "MovePaused ;; npc::MovePaused",
                            "val": "<h3>bool MovePaused();</h3>\n\nReturns true if the enemy is in a state in which it should not be allowed to move (ex. spawning, dying, stunned, time frozen by clock)\nReturns false otherwise.\n"
                        },
                        {
                            "name": "Knockback ;; npc::Knockback / npc::NoScriptKnockback / npc::NoSlide / npc::SlideSpeed",
                            "val": "<h3>bool Knockback(int time, int dir, int speed);</h3>\n\nAttempt to knock back the npc in 'dir' direction, for 'time' frames, at a rate of 'speed' pixels per frame.\n\nReturns true if successful, false if the enemy could not be knocked back.\n\n<h3>bool NoScriptKnockback;</h3>\n\nFalse by default. If set to 'true', scripted knockback via 'npc-&gt;Knockback()' is ignored.\n\n<h3>bool NoSlide;</h3>\nFalse by default. If set to 'true', engine knockback is ignored.\n\n<h3>int SlideSpeed;</h3>\nThe number of pixels engine knockback moves the enemy at a time. Default 4."
                        },
                        {
                            "name": "Engine Walking ;; npc::ConstantWalk / npc::ConstantWalk8 / npc::VariableWalk / npc::VariableWalk8 / npc::HaltingWalk / npc::HaltingWalk8 / npc::FloatingWalk",
                            "val": "For 'special' args, use 'SPW_NONE' for ground enemies, and 'SPW_FLOATER' for flying enemies. These functions are generally kinda bad, but they are here if you really want them.\n\n<h3>void ConstantWalk([[int arr[]|NULL for no args, or\n{int rate,int homing,int special}]]);</h3>\nAccess to the engine ConstantWalk behavior.\n\n<h3>void ConstantWalk8([[int arr[]|NULL for no args, or\n{int rate,int homing,int special}]]);</h3>\nAccess to the engine ConstantWalk8 behavior. Like ConstantWalk, but 8-dir.\n\n<h3>void VariableWalk([[int arr[]|{int rate,int homing,int special}]]);</h3>\nAccess to the engine VariableWalk behavior.\n\n<h3>void VariableWalk8([[int arr[]|{int rate,int homing,int special} or\n{int rate,int homing,int special,int dx1,int dy1,int dx2,int dy2}]]);</h3>\nAccess to the engine VariableWalk8 behavior. Like VariableWalk, but 8-dir.\n\n<h3>void HaltingWalk([[int arr[]|{int rate,int homing,int special,int hrate,int haltcnt}]]);</h3>\nAccess to the engine HaltingWalk behavior.\n\n<h3>void HaltingWalk8([[int arr[]|{int rate,int homing,int special,int hrate,int haltcnt}]]);</h3>\nAccess to the engine HaltingWalk8 behavior. Like HaltingWalk, but 8-dir.\n\n<h3>void FloatingWalk([[int arr[]|?? <todo>Figure out how this function works</todo>]]);</h3>\nAccess to the engine FloatingWalk behavior."
                        }
                    ]
                }
            ],
            "todo": true
        },
        {
            "name": "PalData",
            "tabs": [
                {
                    "name": "PalData ROOT",
                    "lines": [
                        {
                            "name": "&lt;-- Managed Pointers ;; function_data_managed",
                            "val": "$0$7"
                        },
                        {
                            "name": "paldata ;; paldata::paldata",
                            "val": "<h3>PalData Pointers</h3>   `paldata`\n\n`paldata` pointers allow storing and modifying various palettes. A paldata holds 256 `rgb` colors divided into 16 CSets. Colors can be disabled to mask them out of various operations.\n\nSee: ${Graphics::CreatePalData|CreatePalData}"
                        },
                        {
                            "name": "rgb ;; paldata::rgb",
                            "val": "<h3>The RGB Type</h3>   `rgb`\n\n`rgb` is a special type used by paldata for storing colors as a single integer. It has a range from 0x0L to 0x3F3F3FL with a special value of INVALID_COLOR (-1) for unassigned colors. rgb cannot inherently cast to other primitive types.\n\nSee: ${Graphics::CreateRGB|CreateRGB}"
                        },
                        {
                            "name": "Access ;; paldata::Color / paldata::R / paldata::G / paldata::B / paldata::ClearColor / paldata::ClearCSet / paldata::ColorValid",
                            "val": "<h3>rgb Color[256];</h3>\nAccess colors of the paldata as ${PalData::rgb|rgb}. Reading an invalid color will return INVALID_COLOR (-1). To write a color as invalid, use ClearColor() instead.\n\n<h3>int R[256];</h3>\n<h3>int G[256];</h3>\n<h3>int B[256];</h3>\nAccess the R/G/B values of the paldata, ranging from 0-63. Reading an invalid color will return -1. To write a color as invalid, use ClearColor() instead.\n\n<h3>void ClearColor(int index);</h3>\nClears the color at index on the paldata. Cleared colors will be skipped when writing to a palette.\n\n<h3>void ClearCSet(int cset);</h3>\nClears an cset on the paldata. Cleared colors will be skipped when writing to a palette.\n\n<h3>void ColorValid(int index);</h3>\nReturns true if the color at index is valid."
                        },
                        {
                            "name": "Loading ;; paldata::LoadLevelPalette",
                            "val": "<h3>LoadLevelPalette(int pal);</h3>\nLoads a level's palette to the paldata.\nCSets will be arranged as they appear on the main palette, so CSet 2 starts at index 0x20, ect.\n\n<h3>LoadSpritePalette(int pal);</h3>\nLoads a page of sprite palettes to the paldata.\nCurrently only values of 0 and 1 are valid.\n\n<h3>void LoadMainPalette();</h3>\nLoads the main palette to the paldata.\nThis will load colors that have been changed by Tint() and Greyscale().\n\n<h3>void LoadCyclePalette(int pal);</h3>\nLoads the cycle/dark room csets from a level palette to the paldata.\nCSets will be arranged as they appear in the level palette editor, so the first four will be left blank.\n\n<h3>void LoadBitmapPalette(int pal);</h3>\nLoads the palette from an image. Currently only BMP, PCX, and TGA are supported."
                        },
                        {
                            "name": "Writing ;; paldata::WriteLevelPalette / paldata::WriteLevelCSet / paldata::WriteSpritePalette / paldata::WriteSpriteCSet / paldata::WriteMainPalette / paldata::WriteMainCSet / paldata::WriteCyclePalette / paldata::WriteCycleCSet",
                            "val": "<h3>void WriteLevelPalette(int pal);</h3>\nWrites the paldata to a level palette. Empty color indices will be skipped.\n\n<h3>void WriteLevelCSet(int pal, int cset);</h3>\nWrites a cset of the paldata to a level palette. Empty color indices will be skipped.\n\n<h3>void WriteSpritePalette(int pal);</h3>\nWrites the paldata to a sprite palette page. Empty color indices will be skipped.\n\n<h3>void WriteSpriteCSet(int pal, int cset);</h3>\nWrites a cset of the paldata to a sprite palette page. Empty color indices will be skipped. \n\n<h3>void WriteMainPalette();</h3>\nWrites the paldata to the main palette. Empty color indices will be skipped.\n\n<h3>void WriteMainCSet(int cset);</h3>\nWrites a cset of the paldata to the main palette. Empty color indices will be skipped. \n\n<h3>void WriteCyclePalette(int pal);</h3>\nWrites the paldata to a level palette's cycle/dark room csets. Empty color indices will be skipped.\n\n<h3>void WriteCycleCset(int pal, int cset);</h3>\nWrites a cset of the paldata to a level palette's cycle/dark room csets. Empty color indices will be skipped."
                        },
                        {
                            "name": "Copying ;; paldata::Copy / paldata::CopyCSet",
                            "val": "<h3>void Copy(paldata target);</h3>\nCopies all the colors from this paldata to the target.\n\n<h3>void CopyCSet(paldata target, int src_cset, int dest_cset);</h3>\nCopies all the colors from one cset on this paldata to another on the target."
                        },
                        {
                            "name": "Mixing ;; paldata::Mix / paldata::MixCSet",
                            "val": "<h3>void Mix(paldata start, paldata end, float percent = 0.5, int color_space = CSPACE_RGB);</h3>\nInterpolates all the colors on a paldata between start and end.\nThe value of percent should range from 0.0000-1.0000 with 0 representing the starting color.\nColor space specifies a color space to interpolate through, changing the resulting average.\n\n<h3>void MixCSet(paldata start, paldata end, int cset, float percent = 0.5, int color_space = CSPACE_RGB);</h3>\nInterpolates all the colors on a cset of a paldata between start and end.\nThe value of percent should range from 0.0000-1.0000 with 0 representing the starting color.\nColor space specifies a color space to interpolate through, changing the resulting average.\n\nColor space specifies a color space to interpolate through, changing the resulting average. Use the following `CSPACE_` constants:\n<ol start=\"0\">\n<li>CSPACE_RGB</li>\n<li>CSPACE_CMYK</li>\n<li>CSPACE_HSV</li>\n<li>CSPACE_HSV_CW</li>\n<li>CSPACE_HSV_CCW</li>\n<li>CSPACE_HSL</li>\n<li>CSPACE_HSL_CW</li>\n<li>CSPACE_HSL_CCW</li>\n<li>CSPACE_LAB</li>\n<li>CSPACE_LCH</li>\n<li>CSPACE_LCH_CW</li>\n<li>CSPACE_LCH_CCW</li>\n</ol>\n\nSee also: ${Graphics::MixColor|MixColor}"
                        },
                        {
                            "name": "Pointer Management ;; paldata::Free / paldata::Own",
                            "val": "<h3>void Free();</h3>\nDe-allocates this `paldata` pointer, so that its' pointer ID may be re-used. You may only have a limited number of paldata pointers active at a time; freeing them when you are done with them helps not reach the limit.\n\n<h3>void Own();</h3>\r\nGrants 'Ownership' of the paldata pointer to the script that calls this function. When the script with 'Ownership' terminates (at the same time its' local arrays are deallocated), this paldata pointer will automatically be 'Free()'d."
                        }
                    ]
                }
            ]
        },
        {
            "name": "Weapon",
            "tabs": [
                {
                    "name": "Weapon ROOT",
                    "lines": [
                        {
                            "name": "&lt;-- Sprite Pointers ;; function_data_sprite",
                            "val": "$Base Data$5"
                        },
                        {
                            "name": "<em>lweapon / eweapon</em>",
                            "val": "<h3>Weapon Pointers</h3>   `lweapon`, `eweapon`\n\nThese pointers represent weapon objects on screen. `lweapon` pointers represent the player's weapons, while `eweapon` pointers represent enemy weapons.\nSee: ${LoadLWeapon}, ${CreateLWeapon}, ${LoadEWeapon}, ${CreateEWeapon}\n\n"
                        },
                        {
                            "name": "EWeapon / LWeapon exclusive ;; lwpnptr / ewpnptr / eweapon::Parent / lweapon::Parent / lweapon::Weapon / lweapon::Defense / lweapon::Special",
                            "val": "<h2>EWeapon Exclusive</h2>\n\n<h3>npc Parent;</h3>\nThe npc pointer to the parent NPC.\n\n<h2>LWeapon Exclusive</h2>\n\n<h3>int Parent;</h3>\nThe item ID of the parent item.\n\n<h3>int Weapon;</h3>\nThe UseWeapon property for this weapon. If set to a value greater than 0, this value will be used instead of the weapon's type when interacting with npcs and triggers. Uses `LW_` constants.\n\n<h3>int Defense;</h3>\nThe default defense of the weapon. If set to a value greater than 0, this defense will be used instead of the `(None)` defense when hitting enemies. Uses `NPCDT_` constants.\n\n<h3>int Special;</h3>\nThe special info for the lweapon. Used by wind lweapons, instead of Level, to determine their effects. \n"
                        },
                        {
                            "name": "Basic Info ;; lweapon::ID / eweapon::ID / lweapon::Type / eweapon::Type / lweapon::Family / eweapon::Family / lweapon::isValid / eweapon::isValid / lweapon::Level / eweapon::Level / lweapon::Dir / eweapon::Dir / lweapon::Angle / eweapon::Angle / lweapon::DegAngle / eweapon::DegAngle / lweapon::Angular / eweapon::Angular / lweapon::MakeAngular / eweapon::MakeAngular / lweapon::MakeDirectional / eweapon::MakeDirectional / lweapon::Vx / eweapon::Vx / lweapon::Vy / eweapon::Vy / lweapon::Animation / eweapon::Animation",
                            "val": "<h3>int ID;\nint Type;\nint Family;</h3>\nThe weapon type of the weapon. Some types have hardcoded behaviors.\n\n<h3>bool isValid();</h3>\nReturns true if this pointer points to a valid weapon. If this returns false, using any other value of this pointer will error.\n\n<h3>int Level;</h3>\nFor lweapons, the level of the weapon.\nFor eweapons, bitwise. The `1` bit represents it being a \"boss\" weapon (ex. 'boss fireball')\n\n<h3>int Dir;</h3>\nThe weapon's direction.\n\n<h3>float Angle;\nfloat DegAngle;</h3>\nThe angle of the weapon, in radians for Angle or degrees for DegAngle. Has no real effect if the weapon is not `Angular`.\n\n<h3>bool Angular;</h3>\nIf the weapon is angular (instead of directional)\n\n<h3>void MakeAngular();</h3>\nIf the weapon is not Angular, makes it Angular, and sets its' Angle based on its' Dir.\n\n<h3>void MakeDirectional();</h3>\nIf the weapon is Angular, makes it not Angular, and sets its' Dir based on its' Angle.\n\n<h3>float Vx;\nfloat Vy;</h3>\nThe velocity on the X or Y axis. Setting these will make the weapon Angular if it isn't already, and will adjust the weapon's Angle and Step speed.\n\n<h3>bool Animation;</h3>\nIf the engine should animate the weapon's graphics.\n\n\n"
                        },
                        {
                            "name": "Position ;; lweapon::X / eweapon::X / lweapon::Y / eweapon::Y / lweapon::Z / eweapon::Z / lweapon::Jump / eweapon::Jump / lweapon::Gravity / eweapon::Gravity / lweapon::MoveFlags / eweapon::MoveFlags / lweapon::FakeZ / eweapon::FakeZ / lweapon::FakeJump / eweapon::FakeJump",
                            "val": "<h3>int X; int Y; int Z;</h3>\n\nRead/Write; These values store the weapon's position on each of the three axes.\nIf the ${QRS|quest rule} `Sprite Coordinates are Float` is checked, these values can include up to 4 decimal places; otherwise values are truncated.\n\n<h3>int Jump;</h3>\nThe weapon's upward velocity, in pixels per frame. Affected by gravity each frame, if gravity is enabled for this weapon.\n\n<h3>bool Gravity;</h3>\nTrue by default. If false, gravity will no longer affect this weapon.\n\n<h3>bool MoveFlags[];</h3>\nThe movement flags of the weapon. See `WPNMV_` constants.\n#{WPNMV_ constants|$[WPNMV_]}\n<h3>int FakeZ;</h3>\nThe position of the weapon on the FakeZ axis.\n\n<h3>int FakeJump;</h3>\nThe velocity of the weapon in the FakeZ axis.\n\n\n\n\n\n"
                        },
                        {
                            "name": "Sprite Limit ;; lweapon::Max / eweapon::Max",
                            "val": "<h3>int Max();</h3>\nReturns the max number of weapons currently allowed.\n\n<h3>void Max(int newmax);</h3>\nSets the max number of weapons allowed to a new value. Range `1-1024`.\n"
                        },
                        {
                            "name": "Graphical Info ;; lweapon::OriginalTile / eweapon::OriginalTile / lweapon::Tile / eweapon::Tile / lweapon::OriginalCSet / eweapon::OriginalCSet / lweapon::CSet / eweapon::CSet / lweapon::NumFrames / eweapon::NumFrames / lweapon::Frame / eweapon::Frame / lweapon::ASpeed / eweapon::ASpeed / lweapon::Flash / eweapon::Flash / lweapon::FlashCSet / eweapon::FlashCSet / lweapon::Flip / eweapon::Flip / lweapon::UseSprite / eweapon::UseSprite / lweapon::Sprites[] / eweapon::Sprites[]",
                            "val": "<h3>int OriginalTile;</h3>\nThe starting tile of the weapon's animation.\n\n<h3>int Tile;</h3>\nThe currently displaying tile of the weapon's animation. Set by the engine each frame if ${lweapon::Animation|animation} is enabled.\n\n<h3>int OriginalCSet;</h3>\nThe starting cset of the weapon.\n\n<h3>int CSet;</h3>\nThe CSet of the weapon.\n\n<h3>int NumFrames;</h3>\nThe number of frames in the weapon's animation.\n\n<h3>int Frame;</h3>\nThe current frame number that the animation is on.\n\n<h3>int ASpeed;</h3>\nThe speed of the animation, in frames per frame.\n\n<h3>bool Flash;</h3>\nIf the weapon is flashing or not. When flashing, it changes between its' CSet and FlashCSet.\n\n<h3>int FlashCSet;</h3>\nThe secondary CSet used for flashing.\n\n<h3>int Flip;</h3>\nThe flip status of the weapon's tile. Uses the [[`FLIP_`|$FLIP_]] constants.\n\n<h3>void UseSprite(int spriteid);</h3>\nLoads the graphical information from the ${spritedata} indicated by `spriteid` to the weapon.\n\n<h3>int Sprites[WPN_SPRITE_MAX];</h3>\nVarious sprites used by the weapon."
                        },
                        {
                            "name": "Graphical Info 2 ;; lweapon::ScriptTile / eweapon::ScriptTile / lweapon::ScriptFlip / eweapon::ScriptFlip / lweapon::ShadowXOffset / eweapon::ShadowXOffset / lweapon::ShadowYOffset / eweapon::ShadowYOffset / lweapon::ShadowSprite / eweapon::ShadowSprite / lweapon::DrawStyle / eweapon::DrawStyle / lweapon::Rotation / eweapon::Rotation / lweapon::Scale / eweapon::Scale / lweapon::AutoRotate / eweapon::AutoRotate / lweapon::LightShape / eweapon::LightShape / lweapon::LightRadius / eweapon::LightRadius",
                            "val": "<h3>int ScriptTile;</h3>\n-1 by default. If this is set > -1, this tile will be displayed by the engine, regardless of the normal engine animation. Set back to -1 to restore engine animation.\n\n<h3>int ScriptFlip;</h3>\n-1 by default. If this is set > -1, this flip value will be used instead of the normal 'Flip' value. Set back to -1 to restore normal flip.\n\n<h3>int ShadowXOffset;\nint ShadowYOffset;</h3>\nThe x/y offset of the sprite's shadow.\n\n<h3>int ShadowSprite;</h3>\nThe ${spritedata} sprite ID to use for the item's shadow.\n\n<h3>int DrawStyle;</h3>\nThe mode for the sprite's draws, using the `DS_` constants.\n#{DS_ constants|$[DS_]}\n<h3>float Rotation;</h3>\nA rotation of the sprite draw, in degrees.\n\n<h3>float Scale;</h3>\nA scale of the sprite draw, as a multiplier.\n\n<h3>bool AutoRotate;</h3>\nIf true, the weapon's 'Rotation' will be automatically set based on its' Angle.\n\n<h3>int LightShape;</h3>\nThe shape of light emitted by this sprite. Uses the `LIGHT_` constants.\n#{LIGHT_ constants|$[LIGHT_]}\n<h3>int LightRadius;</h3>\nThe size of the light emitted by this sprite, in pixels.\n\n"
                        },
                        {
                            "name": "Next -&gt; ;; weaponptr2",
                            "val": "$-1$1"
                        }
                    ]
                },
                {
                    "name": "Weapon 2",
                    "lines": [
                        {
                            "name": "&lt;-- Sprite Pointers ;; function_data_sprite",
                            "val": "$Base Data$5"
                        },
                        {
                            "name": "Size Info ;; lweapon::Extend / eweapon::Extend / lweapon::HitWidth / eweapon::HitWidth / lweapon::HitHeight / eweapon::HitHeight / lweapon::HitZHeight / eweapon::HitZHeight / lweapon::TileWidth / eweapon::TileWidth / lweapon::TileHeight / eweapon::TileHeight / lweapon::DrawXOffset / eweapon::DrawXOffset / lweapon::DrawYOffset / eweapon::DrawYOffset / lweapon::TotalDYOffset / eweapon::TotalDYOffset / lweapon::DrawZOffset / eweapon::DrawZOffset / lweapon::HitXOffset / eweapon::HitXOffset / lweapon::HitYOffset / eweapon::HitYOffset",
                            "val": "<h3>int Extend;</h3>\nIf the sprite should be extended (large). Set to 3 to extend, 0 otherwise.\n\n<h3>int HitWidth;\nint HitHeight;</h3>\nThe width/height of the hitbox, in pixels.\n\n<h3>int HitZHeight;</h3>\nThe height of the hitbox in the Z-axis, in pixels.\n\n<h3>int TileWidth;\nint TileHeight;</h3>\nThe width/height of the sprite's graphic, in tiles.\n\n<h3>int DrawXOffset;\nint DrawYOffset;</h3>\nThe visual offset, in pixels.\n\n<h3>int TotalDYOffset;</h3>\nRead-only, the weapon's total visual Y-offset.\n\n<h3>int DrawZOffset;</h3>\nThe Z offset, in pixels.\n\n<h3>int HitXOffset;\nint HitYOffset;</h3>\nThe hitbox offset, in pixels.\n\n\n"
                        },
                        {
                            "name": "Script Info ;; lweapon::Script / eweapon::Script / lweapon::InitD / eweapon::InitD / lweapon::Misc / eweapon::Misc",
                            "val": "<h3>int Script;</h3>\nThe weapon script running on this weapon.\n\n<h3>int InitD[8];</h3>\nThe 8 InitD[] arguments for the weapon script.\n\n<h3>int Misc[32];</h3>\nAn array of misc values for script use.\n\n"
                        },
                        {
                            "name": "Status ;; lweapon::Falling / eweapon::Falling / lweapon::FallCombo / eweapon::FallCombo / lweapon::Drowning / eweapon::Drowning / lweapon::DrownCombo / eweapon::DrownCombo / lweapon::SwitchHooked / eweapon::SwitchHooked / lweapon::Switch / eweapon::Switch / lweapon::Timeout / eweapon::Timeout",
                            "val": "<h3>int Timeout;</h3>\nIf > 0, ticks down each frame. When ticking down to 0, kills the weapon.\n\n<h3>int Falling;</h3>\nThe timer indicating how long left the sprite will be falling. If 0, the sprite is not falling. Max value of 70, which is the value at the start of falling.\n\n<h3>int FallCombo;</h3>\nThe pitfall combo the sprite is falling into, if it is falling.\n\n<h3>int Drowning;</h3>\nThe timer indicating how long left the sprite will be drowning. If 0, the sprite is not drowning. Max value of 64, which is the value at the start of drowning.\n\n<h3>int DrownCombo;</h3>\nThe liquid combo the sprite is drowning in, if it is drowning.\n\n<h3>bool SwitchHooked;</h3>\nIf the sprite is currently being switch-hooked.\n\n<h3>bool Switch(int effect);</h3>\nSwitch the player with this sprite. Use the `SW_EFF_` constants for 'effect' to select a visual style for the switch.\nReturns true if it succeeds, and false otherwise."
                        },
                        {
                            "name": "Misc Info ;; lweapon::Explode / eweapon::Explode / lweapon::Remove / eweapon::Remove / lweapon::DeadState / eweapon::DeadState / lweapon::Step / eweapon::Step / lweapon::Power / eweapon::Power / lweapon::Damage / eweapon::Damage / lweapon::Behind / eweapon::Behind / lweapon::Unblockable / eweapon::Unblockable / lweapon::CollDetection / eweapon::CollDetection / lweapon::Flags / eweapon::Flags",
                            "val": "<h3>void Explode(int mode);</h3>\nCreates an explosion particle effect in mode 0, 1, or 2 of the sprite.\n\n<h3>void Remove();</h3>\nInstantly deletes the weapon.\n\n<h3>int DeadState;</h3>\nThe deadstate of the weapon, denoted by the `WDS_` constants.\n\n<h3>int Step;</h3>\nThe movement speed of the weapon, in 100th's/pixel per frame.\n\n<h3>int Power;\nint Damage;</h3>\nThe amount of damage the weapon deals.\n\n<h3>bool Behind;</h3>\nIf true, the weapon's sprite will draw behind the player and enemies.\n\n<h3>int Unblockable;</h3>\nA bitwise flagset of unblockable flags, using the `UNBLOCK_` constants.\n#{UNBLOCK_ constants|$[UNBLOCK_]}\n<h3>bool CollDetection;</h3>\nIf the weapon's collision is enabled. Set to false to disable collision entirely.\n\n<h3>bool Flags[WFLAG_MAX];</h3>\nA set of weapon flags. Use the `WFLAG_` constants as indexes.\n#{WFLAG_ constants|$[WFLAG_]}"
                        },
                        {
                            "name": "Owning ;; lweapon::Own / lweapon::OwnArray / lweapon::OwnObject / eweapon::Own / eweapon::OwnArray / eweapon::OwnObject",
                            "val": "<h3>void Own(bitmap b);\nvoid Own(paldata pd);\nvoid Own(stack st);\nvoid Own(file f);\nvoid Own(directory dir);\nvoid Own(randgen rnd);\nvoid OwnArray(untyped[] array);\nvoid OwnObject([Object] object);</h3>\n\nGrants 'Ownership' of the parameter object to the weapon."
                        },
                        {
                            "name": "Death and Lifting ;; lweapon::DeathItem / lweapon::DeathDropset / lweapon::DeathItemPFlags / lweapon::DeathSprite / lweapon::DeathSFX / lweapon::LiftLevel / lweapon::LiftTime / lweapon::LiftHeight / eweapon::DeathItem / eweapon::DeathDropset / eweapon::DeathItemPFlags / eweapon::DeathSprite / eweapon::DeathSFX / eweapon::LiftLevel / eweapon::LiftTime / eweapon::LiftHeight",
                            "val": "<h3>int DeathItem;</h3>\nIf `&gt; -1`, this item will be spawned when the weapon dies.\n\n<h3>int DeathDropset;</h3>\nIf `&gt; -1`, this item dropset will be rolled for a drop when the weapon dies.\n\n<h3>int DeathItemPFlags;</h3>\nThe ${itemsprite::Pickup|Pickup Flags} to use for the item dropped via `DeathItem` or `DeathDropset`.\n\n<h3>int DeathSprite;</h3>\nIf `&gt; -1`, display this Sprite Data sprite when the weapon dies.\nSet to `-2 == Bush Clippings`, `-3 == Flower Clippings`, or `-4 == Grass Clippings` to display a clippings sprite when the weapon dies.\n\n<h3>int DeathSFX;</h3>\nIf `&gt; 0`, this SFX will be played when the weapon dies.\n\n<h3>int LiftLevel;</h3>\nNOTE: Currently only `lweapon`s can be lifted.\nIf this is `0`, the weapon cannot be lifted.\nIf this is `&gt; 0`, this weapon can be lifted by any lift glove with a level `&gt;= LiftLevel`.\n\n<h3>int LiftTime;</h3>\nThe time it takes to lift this weapon via engine lifting.\n\n<h3>int LiftHeight;</h3>\nThe height to lift this weapon to via engine lifting."
                        },
                        {
                            "name": "&lt;-- Prev ;; weaponptr",
                            "val": "$-1"
                        }
                    ]
                }
            ]
        },
        {
            "name": "Combodata",
            "tabs": [
                {
                    "name": "0",
                    "lines": [
                        {
                            "name": "&lt;-- Misc Data Pointers ;; function_data_misc",
                            "val": "$0$6"
                        },
                        {
                            "name": "<em>combodata</em>",
                            "val": "<h3>ComboData Pointers</h3>   `combodata`\n\nThese pointers represent a combo ID, and all its' associated attributes.\n\nSee: ${Game::LoadComboData|LoadComboData}"
                        },
                        {
                            "name": "ID ;; combodata::ID",
                            "val": "<h3>int ID;</h3>\nRead-only, the combo ID this combodata points to."
                        },
                        {
                            "name": "Script Data ;; combodata::InitD / combodata::Script",
                            "val": "<h3>int Script;</h3>\nThe combo script that this combo runs.\n\n<h3>untyped InitD[2];</h3>\nThe 2 InitD[] values for the combo script."
                        },
                        {
                            "name": "Graphics ;; combodata::Tile / combodata::OriginalTile / combodata::Frame / combodata::AClk / combodata::ASpeed / combodata::Frames / combodata::Flip / combodata::CSet2 / combodata::CSet2Flags / combodata::SkipAnimX / combodata::SkipAnimY / combodata::AnimFlags",
                            "val": "<h3>int Tile;</h3>\nThe tile currently being displayed by the combo. This is automatically overwritten each frame by the engine.\n\n<h3>int Frame;</h3>\nThe current animation frame the combo is on in its' animation. Set to 0 to reset to start of animation.\n\n<h3>int AClk;</h3>\nThe animation clock of the combo. Set to 0 to reset the timer.\n\n<h3>int OriginalTile;</h3>\nThe 'Original Tile' of the combo, used as the start of its' animation.\n\n<h3>int Frames;</h3>\nThe number of frames in the combo animation before it loops.\n\n<h3>int ASpeed;</h3>\nThe combo animation speed.\n\n<h3>int SkipAnimX;</h3>\nThe number of extra tiles to move horizontally between each frame.\n\n<h3>int SkipAnimY;</h3>\nThe number of extra tiles to move vertically, when the horizontal movement goes past the end of a tile row.\n\n<h3>int AnimFlags;</h3>\nBitwise access to the combo's animation flags. Use the [[`AF_` constants|$AF_]] to access.\n\n<h3>int Flip;</h3>\nThe combo's flip value. Use the `FLIP_` or `ROT_` constants from `std_constants.zh` for this value.\n\n<h3>int CSet2;</h3>\nThe CSet2 offset for this combo.\n\n<h3>int CSet2Flags;</h3>\nBitwise access to the 4 corners of the cset2 square. <todo>Untested!</todo>"
                        },
                        {
                            "name": "Script-Specific ;; combodata::X / combodata::Y / combodata::Pos / combodata::Layer",
                            "val": "These attributes are ONLY usable on the `this` pointer in a `combodata script`.\n\n<h3>int X;\nint Y;\nint Layer;\nint Pos;</h3>\nRead-only. Gives the X, Y, Layer, and Combo Pos of the combo running this script."
                        },
                        {
                            "name": "Effects ;; combodata::Walk / combodata::Effect / combodata::Type / combodata::Flag",
                            "val": "<h3>int Walk;</h3>\nThe solidity bitmask of the combo (same as ${Screen::ComboS[]|Screen-&gt;ComboS[]})\n\n<h3>int Effect;</h3>\nThe effect bitmask of the combo (same as ${Screen::ComboE[]|Screen-&gt;ComboE[]})\n\n<h3>int Type;</h3>\nThe ${combotypes|combo type} of the combo. Use the `CT_` constants from `std_constants.zh`.\n\n<h3>int Flag;</h3>\nThe ${mapflags|inherent flag} of the combo. Use the `CF_` constants from `std_constants.zh`."
                        },
                        {
                            "name": "Cycling ;; combodata::NextData / combodata::NextCSet",
                            "val": "<h3>int NextData;</h3>\nIf `&gt; 0`, cycling is enabled for this combo. When the combo's animation would normally loop, instead the combo will change to the `NextData` combo.\n\n<h3>int NextCSet;</h3>\nIf the ${combodata::AnimFlags|animation flag} `AF_CYCLENOCSET` is NOT set, the combo will change to this cset when it cycles."
                        },
                        {
                            "name": "Attributes / Flags ;; combodata::Attributes / combodata::Attrishorts / combodata::Attribytes / combodata::Flags / combodata::GenFlags",
                            "val": "<h3>untyped Attribytes[8];</h3>\nThe 8 combo attribytes. These have a byte-sized range, `0 to 255`. Their effect depends on the combo type.\n\n<h3>untyped Attrishorts[8];</h3>\nThe 8 combo attrishorts. These have a short-sized range, `-32768 to 32767`. Their effect depends on the combo type.\n\n<h3>untyped Attributes[4];</h3>\nThe 4 combo attributes. These have a full range (all zscript values, including decimal). Their effect depends on the combo type.\n\n<h3>bool Flags[16];</h3>\nThe 16 combo flags. Their effect depends on the combo type.\n\n<h3>bool GenFlags[];</h3>\nThe combo generic flags, specified by the [[`GENFLAG_` constants|$GENFLAG_]]."
                        },
                        {
                            "name": "Combo Triggers ;; combodata::TrigCSetChange / combodata::TrigSpawnItem / combodata::TrigSpawnEnemy / combodata::TrigExState / combodata::TrigExDoorDir / combodata::TrigExDoorIndex / combodata::TrigSpawnItemPickup / combodata::TrigCopycat / combodata::TrigCooldown / combodata::TrigCtrAmount / combodata::TrigCounter / combodata::TrigLightBeam / combodata::TrigProximity / combodata::TrigChange / combodata::TrigSFX / combodata::TrigTimer / combodata::TrigItem / combodata::TrigLevel / combodata::TrigButton[] / combodata::TrigFlags[] / combodata::TrigLevelState / combodata::TrigGlobalState / combodata::TrigGStateTimer / combodata::TrigGroup / combodata::TrigGroupVal / combodata::TrigGenScript / combodata::TriggerCSetChange / combodata::TriggerSpawnItem / combodata::TriggerSpawnEnemy / combodata::TriggerExState / combodata::TriggerExDoorDir / combodata::TriggerExDoorIndex / combodata::TriggerSpawnItemPickup / combodata::TriggerCopycat / combodata::TriggerCooldown / combodata::TriggerCtrAmount / combodata::TriggerCounter / combodata::TriggerLightBeam / combodata::TriggerProximity / combodata::TriggerChange / combodata::TriggerSFX / combodata::TriggerTimer / combodata::TriggerItem / combodata::TriggerLevel / combodata::TriggerButton[] / combodata::TriggerFlags[] / combodata::TriggerLevelState / combodata::TriggerGlobalState / combodata::TriggerGStateTimer / combodata::TriggerGroup / combodata::TriggerGroupVal / combodata::TriggerGenScript",
                            "val": "Using 'Trigger' instead of 'Trig' in the names of these commands also works.\n\n<h3>bool TrigFlags[];</h3>\nThe combo's Trigger Flags, accessed with the `TRIGFLAG_` constants.\n#{TRIGFLAG_ constants|$[TRIGFLAG_]}\n\n<h3>bool TrigButton[];</h3>\n[[Which buttons|$INTBTN_]] will trigger this combo (Which directions this works from is determined by `TRIGFLAG_BTN_` triggerflags)\n\n<h3>int TrigLevel;</h3>\nThe min level (or max, if `TRIGFLAG_INVERT_MIN_MAX` is set) of Weapon that can trigger this combo.\n\n<h3>int TrigItem;</h3>\nNote: This is a [[$Trigger Requirement]], not a trigger.\nThe required item ID for triggering the combo. If `0`, no item is required.\nIf `TRIGFLAG_INVERT_ITEMREQ` is set, the item must NOT be owned to trigger instead.\nIf `TRIGFLAG_CONSUME_ITEMREQ` is set, the item will be consumed upon triggering.\n\n<h3>int TrigTimer;</h3>\nThe trigger timer. If `&gt; 0`, the combo triggers every this many frames.\n\n<h3>int TrigSFX;</h3>\nThe SFX to play when triggering the combo.\n\n<h3>int TrigChange;</h3>\nThe amount the combo will change by when triggered.\n\n<h3>int TrigCSetChange;</h3>\nThe amount the cset will change by when triggered.\n\n<h3>int TrigProximity;</h3>\nNote: This is a [[$Trigger Requirement]], not a trigger.\nThe combo will only trigger if the player's distance from the combo is `&lt;=` this distance.\nIf 0, proximity requirement is disabled.\nIf `TRIGFLAG_INVERT_PROXIMITY` is set, the player's distance must be `&gt;` this distance instead.\n\n<h3>int TrigLightBeam;</h3>\nThe light beam ID that this combo interacts with. 0 interacts with all beams, 1 to 32 interact only with matching beams.\nThis only has any effect if `TRIGFLAG_LIGHTON` or `TRIGFLAG_LIGHTOFF` is set.\n\n<h3>int TrigCounter;</h3>\nThe counter used for counter-based trigger flags.\n<h3>int TriggerCtrAmount;</h3>\nThe counter amount used for counter-based trigger flags.\n\n<h3>int TrigCooldown;</h3>\nThe combo (assuming it does not change on trigger) will be unable to trigger again for this many frames after triggering.\n\n<h3>int TrigCopycat;</h3>\nIf `&gt; 0`, when this combo is triggered, it will trigger all other combos on screen with the same `TrigCopycat` value.\n\n<h3>int TrigExState;</h3>\nIf `&gt; -1`, the ExState this combo is linked to.\n<h3>int TrigExDoorDir;</h3>\n * If `&gt; -1`, the direction of ExDoor that the combo is linked to\n<h3>int TrigExDoorIndex;</h3>\n * If `TrigExDoorDir` is `&gt; -1`, the index of that direction of ExDoor that the combo is linked to.\n\n<h3>int TrigSpawnEnemy;</h3>\nIf `&gt; 0`, this enemy ID will be spawned when the combo triggers.\n\n<h3>int TrigSpawnItem;</h3>\nIf `&gt; 0`, this item ID will be spawned when the combo triggers.\nIf `&lt; 0`, an item from this dropset ID will be chosen to be spawned when the combo triggers.\n\n<h3>int TrigSpawnItemPickup;</h3>\nThe `-&gt;Pickup` flags for the spawned item.\nOnly `IP_HOLDUP`, `IP_TIMEOUT`, `IP_TRIGGERSECRETS`, and `IP_ALWAYSGRAB` are valid.\n\n<h3>int TrigLevelState;</h3>\nThe LevelState used for the `TRIGFLAG_TRIGLEVELSTATE` and `TRIGFLAG_LEVELSTATE` flags. 0-31, inclusive.\n\n<h3>int TrigGlobalState;</h3>\nThe GlobalState used for the `TRIGFLAG_TRIGGLOBALSTATE` and `TRIGFLAG_GLOBALSTATE` flags. 0-255, inclusive.\n\n<h3>int TrigGStateTimer;</h3>\nIf `&gt; 0`,  the global trigger caused by `TRIGFLAG_GLOBALSTATE` will set to the 'on' state with this value as a timer in frames. If this value is 0, it instead toggles the state as normal.\n\n<h3>int TrigGroup;</h3>\nThe TrigGroup used for the `TRIGFLAG_TGROUP_CONTRIB`, `TRIGFLAG_TGROUP_LESS`, and `TRIGFLAG_TGROUP_GREATER` flags. 0-255, inclusive.\n\n<h3>int TrigGroupVal;</h3>\nThe value used for the `TRIGFLAG_TGROUP_LESS` and `TRIGFLAG_TGROUP_GREATER` flags. 0-65535, inclusive.\n\n<h3>int TrigGenScript;</h3>\nIf `&gt; 0`, the specified ${genericdata|generic script} will be run in the ${genericdata::RunFrozen|RunFrozen} mode."
                        },
                        {
                            "name": "Lifting ;; combodata::LiftTime / combodata::LiftHeight / combodata::LiftBreakSFX / combodata::LiftBreakSprite / combodata::LiftSFX / combodata::LiftGFXSprite / combodata::LiftGFXType / combodata::LiftFlags[] / combodata::LiftItem / combodata::LiftLevel / combodata::LiftDamage / combodata::LiftUnderCSet / combodata::LiftUnderCombo / combodata::LiftGFXCSet / combodata::LiftGFXCombo / combodata::LiftWeaponItem",
                            "val": "<h3>int LiftGFXType;</h3>\nWhat GFX to use to display the lifted object.\n#{LIFTGFX_ constants|$[LIFTGFX_]}\n\n<h3>int LiftGFXCombo;\nint LiftGFXCSet;</h3>\nThe GFX combo/cset used to display the object, if 'Other Combo GFX' is the GFX mode.\nThe combo's CSet is used instead if `LF_NOWPNCMBCSET` is set.\n\n<h3>int LiftGFXSprite;</h3>\nThe GFX sprite used to display the object, if 'Sprite Data GFX' is the GFX mode.\n\n<h3>int LiftBreakSprite;</h3>\nThe Sprite Data sprite displayed when the object breaks.\n\n<h3>int LiftUnderCombo;\nint LiftUnderCSet;</h3>\nThe combo/cset that will be left behind when this combo is lifted.\nIf `LF_NOUCSET` is set, the undercset will not be used, instead leaving the combo's cset.\n\n<h3>int LiftDamage;</h3>\nThe weapon damage of the thrown object.\n\n<h3>int LiftLevel;</h3>\nThe minimum lift glove level required to lift this object.\n\n<h3>int LiftItem;</h3>\nIf `&gt; 0`, drops this item ID.\nDrops the item upon breaking, unless `LF_DROPONLIFT` is set, in which case it drops upon lifting.\nIf `LF_DROPSET` is set, this number is a dropset to choose an item from, instead of an item ID.\nIf `LF_SPECIALITEM` is set, this item is treated as the room's Special Item.\n\n<h3>int LiftSFX;</h3>\nThe SFX played on lifting.\n<h3>int LiftBreakSFX;</h3>\nThe SFX played on breaking.\n\n<h3>int LiftHeight;</h3>\nThe height above the player's head to lift the object.\n\n<h3>int LiftTime;</h3>\nThe number of frames it takes to lift the object to its' full height.\n\n<h3>int LiftFlags[];</h3>\nThe combo lift flags.\n#{LF_ constants|$[LF_]}\n\n<h3>int LiftWeaponItem;</h3>\nIf >0, the weapon will behave specially based on the provided item ID.\nFor bombs / super bombs, a matching LW_BOMB/LW_SBOMB is created.\nOther item types have no effect at this time."
                        }
                    ]
                }
            ]
        },
        {
            "name": "DMapData",
            "tabs": [
                {
                    "name": "DMapData ROOT",
                    "lines": [
                        {
                            "name": "&lt;-- Misc Data Pointers ;; function_data_misc",
                            "val": "$0$6"
                        },
                        {
                            "name": "<em>dmapdata</em> ;; dmapdata",
                            "val": "<h3>DMapData Pointers</h3>   `dmapdata`\n\nThese pointers represent a dmap and all its' associated attributes.\n\nSee: ${Game::LoadDMapData|LoadDMapData}"
                        },
                        {
                            "name": "DMap Strings ;; dmapdata::GetName / dmapdata::SetName / dmapdata::GetTitle / dmapdata::SetTitle / dmapdata::IntroStringID / dmapdata::GetIntro / dmapdata::SetIntro / dmapdata::GetMusic / dmapdata::SetMusic",
                            "val": "<h3>void GetName([[char32[] buf|At least size 21]]);</h3>\nFills the buffer with the dmap's name.\n<h3>void SetName([[char32[] buf|At most 20 characters]]);</h3>\nSets the DMap's name to the buffer contents.\n\n<h3>void GetTitle(char32[] buf);</h3>\nFills the buffer with the dmap's title.\nIf the rule 'Old DMap Titles and Intros' is on, will resize the buffer to the length of the title string.\n<h3>void SetTitle(char32[] buf);</h3>\nSets the DMap's title to the buffer contents.\n\n<h3>int IntroStringID;</h3>\nThe ID in the string editor for the dmap's intro string.\nIf the quest rule 'Old DMap Titles and Intros' is on, this is unused.\n\n<h3>void GetIntro([[char32[] buf|At least size 73]]);</h3>\nFills the buffer with the dmap's intro.\nIf the quest rule 'Old DMap Titles and Intros' is off, this is unused.\n<h3>void SetIntro([[char32[] buf|At most 72 characters]]);</h3>\nSets the DMap's intro to the buffer contents.\nIf the quest rule 'Old DMap Titles and Intros' is off, this is unused.\n\n<h3>void GetMusic([[char32[] buf|At least size 56]]);</h3>\nFills the buffer with the dmap's enhanced music filename. See ${dmapdata::MusicTrack|MusicTrack}.\n<h3>void SetMusic([[char32[] buf|At most 55 characters]]);</h3>\nSets the DMap's enhanced music filename to the buffer contents. See ${dmapdata::MusicTrack|MusicTrack}."
                        },
                        {
                            "name": "Basic Info ;; dmapdata::ID / dmapdata::Map / dmapdata::Level / dmapdata::Compass / dmapdata::Continue / dmapdata::Offset / dmapdata::Type / dmapdata::Palette",
                            "val": "<h3>int ID;</h3>\nRead-Only. The DMap's ID number.\n\n<h3>int Map;</h3>\nWhich map this DMap is associated with.\n\n<h3>int Level;</h3>\nThe Level Number of this dmap.\n\n<h3>int Compass;\nint Continue;</h3>\nThe compass marker and continue screen numbers.\n\n<h3>int Offset;</h3>\nThe DMap offset.\n\n<h3>int Type;</h3>\nThe type of the dmap, using the [[`DMAP_`|$DMAP_]] constants.\n\n<h3>int Palette;</h3>\nThe level palette to use for this DMap"
                        },
                        {
                            "name": "Music ;; dmapdata::MIDI / dmapdata::MusicTrack / dmapdata::MusicLoopStart / dmapdata::MusicLoopEnd / dmapdata::MusicCrossfadeIn / dmapdata::MusicCrossfadeOut",
                            "val": "<h3>int MIDI;</h3>\nThe MIDI set to play on this dmap.\n\n<h3>int MusicTrack;</h3>\nThe track number to use for enhanced music. See ${dmapdata::GetMusic|GetMusic/SetMusic}.\n\n<h3>int MusicLoopStart;</h3>\nThe starting loop point for enhanced music in seconds.\n\n<h3>int MusicLoopEnd;</h3>\nThe ending loop point for enhanced music in seconds.\n\n<h3>int MusicCrossfadeIn;</h3>\nThe number of frames enhanced music fades in for.\n\n<h3>int MusicCrossfadeOut;</h3>\nThe number of frames enhanced music fades out for."
                        },
                        {
                            "name": "Active Script ;; dmapdata::Script / dmapdata::InitD",
                            "val": "<h3>int Script;</h3>\nThe dmapdata script to run on this dmap.\n\n<h3>untyped InitD[8];</h3>\nThe 8 InitD values for the active dmap script."
                        },
                        {
                            "name": "--&gt; Next ;; dmapdata2",
                            "val": "$-1$1"
                        }
                    ]
                },
                {
                    "name": "DMapData 2",
                    "lines": [
                        {
                            "name": "&lt;-- Misc Data Pointers ;; function_data_misc",
                            "val": "$0$6"
                        },
                        {
                            "name": "Subscreens ;; dmapdata::ActiveSubscreen / dmapdata::PassiveSubscreen / dmapdata::OverlaySubscreen / dmapdata::ASubScript / dmapdata::PSubScript / dmapdata::SubInitD",
                            "val": "<h3>int ActiveSubscreen;</h3>\nWhich engine active subscreen to use on this dmap.\n\n<h3>int PassiveSubscreen;</h3>\nWhich engine passive subscreen to use on this dmap.\n\n<h3>int OverlaySubscreen;</h3>\nWhich engine overlay subscreen to use on this dmap.\n\n<h3>int ASubScript;</h3>\nWhich dmapdata script to use as a replacement for the engine active subscreen (0 for none).\n\n<h3>int PSubScript;</h3>\nWhich dmapdata script to run for passive subscreen draws.\n\n<h3>untyped SubInitD[8];</h3>\nThe 8 InitD values shared by the Active and Passive Subscreen Scripts."
                        },
                        {
                            "name": "Map Script ;; dmapdata::MapScript / dmapdata::MapInitD",
                            "val": "<h3>int MapScript;</h3>\nWhich dmapdata script to use as a replacement for the engine fullscreen map (0 for none).\n\n<h3>untyped MapInitD[8];</h3>\nThe 8 InitD values used by the Map Script."
                        },
                        {
                            "name": "Subscreen Maps ;; dmapdata::Grid / dmapdata::Charted / dmapdata::MapTile / dmapdata::MapCSet / dmapdata::MiniMapTile / dmapdata::MiniMapCSet",
                            "val": "<h3>int Grid[8];</h3>\nBitwise values representing the state of the map grid. Make use of the functions in `std_zh/dmapgrid.zh` to access these values.\n\n<h3>int Charted[128];</h3>\nStores the large map exploration data for each screen on the dmap. <todo>Test if works on overworld dmaps.</todo>\nData is stored in a bitwise format. Access each index using the [[`CHRT_`|$CHRT_]] constants\n\n<h3>int MapTile[2];</h3>\nThe tile used for the engine subscreen Large Map. The [0] index tile is used without the dungeon map, and the [1] index with the dungeon map.\nIf a tile is '0', the default background is used. <todo>What's the default here?</todo>\n\n<h3>int MapCSet[2];</h3>\nThe csets used for the engine subscreen Large Map, to go along with the MapTile[].\n\n<h3>int MiniMapTile[2];</h3>\nThe tile used for the engine subscreen Small Map. The [0] index tile is used without the dungeon map, and the [1] index with the dungeon map.\nIf a tile is '0', the default background is used. The default is set in 'Graphics->Map Styles' in ZQuest.\n\n<h3>int MiniMapCSet[2];</h3>\nThe csets used for the engine subscreen Small Map, to go along with the MiniMapTile[].\n"
                        },
                        {
                            "name": "Items ;; dmapdata::DisabledItems / dmapdata::MirrorDMap",
                            "val": "<h3>bool DisabledItems[NUM_ITEMDATA];</h3>\nIf each item on the dmap is disabled.\n\n<h3>int MirrorDMap;</h3>\nThe DMap ID that using a Mirror will take you to. If this is '-1', Mirrors will not be able to warp you to another dmap. If the ${dmapdata::Flagset|flag} 'Mirror Continues instead of Warping' is set, the mirror dmap setting is not used."
                        },
                        {
                            "name": "Flags ;; dmapdata::Sideview / dmapdata::Flagset",
                            "val": "<h3>bool Sideview;</h3>\nIf true, the dmap is treated as sideview by default; screens with the sideview flag enabled will toggle sideview back *off*.\n\n<h3>bool Flagset[DMFS_MAX];</h3>\nThe flags for the dmap. Uses the `DMFS_` constants.\n#{DMFS_ constants|$[DMFS_]}"
                        },
                        {
                            "name": "&lt;-- Prev ;; dmapdataptr",
                            "val": "$-1"
                        }
                    ]
                }
            ]
        },
        {
            "name": "Itemdata",
            "tabs": [
                {
                    "name": "Itemdata ROOT",
                    "lines": [
                        {
                            "name": "&lt;-- Misc Data Pointers ;; function_data_misc",
                            "val": "$0$6"
                        },
                        {
                            "name": "<em>itemdata</em> ;; itemdata",
                            "val": "<h3>ItemData Pointers</h3>   `itemdata`\n\nThese pointers represent an inventory item and all its' associated attributes.\n\nSee: ${Game::LoadItemData|LoadItemData}"
                        },
                        {
                            "name": "Basic Info ;; itemdata::ID / itemdata::EquipmentItem / itemdata::Family / itemdata::Type / itemdata::Level / itemdata::Power / itemdata::Attributes / itemdata::GetName / itemdata::GetDisplayName / itemdata::SetDisplayName / itemdata::GetShownName",
                            "val": "<h3>int ID;</h3>\nRead-only, the item ID this itemdata is associated with.\n\n<h3>bool EquipmentItem;</h3>\nIf the item is an equipment item or not. Items which are not equipment items cannot be \"owned\" by the player or put on buttons.\n\n<h3>int Family;\nint Type;</h3>\nThe type ${itemclass|(itemclass)} of the item. Uses the `IC_` constants.\n\n<h3>int Level;</h3>\nThe level of the item.\n\n<h3>int Power;\nint Damage;</h3>\nThe item power. Usage depends on itemclass.\n\n<h3>untyped Attributes[10];</h3>\nThe 10 item attributes.\n\n<h3>void GetName(char32 buf[]);</h3>\nFills the buffer with the item's Name.\n\n<h3>void GetDisplayName([[char32 buf[]|256+ character buffer]]);</h3>\nFills the buffer with the item's Display Name.\n\n<h3>void SetDisplayName([[char32 buf[]|Max 255 characters]]);</h3>\nSets the item's Display Name to the contents of the buffer.\n\n<h3>void GetShownName([[char32 buf[]|256+ character buffer]]);</h3>\nFills the buffer with the name of the item as shown on the subscreen. This automatically handles display names, including special instances such as the contents of Bottles."
                        },
                        {
                            "name": "Pickup Info ;; itemdata::Amount / itemdata::Gradual / itemdata::Counter / itemdata::MaxIncrement / itemdata::Max / itemdata::PickupSound / itemdata::MinHearts / itemdata::KeepOld / itemdata::GainLower / itemdata::Combine / itemdata::PString / itemdata::PickupString / itemdata::PickupStringFlags",
                            "val": "<h3>int Amount;</h3>\nThe amount of the 'Counter' to increase when this item is picked up. Range `-9999 to 16383`.\n\n<h3>bool Gradual;</h3>\nThe 'Gradual' flag.\n\n<h3>int Counter;</h3>\nThe counter to increase when this item is picked up.\n\n<h3>int MaxIncrement;</h3>\nHow much to increase the max of the 'Counter' by\n\n<h3>int Max;</h3>\nThe '...But not above' field- the amount the max of 'Counter' will not be increased above.\n\n<h3>int PickupSound;</h3>\nThe sound to play when the item is picked up.\n\n<h3>int MinHearts;</h3>\nThe number of max hearts required to pick up the item.\n\n<h3>bool KeepOld;</h3>\nThe 'Keep Lower Level Items' flag\n\n<h3>bool GainLower;</h3>\nThe 'Gain All Lower Level Items' flag\n\n<h3>bool Combine;</h3>\nThe 'Upgrade When Collected Twice' flag\n\n<h3>int PString;\nint PickupString;</h3>\nThe message string to display upon picking up the item.\n\n<h3>int PickupStringFlags;</h3>\nThe flags associated with the pickup string, as bitwise flags. Use the `IPSTR_` constants to access this.\n\n"
                        },
                        {
                            "name": "Action Info ;; itemdata::UseSound / itemdata::UseSound2 / itemdata::Downgrade / itemdata::Cost / itemdata::Cost2 / itemdata::CostCounter / itemdata::CostCounter2 / itemdata::CostTimer / itemdata::CostTimer2 / itemdata::Validate / itemdata::Validate2",
                            "val": "<h3>int UseSound;</h3>\nThe item's usage sound. If/how this is used depends on itemclass.\n\n<h3>int UseSound2;</h3>\nThe item's second usage sound. If/how this is used depends on itemclass.\n\n<h3>bool Downgrade;</h3>\nThe 'Remove Item When Used' flag.\n\n<h3>int Cost;\nint Cost2;</h3>\nThe 'Use Cost'/'Use Cost 2' of the item.\n\n<h3>int CostCounter;\nint CostCounter2;</h3>\nThe counter for the 'Use Cost'/'Use Cost 2' of the item.\n\n<h3>int CostTimer;\nint CostTimer2;</h3>\nThe timer for the 'Use Cost'/'Use Cost 2' of the item.\n\n<h3>bool Validate;\nbool Validate2;</h3>\nThe 'Only Validate Cost'/'Only Validate Cost 2' checkboxes"
                        },
                        {
                            "name": "Script Info ;; itemdata::Script / itemdata::PScript / itemdata::SpriteScript / itemdata::InitD / itemdata::RunScript",
                            "val": "<h3>int Script;</h3>\nThe item's Action Script\n\n<h3>int PScript;</h3>\nThe item's Pickup Script\n\n<h3>int SpriteScript;</h3>\nThe item's ItemSprite Script\n\n<h3>untyped InitD[8];</h3>\nThe 8 InitD values shared by the item's Action, Pickup, and Sprite scripts.\n\n<h3>void RunScript(int mode = ISCR_RUN);</h3>\nRuns or ends the item script, depending on the mode:#{ISCR_ constants|$[ISCR_]}"
                        },
                        {
                            "name": "Weapon Script Info ;; itemdata::WeaponScript / itemdata::WeaponInitD",
                            "val": "<h3>int WeaponScript;</h3>\nThe item's lweapon script\n\n<h3>untyped WeaponInitD[8];</h3>\nThe 8 InitD values for the weapon script."
                        },
                        {
                            "name": "--&gt; Next ;; dmapdata2",
                            "val": "$-1$1"
                        }
                    ]
                },
                {
                    "name": "Itemdata 2",
                    "lines": [
                        {
                            "name": "&lt;-- Misc Data Pointers ;; function_data_misc",
                            "val": "$0$6"
                        },
                        {
                            "name": "Flags Info ;; itemdata::Flags / itemdata::Edible / itemdata::ConstantScript / itemdata::SideSwimDisabled / itemdata::BunnyUsable / itemdata::JinxImmune / itemdata::JinxSwapped",
                            "val": "<h3>bool Flags[16];</h3>\nThe 16 item flags. `Flags[0]` through `Flags[14]` change depending on the item type; `Flags[15]` is the `Constant Script` flag.\n\n<h3>bool Edible;</h3>\nThe `Can Be Eaten By Enemies` flag.\n\n<h3>bool ConstantScript;</h3>\nThe `Constant Script` flag.\n\n<h3>bool SideSwimDisabled;</h3>\nThe `Disabled In Sideview Water` flag.\n\n<h3>bool BunnyUsable;</h3>\nThe `Usable as a Bunny` flag.\n\n<h3>bool JinxImmune;</h3>\nThe `Immune to jinxes` flag.\n\n<h3>bool JinxSwapped;</h3>\nThe `Uses Other Jinx` flag."
                        },
                        {
                            "name": "Pickup Flags ;; itemdata::Pickup / itemdata::PickupType",
                            "val": "<h3>int Pickup;</h3>\nThe item pickup flags, as a bitwise flagset. Use the `IP_` constants to access. Take care when using any `INTERNAL` flags.\n#{IP_ constants|$[IP_]}\n\n<h3>int PickupType;</h3>\nHow the pickup flags are applied to items upon item creation.\n#{IPTYPE_ constants|$[IPTYPE_]}"
                        },
                        {
                            "name": "Graphics Info ;; itemdata::Tile / itemdata::CSet / itemdata::MiscFlags / itemdata::AFrames / itemdata::ASpeed / itemdata::Delay / itemdata::TileMod / itemdata::Sprites / itemdata::UseBurnSprites / itemdata::BurnSprites[]",
                            "val": "<h3>int Tile;</h3>\nThe starting tile of the item's animation\n\n<h3>int CSet;</h3>\nThe CSet the item sprite uses\n\n<h3>int MiscFlags</h3>\nMisc flags for the item graphics, bitwise flagset. Use the `IMISC_` constants to access.\n#{IMISC_ constants|$[IMISC_]}\n<todo>Item editor can't flip the tile?</todo>\n\n<h3>int AFrames;</h3>\nThe number of frames in the animation\n\n<h3>int ASpeed;</h3>\nThe speed of the animation, in frames per frame.\n\n<h3>int Delay;</h3>\nThe number of delay frames at the start of the animation.\n\n<h3>int TileMod;</h3>\nThe Player Tile Modifier associated with this item.\n\n<h3>int Sprites[10];</h3>\nThe 10 sprites used by the item. How they are used depends on the item type.\n\n<h3>bool UseBurnSprites;</h3>\nIf true, the weapon created by this item will update its sprite when lit on fire using 'BurnSprites[]' below.\n\n<h3>int BurnSprites[ITM_BURNSPR_MAX];</h3>\nThe sprites used for making the weapon change appearance when lit on fire."
                        },
                        {
                            "name": "Size Info ;; itemdata::SizeFlags / itemdata::TileWidth / itemdata::TileHeight / itemdata::HitWidth / itemdata::HitHeight / itemdata::HitZHeight / itemdata::DrawXOffset / itemdata::DrawYOffset / itemdata::HitXOffset / itemdata::HitYOffset",
                            "val": "<h3>int SizeFlags;</h3>\nA bitwise flagset representing all the checkboxes for which sizes to apply from the itemdata. Use the `SZFLAG_` constants to access.\n#{SZFLAG_ constants|$[SZFLAG_]}\n\n<h3>int TileWidth;\nint TileHeight;</h3>\nThe visual size of the sprite, in tiles.\n\n<h3>int HitWidth;\nint HitHeight;</h3>\nThe hitbox size of the sprite, in pixels.\n\n<h3>int HitZHeight;</h3>\nThe Z-Height of the hitbox, in pixels.\n\n<h3>int DrawXOffset;\nint DrawYOffset;</h3>\nThe visual offset of the sprite, in pixels.\n\n<h3>int HitXOffset;\nint HitYOffset;</h3>\nThe hitbox offset of the sprite, in pixels."
                        },
                        {
                            "name": "Weapon Size Info ;; itemdata::WeaponSizeFlags / itemdata::WeaponTileWidth / itemdata::WeaponTileHeight / itemdata::WeaponHitWidth / itemdata::WeaponHitHeight / itemdata::WeaponHitZHeight / itemdata::WeaponDrawXOffset / itemdata::WeaponDrawYOffset / itemdata::WeaponHitXOffset / itemdata::WeaponHitYOffset",
                            "val": "<h3>int WeaponSizeFlags;</h3>\nA bitwise flagset representing all the checkboxes for which sizes to apply from the itemdata. Use the `SZFLAG_` constants to access.\n#{SZFLAG_ constants|$[SZFLAG_]}\n\n<h3>int WeaponTileWidth;\nint WeaponTileHeight;</h3>\nThe visual size of the sprite, in tiles.\n\n<h3>int WeaponHitWidth;\nint WeaponHitHeight;</h3>\nThe hitbox size of the sprite, in pixels.\n\n<h3>int WeaponHitZHeight;</h3>\nThe Z-Height of the hitbox, in pixels.\n\n<h3>int WeaponDrawXOffset;\nint WeaponDrawYOffset;</h3>\nThe visual offset of the sprite, in pixels.\n\n<h3>int WeaponHitXOffset;\nint WeaponHitYOffset;</h3>\nThe hitbox offset of the sprite, in pixels."
                        },
                        {
                            "name": "Weapon Info ;; itemdata::Weapon / itemdata::Defense",
                            "val": "<h3>int Weapon;</h3>\nThe overrided weapon type that the weapon will act like.\n\n<h3>int Defense;</h3>\nThe default defense of the weapon."
                        },
                        {
                            "name": "&lt;-- Prev ;; dmapdataptr",
                            "val": "$-1"
                        }
                    ]
                }
            ]
        },
        {
            "name": "Itemsprite",
            "tabs": [
                {
                    "name": "Itemsprite ROOT",
                    "lines": [
                        {
                            "name": "&lt;-- Sprite Pointers ;; function_data_sprite",
                            "val": "$0$5"
                        },
                        {
                            "name": "<em>itemsprite</em>",
                            "val": "<h3>Itemsprite Pointers</h3>   `itemsprite`\n\nThese pointers represent item objects on screen. These may be screen items, enemy drops, shop items, etc; or you may create your own items via script.\n\nSee: ${LoadItem}, ${CreateItem}\n"
                        },
                        {
                            "name": "Basic Info ;; itemsprite::ID / itemsprite::isValid / itemsprite::Type / itemsprite::Family / itemsprite::Level / itemsprite::Dir / itemsprite::Animation",
                            "val": "<h3>int ID;</h3>\nThe item ID to give when the item is collected.\n\n<h3>bool isValid();</h3>\nReturns true if this pointer points to a valid itemsprite. If this returns false, using any other value of this pointer will error.\n\n<h3>int Type;\nint Family;</h3>\nThe type ${itemclass|(itemclass)} of the item. Uses the `IC_` constants.\n\n<h3>int Level;</h3>\nThe item's level\n\n<h3>int Dir;</h3>\nThe item's direction\n\n<h3>bool Animation;</h3>\nIf the engine should animate the item's graphics\n\n"
                        },
                        {
                            "name": "Position ;; itemsprite::X / itemsprite::Y / itemsprite::Z / itemsprite::Jump / itemsprite::Gravity / itemsprite::MoveFlags / itemsprite::FakeZ / itemsprite::FakeJump",
                            "val": "<h3>int X; int Y; int Z;</h3>\n\nRead/Write; These values store the itemsprite's position on each of the three axes.\nIf the ${QRS|quest rule} `Sprite Coordinates are Float` is checked, these values can include up to 4 decimal places; otherwise values are truncated.\n\n<h3>int Jump;</h3>\nThe itemsprite's upward velocity, in pixels per frame. Affected by gravity each frame, if gravity is enabled for this itemsprite.\n\n<h3>bool Gravity;</h3>\nTrue by default. If false, gravity will no longer affect this itemsprite.\n\n<h3>bool MoveFlags[];</h3>\nThe movement flags of the itemsprite. See `ITEMMV_` constants.\n#{ITEMMV_ constants|$[ITEMMV_]}\n<h3>int FakeZ;</h3>\nThe position of the itemsprite on the FakeZ axis.\n\n<h3>int FakeJump;</h3>\nThe velocity of the itemsprite in the FakeZ axis.\n"
                        },
                        {
                            "name": "Sprite Limit ;; itemsprite::Max",
                            "val": "<h3>int Max();</h3>\nReturns the max number of itemsprites currently allowed.\n\n<h3>void Max(int newmax);</h3>\nSets the max number of itemsprites allowed to a new value. Range `1-1024`.\n"
                        },
                        {
                            "name": "Graphical Info ;; itemsprite::OriginalTile / itemsprite::Tile / itemsprite::CSet / itemsprite::NumFrames / itemsprite::Frame / itemsprite::ASpeed / itemsprite::AClock / itemsprite::Delay / itemsprite::Flash / itemsprite::FlashCSet / itemsprite::Flip",
                            "val": "<h3>int OriginalTile;</h3>\nThe starting tile of the itemsprite's animation.\n\n<h3>int Tile;</h3>\nThe currently displaying tile of the itemsprite's animation. Set by the engine each frame if ${itemsprite::Animation|animation} is enabled.\n\n<h3>int CSet;</h3>\nThe CSet of the itemsprite.\n\n<h3>int NumFrames;</h3>\nThe number of frames in the itemsprite's animation.\n\n<h3>int Frame;</h3>\nThe current frame number that the animation is on.\n\n<h3>int ASpeed;</h3>\nThe speed of the animation, in frames per frame.\n\n<h3>int AClock;</h3>\nThe timer that ASpeed is used with.\n\n<h3>int Delay;</h3>\nThe number of delay frames at the start of the itemsprite's animation.\n\n<h3>bool Flash;</h3>\nIf the itemsprite is flashing or not. When flashing, it changes between its' CSet and FlashCSet.\n\n<h3>int FlashCSet;</h3>\nThe secondary CSet used for flashing.\n\n<h3>int Flip;</h3>\nThe flip status of the itemsprite's tile. Uses the [[`FLIP_`|$FLIP_]] constants.\n\n"
                        },
                        {
                            "name": "Graphical Info 2 ;; itemsprite::ScriptTile / itemsprite::ScriptFlip / itemsprite::ShadowXOffset / itemsprite::ShadowYOffset / itemsprite::ShadowSprite / itemsprite::DrawStyle / itemsprite::Rotation / itemsprite::Scale / itemsprite::LightShape / itemsprite::LightRadius",
                            "val": "<h3>int ScriptTile;</h3>\n-1 by default. If this is set > -1, this tile will be displayed by the engine, regardless of the normal engine animation. Set back to -1 to restore engine animation.\n\n<h3>int ScriptFlip;</h3>\n-1 by default. If this is set > -1, this flip value will be used instead of the normal 'Flip' value. Set back to -1 to restore normal flip.\n\n<h3>int ShadowXOffset;\nint ShadowYOffset;</h3>\nThe x/y offset of the sprite's shadow.\n\n<h3>int ShadowSprite;</h3>\nThe ${spritedata} sprite ID to use for the item's shadow.\n\n<h3>int DrawStyle;</h3>\nThe mode for the sprite's draws, using the `DS_` constants.\n#{DS_ constants|$[DS_]}\n<h3>float Rotation;</h3>\nA rotation of the sprite draw, in degrees.\n\n<h3>float Scale;</h3>\nA scale of the sprite draw, as a multiplier.\n\n<h3>int LightShape;</h3>\nThe shape of light emitted by this sprite. Uses the `LIGHT_` constants.\n#{LIGHT_ constants|$[LIGHT_]}\n<h3>int LightRadius;</h3>\nThe size of the light emitted by this sprite, in pixels.\n\n\n"
                        },
                        {
                            "name": "Size Info ;; itemsprite::Extend / itemsprite::HitWidth / itemsprite::HitHeight / itemsprite::HitZHeight / itemsprite::TileWidth / itemsprite::TileHeight / itemsprite::DrawXOffset / itemsprite::DrawYOffset / itemsprite::DrawZOffset / itemsprite::HitXOffset / itemsprite::HitYOffset",
                            "val": "<h3>int Extend;</h3>\nIf the item sprite should be extended (large). Set to 3 to extend, 0 otherwise.\n\n<h3>int HitWidth;\nint HitHeight;</h3>\nThe width/height of the hitbox, in pixels.\n\n<h3>int HitZHeight;</h3>\nThe height of the hitbox in the Z-axis, in pixels.\n\n<h3>int TileWidth;\nint TileHeight;</h3>\nThe width/height of the sprite's graphic, in tiles.\n\n<h3>int DrawXOffset;\nint DrawYOffset;</h3>\nThe visual offset, in pixels.\n\n<h3>int DrawZOffset;</h3>\nThe Z offset, in pixels.\n\n<h3>int HitXOffset;\nint HitYOffset;</h3>\nThe hitbox offset, in pixels.\n"
                        },
                        {
                            "name": "--&gt; Next ;; itemsprite2",
                            "val": "$-1$1"
                        }
                    ]
                },
                {
                    "name": "Itemsprite 2",
                    "lines": [
                        {
                            "name": "&lt;-- Sprite Pointers ;; function_data_sprite",
                            "val": "$0$5"
                        },
                        {
                            "name": "Pickup Info ;; itemsprite::Pickup / itemsprite::PickupString / itemsprite::PickupStringFlags",
                            "val": "<h3>int Pickup;</h3>\nThe item pickup flags, as a bitwise flagset. Use the `IP_` constants to access. Take care when using any `INTERNAL` flags.\n#{IP_ constants|$[IP_]}\n\n<h3>int PickupString;</h3>\nThe message string to display upon picking up the item.\n\n<h3>int PickupStringFlags;</h3>\nThe flags associated with the pickup string, as bitwise flags. Use the `IPSTR_` constants to access this.\n\n"
                        },
                        {
                            "name": "Script Info ;; itemsprite::Script / itemsprite::InitD / itemsprite::Misc",
                            "val": "<h3>int Script;</h3>\nThe itemsprite script running on this itemsprite.\n\n<h3>int InitD[8];</h3>\nThe 8 InitD[] arguments for the itemsprite script.\n\n<h3>int Misc[32];</h3>\nAn array of misc values for script use.\n"
                        },
                        {
                            "name": "Status ;; itemsprite::Falling / itemsprite::FallCombo / itemsprite::Drowning / itemsprite::DrownCombo / itemsprite::SwitchHooked / itemsprite::Switch",
                            "val": "<h3>int Falling;</h3>\nThe timer indicating how long left the sprite will be falling. If 0, the sprite is not falling. Max value of 70, which is the value at the start of falling.\n\n<h3>int FallCombo;</h3>\nThe pitfall combo the sprite is falling into, if it is falling.\n\n<h3>int Drowning;</h3>\nThe timer indicating how long left the sprite will be drowning. If 0, the sprite is not drowning. Max value of 64, which is the value at the start of drowning.\n\n<h3>int DrownCombo;</h3>\nThe liquid combo the sprite is drowning in, if it is drowning.\n\n<h3>bool SwitchHooked;</h3>\nIf the sprite is currently being switch-hooked.\n\n<h3>bool Switch(int effect);</h3>\nSwitch the player with this sprite. Use the `SW_EFF_` constants for 'effect' to select a visual style for the switch.\nReturns true if it succeeds, and false otherwise.\n"
                        },
                        {
                            "name": "Misc Info ;; itemsprite::Explode / itemsprite::Remove / itemsprite::DroppedBy / itemsprite::ForceGrab",
                            "val": "<h3>void Explode(int mode);</h3>\nCreates an explosion particle effect in mode 0, 1, or 2 of the sprite.\n\n<h3>void Remove();</h3>\nInstantly deletes the itemsprite.\n\n<h3>int DroppedBy;</h3>\nThe dropset that this item was dropped by. Will be set for engine-dropped items, can be written by scripts as well.\n\n<h3>bool ForceGrab;</h3>\nIf set to true, the item will automatically be collected by the player as soon as possible.\n"
                        },
                        {
                            "name": "Owning ;; itemsprite::Own / itemsprite::OwnArray / itemsprite::OwnObject",
                            "val": "<h3>void Own(bitmap b);\nvoid Own(paldata pd);\nvoid Own(stack st);\nvoid Own(file f);\nvoid Own(directory dir);\nvoid Own(randgen rnd);\nvoid OwnArray(untyped[] array);\nvoid OwnObject([Object] object);</h3>\n\nGrants 'Ownership' of the parameter object to the itemsprite."
                        },
                        {
                            "name": "&lt;-- Prev ;; itemspriteptr",
                            "val": "$-1"
                        }
                    ]
                }
            ]
        },
        {
            "name": "ZInfo",
            "tabs": [
                {
                    "name": "ZInfo ROOT",
                    "lines": [
                        {
                            "name": "&lt;-- Global Pointers ;; function_globalptr",
                            "val": "$Base Data$3"
                        },
                        {
                            "name": "<em>ZInfo</em> ;; zinfo",
                            "val": "The `ZInfo-&gt;` pointer allows accessing zinfo strings.\n\n<todo>add more getter functions to `ZInfo-&gt;`</todo>\n"
                        },
                        {
                            "name": "itemclass ;; ZInfo::GetItemClass",
                            "val": "<h3>void GetItemClass(char32 [[buf[]|256 chars]], int itemclass_id);</h3>\nCopies the name of the specified itemclass (use `IC_` constants) into the buffer.\n"
                        }
                    ]
                }
            ]
        },
        {
            "name": "SpriteData",
            "tabs": [
                {
                    "name": "SpriteData ROOT",
                    "lines": [
                        {
                            "name": "&lt;-- Misc Data Pointers ;; function_data_misc",
                            "val": "$0$6"
                        },
                        {
                            "name": "<em>spritedata</em> ;; spritedata",
                            "val": "<h3>SpriteData Pointers</h3>   `spritedata`\n\nThese pointers represent the `Quest-&gt;Graphics-&gt;Sprites-&gt;Sprite Data` sprite information.\n\nSee: ${Game::LoadSpriteData|LoadSpriteData}"
                        },
                        {
                            "name": "Data ;; spritedata::ID / spritedata::Tile / spritedata::CSet / spritedata::FlashCSet / spritedata::Frames / spritedata::Speed / spritedata::Flags / spritedata::Type",
                            "val": "<h3>int ID;</h3>\nRead-only. The sprite ID this spritedata is associated with.\n\n<h3>int Tile;</h3>\nThe tile of the sprite.\n\n<h3>int CSet;</h3>\nThe cset of the sprite.\n\n<h3>int FlashCSet;</h3>\nThe flash cset of the sprite.\n\n<h3>int Frames;</h3>\nThe frame count of the sprite.\n\n<h3>int Speed;</h3>\nThe speed of the sprite, in frames per frame\n\n<h3>bool Flags[5];</h3>\nThe sprite's flags. Use the `SPRFL_` constants as indexes.\n#{SPRFL_ constants|$[SPRFL_]}\n<h3>int Type;</h3>\nThe 'Type' field of the sprite."
                        }
                    ]
                }
            ]
        },
        {
            "name": "Game",
            "tabs": [
                {
                    "name": "Game 1",
                    "lines": [
                        {
                            "name": "&lt;-- Global Pointers ;; function_globalptr",
                            "val": "$Base Data$3"
                        },
                        {
                            "name": "<em>Game</em>",
                            "val": "The `Game->` pointer holds many general internal functions and variables."
                        },
                        {
                            "name": "Current Position ;; Game::CurLevel / Game::CurDMap / Game::CurMap / Game::CurDMScreen / Game::CurDMapScreen / Game::CurScreen / Game::GetCurLevel / Game::GetCurDMap / Game::GetCurMap / Game::GetCurDMapScreen / Game::GetCurScreen",
                            "val": "<h3>int CurScreen;\nint GetCurScreen();</h3>\nReturns the screen the player is currently on.\n\n<h3>int CurDMapScreen;\nint CurDMScreen;\nint GetCurDMapScreen();</h3>\nReturns the screen the player is currently on, offset by the current dmap offset.\n\n<h3>int CurMap;\nint GetCurMap();</h3>\nReturns the map the player is currently on.\n\n<h3>int CurDMap;\nint GetCurDMap();</h3>\nReturns the dmap the player is currently on.\n\n<h3>int CurLevel;\nint GetCurLevel();</h3>\nReturns the level the player is currently on."
                        },
                        {
                            "name": "Counters ;; Game::Counter / Game::MCounter / Game::DCounter",
                            "val": "<h3>int Counter[NUM_COUNTERS];</h3>\n\nThe value of each of the game's counters (using [[`CR_`|$Counter]] constants). Values `0 to 65535`.\n\n<h3>int MCounter[NUM_COUNTERS];</h3>\n\nThe max value of each of the game's counters (using [[`CR_`|$Counter]] constants). Values `0 to 65535`.\n\n<h3>int DCounter[NUM_COUNTERS];</h3>\n\nThe value of each of the game's drain counters (using [[`CR_`|$Counter]] constants). Values `-32768 to 32767`.\nThese will approach 0 each frame, adding or subtracting from the matching `Counter[]`."
                        },
                        {
                            "name": "Misc Arrays ;; Game::Misc / Game::Misc2 / Game::Misc3",
                            "val": "<h3>untyped Misc[32];\nuntyped Misc2[256];\nuntyped Misc3[256];</h3>\n\n3 misc data arrays."
                        },
                        {
                            "name": "Basic Loaders ;; Game::LoadGenericData / Game::LoadBottleShopData / Game::LoadBottleData / Game::LoadDropset / Game::LoadDMapData / Game::LoadMessageData / Game::LoadInfoShopData / Game::LoadShopData / Game::LoadSpriteData / Game::LoadComboData / Game::LoadNPCData / Game::LoadItemData",
                            "val": "<mono>\n<h3>${itemdata}       LoadItemData       (int item_id);</h3>\n<h3>${npcdata}        LoadNPCData        (int npc_id);</h3>\n<h3>${combodata}      LoadComboData      (int combo_id);</h3>\n<h3>${spritedata}     LoadSpriteData     (int misc_spr_id);</h3>\n<h3>${shopdata}       LoadShopData       (int shop_id);</h3>\n<h3>${shopdata}       LoadInfoShopData   (int shop_id);</h3>\n<h3>${messagedata}    LoadMessageData    (int string_id);</h3>\n<h3>${dmapdata}       LoadDMapData       (int dmap_id);</h3>\n<h3>${dropsetdata}    LoadDropset        (int dropset_id);</h3>\n<h3>${bottledata}     LoadBottleData     (int bottle_type_id);</h3>\n<h3>${bottleshopdata} LoadBottleShopData (int bottleshop_id);</h3>\n<h3>${genericdata}    LoadGenericData    (int generic_script_id);</h3></mono>\n\nThese functions load the specified pointer, returning `NULL` on a failure."
                        },
                        {
                            "name": "Other Loaders ;; Game::LoadStack / Game::LoadRNG / Game::LoadBitmapID / Game::CreateBitmap / Game::AllocateBitmap / Game::LoadScrollingScreen / Game::LoadTempScreen / Game::LoadMapData / Game::LoadSavedPortal / LoadSavedPortal / Game::CreateSavedPortal / Game::NumSavedPortals",
                            "val": "<h3>${mapdata} LoadMapData(int map, int screen);</h3>\n\nLoads the mapdata pointer for the screen at `(map,screen)`. Edits to these pointers do not persist through quest exit. Edits to these pointers will NOT affect the \"current screen\", even if the current map/screen is supplied; see `LoadTempScreen()` below for that.\n\n<h3>${mapdata} LoadTempScreen(int layer);</h3>\n\nLoads the temp mapdata pointer for the specified layer. `LoadTempScreen(0)` gives a pointer that works mostly the same as `Screen->`, while passing 1 through 6 will give equal access to the other layers of the screen. Modifications to these pointers are reset when the screen changes.\n\n<h3>${mapdata} LoadScrollingScreen(int layer);</h3>\n\nLoads the temp mapdata pointer for the specified layer's *scrolling screen*. This is only used during scrolling, for drawing the screen you just came from during the scrolling animation. Writing to this at any time other than during scrolling will have no effect.\n\n<h3>${bitmap} CreateBitmap(int width = 256, int height = 256);</h3>\n\nAllocates a new bitmap pointer, creating a `width by height` canvas (cleared to color 0). Be sure to `Free()` it when you are done, or `Own()` it to attach it to a script!\n\nIf [[\"Old Args for CreateBitmap and bitmap->Create()\"|at \"ZScript->Quest Script Settings->Instructions\"]] is enabled, then `width` and `height` are swapped with each other.\n\n<h3>${bitmap} AllocateBitmap();</h3>\n\nAllocates a new bitmap pointer, but does not create a canvas on it. ${bitmap::Create|bitmap->Create()} can later be used to create a canvas on the pointer. Be sure to `Free()` it when you are done, or `Own()` it to attach it to a script!\n\n<h3>${bitmap} LoadBitmapID([[int render_target|`RT_` constants]]);</h3>\n\nLoads a `bitmap` pointer for one of the old-style render target `RT_` bitmaps.\n<todo>Unsure if these have been tested to work properly?</todo>\n\n<h3>${randgen} LoadRNG();</h3>\n\nLoads an unused `randgen` pointer. Be sure to `Free()` it when you are done, or `Own()` it to attach it to a script!\n\n<h3>${stack} LoadStack();</h3>\n\nLoads an unused `stack` pointer. Be sure to `Free()` it when you are done, or `Own()` it to attach it to a script!\n\n<h3>${savedportal} LoadSavedPortal(int saved_portal_id);</h3>\n\nLoads a 'Saved Portal' pointer. Use `1 &lt;= saved_portal_id &lt;= NumSavedPortals()`, OR `saved_portal_id == -1` to access the Magic Mirror's portal.\n\n<h3>int NumSavedPortals();</h3>\n\nReturns the number of saved portals that currently exist.\n\n<h3>${savedportal} SavedPortals[];</h3>\n\nA 0-indexed ${Internal Arrays|Internal Array pointer} referencing the saved portal objects. Cannot access the Magic Mirror's portal."
                        },
                        {
                            "name": "String Getters ;; Game::GetDMap / Game::GetCombo / Game::GetItem / Game::GetNPC / Game::GetGenericScript / Game::GetItemSpriteScript / Game::GetScreenScript / Game::GetDMapScript / Game::GetGlobalScript / Game::GetPlayerScript / Game::GetEWeaponScript / Game::GetLWeaponScript / Game::GetNPCScript / Game::GetItemScript / Game::GetComboScript / Game::GetFFCScript ;; GetFFCScript / GetComboScript / GetItemScript / GetNPCScript / GetLWeaponScript / GetEWeaponScript / GetPlayerScript / GetGlobalScript / GetDMapScript / GetScreenScript / GetItemSpriteScript / GetGenericScript / GetNPC / GetItem / GetCombo / GetDMap",
                            "val": "<h3>int GetFFCScript(char32 name[]);</h3>\n<h3>int GetComboScript(char32 name[]);</h3>\n<h3>int GetItemScript(char32 name[]);</h3>\n<h3>int GetNPCScript(char32 name[]);</h3>\n<h3>int GetLWeaponScript(char32 name[]);</h3>\n<h3>int GetEWeaponScript(char32 name[]);</h3>\n<h3>int GetPlayerScript(char32 name[]);</h3>\n<h3>int GetGlobalScript(char32 name[]);</h3>\n<h3>int GetDMapScript(char32 name[]);</h3>\n<h3>int GetScreenScript(char32 name[]);</h3>\n<h3>int GetItemSpriteScript(char32 name[]);</h3>\n<h3>int GetGenericScript(char32 name[]);</h3>\n\nGets the script of the specified type with a name exactly matching `name`. If no such script exists, returns `-1`.\n\n<h3>int GetNPC(char32 name[]);</h3>\n<h3>int GetItem(char32 name[]);</h3>\n<h3>int GetCombo(char32 name[]);</h3>\n<h3>int GetDMap(char32 name[]);</h3>\n\nGets the ID of the npc/item/combo/dmap whose name exactly matches `name`. If no such object exists, returns `-1`."
                        },
                        {
                            "name": "Version Checking ;; Game::ZScriptVersion / Game::Version / Game::Build / Game::Beta / Game::BetaType",
                            "val": "<h3>int Version;</h3>\n\nRead-only. The current version of ZC that the quest is being played in (ex: \"2.55\" for 2.55)\n\n<h3>int Build;</h3>\n\nRead-only. The current Build ID of ZC that the quest is being played in.\n\n<h3>int Beta;</h3>\n\nRead-only. The current detailed version; this can be the current Alpha, Beta, Gamma, or Release number, depending on the version of the program.\nFor nightlies, returns a half-measure; ex. \"Nightly A111/A112\" would return \"111.5\".\n\n<h3>int BetaType;</h3>\n\nRead-only. What type of detailed version the program is in. `0 = Alpha`, `1 = Beta`, `2 = Gamma`, `3 = Release`, `-1 = error`.\n\n<h3>int ZScriptVersion;</h3>\n\nThe ZScript version number the quest was last compiled in."
                        },
                        {
                            "name": "Level Items ;; Game::LItems / Game::LKeys",
                            "val": "<h3>int LKeys[NUM_LEVELS];</h3>\n\nHow many level-specific keys are owned for each level.\n\n<h3>int LItems[NUM_LEVELS];</h3>\n\nContains a bitwise flagset of the \"Level Items\".\n<ul>\r\n<li>LI_TRIFORCE = 0x01</li>\r\n<li>LI_MAP = 0x02</li>\r\n<li>LI_COMPASS = 0x04</li>\r\n<li>LI_BOSS = 0x08</li>\r\n<li>LI_BOSSKEY = 0x10</li>\n</ul>"
                        },
                        {
                            "name": "--&gt; Next ;;gameptr2",
                            "val": "$-1$1"
                        },
                        {
                            "name": "--&gt;&gt; End ;;gameptr3",
                            "val": "$-1$2"
                        }
                    ]
                },
                {
                    "name": "Game 2",
                    "lines": [
                        {
                            "name": "&lt;-- Global Pointers ;; function_globalptr",
                            "val": "$0$3"
                        },
                        {
                            "name": "Switches ;; Game::LSwitches / Game::GSwitches",
                            "val": "<h3>long LSwitches[NUM_LEVELS];</h3>\n\nThe level-specific switch states for each level. Each level has a single `long`, representing 32 bitwise states. Ex: `(Game-&gt;LSwitches[Game-&gt;CurLevel] & (1Lb &lt;&lt; (5)))` will get the switch state indexed '5'.\n\n<h3>int GSwitch[256];</h3>\n\nThe 256 global switch timers.\nA value of `0` represents an \"off\" switch.\nA value of `-1` represents an \"on\" switch.\nA value `&gt; 0` represents a \"timed\" switch, which will remain on for that many more frames."
                        },
                        {
                            "name": "Game Arrays ;; Game::MiscSprites / Game::MiscSFX / Game::BottleState / Game::OverrideItems / Game::Scrolling / Game::Gravity / Game::Generic / Game::Suspend",
                            "val": "<h3>int MiscSprites[MISCSPR_MAX];</h3>\nThe `Quest->Graphics->Sprites->Misc Sprites` values, accessed with the `MISCSPR_` constants.\n\n<h3>int MiscSFX[MISCSFX_MAX];</h3>\nThe `Quest->Audio->Misc SFX` values, accessed with the `MISCSFX_` constants.\n\n<h3>int BottleState[256];</h3>\nThe contents of the player's fillable bottles. Use bottle type IDs for the values, and slots (set in the bottle item's attributes) as the indexes.\n\n<h3>int OverrideItems[IC_MAX];</h3>\nThe override values for each itemclass. Default value is `-2`. If set to `-2`, no override occurs. If `&gt; -2`, anything that checks for the 'highest level item' of this class uses this ID instead. A value of `-1` indicates forcing it to return 'no item'.\nIf set to an item ID that is of the wrong itemclass, has no effect.\n\n<h3>int Scrolling[5];</h3>\nRead-only; values related to scrolling.\n#{Values|<ol start=\"0\">\n<li>SCROLL_DIR: The direction the screen is scrolling, -1 while not scrolling.</li>\n<li>SCROLL_NX: The top-left X offset of the 'new' screen during scrolling.</li>\n<li>SCROLL_NY: The top-left Y offset of the 'new' screen during scrolling.</li>\n<li>SCROLL_OX: The top-left X offset of the 'old' screen during scrolling.</li>\n<li>SCROLL_OY: The top-left Y offset of the 'old' screen during scrolling.</li>\n</ol>}\n\n<h3>int Gravity[3];</h3>\nValues related to gravity.\n#{Values|<ol start=\"0\">\n<li>GR_STRENGTH: The strength of gravity.</li>\n<li>GR_TERMINALV: The terminal velocity.</li>\n<li>GR_SPRLAYER: The sprite layer threshold.</li>\n</ol>}\n\n<h3>untyped Generic[GEN_MAX];</h3>\nGeneric values related to the game.\n#{Values|<ol start=\"0\">\n<li>GEN_HEARTPIECES: The number of heart pieces currently owned.</li>\n<li>GEN_MAGICDRAINRATE: The magic drain multiplier. Lowered when half magic is acquired.</li>\n<li>GEN_CANSLASH: Bool, whether or not the player can slash with swords.</li>\n<li>GEN_WARPLEVEL: The current whistle warp ring. This is set every time the whistle is used.</li>\n<li>GEN_HCPPERHC: How many heart pieces make a heart container.</li>\n<li>GEN_CONTINUEHEARTS: The [[amount of life|Either in HP, or in percentage of max HP out of 100, depending on the value of `GEN_CONTINUEISPERCENT`]] the player `Continue`'s with.</li>\n<li>GEN_CONTINUEISPERCENT: Bool, whether the [[above|`GEN_CONTINUEHEARTS`]] value is a percentage of max life or not.</li>\n<li>GEN_HP_PER_HEART: The number of HP per heart.</li>\n<li>GEN_MP_PER_BLOCK: The number of MP per block.</li>\n<li>GEN_HERO_DMG_MULT: The damage multiplier for damage dealt by the player.</li>\n<li>GEN_ENEM_DMG_MULT: The damage multiplier for damage dealt by enemies.</li>\n<li>GEN_DITHER_TYPE: The dither type used by ${Dark Rooms|engine dark rooms}.</li>\n<li>GEN_DITHER_ARG: The dither arg used by ${Dark Rooms|engine dark rooms}.</li>\n<li>GEN_DITHER_PERCENT: The percentage of light circles taken up by dithering in ${Dark Rooms|engine dark rooms}.</li>\n<li>GEN_DEFAULT_LIGHT_RAD: The default light radius of enemies in ${Dark Rooms|engine dark rooms}.</li>\n<li>GEN_TRANS_PERCENT: The percentage of light circles taken up by transparency in ${Dark Rooms|engine dark rooms}.</li>\n<li>GEN_DARKNESS_COLOR: The color index of darkness in ${Dark Rooms|engine dark rooms}.</li>\n<li>GEN_WATERGRAVITY: The gravity when not moving while in sideview swimming water. Can be negative.</li>\n<li>GEN_SIDESWIM_STEP_UP: The hero's sideswim step speed in the up direction.</li>\n<li>GEN_SIDESWIM_STEP_SIDE: The hero's sideswim step speed in the side directions.</li>\n<li>GEN_SIDESWIM_STEP_DOWN: The hero's sideswim step speed in the down direction.</li>\n<li>GEN_SIDESWIM_EXITJUMP: The jump value given when exiting sideview water from the top. If 0, can only leave water via a ladder.</li>\n<li>GEN_BUNNY_TILEMOD: The player tile modifier added when the ${Hero::BunnyClk|bunny status effect} is active.</li>\n<li>GEN_SWITCHHOOK_STYLE: Which `SW_EFF` style to use by [[default|Used for the enemy defense 'Switch w/ Player']] for switch hook effects.</li>\n</ol>}\n\n<h3>bool Suspend[susptLAST];</h3>\nAn array of suspend states, all false by default. By writing these true, certain game operations may be paused until the state is written false again.\n#{Values|<ol start=\"0\">\n<li>susptCOMBOANIM</li>\n<li>susptGUYS</li>\n<li>susptLWEAPONS</li>\n<li>susptEWEAPONS</li>\n<li>susptITEMS</li>\n<li>susptLINK</li>\n<li>susptUPDATEFFC</li>\n<li>susptDECORATIONS</li>\n<li>susptPARTICLES</li>\n<li>susptPALCYCLE</li>\n<li>susptLAKES</li>\n<li>susptCOLLISIONS</li>\n<li>susptCONTROLSTATE</li>\n<li>susptONEFRAMECONDS</li>\n<li>susptSCRIPDRAWCLEAR</li>\n<li>susptQUAKE</li>\n<li>susptGLOBALGAME</li>\n<li>susptNPCSCRIPTS</li>\n<li>susptLWEAPONSCRIPTS</li>\n<li>susptEWEAPONSCRIPTS</li>\n<li>susptITEMSPRITESCRIPTS</li>\n<li>susptFFCSCRIPTS</li>\n<li>susptLINKACTIVE</li>\n<li>susptITEMSCRIPTENGINE</li>\n<li>susptDMAPSCRIPT</li>\n<li>susptSCREENSCRIPTS</li>\n<li>susptSUBSCREENSCRIPTS</li>\n<li>susptCOMBOSCRIPTS</li>\n<li value=\"60\">susptCONVEYORSITEMS</li>\n<li>susptDRAGGINGITEM</li>\n<li>susptROAMINGITEM</li>\n<li>susptLENS</li>\n<li>susptHOOKSHOT</li>\n<li>susptMOVINGBLOCKS</li>\n<li>susptMAGICCAST</li>\n<li>susptSCREENDRAW</li>\n</ol>}"
                        },
                        {
                            "name": "FFRules ;; Game::FFRules ;; FFRules",
                            "val": "<h3>bool FFRules[qr_MAX];</h3>\nThe values of all Quest Rules. Access this array using the `qr_` constants in `include/std_zh/ffrules.zh`.\nAccessing indexes that do not have constants is undefined."
                        },
                        {
                            "name": "EventData ;; Game::Eventdata ;; EventData",
                            "val": "<h3>untyped EventData[];</h3>\nA variably-sized array containing information about the current event. This should be accessed from ${genericdata|Generic Scripts} after returning from ${WaitEvent|WaitEvent()}. Depending on what event WaitEvent() returns, a different set of constants should be used to access this array.\n\nValid events and their index constants:\n\n#{'GENSCR_EVENT_HERO_HIT_1' or 'GENSCR_EVENT_HERO_HIT_2'|Player hit, before/after ring defense applied.\n<ol start=\"0\">\n<li>GENEV_HEROHIT_DAMAGE: An int, amount of damage to be taken.</li>\n<li>GENEV_HEROHIT_HITDIR: An int, the dir to be knocked in.</li>\n<li>GENEV_HEROHIT_NULLIFY: A bool, false by default. Write true to nullify the hit.</li>\n<li>GENEV_HEROHIT_NAYRUON: A bool, if the shield spell is currently protecting the player from damage.</li>\n<li>GENEV_HEROHIT_IFRAMES: An int, the number of Invincibility Frames to give the player after the hit.</li>\n<li>GENEV_HEROHIT_HITTYPE: An [[`OBJTYPE_`|$OBJTYPE_]] value representing the type of the next value.</li>\n<li>GENEV_HEROHIT_HITOBJ: The object that hit the player. The `_HITTYPE` above tells you what type of object pointer this should be cast to.</li>\n</ol>}\n#{'GENSCR_EVENT_COLLECT_ITEM'|Item collected by player\n<ol start=\"0\">\n<li>GENEV_ITEMCOL_ID: The item ID to be picked up</li>\n<li>GENEV_ITEMCOL_PICKUP: The item's 'pickup' flags</li>\n<li>GENEV_ITEMCOL_PSTR: The item's 'pickup string'</li>\n<li>GENEV_ITEMCOL_PSTRFLAGS: The item's 'pickup string flags'</li>\n<li>GENEV_ITEMCOL_NULLIFY: bool, set to true to cancel the item pickup</li>\n<li>GENEV_ITEMCOL_ITEMPTR: The `itemsprite` pointer of the item being collected</li>\n<li>GENEV_ITEMCOL_TYPE: A [[GENEVT_ICTYPE_|<ol start = \"0\">\n<li>GENEVT_ICTYPE_COLLECT: The player touched the item</li>\n<li>GENEVT_ICTYPE_MELEE: A melee lweapon collected the item</li>\n<li>GENEVT_ICTYPE_MELEE_EW: A melee eweapon collected the item</li>\n<li>GENEVT_ICTYPE_RANGED_DRAG: A ranged weapon is about to drag this item (only editing `nullify` has any effect for this type)</li>\n</ol>]] value</li>\n<li>GENEV_ITEMCOL_WPNPTR: The ${lweapon} or ${eweapon} pointer (or null) depending on the above type.</li>\n</ol>}\n#{'GENSCR_EVENT_ENEMY_DROP_ITEM_1'|Enemy drops an item (before creating the item)\n<ol start=\"0\">\n<li>GENEV_EDI1_NPC: The ${npc} pointer</li>\n<li>GENEV_EDI1_ITEMID: The chosen item ID, [[or...|Use `-1` as an item ID to drop no item, or use `-2` to drop an item rolled from the specified dropset.]]</li>\n<li>GENEV_EDI1_DROPSET: The dropset the ID was chosen from.</li>\n</ol>}\n#{'GENSCR_EVENT_ENEMY_DROP_ITEM_2'|Enemy drops an item (after the item exists)\n<ol start=\"0\">\n<li>GENEV_EDI2_NPC: The ${npc} pointer</li>\n<li>GENEV_EDI2_ITM: The ${itemsprite} pointer</li>\n</ol>}\n#{'GENSCR_EVENT_ENEMY_DEATH'|An enemy is dying\n<ol start=\"0\">\n<li>GENEV_EDEATH_DYING: If the enemy is dying (write false to cancel death)</li>\n<li>GENEV_EDEATH_NPC: The ${npc} pointer</li>\n</ol>}\n#{'GENSCR_EVENT_ENEMY_HIT1' or 'GENSCR_EVENT_ENEMY_HIT2'|An enemy is hit, before/after ${npc::Defense|Defense[]} is applied.\n<ol start=\"0\">\n<li>GENEV_EHIT_POWER: The damage amount</li>\n<li>GENEV_EHIT_DEFENSETYPE: The defense type</li>\n<li>GENEV_EHIT_UNBLOCKABLE: The [[unblockable|$Unblockable]] flagset</li>\n<li>GENEV_EHIT_WEAPONID: The weapon's ID</li>\n<li>GENEV_EHIT_NULLIFY: A bool, false by default. Write true to nullify the hit.</li>\n<li>GENEV_EHIT_NPCPTR: The NPC pointer</li>\n<li>GENEV_EHIT_LWPNPTR: The LWeapon pointer</li>\n</ol>}"
                        },
                        {
                            "name": "Saving / Exiting ;; Game::Save / Game::End / Game::Reload / Game::Continue / Game::SaveAndQuit / Game::SaveAndContinue / Game::ShowSaveScreen / Game::ShowSaveQuitScreen / Game::ShowContinueScreen",
                            "val": "<h3>void Save();</h3>\nSaves the game. Can only run once per script per frame.\n\n<h3>void End();</h3>\nCloses the quest, returning to the title screen.\n\n<h3>void Reload();</h3>\nExits the quest without saving, then reloads the previous save.\n\n<h3>void Continue();</h3>\nContinue's the quest, as 'F6->Continue'.\n\n<h3>void SaveAndQuit();</h3>\nSaves the game, then exits.\n\n<h3>void SaveAndContinue();</h3>\nSaves the game, then continues.\n\n<h3>bool ShowSaveScreen();</h3>\nDisplays the Save screen, as Save Point combos use. Returns true if the player saved, false otherwise.\n\n<h3>void ShowSaveQuitScreen();</h3>\nDisplays the Save/Quit screen.\n\n<h3>void ShowContinueScreen();</h3>\nDisplays the engine Continue/Save/Retry screen."
                        },
                        {
                            "name": "Object Counts ;; Game::MaxItemsprites / Game::MaxEWeapons / Game::MaxLWeapons / Game::MaxNPCs ;; MaxNPCs / MaxLWeapons / MaxEWeapons / MaxItemsprites",
                            "val": "<h3>int MaxNPCs();\nint MaxLWeapons();\nint MaxEWeapons();\nint MaxItemsprites();</h3>\nReturns the current max sprite count for each sprite type.\n\n<h3>void MaxNPCs(int newmax);\nvoid MaxLWeapons(int newmax);\nvoid MaxEWeapons(int newmax);\nvoid MaxItemsprites(int newmax);</h3>\nSets the max sprite count for a sprite type to the given new value. Max must be between 1 and 1024, inclusive."
                        },
                        {
                            "name": "Last Locations ;; Game::LastEntranceDMap / Game::LastEntranceScreen / Game::ContinueDMap / Game::ContinueScreen ;; ContinueScreen / ContinueDMap / LastEntranceScreen / LastEntranceDMap",
                            "val": "<h3>int LastEntranceScreen;\nint LastEntranceDMap;</h3>\nThe last entrance point the player used, and will be reset to by some mechanics.\n\n<h3>int ContinueScreen;\nint ContinueDMap;</h3>\nThe continue point the player will be reset to when continuing."
                        },
                        {
                            "name": "Save File Status ;; Game::SetSaveName / Game::GetSaveName / Game::Standalone / Game::HasPlayed / Game::MaxCheat / Game::Cheat / Game::NumDeaths / Game::TimeValid / Game::Time ;; Time / TimeValid / NumDeaths / Cheat / MaxCheat / HasPlayed / Standalone / GetSaveName / SetSaveName",
                            "val": "<h3>int MaxCheat;</h3>\nThe highest cheat level that is enabled for the player. The player can change their cheat level in the cheat menu to any value <= this value (range 0-4). Updates when the player enters a cheat code.\n\n<h3>int Cheat;</h3>\nThe current activated cheat level. (range 0-4)\n\n<h3>int NumDeaths;</h3>\nThe number of times the player has died.\n\n<h3>bool HasPlayed;</h3>\nRead-only. Returns true if the current save file was loaded, false if it was a freshly created save.\n\n<h3>bool TimeValid;</h3>\nIf 'false', `Game->Time` does not contain accurate time information.\n\n<h3>long Time;</h3>\nThe number of frames passed on the save file, as a `long`. `include/time.zh` has several functions that help manage this value.\n\n<h3>bool Standalone;</h3>\nTrue if the game is running in `Standalone` mode.\n\n<h3>void GetSaveName(char32 buf[]);</h3>\nLoads the save file name into the buffer.\n\n<h3>void SetSaveName(char32 buf[]);</h3>\nSets the save file name to the contents of the buffer, limit 8 characters."
                        },
                        {
                            "name": "Global Settings ;; Game::DisableActiveSubscreen / Game::SkipF6 / Game::SkipCredits / Game::ClickToFreezeEnabled / Game::TypingMode / Game::SubscreenSpeed ;; SubscreenSpeed / TypingMode / ClickToFreezeEnabled / SkipCredits / SkipF6 / DisableActiveSubscreen",
                            "val": "<h3>int SubscreenSpeed;</h3>\nSpeed multiplier for the engine subscreen rise/fall. Default 1. Max 85.\n\n<h3>bool TypingMode;</h3>\nIf true, keyboard input is disabled except for scripts reading it.\n\n<h3>bool ClickToFreezeEnabled;</h3>\nWriting this to 'false' forcibly disables the \"Click To Freeze\" setting, allowing the user to click without pausing the game (ex. for scripted mouse interaction)\n\n<h3>bool SkipCredits;</h3>\nIf true, the end credits will not be shown.\n\n<h3>bool SkipF6;</h3>\nIf true, the F6 menu will not appear when F6 is pressed. The prompt to exit the game will still be shown.\n\n<h3>bool DisableActiveSubscreen;</h3>\nIf true, pressing the Start button will no longer open the active subscreen."
                        },
                        {
                            "name": "--&gt; Next ;;gameptr3",
                            "val": "$-1$2"
                        },
                        {
                            "name": "&lt;-- Prev ;;gameptr",
                            "val": "$-1$0"
                        }
                    ]
                },
                {
                    "name": "Game 3",
                    "lines": [
                        {
                            "name": "&lt;-- Global Pointers ;; function_globalptr",
                            "val": "$0$3"
                        },
                        {
                            "name": "IncrementQuest ;; Game::IncrementQuest ;; IncrementQuest",
                            "val": "<h3>void IncrementQuest();</h3>\nEnds the current quest in victory, resetting to the title screen (without showing the normal end credits), and if this quest is part of a module, increment to the next quest in the module."
                        },
                        {
                            "name": "Screen->D[] ;; Game::GetScreenD / Game::SetScreenD / Game::GetDMapScreenD / Game::SetDMapScreenD",
                            "val": "<h3>untyped GetScreenD(int screen, int reg);</h3>\nGets the `Screen->D[reg]` for the screen `screen` on the current dmap.\n\n<h3>untyped SetScreenD(int screen, int reg, untyped val);</h3>\nSets the `Screen->D[reg]` for the screen `screen` on the current dmap to `val`.\n\n<h3>untyped GetDMapScreenD(int dmap, int screen, int reg);</h3>\nGets the `Screen->D[reg]` for the screen `screen` on the specified dmap.\n\n<h3>untyped SetDMapScreenD(int dmap, int screen, int reg, untyped val);</h3>\nSets the `Screen->D[reg]` for the screen `screen` on the specified dmap to `val`."
                        },
                        {
                            "name": "GuyCount ;; Game::GuyCount",
                            "val": "<h3>int GuyCount[256];</h3>\nThe count of enemies remaining alive for each screen on the current map."
                        },
                        {
                            "name": "DisableItem[] ;; Game::DisableItem",
                            "val": "<h3>bool DisableItem[NUM_ITEMDATA];</h3>\n\nWhether each item is disabled or not on the current dmap."
                        },
                        {
                            "name": "Misc ;; Game::MapCount / Game::NumMessages",
                            "val": "<h3>int MapCount();</h3>\nThe number of maps in the quest.\n\n<h3>int NumMessages;</h3>\nThe number of message strings in the quest.\n\n<h3>int GetMidi();</h3>\nReturns the current MIDI playing."
                        },
                        {
                            "name": "Mouse Cursors ;; Game::MouseCursor / Game::SetCustomCursor / Cursors",
                            "val": "<h3>int MouseCursor;</h3>\nWhich mouse cursor (using the [[$ZCM_]] constants) should be displayed during gameplay. ZCM_BLANK is the default, and it resets on visiting the title screen.\n\n<h3>void SetCustomCursor(bitmap b, int fx, int fy, [[bool sys_recolor = false|If true, some system colors in cset 15 will be replaced based on the current program Theme.\n<ul><li>0xF1 = Cursor Misc</li>\n<li>0xF2 = Cursor Outline</li>\n<li>0xF3 = Cursor Light</li>\n<li>0xF5 = Cursor Dark</li></ul>]], [[bool user_scale|If true, the user's cursor scale config will be applied. = false]]);</h3>\nSets the custom cursor used by ZCM_CUSTOM from the bitmap b.\nfx,fy indicates the [[focal point|Normal cursors usually place this at the upper-left, on the transparent pixel the arrow points to.\nFor a crosshair cursor, this would be the center point.]] of the cursor.\n\nWARNINGS:\n\nThe palette will NOT update on custom cursors automatically. You must call this function again if the cursor should be affected by palette changes.\n\nThe cursor will use the image on the bitmap at the START of the frame, before any of this frame's draws. This means you should have a `Waitframe()` after the draws to the bitmap, before calling this function."
                        },
                        {
                            "name": "TrigGroups ;; Game::TrigGroups[] / Game::TriggerGroups[] / TrigGroups[] / TriggerGroups[]",
                            "val": "<h3>int TrigGroups[256];\nint TriggerGroups[256];</h3>\nRead-only. The 256 'Trigger Group' values for the current screen.\nThese represent a count of combos that 'Contribute to TrigGroup' that are present on the screen, layers, and ffcs."
                        },
                        {
                            "name": "--",
                            "val": ""
                        },
                        {
                            "name": "--",
                            "val": ""
                        },
                        {
                            "name": "&lt;&lt;-- Start ;;gameptr",
                            "val": "$-1$0"
                        },
                        {
                            "name": "&lt;-- Prev ;;gameptr2",
                            "val": "$-1$1"
                        }
                    ]
                }
            ]
        },
        {
            "name": "Global",
            "tabs": [
                {
                    "name": "Global ROOT",
                    "lines": [
                        {
                            "name": "&lt;-- Data / Functions ;; function_root",
                            "val": "$0$1"
                        },
                        {
                            "name": "--",
                            "val": "<h3>Global Functions</h3>\n\nGlobal functions are a member of no pointer type, and instead are simply able to be called from anywhere."
                        },
                        {
                            "name": "Misc Functions",
                            "val": "$-1$1"
                        },
                        {
                            "name": "Math Functions",
                            "val": "$-1$2"
                        },
                        {
                            "name": "Logging Functions",
                            "val": "$-1$3"
                        },
                        {
                            "name": "String Functions",
                            "val": "$-1$4"
                        },
                        {
                            "name": "Array Functions",
                            "val": "$-1$5"
                        }
                    ]
                },
                {
                    "name": "Misc Functions",
                    "lines": [
                        {
                            "name": "&lt;-- Global Functions",
                            "val": "$-1$0"
                        },
                        {
                            "name": "--",
                            "val": "Functions that don't fit a particular category."
                        },
                        {
                            "name": "Quit / QuitNoKill",
                            "val": "<h3>void Quit();</h3>\n\nExits the current script entirely. Has the same effect as reaching the end of 'void run()', or 'return'ing from the 'void run()'.\n\n<h3>void QuitNoKill();</h3>\n\nExits the current script entirely, and forcibly skips the de-allocating of objects 'Owned' by the script. Only use this if you know what you are doing!"
                        },
                        {
                            "name": "Waiting ;; Waitframe / Waitdraw / WaitTo / WaitEvent",
                            "val": "<h3>void Waitframe();</h3>\n\nWhen called, the script ends running for the current frame. The engine will proceed with one frame of gameplay before resuming this script at this position.\n\n<h3>void Waitdraw();</h3>\n\nWhen called the first time in a frame, the script ends running for a portion of time. The engine will proceed with <em>part</em> of a frame of gameplay, allowing other engine activities to occur, before resuming this script.\n\nIf called again, the additional call will act as a call to 'Waitframe()', as it cannot wait any more of the frame without the frame ending.\n\n<h3>void WaitTo(int timing, bool at_least = false);</h3>\nCan only be used in a passively-running ${genericdata|Generic Script}.\nWaits until it is the specified timing. If 'at_least == true', will not wait if it is already past that timing for the frame.\n\n#{Available Timings|\n<ol start=\"-1\">\n<li>SCR_TIMING_INIT</li>\n<li>SCR_TIMING_START_FRAME</li>\n<li>SCR_TIMING_POST_COMBO_ANIM</li>\n<li>SCR_TIMING_POST_POLL_INPUT</li>\n<li>SCR_TIMING_POST_FFCS</li>\n<li>SCR_TIMING_POST_GLOBAL_ACTIVE</li>\n<li>SCR_TIMING_POST_PLAYER_ACTIVE</li>\n<li>SCR_TIMING_POST_DMAPDATA_ACTIVE</li>\n<li>SCR_TIMING_POST_DMAPDATA_PASSIVESUBSCREEN</li>\n<li>SCR_TIMING_POST_COMBOSCRIPT</li>\n<li>SCR_TIMING_POST_PUSHBLOCK</li>\n<li>SCR_TIMING_POST_ITEMSPRITE_SCRIPT</li>\n<li>SCR_TIMING_POST_ITEMSPRITE_ANIMATE</li>\n<li>SCR_TIMING_POST_NPC_ANIMATE</li>\n<li>SCR_TIMING_POST_EWPN_ANIMATE</li>\n<li>SCR_TIMING_POST_EWPN_SCRIPT</li>\n<li>SCR_TIMING_POST_OLD_ITEMDATA_SCRIPT</li>\n<li>SCR_TIMING_POST_PLAYER_ANIMATE</li>\n<li>SCR_TIMING_POST_NEW_ITEMDATA_SCRIPT</li>\n<li>SCR_TIMING_POST_CASTING</li>\n<li>SCR_TIMING_POST_LWPN_ANIMATE</li>\n<li>SCR_TIMING_POST_DECOPARTICLE_ANIMATE</li>\n<li>SCR_TIMING_POST_COLLISIONS_PALETTECYCLE</li>\n<li>SCR_TIMING_WAITDRAW</li>\n<li>SCR_TIMING_POST_GLOBAL_WAITDRAW</li>\n<li>SCR_TIMING_POST_PLAYER_WAITDRAW</li>\n<li>SCR_TIMING_POST_DMAPDATA_ACTIVE_WAITDRAW</li>\n<li>SCR_TIMING_POST_DMAPDATA_PASSIVESUBSCREEN_WAITDRAW</li>\n<li>SCR_TIMING_POST_SCREEN_WAITDRAW</li>\n<li>SCR_TIMING_POST_FFC_WAITDRAW</li>\n<li>SCR_TIMING_POST_COMBO_WAITDRAW</li>\n<li>SCR_TIMING_POST_ITEM_WAITDRAW</li>\n<li>SCR_TIMING_POST_NPC_WAITDRAW</li>\n<li>SCR_TIMING_POST_EWPN_WAITDRAW</li>\n<li>SCR_TIMING_POST_LWPN_WAITDRAW</li>\n<li>SCR_TIMING_POST_ITEMSPRITE_WAITDRAW</li>\n<li>SCR_TIMING_PRE_DRAW</li>\n<li>SCR_TIMING_POST_DRAW</li>\n<li>SCR_TIMING_POST_STRINGS</li>\n<li>SCR_TIMING_END_FRAME</li>\n</ol>\n}\n\n<h3>int WaitEvent();</h3>\nCan only be used in a passively-running ${genericdata|Generic Script}.\nIs only used in conjunction with ${genericdata::EventListen|'EventListen[]'}. Waits until any event the script is listening to via ${genericdata::EventListen|`EventListen[] = true`} occurs. When such an event occurs, the function will return the event type, and ${EventData|Game->EventData[]} will be filled with information about the current event, much of which is modifiable."
                        },
                        {
                            "name": "Tile Functions ;; CopyTile / SwapTile / OverlayTile / ClearTile",
                            "val": "<h3>void CopyTile(int src, int dest);</h3>\nCopies tile 'src' to tile 'dest'.\n\n<h3>void OverlayTile(int src, int dest);<span class=\"vers\">   Since 2.53</span></h3>\nOverlays tile 'src' over tile 'dest'.\n\n<h3>void SwapTile(int a, int b);</h3>\nSwaps the tiles 'a' and 'b'.\n\n<h3>void ClearTile(int tile);</h3>\nClears the tile 'tile' to be blank.\n\n<h3>Note</h3>\nAll tile modifications are temporary, and will be reset when the quest is exited."
                        },
                        {
                            "name": "Distance / LongDistance",
                            "val": "<h3>float Distance(float x1, float y1, float x2, float y2);</h3>\n<h3>float Distance(float x1, float y1, float x2, float y2, int scale);</h3>\n\nCalculates the distance between two points, optionally using a scale divisor to handle distances that would otherwise overflow.\n\n<h3>long LongDistance(long x1, long y1, long x2, long y2);</h3>\n<h3>long LongDistance(long x1, long y1, long x2, long y2, long scale);</h3>\n\nSame as 'Distance()', but takes distances as 'long' coordinates, returning a 'long' distance value."
                        },
                        {
                            "name": "GetSystemTime ;; RTC ;; System Clock / Real Clock",
                            "val": "<h3>int GetSystemTime(int index);</h3>\n\nReturns information from the real-time clock of the system.\nValid values:\n<ol start=0>\n<li>RTC_YEAR: Returns the year</li>\n<li>RTC_MONTH: Returns the month, with 1 = January</li>\n<li>RTC_DAYOFMONTH: Returns the day of the month, 1-31</li>\n<li>RTC_DAYOFWEEK: Returns the day of the week, 1 = Sunday</li>\n<li>RTC_HOUR: Returns the current hour, 0-23</li>\n<li>RTC_MINUTE: Returns the current minute, 0-59</li>\n<li>RTC_SECOND: Returns the current second, 0-60 (only 60 for leap seconds on certain systems)</li>\n<li>RTC_DAYOFYEAR: Returns the day of the year, 0-365</li>\n<li>RTC_DAYLIGHTTIME: Returns a value based on DST. 0 indicates DST is not in effect, &gt;0 indicates it is, and &lt;0 indicates that the system does not know.</li>\n</ol>"
                        },
                        {
                            "name": "SRAM",
                            "val": "<h3>void SaveSRAM(char32[] [[filename|.zcsram]], int flags);\nvoid LoadSRAM(char32[] [[filename|.zcsram]], int flags);</h3>\n\nSaves/loads internal data (which is normally <em>temporarily</em> altered by scripts) of the types specified in 'flags'.\n\nFlags:\n<ul>\n<li>npcdata: 0x01</li>\n<li>itemdata: 0x02</li>\n<li>spritedata: 0x04</li>\n<li>combodata: 0x08</li>\n<li>dmapdata: 0x10</li>\n<li>mapdata: 0x20</li>\n</ul>\n\nFlags are OR'd together (ex. `0x01 | 0x02 | 0x04`). Passing '0' will use ALL flags.\n\nRelated: ${OnSaveLoad}, ${OnSave}"
                        },
                        {
                            "name": "OwnObject / GlobalObject",
                            "val": "<h3>void OwnObject([Object] obj);</h3>\nTakes an ${objects|Object} parameter. Grants ownership of the object to the currently running script.\nWhen the owning script dies, the owned object will be deleted.\n\nNote: Objects are already owned by the script that created them automatically, without needing to call this function.\n\n<h3>void GlobalObject([Object] obj);</h3>\nTakes an ${objects|Object} parameter. Globalizes the object, making it no longer owned by any script.\nGlobalized objects will be saved to the save file, and remain intact upon reloading.\nCalling 'OwnObject()' on a globalized object will undo this, returning it to script ownership."
                        }
                    ]
                },
                {
                    "name": "Math Functions",
                    "lines": [
                        {
                            "name": "&lt;-- Global Functions",
                            "val": "$-1$0"
                        },
                        {
                            "name": "<u>Math Functions</u> ;;GlobalMath;; Math Functions",
                            "val": "These functions relate to various mathematical operations."
                        },
                        {
                            "name": "Abs",
                            "val": "<h3>float Abs(float val);</h3>\n\nReturns the absolute value of the parameter."
                        },
                        {
                            "name": "Ceiling / Floor",
                            "val": "<h3>int Ceiling(float val);</h3>\nReturns 'val' rounded up to the next higher integer.\n\n<h3>int Floor(float val);</h3>\nReturns 'val' rounded down to the next lower integer."
                        },
                        {
                            "name": "Factorial",
                            "val": "<h3>int Factorial(int val);</h3>\n\nReturns 'val!'. Returns '0' for negative values."
                        },
                        {
                            "name": "Log10 / Ln",
                            "val": "<h3>float Log10(float val);</h3>\nReturns the log<sub>10</sub> of the value. Values &lt;= 0 return 0.\n\n<h3>float Ln(float val);</h3>\nReturns the natural log (log<sub>e</sub>) of the value. Values &lt;= 0  return 0."
                        },
                        {
                            "name": "Min / Max / Choose",
                            "val": "<h3>untyped Min([[...untyped args|Takes 2+ untyped args]]);</h3>\nReturns the <em>lowest</em> parameter.\n\n<h3>untyped Max([[...untyped args|Takes 2+ untyped args]]);</h3>\nReturns the <em>highest</em> parameter.\n\n<h3>untyped Choose([[...untyped args|Takes 1+ untyped args]]);</h3>\nReturns a random parameter, using the global RandGen."
                        },
                        {
                            "name": "Pow / InvPow",
                            "val": "<h3>int Pow(int base, int exp);</h3>\nReturns 'base<sup>exp</sup>', with '0<sup>0</sup>==1'. Negative values of 'exp' work, though may not be useful, as the return value is truncated to the nearest integer.\n\n<h3>int LPow(long base, long exp);</h3>\nReturns 'base<sup>exp</sup>', with '0<sup>0</sup>==1'. Negative values of 'exp' work, though may not be useful, as the return value is truncated to the nearest long.\n\n<h3>int InvPow(int base, int exp);</h3>\nReturns 'base<sup>(1/exp)</sup>', undefined if 'exp' is 0, or if 'exp' is even and 'base' is negative. Negative values of 'exp' work, though may not be useful, as the return value is truncated to the nearest integer."
                        },
                        {
                            "name": "Sqrt",
                            "val": "<h3>float Sqrt(float val);</h3>\n\nReturns the square root of the value. Undefined for negative values, and will return an error."
                        },
                        {
                            "name": "Trig Functions ;; Sin / Cos / Tan / ArcSin / ArcCos / ArcTan / RadianSin / RadianCos / RadianTan ;; Trig Functions",
                            "val": "<h3>float Sin(float deg);\nfloat Cos(float deg);\nfloat Tan(float deg);</h3>\nReturns the trig Sin/Cos/Tan of the degree value given.\n\n<h3>float RadianSin(float rad);\nfloat RadianCos(float rad);\nfloat RadianTan(float rad);</h3>\nReturns the trig Sin/Cos/Tan of the radian value given.\n\n<h3>float ArcSin(float x);\nfloat ArcCos(float x);\nfloat ArcTan(float x, float y);</h3>\nReturns the trig ArcSin/ArcCos/ArcTan of the value(s) given."
                        },
                        {
                            "name": "Angle Conversion ;; RadtoDeg / DegtoRad",
                            "val": "<h3>float DegtoRad(float deg);\nfloat RadtoDeg(float rad);</h3>\nConverts between degrees and radians."
                        }
                    ]
                },
                {
                    "name": "Logging Functions",
                    "lines": [
                        {
                            "name": "&lt;-- Global Functions",
                            "val": "$-1$0"
                        },
                        {
                            "name": "<u>Logging</u>;;GlobalLogging ;; Logging Functions",
                            "val": "These functions all relate to the ${Output Console}, and printing data to it."
                        },
                        {
                            "name": "Trace",
                            "val": "<h3>void Trace(untyped val);\nvoid Trace(long val);</h3>\n\nPrints the passed value to the ${Output Console|output console}. Includes a newline character after the value.\n\nIf a `long` val is passed, it prints the number with no decimal place (long format). Otherwise, it prints the number with 4 decimal places. "
                        },
                        {
                            "name": "TraceB",
                            "val": "<h3>void TraceB(untyped val);</h3>\n\nPrints the passed value to the ${Output Console|output console}, as \"true\" if the value is nonzero, or \"false\" if the value is 0. Includes a newline character after the value."
                        },
                        {
                            "name": "TraceS",
                            "val": "<h3>void TraceS(char32[] string);</h3>\n\nPrints the passed string to the ${Output Console|output console}. Does not include a newline character after the string."
                        },
                        {
                            "name": "TraceNL",
                            "val": "<h3>void TraceNL();</h3>\n\nPrints a newline character to the ${Output Console|output console}."
                        },
                        {
                            "name": "TraceToBase",
                            "val": "<h3>void TraceToBase(int val, int base, int mindigits);</h3>\n\nPrints the passed value to the ${Output Console|output console}, in the specified base, where \"2 &lt;= base &lt;= 36\". Value will be floored before print, so decimal values are not printed. Will print at least 'mindigits' digits, using leading 0s as needed. Includes a newline character after the value."
                        },
                        {
                            "name": "ClearTrace",
                            "val": "<h3>void ClearTrace();</h3>\n\nClears the logs from ${allegro.log}, and clears the ${output console}."
                        },
                        {
                            "name": "printf ;; printf / printfa",
                            "val": "<h3>void printf(char32[] format_string, [[...untyped args|Takes 0+ untyped args]]);</h3>\n<h3>void printfa(char32[] format_string, [[untyped[] args|Takes an array of untyped args]]);</h3>\n\nPrints the specified format_string to the ${Output Console|output console}, using the given args to fill in parts of the string that are specially marked. Does not include a newline character after the string.\n\nValid patterns:\n<ul>\n<li>'%i' or '%p': Inserts the value as an integer (no decimal places).</li>\n<li>'%f': Inserts the value as a float number (decimal places included)</li>\n<li>'%d': Acts as '%i' if all decimal places are '0', as '%f' otherwise.</li>\n<li>'%l': Inserts the value as a long (decimal places included, but no decimal point)</li>\n<li>'%s': Inserts the value as a string (must be a valid array pointer)</li>\n<li>'%c': Inserts the value as a character.</li>\n<li>'%x' or '%X': Inserts the value as a hexadecimal integer (no decimal places). Capitalization of letters matches the capitalization of the 'x'.</li>\n<li>'%b' or '%B': Inserts the value in Binary. 'b' has no decimal included, while 'B' uses all 32 bits as a long.</li>\n<li>'%a?': Inserts an array. Must be followed by another letter from this list, which will be used as the format for each element in the array. Ex: '%aB' inserts an array, where each index is inserted in long binary. '%04ad' inserts an array, where each element is a number of at least 4 digits.</li>\n<li>'%%': Inserts a single '%', does not act as a pattern.</li>\n</ul>\n\nAlso, by including numbers between the '%' and letter for patterns (excluding '%s', '%c', '%%'), it will take a minimum of that many digits, adding leading 0's as needed. Example: '%5i' given a value of '253' would display as '00253', filling up 5 digits of space. The max number of digits is 10, except in Binary ('%b','%B'), where it is 32.\n\nRelated: ${sprintf|sprintf()}"
                        }
                    ]
                },
                {
                    "name": "String Functions",
                    "lines": [
                        {
                            "name": "&lt;-- Global Functions",
                            "val": "$-1$0"
                        },
                        {
                            "name": "<u>String Functions</u> ;; GlobalString ;; String Functions",
                            "val": "These functions relate to the manipulation of strings."
                        },
                        {
                            "name": "Case Conversion ;; utol / ltou / convcase",
                            "val": "<h3>char32[] utol(char32[] string);\nchar32[] ltou(char32[] string);\nchar32[] convcase(char32[] string);</h3>\n\nReturns the string passed.\nConverts the capitalization of every letter in the string. Respectively, converting all to upper, all to lower, or inverting the case."
                        },
                        {
                            "name": "ilen",
                            "val": "<h3>int ilen(char32[] string);</h3>\n\nReturns the number of characters in the string that are taken up by a number (as would be read by ${atoi}, including negative sign);"
                        },
                        {
                            "name": "itoacat",
                            "val": "<h3>int itoacat(char32[] dest, int val);</h3>\n\nAppends the value 'val' on the end of the 'dest' string; combining ${itoa} with ${strcat}"
                        },
                        {
                            "name": "sprintf ;; sprintf / sprintfa",
                            "val": "<h3>void sprintf(char32[] dest, char32[] format_string, [[...untyped args|Takes 0+ untyped args]]);</h3>\n<h3>void sprintfa(char32[] dest, char32[] format_string, [[untyped[] args|Takes an array of untyped args]]);</h3>\n\nActs exactly as ${printf}, except instead of printing the result to the ${Output Console|output console}, it is instead placed in the 'dest' buffer. If the 'dest' buffer is too small, it will be resized to fit the contents."
                        },
                        {
                            "name": "strcat",
                            "val": "<h3>char32[] strcat(char32[] dest, char32[] src);</h3>\n\nAppends 'src' to the end of 'dest'. Returns 'dest'."
                        },
                        {
                            "name": "strcpy",
                            "val": "<h3>void strcpy(char32[] dest, char32[] src);</h3>\n\nCopies the string 'src' to 'dest'."
                        },
                        {
                            "name": "strcspn",
                            "val": "<h3>int strcspn(char32[] str, char32[] chars);</h3>\n\nReturns the length in 'str' before any character in 'chars' is found.\n\nRelated: ${strspn}"
                        },
                        {
                            "name": "String Comparison ;; strcmp / strncmp / stricmp / strnicmp",
                            "val": "<h3>int strcmp(char32[] str1, char32[] str2);\nint strncmp(char32[] str1, char32[] str2, int num_chars);\nint stricmp(char32[] str1, char32[] str2);\nint strnicmp(char32[] str1, char32[] str2, int num_chars);</h3>\n\nCompares the contents of the two strings.\nReturns '0' if the strings are equal. Otherwise, compares the first character that is different between the strings, returning &gt;0 if it is larger in str1, and &lt;0 if it is larger in str2.\n'strncmp' and 'strnicmp' only compares the first 'num_chars' characters.\n'stricmp' and 'strnicmp' compare case-insensitively."
                        },
                        {
                            "name": "String Searching ;; strchr / strrchr / strstr",
                            "val": "<h3>int strchr(char32[] str, char32 c);</h3>\n\nReturns the first index of 'str' that contains the character 'c'.\n\n<h3>int strrchr(char32[] str, char32 c);</h3>\n\nReturns the last index of 'str' that contains the character 'c'.\n\n<h3>int strstr(char32[] str, char32[] tofind);</h3>\n\nReturns the index of the first instance of the string 'tofind' within 'str'."
                        },
                        {
                            "name": "String to Value ;; atoi / xtoi",
                            "val": "<h3>int atoi(char32[] str);</h3>\n\nConverts a string containing a number to its' numeric value.\nEx. `atoi(\"0526\"); == 526`\n\n<h3>int xtoi(char32[] str);</h3>\n\nConverts a string containing a hexadecimal number to its' numeric value.\nEx. `xtoi(\"0x15\"); == 21`"
                        },
                        {
                            "name": "strlen",
                            "val": "<h3>int strlen(char32[] str);</h3>\n\nReturns the length of the string in characters."
                        },
                        {
                            "name": "strspn",
                            "val": "<h3>int strcspn(char32[] str, char32[] chars);</h3>\n\nReturns the length in 'str' until any character NOT in 'chars' is found.\n\nRelated: ${strcspn}"
                        },
                        {
                            "name": "Value to String ;; itoa / xtoa",
                            "val": "<h3>int itoa(char32[] dest, int val);</h3>\n\nConverts the value 'val' to a string, and places it in the 'dest'.\nEx. `itoa(dest, 72);` leaves the buffer holding `\"72\"`.\n\n<h3>int xtoa(char32[] dest, int val);</h3>\n\nConverts the value 'val' to a string, as hexadecimal, and places it in the 'dest'.\nEx. `xtoa(dest, 21);` leaves the buffer holding `\"0x15\"`."
                        }
                    ]
                },
                {
                    "name": "Array Functions",
                    "lines": [
                        {
                            "name": "&lt;-- Global Functions",
                            "val": "$-1$0"
                        },
                        {
                            "name": "<u>Array Functions</u> ;; GlobalArray ;; Array Functions",
                            "val": "These functions relate to arrays."
                        },
                        {
                            "name": "ArrayCopy",
                            "val": "<h3>void ArrayCopy(untyped[] dest, untyped[] src);</h3>\n\nCopies all data from 'src' to 'dest'. If the arrays are not the same size, the smaller size is used, and the excess in the larger array is ignored."
                        },
                        {
                            "name": "IsValidArray",
                            "val": "<h3>bool IsValidArray(untyped[] arr);</h3>\n\nReturns true if the value 'arr' points to a valid array."
                        },
                        {
                            "name": "SizeOfArray",
                            "val": "<h3>int SizeOfArray(untyped[] arr);</h3>\n\nReturns the size of the array"
                        },
                        {
                            "name": "ResizeArray",
                            "val": "<h3>void ResizeArray(untyped[] arr, int size);</h3>\n\nResizes the array 'arr' to size 'size'. If 'size' is &lt;1, the array becomes size 1 instead."
                        },
                        {
                            "name": "OwnArray / DestroyArray",
                            "val": "<h3>void OwnArray(untyped[] arr);</h3>\nGrants ownership of the target array to the currently running script.\nIf this array is not a local array, nothing happens.\nIf it is a local array, the array will no longer be destroyed when it reaches the end of its' declaring scope- it will last until the owning script ends, at which point it will be freed.\n\n<h3>void DestroyArray(untyped[] arr);</h3>\nIf 'arr' is a local array, destroys it immediately. Otherwise does nothing."
                        },
                        {
                            "name": "Push / Pop ;; ArrayPushBack / ArrayPushFront / ArrayPushAt / ArrayPopBack / ArrayPopFront / ArrayPopAt",
                            "val": "<h3>bool ArrayPushBack(untyped[] arr, untyped val);\nbool ArrayPushFront(untyped[] arr, untyped val);\nbool ArrayPushAt(untyped[] arr, untyped val, int indx);</h3>\n\nIncreases the size of the array by 1, inserting 'val' at the back/front/specified index of the array. If an invalid index is passed, the back of the array will be targetted.\nReturns false if it fails for any reason, such as the array being max-sized already.\n\n<h3>untyped ArrayPopBack(untyped[] arr);\nuntyped ArrayPopFront(untyped[] arr);\nuntyped ArrayPopAt(untyped[] arr, int indx);</h3>\n\nDecreases the size of the array by 1, removing and returning the element at the back/front/specified index of the array. If an invalid index is passed, the back of the array will be targetted.\nErrors and returns `-1` if the array is size 0."
                        }
                    ]
                }
            ]
        },
        {
            "name": "FFC",
            "tabs": [
                {
                    "name": "FFC ROOT",
                    "lines": [
                        {
                            "name": "&lt;-- Data Pointers ;; function_data",
                            "val": "$0$4"
                        },
                        {
                            "name": "<em>ffc</em>",
                            "val": "<h3>FFC Pointers</h3>   `ffc`\n\nThese pointers represent the 32 Freeform Combos on the current screen, and their various attributes and functions.\nUsing these pointers, you can move them, change their combo, change their script, etc.\n\nSee: ${LoadFFC}"
                        },
                        {
                            "name": "Position ;; ffcPosition / ffc::X / ffc::Y",
                            "val": "<h3>int X; int Y;</h3>\n\nRead/Write; These values store the ffc's position on each of the two axes; FFCs do not have a 'Z' position.\nValues may contain up to 4 decimal places, regardless of QRs."
                        },
                        {
                            "name": "Data / CSet ;; ffc::Data / ffc::CSet",
                            "val": "<h3>int Data;</h3>\nThe combo used by the FFC for its' visuals and type.\n\n<h3>int CSet;</h3>\nThe CSet the FFC displays in."
                        },
                        {
                            "name": "Size ;; ffc::TileHeight / ffc::TileWidth / ffc::EffectHeight / ffc::EffectWidth",
                            "val": "<h3>int TileHeight; int TileWidth;</h3>\nThe visual size, in tiles (1 to 4), of the FFC. The tile set by its' combo will be the upper-left tile, with the rest drawn as a tile block from there.\n\n<h3>int EffectHeight; int EffectWidth;</h3>\nThe hitbox size, in pixels (1 to 64), of the FFC. Unless the FFC is ${FFC::Flags|Ethereal}, the type of its' combo will affect this area. NOTE: Not all combo types function when placed on FFCs."
                        },
                        {
                            "name": "Scripts ;; ffc::Script / ffc::InitD / ffc::Misc",
                            "val": "<h3>int Script;</h3>\nThe FFC script ID running on this FFC.\n\n<h3>untyped InitD[8];</h3>\nThe 8 InitD[] parameters for the FFC's script.\n\n<h3>untyped Misc[16];</h3>\nA miscilaneous data array, for script use."
                        },
                        {
                            "name": "Movement ;; ffcMovement / ffc::Vx / ffc::Vy / ffc::Ax / ffc::Ay / ffc::Delay",
                            "val": "<h3>int Vx; int Vy;</h3>\nThe FFC's current X and Y axis velocities.\n\n<h3>int Ax; int Ay;</h3>\nThe FFC's current X and Y axis accelerations.\n\n<h3>int Delay;</h3>\nThe time in frames before the FFC will begin moving.\n\n"
                        },
                        {
                            "name": "Flags ;; ffc::Flags",
                            "val": "<h3>int Flags[14];</h3>\nThe FFC's flags.\n\nValues representing FFC flags:\n<ol start='0'><li>[[FFCF_OVERLAY|Draws between layers 4 and 5 if enabled]]</li>\n<li>[[FFCF_TRANS|Draws transparently if enabled]]</li>\n<li>[[FFCF_SOLID|Makes the FFC behave as entirely solid. [NOT FULLY IMPLEMENTED]]</li>\n<li>[[FFCF_CARRYOVER|If enabled, the FFC will carry between screens, replacing the FFC that is of the same index on any screen it is brought to.]]</li>\n<li>[[FFCF_STATIONARY|Ignores movement attributes if enabled.]]</li>\n<li>[[FFCF_CHANGER|Changes other FFCs that come into contact with this one]]</li>\n<li>[[FFCF_PRELOAD|The FFC's script will run for one frame before scrolling onto its' screen.]]</li>\n<li>[[FFCF_LENSVIS|The FFC is invisible unless you are using a Lens of Truth.]]</li>\n<li>[[FFCF_RESET|When the FFC is carried over to a new screen, its' script will restart.]]</li>\n<li>[[FFCF_ETHEREAL|The FFC will not apply its' combo's 'Type' effects, nor block the types of combos under it.]]</li>\n<li>[[FFCF_IGNOREHOLDUP|The FFC continues to run while the player is holding an item up.]]</li>\n<li>[[FFCF_IGNORECHANGER|The FFC will ignore changer FFCs.]]</li>\n<li>[[FFCF_IMPRECISIONCHANGER|The FFC will collide with changer FFCs when it is on the same whole pixel to them, rather than requiring the exact same subpixel.]]</li>\n<li>[[FFCF_LENSINVIS|The FFC is invisible while using the lens of truth.]]</li></ol>"
                        },
                        {
                            "name": "Link ;; ffc::Link",
                            "val": "<h3>int Link;</h3>\nRepresents the ID of another FFC this one is 'linked' to."
                        },
                        {
                            "name": "ID ;; ffc::ID",
                            "val": "<h3>int ID;</h3>\nRead-only: the screen index of the FFC."
                        },
                        {
                            "name": "Owning ;; ffc::Own / ffc::OwnArray / ffc::OwnObject",
                            "val": "<h3>void Own(bitmap b);\nvoid Own(paldata pd);\nvoid Own(stack st);\nvoid Own(file f);\nvoid Own(directory dir);\nvoid Own(randgen rnd);\nvoid OwnArray(untyped[] array);\nvoid OwnObject([Object] object);</h3>\n\nGrants 'Ownership' of the parameter object to the ffc."
                        }
                    ]
                }
            ]
        },
        {
            "name": "GenericData",
            "tabs": [
                {
                    "name": "GenericData ROOT",
                    "lines": [
                        {
                            "name": "&lt;-- Misc Data Pointers ;; function_data_misc",
                            "val": "$0$6"
                        },
                        {
                            "name": "<em>genericdata</em>",
                            "val": "<h3>GenericData Pointers</h3>   `genericdata`\n\n`genericdata` pointers allow interacting with and running `generic` scripts.\n\nSee: ${Game::LoadGenericData|LoadGenericData}, ${WaitTo}, ${WaitEvent}"
                        },
                        {
                            "name": "Script Running ;; genericdata::Running / genericdata::RunFrozen / genericdata::ExitState / genericdata::ReloadState",
                            "val": "<h3>bool Running;</h3>\nWhen read, returns true if the script is currently running passively.\nIf written false, kills the script. If written true, launches (or restarts) the script.\n\n<h3>bool RunFrozen();</h3>\nAttempt to run the generic script in frozen mode.\nReturns true if successful, false otherwise.\nIf successful, the script will run until it exits, with everything else in the engine frozen, including all other scripts.\n\n<h3>bool ExitState[GENSCR_NUMST];\nbool ReloadState[GENSCR_NUMST];</h3>\nArrays of exit and reload conditions. All states default to 'false'.\nIf an exitstate is true, when the associated condition is met, the script will exit entirely.\nIf a reloadstate is true, when the associated condition is met, the script will restart from the start if it was already running.\n\nAvailable states:\n<ol start=\"0\"><li>[[GENSCR_ST_RELOAD|Will exit or reload on starting from the title screen if true. NOTE: Even if reload is false, scripts will reload on this condition.]]</li>\n<li>[[GENSCR_ST_CONTINUE|Will exit or reload upon 'F6->Continue', or an effect which mimics 'F6->Continue'.]]</li>\n<li>[[GENSCR_ST_CHANGE_SCREEN|Will exit or reload upon changing screens]]</li>\n<li>[[GENSCR_ST_CHANGE_DMAP|Will exit or reload upon changing dmaps]]</li>\n<li>[[GENSCR_ST_CHANGE_LEVEL|Will exit or reload upon changing dmap levels]]</li></ol>"
                        },
                        {
                            "name": "Event Listening ;; genericdata::EventListen",
                            "val": "<h3>bool EventListen[GENSCR_NUMEVENT];</h3>\nArray of event listener conditions. When ${WaitEvent|WaitEvent()} is called, the script will wait until any event which has a value of 'true' in this array occurs.\nDefaults to all false.\n\nSee: ${WaitEvent}, ${EventData}\n\nAvailable states:\n<ol start=\"0\"><li>[[GENSCR_EVENT_INIT|When loading from a save or starting a new quest]]</li>\n<li>[[GENSCR_EVENT_CONTINUE|When 'F6->Continue' occurs, before conditions have been reset.]]</li>\n<li>[[GENSCR_EVENT_FFC_PRELOAD|The 'FFC runs on Screen Init' timing]]</li>\n<li>[[GENSCR_EVENT_CHANGE_SCREEN|When the screen changes]]</li>\n<li>[[GENSCR_EVENT_CHANGE_DMAP|When the dmap changes]]</li>\n<li>[[GENSCR_EVENT_CHANGE_LEVEL|When the level changes]]</li>\n<li>[[GENSCR_EVENT_HERO_HIT_1|When the player is hit, before ring defense is applied]]</li>\n<li>[[GENSCR_EVENT_HERO_HIT_2|When the player is hit, after ring defense is applied]]</li>\n<li>[[GENSCR_EVENT_COLLECT_ITEM|When an item is collected]]</li>\n<li>[[GENSCR_EVENT_ENEMY_DROP_ITEM_1|When an enemy drops an item, before it creates an item]]</li>\n<li>[[GENSCR_EVENT_ENEMY_DROP_ITEM_2|When an enemy drops an item, after the item is created (only if 'Nothing' isn't chosen)]]</li>\n<li>[[GENSCR_EVENT_ENEMY_DEATH|An enemy dies]]</li>\n<li>[[GENSCR_EVENT_ENEMY_HIT1|When an enemy is hit, before defenses]]</li>\n<li>[[GENSCR_EVENT_ENEMY_HIT2|When an enemy is hit, after defenses]]</li>\n<li>[[GENSCR_EVENT_POST_COLLECT_ITEM|After an item is collected (After the holdup animation completes, if held)]]</li></ol>"
                        },
                        {
                            "name": "Data Storage ;; genericdata::InitD / genericdata::Data / genericdata::DataSize",
                            "val": "<h3>untyped InitD[8];</h3>\nThe 8 InitD[] parameters for the generic script. Shared by passive and frozen run modes.\n\n<h3>int DataSize;</h3>\nRead/write; the size of the script's Data array (see below). Writing this resizes the array, where any area above the previous maximum is cleared to '0'.\nDefaults to size '0'.\n\n<h3>untyped Data[DataSize];</h3>\nA misc data array, resizable by writing to DataSize (see above). All indexes are saved with the save file, including any resizing."
                        }
                    ]
                }
            ]
        },
        {
            "name": "File",
            "tabs": [
                {
                    "name": "File ROOT",
                    "lines": [
                        {
                            "name": "&lt;-- Managed Pointers ;; function_data_managed",
                            "val": "$0$7"
                        },
                        {
                            "name": "<em>file</em>",
                            "val": "<h3>File Pointers</h3>   `file`\n\n`file` pointers allow directly interacting with files on the user's system.\nEach quest has a directory created at `[zc root]/files/[quest name]/`, and ONLY files within this directory are accessible. All paths are relative to this directory.\n\nThere is no 'LoadFile' function. To load a file, declare a variable of type 'file', and call ${file::Open|Open()}, ${file::Create|Create()}, or ${file::OpenMode|OpenMode()} to open a file to it.\n\nGeneral info about filesystem access:\nFiles opened with '${file::Open|Open()}' or '${file::Create|Create()}', as well as some modes passed to '${file::OpenMode|OpenMode()}', can be Read/Write. In a Read/Write mode, you must call one of a few certain functions between a read call and a write call. These functions will list this effect in their description.\n\nWriting to files does not write directly to disk, but to a buffer. It is guaranteed that the contents of this buffer will be written to disk upon a successful call to '${file::Flush|Flush()}', or upon the closing of the file. Upon exiting the quest, all open files are closed.\n\nThere is a limit of 256 file pointers. A pointer does not need to have a file open to count against this limit. Any pointer that returns true from '${file::isAllocated|isAllocated()}' counts against this limit. Calling '${file::Free|Free()}' will deallocate a pointer, thus no longer counting against this limit. If you open many files without calling '${file::Free|Free()}', you may run out of pointers, and be unable to open further files (until you call '${file::Free|Free()}' on some existing pointers).\n\nFiles are NOT automatically freed if they fall out of scope. You should be sure to manually call '${file::Free|Free()}' before this happens, or you may lose the pointer, and be unable to free it later. Using ${file::Own|Own()}, you can set a file pointer to automatically free when the calling script exits.\n\nRemember: POSIX filesystems are Case-SenSitive. "
                        },
                        {
                            "name": "File Opening ;; file::Open / file::Create / file::OpenMode",
                            "val": "<h3>bool Open(char32[] \"filepath\");\nbool Create(char32[] \"filepath\");</h3>\nIf the file pointer is not allocated, these will allocate it. Also closes any file that is already open on the pointer.\nAttempts to open \"[zc root]/files/[questname]/[filepath]\", in mode 'rb+' for 'Open()' or 'wb+' for 'Create()'.\nOpen will fail if the file does not exist; Create will create it if it does not exist, and wipe the file clean if it does exist.\n\n<h3>bool OpenMode(char32[] \"filepath\", char32[] \"mode_string\");</h3>\nIf the file pointer is not allocated, this will allocate it. Also closes any file that is already open on the pointer.\nSame as 'Open()', but the file is opened with the specified mode.\nValid modes (details taken from <a href=\"http://www.cplusplus.com/reference/cstdio/fopen\" target = \"_blank\">http://www.cplusplus.com/reference/cstdio/fopen/</a>):\n    \"r\"  | read: Open file for input operations. The file must exist.\n    \"w\"  | write: Create an empty file for output operations. If a file\n           with the same name already exists, its contents are discarded\n           and the file is treated as a new empty file.\n    \"a\"  | append: Open file for output at the end of a file. Output operations\n           always write data at the end of the file, expanding it. Repositioning\n           operations ('${file::Seek|Seek()}', '${file::Rewind|Rewind()}') are ignored. The file is created if\n           it does not exist.\n    \"r+\" | read/update: Open a file for update (both for input and output). The\n           file must exist.\n    \"w+\" | write/update: Create an empty file and open it for update (both for\n           input and output). If a file with the same name already exists its\n           contents are discarded and the file is treated as a new empty file.\n    \"a+\" | append/update: Open a file for update (both for input and output)\n           with all output operations writing data at the end of the file.\n           Repositioning operations (fseek, fsetpos, rewind) affects the next\n           input operations, but output operations move the position back to the\n           end of file. The file is created if it does not exist.\n\nThe letter \"b\" can be added to the end of any of these (or before the \"+\", for update modes)\n    to specify a binary file mode. Not doing this will specify a text file mode.\nText files are files containing sequences of lines of text. Depending on the environment\n    where the application runs, some special character conversion may occur in input/output\n    operations in text mode to adapt them to a system-specific text file format. Although\n    on some environments no conversions occur and both text files and binary files are\n    treated the same way, using the appropriate mode improves portability."
                        },
                        {
                            "name": "Remove ;; file::Remove",
                            "val": "<h3>bool Remove();</h3>\nDeletes the file. This will close it, as with ${file::Close|Close()}, and then delete it from the filesystem.\nReturns true if successful. The file will be closed, even if the removal fails."
                        },
                        {
                            "name": "File Pointer Management ;; file::Flush / file::Close / file::Free / file::Own / file::isAllocated / file::isValid",
                            "val": "<h3>bool Flush();</h3>\nFlushes the buffer of the file being written to.\nWrites to a file do not actually write to the file immediately; they instead go to a buffer. Calling this function will force the buffer to be written to disk.\n\n<h3>void Close();</h3>\nCloses any open file connected to the file pointer (which also includes 'Flush()'). Does *NOT* deallocate the pointer, it is still reserved to open new files on.\n\n<h3>void Free();</h3>\nCloses any file as 'Close()', then deallocates the file pointer so it may be re-used.\n\n<h3>void Own();</h3>\nGrants 'Ownership' of the file pointer to the script that calls this function. When the script with 'Ownership' terminates (at the same time its' local arrays are deallocated), this file pointer will automatically be 'Free()'d.\n\n<h3>bool isAllocated();</h3>\nReturns true if this pointer is allocated. This does not necessarily mean a file is open, just that the pointer has a reserved ID.\n<h3>bool isValid();</h3>\nReturns true if a file is open on the pointer.\n\n<h3>bool Allocate();</h3>\nAttempts to allocate the file pointer. If it was already allocated, this will re-allocate it without freeing it!\nReturns true if successful, false if the max number of files is already allocated."
                        },
                        {
                            "name": "File Reading ;; file::ReadString / file::ReadChars / file::ReadBytes / file::ReadInts / file::GetChar / file::UngetChar",
                            "val": "<h3>int ReadString(char32[] buf);</h3>\nReads a section of characters from the file.\nWill read either until 'buf' is full, an error occurs, End of File is reached, or a newline character is reached.\nIf it ends due to reaching a newline character, the newline character will be included at the end of the string.\nReturns the length of the string read into 'buf'.\n\n<h3>int ReadChars(char32[] buf, int count = -1, int pos = 0);</h3>\nReads a section of characters from the file.\nStarts placing characters at 'buf[pos]'. If 'pos' is negative, starts at 'buf[0]'.\nIf 'count' is 0, does nothing and returns 0.\nIf 'count' is negative, reads until it fills 'buf', an error occurs, or End of File is reached.\nIf 'count' is positive, reads 'count' characters into 'buf'.\nWill always add a null character at the end of the read characters.\nReturns the number of characters read, excluding the added null character.\n\n<h3>int ReadBytes(untyped[] buf, int count = -1, int pos = 0);</h3>\nReads a section of binary data from the file.\nStarts placing data at 'buf[pos]'. If 'pos' is negative, starts at 'buf[0]'.\nIf 'count' is 0, does nothing and returns 0.\nIf 'count' is negative, reads until it fills 'buf', an error occurs, or End of File is reached.\nIf 'count' is positive, reads 'count' characters into 'buf'.\nThe binary data read will be 8b; such that reading '1' will place '1' into buf. This means that the binary data cannot contain decimal places.\nReturns the number of bytes read.\n\n<h3>int ReadInts(untyped[] buf, int count = -1, int pos = 0);</h3>\nReads a section of binary data from the file.\nStarts placing data at 'buf[pos]'. If 'pos' is negative, starts at 'buf[0]'.\nIf 'count' is 0, does nothing and returns 0.\nIf 'count' is negative, reads until it fills 'buf', an error occurs, or End of File is reached.\nIf 'count' is positive, reads 'count' characters into 'buf'.\nThe binary data read will be 32b; such that reading '1' will place '0.0001' into buf. This means that the binary data can contain decimal places.\nReturns the number of ints read.\n\n<h3>char32 GetChar();</h3>\nReads and returns the next character in the file.\nReturns -1 if it fails; check 'EOF' and 'Error' to see why.\n<h3>char32 UngetChar(char32 c);</h3>\nUn-reads 'c' to the input stream.\nReturns -1 if it fails; otherwise returns 'c'.\nThis is a READ operation, not a WRITE operation. The file will not actually be modified; but further read operations will find this as the next character to be read.\nUseful if you read a character, then realize you don't want it."
                        },
                        {
                            "name": "File Writing ;; file::WriteString / file::WriteChars / file::WriteBytes / file::WriteInts / file::PutChar",
                            "val": "<h3>int WriteString(char32[] str);</h3>\nWrites the string stored in 'str' to the file.\nReturns the number of characters successfully written.\n\n<h3>int WriteChars(char32[] buf, int count = -1, int pos = 0);</h3>\nWrites characters from 'buf' to file.\nStarts at 'buf[pos]'. If 'pos' is negative, starts at 'buf[0]'.\nIf 'count' is 0, does nothing and returns 0.\nIf 'count' is negative, writes from 'buf' until it finds a null character, or reaches the end of 'buf'.\nIf 'count' is positive, writes 'count' characters from buf.\nReturns the number of characters successfully written.\n\n<h3>int WriteBytes(untyped[] arr, int count = -1, int pos = 0);</h3>\nWrites 8b binary data from 'arr' to file.\nThe binary data written will be 8b; such that writing '1' will write '1' to file. This means that the binary data cannot contain decimal places.\nStarts at 'arr[pos]'. If 'pos' is negative, starts at 'arr[0]'.\nIf 'count' is 0, does nothing and returns 0.\nIf 'count' is negative, writes from 'arr' until it reaches the end of 'arr'.\nIf 'count' is positive, writes 'count' ints from arr.\nReturns the number of bytes successfully written.\n\n<h3>int WriteInts(untyped[] arr, int count = -1, int pos = 0);</h3>\nWrites 32b binary data from 'arr' to file.\nThe binary data written will be 32b; such that writing '1' will write '10000' to file. This means that the binary data can contain decimal places; writing '0.0001' will write '1' to file.\nStarts at 'arr[pos]'. If 'pos' is negative, starts at 'arr[0]'.\nIf 'count' is 0, does nothing and returns 0.\nIf 'count' is negative, writes from 'arr' until it reaches the end of 'arr'.\nIf 'count' is positive, writes 'count' ints from arr.\nReturns the number of 32b integers successfully written.\n\n<h3>char32 PutChar(char32 c);</h3>\nWrites 'c' to file.\nReturns -1 if it fails; otherwise returns 'c'."
                        },
                        {
                            "name": "File Position ;; file::Pos / file::Seek / file::Rewind",
                            "val": "<h3>long Pos;</h3>\nRead-only. This represents the current position in the file.\nIn binary modes ('Open()', 'Create()', or 'OpenMode()' including \"b\"), this is the number of bytes into the file, as a long; i.e. '10L' == 10 bytes.\nIn text modes ('OpenMode()' not including \"b\"), the numerical value may not be meaningful but can still be used to restore the position to the same position later using 'Seek()' (if there are characters put back using 'UngetChar()' still pending of being read, the behavior is undefined).\n\n<h3>bool Seek(long pos, bool from_current = false);</h3>\nMoves the current position of the file.\n'pos' is a 32b value, where '1L' represents 1 byte; similar to 'Pos'.\nIf 'from_current' is true, it moves forward from the current position.\nOtherwise, it moves so that 'Pos' is equal to 'pos'.\nUsing 'from_current'==true in a file open in text mode ('OpenMode()' not including \"b\") is undefined.\nReturns true if successful, false otherwise.\nIf successful, this function has the following side-effects:\n<ul><li>All previous calls to 'UngetChar()' are dropped.</li>\n<li>The 'EOF' indicator is set to false.</li>\n<li>Allows switching between reading and writing on a read/write file.</li></ul>\n\n<h3>void Rewind();</h3>\nRewinds to the beginning of the file.\nThis function has the following side-effects:\n<ul><li>All previous calls to 'UngetChar()' are dropped.</li>\n<li>The 'EOF' indicator is set to false.</li>\n<li>The 'Error' indicator is set to 0.</li>\n<li>Allows switching between reading and writing on a read/write file.</li></ul>"
                        },
                        {
                            "name": "File Status ;; file::EOF / file::Error / file::ClearError / file::GetError",
                            "val": "<h3>bool EOF;</h3>\nRead-Only. Returns true if a read call attempted to read past the end of the file.\nIf true, no further read calls will succeed until the position has been changed; i.e. 'Seek()' or 'Rewind()'.\n\n<h3>int Error;</h3>\r\nRead-Only. Returns 0 if the file has not enountered an error.\r\nIf an error was encountered, returns an error code number.\n\n<h3>void ClearError();</h3>\r\nClears the active EOF and Error indicators.\r\ni.e. this writes 'EOF = false;' and 'Error = 0;'.\n\n<h3>void GetError(char32[] buf);</h3>\r\nStores a string describing the current error into the buffer provided.\r\nStores an empty string if 'Error == 0'."
                        }
                    ]
                }
            ]
        },
        {
            "name": "Directory",
            "tabs": [
                {
                    "name": "Directory ROOT",
                    "lines": [
                        {
                            "name": "&lt;-- Managed Pointers ;; function_data_managed",
                            "val": "$0$7"
                        },
                        {
                            "name": "<em>directory</em>",
                            "val": "<h3>Directory Pointers</h3>   `directory`\n\n`directory` pointers allow interacting with directories on the user's system.\nEach quest has a directory created at \"[zc root]/files/[quest name]/\", and ONLY directories within this directory are accessible. All paths are relative to this directory.\n\nSee: ${LoadDirectory}"
                        },
                        {
                            "name": "Access ;; directory::Size / directory::GetFilename / directory::Reload",
                            "val": "<h3>int Size;</h3>\nRead-only. The number of files/folders contained in the directory.\n\n<h3>bool GetFilename(int index, char32[] buf);</h3>\nLoads the name of the 'index' file (0 <= index < Size)\nThe name will be placed in the buffer\nReturns true if successful, false if it fails.\n\n<h3>void Reload();</h3>\nRefreshes the directory, updating the 'Size' and results of 'GetFilename()' to reflect any changes."
                        },
                        {
                            "name": "Pointer Management ;; directory::Free / directory::Own",
                            "val": "<h3>void Free();</h3>\nThis will deallocate the directory pointer, so that the pointer ID may be re-used.\nThere is a limit to how many directory pointers may be allocated at once, so be sure to free them when you are no longer using them.\n\n<h3>void Own();</h3>\nGrants 'Ownership' of the directory pointer to the script that calls this function. When the script with 'Ownership' terminates (at the same time its' local arrays are deallocated), this directory pointer will automatically be 'Free()'d."
                        }
                    ]
                }
            ]
        },
        {
            "name": "Hero",
            "tabs": [
                {
                    "name": "Hero 1",
                    "lines": [
                        {
                            "name": "&lt;-- Global Pointers ;; function_globalptr",
                            "val": "$Base Data$3"
                        },
                        {
                            "name": "<em>Hero</em>",
                            "val": "The `Hero->` pointer holds various data and functions related to the player character.\n\n`Player->` is an alternate token, which accesses the same functions."
                        },
                        {
                            "name": "State ;; Hero::Position / Hero::Jump / Hero::Dir / Hero::Action / Hero::Climbing / Hero::JumpCount / Hero::HammerState",
                            "val": "<h3>int X; int Y; int Z;</h3>\nRead/Write; These values store the player's position on each of the three axes.\nIf the quest rule [['Sprite Coordinates are Float'|at \"ZScript->Quest Script Settings->Object\"]] is checked, these values can include up to 4 decimal places; otherwise values are truncated to int.\n\n<h3>int Jump;</h3>\nThe speed, in pixels per frame, that the Hero is moving upwards along the Z axis.\n\nUnless on the ground, the quest's Gravity is subtracted from this each frame (until it is lower than the terminal velocity value).\n\n<h3>int Dir;</h3>\nThe direction the Hero is facing. The Hero may not face diagonally.\n\n<h3>int HitDir;</h3>\nThe direction the Hero is currently being knocked back, if they are being knocked back.\n\n<h3>int Action;</h3>\nRepresents the Hero's current action state. Writing to this may cause various effects to occur, depending on what the value was previously, and what the new value is.\n\nUse the `LA_` constants to access this.\n\n<h3>int FakeZ;</h3>\nThe Hero's current FakeZ axis position. This value is treated as a second, separate Z axis;\nSprites will be offset upwards by this amount when drawn just like the Z axis and shadows will draw if applicable; however, the sprite's hitbox will not be moved upwards into the Z Axis; instead it will be moved upwards on the Y axis, mimicking how Vires and Pols Voice worked in the original Zelda.\nThis value is affected by 'FakeJump' instead of 'Jump'.\n \n<h3>int FakeJump;</h3>\nThe current velocity on the FakeZ axis. This value is added to FakeZ every frame; and this value is decreased by the gravity value until it is lower than the terminal velocity value.\n\n<h3>bool Climbing;</h3>\nIf true, the Hero is currently holding onto a Sideview Ladder.\n\n<h3>bool JumpCount;</h3>\nThe number of jumps the player has jumped in mid-air since the last time they landed.\nIf positive, resets to 0 when landing.\nRoc's Feathers allow you to jump in mid-air if this is less than the Extra Jumps count of the feather item.\n\n<h3>bool Standing;</h3>\nRead-only. Returns true if the Hero is standing on the ground.\n\n<h3>int CoyoteTime;</h3>\nThe number of frames the Hero has been off the ground, max 65535.\nIf the Hero jumps, immediately sets this value to 65535.\nIf this value is not 65535 and is less than a Feather item's Coyote Time value, that feather can be used to jump, even in mid-air.\n\n<h3>int HammerState;</h3>\nRead-only. Returns a value representing the current hammer swing.\n<ol start = 0><li>Not swinging hammer</li>\n<li>Hammer above head</li>\n<li>Hammer at angle</li>\n<li>Hammer hit the ground</li></ol>"
                        },
                        {
                            "name": "Equipped Items ;; Hero::ItemA / Hero::ItemB / Hero::ItemX / Hero::ItemY / HeroButtonItems / Hero::SetEquipmentA / Hero::SetEquipmentB / Hero::SetEquipmentX / Hero::SetEquipmentY",
                            "val": "<h3>int ItemA;\nint ItemB;\nint ItemX;\nint ItemY;</h3>\nWhen reading these values, returns the item ID currently equipped to the given button. Returns '-1' if no item is equipped.\nWhen writing a value other than '-1', forcibly equips the given item to the given button (force-equip may or may not play nicely with engine active subscreens?).\nWriting '-1' will un-force-equip an item.\n\n<h3>void SelectAWeapon(int dir);\nvoid SelectBWeapon(int dir);\nvoid SelectXWeapon(int dir);\nvoid SelectYWeapon(int dir);</h3>\nChanges the item equipped to the given button, as though the engine subscreen selection was moved in the specified direction. DIR_RIGHT and DIR_LEFT for this work the same way as the engine's item quickswap right/left."
                        },
                        {
                            "name": "Status Effects ;; Hero::SwordJinx / Hero::ItemJinx / Hero::ShieldJinx / Hero::Stun / Hero::Drunk / Hero::Eaten / Hero::ClockActive / Hero::ClockTimer / Hero::Grabbed / Hero::BunnyClk",
                            "val": "<h3>int SwordJinx;\nint ItemJinx;\nint ShieldJinx;</h3>\nRepresents the duration of the Jinx status effects. The sword jinx prevents the Hero from using their sword, while the Item jinx prevents using all other items. The Shield jinx prevents both active and passive blocking via shields.\n\nIf the value is '-1', the jinx is currently active, with no timer.\nIf the value is '> 0', the jinx is currently active, with that many frames remaining until it wears off on its' own.\n\n<h3>int Stun;</h3>\nRepresents the remaining duration of the Stun effect on the player. While stunned, the player cannot do almost anything.\n\n<h3>int BunnyClk;</h3>\nRepresents the duration of the Bunny effect.\n\nIf the value is '>0', the player is a Bunny for that many frames.\nIf the value is '-1', the bunny effect is based on the current dmap being a bunny dmap, and the player not having a Pearl item.\nValues '-2' to '-99' are reserved for future engine use.\nIf the value is '<= -100', the player will remain a bunny until a script changes this.\n\n<h3>bool ClockActive;</h3>\nIf true, a 'Clock' item is active, rendering the player invincible and freezing all enemies.\n<h3>int ClockTimer;</h3>\nThe remaining time on the 'Clock' effect. If this is 0, but 'ClockActive' is true, then the effect lasts until screen change.\n\n<h3>int Drunk;</h3>\nThe value represents the duration of the Drunk status affect, and also affects the intensity of the effect. While active, messes with the players controls, randomly toggling their input (either pressing buttons they did not press, or un-pressing buttons they did press). The longer duration remaining, the higher the rate of input interference.\n\n<h3>int Eaten;</h3>\nThe duration the player has been eaten (i.e. LikeLike) for, 0 if not eaten.\n\n<h3>bool Grabbed;</h3>\nTrue if the player has been grabbed (i.e. Wallmaster)"
                        },
                        {
                            "name": "HP / MP ;; Hero::HP / Hero::MP / Hero::MaxHP / Hero::MaxMP",
                            "val": "<h3>int HP; int MP;\nint MaxHP; int MaxMP;</h3>\nRepresents the Hero's health, magic, and the maxes for each of these."
                        },
                        {
                            "name": "TileMod ;; Hero::TileMod",
                            "val": "<h3>int TileMod;</h3>\nRead-only. Returns the current total 'Player Tile Modifier'.\nThis is calculated by summing the PTM of [[all owned items|'Active Use' shields only apply their PTM if they are in-use, instead applying a separate 'inactive PTM' if they are not in use.\nIf the Hero is currently a Bunny, PTMs for items that are not 'Usable As Bunny' will not be applied, though the global 'Bunny PTM' will be.]]."
                        },
                        {
                            "name": "Graphics ;; Hero::Tile / Hero::Flip / Hero::ScriptTile / Hero::ScriptFlip / Hero::ScriptCSet / Hero::Scale / Hero::Rotation / Hero::FlashingCSet / Hero::isFlickerFrame / Hero::FlickerColor / Hero::FlickerTransparencyPasses",
                            "val": "<h3>int Tile;</h3>\nThe tile the engine animation has selected to display this frame for the player.\n\n<h3>int Flip;</h3>\nThe flip value the engine animation has selected to display this frame for the player.\n\n<h3>int CSet;</h3>\nThe cset value the engine animation has selected to display this frame for the player.\n\n<h3>int ScriptTile;</h3>\nIf not '-1', this tile will override the engine's selected tile for the player.\n\n<h3>int ScriptFlip;</h3>\nIf not '-1', this tile will override the engine's selected flip for the player.\n\n<h3>int ScriptCSet;</h3>\nIf not '-1', this CSet will override the engine's selected cset for the player.\n\n<h3>int Scale;</h3>\nA scale that will be applied to the player's drawn size (does not affect hitbox)\n\n<h3>int Rotation;</h3>\nA rotation angle (in Degrees) that will be applied to the player's draw (does not affect hitbox)\n\n<h3>int ShadowXOffset;\nint ShadowYOffset;</h3>\nOffsets to the draw position of the Hero's shadow.\n\n<h3>int FlashingCSet;</h3>\nThis returns Link's current displayed cset when taking damage or invincible. If not in one of these states, will return his normal cset.\nIf called before Waitdraw() / player update, results may be off by a frame.\nIf the quest rule 'Invincible Player Flickers' is checked, this is unused.\n\n<h3>bool isFlickerFrame();</h3>\nThis returns true if Link is currently in a flicker frame (either invisible or color masked).\nIf called before Waitdraw() / player update, results may be off by a frame.\nIf the quest rule 'Invincible Player Flickers' is unchecked, this is unused.\n\n<h3>int FlickerColor;</h3>\nThis sets what color Link is drawn when flickering.\nIf -1, will use the default from Init Data.\nIf the quest rule 'Invincible Player Flickers' is unchecked, this is unused.\n\n<h3>int FlickerTransparencyPasses;</h3>\nThis sets how many times the transparency effect is applied to Link's flicker effect.\nIf -1, will use the default from Init Data. If 0, will use a solid color.\nIf the quest rule 'Invincible Player Flickers' is unchecked, this is unused."
                        },
                        {
                            "name": "Warping ;; Hero::Warp / Hero::WarpEx / Hero::PitWarp / Hero::IsWarping",
                            "val": "<h3>void Warp(int dmap, int screen);</h3>\nWarps the player to the specified dmap/screen. Uses an 'Insta-Warp' type, and uses the 'A' return square.\n\n<h3>void PitWarp(int dmap, int screen);</h3>\nSame as 'Warp()', but instead of positioning the Hero at the 'A' return square, instead the Hero stays in the exact same position.\n\n<h3>bool IsWarping;</h3>\nRead-only, true if a warp is currently in progress.\n\n<h3>void WarpEx(int[] ptr);</h3>\nWarpEX takes an array pointer containing parameters, instead of a set of parameters.\nValid parameter sets:\n<ul><li>Hero->WarpEx({type, dmap, screen, x, y, effect, sound, flags});</li>\n<li>Hero->WarpEx({type, dmap, screen, x, y, effect, sound, flags, forcedir});</li></ul>\n\nParameter descriptions:\n<ul><li>type: The warp type to use. Uses the `WT_` constants. All insta-warp types act the same, and do not provide their warp effect.</li>\n<li>dmap / screen: the location to warp to</li>\n<li>x / y: These represent the position to spawn at, either using a [[return square|If 'x &lt; 0', use the `WARP_` constants for 'y' to specify one of the 4 return squares.]], [[pitwarp|Setting both x and y '&lt; 0', or 'x &lt; 0' and 'y == 5', causes the player to stay in place.]], or [[coordinates|If 'x &gt; 0' and 'y &gt; 0', the Hero will spawn on the new screen at those coordinates.]].</li>\n<li>effect: What warp effect to display (uses [[`WARPEFFECT_`|$WARPEFFECT_]] constants)</li>\n<li>sound: An SFX to play during the warp.</li>\n<li>flags: See flag details below</li>\n<li>forcedir: If a direction is supplied for 'forcedir', the Hero will face that direction after the warp.</li></ul>\n\nWarp flags use the `WARP_FLAG_` constants, OR'd (`|`) together.\n<ul><li>[[WARP_FLAG_PLAYSOUNDS|If enabled, SFX will not be killed during the warp.]]</li>\n<li>[[WARP_FLAG_PLAYMUSIC|If enabled, Music will not be killed during the warp.]]</li>\n<li>[[WARP_FLAG_SCRIPTDRAW|If enabled, script draws will remain during the warp.]]</li>\n<li>[[WARP_FLAG_SETENTRANCESCREEN|If enabled, the 'last entrance screen' will be set by the warp.]]</li>\n<li>[[WARP_FLAG_SETENTRANCEDMAP|If enabled, the 'last entrance dmap' will be set by the warp.]]</li>\n<li>[[WARP_FLAG_SETCONTINUESCREEN|If enabled, the 'continue screen' will be set by the warp.]]</li>\n<li>[[WARP_FLAG_SETCONTINUEDMAP|If enabled, the 'continue dmap' will be set by the warp.]]</li>\n<li>[[WARP_FLAG_DONTCLEARSPRITES|If enabled, sprite type objects (such as weapons, items, enemies) will not be destroyed, and will warp to the new screen with you.]]</li>\n<li>[[WARP_FLAG_CLEARITEMS|Clears items from the screen, even with WARP_FLAG_DONTCLEARSPRITES enabled.]]</li>\n<li>[[WARP_FLAG_CLEARGUYS|Clears enemies from the screen, even with WARP_FLAG_DONTCLEARSPRITES enabled.]]</li>\n<li>[[WARP_FLAG_CLEARLWEAPONS|Clears lweapons from the screen, even with WARP_FLAG_DONTCLEARSPRITES enabled.]]</li>\n<li>[[WARP_FLAG_CLEAREWEAPONS|Clears eweapons from the screen, even with WARP_FLAG_DONTCLEARSPRITES enabled.]]</li>\n<li>[[WARP_FLAG_CLEARHOOKSHOT|Clears hookshot weapons from the screen, even with WARP_FLAG_DONTCLEARSPRITES enabled.]]</li>\n<li>[[WARP_FLAG_CLEARDECORATIONS|Clears decorations from the screen, even with WARP_FLAG_DONTCLEARSPRITES enabled.]]</li>\n<li>[[WARP_FLAG_CLEARPARTICLES|Clears particles from the screen, even with WARP_FLAG_DONTCLEARSPRITES enabled.]]</li>\n<li>[[WARP_FLAG_NOSTEPFORWARD|Prevents the 'step forward' animation that occurs on entering a dungeon screen from occurring after the warp.]]</li></ul>"
                        },
                        {
                            "name": "Explode ;; Hero::Explode",
                            "val": "<h3>void Explode(int mode);</h3>\nCreates an effect of the Hero's sprite 'Exploding'. This creates a particle for each pixel of the Hero's visual sprite, which will move in a pattern based on the selected 'mode'.\n\nModes:\n<ol start=\"0\"><li>Twilight</li>\n<li>Sand of Hours</li>\n<li>Farore's Wind</li></ol>"
                        },
                        {
                            "name": "--&gt; Next ;; heroptr2",
                            "val": "$-1$1"
                        },
                        {
                            "name": "--&gt;&gt; End ;; heroptr3",
                            "val": "$-1$2"
                        }
                    ]
                },
                {
                    "name": "Hero 2",
                    "lines": [
                        {
                            "name": "&lt;-- Global Pointers ;; function_globalptr",
                            "val": "$0$3"
                        },
                        {
                            "name": "Invunlerability ;; Hero::InvFrames / Hero::InvFlicker",
                            "val": "<h3>int InvFrames;</h3>\nThe number of frames the player is currently invulnerable (after being hit). Read/write.\n\n<h3>bool InvFlicker;</h3>\nIf set false, the player with neither flash nor flicker when invincible."
                        },
                        {
                            "name": "Defense ;; Hero::Defense",
                            "val": "<h3>int Defense[MAX_DEFENSE];</h3>\nRepresents the player's weapon defenses.\nAccess using the 'NPCD_' constants for indexes, and the 'NPCDT_' constants for the values."
                        },
                        {
                            "name": "HitBy ;; Hero::HitBy",
                            "val": "<h3>untyped HitBy[];</h3>\nAccess the following data indexes:\n<ul><li>HIT_BY_NPC - the Screen Index of the NPC that hit the player this frame.</li>\n<li>HIT_BY_NPC_UID - the UID of the NPC that hit the player this frame.</li>\n<li>HIT_BY_EWEAPON - the Screen Index of the EWEAPON that hit the player this frame.</li>\n<li>HIT_BY_EWEAPON_UID - the UID of the EWEAPON that hit the player this frame.</li>\n<li>HIT_BY_LWEAPON - the Screen Index of the LWEAPON that hit the player this frame.</li>\n<li>HIT_BY_LWEAPON_UID - the UID of the LWEAPON that hit the player this frame.</li></ul>"
                        },
                        {
                            "name": "Item ;; Hero::Item",
                            "val": "<h3>bool Item[NUM_ITEMDATA];</h3>\nAccess using Item IDs as indexes. Represents if the item is currently owned by the player. Read/Write."
                        },
                        {
                            "name": "Movespeed ;; Hero::Steps / Hero::Step / HeroMovement",
                            "val": "<h3>int Step;</h3>\nIf the quest rule [['New Hero Movement'|at \"Quest->Options->Player\"]] is enabled, this represents the move rate of the player, in 100ths pixel per frame (Default 150, i.e. 1.5 pixels per frame; changable in 'Init Data')\n\n<h3>int Steps[8];</h3>\nIf the quest rule [['New Hero Movement'|at \"Quest->Options->Player\"]] is NOT enabled, this array is used to move the player.\nWhen moving horizontally/vertically, the x/y modulo 8 determines which index is used, and that many pixels will be moved.\nModifying this array requires care to actually accomplish anything, and it is highly recommended to enable the 'New Hero Movement' quest rule and use 'Hero->Step' above instead."
                        },
                        {
                            "name": "Movement ;; Hero::MoveXY / Hero::CanMoveXY / Hero::MoveAtAngle / Hero::CanMoveAtAngle / Hero::Move / Hero::CanMove",
                            "val": "<h3>bool MoveXY(float dx, float dy, [[bool is_knockback = false|Currently does nothing for the player. Might in the future. In theory, should be 'true' if the movement is meant to simulate some form of knockback.]], [[bool ignore_sideview = false|If true, allows 'dy' movement regardless of sideview restrictions.]], [[bool corner_shove = true|If true, and either dx==0 or dy==0, then if the movement moves the player into the corner of a solid, they will be shoved around the corner- the same way engine movement handles corners.]]);\nbool CanMoveXY(float dx, float dy, [[bool is_knockback = false|Currently does nothing for the player. Might in the future. In theory, should be 'true' if the movement is meant to simulate some form of knockback.]], [[bool ignore_sideview = false|If true, allows 'dy' movement regardless of sideview restrictions.]], [[bool corner_shove = true|If true, and either dx==0 or dy==0, then if the movement moves the player into the corner of a solid, they will be shoved around the corner- the same way engine movement handles corners.]]);</h3>\n\nAttempts to move the player by 'dx' in the x direction and 'dy' in the y direction, failing if they are blocked by something they cannot walk through.\n\nReturns true if the player moves the full distance, false if the player was blocked at all.\n\nThe 'CanMoveXY' variant will not actually move the player at all, but will run the collision checks and return true if they <em>CAN</em> move the full distance, or false if they <em>WOULD</em> be blocked.\n\n<h3>bool MoveAtAngle(float degrees, float distance, bool is_knockback = false, bool ignore_sideview = false, bool corner_shove = true);\nbool CanMoveAtAngle(float degrees, float distance, bool is_knockback = false, bool ignore_sideview = false, bool corner_shove = true);</h3>\nSame as 'MoveXY', but moves by 'distance' in the 'degrees' angular direction.\n\n<h3>bool MoveAtAngle(int dir, float distance, bool is_knockback = false, bool ignore_sideview = false, bool corner_shove = true);\nbool CanMoveAtAngle(float degrees, float distance, bool is_knockback = false, bool ignore_sideview = false, bool corner_shove = true);</h3>\nSame as 'MoveXY', but moves by 'distance' in the 'dir' direction."
                        },
                        {
                            "name": "HeldItem ;; Hero::HeldItem",
                            "val": "<h3>int HeldItem;</h3>\nThe item displayed above the Hero's head (requires them to be in an item holding ${Hero::Action|Action})."
                        },
                        {
                            "name": "HealthBeep ;; Hero::HealthBeep",
                            "val": "<h3>int HealthBeep;</h3>\nNormally between 70 and -1, representing the timer for a non-constant low health beep.\nWriting '-2' to this prevents the engine from stopping the SFX that is set as the health beep.\nWriting '-4' to this prevents the engine from both stopping and starting the SFX."
                        },
                        {
                            "name": "Flags ;; Hero::Flags / Hero::Invisible / Hero::NoStepForward / Hero::Animation / Hero::CollDetection / Hero::Diagonal / Hero::BigHitbox / Hero::Gravity",
                            "val": "<h3>bool Invisible;</h3>\nIf set true, will prevent the player from being drawn.\n\n<h3>bool NoStepForward;</h3>\nIf set true, prevents the 'step forward' that occurs when entering a dungeon room.\n\n<h3>bool Animation;</h3>\nIf set false, disables the player's engine animation.\n\n<h3>bool CollDetecton;</h3>\nIf set false, the player's engine collision will be disabled (i.e. player is invincible)\n\n<h3>bool Diagonal;</h3>\nIf true, the Hero can move diagonally.\n\n<h3>bool BigHitbox;</h3>\nIf true, the Hero's hitbox is 16x16 instead of 16x8.\n\n<h3>bool Gravity;</h3>\nIf false, the player ignores gravity."
                        },
                        {
                            "name": "Misc ;; Hero::Misc",
                            "val": "<h3>untyped Misc[32];</h3>\nAn array of 32 misc values for script use."
                        },
                        {
                            "name": "&lt;-- Prev ;; heroptr",
                            "val": "$-1$0"
                        },
                        {
                            "name": "--&gt; Next ;; heroptr3",
                            "val": "$-1$2"
                        }
                    ]
                },
                {
                    "name": "Hero 3",
                    "lines": [
                        {
                            "name": "&lt;-- Global Pointers ;; function_globalptr",
                            "val": "$0$3"
                        },
                        {
                            "name": "Ladder Position ;; Hero::LadderX / Hero::LadderY",
                            "val": "<h3>int LadderX; int LadderY;</h3>\nThe position the ladder is currently placed at."
                        },
                        {
                            "name": "SFX ;; Hero::HurtSound",
                            "val": "<h3>int HurtSound;</h3>\nThe SFX played when the player is hurt."
                        },
                        {
                            "name": "Pushing ;; Hero::Pushing",
                            "val": "<h3>int Pushing;</h3>\nThe number of frames the Hero has been pushing against something for."
                        },
                        {
                            "name": "Pit / Water States ;; Hero::PitPullDir / Hero::PitPullTimer / Hero::Falling / Hero::FallCombo",
                            "val": "<h3>int PitPullDir;</h3>\nThe direction the player is being pulled into a pit in.\n<h3>int PitPullTimer;</h3>\nThe timer related to pit pulling\n\n<h3>int Falling;</h3>\nIf >0, the player is falling down a pit. Decreases each frame. Max value 70.\n<h3>int FallCombo;</h3>\nThe combo ID of the pit the player is currently falling into.\n\n<h3>int Drowning;</h3>\n<todo>needs docs</todo>\n<h3>int DrownCombo;</h3>\nThe combo ID of the water the player is currently drowning in."
                        },
                        {
                            "name": "MoveFlags ;; Hero::MoveFlags",
                            "val": "<h3>bool MoveFlags[];</h3>\nAccess the following flags:\n<ol start = \"0\"><li>HEROMV_OBEYS_GRAVITY - If false, the player ignores gravity.</li>\n<li>HEROMV_CAN_PITFALL - If false, the player floats over pitfalls.</li>\n<li>HEROMV_NO_FAKE_Z - The player's Fake Z axis is disabled if true</li>\n<li>HEROMV_NO_REAL_Z - The player's Z axis is disabled if true</li></ol>"
                        },
                        {
                            "name": "Respawn Position ;; Hero::RespawnX / Hero::RespawnY / Hero::RespawnDMap / Hero::RespawnScreen",
                            "val": "<h3>int RespawnX;\nint RespawnY;\nint RespawnDMap;\nint RespawnScreen;</h3>\nThe position, dmap, and screen that the player will respawn at when they drown or fall in a bottomless pit.\nDoes nothing if [['Classic Respawn Points'|at \"Quest->Options->Combo\"]] is enabled."
                        },
                        {
                            "name": "SwitchHook values ;; Hero::SwitchTimer / Hero::SwitchMaxTimer / Hero::SwitchCombo",
                            "val": "<h3>int SwitchTimer;\nint SwitchMaxTimer;</h3>\nTimer values for the current switchhook effect.\nIf 'SwitchTimer' is '>0', then a switchhook effect is currently active. When 'SwitchTimer' == 'SwitchMaxTimer / 2', the player will swap with the target object.\nRead-only.\n\n<h3>bool SwitchCombo(int pos, int effect);</h3>\nSwitch the player with the given combo position. A hookable combo must be present at that position (on any valid layer) for this to succeed.\nUse the `SW_EFF_` constants for 'effect' to select a visual style for the switch.\nReturns true if it succeeds, and false otherwise."
                        },
                        {
                            "name": "Death Effects ;; Hero::Immortal / Hero::Kill",
                            "val": "<h3>int Immortal;</h3>\nIf not 0, the player will not die, even when they have 0 hp. Effects such as bottled fairies will not trigger.\nIf '>0', automatically decrements by 1 each frame.\nIf this value becomes 0 while the player is at 0 hp, the death effect will trigger, including any bottled fairies.\n\n<h3>void Kill(bool bypass_revive);</h3>\nImmediately kills the player, setting their HP to 0, and ignoring 'Immortal'.\nIf 'bypass_revive' is true, revival effects such as bottled fairies will not trigger, and the 'one frame before death' that scripts would use to revive will also be skipped."
                        },
                        {
                            "name": "Lifting ;; Hero::ReleaseLiftWeapon / Hero::LiftWeapon / Hero::LiftedWeapon / Hero::LiftTimer / Hero::LiftMaxTimer / Hero::LiftHeight / Hero::LiftFlags[]",
                            "val": "<h3>lweapon ReleaseLiftWeapon();</h3>\nReturns a pointer to the held weapon, and causes the player to let go of it.\n\n<h3>void LiftWeapon(lweapon weap, int timer, int height);</h3>\nCauses the player to lift the specified weapon in the same way they lift combos with the Lift Glove.\nIf an lweapon script lifts itself, this also functions as a ${Waitframe|Waitframe()}.\n\n<h3>lweapon LiftedWeapon;</h3>\nThe weapon currently held by the player. Overwriting this directly will delete any weapon previously held.\nIf an lweapon script lifts itself, this also functions as a ${Waitframe|Waitframe()}.\n\n<h3>int LiftTimer;\nint LiftMaxTimer;</h3>\nThe time the current lift operation takes. The LiftMaxTimer is the total time, the LiftTimer starts at the same value but ticks down each frame the lift continues.\n\n<h3>int LiftHeight;</h3>\nThe height that the object will be lifted above the player's head.\n\n<h3>bool LiftFlags[LIFTFL_MAX];</h3>\nWhen the engine lifts an object, it will overwrite these flags.\nAccess the following flags:\n<ol start = \"0\"><li>LIFTFL_DISABLE_SHIELD - If true, the shield is disabled when lifting the same way it is when swinging a weapon.</li>\n<li>LIFTFL_DISABLE_ITEMS - If true, the player can't use any items unrelated to lifting. (Items related to lifting, such as bombs with the liftable flag set or a Lift Glove, will throw the held item regardless)</li></ol>"
                        },
                        {
                            "name": "&lt;&lt;-- Start ;; heroptr",
                            "val": "$-1$0"
                        },
                        {
                            "name": "&lt;-- Prev ;; heroptr2",
                            "val": "$-1$1"
                        }
                    ]
                }
            ]
        },
        {
            "name": "RandGen",
            "tabs": [
                {
                    "name": "RandGen ROOT",
                    "lines": [
                        {
                            "name": "&lt;-- Managed Pointers ;; function_data_managed",
                            "val": "$0$7"
                        },
                        {
                            "name": "<em>randgen</em>",
                            "val": "<h3>RandGen Pointers</h3>   `randgen`\n\n`randgen` pointers reference specific random number generators. You can create and seed them yourself.\nAny randgen pointer with a value of `NULL` can be used to reference the engine's RNG. The global pointer `RandGen->` is available as a null `randgen` pointer.\n\nSee: ${LoadRNG}"
                        },
                        {
                            "name": "Rand ;; randgen::Rand ;; Rand",
                            "val": "<h3>int Rand();</h3>\nReturns a random number `-214748 to 214748`, inclusive.\n\n<h3>int Rand(int bound);</h3>\nReturns a random number `0 to bound`, inclusive.\n\n<h3>int Rand(int bound1, int bound2);</h3>\nReturns a random number `bound1 to bound2`, inclusive.\n\n<h3>Note</h3>\nAll of these functions return integer values, with no decimal places."
                        },
                        {
                            "name": "LRand ;; randgen::LRand ;; LRand",
                            "val": "<h3>long LRand();</h3>\nReturns a random long number `-2147483648L to 2147483647L`, inclusive.\n\n<h3>long LRand(long bound);</h3>\nReturns a random long number `0L to bound`, inclusive.\n\n<h3>long LRand(long bound1, long bound2);</h3>\nReturns a random long number `bound1 to bound2`, inclusive.\n\n<h3>Note</h3>\nAll of these functions return long values. If you treat them as integer values, they will have decimal places."
                        },
                        {
                            "name": "SRand ;; randgen::SRand ;; SRand",
                            "val": "<h3>void SRand(long seed);</h3>\nSeeds the RNG with the given seed.\n\n<h3>long SRand();</h3>\nSeeds the RNG with a randomly-determined seed, based off of the system clock and the previous RNG.\nReturns the random seed."
                        },
                        {
                            "name": "Pointer Management ;; randgen::Free / randgen::Own",
                            "val": "<h3>void Free();</h3>\nDe-allocates this `randgen` pointer, so that its' pointer ID may be re-used. You may only have a limited number of randgen pointers active at a time; freeing them when you are done with them helps not reach the limit.\n\n<h3>void Own();</h3>\r\nGrants 'Ownership' of the randgen pointer to the script that calls this function. When the script with 'Ownership' terminates (at the same time its' local arrays are deallocated), this randgen pointer will automatically be 'Free()'d."
                        }
                    ]
                }
            ]
        },
        {
            "name": "Stack",
            "tabs": [
                {
                    "name": "Stack ROOT",
                    "lines": [
                        {
                            "name": "&lt;-- Managed Pointers ;; function_data_managed",
                            "val": "$0$7"
                        },
                        {
                            "name": "<em>stack</em>",
                            "val": "<h3>Stack Pointers</h3>   `stack`\n\n`stack` pointers allow storing and managing large sets of data, similar to arrays. The max storage of a stack is `2,147,483,647` elements, compared to arrays which have a maximum of `214,748` elements. Stacks also have various functions for accessing the data.\n\nSee: ${LoadStack}"
                        },
                        {
                            "name": "Size ;; stack::Size / stack::Full",
                            "val": "<h3>long Size;</h3>\nRead-only. The size of the stack, given as a LONG. This means that a stack with 5 items will have a size of '5L'.\n\n<h3>bool Full;</h3>\nRead-only. Returns true if the stack cannot hold any more elements."
                        },
                        {
                            "name": "Push ;; stack::PushBack / stack::PushFront",
                            "val": "If the stack is ${stack::Full|full}, Push functions will do nothing.\n\n<h3>void PushBack(untyped val);</h3>\nAdds the element 'val' to the end of the stack.\n\n<h3>void PushFront(untyped val);</h3>\nAdds the element 'val' to the beginning of the stack."
                        },
                        {
                            "name": "Pop / Peek ;; stack::PopBack / stack::PopFront / stack::PeekBack / stack::PeekFront",
                            "val": "If the stack is empty, Pop and Peek functions will return '0', doing nothing else.\n\n<h3>untyped PopBack();</h3>\nReturns the last element in the stack, removing it from the stack in the process.\n\n<h3>untyped PopFront();</h3>\nReturns the first element in the stack, removing it from the stack in the process.\n\n<h3>untyped PeekBack();</h3>\nReturns the last element in the stack, without removing it.\n\n<h3>untyped PeekFront();</h3>\nReturns the first element in the stack, without removing it."
                        },
                        {
                            "name": "Other Access ;; stack::Get / stack::Set / stack::Clear",
                            "val": "<h3>void Clear();</h3>\nRemoves every element from the stack.\n\n<h3>untyped Get(long ind);</h3>\nReturns the element at the index 'ind', which is a LONG value. This means that '0L' is the first element, '1L' is the second, etc.\nIf an invalid index is given, '0' is returned.\n\n<h3>void Set(long ind, untyped val);</h3>\nOverwrites the element at the index 'ind' (which is a LONG value) with 'val'. This means that '0L' is the first element, '1L' is the second, etc.\nIf an invalid index is given, nothing happens."
                        },
                        {
                            "name": "Pointer Management ;; stack::Free / stack::Own",
                            "val": "<h3>void Free();</h3>\nDe-allocates this `stack` pointer, so that its' pointer ID may be re-used. You may only have a limited number of stack pointers active at a time; freeing them when you are done with them helps not reach the limit.\n\n<h3>void Own();</h3>\nGrants 'Ownership' of the stack pointer to the script that calls this function. When the script with 'Ownership' terminates (at the same time its' local arrays are deallocated), this stack pointer will automatically be 'Free()'d."
                        }
                    ]
                }
            ]
        },
        {
            "name": "BottleData",
            "tabs": [
                {
                    "name": "BottleData ROOT",
                    "lines": [
                        {
                            "name": "&lt;-- Misc Data Pointers ;; function_data_misc",
                            "val": "$0$6"
                        },
                        {
                            "name": "<em>bottledata</em>",
                            "val": "<h3>BottleData Pointers</h3>   `bottledata`\n\n`bottledata` pointers allow accessing data relating to 'Bottle Types'.\n\nSee: ${Game::LoadBottleData|LoadBottleData}"
                        },
                        {
                            "name": "Name ;; bottledata::name / bottledata::GetName / bottledata::SetName",
                            "val": "<h3>void GetName(char32[] str);</h3>\nLoads the name of the bottledata into the provided string buffer.\n\n<h3>void SetName(char32[] str);</h3>\nSets the name of the bottledata to the provided string.\n"
                        },
                        {
                            "name": "Counter ;; bottledata::Counter",
                            "val": "<h3>int Counter[3];</h3>\n\nThe refill counters of this bottle type.\n\nUse the `CR_` constants for these values."
                        },
                        {
                            "name": "Amount ;; bottledata::Amount",
                            "val": "<h3>int Amount[3];</h3>\n\nThe amount to refill each counter (0-65535)"
                        },
                        {
                            "name": "IsPercent ;; bottledata::IsPercent",
                            "val": "<h3>bool IsPercent[3];</h3>\n\nWhether the given counter refill is a percentage of max, instead of a direct value."
                        },
                        {
                            "name": "Flags ;; bottledata::Flags",
                            "val": "<h3>bool Flags[4];</h3>\n\nA set of flags. Use the `BTF_` constants to access this."
                        },
                        {
                            "name": "NextType ;; bottledata::NextType",
                            "val": "<h3>int NextType;</h3>\n\nWhat bottle type will remain in the bottle after drinking the current type."
                        }
                    ]
                }
            ]
        },
        {
            "name": "BottleShopData",
            "tabs": [
                {
                    "name": "BottleShopData ROOT",
                    "lines": [
                        {
                            "name": "&lt;-- Misc Data Pointers ;; function_data_misc",
                            "val": "$0$6"
                        },
                        {
                            "name": "<em>bottleshopdata</em>",
                            "val": "<h3>BottleShopData Pointers</h3>   `bottleshopdata`\n\n`bottleshopdata` pointers allow accessing data relating to 'Bottle Shop Types'.\n\nSee: ${Game::LoadBottleShopData|LoadBottleShopData}\n\nRelated: ${bottledata}"
                        },
                        {
                            "name": "Name ;; bottleshopdata::GetName / bottleshopdata::SetName",
                            "val": "<h3>void GetName(char32[] str);</h3>\nLoads the name of the bottleshopdata into the provided string buffer.\n\n<h3>void SetName(char32[] str);</h3>\nSets the name of the bottleshopdata to the provided string.\n"
                        },
                        {
                            "name": "Fill ;; bottleshopdata::Fill",
                            "val": "<h3>int Fill[3];</h3>\n\nWhich bottle type each index fills a bottle with.\n\nRelated: ${bottledata}"
                        },
                        {
                            "name": "Combo ;; bottleshopdata::Combo",
                            "val": "<h3>int Combo[3];</h3>\n\nWhat combo to display as a visual for each index."
                        },
                        {
                            "name": "CSet ;; bottleshopdata::CSet",
                            "val": "<h3>int CSet[3];</h3>\n\nWhat CSet to use for the combo for each index."
                        },
                        {
                            "name": "Price ;; bottleshopdata::Price",
                            "val": "<h3>int Price[3];</h3>\n\nThe price, in rupees (0-65535) to purchase each index."
                        },
                        {
                            "name": "InfoString ;; bottleshopdata::InfoString",
                            "val": "<h3>int InfoString[3];</h3>\n\nThe ${message string} to display upon purchasing each index."
                        }
                    ]
                }
            ]
        },
        {
            "name": "DropsetData",
            "tabs": [
                {
                    "name": "DropsetData ROOT",
                    "lines": [
                        {
                            "name": "&lt;-- Misc Data Pointers ;; function_data_misc",
                            "val": "$0$6"
                        },
                        {
                            "name": "<em>dropsetdata</em>",
                            "val": "<h3>DropsetData Pointers</h3>   `dropsetdata`\n\n`dropsetdata` pointers allow accessing dropsets, and using them to pick random items.\n\nSee: ${Game::LoadDropset|LoadDropset}\n\n<todo>Name getter/setter, Create(x,y,z=0)</todo>\n"
                        },
                        {
                            "name": "Choose ;; dropsetdata::Choose",
                            "val": "<h3>int Choose();</h3>\n\nRandomly selects an item from the dropset, and returns its' ID.\nReturns `-1` if ${dropsetdata::NothingChance|nothing} is chosen."
                        },
                        {
                            "name": "Items ;; dropsetdata::Items",
                            "val": "<h3>int Items[10];</h3>\n\nThe item IDs stored in this dropset."
                        },
                        {
                            "name": "Chances ;; dropsetdata::Chances",
                            "val": "<h3>int Chances[10];</h3>\n\nThe chances for each item to appear. These are <em>not</em> percentages, but weights; changing one will affect the odds of all of them."
                        },
                        {
                            "name": "NothingChance ;; dropsetdata::NothingChance",
                            "val": "<h3>int NothingChance;</h3>\n\nThe weighted value for no item being chosen at all."
                        }
                    ]
                }
            ]
        },
        {
            "name": "MessageData",
            "tabs": [
                {
                    "name": "MessageData ROOT",
                    "lines": [
                        {
                            "name": "&lt;-- Misc Data Pointers ;; function_data_misc",
                            "val": "$0$6"
                        },
                        {
                            "name": "<em>messagedata</em>",
                            "val": "<h3>MessageData Pointers</h3>   `messagedata`\n\n`messagedata` pointers allow accessing and editing ${message strings}.\n\nSee: ${Game::LoadMessageData|LoadMessageData}"
                        },
                        {
                            "name": "Message ;; messagedata::Get / messagedata::Set / messagedata::Length",
                            "val": "<h3>void Get(char32[] str);</h3>\nLoads the message into the provided string buffer.\n\n<h3>void Set(char32[] str);</h3>\nSets the message to the provided string.\n\n<h3>int Length;</h3>\nThe length, in characters, of the message. Read-only."
                        },
                        {
                            "name": "Positioning ;; messagedata::X / messagedata::Y / messagedata::Width / messagedata::Height",
                            "val": "<h3>int X;\nint Y;</h3>\n\nThe X/Y position of the message box.\n\n<h3>int Width;\nint Height;</h3>\n\nThe width/height of the message box, in pixels.\nIf [[Old String Frame Width/Height|at Quest->Options->Compat]] is checked, the box will actually be 16 pixels wider and taller than is set here."
                        },
                        {
                            "name": "Text Display ;; messagedata::Font / messagedata::VSpace / messagedata::HSpace / messagedata::Margins",
                            "val": "<h3>int Font;</h3>\nThe font to display the message in. Use the `FONT_` constants for this value.\n\n<h3>int VSpace;\nint HSpace;</h3>\nThe spacing between lines/characters, in pixels.\n\n<h3>int Margins[4];</h3>\n\nThe margins, in pixels, from each edge of the text box. Use the `DIR_` constants to access this.\nIf [[Old String Margins|at Quest->Options->Compat]] is checked, these will not apply."
                        },
                        {
                            "name": "Background Graphics ;; messagedata::Tile / messagedata::CSet",
                            "val": "<h3>int Tile;</h3>\nThe tile used for the background.\nIf the ${messagedata::Flags|'Full Tiled Background' flag} is set, this is the top-left tile of a tile block the size of the message box.\nOtherwise, it is the top-left of a 2x2 square of tiles in a 'frame' style.\n\n<h3>int CSet;</h3>\nThe CSet to draw the background in."
                        },
                        {
                            "name": "Portraits ;; messagedata::PortraitTile / messagedata::PortraitCSet / messagedata::PortraitX / messagedata::PortraitY / messagedata::PortraitTileWidth / messagedata::PortraitTileHeight",
                            "val": "<h3>int PortraitTile;</h3>\nThe upper-left corner tile of the portrait. If set to 0, no portrait will be displayed.\n\n<h3>int PortraitCSet;</h3>\nThe CSet to draw the portrait in\n\n<h3>int PortraitX;\nint PortraitY;</h3>\nThe X/Y position of the portrait.\n\n<h3>int PortraitTileWidth;\nint PortraitTileHeight;</h3>\nThe tile width/height of the portrait. Max 16 and 14 respectively. If either is '0', no portrait will be displayed."
                        },
                        {
                            "name": "Next ;; messagedata::Next",
                            "val": "<h3>int Next;</h3>\n\nThe 'next' message, which will be automatically displayed when this message finishes.\nIf set to 0, no message will automatically follow this one."
                        },
                        {
                            "name": "Sound ;; messagedata::Sound",
                            "val": "<h3>int Sound;</h3>\n\nThe SFX to play when a new character is drawn (including spaces).\nIf 0, no sound is played."
                        },
                        {
                            "name": "ListPosition ;; messagedata::ListPosition",
                            "val": "<h3>int ListPosition;</h3>\n\nThe list position of the messagedata as it is displayed in ZQ."
                        },
                        {
                            "name": "Flags ;; messagedata::Flags",
                            "val": "<h3>bool Flags[7];</h3>\n\nA set of flags for the messagedata.\n<ol start=\"0\">\n<li>MSGFLAG_WRAP: If the text wraps around the bounding box</li>\n<li>MSGFLAG_CONT: If the message is a continuation of the previous one</li>\n<li value=\"4\">MSGFLAG_FULLTILE: If the ${messagedata::Tile|background} is 'Full Tiled'</li>\n<li>MSGFLAG_TRANS_BG: If the background is transparent</li>\n<li>MSGFLAG_TRANS_FG: If the text is transparent</li>\n</ol>"
                        },
                        {
                            "name": "TextWidth / TextHeight ;; messagedata::TextWidth / messagedata::TextHeight",
                            "val": "<h3>int TextWidth();\nint TextHeight();</h3>\n\nReturns the width/height, in pixels, of the message text - <em>not</em> including line wrap / breaks.\nThis is the width/height that would be used to call ${Screen::DrawString|DrawString} with this message string and font.\n\nTextHeight() is effectively the same as calling ${Text::FontHeight|Text->FontHeight()} using ${messagedata::Font|the message's font}.\nTextWidth() is effectively the same as using ${messagedata::Get|messagedata->Get()} to get the text into a ZScript string, and then passing that with ${messagedata::Font|the message's font} to ${Text::StringWidth|Text->StringWidth()}."
                        },
                        {
                            "name": "Shadow Graphics ;; messagedata::ShadowType / messagedata::ShadowColor",
                            "val": "<todo>Shadow effects are not yet accessible!</todo>"
                        }
                    ]
                }
            ]
        },
        {
            "name": "ShopData",
            "tabs": [
                {
                    "name": "ShopData ROOT",
                    "lines": [
                        {
                            "name": "&lt;-- Misc Data Pointers ;; function_data_misc",
                            "val": "$0$6"
                        },
                        {
                            "name": "<em>shopdata</em>",
                            "val": "<h3>ShopData Pointers</h3>   `shopdata`\n\n`shopdata` pointers allow accessing data relating to 'Bottle Shop Types'.\n\nSee: ${Game::LoadShopData|LoadShopData}, ${Game::LoadInfoShopData|LoadInfoShopData}"
                        },
                        {
                            "name": "Type ;; shopdata::Type",
                            "val": "<h3>int Type;</h3>\n\nRead-only. Returns the type of the shop, where:\n<ol start=\"0\">\n<li>Invalid</li>\n<li>Item Shop</li>\n<li>Info Shop</li>\n</ol>"
                        },
                        {
                            "name": "Item ;; shopdata::Item / shopdata::HasItem",
                            "val": "<h3>int Item[3];</h3>\n\nThe 3 items available in the shop.\n\n<h3>bool HasItem[3];</h3>\n\nWhether a given position should have an item.\n\n<h3>Note:</h3>\nThese values are only valid for ${shopdata::Type|item shops}."
                        },
                        {
                            "name": "Price ;; shopdata::Price",
                            "val": "<h3>int Price[3];</h3>\n\nThe price, in rupees (0-65535) to purchase each index."
                        },
                        {
                            "name": "String ;; shopdata::String",
                            "val": "<h3>int String[3];</h3>\n\nThe ${message string} to display upon purchasing each index."
                        }
                    ]
                }
            ]
        },
        {
            "name": "Screen",
            "tabs": [
                {
                    "name": "Screen ROOT",
                    "lines": [
                        {
                            "name": "&lt;-- Global Pointers ;; function_globalptr",
                            "val": "$Base Data$3"
                        },
                        {
                            "name": "<em>Screen</em> ;;screeninfo",
                            "val": "The `Screen->` pointer holds various data pertaining to how each screen is made up, as well as various functions which draw to the screen, or create/load pointers to objects present on the screen."
                        },
                        {
                            "name": "Shared with 'mapdata' ;; mapscrShare",
                            "val": "$MapData$1"
                        },
                        {
                            "name": "Shared with 'bitmap' ;;bitscrShare",
                            "val": "$Bitmap$2"
                        },
                        {
                            "name": "Effects ;; Screen::Lit / Screen::Wavy / Screen::Quake",
                            "val": "<h3>bool Lit;</h3>\nWhether or not the screen is 'lit'. Applies to Classic Darkrooms.\nDoes nothing if [['New Dark Rooms'|at \"Quest->Options->Misc\"]] is enabled.\n\n<h3>int Wavy;</h3>\nThe remaining time, in frames, of the 'Wavy' visual effect. Decrements by 1 each frame.\nThe wavy effect is more intense the higher the value is.\n\n<h3>int Quake;</h3>\nThe remaining time, in frames, of the 'Quake' visual effect. Decrements by 1 each frame.\nThe quake effect is more intense the higher the value is."
                        },
                        {
                            "name": "Screen Objects ;; Screen::LoadFFC / Screen::CreateEWeapon / Screen::LoadEWeapon / Screen::NumEWeapons / Screen::CreateLWeapon / Screen::LoadLWeapon / Screen::NumLWeapons / Screen::CreateNPC / Screen::LoadNPC / Screen::NumNPCs / Screen::CreateItem / Screen::LoadItem / Screen::NumItems / LoadFFC / LoadNPC / LoadLWeapon / LoadEWeapon / LoadItem / LoadPortal / CreateNPC / CreateLWeapon / CreateEWeapon / CreateItem / CreatePortal / NumFFCs / NumNPCs / NumLWeapons / NumEWeapons / NumItems / NumPortals",
                            "val": "<h3>int NumItems();\nint NumNPCs();\nint NumLWeapons();\nint NumEWeapons();\nint NumFFCs();\nint NumPortals();</h3>\nReturns the number of the given object type that are present on the current screen.\n\n<h3>${itemsprite} CreateItem(int id);\n${npc} CreateNPC(int id);\n${lweapon} CreateLWeapon(int id);\n${eweapon} CreateEWeapon(int id);\n${portal} CreatePortal();</h3>\nCreates a new sprite object, with the given ID. Use the `LW_` and `EW_` constants for `CreateLWeapon()`/`CreateEWeapon()`. Use the item editor IDs and enemy editor IDs for `CreateItem()`/`CreateNPC()`.\n\n<h3>${itemsprite} LoadItem(int n);\n${npc} LoadNPC(int n);\n${lweapon} LoadLWeapon(int n);\n${eweapon} LoadEWeapon(int n);\n${portal} LoadPortal(int n);</h3>\nWhere `1 &lt;= n &lt;= NumObjects`, returns a pointer to the nth object on the screen.\nUsed to access itemsprites, npcs, lweapons, and eweapons that currently exist on the screen.\nFor 'LoadPortal()', use '-1' to access the Magic Mirror's portal, which is inactive if its' dmap is -1.\n\n<h3>${ffc} LoadFFC(int n);</h3>\nReturns a pointer to the nth FFC on the screen, where `1 &lt;= n &lt;= MAX_FFC`.\nUsed to access ffcs that currently exist on the screen.\n\n<h3>${itemsprite} Items[];\n${npc} NPCs[];\n${lweapon} LWeapons[];\n${eweapon} EWeapons[];\n${ffc} FFCs[];\n${portal} Portals[];</h3>\n${Internal Arrays|Internal Array pointers} to arrays containing all of each respective type of object on the screen. These arrays are 0-indexed."
                        },
                        {
                            "name": "Moving Blocks ;; Screen::MovingBlockX / Screen::MovingBlockY / Screen::MovingBlockLayer / Screen::MovingBlockCombo / Screen::MovingBlockCSet",
                            "val": "This data is all related to the current block being pushed on the screen.\n\n<h3>int MovingBlockX;\nint MovingBlockY;</h3>\nThe X/Y position of the block. If no block is being moved, these will both return '-1'.\n\n<h3>int MovingBlockLayer;</h3>\nThe layer of the block. Depending on some QRs, this may affect what combos the block interacts with.\nWhen the block 'clicks into place' after moving, it will be placed on this layer.\n\n<h3>int MovingBlockCombo;\nint MovingBlockCSet;</h3>\nThe combo/cset used by the moving block. These affect how it is drawn during movement, and what combo/cset will be placed on the screen when movement ends."
                        },
                        {
                            "name": "D[] ;; Screen::D",
                            "val": "<h3>untyped D[8];</h3>\nA set of 8 misc values for each screen."
                        },
                        {
                            "name": "Screen Open/Close Effects ;; Screen::ClosingWipe / Screen::OpeningWipe / Screen::WavyOut / Screen::WavyIn / Screen::ZapOut / Screen::ZapIn",
                            "val": "<h3>void WavyIn();\nvoid WavyOut();</h3>\nPlays the warping screen 'wave' effect.\n\n<h3>void ZapIn();\nvoid ZapOut();</h3>\nPlays the warping screen 'zap' effect.\n\n<h3>void OpeningWipe();\nvoid ClosingWipe();</h3>\nPlays the warping screen 'wipe' effect, respecting the wipe-related QRs.\n\n<h3>void OpeningWipe(int shape);\nvoid ClosingWipe(int shape);</h3>\nPlays the warping screen 'wipe' effect with the specified shape, using the `WIPE_` constants for the shape."
                        },
                        {
                            "name": "Message Strings ;; Screen::Message / Screen::ShowingMessage",
                            "val": "Related: ${messagedata}, ${Message Strings}\n\n<h3>int ShowingMessage;</h3>\nRead-only. The message ID of the messagestring currently showing on-screen.\nReads 0 if no message is being displayed.\n\n<h3>void Message(int msgID);</h3>\nDisplays the specified messagestring on the screen.\nIf '0' is passed, closes any message that is already open on the screen."
                        },
                        {
                            "name": "Misc ;; Screen::TriggerSecrets / Screen::SecretsTriggered / Screen::ClearSprites / Screen::SpawnScreenEnemies / Screen::TriggerCombo",
                            "val": "<h3>bool SecretsTriggered();</h3>\nReturns true if secrets have been triggered on this screen (including temp).\n\n<h3>void TriggerSecrets();</h3>\nTriggers secrets on this screen (temp only, write ${Screen::State|`Screen->State[ST_SECRET] = true;`} to set the perm secret state)\nDoes not play the screen's ${Screen::SecretSFX|SecretSFX} as part of the trigger.\n\n<h3>void ClearSprites(int spritelist);</h3>\r\nKills all sprite objects of the specified type, using the `SL_` constants.\r\nEx: `Screen->ClearSprites(SL_GUYS);` will delete all enemies on the screen.\r\n\r\n<h3>bool SpawnScreenEnemies();</h3>\r\nImmediately attempts to spawn the ${Screen::Enemy|screen's enemies}, using the ${Screen::Pattern|screen's pattern}.\r\nReturns true on success, false on failure.\r\nFails if enemies are still in the middle of entering from the sides, or if the screen's pattern is `PATTERN_NO_SPAWNING`.\r\n\r\n<h3>bool TriggerCombo(int layer, int pos);</h3>\r\nAttempts to trigger the combo at 'layer,pos'. Returns true on success, false on failure.\r\n\r\nFails in special cases depending on the combo, as well as if either layer or pos is invalid.\r\n\r\nIf no 'Triggers' tab behaviors are set, won't do anything."
                        },
                        {
                            "name": "Render Targets ;; Screen::GetRenderTarget / Screen::SetRenderTarget",
                            "val": "<h3>int GetRenderTarget();\nvoid SetRenderTarget(int rt);</h3>\n\nGets/sets the current \"Render Target\". Most times this should be 'RT_SCREEN', though versions older than 2.55 required using this for bitmap drawing. 2.55's ${bitmapptr|`bitmap` pointers} effectively obsolete the render target system, and should be used instead of this.\n\nUses the constants `RT_SCREEN` for the screen, and `RT_BITMAP0` through `RT_BITMAP6` for the 6 old-style bitmap targets."
                        },
                        {
                            "name": "Drawing ;; Screen::PutPixels / Screen::DrawTiles / Screen::DrawCombos / Screen::Lines / Screen::DrawBitmap / Screen::DrawBitmapEx / Screen Drawing Funcs",
                            "val": "<h3>void DrawBitmap(int layer, int bitmap_id,\n        int source_x, int source_y, int source_w, int source_h,\n        int dest_x, int dest_y, int dest_w, int dest_h,\n        float rotation, bool mask);</h3>\n\nDraws an area from the old-style render target bitmap indicated by `bitmap_id` to the current render target.\n\n<h3>void DrawBitmapEx(int layer, int bitmap_id,\n        int source_x, int source_y, int source_w, int source_h, \n        int dest_x, int dest_y, int dest_w, int dest_h, \n        float rotation = 0, int cx = 0, int cy = 0,\n        int mode = 0, int lit = 0,  bool mask = true);</h3>\n\nSimilar to 'DrawBitmap', but offers some extra mode options- using the 'BITDX_' constants.\n\n<h2>Array Drawing Functions</h2>\nThese take a repeating-array of parameters.\n\n<h3>void PutPixels(int layer, int arr[], int rx, int ry, int rangle);</h3>\nPuts multiple pixels to the screen in one function call. PutPixels() expects an array as its arg, with the array in the format of repeating blocks of `{ x, y, color, trans }`.\n\n<h3>void DrawTiles(int layer, int arr[]);</h3>\nSimilar to FastTile(), but it draws multiple tiles in one call. The array arg should be an array with repeating sets of `{x,y,tile,color,opacity}`\n\n<h3>void DrawCombos(int layer, int arr[]);</h3>\nSimilar to FastCombo(), but it draws multiple combos in one call. The array arg should be an array with repeating sets of `{x,y,combo,color,opacity}`\n\n<h3>void Lines(int layer, int arr[]);</h3>\nSimilar to Line(), but it draws multiple lines in one call. The array arg should be an array with repeating sets of `{x,y,x2,y2,color,scale,rx,ry,rangle,opacity}`"
                        },
                        {
                            "name": "Darkroom Lighting ;; Screen::DrawLightCircle / Screen::DrawLightSquare / Screen::DrawLightCone",
                            "val": "<h3>void DrawLightCircle(int cx, int cy, [[int radius = -1|The radius of the circle, in pixels. Defaults to the Game-&gt;Generic[GEN_DEFAULT_LIGHT_RAD] value if left negative.]], [[int transp_rad = -1, int dith_rad = -1, int dith_type = -1, int dith_arg = -1|Will use the values from Game-&gt;Generic[] if a negative (or default) is passed.]]);</h3>\n\nDraws a circular light to the engine darkroom bitmap, centered on 'cx,cy'.\n\n<h3>void DrawLightSquare(int cx, int cy, [[int radius = -1|The radius of the square, in pixels. Defaults to the Game-&gt;Generic[GEN_DEFAULT_LIGHT_RAD] value if left negative.]], [[int transp_rad = -1, int dith_rad = -1, int dith_type = -1, int dith_arg = -1|Will use the values from Game-&gt;Generic[] if a negative (or default) is passed.]]);</h3>\n\nDraws a square light to the engine darkroom bitmap, centered on 'cx,cy'.\n\n<h3>void DrawLightCone(int cx, int cy, int dir, [[int length = -1|The length of the cone in pixels. Defaults to DOUBLE the Game-&gt;Generic[GEN_DEFAULT_LIGHT_RAD] value if left negative.]], [[int transp_rad = -1, int dith_rad = -1, int dith_type = -1, int dith_arg = -1|Will use the values from Game-&gt;Generic[] if a negative (or default) is passed.]]);</h3>\n\nDraws a cone of light to the engine darkroom bitmap, emanating in the 8-dir 'dir' from the point 'cx,cy'."
                        }
                    ]
                }
            ]
        },
        {
            "name": "MapData",
            "tabs": [
                {
                    "name": "MapData ROOT",
                    "lines": [
                        {
                            "name": "&lt;-- Misc Data Pointers ;; function_data_misc",
                            "val": "$0$6"
                        },
                        {
                            "name": "<em>mapdata</em>",
                            "val": "<h3>MapData Pointers</h3>   `mapdata`\n\n`mapdata` pointers allow accessing data from any screen.\nDepending on how a mapdata pointer is loaded, it may represent a ${LoadTempScreen|temporary current screen}, a ${LoadScrollingScreen|temporary scrolling screen}, or a ${LoadMapData|permanent screen}.\n\nMany parts of `mapdata` are shared with `Screen->`.\n\nSee: ${LoadTempScreen}, ${LoadScrollingScreen}, ${LoadMapData}"
                        },
                        {
                            "name": "Shared w/ Screen-> ;; mapscrShare",
                            "val": "$MapData$1"
                        },
                        {
                            "name": "Map / Screen ;; mapdata::Map / mapdata::Screen",
                            "val": "<h3>int Map;</h3>\nRead-only. Returns the map this mapdata points to.\n\n<h3>int Screen;</h3>\nRead-only. Returns the screen this mapdata points to."
                        },
                        {
                            "name": "FFC Info ;; mapdata::FFCRunning[] / mapdata::FFCScript[] / mapdata::FFCLink[] / mapdata::FFCTileHeight[] / mapdata::FFCTileWidth[] / mapdata::FFCEffectHeight[] / mapdata::FFCEffectWidth[] / mapdata::FFCFlags[] / mapdata::FFCAy[] / mapdata::FFCAx[] / mapdata::FFCVy[] / mapdata::FFCVx[] / mapdata::FFCY[] / mapdata::FFCX[] / mapdata::FFCDelay[] / mapdata::FFCCSet[] / mapdata::FFCData[] / mapdata::GetFFCInitA / mapdata::SetFFCInitA / mapdata::GetFFCInitD / mapdata::SetFFCInitD",
                            "val": "<h4>int ${ffc::Data|FFCData}[MAX_FFC];\nint ${ffc::CSet|FFCCSet}[MAX_FFC];\nint ${ffc::Delay|FFCDelay}[MAX_FFC];\nint ${ffc::X|FFCX}[MAX_FFC]; int ${ffc::Y|FFCY}[MAX_FFC];\nint ${ffc::Vx|FFCVx}[MAX_FFC]; int ${ffc::Vy|FFCVy}[MAX_FFC];\nint ${ffc::Ax|FFCAx}[MAX_FFC]; int ${ffc::Ay|FFCAy}[MAX_FFC];\nint ${ffc::Flags|FFCFlags}[MAX_FFC];\nint ${ffc::EffectWidth|FFCEffectWidth}[MAX_FFC]; int ${ffc::EffectHeight|FFCEffectHeight}[MAX_FFC];\nint ${ffc::TileWidth|FFCTileWidth}[MAX_FFC]; int ${ffc::TileHeight|FFCTileHeight}[MAX_FFC];\nint ${ffc::Link|FFCLink}[MAX_FFC];\nint ${ffc::Script|FFCScript}[MAX_FFC];</h4>\nAccess various properties of the FFCs on the screen, remotely. See ${ffc|ffc} for more information on each value.\nFor `int FFCFlags[];`, instead of being an array of boolean flags, each index is a bitwise flagset. To access, use bitwise operators and the `FFCBF_` constants (which represent the same thing as their matching `FFCF_` counterparts)\n\n<h3>untyped GetFFCInitD(int ffc_index, int n);\nvoid SetFFCInitD(int ffc_index, int n, untyped value);</h3>\nAccess the ${ffc::InitD|`InitD[n]`} for the specified FFC on the screen."
                        }
                    ]
                },
                {
                    "name": "Shared w/ Screen 1",
                    "lines": [
                        {
                            "name": "&lt;-- MapData Pointers ;; mapdataptr",
                            "val": "$MapData"
                        },
                        {
                            "name": "&lt;-- Screen Pointer ;; screenptr",
                            "val": "$Screen"
                        },
                        {
                            "name": "Info",
                            "val": "These functions and variables are shared between `Screen->` and `mapdata->` pointers. For `Screen->`, the 'current screen' is the screen the player is presently on, as a temporary screen. For `mapdata->`, it is whatever screen was loaded to create the mapdata pointer."
                        },
                        {
                            "name": "Solidity Checks ;; mapdata::isSolid / Screen::isSolid / mapdata::isSolidLayer / Screen::isSolidLayer",
                            "val": "<h3>bool isSolid(int x, int y);\nbool isSolidLayer(int x, int y, int layer);</h3>\n\nReturns true if the given x,y position on the screen is 'solid'.\n`isSolid` returns true if either layer 0,1, or 2 is solid\n`isSolidLayer` returns true only for the specified layer."
                        },
                        {
                            "name": "Combo / Flag Data ;; mapdata::ComboE[] / Screen::ComboE[] / mapdata::ComboS[] / Screen::ComboS[] / mapdata::ComboT[] / Screen::ComboT[] / mapdata::ComboI[] / Screen::ComboI[] / mapdata::ComboF[] / Screen::ComboF[] / mapdata::ComboC[] / Screen::ComboC[] / mapdata::ComboD[] / Screen::ComboD[]",
                            "val": "<h3>int ComboD[176];</h3>\nThe Combo ID placed at each position on the screen.\n\n<h3>int ComboC[176];</h3>\nThe CSet of the combo placed at each position on the screen.\n\n<h3>int ComboF[176];</h3>\nThe mapflag placed at each position on the screen.\n\n<h3>int ComboI[176];</h3>\nThe inherent flag of the combo placed at each position on the screen.\nWriting to this changes the inherent flag for EVERY combo of that combo ID.\n\n<h3>int ComboT[176];</h3>\nThe combo type of the combo placed at each position on the screen.\nWriting to this changes the combo type for EVERY combo of that combo ID.\n\n<h3>int ComboS[176];</h3>\nThe solidity map of the combo placed at each position on the screen.\nWriting to this changes the solidity map for EVERY combo of that combo ID.\n\n<h3>int ComboE[176];</h3>\nThe effect map of the combo placed at each position on the screen.\nWriting to this changes the effect map for EVERY combo of that combo ID."
                        },
                        {
                            "name": "Secret Combos ;; mapdata::SecretFlags / Screen::SecretFlags / mapdata::SecretCSet / Screen::SecretCSet / mapdata::SecretCombo / Screen::SecretCombo",
                            "val": "<h3>Secret Combos</h3>\nSecret combos are the combos that replace certain screen flags when ${secrets} are triggered. When they replace, it replaces the Combo, Placed Flag, and CSet of the given location.\nSecret Combo data is indexed using the `SECCMB_` constants.\n\n<h3>int SecretCombo[SECCMB_MAX];</h3>\nThe combo that will be placed for each secret type.\n\n<h3>int SecretCSet[SECCMB_MAX];</h3>\nThe cset that will be placed for each secret type.\n\n<h3>int SecretFlags[SECCMB_MAX];</h3>\nThe screen flags that will be placed for each secret type.\n\n<h3>Notes:</h3>\nThe index `SECCMB_SECRETSNEXT` is used for `Secrets->Next` flags, and does not make use of `SecretCombo[]` or `SecretCSet[]`; though it does make use of `SecretFlags[]`."
                        },
                        {
                            "name": "SFX / Music ;; mapdata::ItemSFX / Screen::ItemSFX / mapdata::SecretSFX / Screen::SecretSFX / mapdata::BossSFX / Screen::BossSFX / mapdata::AmbientSFX / Screen::AmbientSFX / mapdata::MIDI / Screen::MIDI",
                            "val": "<h3>int ItemSFX;</h3>\nThe SFX that will play when an item is held up on this screen.\n\n<h3>int SecretSFX;</h3>\nThe SFX that will play when secrets are triggered on this screen.\n\n<h3>int BossSFX;</h3>\nThe SFX for the boss roar on this screen.\n\n<h3>int AmbientSFX;</h3>\nThe SFX for the ambient sound of the screen.\n\n<h3>int MIDI;</h3>\nThe 'Screen MIDI' to play for this screen."
                        },
                        {
                            "name": "Room Data ;; mapdata::Guy / Screen::Guy / mapdata::String / Screen::String / mapdata::RoomType / Screen::RoomType / mapdata::Catchall / Screen::Catchall",
                            "val": "<h3>int Guy;</h3>\nThe screen guy.\n\n<h3>int String;</h3>\nThe screen string.\n\n<h3>int RoomType;</h3>\nThe screen room type. Use the `RT_` constants for this value.\n\n<h3>int Catchall;</h3>\nThe screen's 'catchall' value. This is the roomtype-specific data, such as the 'Special Item' in a 'Special Item' room."
                        },
                        {
                            "name": "Screen Item ;; mapdata::Item / Screen::Item / mapdata::ItemX / Screen::ItemX / mapdata::ItemY / Screen::ItemY",
                            "val": "<h3>int Item;</h3>\nThe item placed on the screen. -1 if no item placed.\n\n<h3>int ItemX;\nint ItemY;</h3>\nThe X/Y position the screen's item spawns at."
                        },
                        {
                            "name": "Warp Data ;; screen_warp_data / mapdata::TileWarpType / Screen::TileWarpType / mapdata::SideWarpType / Screen::SideWarpType / mapdata::TileWarpOverlay / Screen::TileWarpOverlay / mapdata::SideWarpOverlay / Screen::SideWarpOverlay / mapdata::TileWarpDMap / Screen::TileWarpDMap / mapdata::TileWarpScreen / Screen::TileWarpScreen / mapdata::SideWarpDMap / Screen::SideWarpDMap / mapdata::SideWarpScreen / Screen::SideWarpScreen / mapdata::TileWarpReturnSquare / Screen::TileWarpReturnSquare / mapdata::SideWarpReturnSquare / Screen::SideWarpReturnSquare / mapdata::SideWarpID / Screen::SideWarpID / mapdata::WarpReturnX / Screen::WarpReturnX / mapdata::WarpReturnY / Screen::WarpReturnY / mapdata::WarpArrivalX / Screen::WarpArrivalX / mapdata::WarpArrivalY / Screen::WarpArrivalY / mapdata::TimedWarpTimer / Screen::TimedWarpTimer",
                            "val": "<h3>Note:</h3>\nMost of these arrays are indexed via the `WARP_` constants; where `WARP_A` is 0, through `WARP_D` as 3.\n\n<h3>int TileWarpType[4];\nint SideWarpType[4];</h3>\nThe warp type of the given warp. Use the `WT_` constants for these values.\n\n<h3>bool TileWarpOverlay[4];\nbool SideWarpOverlay[4];</h3>\nThe state of the `Combos Carry Over` checkbox for each warp.\n\n<h3>int TileWarpDMap[4];\nint TileWarpScreen[4];\nint SideWarpDMap[4];\nint SideWarpScreen[4];</h3>\nThe DMap and Screen that make up the destination of each warp.\n\n<h3>int TileWarpReturnSquare[4];\nint SideWarpReturnSquare[4];</h3>\nThe return square set as the destination for each warp. 0 = A, 3 = D.\n\n<h3>int SideWarpID[4];</h3>\nThis array is indexed via the `DIR_` constants, with the `WARP_` constants as the values.\nEx: `SideWarpID[DIR_UP] = WARP_A;` sets the Up sidewarp to use Side Warp A.\n\n<h3>int WarpReturnX[4];\nint WarpReturnY[4];</h3>\nThe X/Y coordinates of the 4 blue return squares\n\n<h3>int WarpArrivalX;\nint WarpArrivalY;</h3>\nThe X/Y coordinates of the old green arrival square.\n\n<h3>int TimedWarpTimer;</h3>\nThe timer used for executing a timed warp."
                        },
                        {
                            "name": "State / ExState / ExDoor ;; mapdata::State / Screen::State / mapdata::ExState / Screen::ExState / mapdata::GetExDoor / Screen::GetExDoor / mapdata::SetExDoor / Screen::SetExDoor",
                            "val": "<h3>bool State[32];</h3>\nThe screen states used for this screen. Use the `ST_` constants to access this.\n\n<h3>bool ExState[32];</h3>\nThe 32 'Extra States' used for this screen.\n\n<h3>bool GetExDoor(int dir, int index);</h3>\nReturns a door state for the screen.\nEach direction (DIR_UP,DIR_DOWN,DIR_LEFT,DIR_RIGHT) has 8 indexes (0-7)\n\n<h3>void SetExDoor(int dir, int index, bool state);</h3>\nSets a door state for the screen.\nEach direction (DIR_UP,DIR_DOWN,DIR_LEFT,DIR_RIGHT) has 8 indexes (0-7)"
                        },
                        {
                            "name": "--&gt; Next ;;mapscrShare2",
                            "val": "$-1$2"
                        },
                        {
                            "name": "--&gt;&gt; End ;;mapscrShare3",
                            "val": "$-1$3"
                        }
                    ]
                },
                {
                    "name": "Shared w/ Screen 2",
                    "lines": [
                        {
                            "name": "&lt;-- MapData Pointers ;; mapdataptr",
                            "val": "$MapData"
                        },
                        {
                            "name": "&lt;-- Screen Pointer ;; screenptr",
                            "val": "$Screen"
                        },
                        {
                            "name": "Script Data ;; mapdata::Script / mapdata::InitD / Screen::Script / Screen::InitD",
                            "val": "<h3>int Script;</h3>\nThe screen script that runs on this screen.\n\n<h3>untyped InitD[8];</h3>\nThe 8 script arguments for the script that runs on this screen."
                        },
                        {
                            "name": "Palette ;; mapdata::Palette / Screen::Palette",
                            "val": "<h3>int Palette;</h3>\nThe palette set in the F4 menu in ZQuest for this screen. Has no effect during play, but can be read and written."
                        },
                        {
                            "name": "Door ;; mapdata::Door / Screen::Door",
                            "val": "<h3>int Door[4];</h3>\nThe 4 door states of the screen, indexed with the `DIR_` constants.\nUse the `D_` constants for the values."
                        },
                        {
                            "name": "Maze Paths ;; mapdata::MazePath / mapdata::ExitDir / Screen::MazePath / Screen::ExitDir",
                            "val": "<h3>int MazePath[4];</h3>\nThe four directions you must go for the maze path. Use the `DIR_` constants for the values.\n\n<h3>int Exitdir;</h3>\nThe direction that exits the maze path instantly. Use the `DIR_` constants for the value."
                        },
                        {
                            "name": "Screen Enemies ;; mapdata::Enemy / mapdata::Pattern / Screen::Enemy / Screen::Pattern",
                            "val": "<h3>int Enemy[10];</h3>\nThe 10 enemies that appear on this screen.\n\n<h3>int Pattern;</h3>\nThe spawn pattern for the screen enemies. Use the `PATTERN_` constants for the value.\n\nRelated: ${Screen::SpawnScreenEnemies|Screen->SpawnScreenEnemies}"
                        },
                        {
                            "name": "UnderCombo / UnderCSet ;; mapdata::UnderCombo / mapdata::UnderCSet / Screen::UnderCombo / Screen::UnderCSet",
                            "val": "<h3>int UnderCombo;</h3>\nThe screen's undercombo, which will appear as a result of various combo interactions, such as pushing blocks, awakening armos, etc.\n\n<h3>int UnderCSet;</h3>\nThe CSet associated with the undercombo."
                        },
                        {
                            "name": "CSensitive",
                            "val": "<h3>int CSensitive;</h3>\nThe value of damage combo sensitivity for the screen."
                        },
                        {
                            "name": "Carry Flags ;; mapdata::NoReset / mapdata::NoCarry / Screen::NoReset / Screen::NoCarry / mapdata::NextMap / Screen::NextMap / mapdata::NextScreen / Screen::NextScreen",
                            "val": "<h3>int NoReset;</h3>\nThe `No Reset` carryover flags.\n#{Values|<ul><li>NORESET_B_SECRET: 0x2000</li>\n<li>NORESET_B_ITEM: 0x0010</li>\n<li>NORESET_B_SPECIALITEM: 0x0020</li>\n<li>NORESET_B_LOCKBLOCK: 0x0100</li>\n<li>NORESET_B_BOSSLOCKBLOCK: 0x0200</li>\n<li>NORESET_B_CHEST: 0x0400</li>\n<li>NORESET_B_LOCKEDCHEST: 0x0800</li>\n<li>NORESET_B_BOSSCHEST: 0x1000</li>\n<li>NORESET_B_DOOR_B_UP: 0x0001</li>\n<li>NORESET_B_DOOR_B_DOWN: 0x0002</li>\n<li>NORESET_B_DOOR_B_LEFT: 0x0004</li>\n<li>NORESET_B_DOOR_B_RIGHT: 0x0008</li></ul>}\n\n<h3>int NoCarry;</h3>\nThe `No Carry Over` carryover flags.\n#{Values|<ul><li>NOCARRY_B_SECRET: 0x2000</li>\n<li>NOCARRY_B_ITEM: 0x0010</li>\n<li>NOCARRY_B_SPECIALITEM: 0x0020</li>\n<li>NOCARRY_B_LOCKBLOCK: 0x0100</li>\n<li>NOCARRY_B_BOSSLOCKBLOCK: 0x0200</li>\n<li>NOCARRY_B_CHEST: 0x0400</li>\n<li>NOCARRY_B_LOCKEDCHEST: 0x0800</li>\n<li>NOCARRY_B_BOSSCHEST: 0x1000</li></ul>}\n\n<h3>int NextMap;\nint NextScreen;</h3>\n\nThe map and screen that screen states carry over to."
                        },
                        {
                            "name": "Layer Info ;; mapdata::LayerMap / mapdata::LayerScreen / Screen::LayerMap / Screen::LayerScreen / mapdata::LayerInvisible / Screen::LayerInvisible / mapdata::LayerOpacity / Screen::LayerOpacity",
                            "val": "<h3>int LayerMap[7];\nint LayerScreen[7];</h3>\nThe map and screen for each layer. Index [0] of these arrays does nothing, and is invalid to access.\n\n<h3>int LayerOpacity[7];</h3>\nThe opacity value (`OP_OPAQUE` or `OP_TRANS`) for each layer. Index [0] does nothing, and is invalid to access.\n\n<h3>bool LayerInvisible[7];</h3>\nIf true, the given layer is invisible and will not be drawn.\n"
                        },
                        {
                            "name": "&lt;-- Prev ;;mapscrShare",
                            "val": "$-1$1"
                        },
                        {
                            "name": "--&gt; Next ;;mapscrShare3",
                            "val": "$-1$3"
                        }
                    ]
                },
                {
                    "name": "Shared w/ Screen 3",
                    "lines": [
                        {
                            "name": "&lt;-- MapData Pointers ;; mapdataptr",
                            "val": "$MapData"
                        },
                        {
                            "name": "&lt;-- Screen Pointer ;; screenptr",
                            "val": "$Screen"
                        },
                        {
                            "name": "ScriptDraws ;; mapdata::ScriptDraws / Screen::ScriptDraws",
                            "val": "<h3>bool ScriptDraws[8];</h3>\nIf false, the given layer of script draws will be disabled on this screen."
                        },
                        {
                            "name": "Valid ;; mapdata::Valid / Screen::Valid",
                            "val": "<h3>bool Valid</h3>\nReturns true if the screen is 'valid'. Screens that appear with the default blue background in ZQuest are 'invalid'. Modifying a combo on a screen makes it become 'valid'. If a layer is 'invalid', it will not be drawn."
                        },
                        {
                            "name": "DoorComboSet ;; mapdata::DoorComboSet / Screen::DoorComboSet",
                            "val": "<h3>int DoorComboSet;</h3>\nThe Door Set used for the NES dungeon doors on this screen."
                        },
                        {
                            "name": "Stairs ;; mapdata::StairsX / mapdata::StairsY / Screen::StairsX / Screen::StairsY",
                            "val": "<h3>int StairsX;\nint StairsY;</h3>\n\nThe X/Y position of the 'Stairs' secret on the screen."
                        },
                        {
                            "name": "Flags ;; mapdata::EFlags[] / Screen::EFlags[] / mapdata::SFlags[] / Screen::SFlags[] / mapdata::Flags[] / Screen::Flags[]",
                            "val": "<h3>int Flags[];</h3>\nArrays containing flag data for each screen.\nTo access these, use the following std_zh functions:\n`int ScreenFlag(int category, int flag);`\n`int ScreenFlag(mapdata m, int category, int flag);`\nUse the `SF_` constants for `category`, and the matching set of either the `SFR_`, `SFV_`, `SFS_`, `SFW_`, `SFI_`, `SFC_`, `SFSV_`, `SFF_`, `SFWH_`, or `SFM_` constants for `flag`.\n\n<h3>int EFlags[];</h3>\nArrays containing flag data for each screen.\nTo access these, use the following std_zh functions:\n`int ScreenEFlag(int category, int flag);`\n`int ScreenEFlag(mapdata md, int category, int flag)`\nUse the `SEF_` constants for `category`, and the matching set of either the `SEFSP_`, `SEFL1_`, or `SEFL2_` constants for `flag`."
                        },
                        {
                            "name": "LensShows / LensHides ;; mapdata::LensShows / mapdata::LensHides / Screen::LensShows / Screen::LensHides",
                            "val": "<h3>bool LensShows[7];\nbool LensHides[7];</h3>\nArrays of the 7 layer show/hide values for the lens of truth.\nIf a `LensShows[]` index is true, the layer will only be visible while using the lens.\nIf a `LensHides[]` index is true, the layer only be visible when NOT using the lens.\nWriting an index true in one array, forces it false in the other."
                        },
                        {
                            "name": "Misc Data Array ;; Screen::Data[] / Screen::DataSize / mapdata::Data[] / mapdata::DataSize",
                            "val": "<h3>int DataSize;</h3>\nRead-write, the size of the `Data[]` array.\n\n<h3>untyped Data[];</h3>\nResizable array of data for scripts to use. All changes are saved to the save file."
                        },
                        {
                            "name": "&lt;&lt;-- Start",
                            "val": "$-1$1"
                        },
                        {
                            "name": "&lt;-- Prev ;;mapscrShare2",
                            "val": "$-1$2"
                        }
                    ]
                }
            ]
        },
        {
            "name": "Bitmap",
            "tabs": [
                {
                    "name": "Bitmap 1",
                    "lines": [
                        {
                            "name": "&lt;-- Managed Pointers ;; function_data_managed",
                            "val": "$0$7"
                        },
                        {
                            "name": "<em>bitmap</em>",
                            "val": "<h3>Bitmap Pointers</h3>   `bitmap`\n\n`bitmap` pointers allow creating, manipulating, and storing visual data.\n\nA number of drawing commands from `bitmap` are shared with `Screen->`.\n\nSee: ${CreateBitmap}, ${bitmap::Create|Create}"
                        },
                        {
                            "name": "Shared w/ Screen-> ;; bitscrShare",
                            "val": "$Bitmap$2"
                        },
                        {
                            "name": "Width / Height ;; bitmap::Width / bitmap::Height",
                            "val": "<h3>int Width;\nint Height;</h3>\n\nRead-only. The width/height of the bitmap *at the start of this frame* in pixels."
                        },
                        {
                            "name": "Pointer Management ;; bitmap::isAllocated / bitmap::isValid / bitmap::Free / bitmap::Own",
                            "val": "<h3>bool isAllocated();</h3>\nReturns true if the bitmap pointer has been allocated for use.\n\n<h3>bool isValid();</h3>\nReturns true if the bitmap pointer has been created to be drawn to.\n\n<h3>void Free();</h3>\nDe-allocates this `bitmap` pointer, so that its' pointer ID may be re-used. You may only have a limited number of bitmap pointers active at a time; freeing them when you are done with them helps not reach the limit.\n\n<h3>void Own();</h3>\nGrants 'Ownership' of the bitmap pointer to the script that calls this function. When the script with 'Ownership' terminates (at the same time its' local arrays are deallocated), this bitmap pointer will automatically be 'Free()'d."
                        },
                        {
                            "name": "File IO ;; bitmap::Read / bitmap::Write",
                            "val": "<h3>void Read(int layer, char32 filename[]);</h3>\n\nReads from the specified image file into the bitmap.  Read() will fail if:\n<ul>\n<li>The file is corrupt:</li>\n<ul>\n<li>PNG, JPEG, or other 'compressed' formats may abort if the file is corrupt.</li>\n<li>Formats such as .BMP or .TGA may read up until missing data, as they are linear.</li>\n</ul>\n<li>The file is missing.</li>\n<li>The filename is incorrect. Remember that POSIX filesystems are Case-SenSitive.</li>\n</ul>\n\nIf [[\"All bitmap-> and FileSystem-> paths relative to quest 'Files' folder\"|at \"ZScript->Quest Script Settings->Instructions\"]] is enabled, paths are relative to the quest's specific directory; otherwise they are relative to the ZC folder.\n\n<h3>void Write(int layer, char32 filename[], bool allow_overwrite = false);</h3>\n\nWrites from the bitmap to the specified image file. Requires one of: `.png`,`.gif`,`pcx`,`.tgx`,`.bmp`. Fails otherwise.\n\nWill not replace an existing file, unless `allow_overwrite` is true. Will automatically create missing directories on the specified path.\n\nIf [[\"All bitmap-> and FileSystem-> paths relative to quest 'Files' folder\"|at \"ZScript->Quest Script Settings->Instructions\"]] is enabled, paths are relative to the quest's specific directory; otherwise they are relative to the ZC folder."
                        },
                        {
                            "name": "WriteTile ;; bitmap::WriteTile",
                            "val": "<h3>void WriteTile(int layer, int x, int y, int tile, bool is8bit = true, bool mask = false);</h3>\nWrites a 16x16 area from the bitmap to the tile `tile`. The tile's 8-bit status will be set to the value of `is8bit`. If `mask` is true, the draw will be an `Overlay`- otherwise it will overwrite."
                        },
                        {
                            "name": "Creating / Clearing ;; bitmap::Create / bitmap::Clear / bitmap::ClearToColor",
                            "val": "<h3>void Create(int layer = 0, int width = 256, int height = 256);</h3>\nCreates a bitmap on the pointer of `width by height`, destroying any data that was previously on the pointer.\n\nIf [[\"Old Args for CreateBitmap and bitmap->Create()\"|at \"ZScript->Quest Script Settings->Instructions\"]] is enabled, then `width` and `height` are swapped with each other.\n\n<h3>void Clear(int layer = 0);</h3>\nClears the bitmap to color 0 on the specified layer timing.\n\n<h3>void ClearToColor(int layer, int color);</h3>\nClears the bitmap to the specified color on the specified layer timing."
                        },
                        {
                            "name": "--&gt; Next ;;bitmapptr2",
                            "val": "$-1$1"
                        }
                    ]
                },
                {
                    "name": "Bitmap 2",
                    "lines": [
                        {
                            "name": "&lt;-- Managed Pointers ;; function_data_managed",
                            "val": "$0$7"
                        },
                        {
                            "name": "Pixel Checking ;; bitmap::GetPixel / bitmap::CountColor",
                            "val": "<h3>int GetPixel(int x, int y);</h3>\nReturns the palette index at the given position on the bitmap *at the start of the frame*. This does not account for this frame's draws that have yet to happen.\n\n<h3>int CountColor(bitmap mask, int x, int y, int checkColor, int maskColor = -1);</h3>\nChecks the area of this bitmap specified by the area on the `mask` bitmap which matches the `maskColor`. For a `maskColor` of `-1`, all non-zero values will match.\n\nReturns the number of pixels in said area that match the `checkColor` on this bitmap. For a `checkColor` of `-1`, all non-zero values will match.\n\nThe area checked is from `x,y` to `x+mask->Width,y+mask->Height`. If this goes out of bounds, the out of bounds area is ignored.\n\nThis does not account for this frame's draws that have yet to happen."
                        },
                        {
                            "name": "Masked Draws ;; bitmap::MaskedDraw / bitmap::MaskedBlit",
                            "val": "<h3>void Dither(int layer, bitmap mask, int color, int ditherType, int ditherArg);</h3>\nDraws `color` onto the bitmap on pixels that are non-color-0 on the `mask` bitmap, based on the [[`ditherType`|`DITH_` constants]]\n\n<h3>void MaskedDraw(int layer, bitmap mask, int color);\nvoid MaskedDraw(int layer, bitmap mask, int color, int maskColor);\nvoid MaskedDraw(int layer, bitmap mask, int color, int startMaskColor, int endMaskColor);</h3>\n\nDraws `color` to this bitmap, in the area specified by the `mask`. Any pixel on the `mask` which matches the `maskColor` will be drawn.\n\nIf no `maskColor` is specified, all non-zero pixels will be considered matching. If a `startMaskColor`+`endMaskColor` are defined, colors between them, inclusive, will be considered matching.\n\n<h3>void MaskedBlit(int layer, bitmap mask, bitmap pattern, bool repeatPattern);\nvoid MaskedBlit(int layer, bitmap mask, bitmap pattern, bool repeatPattern, int maskColor);\nvoid MaskedBlit(int layer, bitmap mask, bitmap pattern, bool repeatPattern, int startMaskColor, int endMaskColor);</h3>\n\nSame as `MaskedDraw`, except instead of drawing a specified `color` to this bitmap, it draws from a `pattern` bitmap.\n\nIf `repeatPattern` is false, the area from `0,0` to `pattern->Width-1`,`pattern->Height-1` will be drawn.\n\nIf `repeatPattern` is true, the entire bitmap will be drawn, repeating the `pattern` both horizontally and vertically tiled."
                        },
                        {
                            "name": "<h3>void ReplaceColors(int layer, int color, int startCol, int endCol);</h3>\nReplaces colors that are &gt;= startCol and &lt;= endCol with `color`.\n\n<h3>void ShiftColors(int layer, int shift, int startCol, int endCol);</h3>\nShifts colors that are &gt;= startCol and &lt;= endCol by adding `shift` to them.",
                            "val": "<h3>void ReplaceColors(int layer, int color, int startCol, int endCol);</h3>\nReplaces colors that are &gt;= startCol and &lt;= endCol with `color`.\n\n<h3>void ShiftColors(int layer, int shift, int startCol, int endCol);</h3>\nShifts colors that are &gt;= startCol and &lt;= endCol by adding `shift` to them."
                        },
                        {
                            "name": "Blitting ;; bitmap::Blit / bitmap::BlitTo",
                            "val": "<h3>void Blit(int layer, bitmap target,\n        int sx, int sy, int sw, int sh,\n        int dx, int dy, int dw, int dh,\n        [[float rotation = 0|Degrees]], int cx = 0, int cy = 0,\n        [[int mode = 0|`BITDX_` constants]], int lit = 0,  bool mask = true);</h3>\n\nDraws an area specified by the (sx,sy,sw,sh) from this bitmap to the destination area (dx,dy,dw,dh) of the target bitmap.\n\nIf 'rotation' is non-zero, rotates the draw around the (cx,cy) point.\n\n'lit', if non-zero, will attempt to tint the draw based on that palette index.\n\nIf 'mask' is false, color 0 will draw as color 0 instead of transparent.\n\n<h3>void BlitTo(int layer, bitmap source,\n        int sx, int sy, int sw, int sh,\n        int dx, int dy, int dw, int dh,\n        [[float rotation = 0|Degrees]], int cx = 0, int cy = 0,\n        [[int mode = 0|`BITDX_` constants]], int lit = 0,  bool mask = true);</h3>\n\nAs `Blit()`, but draws from (sx,sy,sw,sh) of the `source` bitmap to (dx,dy,dw,dh) of this bitmap."
                        },
                        {
                            "name": "DrawPlane ;; bitmap::DrawPlane",
                            "val": "<h3>void DrawPlane(int layer, bitmap src, int sx, int sy, int dx,\r\n\tint dy, int dw, int dh, int space_z, int horizon, \r\n\tfloat scale_x = 1, float scale_y = 1, bool mask = true);</h3>\n\nDraws a scaled 'Mode 7' style effect, line-by-line, where each raster is scaled down toward a horizon point."
                        },
                        {
                            "name": "Specialized DrawScreen ;; bitmap::DrawScreenSolid / bitmap::DrawScreenSolidity / bitmap::DrawScreenComboTypes / bitmap::DrawScreenComboFlags / bitmap::DrawScreenComboIFlags",
                            "val": "<h3>void DrawScreenSolid(int layer, \n        int map, int source_screen, \n        int x, int y, float rotation = 0);</h3>\n\nDraws the solidity mask entire screen from screen on map on the specified layer of the bitmap at (x,y) in colour index 1. If rotation is not zero, it(the entire screen) will rotate about its center.\n\n<h3>void DrawScreenSolidity(int layer, \n        int map, int source_screen, \n        int x, int y, float rotation = 0);</h3>\n\nDraws the solidity value for each combo position of an entire screen from screen on map on the specified layer of the bitmap at (x,y). Each combo position will be drawn in the palette index equal to its value as ComboS[]. If rotation is not zero, it(the entire screen) will rotate about its center.\n\n<h3>void DrawScreenComboTypes(int layer, \n        int map, int source_screen, \n        int x, int y, float rotation = 0);</h3>\n\nDraws the combo type value for each combo position of an entire screen from screen on map on the specified layer of the bitmap at (x,y). Each combo position will be drawn in the palette index equal to its value as ComboT[]. If rotation is not zero, it(the entire screen) will rotate about its center.\n\n<h3>void DrawScreenComboIFlags(int layer, \n        int map, int source_screen, \n        int x, int y, float rotation = 0);</h3>\n\nAs `DrawScreenComboTypes`, but `ComboI[]` instead of `ComboT[]`\n\n<h3>void DrawScreenComboFlags(int layer, \n        int map, int source_screen, \n        int x, int y, float rotation = 0);</h3>\n\nAs `DrawScreenComboTypes`, but `ComboF[]` instead of `ComboT[]`"
                        },
                        {
                            "name": "--",
                            "val": ""
                        },
                        {
                            "name": "&lt;-- Prev ;;bitmapptr",
                            "val": "$-1$0"
                        }
                    ]
                },
                {
                    "name": "Shared w/ Screen 1",
                    "lines": [
                        {
                            "name": "&lt;-- Bitmap Pointers ;; bitmapptr",
                            "val": "$Bitmap"
                        },
                        {
                            "name": "&lt;-- Screen Pointer ;; screenptr",
                            "val": "$Screen"
                        },
                        {
                            "name": "Info",
                            "val": "These functions and variables are shared between `Screen->` and `bitmap->` pointers. For `Screen->`, draws go to the visible screen itself; while for `bitmap->`, draws go to the bitmap's stored pixels."
                        },
                        {
                            "name": "Rectangle ;; bitmap::Rectangle / Screen::Rectangle ;; Rectangle",
                            "val": "<h3>void Rectangle(int layer, int x, int y, int x2, int y2, int color,\n        float scale = 1, int rx = 0, int ry = 0, [[int rangle = 0|Degrees]],\n        bool fill = true, int opacity = OP_OPAQUE);</h3>\n\nDraws a rectangle from the (x,y) corner to the (x2,y2) corner. If 'fill' is true, the rectangle will be filled with the color, otherwise it will be a 1-pixel outline of the color.\n\nIf scale is not '1', it will scale the size of the rectangle.\nIf 'rangle' is not 0, it will rotate the draw around the (rx,ry) point."
                        },
                        {
                            "name": "Circle ;; Screen::Circle / bitmap::Circle ;; Circle",
                            "val": "<h3>void Circle(int layer, int x, int y, int radius, int color,\n        float scale = 1, int rx = 0, int ry = 0, [[int rangle = 0|Degrees]],\n        bool fill = true, int opacity = OP_OPAQUE);</h3>\n\nDraws a circle of radius `radius` centered on the point (x,y). If 'fill' is true, the circle will be filled with the color, otherwise it will be a 1-pixel outline of the color.\n\nIf scale is not '1', it will scale the size of the circle.\nIf 'rangle' is not 0, it will rotate the draw around the (rx,ry) point."
                        },
                        {
                            "name": "Arc ;; Screen::Arc / bitmap::Arc ;; Arc",
                            "val": "<h3>void Arc(int layer, int x, int y, int radius,\n        [[int startangle, int endangle|Degrees]], int color,\n        float scale = 1, int rx = 0, int ry = 0, [[int rangle = 0|Degrees]],\n        bool closed = true, bool fill = true, int opacity = OP_OPAQUE);</h3>\n\nDraws an arc from 'startangle' to 'endangle' degrees of a circle of radius `radius` centered on the point (x,y). If 'closed' is true, the ends of the arc will be connected to the point (x,y), creating a slice of a pie chart shape. If 'fill' is true, the arc will be filled with the color, otherwise it will be a 1-pixel outline of the color.\n\nThis function is undefined unless `0 &lt;= (endangle-startangle) &lt; 360`.\n\nIf scale is not '1', it will scale the size of the arc.\nIf 'rangle' is not 0, it will rotate the draw around the (rx,ry) point."
                        },
                        {
                            "name": "Ellipse ;; Screen::Ellipse / bitmap::Ellipse ;; Ellipse",
                            "val": "<h3>void Ellipse(int layer, int x, int y, int xradius,\n        int yradius, int color, float scale = 1,\n        int rx = 0, int ry = 0, [[int rangle = 0|Degrees]],\n        bool fill = true, int opacity = OP_OPAQUE);</h3>\n\nDraws an ellipse of radii `xradius, yradius` centered on the point (x,y). If 'fill' is true, the ellipse will be filled with the color, otherwise it will be a 1-pixel outline of the color.\n\nIf scale is not '1', it will scale the size of the ellipse.\nIf 'rangle' is not 0, it will rotate the draw around the (rx,ry) point."
                        },
                        {
                            "name": "Line ;; Screen::Line / bitmap::Line ;; Line",
                            "val": "<h3>void Line(int layer, int x, int y, int x2, int y2, int color,\n        float scale = 1, int rx = 0, int ry = 0, [[int rangle = 0|Degrees]],\n        int opacity = OP_OPAQUE);</h3>\n\nDraws a line from the (x,y) point to the (x2,y2) point.\n\nIf scale is not '1', it will scale the size of the line.\nIf 'rangle' is not 0, it will rotate the draw around the (rx,ry) point."
                        },
                        {
                            "name": "Spline ;; Screen::Spline / bitmap::Spline ;; Spline",
                            "val": "<h3>void Spline(int layer, int x1, int y1, int x2, int y2,\n        int x3, int y3, int x4, int y4, int color,\n        int opacity = OP_OPAQUE);</h3>\n\nDraws a cardinal spline on the screen."
                        },
                        {
                            "name": "PutPixel ;; Screen::PutPixel / bitmap::PutPixel ;; PutPixel",
                            "val": "<h3>void PutPixel(int layer, int x, int y, int x2, int y2, int color,\n        int rx = 0, int ry = 0, [[int rangle = 0|Degrees]],\n        int opacity = OP_OPAQUE);</h3>\n\nDraws a pixel at (x,y).\n\nIf 'rangle' is not 0, it will rotate the draw around the (rx,ry) point."
                        },
                        {
                            "name": "DrawInteger / DrawCharacter ;; Screen::DrawInteger / bitmap::DrawInteger / Screen::DrawCharacter / bitmap::DrawCharacter ;; DrawInteger / DrawCharacter",
                            "val": "<h3>void DrawInteger(int layer, int x, int y, int font, int color,\n        int background_color, int width, int height, int val, int num_decimal_places = 0,\n        int opacity = OP_OPAQUE);</h3>\n\nDraws a number, in the font specified using `FONT_` constants, with the top-left at (x,y). The number will be exactly width by height pixels, in the `color`. If `background_color` is not `-1`, it will be drawn behind the number in a rectangle. Up to 'num_decimal_places' places after the decimal point will be shown.\n\n<h3>void DrawCharacter(int layer, int x, int y, int font, int color,\r\n        int background_color, int width, int height, char32 char,\r\n        int opacity = OP_OPAQUE);</h3>\r\n\r\nDraws a single character, in the font specified using `FONT_` constants, with the top-left at (x,y). The character will be exactly width by height pixels, in the `color`. If `background_color` is not `-1`, it will be drawn behind the character in a rectangle."
                        },
                        {
                            "name": "DrawString ;; Screen::DrawString / bitmap::DrawString ;; DrawString",
                            "val": "<h3>void DrawString(int layer, int x, int y, int font, int color, int format,\n        int background_color, char32 str[], int opacity = OP_OPAQUE);</h3>\n\nDraws a string, in the font specified using `FONT_` constants, in the 'color'. If `background_color` is not `-1`, it will be drawn behind the string in a rectangle. Where the string is drawn depends on the `format`:\n<ul>\n<li>TF_NORMAL: Top-left of string is at (x,y)</li>\n<li>TF_CENTERED: Top-center of string is at (x,y)</li>\n<li>TF_RIGHT: Top-right of string is at (x,y)</li>\n</ul>\n\n<h3>void DrawString(int layer, int x, int y, int font, int color, int format,\n        int background_color, char32 str[], int opacity,\n        int shadow_type, int shadow_color);</h3>\n\nSame as the above version of DrawString(), except the string is drawn with a shadow. The shadow's style is defined as `SHD_` constants, and the shadow will be drawn in the specified `shadow_color`."
                        },
                        {
                            "name": "--&gt; Next ;;bitscrShare2",
                            "val": "$-1$3"
                        }
                    ]
                },
                {
                    "name": "Shared w/ Screen 2",
                    "lines": [
                        {
                            "name": "&lt;-- Bitmap Pointers ;; bitmapptr",
                            "val": "$Bitmap"
                        },
                        {
                            "name": "&lt;-- Screen Pointer ;; screenptr",
                            "val": "$Screen"
                        },
                        {
                            "name": "Tile Draws ;; Screen::DrawTileCloaked / bitmap::DrawTileCloaked / Screen::DrawTile / bitmap::DrawTile / Screen::FastTile / bitmap::FastTile",
                            "val": "<h3>void FastTile(int layer, int x, int y, int tile, int cset, int opacity = OP_OPAQUE);</h3>\n\nDraws the specified tile in the specified cset, with the upper-left at (x,y).\n\n<h3>void DrawTile(int layer, int x, int y, int tile, int blockw, int blockh,\n        int cset, int xscale = -1, int yscale = -1, int rx = 0, int ry = 0, [[int rangle = 0|Degrees]],\n        int flip = 0, bool transparency = true, int opacity = OP_OPAQUE);</h3>\n\nDraws a block of tiles starting from the specified tile, in the specified cset, with the upper-left at (x,y).\nThe size of the tile block is determined by `blockw` and `blockh`, which must be integers from 1 to 20 inclusive.\nIf `xscale` and `yscale` are both >0, the draw will be stretched to be `xscale by yscale` pixels. Otherwise, the draw will be `16*blockw by 16*blockh` pixels.\nIf `transparency` is false, color 0 in the tile will be drawn as color 0 instead of transparent.\nThe draw will be flipped based on `flip`, using the `FLIP_` constants.\nIf 'rangle' is not 0, it will rotate the draw around the (rx,ry) point.\nIf 'rx' OR 'ry' is `<= -777`, it will rotate around the center of the draw instead of an arbitrary point.\n\n<h3>void DrawTileCloaked(int layer, int x, int y, int tile, int blockw, int blockh, int flip = 0);</h3>\n\nSimilar to `DrawTile()`, but draws with a \"cloaked\" effect. This means that it does not actually draw the tiles, but instead it distorts the destination bitmap in the draw area based on the pixels in the tiles."
                        },
                        {
                            "name": "Combo Draws ;; Screen::DrawComboCloaked / bitmap::DrawComboCloaked / Screen::DrawCombo / bitmap::DrawCombo / Screen::FastCombo / bitmap::FastCombo ;; FastCombo / DrawCombo / DrawComboCloaked",
                            "val": "<h3>void FastCombo(int layer, int x, int y, int combo, int cset, int opacity = OP_OPAQUE);</h3>\n\nAs ${FastTile|FastTile()}, for the current tile of `combo`.\n\n<h3>void DrawCombo(int layer, int x, int y, int combo, int blockw, int blockh,\n        int cset, int xscale = -1, int yscale = -1, int rx = 0, int ry = 0, [[int rangle = 0|Degrees]],\n        int flip = 0, bool transparency = true, int opacity = OP_OPAQUE);</h3>\n\nAs ${DrawTile|DrawTile()}, but for the current tile of the combos.\n\n<h3>void DrawComboCloaked(int layer, int x, int y, int combo, int blockw, int blockh, int flip = 0);</h3>\n\nAs ${DrawTileCloaked|DrawTileCloaked()}, but for the current tile of the combos."
                        },
                        {
                            "name": "Quad ;; Screen::Quad / bitmap::Quad ;; Quad",
                            "val": "<h3>void Quad(int layer, int x1, int y1, int x2, int y2, int x3, int y3,\n        int x4, int y4, int w, int h, int cset, int flip,\n        int texture, [[int render_mode|`PT_` constants]], bitmap render_source = NULL);</h3>\n\nNOTE: the `bitmap render_source` parameter is only available for `bitmap-&gt;Quad()`, not `Screen-&gt;Quad()`.\n\nDraws a quad with the 4 specified corners, drawn counterclockwise from (x1,y1).\n\nThe texture is mapped from a tile or tile block if `texture &gt; 0`, or a combo/combo block if `texture &lt;= 0`. (Ex: texture = -32 will use combo 32 as a texture). `w, h` must be values from 1 to 16, and must be powers of 2.\n\nFor `bitmap-&gt;Quad()`, if `render_source` is a valid bitmap, a section of it (based on `w, h`) will be used as the texture instead."
                        },
                        {
                            "name": "Triangle ;; Screen::Triangle / bitmap::Triangle ;; Triangle",
                            "val": "<h3>void Triangle(int layer, int x1, int y1, int x2, int y2, int x3, int y3,\n        int w, int h, int cset, int flip, int texture,\n        [[int render_mode|`PT_` constants]], bitmap render_source = NULL);</h3>\n\nNOTE: the `bitmap render_source` parameter is only available for `bitmap-&gt;Triangle()`, not `Screen-&gt;Triangle()`.\n\nDraws a triangle with the 3 specified corners, drawn counterclockwise from (x1,y1).\n\nThe texture is mapped from a tile or tile block if `texture &gt; 0`, or a combo/combo block if `texture &lt;= 0`. (Ex: texture = -32 will use combo 32 as a texture). `w, h` must be values from 1 to 16, and must be powers of 2.\n\nFor `bitmap-&gt;Triangle()`, if `render_source` is a valid bitmap, a section of it (based on `w, h`) will be used as the texture instead."
                        },
                        {
                            "name": "Quad3D ;; Screen::Quad3D / bitmap::Quad3D ;; Quad3D",
                            "val": "<h3>void Quad3D(int layer, int pos[12], uv[8], csets[4], size[2], int flip,\n        int texture, [[int render_mode|`PT_` constants]], bitmap render_source = NULL);</h3>\n\nNOTE: the `bitmap render_source` parameter is only available for `bitmap-&gt;Quad3D()`, not `Screen-&gt;Quad3D()`.\n\nDraws a 3d quad with the 4 corners specified in `pos` as `{x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4}`. `uv` specifies texture coordinates as `{x1,y1,x2,y2,x3,y3,x4,y4}`. `size` specifies the texture's `{w,h}`.\n\nThe texture is mapped from a tile or tile block if `texture &gt; 0`, or a combo/combo block if `texture &lt;= 0`. (Ex: texture = -32 will use combo 32 as a texture).\n\nFor `bitmap-&gt;Quad3D()`, if `render_source` is a valid bitmap, a section of it (based on `{w, h}` in `size`) will be used as the texture instead."
                        },
                        {
                            "name": "Triangle3D ;; Screen::Triangle3D / bitmap::Triangle3D ;; Triangle3D",
                            "val": "<h3>void Triangle3D(int layer, int pos[9], uv[6], csets[3], size[2], int flip,\n        int texture, [[int render_mode|`PT_` constants]], bitmap render_source = NULL);</h3>\n\nNOTE: the `bitmap render_source` parameter is only available for `bitmap-&gt;Triangle3D()`, not `Screen-&gt;Triangle3D()`.\n\nDraws a 3d quad with the 4 corners specified in `pos` as `{x1,y1,z1,x2,y2,z2,x3,y3,z3}`. `uv` specifies texture coordinates as `{x1,y1,x2,y2,x3,y3}`. `size` specifies the texture's `{w,h}`.\n\nThe texture is mapped from a tile or tile block if `texture &gt; 0`, or a combo/combo block if `texture &lt;= 0`. (Ex: texture = -32 will use combo 32 as a texture).\n\nFor `bitmap-&gt;Triangle3D()`, if `render_source` is a valid bitmap, a section of it (based on `{w, h}` in `size`) will be used as the texture instead."
                        },
                        {
                            "name": "DrawLayer ;; Screen::DrawLayer / bitmap::DrawLayer ;; DrawLayer",
                            "val": "<h3>void DrawLayer(int layer, \n        int source_map, int source_screen, int source_layer, \n        int x, int y, float rotation = 0, int opacity = OP_OPAQUE);</h3>\n\nDraws the entire layer `source_layer` from the screen `source_map, source_screen`.\nIf `rotation` isn't 0, the layer will be rotated around its' centerpoint."
                        },
                        {
                            "name": "DrawScreen ;; Screen::DrawScreen / bitmap::DrawScreen ;; DrawScreen",
                            "val": "<h3>void DrawScreen(int layer, \n        int source_map, int source_screen, int source_layer, \n        int x, int y, float rotation = 0);</h3>\n\nDraws the entire screen `source_map, source_screen`.\nIf `rotation` isn't 0, the screen will be rotated around its' centerpoint."
                        },
                        {
                            "name": "DrawFrame ;; Screen::DrawFrame / bitmap::DrawFrame ;; DrawFrame",
                            "val": "<h3>void DrawFrame(int layer,\n        int x, int y, int tile, int cset,\n        int width, int height, bool overlay = true,\n        int opacity = OP_OPAQUE);</h3>\n\nDraws a frame using a 2x2 block of tiles, the upper-left tile specified as `tile`. This works the same way as the default \"blue frame\" on engine subscreens.\n`width, height` indicate how many 8x8 pixel squares the frame is wide/high- so `4,4` would give a 32x32 pixel frame.\nIf `overlay` is false, color 0 in the frame tiles will be drawn as color 0 instead of transparent."
                        },
                        {
                            "name": "Polygon ;; Screen::Polygon / bitmap::Polygon ;; Polygon",
                            "val": "<h3>void Polygon(int layer, int num_points, int vertices[],\n        int colour, int opacity = OP_OPAQUE);</h3>\n\nDraws a polygon, where `vertices` is an array, of which the first `num_points*2` indexes are made up of `num_points` `x,y` pairs. (ex for `num_points = 4`, `vertices = {x1,y1,x2,y2,x3,y3,x4,y4}`)."
                        },
                        {
                            "name": "&lt;-- Prev ;;bitscrShare",
                            "val": "$-1$2"
                        }
                    ]
                }
            ]
        },
        {
            "name": "Audio",
            "tabs": [
                {
                    "name": "Audio ROOT",
                    "lines": [
                        {
                            "name": "&lt;-- Global Pointers ;; function_globalptr",
                            "val": "$Base Data$3"
                        },
                        {
                            "name": "<em>Audio</em>",
                            "val": "The `Audio->` pointer holds various functions relating to SFX, MIDI, and Enhanced Music."
                        },
                        {
                            "name": "SFX ;; audio_sfx / Audio::PlaySound / Audio::EndSound / Audio::PauseSound / Audio::ResumeSound / Audio::ContinueSound / Audio::PlaySoundEx / Audio::AdjustSound / Audio::GetSoundCompletion",
                            "val": "<h3>void PlaySound(int sfx);</h3>\nPlays the quest SFX 'sfx'.\n\n<h3>void EndSound(int sfx);</h3>\nIf 'sfx' is playing, immediately stop it.\n\n<h3>void PauseSound(int sfx);</h3>\nIf 'sfx' is playing, pause it (so that it may be resumed later).\n\n<h3>void ResumeSound(int sfx);\nvoid ContinueSound(int sfx);</h3>\nResume 'sfx' from where it was paused.\n\n<h3>void PlaySoundEx(int sfx, int [[volume|Ranges from 0 (mute) to 100 (the player's volume setting)]], int [[pan|Ranges from -128 (left) to 127 (right)]] = 0, long [[freq|If <0L, will use the sound's default frequency]] = -1L, bool [[loop|Is true, the sound will repeat infinitely until played again or terminated with EndSound()]] = false);</h3>\nPlays the quest SFX 'sfx' but with different properties.\n\n<h3>void AdjustSound(int sfx, int [[volume|Ranges from 0 (mute) to 100 (the player's volume setting)]], int [[pan|Ranges from -128 (left) to 127 (right)]] = 0, long [[freq|If <0L, will use the sound's default frequency]] = -1L, bool [[loop|Is true, the sound will repeat infinitely until played again or terminated with EndSound()]] = false);</h3>\nChange properties on a currently playing sound.\n\n<h3>float GetSoundCompletion(int sfx);</h3>\nReturns a rough completion percentage (0-100) for how much of a sound has played.\nReturns -1 if the sound is not currently playing."
                        },
                        {
                            "name": "MIDI ;; audio_midi / Audio::PlayMIDI / Audio::PauseCurMIDI / Audio::ResumeCurMIDI ;; PlayMIDI / PauseCurMIDI / ResumeCurMIDI",
                            "val": "<h3>void PlayMIDI(int midi);</h3>\nPlays the MIDI 'midi'. Will revert upon changing screens.\n\n<h3>void PauseCurMIDI();</h3>\nPauses the currently playing MIDI so that it may be resumed later.\n\n<h3>void ResumeCurMIDI();</h3>\nResumes the previously paused MIDI."
                        },
                        {
                            "name": "Enhanced Music ;; audio_enh / Audio::PlayEnhancedMusic / Audio::CrossfadeEnhancedMusic / Audio::GetMusicPos / Audio::SetMusicPos / Audio::SetMusicSpeed / Audio::GetMusicLength / Audio::SetMusicLoop",
                            "val": "<h3>bool PlayEnhancedMusic(char32[] [[filename|Max 255 characters\nValid Extensions: ogg, mp3, spc, gbs, vgm, gym, nsf, it, xm, s3m, mod]], int track);</h3>\n\nPlays the specified enhanced music, if it's available. If the music format does not support tracks, the track argument is ignored.\nIf the music cannot be played, the current music will continue. The music will revert to normal upon leaving the screen unless ${Audio::MusicRefresh|MusicRefresh} specifies otherwise.\nReturns true if the music file was loaded successfully.\n\n<h3>bool CrossfadeEnhancedMusic(char32[] [[filename|Max 255 characters\nValid Extensions: ogg, mp3, it, xm, s3m, mod]], int track, int [[fadeoutframes|Time in frames it takes for the old music to fade out]], int [[fadeinframes|Time in frames it takes for the new music to fade in]], int [[delayframes|An added delay before the new music fades in. If <0, will delay the old music fading out instead]] = 0, float [[startpos|A starting time for the new music in seconds.]] = 0);</h3>\n\nPlays the specified enhanced music with a crossfade, if it's available. If the music format does not support tracks, the track argument is ignored.\nIf the music cannot be played, the current music will continue. The music will revert to normal upon leaving the screen unless ${Audio::MusicRefresh|MusicRefresh} specifies otherwise.\nReturns true if the music file was loaded successfully.\n\n<h3>int GetMusicPos();</h3>\nReturns the current seek position of the currently playing enhanced music in seconds.\n\n<h3>void SetMusicPos(int new_pos);</h3>\nSets the play position for the currently playing enhanced music in seconds.\n\n<h3>void SetMusicSpeed(int newspeed);</h3>\nSets the playback speed of the currently playing enhanced music.\n\n<h3>void GetMusicLength();</h3>\nReturns the length of the current playing enhanced music in seconds.\n\n<h3>void SetMusicLoop(float start, float end);</h3>\nLoops the currently playing enhanced music between two timestamps in seconds."
                        },
                        {
                            "name": "Volume ;; audio_vol / Audio::adjustsfxvolume / Audio::adjustmusicvolume",
                            "val": "<h3>void AdjustMusicVolume(int percent);</h3>\nAdjusts a multiplier for the volume of all MIDI, DIGI, and Enhanced Music.\nValues range from 0 (mute) to 100 (the player's max volume setting).\n\n<h3>void AdjustSFXVolume(int percent);</h3>\nAdjusts a multiplier for the volume of all Sound Effects (WAV).\nValues range from 0 (mute) to 100 (the player's max volume setting).\n\n<h3>Note:</h3>\nIf the quest rule \"Old (Buggy) ZScript Volume Access\" is enabled, these functions will behave differently:\n#{Deprecated Behavior|\n\n<h3>void AdjustMusicVolume(int percent);</h3>\nAdjusts the music volume (MIDI and Enhanced Music) to 'percent'% of the user's setting.\n\n<h3>void AdjustSFXVolume(int percent);</h3>\nAdjusts the SFX volume to 'percent'% of the user's setting.\n\n<h3>Note:</h3>\nThese <em>set</em> the volume relative to the user's original setting. If the user has a slider set to 0, no amount of calls will make it play sound. If the user has the slider at max, no amount of calls can make it any louder.\nExample: Assume the user has SFX volume at '32', and MIDI volume at '128'.\n```Audio->AdjustSFXVolume(200); //SFX volume is now '64'\nAudio->AdjustMusicVolume(50); //MIDI volume is now '64'\nAudio->AdjustSFXVolume(150); //SFX volume is now '48'\nAudio->AdjustMusicVolume(100); //MIDI volume is now '128'```\n}"
                        },
                        {
                            "name": "PanStyle ;; Audio::PanStyle",
                            "val": "<h3>int PanStyle;</h3>\nThe audio panning style. Use the `PAN_` constants for this value."
                        },
                        {
                            "name": "MusicRefresh ;; audio_musicrefresh / Audio::MusicRefresh / Audio::MusicRefreshFlags",
                            "val": "<h3>int MusicRefresh;</h3>\nThis controls how often the engine refreshes the currently playing music while warping. \nUse the following `MR_` constants:\n<ol start='0'><li>[[MR_SCREEN|Refresh on every screen transition (default behavior)]]</li>\n<li>[[MR_DMAP|Refresh on dmap change]]</li>\n<li>[[MR_LEVEL|Refresh on level change]]</li>\n<li>[[MR_NEVER|Never refresh on warps]]</li></ol>\n\n<h3>bool MusicRefreshFlags[2];</h3>\nA set of flags for handling extra effects on MusicRefresh.\nUse the following `MRF_` constants:\n<ul><li>[[MRF_NOCUT|Music persists through warp types that cut to silence]]</li>\n<li>[[MRF_REVERT|Upon taking a warp that triggers refresh, revert to MR_SCREEN]]</li></ul>"
                        }
                    ]
                }
            ]
        },
        {
            "name": "FileSystem",
            "tabs": [
                {
                    "name": "FileSystem ROOT",
                    "lines": [
                        {
                            "name": "&lt;-- Global Pointers ;; function_globalptr",
                            "val": "$Base Data$3"
                        },
                        {
                            "name": "<em>FileSystem</em>",
                            "val": "The `FileSystem->` pointer holds misc functions related to files and directories.\n\nPaths are often relative to a 'quest specific directory', which is at \"[zc root]/files/[quest name]/\"\n\nRelated: ${fileptr|file}, ${directoryptr|directory}"
                        },
                        {
                            "name": "FileExists / DirExists",
                            "val": "<h3>bool FileExists(char32[] \"filepath\");\nbool DirExists(char32[] \"dirpath\");</h3>\nReturns true if the file/dir specified by the given path exists.\nIf [[\"All bitmap-> and FileSystem-> paths relative to quest 'Files' folder\"|at \"ZScript->Quest Script Settings->Instructions\"]] is enabled, paths are relative to the quest's specific directory; otherwise they are relative to the ZC folder."
                        },
                        {
                            "name": "Remove ;; FileSystem::Remove",
                            "val": "<h3>bool Remove(char32[] \"filepath\");</h3>\nDeletes the file pointed to by 'filepath'. Path is relative to the quest's specific directory."
                        },
                        {
                            "name": "LoadDirectory ;; FileSystem::LoadDirectory / LoadDirectory",
                            "val": "<h3>directory LoadDirectory(char32[] dirpath);</h3>\nOpens the directory pointed to by 'dirpath'"
                        }
                    ]
                }
            ]
        },
        {
            "name": "Text",
            "tabs": [
                {
                    "name": "Text ROOT",
                    "lines": [
                        {
                            "name": "&lt;-- Global Pointers ;; function_globalptr",
                            "val": "$Base Data$3"
                        },
                        {
                            "name": "<em>Text</em>",
                            "val": "The `Text->` pointer holds various functions relating to text/fonts."
                        },
                        {
                            "name": "Font Height ;; text_hei / text::fontheight / text::charheight / text::stringheight / text::messageheight ;; fontheight / charheight / stringheight / messageheight",
                            "val": "<h3>int FontHeight(int font);\nint CharHeight(char32 c, int font);\nint StringHeight(char32[] s, int font);</h3>\n\nReturns the height of 'font', in pixels.\n\n<h3>int MessageHeight(int msg);</h3>\n\nReturns the height of the font assigned to the 'msg' ${messagedata}."
                        },
                        {
                            "name": "Font Width ;; text_wid / Text::charwidth / Text::stringwidth / Text::messagewidth ;; charwidth / stringwidth / messagewidth",
                            "val": "<h3>int CharWidth(char32 c, int font);\nint StringWidth(char32[] s, int font);</h3>\n\nReturns the width of the character 'c' or string 's', in the given font, as '${DrawString}' would draw it.\n\n<h3>int MessageWidth(int msg);</h3>\n\nReturns the width of the ${messagedata} 'msg', as '${DrawString}' would draw it."
                        }
                    ]
                }
            ]
        },
        {
            "name": "Graphics",
            "tabs": [
                {
                    "name": "Graphics ROOT",
                    "lines": [
                        {
                            "name": "&lt;-- Global Pointers ;; function_globalptr",
                            "val": "$Base Data$3"
                        },
                        {
                            "name": "<em>Graphics</em>",
                            "val": "The `Graphics->` pointer holds various functions relating to visual effects."
                        },
                        {
                            "name": "Tinting ;; Graphics::Tint / Graphics::MonochromeHue / Graphics::ClearTint ;; Tint / MonochromeHue / ClearTint",
                            "val": "<h3>void Tint(int red, int green, int blue);\nvoid MonochromeHue(int red, int green, int blue, bool distributed = true);</h3>\n\nTints the palette by adding `red`, `green`, and `blue` to the respective values of every palette swatch. Subsequent calls to these functions will SUM the tint with all previous tints.\nIf `MonochromeHue` is used, the palette will be greyscaled (either via a `uniform` or `distributed` greyscale, based on the 'distributed' bool) before the tint is applied.\n\n<h3>void ClearTint();</h3>\n\nClears all tint effects."
                        },
                        {
                            "name": "Draw Count ;; Graphics::NumDraws / Graphics::MaxDraws",
                            "val": "<h3>int NumDraws();</h3>\n\nReturns the number of script drawing commands that are currently waiting in the draw queue.\n\n<h3>int MaxDraws();</h3>\r\n\r\nReturns the limit of the drawing queue. If ${Graphics::NumDraws|NumDraws()} returns the same as this, no further drawing commands will work until the queue has been cleared (i.e. the next frame)"
                        },
                        {
                            "name": "GetPixel ;; Graphics::GetPixel",
                            "val": "<h3>int GetPixel(bitmap b, int x, int y);</h3>\n\nSame as ${bitmap::GetPixel|'b->GetPixel(x,y)'}"
                        },
                        {
                            "name": "Wavy ;; Graphics::Wavy",
                            "val": "<h3>void Wavy(bool style_in);</h3>\n\nCreates a 'wave' effect, as a 'Wavy' warp type uses.\nThere are both 'in' and 'out' styles; if `style_in` is true, then the 'in' style is used; else the 'out' style is used."
                        },
                        {
                            "name": "Zap ;; Graphics::Zap",
                            "val": "<h3>void Zap(bool style_in);</h3>\n\nCreates a 'zap' effect, as a 'Zap' warp type uses.\nThere are both 'in' and 'out' styles; if `style_in` is true, then the 'in' style is used; else the 'out' style is used."
                        },
                        {
                            "name": "IsBlankTile ;; Graphics::IsBlankTile",
                            "val": "<h3>bool IsBlankTile[214500];</h3>\n\nRead-only. True if the given tile is entirely blank (all color 0)."
                        },
                        {
                            "name": "Is8BitTile ;; Graphics::Is8BitTile",
                            "val": "<h3>bool Is8BitTile[214500];</h3>\n\nRead-only. True if the given tile uses 8-bit color."
                        },
                        {
                            "name": "GetTilePixel ;; Graphics::GetTilePixel",
                            "val": "<h3>int GetTilePixel(int tile, int x, int y, int cset = 0);</h3>\n\nReturns the color index at an x,y coordinate of a tile.\nIf the tile isn't 8-bit, will return a color in the cset specified."
                        },
                        {
                            "name": "SetTilePixel ;; Graphics::SetTilePixel",
                            "val": "<h3>int SetTilePixel(int tile, int x, int y, int color);</h3>\n\nSets the color index an an x,y coordinate of a tile.\nIf writing an 8-bit color to a 4-bit tile, the cset bits will be discarded.\nThis is not considered a draw command and is not affected by deferred draw timing. It will run instantly, before any draws for the frame."
                        },
                        {
                            "name": "Greyscale ;; Graphics::Greyscale / Graphics::Grayscale",
                            "val": "<h3>void Greyscale(bool enable);</h3>\n\nEnables or disables 'greyscale' mode. ${Graphics::MonochromeHue|MonochromeHue()} works similarly, but with more options."
                        },
                        {
                            "name": "Monochrome ;; Graphics::Monochrome",
                            "val": "<h3>void Monochrome(int preset);</h3>\n\nActivates a monochrome preset.\n<ol start=\"0\">\n<li>TINT_NONE</li>\n<li>TINT_GREY</li>\n<li>TINT_RED</li>\n<li>TINT_GREEN</li>\n<li>TINT_BLUE</li>\n<li>TINT_VIOLET</li>\n<li>TINT_TEAL</li>\n<li>TINT_AMBER</li>\n<li>TINT_CYAN</li>\n</ol>\n\nTo use a distributed monochrome mode, add `TINT_MODE_DISTRIBUTED` to the preset."
                        },
                        {
                            "name": "CreatePalData ;; Graphics::CreatePalData",
                            "val": "<h3>paldata CreatePalData();\npaldata CreatePalData(rgb color);</h3>\n\nCreates a new paldata. If 'color' is specified, fills the palette with that rgb color.\n\nSee: ${paldata::paldata|paldata}"
                        },
                        {
                            "name": "MixColor ;; Graphics::MixColor",
                            "val": "<h3>rgb MixColor(rgb start, rgb end, float percent, int color_space = CSPACE_RGB);</h3>\nInterpolates a color between start and end and then returns the resulting rgb.\nThe value of percent should range from 0.0000-1.0000, with 0 representing the starting color.\n\nColor space specifies a color space to interpolate through, changing the resulting average. Use the following `CSPACE_` constants:\n<ol start=\"0\">\n<li>CSPACE_RGB</li>\n<li>CSPACE_CMYK</li>\n<li>CSPACE_HSV</li>\n<li>CSPACE_HSV_CW</li>\n<li>CSPACE_HSV_CCW</li>\n<li>CSPACE_HSL</li>\n<li>CSPACE_HSL_CW</li>\n<li>CSPACE_HSL_CCW</li>\n<li>CSPACE_LAB</li>\n<li>CSPACE_LCH</li>\n<li>CSPACE_LCH_CW</li>\n<li>CSPACE_LCH_CCW</li>\n</ol>\n\nSee also: ${paldata::Mix|Color Mixing}"
                        },
                        {
                            "name": "CreateRGB ;; Graphics::CreateRGB / rgb",
                            "val": "<h3>rgb CreateRGB(int r, int g, int b);\nrgb CreateRGB(long hexcode);</h3>\nTakes either an (r,g,b) ranging 0 &lt;= n &lt;= 63, or takes a long hexcode (0xRRGGBBL), with each rgb section 0 &lt;= n &lt;= 255.\nConverts whichever is passed into an 'rgb' value, representing a color with 0-63 rgb values, which is used by paldata functions.\n\nSee: ${paldata::rgb|rgb}"
                        }
                    ]
                }
            ]
        },
        {
            "name": "Input",
            "tabs": [
                {
                    "name": "Input ROOT",
                    "lines": [
                        {
                            "name": "&lt;-- Global Pointers ;; function_globalptr",
                            "val": "$Base Data$3"
                        },
                        {
                            "name": "<em>Input</em>",
                            "val": "The `Input->` pointer holds various values relating to button, mouse, and keyboard input."
                        },
                        {
                            "name": "KeyBindings ;; Input::keybindings",
                            "val": "<h3>int KeyBindings[14];</h3>\n\nFor each index (using `CB_` constants to access), the keyboard key (`KEY_` constants) that is bound to that button."
                        },
                        {
                            "name": "Button Input ;; Input::press / Input::button",
                            "val": "<h3>bool Button[CB_MAX];\nbool Press[CB_MAX];</h3>\n\nWhether the given button (`CB_` constants) is down (or 'pressed').\n\n'Press' indicates this was the first frame the button is down, while 'Button' indicates only that the button <em>is</em> down, with no regard for how long it has been down.\n\nThese are the same as the old `Hero->InputBUTTON` and `Hero->PressBUTTON` values, but as arrays."
                        },
                        {
                            "name": "Keyboard Input ;; Input::key / Input::keypress / Input::modifierkeys",
                            "val": "<h3>bool Key[KEY_MAX];</h3>\nReturns true if the respective key is down this frame (similar to ${Input::button|Button[]}, but for keys instead of buttons).\n\n<h3>bool KeyPress[KEY_MAX];</h3>\nReturns true if the respective key was just pressed this frame (similar to ${Input::press|Press[]}, but for keys instead of buttons).\n\n<h3>int ModifierKeys;</h3>\nReturns the modifier keys as a bitwise flagset.\n#{Flag Constants|<ul><li>KB_SHIFT_FLAG: 0x0001</li>\n<li>KB_CTRL_FLAG: 0x0002</li>\n<li>KB_ALT_FLAG: 0x0004</li>\n<li>KB_LWIN_FLAG: 0x0008</li>\n<li>KB_RWIN_FLAG: 0x0010</li>\n<li>KB_MENU_FLAG: 0x0020</li>\n<li>KB_COMMAND_FLAG: 0x0040</li>\n<li>0x0080 unused flag</li></ul><ul>\n<li>KB_SCROLOCK_FLAG: 0x0100</li>\n<li>KB_NUMLOCK_FLAG: 0x0200</li>\n<li>KB_CAPSLOCK_FLAG: 0x0400</li>\n<li>KB_INALTSEQ_FLAG: 0x0800</li>\n<li>KB_ACCENT1_FLAG: 0x1000</li>\n<li>KB_ACCENT2_FLAG: 0x2000</li>\n<li>KB_ACCENT3_FLAG: 0x4000</li>\n<li>KB_ACCENT4_FLAG: 0x8000</li></ul>\n}"
                        },
                        {
                            "name": "Mouse Input ;; Input::mouse",
                            "val": "<h3>int Mouse[6];</h3>\n\n<ol start=\"0\">\n<li>MOUSE_X: the X position of the mouse</li>\n<li>MOUSE_Y: the Y position of the mouse</li>\n<li>MOUSE_Z: the Z position of the mouse (scrollwheel)</li>\n<li>MOUSE_LEFT: bool, true if the left mouse button is down.</li>\n<li>MOUSE_RIGHT: bool, true if the right mouse button is down.</li>\n<li>MOUSE_MIDDLE: bool, true if the middle mouse button is down.</li>\n</ol>"
                        },
                        {
                            "name": "Disabling ;; Input::disablebutton / Input::disablekey",
                            "val": "<h3>bool DisableButton[CB_MAX];</h3>\n\nWhether a given button (`CB_` constants) is disabled from having any in-engine effect.\n\n<h3>bool DisableKey[KEY_MAX];</h3>\n\nWhether a given keyboard key (`KEY_` constants) is disabled from having any in-engine effect.\nCertain keys, such as F9 for `reset system`, will work regardless of this setting."
                        }
                    ]
                }
            ]
        }
    ],
    "named": {
        "name": "Named_Data",
        "tabs": [
            {
                "name": "TTIPS",
                "lines": [
                    {
                        "name": "Shadow Type",
                        "val": "<ol start=\"0\"><li>No Shadow</li>\n<li>Basic shadow, no text</li>\n<li>'U' shadow, no text</li>\n<li>Full outline shadow, no text</li>\n<li>'+' outline shadow, no text</li>\n<li>'X' outline shadow, no text</li>\n<li>Basic shadow, behind text</li>\n<li>'U' shadow, behind text</li>\n<li>Full outline shadow, behind text</li>\n<li>'+' outline shadow, behind text</li>\n<li>'X' outline shadow, behind text</li></ol>"
                    },
                    {
                        "name": "Counter",
                        "val": "<iblock><ol start=\"-1\">\n<li>CR_NONE</li>\n<li>CR_LIFE</li>\n<li>CR_RUPEES</li>\n<li>CR_BOMBS</li>\n<li>CR_ARROWS</li>\n<li>CR_MAGIC</li>\n<li>CR_KEYS</li>\n<li>CR_SBOMBS</li>\n<li>CR_CUSTOM1</li>\n<li>CR_CUSTOM2</li>\n<li>CR_CUSTOM3</li>\n<li>CR_CUSTOM4</li>\n<li>CR_CUSTOM5</li>\n<li>CR_CUSTOM6</li>\n<li>CR_CUSTOM7</li>\n<li>CR_CUSTOM8</li>\n<li>CR_CUSTOM9</li>\n<li>CR_CUSTOM10</li>\n<li>CR_CUSTOM11</li>\n<li>CR_CUSTOM12</li>\n<li>CR_CUSTOM13</li>\n<li>CR_CUSTOM14</li>\n<li>CR_CUSTOM15</li>\n<li>CR_CUSTOM16</li>\n<li>CR_CUSTOM17</li>\n<li>CR_CUSTOM18</li></ol></iblock>  <iblock><ol start=\"25\">\n<li>CR_CUSTOM19</li>\n<li>CR_CUSTOM20</li>\n<li>CR_CUSTOM21</li>\n<li>CR_CUSTOM22</li>\n<li>CR_CUSTOM23</li>\n<li>CR_CUSTOM24</li>\n<li>CR_CUSTOM25</li>\n<li>CR_CUSTOM26</li>\n<li>CR_CUSTOM27</li>\n<li>CR_CUSTOM28</li>\n<li>CR_CUSTOM29</li>\n<li>CR_CUSTOM30</li>\n<li>CR_CUSTOM31</li>\n<li>CR_CUSTOM32</li>\n<li>CR_CUSTOM33</li>\n<li>CR_CUSTOM34</li>\n<li>CR_CUSTOM35</li>\n<li>CR_CUSTOM36</li>\n<li>CR_CUSTOM37</li>\n<li>CR_CUSTOM38</li>\n<li>CR_CUSTOM39</li>\n<li>CR_CUSTOM40</li>\n<li>CR_CUSTOM41</li>\n<li>CR_CUSTOM42</li>\n<li>CR_CUSTOM43</li></ol></iblock>  <iblock><ol start=\"50\">\n<li>CR_CUSTOM44</li>\n<li>CR_CUSTOM45</li>\n<li>CR_CUSTOM46</li>\n<li>CR_CUSTOM47</li>\n<li>CR_CUSTOM48</li>\n<li>CR_CUSTOM49</li>\n<li>CR_CUSTOM50</li>\n<li>CR_CUSTOM51</li>\n<li>CR_CUSTOM52</li>\n<li>CR_CUSTOM53</li>\n<li>CR_CUSTOM54</li>\n<li>CR_CUSTOM55</li>\n<li>CR_CUSTOM56</li>\n<li>CR_CUSTOM57</li>\n<li>CR_CUSTOM58</li>\n<li>CR_CUSTOM59</li>\n<li>CR_CUSTOM60</li>\n<li>CR_CUSTOM61</li>\n<li>CR_CUSTOM62</li>\n<li>CR_CUSTOM63</li>\n<li>CR_CUSTOM64</li>\n<li>CR_CUSTOM65</li>\n<li>CR_CUSTOM66</li>\n<li>CR_CUSTOM67</li>\n<li>CR_CUSTOM68</li></ol></iblock>  <iblock><ol start=\"75\">\n<li>CR_CUSTOM69</li>\n<li>CR_CUSTOM70</li>\n<li>CR_CUSTOM71</li>\n<li>CR_CUSTOM72</li>\n<li>CR_CUSTOM73</li>\n<li>CR_CUSTOM74</li>\n<li>CR_CUSTOM75</li>\n<li>CR_CUSTOM76</li>\n<li>CR_CUSTOM77</li>\n<li>CR_CUSTOM78</li>\n<li>CR_CUSTOM79</li>\n<li>CR_CUSTOM80</li>\n<li>CR_CUSTOM81</li>\n<li>CR_CUSTOM82</li>\n<li>CR_CUSTOM83</li>\n<li>CR_CUSTOM84</li>\n<li>CR_CUSTOM85</li>\n<li>CR_CUSTOM86</li>\n<li>CR_CUSTOM87</li>\n<li>CR_CUSTOM88</li>\n<li>CR_CUSTOM89</li>\n<li>CR_CUSTOM90</li>\n<li>CR_CUSTOM91</li>\n<li>CR_CUSTOM92</li>\n<li>CR_CUSTOM93</li></ol></iblock>  <iblock><ol start=\"100\">\n<li>CR_CUSTOM94</li>\n<li>CR_CUSTOM95</li>\n<li>CR_CUSTOM96</li>\n<li>CR_CUSTOM97</li>\n<li>CR_CUSTOM98</li>\n<li>CR_CUSTOM99</li>\n<li>CR_CUSTOM100</li></ol></iblock>"
                    },
                    {
                        "name": "OBJTYPE_",
                        "val": "<ol start=\"0\"><li>OBJTYPE_NPC</li>\n<li>OBJTYPE_LWPN</li>\n<li>OBJTYPE_EWPN</li>\n<li>OBJTYPE_ITSPR</li>\n<li>OBJTYPE_COMBODATA</li></ol>"
                    },
                    {
                        "name": "Unblockable",
                        "val": "<ul>\r\n<li>UNBLOCK_NONE = 0000b</li>\r\n<li>UNBLOCK_NORM = 0001b - Bypasses normal 'block' defenses</li>\r\n<li>UNBLOCK_IGNR = 0010b - Bypasses 'ignore' defenses</li>\r\n<li>UNBLOCK_SHLD = 0100b - Bypasses enemy/hero 'shields'</li>\r\n<li>UNBLOCK_REFL = 1000b - Bypasses hero 'reflect' on shields</li>\r\n<li>UNBLOCK_ALL = 1111b</li>\n</ul>"
                    },
                    {
                        "name": "Trigger Requirement",
                        "val": "This condition does not trigger the combo itself- instead, when something tries to trigger this combo, it must ALSO pass this condition.\nTo make this act as a trigger in itself, combine with the 'Always Triggered' (`TRIGFLAG_AUTO`) flag."
                    },
                    {
                        "name": "CHRT_",
                        "val": "<mono>CHRT_VISITED = 10000000b\nCHRT_UP      = 00000001b\nCHRT_DOWN    = 00000010b\nCHRT_LEFT    = 00000100b\nCHRT_RIGHT   = 00001000b</mono>"
                    },
                    {
                        "name": "DMAP_",
                        "val": "<ol start=\"0\"><li>DMAP_DUNGEON</li>\n<li>DMAP_OVERWORLD</li>\n<li>DMAP_CAVE</li>\n<li>DMAP_BSOVERWORLD</li></ol>\n"
                    },
                    {
                        "name": "FLIP_",
                        "val": "<mono>FLIP_NONE        = 0\nFLIP_HORIZONTAL  = 1\nFLIP_VERTICAL    = 2\nFLIP_HV          = 3\nFLIP_VH          = 3\nFLIP_BOTH        = 3\n//rotation and flip\nROT_CW           = 4\nROT_CW_FLIP      = 5\nROT_CCW_FLIP     = 6\nROT_CCW          = 7</mono>\n"
                    },
                    {
                        "name": "ZCM_",
                        "val": "Values for `Game->MouseCursor`\n<ol start=\"0\"><li>ZCM_CUSTOM: Use a custom cursor</li>\n<li>ZCM_BLANK: Don't display a cursor</li>\n<li>ZCM_NORMAL: Display the engine cursor</li></ol>"
                    }
                ]
            },
            {
                "name": "MISC",
                "lines": [
                    {
                        "name": "WARPEFFECT_",
                        "val": "Values representing various warp transition effects.\n<ol start='0'><li>WARPEFFECT_NONE</li>\n<li>WARPEFFECT_ZAP</li>\n<li>WARPEFFECT_WAVE</li>\n<li>WARPEFFECT_INSTANT</li>\n<li>WARPEFFECT_OPENWIPE</li></ol>"
                    },
                    {
                        "name": "AF_",
                        "val": "Bitwise values used to access `combodata-&gt;AnimFlags`\n<ul><li>AF_FRESH: Refresh Animation on Room Entry</li>\n<li>AF_CYCLE: Refresh Animation When Cycled To</li>\n<li>AF_CYCLENOCSET: Cycle ignores CSet</li>\n<li>AF_TRANSPARENT: Toggle Transparent</li></ul>"
                    },
                    {
                        "name": "GENFLAG_",
                        "val": "Indexes for `combodata-&gt;GenFlags[]`\n<ol start='0'><li>GENFLAG_HOOKSHOTTABLE: Hook-Grabbable</li>\n<li>GENFLAG_SWITCHHOOKABLE: Switch-Hookable</li></ol>"
                    },
                    {
                        "name": "TRIGFLAG_",
                        "val": "Indexes for `combodata-&gt;TrigFlags[]`\n<ol start='0'><li>[[TRIGFLAG_SWORD|Triggered by Sword LWeapons]]</li>\n<li>[[TRIGFLAG_SWORDBEAM|Triggered by Sword Beam LWeapons]]</li>\n<li>[[TRIGFLAG_BRANG|Triggered by Boomerang LWeapons]]</li>\n<li>[[TRIGFLAG_BOMB|Triggered by Bomb (explosion) LWeapons]]</li>\n<li>[[TRIGFLAG_SBOMB|Triggered by Super Bomb (explosion) LWeapons]]</li>\n<li>[[TRIGFLAG_LITBOMB|Triggered by Bomb (placed) LWeapons]]</li>\n<li>[[TRIGFLAG_LITSBOMB|Triggered by Super Bomb (placed) LWeapons]]</li>\n<li>[[TRIGFLAG_ARROW|Triggered by Arrow LWeapons]]</li>\n<li>[[TRIGFLAG_FIRE|Triggered by Fire LWeapons]]</li>\n<li>[[TRIGFLAG_WHISTLE|Triggered by Whistle LWeapons (whistle played)]]</li>\n<li>[[TRIGFLAG_BAIT|Triggered by Bait LWeapons]]</li>\n<li>[[TRIGFLAG_WAND|Triggered by Wand Handle LWeapon]]</li>\n<li>[[TRIGFLAG_MAGIC|Triggered by Magic LWeapons]]</li>\n<li>[[TRIGFLAG_WIND|Triggered by Wind LWeapons]]</li>\n<li>[[TRIGFLAG_REFMAGIC|Triggered by Reflected Magic LWeapons]]</li>\n<li>[[TRIGFLAG_REFFIREBALL|Triggered by Reflected Fireball LWeapons]]</li>\n<li>[[TRIGFLAG_REFROCK|Triggered by Reflected Rock LWeapons]]</li>\n<li>[[TRIGFLAG_HAMMER|Triggered by Hammer LWeapon]]</li>\n<li>[[TRIGFLAG_RESET_ANIM|On trigger, reset the animation of the combo.]]</li>\n<li>[[TRIGFLAG_INVERT_PROXIMITY|Proximity requirement is reversed]]</li>\n<li>[[TRIGFLAG_BTN_TOP|Triggered by button press from above]]</li>\n<li>[[TRIGFLAG_BTN_BOTTOM|Trigger by button press from below]]</li>\n<li>[[TRIGFLAG_BTN_LEFT|Trigger by button press from left]]</li>\n<li>[[TRIGFLAG_BTN_RIGHT|Trigger by button press from right]]</li>\n<li>[[TRIGFLAG_INVERT_MIN_MAX|Treat the 'TriggerLevel' as a max instead of a min]]</li>\n<li>[[TRIGFLAG_STEP|Triggered by 'Step-&gt;']]</li>\n<li>[[TRIGFLAG_STEP_SENS|Triggered by 'Step-&gt;Sensitive']]</li>\n<li>[[TRIGFLAG_SHUTTER|Triggered by 'Shutter-&gt;']]</li>\n<li>[[TRIGFLAG_CTYPE_EFFECTS|On trigger, cause the combo's type-related effects to occur. (ex: opening a chest)]]</li>\n<li>[[TRIGFLAG_ONLY_GENTRIG|Don't allow the combo to trigger via it's normal trigger methods (ex: bush via slashing)]]</li>\n<li>[[TRIGFLAG_KILL_WEAPON|If triggered by a weapon, kill the weapon.]]</li>\n<li>[[TRIGFLAG_EW_FIREBALL|Triggered by Fireball EWeapons]]</li>\n<li>[[TRIGFLAG_HOOKSHOT|Triggered by Hookshot LWeapons]]</li>\n<li>[[TRIGFLAG_SPARKLE|Triggered by Sparkle LWeapons]]</li>\n<li>[[TRIGFLAG_BYRNA|Triggered by Byrna LWeapons]]</li>\n<li>[[TRIGFLAG_REFBEAM|Triggered by Reflected Beam LWeapons]]</li>\n<li>[[TRIGFLAG_STOMP|Triggered by Stomp Boot LWeapons]]</li>\n<li>[[TRIGFLAG_SCRIPT1|Triggered by 'Custom Weapon 01' LWeapons]]</li>\n<li>[[TRIGFLAG_SCRIPT2|Triggered by 'Custom Weapon 02' LWeapons]]</li>\n<li>[[TRIGFLAG_SCRIPT3|Triggered by 'Custom Weapon 03' LWeapons]]</li>\n<li>[[TRIGFLAG_SCRIPT4|Triggered by 'Custom Weapon 04' LWeapons]]</li>\n<li>[[TRIGFLAG_SCRIPT5|Triggered by 'Custom Weapon 05' LWeapons]]</li>\n<li>[[TRIGFLAG_SCRIPT6|Triggered by 'Custom Weapon 06' LWeapons]]</li>\n<li>[[TRIGFLAG_SCRIPT7|Triggered by 'Custom Weapon 07' LWeapons]]</li>\n<li>[[TRIGFLAG_SCRIPT8|Triggered by 'Custom Weapon 08' LWeapons]]</li>\n<li>[[TRIGFLAG_SCRIPT9|Triggered by 'Custom Weapon 09' LWeapons]]</li>\n<li>[[TRIGFLAG_SCRIPT10|Triggered by 'Custom Weapon 10' LWeapons]]</li>\n<li>[[TRIGFLAG_AUTO|Triggered automatically, every frame.]]</li>\n<li>[[TRIGFLAG_TRIG_SECRETS|Triggered by 'Secrets-&gt;']]</li>\n<li>[[TRIGFLAG_INVERT_ITEMREQ|Invert the item requirement (require NOT having the item)]]</li>\n<li>[[TRIGFLAG_CONSUME_ITEMREQ|On trigger, consume the required item.]]</li>\n<li>[[TRIGFLAG_COUNTER_GE|Only trigger if the counter has &gt;= the specified amount]]</li>\n<li>[[TRIGFLAG_COUNTER_LT|Only trigger if the counter has &lt; the specified amount]]</li>\n<li>[[TRIGFLAG_COUNTER_EAT|Consume the specified amount from the counter. Negative amounts add.]]</li>\n<li>[[TRIGFLAG_COUNTER_NOT_ONLY_TRIG_EAT|Consume the specified amount from the counter even if the combo failed to trigger.]]</li>\n<li>[[TRIGFLAG_LIGHTON|Triggered by a lightbeam.]]</li>\n<li>[[TRIGFLAG_LIGHTOFF|Triggered by lack of a lightbeam.]]</li>\n<li>[[TRIGFLAG_PUSH|Triggered when the player pushes into the combo.]]</li>\n<li>[[TRIGFLAG_LENS_ON|Triggered when the lens is revealing.]]</li>\n<li>[[TRIGFLAG_LENS_OFF|Triggered when the lens is not revealing.]]</li>\n<li>[[TRIGFLAG_EW_ARROW|Triggered by Arrow EWeapons]]</li>\n<li>[[TRIGFLAG_EW_BRANG|Triggered by Boomerang EWeapons]]</li>\n<li>[[TRIGFLAG_EW_SWORD|Triggered by Sword EWeapons]]</li>\n<li>[[TRIGFLAG_EW_ROCK|Triggered by Rock EWeapons]]</li>\n<li>[[TRIGFLAG_EW_SCRIPT1|Triggered by 'Custom Weapon 01' EWeapons]]</li>\n<li>[[TRIGFLAG_EW_SCRIPT2|Triggered by 'Custom Weapon 02' EWeapons]]</li>\n<li>[[TRIGFLAG_EW_SCRIPT3|Triggered by 'Custom Weapon 03' EWeapons]]</li>\n<li>[[TRIGFLAG_EW_SCRIPT4|Triggered by 'Custom Weapon 04' EWeapons]]</li>\n<li>[[TRIGFLAG_EW_SCRIPT5|Triggered by 'Custom Weapon 05' EWeapons]]</li>\n<li>[[TRIGFLAG_EW_SCRIPT6|Triggered by 'Custom Weapon 06' EWeapons]]</li>\n<li>[[TRIGFLAG_EW_SCRIPT7|Triggered by 'Custom Weapon 07' EWeapons]]</li>\n<li>[[TRIGFLAG_EW_SCRIPT8|Triggered by 'Custom Weapon 08' EWeapons]]</li>\n<li>[[TRIGFLAG_EW_SCRIPT9|Triggered by 'Custom Weapon 09' EWeapons]]</li>\n<li>[[TRIGFLAG_EW_SCRIPT10|Triggered by 'Custom Weapon 10' EWeapons]]</li>\n<li>[[TRIGFLAG_EW_MAGIC|Triggered by Magic EWeapons]]</li>\n<li>[[TRIGFLAG_EW_BBLAST|Triggered by Bomb (explosion) EWeapons]]</li>\n<li>[[TRIGFLAG_EW_SBBLAST|Triggered by Super Bomb (explosion) EWeapons]]</li>\n<li>[[TRIGFLAG_EW_LITBOMB|Triggered by Bomb (unexploded) EWeapons]]</li>\n<li>[[TRIGFLAG_EW_LITSBOMB|Triggered by Super Bomb (unexploded) EWeapons]]</li>\n<li>[[TRIGFLAG_EW_FIRETRAIL|Triggered by Fire Trail EWeapons]]</li>\n<li>[[TRIGFLAG_EW_FLAME|Triggered by Flame EWeapons]]</li>\n<li>[[TRIGFLAG_EW_WIND|Triggered by Wind EWeapons]]</li>\n<li>[[TRIGFLAG_EW_FLAME2|Triggered by Flame 2 EWeapons]]</li>\n<li>[[TRIGFLAG_EXST_ITEM|Trigger ExState after picking up the spawned item]]</li>\n<li>[[TRIGFLAG_EXST_ENEMY|Trigger ExState after killing the spawned enemy]]</li>\n<li>[[TRIGFLAG_AUTOGRAB_ITEM|Spawned item auto-collects]]</li>\n<li>[[TRIGFLAG_KILL_ENEMIES|Triggered when all enemies are killed]]</li>\n<li>[[TRIGFLAG_SECRETSTR|Triggered when screen secrets are triggered]]</li>\n<li>[[TRIGFLAG_THROWN|Triggered by Thrown Object weapons]]</li>\n<li>[[TRIGFLAG_QUAKESTUN|Triggered by a Quake Stun]]</li>\n<li>[[TRIGFLAG_SQUAKESTUN|Triggered by a Super Quake Stun]]</li>\n<li>[[TRIGFLAG_ANYFIRE|Triggered by Any Fire]]</li>\n<li>[[TRIGFLAG_STRONGFIRE|Triggered by Strong Fire]]</li>\n<li>[[TRIGFLAG_MAGICFIRE|Triggered by Magic Fire]]</li>\n<li>[[TRIGFLAG_DIVINEFIRE|Triggered by Divine Fire]]</li>\n<li>[[TRIGFLAG_TRIGLEVELSTATE|Triggered by Level State]]</li>\n<li>[[TRIGFLAG_LEVELSTATE|Triggers Level State]]</li>\n<li>[[TRIGFLAG_TRIGGLOBALSTATE|Triggered by Global State]]</li>\n<li>[[TRIGFLAG_GLOBALSTATE|Triggers Global State]]</li>\n<li>[[TRIGFLAG_DO_KILL_ENEMIES|Kill all enemies]]</li>\n<li>[[TRIGFLAG_DO_CLEAR_ENEMIES|Delete all enemies]]</li>\n<li>[[TRIGFLAG_DO_CLEAR_LWEAPONS|Delete all lweapons]]</li>\n<li>[[TRIGFLAG_DO_CLEAR_EWEAPONS|Delete all eweapons]]</li>\n<li>[[TRIGFLAG_IGNITE_WEAPONS_ANY|Light the triggering weapon on normal fire.]]</li>\n<li>[[TRIGFLAG_IGNITE_WEAPONS_STRONG|Light the triggering weapon on strong fire.]]</li>\n<li>[[TRIGFLAG_IGNITE_WEAPONS_MAGIC|Light the triggering weapon on magic fire.]]</li>\n<li>[[TRIGFLAG_IGNITE_WEAPONS_DIVINE|Light the triggering weapon on divine fire.]]</li>\n<li>[[TRIGFLAG_SEPARATE_WEAPON_TRIGGERS|Triggering weapons only trigger weapon-related effects]]</li>\n<li>[[TRIGFLAG_TGROUP_CONTRIB|This combo contributes to its' TrigGroup]]</li>\n<li>[[TRIGFLAG_TGROUP_LESS|When the number of combos that contribute to this combo's Trigger Group is LESS than the Trigger Group Val, trigger this combo.]]</li>\n<li>[[TRIGFLAG_TGROUP_GREATER|When the number of combos that contribute to this combo's Trigger Group is GREATER than the Trigger Group Val, trigger this combo.]]</li></ol>"
                    },
                    {
                        "name": "INTBTN_",
                        "val": "<ol start='0'><li>INTBTN_A</li>\n<li>INTBTN_B</li>\n<li>INTBTN_L</li>\n<li>INTBTN_R</li>\n<li>INTBTN_EX1</li>\n<li>INTBTN_EX2</li>\n<li>INTBTN_EX3</li>\n<li>INTBTN_EX4</li></ol>"
                    },
                    {
                        "name": "LIFTGFX_",
                        "val": "Values for `combodata-&gt;LiftGFXType`\n<ol start='0'><li>[[LIFTGFX_THISCOMBO|Uses the combo's graphics directly.]]</li>\n<li>[[LIFTGFX_OTHERCOMBO|Uses the graphics of another combo/cset, specified as `LiftGFXCombo`/`LiftGFXCSet`]]</li>\n<li>[[LIFTGFX_SPRITEDATA|Uses a Sprite Data sprite as the graphics, specified as `LiftGFXSprite`.]]</li></ol>"
                    },
                    {
                        "name": "LF_",
                        "val": "Indexes for `combodata-&gt;LiftFlags[]`\n<ol start='0'><li>[[LF_LIFTABLE|Combo can be lifted]]</li>\n<li>[[LF_DROPSET|The `LiftItem` is a dropset instead of an item ID]]</li>\n<li>[[LF_DROPONLIFT|The `LiftItem` is dropped on lift, instead of break.]]</li>\n<li>[[LF_SPECIALITEM|The `LiftItem` is the room's special item.]]</li>\n<li>[[LF_NOUCSET|Leaves the combo's CSet behind, instead of the UnderCSet.]]</li>\n<li>[[LF_NOWPNCMBCSET|Uses the combo's CSet, instead of the `LiftGFXCSet`]]</li>\n<li>[[LF_BREAKONSOLID|The weapon breaks upon colliding with a solid object, instead of going through solids.]]</li></ol>"
                    },
                    {
                        "name": "DMFS_",
                        "val": "Indexes for `dmapdata-&gt;Flagset[]`\n<ol start='0'><li>[[DMFS_CAVESNOTCELLARS|Use Caves Instead Of Item Cellars]]</li>\n<li>[[DMFS_3STAIRWARPS|Allow 3-Stair Warp Rooms]]</li>\n<li>[[DMFS_WWIND|Allow Whistle Whirlwinds]]</li>\n<li>[[DMFS_GUYCAVES|Special Rooms and Guys Are In Caves Only]]</li>\n<li>[[DMFS_NOCOMPASS|Don't Display Compass Marker On Minimap]]</li>\n<li>[[DMFS_WAVY|Underwater Wave Effect]]</li>\n<li>[[DMFS_WWINDRET|Whistle Whirlwind Returns Player To Start]]</li>\n<li>[[DMFS_ALWAYSINTROMSG|Always Display Intro String]]</li>\n<li>[[DMFS_VIEWMAP|View Overworld Map By Pressing 'Map']]</li>\n<li>[[DMFS_DMAPMAP|...But Only Show Screens Marked In Minimap]]</li>\n<li>[[DMFS_MINIMAPCOLORFIX|Use Minimap Foreground Color 2]]</li>\n<li>[[DMFS_SCRIPT1|Script 1]]</li>\n<li>[[DMFS_SCRIPT2|Script 2]]</li>\n<li>[[DMFS_SCRIPT3|Script 3]]</li>\n<li>[[DMFS_SCRIPT4|Script 4]]</li>\n<li>[[DMFS_SCRIPT5|Script 5]]</li>\n<li>[[DMFS_SIDEVIEW|Sideview (same as `bool Sideview;`)]]</li>\n<li>[[DMFS_LAYER3ISBACKGROUND|Layer 3 is Background on All Screens]]</li>\n<li>[[DMFS_LAYER2ISBACKGROUND|Layer 2 is Background on All Screens]]</li>\n<li>[[DMFS_TRUECELLARENEMIES|Use Enemy List for Cellar Enemies]]</li>\n<li>[[DMFS_BUNNY|Become Bunny with no Pearl]]</li>\n<li>[[DMFS_MIRRORCONTINUE|Mirror Continues instead of Warping]]</li></ol>"
                    },
                    {
                        "name": "ISCR_",
                        "val": "Modes for `itemdata-&gt;RunScript()`\n<ol start='0'><li>[[ISCR_KILL|Ends the item script if it was running]]</li>\n<li>[[ISCR_RUN|Runs the item script normally]]</li>\n<li>[[ISCR_PERPETUAL|Runs the item script allowing it to run for multiple frames even if the QR 'Item Scripts Continue To Run' is off.\nYou probably don't ever need this? Most quests should just have that QR on...]]</li></ol>"
                    },
                    {
                        "name": "IP_",
                        "val": "Flags for `itemdata-&gt;Pickup` and `itemsprite-&gt;Pickup`\n<mono>[[IP_BIGRANGE       = 0x0001|INTERNAL Collision rectangle is large]]\n[[IP_HOLDUP         = 0x0002|Link holds it up when collecting it.]]\n[[IP_ST_ITEM        = 0x0004|Sets the screen state \"Item\" when collected.]]\n[[IP_DUMMY          = 0x0008|A 'dummy' item, such as rupee markers in shops. Can't be collected and ignores gravity.]]\n[[IP_CHECK          = 0x0010|INTERNAL Check restrictions (money in a shop, etc.)]]\n[[IP_MONEY          = 0x0020|INTERNAL This item causes money loss (bomb upgrade, swindle room, etc.)]]\n[[IP_FADE           = 0x0040|INTERNAL Blinks if fadeclk>0]]\n[[IP_ENEMYCARRIED   = 0x0080|The item-carrying NPC carries it. If no NPC has an item, the most recently created NPC carries it.]]\n[[IP_TIMEOUT        = 0x0100|Disappears after 512 frames. Can be collected by melee weapons if the related quest rule is not set.]]\n[[IP_BIGTRIFORCE    = 0x0200|INTERNAL Large collision rectangle (used for large triforce)]]\n[[IP_NODRAW         = 0x0400|INTERNAL Don't draw this (for underwater items)]]\n[[IP_ST_SPECIALITEM = 0x0800|Sets the screen state \"Special Item\" when collected.]]\n[[IP_TRIGGERSECRETS = 0x1000| Triggers screen secrets when collected]]\n[[IP_ALWAYSGRAB     = 0x2000| Item is always able to be picked up (ex. brang/hshot/arrows/melee weapons)]]</mono>"
                    },
                    {
                        "name": "IPTYPE_",
                        "val": "Flags for `itemdata-&gt;PickupType`\n<ol start=\"0\"><li>[[IPTYPE_DISABLED|Item pickup flags are not applied]]</li>\n<li>[[IPTYPE_SET|Overrides all pickup flags to these exact settings. WARNING: Do not select this unless you know what you are doing.]]</li>\n<li>[[IPTYPE_ADD|Add the selected pickup flags.]]</li>\n<li>[[IPTYPE_SUB|Remove the selected pickup flags.]]</li>\n<li>[[IPTYPE_LIMIT|Remove any non-selected pickup flags. WARNING: Do not select this unless you know what you are doing.]]</li></ol>"
                    },
                    {
                        "name": "IMISC_",
                        "val": "Flags for `itemdata-&gt;MiscFlags`\n<mono>[[IMISC_FLASH   = 0x01|The item flashes]]\n[[IMISC_TWOHAND = 0x02|When held up, the item is held with 2 hands]]\n[[IMISC_HFLIP   = 0x04|Flips the tile horizontally]]\n[[IMISC_VFLIP   = 0x08|Flips the tile vertically]]\n</mono>"
                    },
                    {
                        "name": "SZFLAG_",
                        "val": "Flags for `itemdata-&gt;SizeFlags` and `itemdata-&gt;WeaponSizeFlags`\n<mono>SZFLAG_TILEHEIGHT     = 0x0002\nSZFLAG_HIT_WIDTH      = 0x0004\nSZFLAG_HIT_HEIGHT     = 0x0008\nSZFLAG_HIT_Z_HEIGHT   = 0x0010\nSZFLAG_HIT_X_OFFSET   = 0x0020\nSZFLAG_HIT_Y_OFFSET   = 0x0040\nSZFLAG_DRAW_X_OFFSET  = 0x0080\nSZFLAG_DRAW_Y_OFFSET  = 0x0100\nSZFLAG_DRAW_Z_OFFSET  = 0x0200\nSZFLAG_ALL            = 0x03FF</mono>"
                    },
                    {
                        "name": "SPRFL_",
                        "val": "Indexes for `spritedata-&gt;Flags[]`\n<ol start=\"0\"><li>SPRFL_AUTOFLASH</li>\n<li>SPRFL_2PFLASH</li>\n<li>SPRFL_HFLIP</li>\n<li>SPRFL_VFLIP</li>\n<li>SPRFL_BEHIND</li></ol>"
                    },
                    {
                        "name": "ITEMMV_",
                        "val": "Indexes for `itemsprite-&gt;MoveFlags`\n<ol start=\"0\"><li>[[ITEMMV_OBEYS_GRAVITY|If the item is affected by gravity.]]</li>\n<li>[[ITEMMV_CAN_PITFALL|If the item can fall in pitfalls.]]</li>\n<li value=\"8\">[[ITEMMV_NO_FAKE_Z|If the FakeZ axis is disabled.]]</li>\n<li>[[ITEMMV_NO_REAL_Z|If the Z axis is disabled.]]</li></ol>\n"
                    },
                    {
                        "name": "WPNMV_",
                        "val": "Indexes for `lweapon-&gt;MoveFlags` and `eweapon-&gt;MoveFlags`\n<ol start=\"0\"><li>[[WPNMV_OBEYS_GRAVITY|If the weapon is affected by gravity.]]</li>\n<li>[[WPNMV_CAN_PITFALL|If the weapon can fall in pitfalls.]]</li>\n<li value=\"8\">[[WPNMV_NO_FAKE_Z|If the FakeZ axis is disabled.]]</li>\n<li>[[WPNMV_NO_REAL_Z|If the Z axis is disabled.]]</li></ol>\n\n"
                    },
                    {
                        "name": "NPCMV_",
                        "val": "Indexes for `npc-&gt;MoveFlags` and `npcdata-&gt;MoveFlags`\n<ol start=\"0\"><li>[[NPCMV_OBEYS_GRAVITY|If the npc is affected by gravity.]]</li>\n<li>[[NPCMV_CAN_PITFALL|If the npc can fall in pitfalls.]]</li>\n<li>[[NPCMV_CAN_PIT_WALK|If the npc can walk into pitfalls]]</li>\n<li>[[NPCMV_CAN_WATERDROWN|If the npc can drown in water]]</li>\n<li>[[NPCMV_CAN_WATER_WALK|If the npc can walk into water]]</li>\n<li>[[NPCMV_ONLY_WATER_WALK|If the npc has limited movement, restricted to water]]</li>\n<li>[[NPCMV_ONLY_SHALLOW_WATER_WALK|If the npc has limited movement, restricted to shallow water]]</li>\n<li>[[NPCMV_ONLY_PIT_WALK|If the npc has limited movement, restricted to pitfalls]]</li>\n<li>[[NPCMV_NO_FAKE_Z|If the FakeZ axis is disabled.]]</li>\n<li>[[NPCMV_NO_REAL_Z|If the Z axis is disabled.]]</li>\n<li>[[NPCMV_USE_FAKE_Z|If the npc should use the FakeZ axis]]</li>\n<li>[[NPCMV_IGNORE_SOLIDITY|If the npc should ignore solidity]]</li>\n<li>[[NPCMV_IGNORE_BLOCKFLAGS|If the npc should ignore flags that would block it, such as `No Enemies` flags]]</li>\n<li>[[NPCMV_IGNORE_SCREENEDGE|If the npc should treat the edge of the screen as a non-boundary]]</li>\n<li>[[NPCMV_USE_SCRIPTED_MOVEMENT_ENGINE|If the npc's engine movement should use the script movement flags]]</li>\n<li>[[NPCMV_NOT_PUSHABLE_BY_SOLIDS|If the npc is immune to being pushed by moving solids]]</li></ol>\n"
                    },
                    {
                        "name": "DS_",
                        "val": "Values for `itemsprite-&gt;DrawStyle`\n<ol start=\"0\"><li>[[DS_NORMAL|Draw the sprite normally.]]</li>\n<li>[[DS_PHANTOM|Draw the sprite transparently.]]</li>\n<li>[[DS_CLOAKED|Draw the sprite cloaked (invisible).]]</li>\n<li>[[DS_LINK|Draw the sprite normally, used for the player.]]</li></ol>\n"
                    },
                    {
                        "name": "LIGHT_",
                        "val": "The light shapes for dark rooms.\n<ol start=\"0\"><li>[[LIGHT_CIRCLE|Emit light in a circle around the sprite. The radius is the circle's radius.]]</li>\n<li>[[LIGHT_CONE|Emit light in a 8-directional cone in the facing direction. The radius is the length of the cone.]]</li>\n<li>[[LIGHT_SQUARE|Emit light in a square around the sprite. The radius is the square's radius.]]</li></ol>"
                    },
                    {
                        "name": "UNBLOCK_",
                        "val": "Flags for `lweapon-&gt;Unblockable` and `eweapon-&gt;Unblockable`\n<mono>UNBLOCK_NONE   = 0000b\nUNBLOCK_NORM   = 0001b\nUNBLOCK_IGNR   = 0010b\nUNBLOCK_SHLD   = 0100b\nUNBLOCK_REFL   = 1000b\nUNBLOCK_ALL    = 1111b</mono>\n"
                    },
                    {
                        "name": "WFLAG_",
                        "val": "Flags for `lweapon-&gt;Flags[]` and `eweapon-&gt;Flags[]`\n<ol start=\"0\"><li>[[WFLAG_PICKUP_ITEMS|If true, the weapon collects any items it touches, similar to engine melee weapons.]]</li>\n<li>[[WFLAG_BREAKS_ON_LANDING|If true, the weapon will die when landing via gravity.]]</li>\n<li>[[WFLAG_BREAKS_ON_SOLID|If true, the weapon will die upon hitting something solid.]]</li>\n<li>[[WFLAG_BURN_ANYFIRE|If true, the weapon will burn fire triggers looking for 'any fire'.]]</li>\n<li>[[WFLAG_BURN_STRONGFIRE|If true, the weapon will burn fire triggers looking for 'strong fire'.]]</li>\n<li>[[WFLAG_BURN_MAGICFIRE|If true, the weapon will burn fire triggers looking for 'magic fire'.]]</li>\n<li>[[WFLAG_BURN_DIVINEFIRE|If true, the weapon will burn fire triggers looking for 'divine fire'.]]</li>\n<li>[[WFLAG_STOP_ON_LANDING|If true, the weapon will change its `Step` to 0 when landing via gravity.]]</li>\n<li>[[WFLAG_STOP_ON_SOLID|If true, the weapon will change its `Step` to 0 upon hitting something solid.]]</li>\n<li>[[WFLAG_UPDATE_BURNSPR|If true, the weapon will automatically change its sprite to a sprite from ${weapon::Sprites|weapon->Sprites[]} depending on the current states of the 'WFLAG_BURN_' flags. (The highest-active burn flag determines which sprite to use)]]</li></ol>"
                    },
                    {
                        "name": "SHLD_",
                        "val": "Indexes for `npc-&gt;Shield[]`\n<ol start=\"0\"><li>[[SHLD_FRONT|If true, the enemy's front is shielded.]]</li>\n<li>[[SHLD_BACK|If true, the enemy's back is shielded.]]</li>\n<li>[[SHLD_LEFT|If true, the enemy's left is shielded.]]</li>\n<li>[[SHLD_RIGHT|If true, the enemy's right is shielded.]]</li>\n<li>[[SHLD_CAN_BREAK|If true, the enemy's shield is breakable.]]</li></ol>"
                    }
                ]
            }
        ]
    },
    "pagetitle": "ZSDocs",
    "header": "ZScript Documentation (WIP)",
    "url": "https://zquestclassic.com/docs/zscript",
    "urltxt": "Latest"
}