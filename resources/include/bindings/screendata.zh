// 176 per screen in the current region. Same as [Region->NumCombos].
//
// @zasm_var REGION_NUM_COMBOS
internal const int NUM_COMBO_POS;

enum WipeEffect
{
	WIPE_CIRCLE,
	WIPE_OVAL,
	WIPE_TRIANGLE,
	WIPE_SMAS,
	WIPE_FADEBLACK,
	WIPE_MAX
};

// Determines how to interpret coordinates given to [Screen] draw functions.
enum DrawOrigin
{
	// When in a scrolling region (or scrolling to/from one), this is equal to [DRAW_ORIGIN_REGION].
	// Otherwise, this is equal to [DRAW_ORIGIN_PLAYING_FIELD].
	DRAW_ORIGIN_DEFAULT = 0L,
	// The origin `(0, 0)` is the top-left pixel of the playing field (where screen combos are drawn).
	// Normally, this is just below the passive subscreen. But in extended height mode,
	// this is the top-left pixel of the screen and so is equivalent to [DRAW_ORIGIN_SCREEN].
	//
	// Use this to draw overlay effects across the playing field.
	DRAW_ORIGIN_PLAYING_FIELD = 1L,
	// The origin `(0, 0)` is the top-left pixel of the screen.
	// Use this to draw overlay effects across the entire screen.
	DRAW_ORIGIN_SCREEN = 2L,
	// The origin `(0, 0)` is the top-left pixel of the current region. Use this to draw with a
	// sprite's coordinates.
	//
	// When scrolling, this is treated as [DRAW_ORIGIN_REGION_SCROLLING_NEW] for new screens and
	// [DRAW_ORIGIN_REGION_SCROLLING_OLD] for old screens.
	DRAW_ORIGIN_REGION = 3L,
	// The origin `(0, 0)` is the top-left pixel of the new region being scrolled to.
	//
	// Equivalent to [DRAW_ORIGIN_REGION] when not scrolling.
	DRAW_ORIGIN_REGION_SCROLLING_NEW = 4L,
	// The origin `(0, 0)` is the top-left pixel of the old region being scrolled away from.
	//
	// Equivalent to [DRAW_ORIGIN_REGION] when not scrolling.
	DRAW_ORIGIN_REGION_SCROLLING_OLD = 5L,
	// The origin `(0, 0)` is the top-left pixel of the sprite [Screen->DrawOriginTarget].
	//
	// If the sprite no longer exists at time of drawing, then the draw command will be ignored.
	//
	// @versionadded 3.0
	DRAW_ORIGIN_SPRITE = 6L,
};

// Polygon rendering modes. Use with Screen->"Psuedo 3D" or "*3D" drawing functions. ie; Polygon, Quad, or Triangle
// For more detail on these polygon rendering modes, see https://github.com/ZQuestClassic/ZQuestClassic/blob/main/third_party/allegro_legacy/docs/src/allegro._tx#L7808.
enum PolygonRenderMode
{
	PT_FLAT                        = 0,  // Single color shading.
	PT_FLATSHADED                  = 1,  // "" with flat shading (*3D only).
	PT_COLSHADED                   = 2,  // "" with color shading (*3D only).
	PT_TEXTURE                     = 3,  // Texture mapped polygon using 2d linear interpolation.
	PT_PTEXTURE                    = 4,  // "".
	PT_MASKTEXTURE                 = 5,  // Transparent texture mapped polygon using 2d linear interpolation.
	PT_MASKPTEXTURE                = 6,  // "".
	PT_LITTEXTURE                  = 7,  // "" with lighting (*3D only).
	PT_LITPTEXTURE                 = 8,  // "" (*3D only).
	PT_MASKLITTEXTURE              = 9,  // "" with transparency.
	PT_MASKLITPTEXTURE             = 10, // "".
	PT_TRANSTEXTURE                = 11, // Translucent texture mapped polygon using 2d linear interpolation.
	PT_TRANSPTEXTURE               = 12, // "".
	PT_MASKTRANSTEXTURE            = 13, // Translucent and transparent texture mapped polygon using 2d linear interpolation.
	PT_MASKTRANSPTEXTURE           = 14, // "".
};

// Sprite lists. Used with [Screen->ClearSprites].
enum SpriteList
{
	SL_GUYS                        = 0, // Enemies.
	SL_ITEMS                       = 1, // Items.
	SL_EWPNS                       = 2, // Enemy weapons.
	SL_LWPNS                       = 3, // Link's weapons.
	SL_DECORATIONS                 = 4, // Grass clippings, Hover boots glow, etc.
	SL_PARTICLES                   = 5, // Farore's Wind particles.
};

// Screen flags, used with [Screen->Flag] and [mapdata::Flag].
enum ScreenFlag
{
	// Room type
	SFL_INTERIOR = 40, // aka 'Cave'.
	SFL_DUNGEON = 41,
	SFL_SIDEVIEW = 51,

	// View
	SFL_INVISIBLE_HERO = 19, // Hide Hero.
	SFL_NO_HERO_MARKER = 52,
	SFL_NO_SUBSCREEN = 20,
	SFL_NO_SUBSCREEN_OFFSET = 22,
	SFL_LAYER2BG = 49, // Layer 2 is background.
	SFL_LAYER3BG = 48, // Layer 3 is background.
	SFL_DARK_ROOM = 2,
	SFL_DARK_DITHER = 67,
	SFL_DARK_TRANS = 68,

	// Secrets
	SFL_SHUTTERS = 0, // Block->Shutters
	SFL_TEMP_SECRETS = 36, // Secrets are temporary.
	SFL_TRIGGERS_PERM = 42, // All Triggers->Perm Secret.
	SFL_ALL_TRIGGER_FLAGS = 45, // All Triggers->16-31.
	SFL_SECRET_SFX = 12, // Play Secret SFX on Entry.

	// Warp
	SFL_WARP_AUTO_DIRECT = 34, // Auto Warps are Direct.
	SFL_WARP_SENSITIVE_DIRECT = 35, // Sensitive warps are Direct.
	SFL_WARP_TIMED_DIRECT = 26, // Timed Warp is Direct.
	SFL_WARP_UP = 8, // Side warp.
	SFL_WARP_DOWN = 9, // Side warp.
	SFL_WARP_LEFT = 10, // Side warp.
	SFL_WARP_RIGHT = 11, // Side warp.
	SFL_WARP_TIMED_RANDOM = 32,
	SFL_WARP_SPRITE_CARRYOVER = 21,
	SFL_WARP_MIRROR_DISABLE = 69,
	SFL_WARP_TIMED_SECRETS_DISABLE = 27, // Secrets Disable Timed Warp.

	// Maze
	SFL_MAZE = 6, // Use maze path.
	SFL_MAZE_OVERRIDES_SIDE_WARPS = 61,
	SFL_MAZE_CAN_GET_LOST = 72,
	SFL_MAZE_LOOPY = 73,

	// Items
	SFL_ITEM_HOLD_UP = 16, // Hold up item.
	SFL_ITEM_FALLS = 50, // Falls from ceiling.
	SFL_SECRETS_ITEM = 62, // Secrets reveal item.
	SFL_ITEM_SECRETS = 63, // Item triggers secrets.
	SFL_ITEM_SECRETS_PERM = 64, // Item triggers secrets, permanently.
	SFL_ITEM_RETURNS = 65, // Regular item always returns.
	SFL_SPECIAL_ITEM_RETURNS = 66, // Special item always returns.

	// Combos
	SFL_MIDAIR = 13, // Combos Affect Midair Hero.
	SFL_CYCLE_INIT = 17, // Cycle combos on screen init.
	SFL_IGNORE_BOOTS = 33, // Damage combos ignores boots.
	SFL_TOGGLE_RINGS = 46, // Toggle 'Rings Affect Combos'.

	// Save
	SFL_SAVE_ON_ENTRY = 31, // Save game on entry.
	SFL_CONTINUE_HERE = 43,
	SFL_SAVE_CONTINUE_HERE = 30, // Save Point->Continue. When saving at a 'Save' combo on this screen, set this as the continue screen.
	SFL_NO_CONTINUE_HERE = 44, // No continue Here after warp. 

	// FFC
	SFL_FFC_WRAP = 47, // FFCs wrap around screen.
	SFL_FFC_NO_CARRYOVER = 39, // If set, no FFC will carryover (even w/ the FFC's "carryover" flag set).

	// Whistle
	SFL_WHISTLE = 4, // Whistle->Stairs.
	SFL_WHISTLE_PALETTE = 54,
	SFL_WHISTLE_DRY_LAKE = 55,

	// Enemies
	SFL_ENEMIES_INVISIBLE = 18, // Hide enemies.
	SFL_ENEMIES_RETURN = 23, // Enemies always return.
	SFL_ENEMIES_ITEM = 1, // Killing enemies spawns screen item.
	SFL_ENEMIES_SECRETS = 15, // Enemies->Secrets.
	SFL_ENEMIES_SECRETS_PERM = 28, // Enemies->Secrets (perm).
	SFL_ENEMIES_STAY_DEAD = 71, // Enemies->Stay Dead - once all enemies are killed they will not respawn again
	SFL_ENEMIES_CHAIN_TRIGGERS = 70, // Chain 'Enemies->' Triggers.
	SFL_TRAPS_IGNORE_SOLID = 14, // Traps Ignore Solidity.
	SFL_ENEMIES_LEADER = 85, // Ringleader. The first enemy listed in the screen's enemy list will be a 'Ringleader'. When this enemy dies, all other enemies will die.
	SFL_ENEMIES_CARRY_ITEM = 86,
	SFL_ENEMIES_BOSS = 87, // Dungeon boss.

	// Enemies (spawn)
	SFL_ENEMY_SPAWN_ZORA = 80, // Spawns a zora enemy on entry.
	SFL_ENEMY_SPAWN_TRAP_CORNER = 81,
	SFL_ENEMY_SPAWN_TRAP_MIDDLE = 82,
	SFL_ENEMY_SPAWN_ROCKS = 83,
	SFL_ENEMY_SPAWN_SHOOTER = 84,

	// Misc
	SFL_TOGGLE_LADDER = 5, // Toggle allow ladder.
	SFL_TOGGLE_DIVING = 38, // Toggle allow diving.
	SFL_SCRIPT_1 = 56,
	SFL_SCRIPT_2 = 57,
	SFL_SCRIPT_3 = 58,
	SFL_SCRIPT_4 = 59,
	SFL_SCRIPT_5 = 60,
	
	// Gravity
	SFL_CUSTOM_GRAV = 74, // use screen-specific [screendata::GravityStrength|Gravity Strength] and [screendata::TerminalVelocity|Terminal Velocity]
};

// Screen Flag groups, used with [Screen->Flags].
// See Screen Data dialog for what flags are contained in each group.
// @deprecated
enum ScreenFlagGroup
{
	SF_ROOMTYPE, // Corresponds to [ScreenFlagRoomType].
	SF_VIEW, // Corresponds to [ScreenFlagView].
	SF_SECRETS, // Corresponds to [ScreenFlagSecrets].
	SF_WARP, // Corresponds to [ScreenFlagWarp].
	SF_ITEMS, // Corresponds to [ScreenFlagItems].
	SF_COMBOS, // Corresponds to [ScreenFlagCombos].
	SF_SAVE, // Corresponds to [ScreenFlagSave].
	SF_FFC, // Corresponds to [ScreenFlagFFC].
	SF_WHISTLE, // Corresponds to [ScreenFlagWhistle].
	SF_MISC, // Corresponds to [ScreenFlagMisc].
	SF_LAST,
};

// @deprecated
enum ScreenFlagRoomType
{
	SFR_INTERIOR,
	SFR_DUNGEON,
	SFR_SIDEVIEW,
	
	SFR_LAST
};

// @deprecated
enum ScreenFlagView
{
	SFV_INVISLINK,
	SFV_NOLINKMARKER,
	SFV_NOSUBSCREEN,
	SFV_NOOFFSET,  //'...but don't offset'
	SFV_LAYER2BG,  //Layer 2 is Background
	SFV_LAYER3BG,
	SFV_DARKROOM, 
	SFV_DARK_DITHER, 
	SFV_DARK_TRANS, 
	
	SFV_LAST
};

// @deprecated
enum ScreenFlagSecrets
{
	SFS_BLOCKSHUT, //Block->Shutters
	SFS_TEMPSECRETS, //Secrets are temporary.
	SFS_TRIGPERM,  //All Triggers->Perm Secret
	SFS_ALLTRIGFLAGS,  //All triggers->16-31
	
	SFS_LAST
};

// @deprecated
enum ScreenFlagWarp
{
	SFW_AUTODIRECT, //Auto Warps are Direct
	SFW_SENDSIRECT, //Sensitive Warps are direct.
	SFW_MAZEPATHS,  //Use maze Path
	SFW_MAZEOVERRIDE,  //maze Overrides Sidewarps
	SFW_SPRITECARRY, //Sprites carry over. 
	SFW_DISABLE_MIRROR, //Disable Magic Mirror
	SFW_MAZE_CAN_GET_LOST, //Maze Can Get Lost
	SFW_MAZE_LOOPY, //Maze Loopy
	
	SFW_LAST
};

// @deprecated
enum ScreenFlagItems
{
	SFI_HOLDUP, //Hold up item.
	SFI_FALLS, //Falls from ceiling
	SFI_SECRETSITEM,  //Secret reveals item
	SFI_ITEMSECRET,  //Item triggers secrets
	SFI_ITEMSECRETPERM, //Item triggering secrets is permanent
	SFI_ITEMRETURNS, //Regular item always returns
	SFI_SPECIALITEMRETURNS, //Special item always returns
	
	SFI_LAST
};

// @deprecated
enum ScreenFlagCombos
{
	SFC_MIDAIR, //Combos affect midair Hero.
	SFC_CYCLEINIT, //Cycle combos on screen init.
	SFC_IGNOREBOOTS,  //Damage combos ignore boots. 
	SFC_TOGGLERINGS,  //Toggle 'Rings Affect Combos'
	
	SFC_LAST
};

// @deprecated
enum ScreenFlagSave
{
	SFSV_SAVECONTHERE, //Save Point->Continue here.
	SFSV_SAVEONENTRY, //Save game on entry.
	SFSV_CONTHERE,  //Continue here.
	SFSV_NOCONTINUEWARP,  //No continue Here after warp. 
	
	SFSV_LAST
};

// @deprecated
enum ScreenFlagFFC
{
	SFF_WRAP,   //Freeform Combos Wrap Around
	SFF_NOCARRYOVER, //No FFC carry over. 
	
	SFF_LAST
};

// @deprecated
enum ScreenFlagMisc
{
	SFM_ALLOW_LADDER,   //Toggle 'Allow Ladder'
	SFM_NO_DIVING,      //Toggle 'No Diving' 
	SFM_SCRIPT1,         //General use 1 (Scripts)
	SFM_SCRIPT2,         //General use 2 (Scripts)
	SFM_SCRIPT3,        //General use 3 (Scripts)
	SFM_SCRIPT4,        //General use 4 (Scripts)
	SFM_SCRIPT5,        //General use 5 (Scripts)

	SFM_LAST
};

// @deprecated
enum ScreenFlagWhistle
{
	SFWH_STAIRS = 0, //Whistle->Stairs
	SFWH_PALCHANGE, //Whistle->Palette Change
	SFWH_DRYLAKE,  //Whistle->Dry lake
	
	SFWH_LAST
};

// Screen enemy flag groups. Used with [Screen->EFlags].
// @deprecated
enum ScreenEnemyFlagGroup
{
	SEF_SPAWN                      = 0, // Corresponds to [ScreenEnemyFlagSpawn].
	SEF_LIST1                      = 1, // Corresponds to [ScreenEnemyFlagList1].
	SEF_LIST2                      = 2, // Corresponds to [ScreenEnemyFlagList2].
};

// See [ScreenEnemyFlagGroup].
// @deprecated
enum ScreenEnemyFlagSpawn
{
	SEFSP_ZORA,
	SEFSP_CORNERTRAP,
	SEFSP_MIDDLETRAP,
	SEFSP_ROCK,
	SEFSP_SHOOTER,
	
	SEFSP_LAST
};

// See [ScreenEnemyFlagGroup].
// @deprecated
enum ScreenEnemyFlagList1
{
	SEFL1_RINGLEADER,
	SEFL1_CARRYITEM,
	SEFL1_INVIS,
	SEFL1_BOSS,
	SEFL1_TRAPS_IGNORE_SOLID,
	
	SEFL1_LAST
};

// See [ScreenEnemyFlagGroup].
// @deprecated
enum ScreenEnemyFlagList2
{
	SEFL2_ALWAYSRET,
	SEFL2_ENEMIES_ITEM,
	SEFL2_ENEMEIS_SECRET,
	SEFL2_ENEMIES_SECRET_PERM,
	SEFL2_CHAIN_ENEMIES_TRIGGERS,
	
	SEFL2_LAST
};

// Render Targets. Used with Screen->"*RenderTarget" and Screen->"Bitmap" drawing functions.
enum RenderTarget
{
	RT_CURRENT                     = -2, // Used with Blit(). mode7(), and RevBlit() for the current RT as dest.
	RT_SCREEN                      = -1, // Draws to screen.
	RT_BITMAP0                     = 0,  // Draws to off-screen bitmap 0.
	RT_BITMAP1                     = 1,  // Draws to off-screen bitmap 1.
	RT_BITMAP2                     = 2,  // Draws to off-screen bitmap 2.
	RT_BITMAP3                     = 3,  // Draws to off-screen bitmap 3.
	RT_BITMAP4                     = 4,  // Draws to off-screen bitmap 4.
	RT_BITMAP5                     = 5,  // Draws to off-screen bitmap 5.
	RT_BITMAP6                     = 6,  // Draws to off-screen bitmap 6.
};

// Contains functionality related to the currently loaded [mapdata] screen,
// including functions for drawing and creating/loading objects belonging to the
// screen.
//
// Many variables in `Screen` refer to a single [mapdata] screen (such as [Screen->UnderCombo]).
// For a scrolling [Region] with multiple screens, which screen these variables refer to
// depends on the context of the running script. See [Screen->Index] for more.
//
// The combo array variables (such as [Screen->ComboD]) may access any combo position
// in the current region. Use [ComboAt] to translate `(x, y)` world coordinates to a
// combo position. The size of these arrays is [NUM_COMBO_POS].
//
// For accessing specific screens, see [mapdata].
//
// Access with `Screen->`.
//
// @tutorial /tutorials/z3_user_guide
class screendata {
	// @delete
	internal screendata();

	// The index for the underlying screen. This determines which screen some variables refer to
	// (such as [UnderCombo], [Valid], or [Guy], just to name a few).
	//
	// In a non-scrolling [Region], this is equal to [Game->CurScreen].
	//
	// In a scrolling [Region], the default is equal to [Game->CurScreen] (the top-left screen).
	// However, many script types use a more relevant screen instead. For example:
	//
	// - screendata scripts use the screen they are assigned to
	// - ffc, npc, eweapon, lweapon, itemsprite, combo - all use the screen they were spawned on ([sprite::SpawnScreen])
	// - player - uses [Game->HeroScreen], which updates as the player moves around
	//
	// @versionadded 2.55.9 equivalent to [Game->CurScreen]
	// @zasm_var SCREEN_INDEX
	internal const int Index;

	// A set of 8 misc values for each screen.
	//
	// @zasm_var SDD
	internal untyped D[];
	
	// The [combodata] of each of the [NUM_COMBO_POS] combo positions on the screen.
	// Read-only, modify by editing the [ComboD] ID.
	//
	// @zasm_var COMBODATAD
	internal const combodata ComboData[];
	
	// The combo ID of each of the [NUM_COMBO_POS] combo positions on the screen.
	//
	// @zasm_var COMBODD
	internal int ComboD[];

	// The CSet of each of the [NUM_COMBO_POS] combo positions on the screen.
	//
	// @zasm_var COMBOCD
	internal int ComboC[];

	// The placed (map) flag of each of the [NUM_COMBO_POS] combo positions on the screen.
	//
	// @zasm_var COMBOFD
	internal int ComboF[];

	// The inherent flag of each of the [NUM_COMBO_POS] combo positions on the screen.
	// Editing this modifies the actual [combodata] of the combo.
	//
	// @zasm_var COMBOID
	internal int ComboI[];

	// The combo type of each of the [NUM_COMBO_POS] combo positions on the screen.
	// Editing this modifies the actual [combodata] of the combo.
	//
	// @value [enum ComboType]
	// @zasm_var COMBOTD
	internal int ComboT[];

	// The solidity bitflags of each of the [NUM_COMBO_POS] combo positions on the screen.
	// Editing this modifies the actual [combodata] of the combo.
	//
	// @value [enum ComboSolidityBitflags]
	// @zasm_var COMBOSD
	internal int ComboS[];

	// The effect area bitflags of each of the [NUM_COMBO_POS] combo positions on the screen.
	// Editing this modifies the actual [combodata] of the combo.
	//
	// @zasm_var COMBOED
	internal int ComboE[];

	// @index [enum DoorIndex]
	// @value [enum DoorType]
	// @zasm_var SCRDOORD
	internal int Door[];

	// The 32 screen states used by this screen.
	//
	// @index [enum ScreenState]
	// @zasm_var SCREENSTATED
	internal bool State[];

	// The 'Extra States' used by this screen.
	//
	// @zasm_var SCREENEXSTATED
	internal bool ExState[];

	// Whether or not the current [Region] is 'lit'. Applies to Classic Darkrooms.
	//
	// @zasm_var LIT
	internal bool Lit;

	// The remaining time, in frames, of the 'Wavy' visual effect. Decrements by
	// 1 each frame.
	//
	// @zasm_var WAVY
	internal int Wavy;

	// The remaining time, in frames, of the 'Quake' visual effect. Decrements
	// by 1 each frame.
	//
	// @zasm_var QUAKE
	internal int Quake;

	// Returns the number of the given object type that are present on the
	// current screen.
	//
	// @zasm_var ITEMCOUNT
	internal const int NumItems;

	// Gets/sets the current "Render Target". Most times this should be
	// 'RT_SCREEN', though versions older than 2.55 required using this for
	// bitmap drawing. 2.55's [bitmap] effectively obsolete the render target
	// system, and should be used instead of this.
	//
	// @value [enum RenderTarget]

	// @zasm_var GETRENDERTARGET
	internal const int GetRenderTarget;

	// Returns the number of the given object type that are present on the
	// current screen.
	//
	// @zasm_var NPCCOUNT
	internal const int NumNPCs;

	// The message ID of the currently active message. 0 if no message is
	// displayed.
	//
	// @zasm_var SHOWNMSG
	internal const int ShowingMessage;

	// Returns the number of the given object type that are present on the
	// current screen.
	//
	// @zasm_var LWPNCOUNT
	internal const int NumLWeapons;

	// Returns the number of the given object type that are present on the
	// current screen.
	//
	// @zasm_var EWPNCOUNT
	internal const int NumEWeapons;

	// The boolean flags for the screen.
	//
	// This only refers to the screen denoted by [Index].
	//
	// @index [enum ScreenFlag]
	// @zasm_var SCREEN_FLAG
	internal bool Flag[];

	// Multiple bitflags, split into groups.
	//
	// This only refers to the screen denoted by [Index].
	//
	// @deprecated Use [var Flag] instead.
	// @index [enum ScreenFlagGroup]
	// @value Varies based on [ScreenFlagGroup]
	// @zasm_var SCREENFLAGSD
	internal const int Flags[];

	// Multiple bitflags related to screen enemies, split into groups.
	//
	// This only refers to the screen denoted by [Index].
	//
	// @deprecated Use [var Flag] instead.
	// @index [enum ScreenEnemyFlagGroup]
	// @value Varies based on [ScreenEnemyFlagGroup]
	// @zasm_var SCREENEFLAGSD
	internal const int EFlags[];

	// If [SFL_CUSTOM_GRAV] is set, this gravity applies on the screen.
	//
	// @zasm_var SCREENDATA_GRAVITY_STRENGTH
	internal int GravityStrength;

	// If [SFL_CUSTOM_GRAV] is set, this terminal velocity applies on the screen.
	//
	// @zasm_var SCREENDATA_TERMINAL_VELOCITY
	internal int TerminalVelocity;

	// The special room type.
	//
	// This only refers to the screen denoted by [Index].
	//
	// @value [enum RoomType]
	// @zasm_var ROOMTYPE
	internal int RoomType;

	// @zasm_var PUSHBLOCKX
	internal int MovingBlockX;

	// @zasm_var PUSHBLOCKY
	internal int MovingBlockY;

	// The layer of a currently moving pushblock.
	// Is -1 and ignores writes if there is no pushblock currently moving.
	// Allows values 0-6; the block will "settle into place" on this layer.
	//
	// @zasm_var PUSHBLOCKLAYER
	internal int MovingBlockLayer;

	// @zasm_var PUSHBLOCKCOMBO
	internal int MovingBlockCombo;

	// @zasm_var PUSHBLOCKCSET
	internal int MovingBlockCSet;

	// The undercombo ID used by the screen.
	//
	// @zasm_var UNDERCOMBO
	internal int UnderCombo;

	// The CSet of the undercombo used by the screen.
	//
	// @zasm_var UNDERCSET
	internal int UnderCSet;

	// @zasm_var SCREENDATAVALID
	internal int Valid;

	// The screen guy.
	//
	// @zasm_var SCREENDATAGUY
	internal int Guy;

	// The screen string.
	//
	// @zasm_var SCREENDATASTRING
	internal int String;

	// The screen item.
	//
	// To determine if there is an item on the screen, if you ever assigned item
	// 0 as a valid screen item in your quest, you will also want to read
	// [HasItem] for that screen.
	//
	// Note: The NULL value is `0`, which is a valid item.
	//
	// @zasm_var SCREENDATAITEM
	internal int Item;

	// The Tile Warp type for Tile Warps A, B, C, and D; [0], [1], [2], and [3]
	// respectively.
	//
	// @index [enum TileWarpIndex]
	// @value [enum WarpType]
	// @zasm_var SCREENDATATILEWARPTYPE
	internal int TileWarpType[];

	// Set or get the overlay state for the warp ID corresponding to the index
	// of this array.
	//
	// @zasm_var SCREENDATATILEWARPOVFLAGS
	internal bool TileWarpOverlay[];

	// The doorset used by the screen, for NES dungeon doors.
	//
	// @zasm_var SCREENDATADOORCOMBOSET
	internal int DoorComboSet;

	// The X-component for each of the four 2.50+ (blue) warp return squares.
	//
	// @zasm_var SCREENDATAWARPRETX
	internal int WarpReturnX[];

	// The Y-component for each of the four 2.50+ (blue) warp return squares.
	//
	// @zasm_var SCREENDATAWARPRETY
	internal int WarpReturnY[];

	// The X component for where a Stairs secret appears on the screen.
	//
	// @zasm_var SCREENDATASTAIRX
	internal int StairsX;

	// The Y component for where a Stairs secret appears on the screen.
	//
	// @zasm_var SCREENDATASTAIRY
	internal int StairsY;

	// The X component for the item location on the screen.
	//
	// @zasm_var SCREENDATAITEMX
	internal int ItemX;

	// The Y component for the item location on the screen.
	//
	// @zasm_var SCREENDATAITEMY
	internal int ItemY;

	// The destination DMap for each of the four warp types.
	//
	// @zasm_var SCREENDATATILEWARPDMAP
	internal int TileWarpDMap[];

	// The destination screen for each of the four warp types.
	//
	// @zasm_var SCREENDATATILEWARPSCREEN
	internal int TileWarpScreen[];

	// The Maze Path 'Exit Direction'.
	//
	// @zasm_var SCREENDATAEXITDIR
	internal int ExitDir;

	// The IDs of the enemies that spawn on the screen.
	//
	// @zasm_var SCREENDATAENEMY
	internal int Enemy[];

	// The enemy 'Spawn Pattern'.
	//
	// @value [enum EnemyPattern]
	// @zasm_var SCREENDATAPATTERN
	internal int Pattern;

	// The Sidewarp type for Sidewarps A, B, C, and D; [0], [1], [2], and [3]
	// respectively.
	//
	// @index [enum SideWarpIndex]
	// @value [enum WarpType]
	// @zasm_var SCREENDATASIDEWARPTYPE
	internal int SideWarpType[];

	// Set or get the overlay state for the warp ID corresponding to the index
	// of this array.
	//
	// @zasm_var SCREENDATASIDEWARPOVFLAGS
	internal bool SideWarpOverlay[];

	// The X-component for the pre-2.50 (green) arrival square.
	//
	// @zasm_var SCREENDATAWARPARRIVALX
	internal int WarpArrivalX;

	// The X-component for the pre-2.50 (green) arrival square.
	//
	// @zasm_var SCREENDATAWARPARRIVALY
	internal int WarpArrivalY;

	// The four Maze Path directions.
	//
	// @zasm_var SCREENDATAPATH
	internal int MazePath[];

	// The destination screen for each of the four sidewarps.
	//
	// @zasm_var SCREENDATASIDEWARPSC
	internal int SideWarpScreen[];

	// Returns the sidewarp ID for a given screen edge, as `SideWarpID[dir]`;
	//
	// Returns [SIDEWARP_NONE] if there is no sidewarp in that direction.
	//
	// Valid indices: [DIR_UP], [DIR_DOWN], [DIR_LEFT], [DIR_RIGHT]
	// Valid values: [SideWarpIndex]
	//
	// @zasm_var SCREENSIDEWARPID
	internal int SideWarpID[];

	// The return square used by Tile Warp (A, B, C, D).
	//
	// @zasm_var SCREENDATATWARPRETSQR
	internal int TileWarpReturnSquare[];

	// The return square used by Side Warp (A, B, C, D).
	//
	// @zasm_var SCREENDATASWARPRETSQR
	internal int SideWarpReturnSquare[];

	// The destination DMap for each of the four sidewarps.
	//
	// @zasm_var SCREENDATASIDEWARPDMAP
	internal int SideWarpDMap[];

	// The palette for the screen set via 'F4' or 'Screen>>Palette' in ZQuest
	//
	// @zasm_var SCREENDATACOLOUR
	internal int Palette;

	// The screen 'Catchall' value.
	//
	// @zasm_var SCREENDATACATCHALL
	internal int Catchall;

	// The value of Damage Combo Sensitivity for the screen.
	//
	// @zasm_var SCREENDATACSENSITIVE
	internal int CSensitive;
	
	// Which parts of the screen state that won't reset via 'Reset Room' combos.
	//
	// @index [enum ScreenState]
	// @zasm_var SCREENDATANORESETARR
	internal bool NoResetState[];
	
	// Which parts of the screen state that won't reset via 'Reset Room' combos.
	//
	// @deprecated Use [NoResetState] instead!
	// @value [enum NoResetBitflags]
	// @zasm_var SCREENDATANORESET
	internal int NoReset;
	
	// For screen state carryovers, which parts of the screen state that won't carry over to the
	// target screen.
	//
	// @index [enum ScreenState]
	// @zasm_var SCREENDATANOCARRYARR
	internal bool NoCarryState[];

	// For screen state carryovers, which parts of the screen state that won't carry over to the
	// target screen.
	//
	// @deprecated Use [NoCarryState] instead!
	// @value [enum NoCarryBitflags]
	// @zasm_var SCREENDATANOCARRY
	internal int NoCarry;
	
	// Which of the 32 ExStates should be carried over to the target screen
	//
	// @zasm_var SCREENDATAEXCARRY
	internal bool ExStateCarry[];
	
	// Which of the 32 ExStates should be reset by 'Reset Room' combos
	//
	// @zasm_var SCREENDATAEXRESET
	internal bool ExStateReset[];

	// The Map IDs used by screen layers 1 through 6, represented as [1] through
	// [6].
	//
	// This array is 1-indexed, so index [0] does nothing and is invalid to access.
	//
	// This only refers to the screen denoted by [Index].
	//
	// @zasm_var SCREENDATALAYERMAP
	internal int LayerMap[];

	// The Screen IDs used by screen layers 1 through 6, represented as [1]
	// through [6].
	//
	// This array is 1-indexed, so index [0] does nothing and is invalid to access.
	//
	// This only refers to the screen denoted by [Index].
	//
	// @zasm_var SCREENDATALAYERSCREEN
	internal int LayerScreen[];

	// The opacity value for each layer used by this screen.
	//
	// Valid layers are 1 through 6, represented as [1] through [6].
	//
	// This array is 1-indexed, so index [0] does nothing and is invalid to access.
	//
	// @zasm_var SCREENDATALAYEROPACITY
	internal int LayerOpacity[];

	// If true, the current layer is invisible.
	//
	// Writing this true for layers 1 through 6 will make those layers
	// invisible.
	//
	// @zasm_var SCREENDATALAYERINVIS
	internal bool LayerInvisible[];

	// If true, the ZC engine will perform script draws on the given queue
	// layer.
	//
	// Each queue layer returns true by default.
	//
	// Writing this false disables script draws targetted to a specific layer
	// queue.
	//
	// @zasm_var SCREENDATASCRIPTDRAWS
	internal bool ScriptDraws[];

	// The timer used by 'Time Warp Tics' in Screen Data->T.Warp
	//
	// @zasm_var SCREENDATATIMEDWARPTICS
	internal int TimedWarpTimer;

	// The map to where secrets on the current mapscreen carry over.
	//
	// Corresponds to the Screen Data>>>Screen State Carryover 'Next Map'
	// selection in the ZQ Editor.
	//
	// @zasm_var SCREENDATANEXTMAP
	internal int NextMap;

	// The screen to where secrets on the current mapscreen carry over.
	//
	// Corresponds to the Screen Data>>>Screen State Carryover 'Next Screen'
	// selection in the ZQ Editor.
	//
	// @zasm_var SCREENDATANEXTSCREEN
	internal int NextScreen;

	// The Combo IDs used by 'Secret Combos' on this screen.
	//
	// @index [enum SecretComboIndex]
	// @zasm_var SCREENDATASECRETCOMBO
	internal int SecretCombo[];

	// The CSets used by 'Secret Combos' on this screen.
	//
	// @index [enum SecretComboIndex]
	// @zasm_var SCREENDATASECRETCSET
	internal int SecretCSet[];

	// The Combo Flags used by 'Secret Combos' on this screen.
	//
	// @index [enum SecretComboIndex]
	// @value [enum ComboFlag]

	// @zasm_var SCREENDATASECRETFLAG
	internal int SecretFlags[];

	// The 'Ambient Sound' under S.Data2.
	//
	// @zasm_var SCREENDATAOCEANSFX
	internal int AmbientSFX;

	// The Boss Roar sound for this screen.
	//
	// @zasm_var SCREENDATABOSSSFX
	internal int BossSFX;

	// The sound that will play on this screen, when secrets are triggered.
	//
	// @zasm_var SCREENDATASECRETSFX
	internal int SecretSFX;

	// The sound that will play if Link holds an item over his head on this
	// screen.
	//
	// @zasm_var SCREENDATAHOLDUPSFX
	internal int ItemSFX;

	// The MIDI that plays on this screen.
	//
	// @zasm_var SCREENDATASCREENMIDI
	internal int MIDI;

	// The screendata script used for the current screen.
	//
	// @zasm_var SCREENSCRIPT
	internal int Script;

	// The eight D args used by the screendata script for the current screen.
	//
	// @zasm_var SCREENINITD
	internal untyped InitD[];

	// Returns true if secrets have been triggered on this screen (including temp).
	//
	// @zasm_var SCREENSECRETSTRIGGERED
	internal const bool SecretsTriggered;

	// Returns the number of the given object type that are present on the
	// current screen.
	//
	// @zasm_var PORTALCOUNT
	internal const int NumPortals;

	// All currently loaded npcs.
	//
	// @zasm_var SCREEN_NPCS
	internal const npc NPCs[];

	// All currently loaded items.
	//
	// @zasm_var SCREEN_ITEMS
	internal const itemsprite Items[];

	// All currently loaded lweapons.
	//
	// @zasm_var SCREEN_LWEAPONS
	internal const lweapon LWeapons[];

	// All currently loaded eweapons.
	//
	// @zasm_var SCREEN_EWEAPONS
	internal const eweapon EWeapons[];

	// All currently loaded ffcs.
	//
	// @zasm_var SCREEN_FFCS
	internal const ffc FFCs[];

	// All currently loaded portals.
	//
	// @zasm_var SCREEN_PORTALS
	internal const portal Portals[];

	// Arrays of the layers which the lens shows.
	//
	// @zasm_var SCREENLENSSHOWS
	internal bool LensShows[];

	// Arrays of the layers which the lens hides.
	//
	// @zasm_var SCREENLENSHIDES
	internal bool LensHides[];

	// The size of the [Data] array.
	//
	// Changes save to the save file.
	//
	// @zasm_var SCREENSCRDATASIZE
	internal int DataSize;

	// Resizable array of data for scripts to use.
	//
	// Changes save to the save file.
	//
	// @zasm_var SCREENSCRDATA
	internal untyped Data[];

	// Number of enemies remaining alive on this screen.
	//
	// @zasm_var SCREENDATAGUYCOUNT
	internal int GuyCount;

	// @zasm_var SCREENDATAOCEANSFX
	internal int OceanSFX;

	// @zasm_var ROOMDATA
	internal int RoomData;

	// The palette for the screen set via 'F4' or 'Screen>>Palette' in ZQuest
	//
	// @zasm_var SCREENDATACOLOUR
	internal int CSet;

	// @zasm_var SCREENDATANEXTMAP
	internal int CarryoverMap;

	// @zasm_var SCREENDATANEXTSCREEN
	internal int CarryoverScreen;

	// If not zero, then the item for this screen will be shown.
	//
	// When the [Hero] takes the item on a screen, this is set to 0.
	//
	// @deprecated Check `->Item > -1` instead!
	// @zasm_var SCREENDATAHASITEM
	internal int HasItem;

	// Each entry is a separate 8-bit flag.
	//
	// @deprecated Use [var Flag] instead.
	// @length 10
	// @zasm_var SCREENDATAFLAGS
	internal int ScreenFlags[];

	// A flagset for enemies on the screen (E.Flags).
	//
	// @deprecated Use [Flag] instead!
	// @zasm_var SCREENDATAENEMYFLAGS
	internal int EnemyFlags;

	// The warp return IDs. Deprecated by SideWarpID[].
	//
	// @deprecated
	// @zasm_var SCREENDATASIDEWARPINDEX
	internal int SideWarpIndex;

	// @deprecated Use [Hero->RespawnX] instead!
	// @zasm_var SCREENDATAENTRYX
	internal int EntryX;

	// @deprecated Use [Hero->RespawnY] instead!
	// @zasm_var SCREENDATAENTRYY
	internal int EntryY;

	// @deprecated
	// @zasm_var SCREENDATALENSLAYER
	internal int LensLayer;

	// Returns the number of the given object type that are present on the
	// current screen.
	//
	// @deprecated Use [NumItems] instead!
	// @zasm
	//   SETR D2 ITEMCOUNT
	internal int NumItems();

	// Where '1 <= n <= [NumItems]', returns a pointer to the nth object on
	// the screen.
	//
	// @zasm
	//   POP D2
	//   SUBV D2 1
	//   LOADITEMR D2
	//   SETR D2 REFITEM
	internal itemsprite LoadItem(int n);

	// Creates a new item sprite.
	//
	// @param [ItemID] id
	// @zasm
	//   POP D2
	//   CREATEITEMR D2
	//   SETR D2 REFITEM
	internal itemsprite CreateItem(int id);

	// Returns the [ffc] for the given [id], where 1 <= id <= [MAX_FFC].
	//
	// See [ffc::ID].
	//
	// @zasm
	//   POP D2
	//   LOAD_FFC D2
	internal ffc LoadFFC(int id);

	// Returns the [ffc] from [screen] of the specified [index], where `0 <= index < 128`.
	//
	// [screen] must be a valid screen within the current [Region].
	//
	// @zasm
	//   POP D3
	//   POP D2
	//   LOAD_FFC_2 D2 D3
	internal ffc LoadFFC(int screen, int index);

	// Returns the number of the given object type that are present on the
	// current screen.
	//
	// @deprecated Use [NumNPCs] instead!
	// @zasm
	//   SETR D2 NPCCOUNT
	internal int NumNPCs();

	// Where `1 <= n <= NumNPCs`, returns a pointer to the nth npc on the
	// screen.
	//
	// @zasm
	//   POP D2
	//   SUBV D2 1
	//   LOADNPCR D2
	//   SETR D2 REFNPC
	internal npc LoadNPC(int n);

	// Creates a new npc (enemy) sprite, with the given ID.
	//
	// @param [NPCID] id
	// @zasm
	//   POP D2
	//   CREATENPCR D2
	//   SETR D2 REFNPC
	internal npc CreateNPC(int id);

	// Kills all sprite objects of the specified type.
	//
	// @param [SpriteList] spritelist
	// @zasm
	//   POP D2
	//   CLEARSPRITESR D2
	//   SETR D2 REFNPC
	internal void ClearSprites(int spritelist);

	// Determines how coordinates given to [Screen] drawing functions are interpreted.
	//
	// Each script has its own copy of this variable, meaning other scripts can't change
	// a script's draw origin unexpectedly.
	//
	// A [bitmap] loaded via [Game->LoadBitmapID] and [RT_SCREEN] also use this draw origin,
	// including when referencing [RT_SCREEN] in [bitmap::Blit], [bitmap::BlitTo] or
	// [bitmap::DrawPlane].
	//
	// When using the deprecated [SetRenderTarget] w/ [RT_BITMAP0] (or the other internal
	// bitmaps), this value is ignored.
	//
	// Defaults to [DRAW_ORIGIN_DEFAULT].
	//
	// @versionadded 2.55.9
	// @zasm_var SCREEN_DRAW_ORIGIN
	internal DrawOrigin DrawOrigin;

	// When [Screen->DrawOrigin] is [DRAW_ORIGIN_SPRITE], this sprite is used as the origin
	// for [Screen] drawing functions.
	//
	// Each script has its own copy of this variable.
	//
	// @versionadded 3.0
	// @zasm_var SCREEN_DRAW_ORIGIN_TARGET
	internal sprite DrawOriginTarget;

	// @zasm
	//   RECTR
	//   POPARGS D5 0.0012
	internal void Rectangle(int layer, int x, int y, int x2, int y2,
							int color, int scale = 1, int rx = 0, int ry = 0,
							int rot_degrees = 0, bool fill = true, int opacity = OP_OPAQUE);

	// @zasm
	//   CIRCLER
	//   POPARGS D5 0.0011
	internal void Circle(int layer, int x, int y, int radius, int color,
						 int scale = 1, int rx = 0, int ry = 0, int rot_degrees = 0,
						 bool fill = true, int opacity = OP_OPAQUE);

	// @zasm
	//   ARCR
	//   POPARGS D5 0.0014
	internal void Arc(int layer, int x, int y, int radius, int start_degrees,
					  int end_degrees, int color, int scale = 1, int rx = 0,
					  int ry = 0, int rot_degrees = 0, bool closed = true,
					  bool fill = true, int opacity = OP_OPAQUE);

	// @zasm
	//   ELLIPSER
	//   POPARGS D5 0.0012
	internal void Ellipse(int layer, int x, int y, int xradius, int yradius,
						  int color, int scale = 1, int rx = 0, int ry = 0,
						  int rot_degrees = 0, bool fill = true, int opacity = OP_OPAQUE);

	// @zasm
	//   LINER
	//   POPARGS D5 0.0011
	internal void Line(int layer, int x, int y, int x2, int y2,
					   int color, int scale = 1, int rx = 0, int ry = 0,
					   int rot_degrees = 0, int opacity = OP_OPAQUE);

	// @zasm
	//   SPLINER
	//   POPARGS D5 0.0011
	internal void Spline(int layer, int x1, int y1, int x2, int y2,
						 int x3, int y3, int x4, int y4, int color,
						 int opacity = OP_OPAQUE);

	// @zasm
	//   PUTPIXELR
	//   POPARGS D5 0.0008
	internal void PutPixel(int layer, int x, int y, int color, int rx = 0,
						   int ry = 0, int rot_degrees = 0, int opacity = OP_OPAQUE);

	// Puts multiple pixels to the screen in one function call.
	//
	// PutPixels() expects an array as its arg, with the array in the format of
	// repeating blocks of `{ x, y, color, trans }` Example:
	//
	// ```
	// PutPixels(1, { 25, 10, 5, OP_OPAQUE, 26, 10, 6, OP_OPAQUE }, 0, 0, 0 );
	// ```
	//
	// This draws two pixels to the screen.
	// The first is at coordinates `(25, 10)`, color 5, and it is opaque. The
	// second is at coordinates `(26, 10)`, color 6, and opaque.
	//
	// @zasm
	//   PIXELARRAYR
	//   POPARGS D5 0.0005
	internal void PutPixels(int layer, int ptr, int rx, int ry, int rot_degrees);

	// Similar to FastTile(), but it draws multiple tiles in one call.
	//
	// The arg *ptr[] should be an array with repeating sets of:
	// `{x,y,tile,color,opacity}`
	//
	// ...per tile that you want to draw.
	//
	// @zasm
	//   TILEARRAYR
	//   POPARGS D5 0.0002
	internal void DrawTiles(int layer, int ptr);

	// Similar to FastCombo, but draws multiple combos in one call.
	//
	// The arg *ptr[] should be an array with repeating sets of:
	// `{x,y,combo,cset,opacity}`
	//
	// ...per combo that you want to draw.
	//
	// @zasm
	//   COMBOARRAYR
	//   POPARGS D5 0.0002
	internal void DrawCombos(int layer, int ptr);

	// Similar to Line(0, but draws multiple lines in one call.
	//
	// The arg *ptr[] should be an array with repeating sets of: `{ x, y, x2,
	// y2, color, scale, rx, ry, angle, opacity }`
	//
	// ...per line that you want to draw.
	//
	// @zasm
	//   LINESARRAY
	//   POPARGS D5 0.0002
	internal void Lines(int layer, int ptr);

	// @zasm
	//   DRAWCHARR
	//   POPARGS D5 0.0010
	internal void DrawCharacter(int layer, int x, int y, int font,
								int color, int bg_color, int width, int height,
								char32 c, int opacity = OP_OPAQUE);

	// @zasm
	//   DRAWINTR
	//   POPARGS D5 0.0011
	internal void DrawInteger(int layer, int x, int y, int font, int color,
							  int bg_color, int width, int height, int value,
							  int num_decimal_places = 0, int opacity = OP_OPAQUE);

	// @zasm
	//   DRAWTILER
	//   POPARGS D5 0.0015
	internal void DrawTile(int layer, int x, int y, int tile, int block_w,
						   int block_h, int cset, int xscale = -1, int yscale = -1,
						   int rx = 0, int ry = 0, int rot_degrees = 0,
						   int flip = 0, bool transparency = true, int opacity = OP_OPAQUE);

	// As DrawTile(), but draws with a cloaked effect.
	//
	// @zasm
	//   DRAWTILECLOAKEDR
	//   POPARGS D5 0.0007
	internal void DrawTileCloaked(int layer, int x, int y, int tile, int blockw,
								  int blockh, int flip = 0);

	// @zasm
	//   DRAWCOMBOR
	//   POPARGS D5 0.0016
	internal void DrawCombo(int layer, int x, int y, int combo, int w,
							int h, int cset, int xscale = -1, int yscale = -1,
							int rx = 0, int ry = 0, int rot_degrees = 0,
							int frame = 0, int flip = 0, bool transparency = true,
							int opacity = OP_OPAQUE);

	// As DrawCombo(), but draws with a cloaked effect.
	//
	// @zasm
	//   DRAWCOMBOCLOAKEDR
	//   POPARGS D5 0.0007
	internal void DrawComboCloaked(int layer, int x, int y, int combo,
								   int tilewidth, int tileheight, int flip = 0);

	// @zasm
	//   QUADR
	//   POPARGS D5 0.0015
	internal void Quad(int layer, int x1, int y1, int x2, int y2,
					   int x3, int y3, int x4, int y4, int w,
					   int h, int cset, int flip, int texture, int render_mode);

	// @zasm
	//   TRIANGLER
	//   POPARGS D5 0.0013
	internal void Triangle(int layer, int x1, int y1, int x2, int y2,
						   int x3, int y3, int w, int h, int cset,
						   int flip, int texture, int render_mode);

	// @zasm
	//   QUAD3DR
	//   POPARGS D5 0.0008
	internal void Quad3D(int layer, int[] pos, int[] uv, int[] csets, int[] size,
						 int flip, int texture, int render_mode);

	// @zasm
	//   TRIANGLE3DR
	//   POPARGS D5 0.0008
	internal void Triangle3D(int layer, int[] pos, int[] uv, int[] csets, int[] size,
							 int flip, int tile, int polytype);

	// @zasm
	//   FASTTILER
	//   POPARGS D5 0.0006
	internal void FastTile(int layer, int x, int y, int tile, int cset,
						   int opacity = OP_OPAQUE);

	// @zasm
	//   FASTCOMBOR
	//   POPARGS D5 0.0006
	internal void FastCombo(int layer, int x, int y, int combo, int cset,
							int opacity = OP_OPAQUE);

	// @zasm
	//   DRAWSTRINGR
	//   POPARGS D5 0.0009
	internal void DrawString(int layer, int x, int y, int font, int color,
							 int background_color, int format, char32[] str,
							 int opacity = OP_OPAQUE);

	// As DrawString(), but includes a shadow on the text.
	//
	// Valid values for [shadow_type]: [ShadowType].
	//
	// @zasm
	//   DRAWSTRINGR2
	//   POPARGS D5 0.0011
	internal void DrawString(int layer, int x, int y, int font, int color,
							 int background_color, int format, char32[] str,
							 int opacity, int shadow_type, int shadow_color);

	// @zasm
	//   DRAWLAYERR
	//   POPARGS D5 0.0008
	internal void DrawLayer(int layer, int source_map, int source_screen, int source_layer,
							int x, int y, int rotation = 0, int opacity = OP_OPAQUE);

	// @zasm
	//   DRAWSCREENR
	//   POPARGS D5 0.0006
	internal void DrawScreen(int layer, int map, int screen, int x, int y,
							 int rotation = 0);

	// @zasm
	//   BITMAPR
	//   POPARGS D5 0.0012
	internal void DrawBitmap(int layer, int bitmap_id, int source_x, int source_y, int source_w,
							 int source_h, int dest_x, int dest_y, int dest_w, int dest_h,
							 int rotation, bool mask);

	// @zasm
	//   BITMAPEXR
	//   POPARGS D5 0.0016
	internal void DrawBitmapEx(int layer, int bitmap_id, int source_x,
							   int source_y, int source_w, int source_h,
							   int dest_x, int dest_y, int dest_w, int dest_h,
							   int rotation = 0, int cx = 0, int cy = 0,
							   int mode = 0, int lit = 0, bool mask = true);
	// As 'bitmap->BlitTo', but draws from a tile instead of a bitmap
	//
	// Blit supports multiple MODES, OR'd together as a bitmask:
	//
	// ```
	// const int BITDX_NORMAL = 0;
	// const int BITDX_TRANS = 0x01; //Translucent
	// const int BITDX_PIVOT = 0x02; //THe sprite will rotate at a specific
	// point, instead of its center. const int BITDX_HFLIP = 0x04; //Horizontal
	// Flip const int BITDX_VFLIP = 0x08; //Vertical Flip.
	// ```
	//
	// You can also set a pivot point for the rotation, using 'int cx' and 'int
	// cy'
	//
	// If these are non-zero, the rotation anchor point will center on these
	// coordinates.
	//
	// You may specify a color to 'int lit' to use a lit mode. This tints the
	// entire bitmap using that color index of the main palette.
	//
	// @zasm
	//   TILEBLIT
	//   POPARGS D5 0.0017
	internal void TileBlit(int layer, int tile, int cset, int source_x, int source_y,
					   int source_w, int source_h, int dest_x, int dest_y,
					   int dest_w, int dest_h, int rotation = 0, int cx = 0,
					   int cy = 0, int mode = 0, int lit = 0, bool mask = true);
	
	// As 'TileBlit', but uses the current tile of a specified combo.
	//
	// Blit supports multiple MODES, OR'd together as a bitmask:
	//
	// ```
	// const int BITDX_NORMAL = 0;
	// const int BITDX_TRANS = 0x01; //Translucent
	// const int BITDX_PIVOT = 0x02; //THe sprite will rotate at a specific
	// point, instead of its center. const int BITDX_HFLIP = 0x04; //Horizontal
	// Flip const int BITDX_VFLIP = 0x08; //Vertical Flip.
	// ```
	//
	// You can also set a pivot point for the rotation, using 'int cx' and 'int
	// cy'
	//
	// If these are non-zero, the rotation anchor point will center on these
	// coordinates.
	//
	// You may specify a color to 'int lit' to use a lit mode. This tints the
	// entire bitmap using that color index of the main palette.
	//
	// @zasm
	//   COMBOBLIT
	//   POPARGS D5 0.0017
	internal void ComboBlit(int layer, int combo, int cset, int source_x, int source_y,
					   int source_w, int source_h, int dest_x, int dest_y,
					   int dest_w, int dest_h, int rotation = 0, int cx = 0,
					   int cy = 0, int mode = 0, int lit = 0, bool mask = true);

	// Gets/sets the current "Render Target". Most times this should be
	// 'RT_SCREEN', though versions older than 2.55 required using this for
	// bitmap drawing. 2.55's [bitmap] effectively obsolete the render target
	// system, and should be used instead of this.
	//
	// @param [RenderTarget] rt
	// @zasm
	//   SETRENDERTARGET
	//   POP D3
	internal void SetRenderTarget(int rt);

	// Triggers the message number [message_id] from the Strings table to be
	// displayed on the screen.
	//
	// If [message_id] is 0, any message being displayed will be removed.
	//
	// @zasm
	//   POP D3
	//   MSGSTRR D3
	internal void Message(int message_id);

	// Returns the number of the given object type that are present on the
	// current screen.
	//
	// @deprecated Use [NumLWeapons] instead!
	// @zasm
	//   SETR D2 LWPNCOUNT
	internal int NumLWeapons();

	// Returns a pointer to the nth [lweapon] on the screen.
	//
	// @param [int] n - Between 1 and [NumLWeapons] (inclusive).
	// @zasm
	//   POP D2
	//   SUBV D2 1
	//   LOADLWEAPONR D2
	//   SETR D2 REFLWPN
	internal lweapon LoadLWeapon(int n);

	// Creates a new lweapon sprite, with the given type.
	//
	// @param [LWeaponType] type
	// @zasm
	//   POP D2
	//   CREATELWEAPONR D2
	//   SETR D2 REFLWPN
	internal lweapon CreateLWeapon(int type);

	// Returns the number of the given object type that are present on the
	// current screen.
	//
	// @deprecated Use [NumEWeapons] instead!
	// @zasm
	//   SETR D2 EWPNCOUNT
	internal int NumEWeapons();

	// Returns a pointer to the nth [eweapon] on the screen.
	//
	// @param [int] n - Between 1 and [NumEWeapons] (inclusive).
	// @zasm
	//   POP D2
	//   SUBV D2 1
	//   LOADEWEAPONR D2
	//   SETR D2 REFEWPN
	internal eweapon LoadEWeapon(int n);

	// Creates a new eweapon sprite, with the given type.
	//
	// @param [EWeaponType] type
	// @zasm
	//   POP D2
	//   CREATEEWEAPONR D2
	//   SETR D2 REFEWPN
	internal eweapon CreateEWeapon(int type);

	// @zasm
	//   POP D1
	//   POP D0
	//   ISSOLID D2
	internal bool isSolid(int x, int y);

	// As [Screen->isSolid], but instead of returning true if there is
	// solidity on layers 0, 1, or 2 - returns the solidity only for
	// the specified layer.
	//
	// @zasm
	//   POP D2
	//   POP D1
	//   POP D0
	//   ISSOLIDLAYER D2
	internal bool isSolidLayer(int x, int y, int layer);

	// Triggers secrets on this screen ([Screen->Index]).
	//
	// Temporary only, for permanent use [Screen->State].
	//
	// @zasm
	//   SECRETS
	internal void TriggerSecrets();

	// Triggers secrets on the provided screen, which must be within the current [Region].
	//
	// Temporary only, for permanent use [Game->LoadTempScreen] and [mapdata::State].
	//
	// @zasm
	//   POP D2
	//   REGION_TRIGGER_SECRETS D2
	internal void TriggerSecrets(int screen);

	// Plays the warping screen 'zap' effect.
	//
	// @zasm
	//   ZAPIN
	//   ZAPIN
	internal void ZapIn();

	// Plays the warping screen 'zap' effect.
	//
	// @zasm
	//   ZAPOUT
	internal void ZapOut();

	// Plays the warping screen 'wave' effect.
	//
	// @zasm
	//   WAVYIN
	internal void WavyIn();

	// Plays the warping screen 'wave' effect.
	//
	// @zasm
	//   WAVYOUT
	internal void WavyOut();

	// Plays the warping screen 'wipe' effect, respecting the wipe-related QRs.
	//
	// @zasm
	//   OPENWIPE
	internal void OpeningWipe();

	// Plays the warping screen 'wipe' effect, respecting the wipe-related QRs.
	//
	// @zasm
	//   CLOSEWIPE
	internal void ClosingWipe();

	// Plays the warping screen 'wipe' effect.
	//
	// Valid values for [effect]: [WipeEffect].
	//
	// @zasm
	//   POP D2
	//   OPENWIPESHAPE D2
	internal void OpeningWipe(int effect);

	// Plays the warping screen 'wipe' effect.
	//
	// Valid values for [effect]: [WipeEffect].
	//
	// @zasm
	//   POP D2
	//   CLOSEWIPESHAPE D2
	internal void ClosingWipe(int effect);

	// @zasm
	//   POLYGONR
	//   POPARGS D5 0.0005
	internal void Polygon(int layer, int num_points, int vertices, int color,
						  int opacity = OP_OPAQUE);

	// Draws a frame using a 2x2 block of tiles, where the upper-left corner of
	// which is the 'tile' value
	//
	// This works based on how the engine subscreen frame object works,
	// stretching the frame from those tiles to whatever size you specify.
	//
	// Width/height are in 8-pixel increments; ex. 4,4 would give a 2x2 tile
	// block; 8,8 would give a 4x4.
	//
	// @zasm
	//   FRAMER
	//   POPARGS D5 0.0009
	internal void DrawFrame(int layer, int x, int y, int tile, int cset,
							int width, int height, bool overlay = true,
							int opacity = OP_OPAQUE);

	// Returns true if secrets have been triggered on this screen (including
	// temp).
	//
	// @deprecated Use [SecretsTriggered] instead!
	// @zasm
	//   SETR D2 SCREENSECRETSTRIGGERED
	internal bool SecretsTriggered();

	// Immediately attempts to spawn all the screen enemies ([Enemy]), using the [Pattern].
	//
	// @zasm
	//   SCREENDOSPAWN
	internal bool SpawnScreenEnemies();

	// Attempts to trigger the combo at 'layer,pos', with it's trigger number 'trig_index'.
	// Returns true on success, false on failure.
	//
	// @zasm
	//   POP D1
	//   POP D3
	//   POP D2
	//   SCRTRIGGERCOMBO2 D2 D3 D1
	internal bool TriggerCombo(int layer, int pos, int trig_index = 0);

	// Returns the number of the given object type that are present on the
	// current screen.
	//
	// @deprecated Use [NumPortals] instead!
	// @zasm
	//   SETR D2 PORTALCOUNT
	internal int NumPortals();

	// Returns a pointer to the nth [portal] on the screen.
	//
	// @param [int] n - Between 1 and [NumPortals] (inclusive).
	// @zasm
	//   POP D2
	//   LOADPORTAL D2
	internal portal LoadPortal(int n);

	// Creates a new portal object.
	//
	// @zasm
	//   CREATEPORTAL
	internal portal CreatePortal();
	
	// Draws a square light to the engine darkroom bitmap, centered on 'cx,cy'.
	// Any of the args that defaults to -1, if passed as -1, will use the default
	// value from `Game->Generic[]` associated.
	//
	// @zasm
	//   DRAWLIGHT_SQUARE
	//   POPARGS D5 0.0007
	internal void DrawLightSquare(int cx, int cy, int radius = -1,
								  int transp_rad = -1, int dith_rad = -1, int dith_type = -1,
								  int dith_arg = -1);

	// Draws a circular light to the engine darkroom bitmap, centered on 'cx,cy'.
	// Any of the args that defaults to -1, if passed as -1, will use the default
	// value from `Game->Generic[]` associated.
	//
	// @zasm
	//   DRAWLIGHT_CIRCLE
	//   POPARGS D5 0.0007
	internal void DrawLightCircle(int cx, int cy, int radius = -1,
								  int transp_rad = -1, int dith_rad = -1, int dith_type = -1,
								  int dith_arg = -1);

	// Draws a cone of light to the engine darkroom bitmap, emanating in the
	// 8-dir 'dir' from the point 'cx,cy'.
	// Any of the args that defaults to -1, if passed as -1, will use the default
	// value from `Game->Generic[]` associated.
	//
	// @zasm
	//   DRAWLIGHT_CONE
	//   POPARGS D5 0.0008
	internal void DrawLightCone(int cx, int cy, int dir, int length = -1,
								int transp_rad = -1, int dith_rad = -1,
								int dith_type = -1, int dith_arg = -1);

	// Returns a door state for the screen.
	//
	// Each direction (DIR_UP,DIR_DOWN,DIR_LEFT,DIR_RIGHT) has 8 indexes (0-7)
	//
	// @zasm
	//   SETR D2 SCREENDATAEXDOOR
	//   POPARGS D5 0.0002
	internal bool GetExDoor(int dir, int index);

	// Sets a door state for the screen.
	//
	// Each direction (DIR_UP,DIR_DOWN,DIR_LEFT,DIR_RIGHT) has 8 indexes (0-7)
	//
	// @zasm
	//   POP D2
	//   SETR SCREENDATAEXDOOR D2
	//   POPARGS D5 0.0002
	internal void SetExDoor(int dir, int index, bool state);

	// Valid values for [type]: [WarpType].
	//
	// @zasm
	//   SETSIDEWARP
	//   POPARGS D5 0.0004
	internal void SetSideWarp(int warp_id, int screen, int dmap, int type);

	// @zasm
	//   SETTILEWARP
	//   POPARGS D5 0.0004
	internal void SetTileWarp(int warp_id, int screen, int dmap, int type);

	// Create an lweapon with sprites, sounds, and other values set as if it was
	// generated by a specific item.
	//
	// @zasm
	//   POP D1
	//   POP D0
	//   SETR D2 CREATELWPNDX
	internal lweapon CreateLWeaponDx(int type, int baseitem);

	// @deprecated
	// @zasm
	//   POP D2
	//   LOADNPCBYSUID D2
	//   SETR D2 REFNPC
	internal npc LoadNPCByUID(int uid);

	// @deprecated
	// @zasm
	//   POP D2
	//   LOADLWEAPONBYSUID D2
	//   SETR D2 REFLWPN
	internal lweapon LoadLWeaponByUID(int uid);

	// @deprecated
	// @zasm
	//   POP D2
	//   LOADWEAPONCBYSUID D2
	//   SETR D2 REFEWPN
	internal eweapon LoadEWeaponByUID(int uid);

	// @deprecated Use [LayerMap] instead!
	// @zasm
	//   POP D3
	//   LAYERMAP D2 D3
	internal int LayerMap(int layer);

	// @deprecated Use [LayerScreen] instead!
	// @zasm
	//   POP D3
	//   LAYERSCREEN D2 D3
	internal int LayerScreen(int layer);

	// @deprecated Use [SideWarpDMap] instead!
	// @zasm
	//   POP D2
	//   GETSIDEWARPDMAP D2
	internal int GetSideWarpDMap(int warp_id);

	// @deprecated Use [SideWarpScreen] instead!
	// @zasm
	//   POP D2
	//   GETSIDEWARPSCR D2
	internal int GetSideWarpScreen(int warp_id);

	// @deprecated Use [SideWarpType] instead!
	// @zasm
	//   POP D2
	//   GETSIDEWARPTYPE D2
	internal int GetSideWarpType(int warp_id);

	// @deprecated Use [TileWarpDMap] instead!
	// @zasm
	//   POP D2
	//   GETTILEWARPDMAP D2
	internal int GetTileWarpDMap(int warp_id);

	// @deprecated Use [TileWarpScreen] instead!
	// @zasm
	//   POP D2
	//   GETTILEWARPSCR D2
	internal int GetTileWarpScreen(int warp_id);

	// @deprecated Use [TileWarpType] instead!
	// @zasm
	//   POP D2
	//   GETTILEWARPTYPE D2
	internal int GetTileWarpType(int warp_id);
}

internal const screendata Screen;
