import "bindings/qrs.zh"

// Use as index for [Game->Gravity].
enum GravityIndex
{
	GR_STRENGTH,
	GR_TERMINALV,
	GR_SPRLAYER,
	GR_AIRDRAG
};

// Use as index for [Game->Scrolling].
enum ScrollingIndex
{
	SCROLL_DIR,
	SCROLL_NX, SCROLL_NY,
	SCROLL_OX, SCROLL_OY,
	SCROLLDATA_NPX, SCROLLDATA_NPY,
	SCROLLDATA_OPX, SCROLLDATA_OPY,
	SCROLL_NEW_REGION_WIDTH, SCROLL_NEW_REGION_HEIGHT,
	SCROLL_OLD_REGION_WIDTH, SCROLL_OLD_REGION_HEIGHT,
	SCROLL_NEW_VIEWPORT_WIDTH, SCROLL_NEW_VIEWPORT_HEIGHT,
	SCROLL_OLD_VIEWPORT_WIDTH, SCROLL_OLD_VIEWPORT_HEIGHT,
	SCROLL_NEW_VIEWPORT_X, SCROLL_NEW_VIEWPORT_Y,
	SCROLL_OLD_VIEWPORT_X, SCROLL_OLD_VIEWPORT_Y,
	SCROLL_NRX, SCROLL_NRY,
	SCROLL_ORX, SCROLL_ORY,
	SCROLLDATA_NEW_REGION_OFFSET_X, SCROLLDATA_NEW_REGION_OFFSET_Y
};

// Use as index for [Game->MiscSprites].
enum MiscSpriteIndex
{
	MISCSPR_FALL,
	MISCSPR_DROWN,
	MISCSPR_LAVADROWN,
	MISCSPR_SWITCHPOOF,
	MISCSPR_MAX
};

// Use as index for [Game->MiscSFX].
enum MiscSfx
{
	MISCSFX_BUSH,
	MISCSFX_SWITCHED,
	MISCSFX_LOWHEART,
	MISCSFX_ERROR,
	MISCSFX_PLAYER_HURT,
	MISCSFX_HAMMER_PEG,
	MISCSFX_SUBSCR_ITEM_ASSIGN,
	MISCSFX_SUBSCR_CURSOR_MOVE,
	MISCSFX_REFILL,
	MISCSFX_RUPEEDRAIN,
	MISCSFX_MAX
};

// Use as index for [Game->Generic].
enum GenericIndex
{
	GEN_HEARTPIECES        = 0, // Heart Pieces currently possessed
	GEN_MAGICDRAINRATE     = 1, // Link's magic usage equals n / 2.
	GEN_CANSLASH           = 2, // Link can slash with the sword.
	// Warp Ring number that a Whirlwind warp will send Link to.
	// It is set every time that Link uses the Whistle.
	GEN_WARPLEVEL          = 3,
	GEN_HCPPERHC           = 4, // How many Pieces of Heart form a complete Heart Container?
	GEN_CONTINUEHEARTS     = 5, // Amount of life that Link continues with
	GEN_CONTINUEISPERCENT  = 6, // Percentage of life that Link continues with
	GEN_HP_PER_HEART       = 7, //How much HP makes a 'heart'
	GEN_MP_PER_BLOCK       = 8, //How much MP makes a 'block'
	GEN_HERO_DMG_MULT      = 9, //Damage multiplier for damage by Link
	GEN_ENEM_DMG_MULT      = 10, //Damage multiplier for damage by enemies
	GEN_DITHER_TYPE        = 11, //Type of dithering used with dark rooms
	GEN_DITHER_ARG         = 12, //Dithering argument used with dark rooms
	GEN_DITHER_PERCENT     = 13, //Percent of light circles taken up by dithering
	GEN_DEFAULT_LIGHT_RAD  = 14, //Default light radius initialized to enemies
	GEN_TRANS_PERCENT      = 15, //Percent of light circles taken up by transparency
	GEN_DARKNESS_COLOR     = 16, //Color of darkness
	GEN_WATERGRAVITY       = 17, //Y position addition when not moving when sideview swimming. can be negative
	GEN_SIDESWIM_STEP_UP   = 18, //Hero step speed when sideview swimming, moving up
	GEN_SIDESWIM_STEP_SIDE = 19, //Hero step speed when sideview swimming, moving left and right
	GEN_SIDESWIM_STEP_DOWN = 20, //Hero step speed when sideview swimming, moving down
	// Jump value when exiting water from the top.
	// If 0, Link can only leave the top of the water via
	// sideview ladder.
	GEN_SIDESWIM_EXITJUMP  = 21,
	GEN_BUNNY_TILEMOD      = 22, //Tile modifier to apply while [Hero] is bunnified
	GEN_SWITCHHOOK_STYLE   = 23, //Which 'SW_EFF' style to use for the 'Switch w/ Hero' enemy defense
	GEN_FLICKER_FRAMES     = 24, //How many frames Link / enemies flicker for with the flicker damage effect
	GEN_FLICKER_COLOR      = 25, //Color used for the flicker effect
	GEN_FLICKER_TRANSP     = 26, //Number of transparency passes for the flicker effect
	GEN_MAX                = 27
};

// Values for [Game->MouseCursor].
enum MouseCursor
{
	ZCM_CUSTOM,
	ZCM_BLANK,
	ZCM_NORMAL,
	ZCM_MAX
};

// Contains general internal functions and variables.
//
// Access with `Game->`.
class Game {
	// @delete
	internal Game();

	// Returns the screen the [Hero] is currently on.
	//
	// @zasm_var CURSCR
	internal const int CurScreen;

	// Returns the screen the [Hero] is currently on, offset by the current dmap
	// offset.
	//
	// @zasm_var CURDSCR
	internal const int CurDMapScreen;

	// Returns the map the [Hero] is currently on.
	//
	// @zasm_var CURMAP
	internal const int CurMap;

	// Returns the dmap the [Hero] is currently on.
	//
	// @zasm_var CURDMAP
	internal const int CurDMap;

	// Returns the level the [Hero] is currently on.
	//
	// @zasm_var CURLEVEL
	internal const int CurLevel;

	// The number of times the [Hero] has died.
	//
	// @zasm_var GAMEDEATHS
	internal int NumDeaths;

	// The current activated cheat level. (range 0-4)
	//
	// @zasm_var GAMECHEAT
	internal int Cheat;

	// The highest cheat level that is enabled for the [Hero]. The [Hero] can
	// change their cheat level in the cheat menu to any value <= this value
	// (range 0-4). Updates when the [Hero] enters a cheat code.
	//
	// @zasm_var GAMEMAXCHEAT
	internal int MaxCheat;

	// Speed multiplier for the engine subscreen rise/fall. Default 1. Max 85.
	//
	// @zasm_var ACTIVESSSPEED
	internal long SubscreenSpeed;

	// The number of frames passed on the save file.
	// `include/time.zh` has several functions that help manage this value.
	//
	// @zasm_var GAMETIME
	internal long Time;

	// Returns true if the current save file was loaded, false if it was a
	// freshly created save.
	//
	// @zasm_var GAMEHASPLAYED
	internal const bool HasPlayed;

	// If true, keyboard input is disabled except for scripts reading it.
	//
	// @zasm_var TYPINGMODE
	internal bool TypingMode;

	// If 'false', `Game->Time` does not contain accurate time information.
	//
	// @zasm_var GAMETIMEVALID
	internal bool TimeValid;

	// The count of enemies remaining alive for each screen on the current map.
	//
	// @zasm_var GAMEGUYCOUNT
	internal int GuyCount[];

	// The continue point the [Hero] will be reset to when continuing.
	//
	// @zasm_var GAMECONTSCR
	internal int ContinueScreen;

	// The continue point the [Hero] will be reset to when continuing.
	//
	// @zasm_var GAMECONTDMAP
	internal int ContinueDMap;

	// The value of each of the game's counters.
	//
	// Valid indices: [CounterIndex] (`CR_`).
	// Valid values: `0 to 65535`.
	//
	// @zasm_var GAMECOUNTERD
	internal int Counter[];

	// The max value of each of the game's counters.
	//
	// Valid indices: [CounterIndex] (`CR_`).
	// Valid values: `0 to 65535`.
	//
	// @zasm_var GAMEMCOUNTERD
	internal int MCounter[];

	// The value of each of the game's drain counters.
	//
	// Valid indices: [CounterIndex] (`CR_`).
	// Valid values: `-32768 to 32767`.
	//
	// @zasm_var GAMEDCOUNTERD
	internal int DCounter[];

	// Generic values related to the game.
	//
	// Valid indices: [GenericIndex] (`GEN_`).
	//
	// @zasm_var GAMEGENERICD
	internal untyped Generic[];

	// Contains a bitwise flagset of the "Level Items".
	//
	// @zasm_var GAMELITEMSD
	internal int LItems[];

	// How many level-specific keys are owned for each level.
	//
	// @zasm_var GAMELKEYSD
	internal int LKeys[];

	// The level-specific switch states for each level. Each level has a single
	// `long`, representing 32 bitwise states. Ex:
	// `(Game->LSwitches[Game->CurLevel] & (1Lb << (5)))` will get the switch
	// state indexed `5`.
	//
	// @zasm_var GAMELSWITCH
	internal long LSwitches[];

	// The 256 global switch timers.
	//
	// @zasm_var GAMEGSWITCH
	internal int GSwitch[];

	// The contents of the [Hero]'s fillable bottles. Use bottle type IDs for
	// the values, and slots (set in the bottle item's attributes) as the
	// indexes.
	//
	// @zasm_var GAMEBOTTLEST
	internal int BottleState[];

	// True if the game is running in `Standalone` mode.
	//
	// @zasm_var GAMESTANDALONE
	internal bool Standalone;

	// The last entrance point the [Hero] used, and will be reset to by some
	// mechanics.
	//
	// @zasm_var GAMEENTRSCR
	internal int LastEntranceScreen;

	// The last entrance point the [Hero] used, and will be reset to by some
	// mechanics.
	//
	// @zasm_var GAMEENTRDMAP
	internal int LastEntranceDMap;

	// Writing this to 'false' forcibly disables the "Click To Freeze" setting,
	// allowing the user to click without pausing the game (ex. for scripted
	// mouse interaction)
	//
	// @zasm_var GAMECLICKFREEZE
	internal bool ClickToFreezeEnabled;

	// The values of all Quest Rules.
	//
	// Valid indices: [QR] (`qr_`).
	//
	// @zasm_var FFRULE
	internal bool FFRules[];

	// If true, the end credits will not be shown.
	//
	// @zasm_var SKIPCREDITS
	internal bool SkipCredits;

	// If true, the F6 menu will not appear when F6 is pressed. The prompt to
	// exit the game will still be shown.
	//
	// @zasm_var SKIPF6
	internal bool SkipF6;

	// An array of suspend states, all false by default. By writing these true,
	// certain game operations may be paused until the state is written false
	// again.
	//
	// @zasm_var GAMESUSPEND
	internal bool Suspend[];

	// Whether each item is disabled or not on the current dmap.
	//
	// @zasm_var DISABLEDITEM
	internal bool DisableItem[];

	// The number of maps in the quest.
	//
	// @zasm_var GAMEMAXMAPS
	internal const int MapCount;

	// The ZScript version number the quest was last compiled in.
	//
	// @zasm_var ZSCRIPTVERSION
	internal const int ZScriptVersion;

	// The current version of ZC that the quest is being played in (ex: "2.55"
	// for 2.55)
	//
	// @zasm_var ZELDAVERSION
	internal const int Version;

	// The current Build ID of ZC that the quest is being played in.
	//
	// @deprecated
	// @zasm_var ZELDABUILD
	internal const int Build;

	// The current detailed version; this can be the current Alpha, Beta, Gamma,
	// or Release number, depending on the version of the program.
	//
	// @zasm_var ZELDABETA
	internal const int Beta;

	// What type of detailed version the program is in. `0 = Alpha`, `1 = Beta`,
	// `2 = Gamma`, `3 = Release`, `-1 = error`.
	//
	// @zasm_var ZELDABETATYPE
	internal const int BetaType;

	// If true, pressing the Start button will no longer open the active
	// subscreen.
	//
	// @zasm_var NOACTIVESUBSC
	internal bool DisableActiveSubscreen;

	// The number of message strings in the quest.
	//
	// @zasm_var GAMENUMMESSAGES
	internal const int NumMessages;

	// Values related to gravity.
	//
	// Valid indices: [GravityIndex] (`GR_`).
	//
	// @zasm_var GAMEGRAVITY
	internal int Gravity[];

	// values related to scrolling.
	//
	// Valid indices: [ScrollingIndex] (`SCROLL_`).
	//
	// @zasm_var GAMESCROLLING
	internal const int Scrolling[];

	// The `Quest->Graphics->Sprites->Misc Sprites` values.
	//
	// Valid indices: [MiscSpriteIndex] (`MISCSPR_`).
	//
	// @zasm_var GAMEMISCSPR
	internal int MiscSprites[];

	// The `Quest->Audio->Misc SFX` values.
	//
	// Valid indices: [MiscSfx] (`MISCSFX_`).
	//
	// @zasm_var GAMEMISCSFX
	internal int MiscSFX[];

	// A variably-sized array containing information about the current event.
	// This should be accessed from [genericdata] after returning from
	// [WaitEvent]. Depending on what event WaitEvent() returns, a different set
	// of constants should be used to access this array.
	//
	// @zasm_var GAMEEVENTDATA
	internal untyped EventData[];

	// Which mouse cursor should be displayed during gameplay.
	// [ZCM_BLANK] is the default, and it resets on visiting the title screen.
	//
	// Valid values: [MouseCursor] (`ZCM_`).
	//
	// @zasm_var GAMEMOUSECURSOR
	internal int MouseCursor;

	// Returns the number of saved portals that currently exist.
	//
	// @zasm_var SAVEDPORTALCOUNT
	internal const int NumSavedPortals;

	// A 0-indexed Internal Array pointer referencing the saved portal objects.
	// Cannot access the Magic Mirror's portal.
	//
	// @zasm_internal_array 6
	internal const savedportal SavedPortals[];

	// The 256 'Trigger Group' values for the current screen.
	//
	// @zasm_var GAMETRIGGROUPS
	internal const int TrigGroups[];

	// The 256 'Trigger Group' values for the current screen.
	//
	// @zasm_var GAMETRIGGROUPS
	internal const int TriggerGroups[];

	// The override values for each itemclass. Default value is `-2`. If set to
	// `-2`, no override occurs. If `> -2`, anything that checks for the
	// 'highest level item' of this class uses this ID instead. A value of `-1`
	// indicates forcing it to return 'no item'.
	//
	// @zasm_var GAMEOVERRIDEITEMS
	internal int OverrideItems[];

	// True if the active subscreen is currently open.
	//
	// @zasm_var GAMEASUBOPEN
	internal const bool ActiveSubscreenOpen;

	// The Y offset of the active subscreen, used while it is opening/closing.
	//
	// Value is `-224` if subscreen is closed, `-56` if it is open, or the
	// current draw offset otherwise.
	//
	// @zasm_var GAMEASUBYOFF
	internal const int ActiveSubscreenY;

	// Returns the total number of active subscreens
	//
	// @zasm_var GAMENUMASUB
	internal int NumActiveSubscreens;

	// Returns the total number of passive subscreens
	//
	// @zasm_var GAMENUMPSUB
	internal int NumPassiveSubscreens;

	// Returns the total number of overlay subscreens
	//
	// @zasm_var GAMENUMOSUB
	internal int NumOverlaySubscreens;

	// Returns the highest valid ID of the strings in the ZQuest String Editor.
	//
	// @zasm_var GAMENUMMESSAGES
	internal const int HighestStringID;

	// @deprecated Use [Input->KeyPress] instead!
	// @zasm_var READKEY
	internal const bool ReadKey[];

	// @deprecated Use [Input->Joypad] instead!
	// @zasm_var JOYPADPRESS
	internal const bool JoypadPress[];

	// @deprecated Use [Input->Press] instead!
	// @zasm_var BUTTONPRESS
	internal bool ButtonPress[];

	// @deprecated Use [Input->Button] instead!
	// @zasm_var BUTTONINPUT
	internal bool ButtonInput[];

	// @deprecated Use [Input->Button] instead!
	// @zasm_var BUTTONHELD
	internal bool ButtonHeld[];

	// Set or get the Level Palette for each DMap
	//
	// @deprecated Use [dmapdata::Palette] instead!
	// @zasm_var DMAPLEVELPAL
	internal int DMapPalette[];

	// @deprecated Use [dmapdata::Flagset] instead!
	// @zasm_var DMAPFLAGSD
	internal int DMapFlags[];

	// @deprecated Use [dmapdata::Level] instead!
	// @zasm_var DMAPLEVELD
	internal int DMapLevel[];

	// @deprecated Use [dmapdata::Compass] instead!
	// @zasm_var DMAPCOMPASSD
	internal int DMapCompass[];

	// @deprecated Use [dmapdata::Continue] instead!
	// @zasm_var DMAPCONTINUED
	internal int DMapContinue[];

	// @deprecated Use [dmapdata::MIDI] instead!
	// @zasm_var DMAPMIDID
	internal int DMapMIDI[];

	// @deprecated Use [dmapdata::Offset] instead!
	// @zasm_var DMAPOFFSET
	internal int DMapOffset[];

	// @deprecated Use [dmapdata::Map] instead!
	// @zasm_var DMAPMAP
	internal int DMapMap[];

	// Ends the current quest in victory, resetting to the title screen (without
	// showing the normal end credits), and if this quest is part of a module,
	// increment to the next quest in the module.
	//
	// @zasm
	//   SETR D2 INCQST
	internal int IncrementQuest();

	// Returns the current max sprite count for each sprite type.
	//
	// @zasm
	//   SETR D2 SPRITEMAXNPC
	internal int MaxNPCs();

	// Sets the max sprite count for a sprite type to the given new value. Max
	// must be between 1 and 1024, inclusive.
	//
	// @zasm
	//   POP D2
	//   SETR SPRITEMAXNPC D2
	internal void MaxNPCs(int value);

	// Returns the current max sprite count for each sprite type.
	//
	// @zasm
	//   SETR D2 SPRITEMAXLWPN
	internal int MaxLWeapons();

	// Sets the max sprite count for a sprite type to the given new value. Max
	// must be between 1 and 1024, inclusive.
	//
	// @zasm
	//   POP D2
	//   SETR SPRITEMAXLWPN D2
	internal void MaxLWeapons(int value);

	// Returns the current max sprite count for each sprite type.
	//
	// @zasm
	//   SETR D2 SPRITEMAXEWPN
	internal int MaxEWeapons();

	// Sets the max sprite count for a sprite type to the given new value. Max
	// must be between 1 and 1024, inclusive.
	//
	// @zasm
	//   POP D2
	//   SETR SPRITEMAXEWPN D2
	internal void MaxEWeapons(int value);

	// Returns the current max sprite count for each sprite type.
	//
	// @zasm
	//   SETR D2 SPRITEMAXITEM
	internal int MaxItemsprites();

	// Sets the max sprite count for a sprite type to the given new value. Max
	// must be between 1 and 1024, inclusive.
	//
	// @zasm
	//   POP D2
	//   SETR SPRITEMAXITEM D2
	internal void MaxItemsprites(int value);

	// Returns the screen the [Hero] is currently on.
	//
	// @deprecated Use [CurScreen] instead!
	// @zasm
	//   SETR D2 CURSCR
	internal int GetCurScreen();

	// Returns the screen the [Hero] is currently on, offset by the current dmap
	// offset.
	//
	// @deprecated Use [CurDMapScreen] instead!
	// @zasm
	//   SETR D2 CURDSCR
	internal int GetCurDMapScreen();

	// Returns the map the [Hero] is currently on.
	//
	// @deprecated Use [CurMap] instead!
	// @zasm
	//   SETR D2 CURMAP
	internal int GetCurMap();

	// Returns the dmap the [Hero] is currently on.
	//
	// @deprecated Use [CurDMap] instead!
	// @zasm
	//   SETR D2 CURDMAP
	internal int GetCurDMap();

	// Returns the level the [Hero] is currently on.
	//
	// @deprecated Use [CurLevel] instead!
	// @zasm
	//   SETR D2 CURLEVEL
	internal int GetCurLevel();

	// @zasm
	//   POP D1
	//   POP D0
	//   SETR D2 SDDD
	internal untyped GetScreenD(int screen, int reg);

	// @zasm
	//   POP D6
	//   POP D1
	//   POP D0
	//   SETR SDDD D6
	internal void SetScreenD(int screen, int reg, untyped value);

	// @zasm
	//   POP D2
	//   POP D1
	//   POP D0
	//   SETR D2 SDDDD
	internal untyped GetDMapScreenD(int dmap, int screen, int reg);

	// @zasm
	//   POP D6
	//   POP D2
	//   POP D1
	//   POP D0
	//   SETR SDDDD D6
	internal void SetDMapScreenD(int arg1, int arg2, int arg3, untyped arg4);

	// @zasm
	//   POP D2
	//   LOADITEMDATAR D2
	//   SETR D2 REFITEMCLASS
	internal itemdata LoadItemData(int item);

	// @deprecated Use [Audio->MIDI] instead!
	// @zasm
	//   SETR D2 GETMIDI
	internal int GetMIDI();

	// Saves the game. Can only run once per script per frame.
	//
	// @zasm
	//   SAVE
	internal void Save();

	// Closes the quest, returning to the title screen.
	//
	// @exit
	// @zasm
	//   GAMEEND
	internal void End();

	// Closes the program, without saving.
	//
	// @exit
	// @zasm
	//   GAMEEXIT
	internal void Exit();

	// Exits the quest without saving, then reloads the previous save.
	//
	// @exit
	// @zasm
	//   GAMERELOAD
	internal void Reload();

	// Continue's the quest, as 'F6->Continue'.
	//
	// @exit
	// @zasm
	//   GAMECONTINUE
	internal void Continue();

	// Saves the game, then exits.
	//
	// @exit
	// @zasm
	//   GAMESAVEQUIT
	internal void SaveAndQuit();

	// Saves the game, then continues.
	//
	// @exit
	// @zasm
	//   GAMESAVECONTINUE
	internal void SaveAndContinue();

	// Displays the engine Continue/Save/Retry screen.
	//
	// @zasm
	//   SHOWF6SCREEN
	internal void ShowContinueScreen();

	// Loads the save file name into the buffer.
	//
	// @zasm
	//   POP D2
	//   GETSAVENAME D2
	internal void GetSaveName(char32[] buf);

	// Sets the save file name to the contents of the buffer, limit 8
	// characters.
	//
	// @zasm
	//   POP D2
	//   SETSAVENAME D2
	internal void SetSaveName(char32[] buf);

	// Displays the Save screen, as Save Point combos use. Returns true if the
	// [Hero] saved, false otherwise.
	//
	// @zasm
	//   SAVESCREEN D2
	internal bool ShowSaveScreen();

	// Displays the Save/Quit screen.
	//
	// @zasm
	//   SAVEQUITSCREEN
	internal void ShowSaveQuitScreen();

	// Gets the script of the specified type with a name exactly matching
	// `name`. If no such script exists, returns `-1`.
	//
	// @zasm
	//   POP D2
	//   GETFFCSCRIPT D2
	internal int GetFFCScript(char32[] name);

	// Gets the script of the specified type with a name exactly matching
	// `name`. If no such script exists, returns `-1`.
	//
	// @zasm
	//   POP D2
	//   GETCOMBOSCRIPT D2
	internal int GetComboScript(char32[] name);

	// Gets the script of the specified type with a name exactly matching
	// `name`. If no such script exists, returns `-1`.
	//
	// @zasm
	//   POP D2
	//   GETITEMSCRIPT D2
	internal int GetItemScript(char32[] name);

	// Gets the script of the specified type with a name exactly matching
	// `name`. If no such script exists, returns `-1`.
	//
	// @zasm
	//   POP D2
	//   GETNPCSCRIPT D2
	internal int GetNPCScript(char32[] name);

	// Gets the script of the specified type with a name exactly matching
	// `name`. If no such script exists, returns `-1`.
	//
	// @zasm
	//   POP D2
	//   GETLWEAPONSCRIPT D2
	internal int GetLWeaponScript(char32[] name);

	// Gets the script of the specified type with a name exactly matching
	// `name`. If no such script exists, returns `-1`.
	//
	// @zasm
	//   POP D2
	//   GETEWEAPONSCRIPT D2
	internal int GetEWeaponScript(char32[] name);

	// Gets the script of the specified type with a name exactly matching
	// `name`. If no such script exists, returns `-1`.
	//
	// @alias GetHeroScript
	// @deprecated_alias GetLinkScript
	// @zasm
	//   POP D2
	//   GETHEROSCRIPT D2
	internal int GetPlayerScript(char32[] name);

	// Gets the script of the specified type with a name exactly matching
	// `name`. If no such script exists, returns `-1`.
	//
	// @zasm
	//   POP D2
	//   GETGLOBALSCRIPT D2
	internal int GetGlobalScript(char32[] name);

	// Gets the script of the specified type with a name exactly matching
	// `name`. If no such script exists, returns `-1`.
	//
	// @zasm
	//   POP D2
	//   GETDMAPSCRIPT D2
	internal int GetDMapScript(char32[] name);

	// Gets the script of the specified type with a name exactly matching
	// `name`. If no such script exists, returns `-1`.
	//
	// @zasm
	//   POP D2
	//   GETSCREENSCRIPT D2
	internal int GetScreenScript(char32[] name);

	// Gets the script of the specified type with a name exactly matching
	// `name`. If no such script exists, returns `-1`.
	//
	// @zasm
	//   POP D2
	//   GETSPRITESCRIPT D2
	internal int GetItemSpriteScript(char32[] name);

	// Gets the ID of the npc/item/combo/dmap whose name exactly matches `name`.
	// If no such object exists, returns `-1`.
	//
	// @zasm
	//   POP D2
	//   GETNPCBYNAME D2
	internal int GetNPC(char32[] name);

	// Gets the ID of the npc/item/combo/dmap whose name exactly matches `name`.
	// If no such object exists, returns `-1`.
	//
	// @zasm
	//   POP D2
	//   GETITEMBYNAME D2
	internal int GetItem(char32[] name);

	// Gets the ID of the npc/item/combo/dmap whose name exactly matches `name`.
	// If no such object exists, returns `-1`.
	//
	// @zasm
	//   POP D2
	//   GETCOMBOBYNAME D2
	internal int GetCombo(char32[] name);

	// Gets the ID of the npc/item/combo/dmap whose name exactly matches `name`.
	// If no such object exists, returns `-1`.
	//
	// @zasm
	//   POP D2
	//   GETDMAPBYNAME D2
	internal int GetDMap(char32[] name);

	// Gets the script of the specified type with a name exactly matching
	// `name`. If no such script exists, returns `-1`.
	//
	// @zasm
	//   POP D2
	//   GETGENERICSCRIPT D2
	internal int GetGenericScript(char32[] name);

	// The number of maps in the quest.
	//
	// @deprecated Use [MapCount] instead!
	// @zasm
	//   SETR D2 GAMEMAXMAPS
	internal int MapCount();

	// Loads an Enemy Editor table data ref for NPC [id], to a [npcdata]
	// pointer.
	//
	// @zasm
	//   POP D2
	//   LOADNPCDATAR D2
	//   SETR D2 REFNPCCLASS
	internal npcdata LoadNPCData(int id);

	// Loads a Combo Editor table data ref for combo [id], to a [combodata]
	// pointer.
	//
	// @zasm
	//   POP D2
	//   LOADCOMBODATAR D2
	//   SETR D2 REFCOMBODATA
	internal combodata LoadComboData(int id);

	// Loads the mapdata pointer for the screen at `(map,screen)`. Edits to
	// these pointers do not persist through quest exit. Edits to these pointers
	// will NOT affect the "current screen", even if the current map/screen is
	// supplied; see [LoadTempScreen] below for that.
	//
	// @zasm
	//   POP D1
	//   POP D0
	//   SETR D2 LOADMAPDATA
	internal mapdata LoadMapData(int map, int screen);

	// Loads the temp mapdata pointer for the specified layer.
	// `LoadTempScreen(0)` gives a pointer that works mostly the same as
	// `Screen->`, while passing 1 through 6 will give equal access to the other
	// layers of the screen. Modifications to these pointers are reset when the
	// screen changes.
	//
	// @zasm
	//   POP D2
	//   LOADTMPSCR D2
	internal mapdata LoadTempScreen(int layer);

	// Same as [LoadTempScreen], but for the specific [screen], which must be
	// within the current [Region].
	//
	// @zasm
	//   POP D1
	//   POP D0
	//   LOADTMPSCR2 D2
	internal mapdata LoadTempScreen(int screen, int layer);

	// Loads the temp mapdata pointer for the specified layer's *scrolling
	// screen*. This is only used during scrolling, for drawing the screen you
	// just came from during the scrolling animation. Writing to this at any
	// time other than during scrolling has no effect.
	//
	// @zasm
	//   POP D2
	//   LOADSCROLLSCR D2
	internal mapdata LoadScrollingScreen(int layer);

	// Loads an Weapon Sprite Editor table data ref for sprite 'id', to a
	// 'spritedata' typed pointer.
	//
	// @zasm
	//   POP D2
	//   LOADSPRITEDATAR D2
	//   SETR D2 REFSPRITEDATA
	internal spritedata LoadSpriteData(int id);

	// Loads a Shop Editor table ref for an item shop with an ID of 'id' to a
	// 'shopdata' typed pointer.
	//
	// @zasm
	//   POP D2
	//   LOADSHOPR D2
	//   SETR D2 REFSHOPDATA
	internal shopdata LoadShopData(int shop);

	// Loads a Shop Editor table ref for an info shop with an ID of [id] to a
	// 'shopdata' typed pointer.
	//
	// @zasm
	//   POP D2
	//   LOADINFOSHOPR D2
	//   SETR D2 REFSHOPDATA
	internal shopdata LoadInfoShopData(int shop);

	// Loads a [bitmap] pointer for one of the old-style render target `RT_`
	// bitmaps.
	//
	// @zasm
	//   POP D2
	//   LOADBITMAPDATAR D2
	//   SETR D2 REFBITMAP
	internal bitmap LoadBitmapID(int id);

	// Loads an String Table Editor table data ref for ZQ Message String 'id',
	// to a [messagedata] typed pointer.
	//
	// @zasm
	//   POP D2
	//   LOADMESSAGEDATAR D2
	//   SETR D2 REFMSGDATA
	internal messagedata LoadMessageData(int id);

	// Loads a dmapdata ref for dmap ID [dmap] to a [dmapdata] typed pointer.
	//
	// @zasm
	//   POP D2
	//   LOADDMAPDATAR D2
	//   SETR D2 REFDMAPDATA
	internal dmapdata LoadDMapData(int dmap);

	// Loads a dropsetdata ref for dropset number [id] to a [dropsetdata] typed
	// pointer.
	//
	// @zasm
	//   POP D2
	//   LOADDROPSETR D2
	//   SETR D2 REFDROPS
	internal dropsetdata LoadDropset(int id);

	// @deprecate Use `new randgen()` instead.
	// @zasm
	//   LOADRNG
	internal randgen LoadRNG();

	// @deprecate Use `new stack()` instead.
	// @zasm
	//   LOADSTACK
	internal stack LoadStack();

	// @zasm
	//   POP D2
	//   WEBSOCKET_LOAD D2
	internal websocket LoadWebSocket(char32[] arg1);

	// Loads a [bottledata] ref for bottledata number [id] to a [bottledata]
	// typed pointer.
	//
	// Range 1-64
	//
	// @zasm
	//   POP D2
	//   LOADBOTTLETYPE D2
	//   SETR D2 REFBOTTLETYPE
	internal bottledata LoadBottleData(int id);

	// Loads a [bottleshopdata] ref for bottleshopdata number [id] to a
	// 'bottleshopdata' typed pointer.
	//
	// Range 0-255
	//
	// @zasm
	//   POP D2
	//   LOADBSHOPDATA D2
	//   SETR D2 REFBOTTLESHOP
	internal bottleshopdata LoadBottleShopData(int id);

	// Loads the [genericdata] pointer referencing the specified generic
	// [scriptslot].
	//
	// Note that `0` is invalid.
	//
	// @zasm
	//   POP D2
	//   LOADGENERICDATA D2
	//   SETR D2 REFGENERICDATA
	internal genericdata LoadGenericData(int scriptslot);

	// Allocates a new bitmap pointer, creating a `width by height` canvas
	// (cleared to color 0).
	//
	// @deprecated Use `new bitmap(width, height)` instead!
	// @zasm
	//   POP D1
	//   POP D0
	//   SETR D2 CREATEBITMAP
	internal bitmap CreateBitmap(int width = 256, int height = 256);

	// Allocates a new bitmap pointer, but does not create a canvas on it.
	// [bitmap::Create] can later be used to create a canvas on the pointer.
	//
	// @zasm
	//   SETR D2 ALLOCATEBITMAPR
	internal bitmap AllocateBitmap();

	// Sets the custom cursor based on the given bitmap. This cursor will be
	// displayed if `Game->MouseCursor == ZCM_CUSTOM`.
	//
	// [fx], [fy] denotes the "focus point" of the cursor. For a normal cursor,
	// this is usually the top-left (the engine cursor uses `1, 1`, which is the
	// transparent pixel directly pointed to by the arrow). For a crosshair type
	// cursor, this would be the center.
	//
	// If [user_scale] is true, the user's mouse scale config will apply to the
	// custom cursor.
	//
	// If [sys_recolor] is true, some special colors will be replaced based on
	// the current theme.
	//
	// - 0xF1 = Cursor Misc
	// - 0xF2 = Cursor Outline
	// - 0xF3 = Cursor Light
	// - 0xF5 = Cursor Dark
	//
	// WARNING: The palette will NOT update on custom cursors automatically. You
	// must call this function again if the cursor should be affected by palette
	// changes.
	//
	// @zasm
	//   GAMESETCUSTOMCURSOR
	//   POPARGS D5 0.0005
	internal void SetCustomCursor(bitmap b, int fx, int fy,
								  bool sys_recolor = false,
								  bool user_scale = false);

	// Returns the number of saved portals that currently exist.
	//
	// @deprecated Use [NumSavedPortals] instead!
	// @zasm
	//   SETR D2 SAVEDPORTALCOUNT
	internal int NumSavedPortals();

	// Loads a 'Saved Portal' pointer. Use 1 <= [saved_portal_id] <=
	// [NumSavedPortals], OR [saved_portal_id] == -1 to access the Magic
	// Mirror's portal.
	//
	// @zasm
	//   POP D2
	//   LOADSAVPORTAL D2
	internal savedportal LoadSavedPortal(int saved_portal_id);

	// @zasm
	//   CREATESAVPORTAL
	internal savedportal CreateSavedPortal();

	// Returns the current item of the selected [itemtype]. This generally
	// returns the highest owned of an itemclass, with some exceptions.
	//
	// If [Game->OverrideItems[itemtype]] is set to an override value, that
	// value will be returned.
	//
	// Use the `IC_` constants for itemtype, and the `CIID_FLAG_` constants
	// bitwise-or'd for [flags].
	//
	// With `CIID_FLAG_CHECKCOST`, it will ignore items whose usecosts are
	// currently not affordable.
	//
	// With `CIID_FLAG_CHECKJINX`, it will ignore items which are currently
	// disabled by jinxes.
	//
	// With `CIID_FLAG_CHECKBUNNY`, it will ignore items which are currently
	// disabled by BunnyClk.
	//
	// Returns `-1` for 'no item'.
	//
	// @zasm
	//   CURRENTITEMID
	//   POPARGS D5 0.0002
	internal int CurrentItemID(int itemtype, int flags = 1L);

	// Loads the [subscreendata] pointer for the specified
	// active/passive/overlay subscreen.
	//
	// Use id `-1` to load the current subscreen of the type.
	//
	// @zasm
	//   POP D2
	//   LOADSUBDATARV D2 0
	internal subscreendata LoadASubData(int id);

	// Loads the [subscreendata] pointer for the specified
	// active/passive/overlay subscreen.
	//
	// Use id `-1` to load the current subscreen of the type.
	//
	// @zasm
	//   POP D2
	//   LOADSUBDATARV D2 1
	internal subscreendata LoadPSubData(int id);

	// Loads the [subscreendata] pointer for the specified
	// active/passive/overlay subscreen.
	//
	// Use id `-1` to load the current subscreen of the type.
	//
	// @zasm
	//   POP D2
	//   LOADSUBDATARV D2 2
	internal subscreendata LoadOSubData(int id);

	// @zasm
	//   SWAPSUBSCREENV 0
	//   POPARGS D5 0.0002
	internal int SwapActiveSubscreens(int arg1, int arg2);

	// @zasm
	//   SWAPSUBSCREENV 1
	//   POPARGS D5 0.0002
	internal int SwapPassiveSubscreens(int arg1, int arg2);

	// @zasm
	//   SWAPSUBSCREENV 2
	//   POPARGS D5 0.0002
	internal int SwapOverlaySubscreens(int arg1, int arg2);

	// @zasm
	//   POP D2
	//   POP D3
	//   GETMESSAGE D3 D2
	internal void GetMessage(int string, char32[] buffer);

	// Places string 'str[]' into ZQ Message 'message'.
	//
	// @zasm
	//   POP D2
	//   POP D3
	//   SETMESSAGE D3 D2
	internal void SetMessage(int message, char32[] str);

	// @zasm
	//   POP D3
	//   COMBOTILE D2 D3
	internal int ComboTile(int combo);

	// @deprecated Use [Audio->PlaySound] instead!
	// @zasm
	//   POP D2
	//   PLAYSOUNDR D2
	internal void PlaySound(int soundid);

	// @deprecated Use [Audio->PlayMIDI] instead!
	// @zasm
	//   POP D2
	//   PLAYMIDIR D2
	internal void PlayMIDI(int MIDIid);

	// @deprecated Use [Audio->PlayEnhancedMusic] instead!
	// @zasm
	//   POP D2
	//   POP D3
	//   PLAYENHMUSIC D3 D2
	internal bool PlayEnhancedMusic(char32[] filename, int track);

	// @deprecated Use [Audio->PlayEnhancedMusic] instead!
	// @zasm
	//   POP D2
	//   POP D3
	//   PLAYENHMUSICEX D3 D2
	internal bool PlayOgg(int arg1, int arg2);

	// @deprecated
	// @zasm
	//   GETENHMUSICPOS D2
	internal int GetOggPos();

	// @deprecated
	// @zasm
	//   POP D2
	//   SETENHMUSICPOS D2
	internal void SetOggPos(int arg1);

	// @deprecated
	// @zasm
	//   POP D2
	//   SETENHMUSICSPEED D2
	internal void SetOggSpeed(int arg1);

	// @deprecated Use 'mapdata->' vars instead!
	// @zasm
	//   POP D0
	//   POP D1
	//   POP D2
	//   GETSCREENFLAGS D2
	internal int GetScreenFlags(int map, int screen, int flagset);

	// @deprecated Use 'mapdata->' vars instead!
	// @zasm
	//   POP D1
	//   POP D0
	//   POP D2
	//   SUBV D2 1
	//   MULTV D2 136
	//   ADDR D0 D2
	//   SETR D2 SCREENSTATEDD
	//   COMPAREV D2 0
	//   SETCMP D2 !=
	internal bool GetScreenState(int map, int screen, int flag);

	// @deprecated Use 'mapdata->' vars instead!
	// @zasm
	//   POP D6
	//   POP D1
	//   POP D0
	//   POP D2
	//   SUBV D2 1
	//   MULTV D2 136
	//   ADDR D0 D2
	//   COMPAREV D6 0
	//   SETCMP SCREENSTATEDD !=
	internal void SetScreenState(int map, int screen, int flag, bool value);

	// @deprecated Use [mapdata::ComboD]' instead!
	// @zasm
	//   POP D0
	//   POP D2
	//   POP D1
	//   SETR D2 COMBODDM
	internal int GetComboData(int map, int screen, int position);

	// @deprecated Use [mapdata::ComboD]'  instead!
	// @zasm
	//   POP D3
	//   POP D0
	//   POP D2
	//   POP D1
	//   SETR COMBODDM D3
	internal void SetComboData(int map, int screen, int position, int value);

	// @deprecated Use [mapdata::ComboC]'  instead!
	// @zasm
	//   POP D0
	//   POP D2
	//   POP D1
	//   SETR D2 COMBOCDM
	internal int GetComboCSet(int map, int screen, int position);

	// @deprecated Use [mapdata::ComboC]'  instead!
	// @zasm
	//   POP D3
	//   POP D0
	//   POP D2
	//   POP D1
	//   SETR COMBOCDM D3
	internal void SetComboCSet(int map, int screen, int position, int value);

	// @deprecated Use [mapdata::ComboF]'  instead!
	// @zasm
	//   POP D0
	//   POP D2
	//   POP D1
	//   SETR D2 COMBOFDM
	internal int GetComboFlag(int map, int screen, int position);

	// @deprecated Use [mapdata::ComboF]'  instead!
	// @zasm
	//   POP D3
	//   POP D0
	//   POP D2
	//   POP D1
	//   SETR COMBOFDM D3
	internal void SetComboFlag(int map, int screen, int position, int value);

	// @deprecated Use [mapdata::ComboT]'  instead!
	// @zasm
	//   POP D0
	//   POP D2
	//   POP D1
	//   SETR D2 COMBOTDM
	internal int GetComboType(int map, int screen, int position);

	// @deprecated Use [mapdata::ComboT]'  instead!
	// @zasm
	//   POP D3
	//   POP D0
	//   POP D2
	//   POP D1
	//   SETR COMBOTDM D3
	internal void SetComboType(int map, int screen, int position, int value);

	// @deprecated Use [mapdata::ComboI]'  instead!
	// @zasm
	//   POP D0
	//   POP D2
	//   POP D1
	//   SETR D2 COMBOIDM
	internal int GetComboInherentFlag(int map, int screen, int position);

	// @deprecated Use [mapdata::ComboI]'  instead!
	// @zasm
	//   POP D3
	//   POP D0
	//   POP D2
	//   POP D1
	//   SETR COMBOIDM D3
	internal void SetComboInherentFlag(int map, int screen, int position,
									   int value);

	// @deprecated Use [mapdata::ComboS]'  instead!
	// @zasm
	//   POP D0
	//   POP D2
	//   POP D1
	//   SETR D2 COMBOSDM
	internal int GetComboSolid(int map, int screen, int position);

	// @deprecated Use [mapdata::ComboS]'  instead!
	// @zasm
	//   POP D3
	//   POP D0
	//   POP D2
	//   POP D1
	//   SETR COMBOSDM D3
	internal void SetComboSolid(int map, int screen, int position, int value);

	// @deprecated
	// @zasm
	//   POP D2
	//   GETUNTYPEDSCRIPT D2
	internal int GetUntypedScript(int arg1);

	// @deprecated
	// @zasm
	//   POP D2
	//   GETSUBSCREENSCRIPT D2
	internal int GetSubscreenScript(int arg1);

	// @deprecated Use [dmapdata::GetMusic] instead!
	// @zasm
	//   POP D2
	//   POP D3
	//   GETMUSICFILE D3 D2
	internal void GetDMapMusicFilename(int dmap, char32[] buf);

	// @deprecated Use [dmapdata::MusicTrack] instead!
	// @zasm
	//   POP D2
	//   GETMUSICTRACK D2
	internal int GetDMapMusicTrack(int dmap);

	// @deprecated Use [dmapdata::SetMusic] instead!
	// @zasm
	//   SETDMAPENHMUSIC
	//   POPARGS D5 0.0003
	internal void SetDMapEnhancedMusic(int dmap, char32[] filename, int track);

	// @deprecated Use [dmapdata::GetName] instead!
	// @zasm
	//   POP D2
	//   POP D3
	//   GETDMAPNAME D3 D2
	internal void GetDMapName(int DMap, char32[] buffer);

	// @deprecated Use [dmapdata::SetName] instead!
	// @zasm
	//   POP D2
	//   POP D3
	//   SETDMAPNAME D3 D2
	internal void SetDMapName(int DMap, char32[] buffer);

	// @deprecated Use [dmapdata::GetTitle] instead!
	// @zasm
	//   POP D2
	//   POP D3
	//   GETDMAPTITLE D3 D2
	internal void GetDMapTitle(int DMap, char32[] buffer);

	// @deprecated Use [dmapdata::SetTitle] instead!
	// @zasm
	//   POP D2
	//   POP D3
	//   SETDMAPTITLE D3 D2
	internal void SetDMapTitle(int DMap, char32[] buffer);

	// @deprecated Use [dmapdata::GetIntro] instead!
	// @zasm
	//   POP D2
	//   POP D3
	//   GETDMAPINTRO D3 D2
	internal void GetDMapIntro(int DMap, char32[] buffer);

	// @deprecated Use [dmapdata::SetIntro] instead!
	// @zasm
	//   POP D2
	//   POP D3
	//   SETDMAPINTRO D3 D2
	internal void SetDMapIntro(int DMap, char32[] buffer);
}

internal const Game Game;
