#include "std_zh/std_constants.zh"
#include "std_zh/script_runners.zh"

//Returns if Link is above an npc.
bool Above(npc n){ return Link->Y < n->Y; }

//Returns if Link is above, below, left of, or right of an ffc.
bool Above(ffc n){ return Link->Y < n->Y; }

//Returns if Link is above, below, left of, or right of an eweapon.
bool Above(eweapon n){ return Link->Y < n->Y; }

//Returns if Link is above, below, left of, or right of an lweapon.
bool Above(lweapon n){ return Link->Y < n->Y; }

//Various methods for shooting at Link and at random
void AimEWeapon(eweapon e, int aimtype)
{
	int angle = RadianAngle(e->X, e->Y, Link->X, Link->Y);
	switch(aimtype)
	{
		case AT_4DIR:
		{
			e->Dir = RadianAngleDir4(angle);
			break;
		}
		case AT_8DIR:
		{
			e->Dir = RadianAngleDir8(angle);
			break;
		}
		case AT_ANGULAR:
		{
			e->Angular = true;
			e->Angle = angle;
			e->Dir = RadianAngleDir8(angle);
			break;
		}
		case AT_RAND4DIR:
		{
			e->Dir = Rand(4);
			break;
		}
		case AT_RAND8DIR:
		{
			e->Dir = Rand(8);
		}
		case AT_RANDANGULAR:
		{
			e->Angular = true;
			e->Angle = Randf(PI2);
			e->Dir = RadianAngleDir8(e->Angle);
			break;
		}
	}
}

//Aiming at enemies and at random
void AimLWeapon(lweapon l, npc n, int aimtype)
{
	int angle = RadianAngle(l->X, l->Y, n->X, n->Y);
	switch(aimtype)
	{
		case AT_4DIR:
		{
			l->Dir = RadianAngleDir4(angle);
			break;
		}
		case AT_8DIR:
		{
			l->Dir = RadianAngleDir8(angle);
			break;
		}
		case AT_ANGULAR:
		{
			l->Angular = true;
			l->Angle = angle;
			l->Dir = RadianAngleDir8(angle);
			break;
		}
		default:
		{
			AimLWeapon(l, aimtype); break;
		}
	}
}

void AimLWeapon(lweapon l, int aimtype)
{
	switch(aimtype)
	{
		case AT_RAND4DIR:
		{
			l->Dir = Rand(4);
			break;
		}
		case AT_RAND8DIR:
		{
			l->Dir = Rand(8);
			break;
		}
		case AT_RANDANGULAR:
		{
			l->Angular = true;
			l->Angle = Randf(PI2);
			l->Dir = RadianAngleDir8(l->Angle);
			break;
		}
		default:
		{
			printf("Invalid aimtype %d provided to AimLWeapon(l,aimtype) \n",aimtype); break;
		}
	}
}

//Returns the direction of the vector from point 1 to point 2, in degrees from -180 to 180. (0 = right)
float Angle(int x1, int y1, int x2, int y2)
{
	return RadtoDeg(ArcTan(x2-x1, y2-y1));
}

// Converts a counterclockwise degree angle (from -180 to 180) into one of the four
// standard directions (DIR_UP, DIR_DOWN, DIR_LEFT, DIR_RIGHT) used by ZC.
int AngleDir4(float angle)
{
	if (angle <= 135 && angle > 45)
		return DIR_DOWN;
	else if (angle <= 45 && angle > -45)
		return DIR_RIGHT;
	else if (angle <= -45 && angle > -135)
		return DIR_UP;
	else
		return DIR_LEFT;
}

// Converts a counterclockwise degree angle (from -180 to 180) into one of the eight
// standard directions (DIR_UP etc.) used by ZC.
int AngleDir8(float angle)
{
	if (angle <= 157.5 && angle > 112.5)
		return DIR_LEFTDOWN;
	else if (angle <= 112.5 && angle > 67.5)
		return DIR_DOWN;
	else if (angle <= 67.5 && angle > 22.5)
		return DIR_RIGHTDOWN;
	else if (angle <= 22.5 && angle > -22.5)
		return DIR_RIGHT;
	else if (angle <= -22.5 && angle > -67.5)
		return DIR_RIGHTUP;
	else if (angle <= -67.5 && angle > -112.5)
		return DIR_UP;
	else if (angle <= -112.5 && angle > -157.5)
		return DIR_LEFTUP;
	else
		return DIR_LEFT;
}


//Returns the correct offset to be at the front of a sprite facing in the direction 'dir'
int AtFrontX(int dir)
{
	dir=DirNormal(dir);
	int x = 0;
	if(dir == DIR_UP || dir == DIR_DOWN) x = 8;
	else if(dir == DIR_RIGHT) x = 16;
	return x;
}

int AtFrontY(int dir)
{
	dir=DirNormal(dir);
	int y = 0;
	if(dir == DIR_DOWN) y = 16;
	else if(dir == DIR_LEFT || dir == DIR_RIGHT) y = 8;
	return y;
}

//B

//Returns if Link is below an npc.
bool Below(npc n){ return Link->Y > n->Y; }

//Returns if Link is above, below, left of, or right of an ffc.
bool Below(ffc n){ return Link->Y > n->Y; }

//Returns if Link is above, below, left of, or right of an eweapon.
bool Below(eweapon n){ return Link->Y > n->Y; }

//Returns if Link is above, below, left of, or right of an lweapon.
bool Below(lweapon n){ return Link->Y > n->Y; }

//C

//This should allow any scripted object to easily mimic Link styled LOZ solidity collision
//checking, be it Link, FFCs, or enemies.
//Note - You should use full_tile=true if you don't want the upper eight pixels to overlap
//solid combos as per LOZ1 behavior.
bool CanWalk(int x, int y, int dir, int step, bool full_tile)
{
	int c=8;
	int xx = x+15;
	int yy = y+15;
	if(full_tile) c=0;
	switch(DirNormal(dir))
	{
		case DIR_UP: return !(y-step<0||Screen->isSolid(x,y+c-step)||Screen->isSolid(x+8,y+c-step)||Screen->isSolid(xx,y+c-step));
		case DIR_DOWN: return !(yy+step>=176||Screen->isSolid(x,yy+step)||Screen->isSolid(x+8,yy+step)||Screen->isSolid(xx,yy+step));
		case DIR_LEFT: return !(x-step<0||Screen->isSolid(x-step,y+c)||Screen->isSolid(x-step,y+c+7)||Screen->isSolid(x-step,yy));
		case DIR_RIGHT: return !(xx+step>=256||Screen->isSolid(xx+step,y+c)||Screen->isSolid(xx+step,y+c+7)||Screen->isSolid(xx+step,yy));
		default: { printf("Invalid direction %d passed to CanWalk(x,y,dir,step,bool) \n",dir); return false; } //invalid direction
	}
}


// Get the X and Y coordinates at the center of a sprite
int CenterLinkX() { return Link->X+8; }
int CenterLinkY() { return Link->Y+8; }
int CenterX(ffc anFFC) { return anFFC->X+8*anFFC->TileWidth; }
int CenterX(npc anNPC) { return anNPC->X+8*anNPC->TileWidth; }
int CenterX(eweapon anEWeapon) { return anEWeapon->X+8*anEWeapon->TileWidth; }
int CenterX(lweapon anLWeapon) { return anLWeapon->X+8*anLWeapon->TileWidth; }
int CenterX(item it) { return it->X+8*it->TileWidth; }
int CenterY(ffc anFFC) { return anFFC->Y+8*anFFC->TileHeight; }
int CenterY(npc anNPC) { return anNPC->Y+8*anNPC->TileHeight; }
int CenterY(eweapon anEWeapon) { return anEWeapon->Y+8*anEWeapon->TileHeight; }
int CenterY(lweapon anLWeapon) { return anLWeapon->Y+8*anLWeapon->TileHeight; }
int CenterY(item it) { return it->Y+8*it->TileHeight; }

//Returns true if the two circles c1 and c2 overlap.
bool CircleCollision(int c1x, int c1y, int radius1, int c2x, int c2y, int radius2)
{
	return (Distance(c1x,c1y,c2x,c2y) <= (radius1+radius2));
}

//Clamps x to the range of low, high.
int Clamp(int x, int low, int high)
{
	if(x<low) x=low;
	else if(x>high) x=high;
	return x;
}

//Clears a block of tiles defined by diagonal corners 'reffirst' and 'reflast'
void ClearTileBlock(int reffirst, int reflast)
{
	if(reflast < reffirst){
		int swap = reffirst;
		reffirst = reflast;
		reflast = swap;
	}
	int w = reflast%20-reffirst%20;
	if(w < 0){
		reffirst -= w;
		reflast += w;
		w = -w;
	}
	for(int i=0;i<=reflast-reffirst;++i) if(i%20 <= w) ClearTile(reffirst+i);
}

//Clears a row of tiles of length 'length' starting from tile 'ref'
void ClearTileRow(int ref, int length)
{
	for(int i=0;i<length;++i) ClearTile(ref+i);
}

//Returns true if there is a collision between the hitboxes of an lweapon and an eweapon.
bool Collision(lweapon a, eweapon b)
{
	int ax = a->X + a->HitXOffset;
	int bx = b->X + b->HitXOffset;
	int ay = a->Y + a->HitYOffset;
	int by = b->Y + b->HitYOffset;
	return RectCollision(ax, ay, ax+a->HitWidth-1, ay+a->HitHeight-1, bx, by, bx+b->HitWidth-1, by+b->HitHeight-1) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//A collision between an lweapon and an lweapon.
bool Collision(lweapon a, lweapon b)
{
	int ax = a->X + a->HitXOffset;
	int bx = b->X + b->HitXOffset;
	int ay = a->Y + a->HitYOffset;
	int by = b->Y + b->HitYOffset;
	return RectCollision(ax, ay, ax+a->HitWidth-1, ay+a->HitHeight-1, bx, by, bx+b->HitWidth-1, by+b->HitHeight-1) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//A collision between an eweapon and an eweapon.
bool Collision(eweapon a, eweapon b)
{
	int ax = a->X + a->HitXOffset;
	int bx = b->X + b->HitXOffset;
	int ay = a->Y + a->HitYOffset;
	int by = b->Y + b->HitYOffset;
	return RectCollision(ax, ay, ax+a->HitWidth-1, ay+a->HitHeight-1, bx, by, bx+b->HitWidth-1, by+b->HitHeight-1) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//A collision between an lweapon and an npc.
bool Collision(lweapon a, npc b)
{
	int ax = a->X + a->HitXOffset;
	int bx = b->X + b->HitXOffset;
	int ay = a->Y + a->HitYOffset;
	int by = b->Y + b->HitYOffset;
	return RectCollision(ax, ay, ax+a->HitWidth-1, ay+a->HitHeight-1, bx, by, bx+b->HitWidth-1, by+b->HitHeight-1) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//A collision between an eweapon and an npc.
bool Collision(eweapon a, npc b)
{
	int ax = a->X + a->HitXOffset;
	int bx = b->X + b->HitXOffset;
	int ay = a->Y + a->HitYOffset;
	int by = b->Y + b->HitYOffset;
	return RectCollision(ax, ay, ax+a->HitWidth-1, ay+a->HitHeight-1, bx, by, bx+b->HitWidth-1, by+b->HitHeight-1) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//A collision between an npc and an npc.
bool Collision(npc a, npc b)
{
	int ax = a->X + a->HitXOffset;
	int bx = b->X + b->HitXOffset;
	int ay = a->Y + a->HitYOffset;
	int by = b->Y + b->HitYOffset;
	return RectCollision(ax, ay, ax+a->HitWidth-1, ay+a->HitHeight-1, bx, by, bx+b->HitWidth-1, by+b->HitHeight-1) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//A collision between an item and an lweapon.
bool Collision(item a, lweapon b)
{
	int ax = a->X + a->HitXOffset;
	int bx = b->X + b->HitXOffset;
	int ay = a->Y + a->HitYOffset;
	int by = b->Y + b->HitYOffset;
	return RectCollision(ax, ay, ax+a->HitWidth-1, ay+a->HitHeight-1, bx, by, bx+b->HitWidth-1, by+b->HitHeight-1) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//A collision between an item and an eweapon.
bool Collision(item a, eweapon b)
{
	int ax = a->X + a->HitXOffset;
	int bx = b->X + b->HitXOffset;
	int ay = a->Y + a->HitYOffset;
	int by = b->Y + b->HitYOffset;
	return RectCollision(ax, ay, ax+a->HitWidth-1, ay+a->HitHeight-1, bx, by, bx+b->HitWidth-1, by+b->HitHeight-1) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//A collision between an item and an npc.
bool Collision(item a, npc b)
{
	int ax = a->X + a->HitXOffset;
	int bx = b->X + b->HitXOffset;
	int ay = a->Y + a->HitYOffset;
	int by = b->Y + b->HitYOffset;
	return RectCollision(ax, ay, ax+a->HitWidth-1, ay+a->HitHeight-1, bx, by, bx+b->HitWidth-1, by+b->HitHeight-1) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//A collision between an item and an item.
bool Collision(item a, item b)
{
	int ax = a->X + a->HitXOffset;
	int bx = b->X + b->HitXOffset;
	int ay = a->Y + a->HitYOffset;
	int by = b->Y + b->HitYOffset;
	return RectCollision(ax, ay, ax+a->HitWidth-1, ay+a->HitHeight-1, bx, by, bx+b->HitWidth-1, by+b->HitHeight-1) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//A collision between an ffc and an lweapon. Uses TileWidth and TileHeight for the FFC's bounding box. Ignores the Z axis.
bool Collision(ffc f, lweapon b)
{
	int bx = b->X + b->HitXOffset;
	int by = b->Y + b->HitYOffset;
	return RectCollision(f->X, f->Y, f->X+(f->TileWidth*16)-1, f->Y+(f->TileHeight*16)-1, bx, by, bx+b->HitWidth-1, by+b->HitHeight-1);
}

//A collision between an ffc and an eweapon. Uses TileWidth and TileHeight for the FFC's bounding box. Ignores the Z axis.
bool Collision(ffc f, eweapon b)
{
	int bx = b->X + b->HitXOffset;
	int by = b->Y + b->HitYOffset;
	return RectCollision(f->X, f->Y, f->X+(f->TileWidth*16)-1, f->Y+(f->TileHeight*16)-1, bx, by, bx+b->HitWidth-1, by+b->HitHeight-1);
}

//A collision between an ffc and an npc. Uses TileWidth and TileHeight for the FFC's bounding box. Ignores the Z axis.
bool Collision(ffc f, npc b)
{
	int bx = b->X + b->HitXOffset;
	int by = b->Y + b->HitYOffset;
	return RectCollision(f->X, f->Y, f->X+(f->TileWidth*16)-1, f->Y+(f->TileHeight*16)-1, bx, by, bx+b->HitWidth-1, by+b->HitHeight-1);
}

//A collision between an ffc and an item. Uses TileWidth and TileHeight for the FFC's bounding box. Ignores the Z axis.
bool Collision(ffc f, item b)
{
	int bx = b->X + b->HitXOffset;
	int by = b->Y + b->HitYOffset;
	return RectCollision(f->X, f->Y, f->X+(f->TileWidth*16)-1, f->Y+(f->TileHeight*16)-1, bx, by, bx+b->HitWidth-1, by+b->HitHeight-1);
}

//A collision between an ffc and an ffc. Uses TileWidth and TileHeight for the FFCs' bounding boxes.
bool Collision(ffc f, ffc f2)
{
	return RectCollision(f->X, f->Y, f->X+(f->TileWidth*16)-1, f->Y+(f->TileHeight*16)-1, f2->X, f2->Y, f2->X+f2->TileWidth*16-1, f2->Y+f2->TileHeight*16-1);
}

//A circular collision between an ffc and an ffc. Uses TileWidth and TileHeight to find the centre of the FFCs.
bool Collision(ffc f, int radius1, ffc f2, int radius2)
{
	return CircleCollision(f->X+f->TileWidth/2, f->Y+f->TileHeight/2, radius1,f2->X+f2->TileWidth/2, f2->Y+f2->TileHeight/2, radius2);
}

// So that you don't have to remember the ordering of the args
bool Collision(eweapon a, lweapon b)
{
	return Collision(b, a);
}

bool Collision(npc a, lweapon b)
{
	return Collision(b, a);
}

bool Collision(npc a, eweapon b)
{
	return Collision(b, a);
}

bool Collision(lweapon a, item b)
{
	return Collision(b, a);
}

bool Collision(eweapon a, item b)
{
	return Collision(b, a);
}

bool Collision(npc a, item b)
{
	return Collision(b, a);
}

bool Collision(lweapon a, ffc b)
{
	return Collision(b, a);
}

bool Collision(eweapon a, ffc b)
{
	return Collision(b, a);
}

bool Collision(npc a, ffc b)
{
	return Collision(b, a);
}

bool Collision(item a, ffc b)
{
	return Collision(b, a);
}

// Returns true if there is a collision between Link's hitbox and the eweapon's.
// This only checks hitboxes.
bool Collision(eweapon b)
{
	int ax = Link->X + Link->HitXOffset;
	int bx = b->X + b->HitXOffset;
	int ay = Link->Y + Link->HitYOffset;
	int by = b->Y + b->HitYOffset;
	return RectCollision(ax, ay, ax+Link->HitWidth-1, ay+Link->HitHeight-1, bx, by, bx+b->HitWidth-1, by+b->HitHeight-1) && (Link->Z + Link->HitZHeight >= b->Z) && (Link->Z <= b->Z + b->HitZHeight);
}

// Returns true if there is a collision between Link's hitbox and the lweapon's.
// This only checks hitboxes.
bool Collision(lweapon b)
{
	int ax = Link->X + Link->HitXOffset;
	int bx = b->X + b->HitXOffset;
	int ay = Link->Y + Link->HitYOffset;
	int by = b->Y + b->HitYOffset;
	return RectCollision(ax, ay, ax+Link->HitWidth-1, ay+Link->HitHeight-1, bx, by, bx+b->HitWidth-1, by+b->HitHeight-1) && (Link->Z + Link->HitZHeight >= b->Z) && (Link->Z <= b->Z + b->HitZHeight);
}

// Returns true if there is a collision between Link's hitbox and the item's.
// This only checks hitboxes.
bool Collision(item b)
{
	int ax = Link->X + Link->HitXOffset;
	int bx = b->X + b->HitXOffset;
	int ay = Link->Y + Link->HitYOffset;
	int by = b->Y + b->HitYOffset;
	return RectCollision(ax, ay, ax+Link->HitWidth-1, ay+Link->HitHeight-1, bx, by, bx+b->HitWidth-1, by+b->HitHeight-1) && (Link->Z + Link->HitZHeight >= b->Z) && (Link->Z <= b->Z + b->HitZHeight);
}

// Returns true if there is a collision between Link's hitbox and the npc's.
// This only checks hitboxes.  Uses TileWidth and TileHeight to find the centre of the FFCs.
bool Collision(npc b)
{
	int ax = Link->X + Link->HitXOffset;
	int bx = b->X + b->HitXOffset;
	int ay = Link->Y + Link->HitYOffset;
	int by = b->Y + b->HitYOffset;
	return RectCollision(ax, ay, ax+Link->HitWidth-1, ay+Link->HitHeight-1, bx, by, bx+b->HitWidth-1, by+b->HitHeight-1) && (Link->Z + Link->HitZHeight >= b->Z) && (Link->Z <= b->Z + b->HitZHeight);
}

// Returns true if there is a collision between Link's hitbox and the FFC's.
// This only checks hitboxes.
bool Collision(ffc f)
{
	int ax = Link->X + Link->HitXOffset;
	int ay = Link->Y + Link->HitYOffset;
	return RectCollision(f->X, f->Y, f->X+(f->TileWidth*16)-1, f->Y+(f->TileHeight*16)-1, ax, ay, ax+Link->HitWidth-1, ay+Link->HitHeight-1);
}

//Only legal from combodata scripts as this->Collision
bool Collision(combodata f)
{
	int ax = Link->X + Link->HitXOffset;
	int ay = Link->Y + Link->HitYOffset;
	return RectCollision(f->X, f->Y, f->X+15, f->Y+15, ax, ay, ax+Link->HitWidth-1, ay+Link->HitHeight-1);
}

//Finds the location of a combo, given its (x,y) coordinates on the screen
int ComboAt(int x, int y)
{
	if (Region->ID)
	{
		x = VBound(x, Region->Width - 1, 0);
		y = VBound(y, Region->Height - 1, 0);
		// Floor'd because in ZScript, ints aren't ints?!
		int scr_dx = Floor(x / 256);
		int scr_dy = Floor(y / 176);
		int offset_pos = (scr_dx + scr_dy * Region->ScreenWidth)*176;
		int pos = ((y%176) & 240)+((x%256)>>4);
		return offset_pos + pos;
	}
	else
	{
		// Fast path.
		x = VBound(x,255,0);
		y = VBound(y,175,0);
		return (y & 240)+(x>>4);
	}
}

//Returns true if the combo at '(x, y)' has either an inherent or place flag of type 'flag'
bool ComboFI(int x, int y, int flag)
{
	int loc = ComboAt(x,y);
	return Screen->ComboF[loc] == flag || Screen->ComboI[loc] == flag;
}

//Returns true if the combo at 'loc' has either an inherent or place flag of type 'flag'
bool ComboFI(int loc, int flag)
{
	return Screen->ComboF[loc] == flag || Screen->ComboI[loc] == flag;
}

// Note: all of the `Region->ID` checks in these various functions are minor performance improvements. The functions
// likely work even without that.

//Return the coordinates of a combo on the screen
int ComboX(int rpos)
{
	if (Region->ID)
	{
		int scr_index = Floor(rpos / 176);
		int scr_width = Region->ScreenWidth;
		int scr_dx = scr_index % scr_width;
		int scr_dy = Floor(scr_index / scr_width);
		int pos = rpos % 176;
		return scr_dx*16*16 + pos%16*16;
	}
	else
	{
		return rpos%16*16;
	}
}
int ComboY(int rpos)
{
	if (Region->ID)
	{
		int scr_index = Floor(rpos / 176);
		int scr_width = Region->ScreenWidth;
		int scr_dx = scr_index % scr_width;
		int scr_dy = Floor(scr_index / scr_width);
		int pos = rpos % 176;
		return scr_dy*11*16 + (pos&0xF0);
	}
	else
	{
		return rpos&0xF0;
	}
}

// Given a screen index, returns the screen offset in the X direction in the current region.
// Example: If the region origin is screen 5, `RegionRelativeScreenX(8) == 3`
int RegionRelativeScreenX(int scr)
{
	if (Region->ID)
	{
		int origin_screen_index = Region->OriginScreenIndex * 10000;
		return scr%16 - origin_screen_index%16;
	}
	else
	{
		return 0;
	}
}

// Given a screen index, returns the screen offset in the Y direction in the current region.
int RegionRelativeScreenY(int scr)
{
	if (Region->ID)
	{
		int origin_screen_index = Region->OriginScreenIndex * 10000;
		return Floor(scr/16) - Floor(origin_screen_index/16);
	}
	else
	{
		return 0;
	}
}

// Given a screen index, returns the world offset in the x direction for the current region.
int RegionWorldOffsetX(int scr)
{
	if (Region->ID)
	{
		return RegionRelativeScreenX(scr) * 256;
	}
	else
	{
		return 0;
	}
}

// Given a screen index, returns the world offset in the y direction for the current region.
int RegionWorldOffsetY(int scr)
{
	if (Region->ID)
	{
		return RegionRelativeScreenY(scr) * 176;
	}
	else
	{
		return 0;
	}
}

// Returns true if the given screen index is inside the current region.
// When not in a region, only returns true if scr is equal to Game->CurScreen.
bool RegionIncludesScreen(int scr)
{
	if (Region->ID)
	{
		int dx = RegionRelativeScreenX(scr);
		if (dx < 0 || dx > Region->ScreenWidth) return false;

		int dy = RegionRelativeScreenY(scr);
		if (dy < 0 || dy > Region->ScreenHeight) return false;

		return true;
	}

	return scr == Game->CurScreen;
}

// Returns the FFC ID of the screen `scr`, which must be within the current Region.
// `index` is the screen-specific index of the FFC (what you would see in the editor on that screen).
int RegionGetFFCId(int scr, int index)
{
	int offset = 128 * (RegionRelativeScreenX(scr) + RegionRelativeScreenY(scr)*Region->ScreenWidth);
	return offset + index;
}

// Returns a if cond is true, else b. Overloaded.
// @deprecated Consider using a ternary expression instead: `cond ? a : b`
T Cond<T>(bool cond, T a, T b)
{
	return cond ? a : b;
}

bool ConsumeKey(int level = -1)
{
	if(level < 0) level = Game->CurLevel;
	if(Game->LKeys[level]>0)
	{
		--Game->LKeys[level];
		return true;
	}
	else if(Game->Counter[CR_KEYS]>0)
	{
		Game->Counter[CR_KEYS]--;
		return true;
	}
	else
		return false;
}

//Copies a block of tiles defined by diagonal corners 'sourcefirst' and 'sourcelast'
//onto the block starting with top left tile 'destfirst'
void CopyTileBlock(int sourcefirst, int sourcelast, int destfirst)
{
	if(sourcelast < sourcefirst){
		int swap = sourcefirst;
		sourcefirst = sourcelast;
		sourcelast = swap;
	}
	int w = sourcelast%20-sourcefirst%20;
	if(w < 0){
		sourcefirst -= w;
		sourcelast += w;
		w = -w;
	}
	for(int i=0;i<=sourcelast-sourcefirst;++i) if(i%20 <= w) CopyTile(sourcefirst+i,destfirst+i);
}

//Copies a row of tiles of length 'length' from 'source' onto 'dest'
void CopyTileRow(int source, int dest, int length)
{
	for(int i=0;i<length;++i) CopyTile(source+i,dest+i);
}

//Add to a counter without rollover.
void CounterAdd(int counter, int amount)
{
	if ( amount + Game->Counter[counter] > COUNTER_MAX ) Game->Counter[counter] = COUNTER_MAX;
	else Game->Counter[counter] += amount;
}

//Reduce a counter without rollvoer.
void CounterReduce(int counter, int amount)
{
	if ( Game->Counter[counter] - amount < COUNTER_MIN ) Game->Counter[counter] = COUNTER_MIN;
	else Game->Counter[counter] -= amount;
}

//Create an EWeapon and set its X and Y position in one command
eweapon CreateEWeaponAt(int id, int x, int y)
{
	eweapon ew = Screen->CreateEWeapon(id);
	if(ew->isValid())
	{
		ew->X = x;
		ew->Y = y;
	}
	return ew;
}

//Create an Item and set its X and Y position in one command
item CreateItemAt(int id, int x, int y)
{
	item it = Screen->CreateItem(id);
	if(it->isValid())
	{
		it->X = x;
		it->Y = y;
	}
	return it;
}

//Create an LWeapon and set its X and Y position in one command
lweapon CreateLWeaponAt(int id, int x, int y)
{
	lweapon lw = Screen->CreateLWeapon(id);
	if(lw->isValid())
	{
		lw->X = x;
		lw->Y = y;
	}
	return lw;
}

//Create an NPC and set its X and Y position in one command
npc CreateNPCAt(int id, int x, int y)
{
	npc nme = Screen->CreateNPC(id);
	if(nme->isValid())
	{
		nme->X = x;
		nme->Y = y;
	}
	return nme;
}

//Creates a timeout item (like a rupee or heart)
item CreateTimeoutItem(int id, int x, int y)
{
	item Spawn = Screen->CreateItem(id);
	SetItemPickup(Spawn, IP_TIMEOUT, true);
	Spawn->HitWidth = 16; Spawn->HitHeight = 16;
	Spawn->X = x; Spawn->Y = y;
	return Spawn;
}

// Returns the cross product of two vectors.
float CrossProduct( float x1, float y1, float x2, float y2 )
{
	return (x1 * y2 - y1 * x2);
}

//D

//Add to a drain counter without rollover.
void DCounterAdd(int counter, int amount)
{
	if ( amount + Game->DCounter[counter] > DCOUNTER_MAX ) Game->DCounter[counter] = DCOUNTER_MAX;
	else Game->MCounter[counter] += amount;
}

//Reduce a drain counter without rollvoer.
void DCounterReduce(int counter, int amount)
{
	if ( Game->DCounter[counter] - amount < DCOUNTER_MIN ) Game->DCounter[counter] = DCOUNTER_MIN;
	else Game->DCounter[counter] -= amount;
}

//Returns if Link has defeated the dungeon boss for a given level.
int DefeatedLevelBoss(int level)
{
        return ((Game->LItems[level]&LI_BOSS) ? 1 : 0 );
}

//Normalizes a dir between 8 and 15
int DirNormal(int dir)
{
	switch(dir)
	{
		case DIR2_UP: return DIR_UP;
		case DIR2_RIGHTUP: return DIR_RIGHTUP;
		case DIR2_RIGHT: return DIR_RIGHT;
		case DIR2_RIGHTDOWN: return DIR_RIGHTDOWN;
		case DIR2_DOWN: return DIR_DOWN;
		case DIR2_LEFTDOWN: return DIR_LEFTDOWN;
		case DIR2_LEFT: return DIR_LEFT;
		case DIR2_LEFTUP: return DIR_LEFTUP;
		default: return dir;
	}
}
//The reverse
int DirAbnormal(int dir)
{
	switch(dir)
	{
		case DIR_UP: return DIR2_UP;
		case DIR_RIGHTUP: return DIR2_RIGHTUP;
		case DIR_RIGHT: return DIR2_RIGHT;
		case DIR_RIGHTDOWN: return DIR2_RIGHTDOWN;
		case DIR_DOWN: return DIR2_DOWN;
		case DIR_LEFTDOWN: return DIR2_LEFTDOWN;
		case DIR_LEFT: return DIR2_LEFT;
		case DIR_LEFTUP: return DIR2_LEFTUP;
		default: return dir;
	}
}

//Returns angle of the given direction.
int Dir4Angle(int dir)
{
	//dir &=7;
	switch(DirNormal(dir))
	{
		case DIR_UP: return DEG_DIR_UP;
		case DIR_DOWN: return DEG_DIR_DOWN;
		case DIR_LEFT: return DEG_DIR_LEFT;
		case DIR_RIGHT: return DEG_DIR_RIGHT;
		default: { printf("Invalid direction %d passed to Dir4Angle \n",dir); return -1; }
	}
}

//Returns angle of the given direction.
int DirAngle(int dir)
{
	//dir &=7; //I do not recall why this is here. Removing it as it seems extraneous. -Z
	switch(DirNormal(dir))
	{
		case DIR_UP: return DEG_DIR_UP;
		case DIR_DOWN: return DEG_DIR_DOWN;
		case DIR_LEFT: return DEG_DIR_LEFT;
		case DIR_RIGHT: return DEG_DIR_RIGHT;
		case DIR_LEFTUP: return DEG_DIR_LEFTUP;
		case DIR_RIGHTUP: return DEG_DIR_RIGHTUP;
		case DIR_LEFTDOWN: return DEG_DIR_LEFTDOWN;
		case DIR_RIGHTDOWN: return DEG_DIR_RIGHTDOWN;
		default: { printf("Invalid direction %d passed to DirAngle \n",dir); return -1; }
	}
}

//Same as Dir4Angle, but return value is measured in radians.
int Dir4Rad(int dir)
{
	switch(DirNormal(dir))
	{
		case DIR_UP: return RAD_DIR_UP;
		case DIR_DOWN: return RAD_DIR_DOWN;
		case DIR_LEFT: return RAD_DIR_LEFT;
		case DIR_RIGHT: return RAD_DIR_RIGHT;
		default: { printf("Invalid direction %d passed to Dir4Rad \n",dir); return -1; }
	}
}

//Same as DirAngle, but return value is measured in radians.
int DirRad(int dir)
{
	//dir &=7;
	switch(DirNormal(dir))
	{
		case DIR_UP: return RAD_DIR_UP;
		case DIR_DOWN: return RAD_DIR_DOWN;
		case DIR_LEFT: return RAD_DIR_LEFT; //Pi
		case DIR_RIGHT: return RAD_DIR_RIGHT;
		case DIR_LEFTUP: return RAD_DIR_LEFTUP;
		case DIR_RIGHTUP: return RAD_DIR_RIGHTUP;
		case DIR_LEFTDOWN: return RAD_DIR_LEFTDOWN;
		case DIR_RIGHTDOWN: return RAD_DIR_RIGHTDOWN;
		default: { printf("Invalid direction %d passed to DirRad \n",dir); return -1; }
	}
}

// Returns the squared distance of a vector.
float DistanceSquared( float x, float y )
{
	return (x * x + y * y);
}

//returns true if Link is within 'dist' distance of an ffc on both its X and its Y axis.
bool DistXY(ffc a, int dist)
{
	if ( Abs(Link->X - a->X) <= dist )
	{
		if ( Abs(Link->Y - a->Y) <= dist ) return true;
	}
	return false;
}

//Returns the Quotient only of x divided by y
int Div(float x, float y)
{
	return (x/y)<<0;
}


// Returns the correct index for getting minimap, or dungeon
// map tiles and csets to use with dmapdata->MiniMapTile[]
// and similar instructions.
// Accepts a dmapdata pointer.
int DMapMapGraphicsIndex(dmapdata dm)
{
	return ((Game->LItems[dm->ID]&LI_MAP) ? 1 : 0);
}

// Returns the correct index for getting minimap, or dungeon
// map tiles and csets to use with dmapdata->MiniMapTile[]
// and similar instructions.
// Accepts a dmap ID as an integer.
int DMapMapGraphicsIndex(int dmapID)
{
	return ((Game->LItems[dmapID]&LI_MAP) ? 1 : 0);
}

// Returns the correct index for getting minimap, or dungeon
// map tiles and csets to use with dmapdata->MiniMapTile[]
// and similar instructions.
// Checks the current DMap.
int DMapMapGraphicsIndex()
{
	return ((Game->LItems[Game->CurDMap]&LI_MAP) ? 1 : 0);
}

// Convert between map and DMap screens
int DMapToMap(int screen, int dmap)
{
	dmapdata dm = Game->LoadDMapData(dmap);
	return screen+dm->Offset;
}

// Returns the dot product of two vectors.
float DotProduct( float x1, float y1, float x2, float y2 )
{
	return (x1 * x2 + y1 * y2);
}


//Overload to Screen->DrawString which includes a position to begin drawing from in the string
//Does not check for overflow
void DrawString(int layer, int x, int y, int font, int color, int background_color, int format, int opacity,
				char32[] ptr, int start)
{
	char32 buffer[256];
	for(int i=start;ptr[i]!=0;++i) buffer[i-start] = ptr[i];
	Screen->DrawString(layer,x,y,font,color,background_color,format,buffer,opacity);
}

//Overload to Screen->DrawString which includes a start and end position to draw the string
//Does not check for overflow
void DrawString(int layer, int x, int y, int font, int color, int background_color, int format, int opacity,
				char32[] ptr, int start, int end)
{
	char32 buffer[256];
	for(int i=start;i<end;++i) buffer[i-start] = ptr[i];
	Screen->DrawString(layer,x,y,font,color,background_color,format,buffer,opacity);
}

// A very simple layer 0 tile drawing routine.
void DrawTileSimple(int x, int y, int tile, int color)
{
	Screen->FastTile(0, x, y, tile, color, 128);
}


//Draws an ffc to a given layer. If the ffc is larger than 1x1 its graphics must all be comboed
void DrawToLayer(ffc f, int layer, int opacity)
{
	Screen->DrawCombo(layer,f->X,f->Y,f->Data,f->TileWidth,f->TileHeight,f->CSet,-1,-1,0,0,0,-1,0,true,opacity);
}

//Draws an npc to a given layer
void DrawToLayer(npc n, int layer, int opacity)
{
	Screen->DrawTile(layer,n->X,n->Y,n->Tile,n->TileWidth,n->TileHeight,n->CSet,-1,-1,0,0,0,0,true,opacity);
}

//Draws an lweapon to a given layer
void DrawToLayer(lweapon l, int layer, int opacity)
{
	Screen->DrawTile(layer,l->X,l->Y,l->Tile,l->TileWidth,l->TileHeight,l->CSet,-1,-1,0,0,0,0,true,opacity);
}

//Draws an eweapon to a given layer
void DrawToLayer(eweapon e, int layer, int opacity)
{
	Screen->DrawTile(layer,e->X,e->Y,e->Tile,e->TileWidth,e->TileHeight,e->CSet,-1,-1,0,0,0,0,true,opacity);
}

//Draws an item to a given layer
void DrawToLayer(item i, int layer, int opacity)
{
	Screen->DrawTile(layer,i->X,i->Y,i->Tile,i->TileWidth,i->TileHeight,i->CSet,-1,-1,0,0,0,0,true,opacity);
}



//Creates and returns an exact copy of the passed LWeapon. Assumes that the passed pointer is valid.
lweapon Duplicate(lweapon a)
{
	lweapon b = Screen->CreateLWeapon(a->ID);
	b->X = a->X;
	b->Y = a->Y;
	b->Z = a->Z;
	b->Jump = a->Jump;
	b->Extend = a->Extend;
	b->TileWidth = a->TileWidth;
	b->TileHeight = a->TileHeight;
	b->HitWidth = a->HitWidth;
	b->HitHeight = a->HitHeight;
	b->HitZHeight = a->HitZHeight;
	b->HitXOffset = a->HitXOffset;
	b->HitYOffset = a->HitYOffset;
	b->DrawXOffset = a->DrawXOffset;
	b->DrawYOffset = a->DrawYOffset;
	b->DrawZOffset = a->DrawZOffset;
	b->Tile = a->Tile;
	b->CSet = a->CSet;
	b->DrawStyle = a->DrawStyle;
	b->Dir = a->Dir;
	b->OriginalTile = a->OriginalTile;
	b->OriginalCSet = a->OriginalCSet;
	b->FlashCSet = a->FlashCSet;
	b->NumFrames = a->NumFrames;
	b->Frame = a->Frame;
	b->ASpeed = a->ASpeed;
	b->Damage = a->Damage;
	b->Step = a->Step;
	b->Angle = a->Angle;
	b->Angular = a->Angular;
	b->CollDetection = a->CollDetection;
	b->DeadState = a->DeadState;
	b->Flash = a->Flash;
	b->Flip = a->Flip;
	for (int i = 0; i < 32; ++i)
		b->Misc[i] = a->Misc[i];
	b->ID = a->ID;
	b->ScriptTile = a->ScriptTile;
	b->ScriptFlip = a->ScriptFlip;
	b->Animation = a->Animation;
	b->Parent = a->Parent;
	b->Level = a->Level;
	b->Script = a->Script;
	b->Weapon = a->Weapon;
	b->Defense = a->Defense;
	b->Level = a->Level;
	for ( int q = 0; q < 8; ++q ) b->InitD[q] = a->InitD[q];
	return b;
}

//Creates and returns an exact copy of the passed EWeapon. Assumes that the passed pointer is valid.
eweapon Duplicate(eweapon a)
{
	eweapon b = Screen->CreateEWeapon(a->ID);
	b->X = a->X;
	b->Y = a->Y;
	b->Z = a->Z;
	b->Jump = a->Jump;
	b->Extend = a->Extend;
	b->TileWidth = a->TileWidth;
	b->TileHeight = a->TileHeight;
	b->HitWidth = a->HitWidth;
	b->HitHeight = a->HitHeight;
	b->HitZHeight = a->HitZHeight;
	b->HitXOffset = a->HitXOffset;
	b->HitYOffset = a->HitYOffset;
	b->DrawXOffset = a->DrawXOffset;
	b->DrawYOffset = a->DrawYOffset;
	b->DrawZOffset = a->DrawZOffset;
	b->Tile = a->Tile;
	b->CSet = a->CSet;
	b->DrawStyle = a->DrawStyle;
	b->Dir = a->Dir;
	b->OriginalTile = a->OriginalTile;
	b->OriginalCSet = a->OriginalCSet;
	b->FlashCSet = a->FlashCSet;
	b->NumFrames = a->NumFrames;
	b->Frame = a->Frame;
	b->ASpeed = a->ASpeed;
	b->Damage = a->Damage;
	b->Step = a->Step;
	b->Angle = a->Angle;
	b->Angular = a->Angular;
	b->CollDetection = a->CollDetection;
	b->DeadState = a->DeadState;
	b->Flash = a->Flash;
	b->Flip = a->Flip;
	for (int i = 0; i < 32; ++i)
		b->Misc[i] = a->Misc[i];
	b->ID = a->ID;
	b->ScriptTile = a->ScriptTile;
	b->ScriptFlip = a->ScriptFlip;
	b->Animation = a->Animation;
	b->Parent = a->Parent;
//	b->Level = a->Level;
	b->Script = a->Script;
	b->Level = a->Level;
	//b->Weapon = a->Weapon;
	//b->Defense = a->Defense;
	for ( int q = 0; q < 8; ++q ) b->InitD[q] = a->InitD[q];
	return b;
}

//E

//Returns if there are enemy NPCs alive on the current screen.
bool EnemiesAlive()
{
	bool alive = false;
	for ( int q = Screen->NumNPCs; q > 0; --q )
	{
		npc n = Screen->LoadNPC(q);
		if ( n->Type != NPCT_PROJECTILE )
		{
			unless ( (n->MiscFlags&NPCMF_NOT_BEATABLE) )
			{
				if ( n->Type != NPCT_FAIRY )
				{
					if ( n->Type != NPCT_GUY )
					{
						alive = true;
					}
				}
			}
		}
	}
	return alive;
}

//F

//Returns if Link is facing an ffc.
bool Facing(ffc f)
{
	if ( Link->Dir == DIR_UP && Link->Y > f->Y ) return true;
	if ( Link->Dir == DIR_DOWN && Link->Y < f->Y ) return true;
	if ( Link->Dir == DIR_RIGHT && Link->X < f->X ) return true;
	if ( Link->Dir == DIR_LEFT && Link->X > f->X ) return true;
	return false;
}

//Returns the number of an FFC, and -1 for a non-valid FFC (which should never happen)
int FFCNum(ffc f)
{
	for(int i=1; i<=128; ++i)
		if(f == Screen->LoadFFC(i))
			return i;
	return -1;
}

//Returns the position of the first instance of the given combo flag, or -1.
//Checks inherent flags too!
int FirstComboFlagOf(int t, int layer)
{
	if(layer < 0 || layer > 6)
		return -1;
	mapdata m = Game->LoadTempScreen(layer);
	for (int i = 0; i < 176; ++i)
	{
		if(m->ComboF[i] == t || m->ComboI[i] == t)
			return i;
	}
	return -1;
}

//Returns the position of the first instance of the given combo, or -1.
int FirstComboTypeOf(int t, int layer)
{
	for (int i = 0; i < 176; ++i)
	{
		unless (layer) //layer 0
		{
			if (Screen->ComboT[i] == t)
				return i;
		}
		else
		{
			if (GetLayerComboT(layer,i) == t)
				return i;
		}
	}
	return -1;
}

//Returns the position of the first instance of the given combo, or -1.
int FirstComboOf(int t, int layer)
{
	for (int i = 0; i < 176; ++i)
	{
		unless (layer) //layer 0
		{
			if (Screen->ComboD[i] == t)
				return i;
		}
		else
		{
			if (GetLayerComboD(layer,i) == t)
				return i;
		}
	}
	return -1;
}

//G

//Returns the catchall type used by a mapscreen passed as pointer 'm'.
catchalltypes GetCatchallType(mapdata m)
{
	switch(m->RoomType)
	{
		//no catchall
		case rtNONE:
		case rtPOTIONORHEART:
		case rtGORIYA:
		case rtLEVEL9:
		case rtTENRUPY:
		case rtGAN:
		case rtWINGAME:
		case rtMAGIC:
		case rtSLASH:
			return caNONE;

		case rtGAMBLE:
			return caGAMBLE;

		//item id
		case rtSPECIALITEM:
			return caITEM;

		case rtSECRETMONEY:
			return caAMOUNT;

		//shops
		case rtPOTION:
		case rtSHOP:
		case rtONEITEM:
			return caSHOPID;

		case rtPAYINFO:
			return caINFOSHOPID;

		//price
		case rtARROWS:
		case rtDOORREPAIR:
		case rtBOMBS:
		case rtMOYL: //the non-heart cost
			return caPRICE;

		case rtSTAIRWARP: return caWARPRING;
		case rtITEMPOND: return caPONDID;

		default:
			return caNONE;

	}
}

//Returns the item ID of the item equipped to the A button
int GetEquipmentA()
{
	return Hero->ItemA;
	//return (Hero->Equipment&0xFF);
}

//Returns the item ID of the item equipped to the B button
int GetEquipmentB()
{
	return Hero->ItemB;
	//return ((Hero->Equipment&0xFF00)>>8);
}

//Returns the item ID of the item equipped to the X button
int GetEquipmentX()
{
	return Hero->ItemX;
	//return ((Hero->Equipment&0xFF00)>>8);
}

//Returns the item ID of the item equipped to the Y button
int GetEquipmentY()
{
	return Hero->ItemY;
	//return ((Hero->Equipment&0xFF00)>>8);
}

//Returns true if DMap bitwise flags 'flag' is set on dmap 'dmap'
bool GetDMapFlag(int dmap, int flag)
{
	dmapdata dm = Game->LoadDMapData(dmap);
	return (dm->Flags&flag);
}

int GetFirstItemOf(int itemclass)
{
	itemdata id;
	for(int q = 0; q <= MAX_ITEMDATA; ++q)
	{
		id = Game->LoadItemData(q);
		if(id->Type == itemclass)
			return q;
	}
	return -1;
}

int GetHighestLevelItem(int itemclass)
{
	itemdata id;
	int ret = -1;
	int curlevel = -1000;
	//143 is default max items, increase if you add lots of your own
	for(int i = 0; i <= MAX_HIGHEST_LEVEL_ITEM_CHECK; ++i)
	{
		id = Game->LoadItemData(i);
		if(id->Family != itemclass)
			continue;
		if(id->Level > curlevel)
		{
			curlevel = id->Level;
			ret = i;
		}
	}
	return ret;
}

int GetHighestLevelItem(item i)
{
	itemdata argid = GetItemData(i);
	int ret = i->ID;
	int curlevel = argid->Level;
	itemdata id;
	//143 is max items, decrease to improve speed if you need to
	for(int i = 0; i <= MAX_HIGHEST_LEVEL_ITEM_CHECK; ++i )
	{
		id = Game->LoadItemData(i);
		if(id->Family != argid->Family)
			continue;
		if(id->Level > curlevel)
		{
			curlevel = id->Level;
			ret = i;
		}
	}
	return ret;
}

/**
 * Faster than the old function; this now works
 * exactly how the engine handles it. -Em
 */
int GetHighestLevelItemOwned(int itemclass)
{
	int result = -1;
	int highestlevel = -1;

	for(int i=0; i<=MAX_HIGHEST_LEVEL_ITEM_CHECK; ++i)
	{
		itemdata id = Game->LoadItemData(i);
		if(id->Family == itemclass && Link->Item[i])
		{
			if(id->Level >= highestlevel)
			{
				highestlevel = id->Level;
				result=i;
			}
		}
	}

	return result;
}


//Gets the ZString (message) ID used by a Pay for Info Shop.
//Argument 1 is the info shop ID, argument 2 is the shop's string (0 to 2).
//Returns the string typed as messagedata, e.g. messagedata md = GetInfoString(shop, 0);
messagedata GetInfoString(int shop_id, int str_id)
{
	if (shop_id < 0 || shop_id > 255 )
	{
		printf("Invalid info shop ID (%d) passed to PayForInfoString()\n", shop_id);
		return NULL;
	}
	if (str_id < 0 || str_id > 2 )
	{
		printf("Invalid string ID (%d) passed to PayForInfoString()\n", str_id);
		return NULL;
	}
	return (Game->LoadMessageData(Game->LoadInfoShopData(shop_id)->String[str_id]));
}

//Copies the ZString (message) ID used by a Pay for Info Shop to a client (ZScript) string.
//Argument 1 is a ZScript string pointer, Arguent 2 is the info shop ID,
//Argument 3 is the shop's string (0 to 2).
void GetInfoString(char32[] buffer, int shop_id, int str_id)
{
	if (shop_id < 0 || shop_id > 255 )
	{
		printf("Invalid info shop ID (%d) passed to PayForInfoString()\n", shop_id);
		return;
	}
	if (str_id < 0 || str_id > 2 )
	{
		printf("Invalid string ID (%d) passed to PayForInfoString()\n", str_id);
		return;
	}
	Game->LoadMessageData(Game->LoadInfoShopData(shop_id)->String[str_id])->Get(buffer);
}

//Gets the ZString (message) ID used by a Pay for Info Shop.
//Argument 1 is the info shop ID, argument 2 is the shop's string (0 to 2).
//Returns an integer of the string ID.
int GetInfoStringID(int shop_id, int str_id)
{
	if (shop_id < 0 || shop_id > 255 )
	{
		printf("Invalid info shop ID (%d) passed to PayForInfoString()\n", shop_id);
		return 0;
	}
	if (str_id < 0 || str_id > 2 )
	{
		printf("Invalid string ID (%d) passed to PayForInfoString()\n", str_id);
		return 0;
	}
	return (Game->LoadInfoShopData(shop_id)->String[str_id]);
}

itemdata GetItemData(item i)
{
	return Game->LoadItemData(i->ID);
}

//Returns true if an item's Pickup state is set
//Use the IP_ constants for the 'pickup' argument of this function
bool GetItemPickup(item i, int pickup)
{
	return (i->Pickup&pickup);
}

//A shorthand way to get a combo on the current layer.
//Layer 0 is the screen itself.
int GetLayerComboC(int layer, int pos)
{
	if (layer < 0 || layer > 6)
	{
		printf("Invalid layer %d passed to GetLayerComboC \n",layer);
		return -1;
	}

	return Game->LoadTempScreen(layer)->ComboC[pos];
}


//A shorthand way to get a combo on the current layer.
//Layer 0 is the screen itself.
int GetLayerComboD(int layer, int pos)
{
	if (layer < 0 || layer > 6)
	{
		printf("Invalid layer %d passed to GetLayerComboD \n",layer);
		return -1;
	}

	return Game->LoadTempScreen(layer)->ComboD[pos];
}

//A shorthand way to get a combo on the current layer.
//Layer 0 is the screen itself.
int GetLayerComboF(int layer, int pos)
{
	if (layer < 0 || layer > 6)
	{
		printf("Invalid layer %d passed to GetLayerComboF \n",layer);
		return -1;
	}

	return Game->LoadTempScreen(layer)->ComboF[pos];
}

//A shorthand way to get a combo on the current layer.
//Layer 0 is the screen itself.
int GetLayerComboI(int layer, int pos)
{
	if (layer < 0 || layer > 6)
	{
		printf("Invalid layer %d passed to GetLayerComboI \n",layer);
		return -1;
	}

	return Game->LoadTempScreen(layer)->ComboI[pos];
}


//A shorthand way to get a combo on the current layer.
//Layer 0 is the screen itself.
int GetLayerComboS(int layer, int pos)
{
	if (layer < 0 || layer > 6)
	{
		printf("Invalid layer %d passed to GetLayerComboS \n",layer);
		return -1;
	}

	return Game->LoadTempScreen(layer)->ComboS[pos];
}


//A shorthand way to get a combo on the current layer.
//Layer 0 is the screen itself.
int GetLayerComboT(int layer, int pos)
{
	if (layer < 0 || layer > 6)
	{
		printf("Invalid layer %d passed to GetLayerComboT \n",layer);
		return -1;
	}

	return Game->LoadTempScreen(layer)->ComboT[pos];
}

//Returns true if Link has the level item 'itm' from level 'level'
//Overloaded to use the current level if no 'level' arg is entered
//Use the LI_ constants for the 'itm' argument
bool GetLevelItem(int level, int itm)
{
	return (Game->LItems[level]&itm);
}
bool GetLevelItem(int itm)
{
	return (Game->LItems[Game->CurLevel]&itm);
}

//Gets mapdata EFlags, similar to ScreenEFlag()
//Uses a mapdata pointer.
int GetMapScreenEFlag(mapdata md, int category, int flag)
{
	int catsizes[] = {5,5,5}; //this is what the editor shows.
	//int catsizes[] = {1,5,4}; //this is what ffscript seems to think, anyway.
	//int catsizes[] = {6,6,5}; //old value, plain wrong. -Z ( 12th February, 2019 )
	if(flag < 0 || flag >= catsizes[category]) return -1;
	return md->EFlags[category]&(1<<flag);
}

//Gets mapdata EFlags, similar to ScreenEFlag()
//Uses map an screen integer values.
int GetMapScreenEFlag(int mapid, int scr, int category, int flag)
{
	mapdata m = Game->LoadMapData(mapid, scr);
	int catsizes[] = {5,5,5}; //this is what the editor shows.
	//int catsizes[] = {1,5,4}; //this is what ffscript seems to think, anyway.
	//int catsizes[] = {6,6,5}; //old value, plain wrong. -Z ( 12th February, 2019 )
	if(flag < 0 || flag >= catsizes[category]) return -1;
	return m->EFlags[category]&(1<<flag);
}


//Helper function to get mapdata->Flags[] values
//See the enum mapscreenflags for legal flags.
//Accepts a mapdata pointer.
bool GetMapscreenFlag(mapdata m, mapscreenflags flagid)
{
	switch(flagid)
	{
		//0, flags
		case MSF_BLOCKSHUT:
			return (m->Flags[0]&1);
		case MSF_ENEMIES_ITEM:
			return (m->Flags[0]&2);
		case MSF_DARKROOM:
			return (m->Flags[0]&4);
		//8 IS A DUMMY PROC
		case MSF_STAIRS:
			return (m->Flags[0]&16);
		case MSF_ALLOW_LADDER:
			return (m->Flags[0]&32);
		case MSF_MAZEPATHS:
			return (m->Flags[0]&64);
		case MSF_SFXONENTRY:
			return (m->Flags[0]&128);

		//1, flags2
		//what, no 1?
		case MSF_MIDAIR:
			return ((m->Flags[1]>>4)&2);
		case MSF_TRAPS_IGNORE_SOLID:
			return ((m->Flags[1]>>4)&4);
		case MSF_ENEMEIS_SECRET:
			return ((m->Flags[1]>>4)&8);

		//2, flags3
		case MSF_HOLDUP:
			return (m->Flags[2]&1);
		case MSF_CYCLEINIT:
			return (m->Flags[2]&2);
		case MSF_INVISIBLEENEMIES:
			return (m->Flags[2]&4);
		case MSF_INVISLINK:
			return (m->Flags[2]&8);
		case MSF_NOSUBSCREEN:
			return (m->Flags[2]&16);
		case MSF_SPRITECARRY:
			return (m->Flags[2]&32);
		case MSF_NOOFFSET:
			return (m->Flags[2]&64);
		case MSF_EMELIESALWAYSRETURN:
			return (m->Flags[2]&128);

		//3, flags4
		//1 AND 2 ARE APPARENTLY UNUSED?
		case MSF_DIRECTTIMEDWARPS:
			return (m->Flags[3]&4);
		case MSF_SECRETSISABLETIMEWRP:
			return (m->Flags[3]&8);
		case MSF_ENEMIES_SECRET_PERM:
			return (m->Flags[3]&16);
		//32 IS NOT USED
		case MSF_SAVECONTHERE:
			return (m->Flags[3]&64);
		case MSF_SAVEONENTRY:
			return (m->Flags[3]&128);

		//4, flags5
		//no 1?
		case MSF_RANDOMTIMEDWARP:
			return (m->Flags[4]&1);
		case MSF_IGNOREBOOTS:
			return (m->Flags[4]&2);
		case MSF_AUTODIRECT:
			return (m->Flags[4]&4);
		case MSF_SENDSIRECT:
			return (m->Flags[4]&8);
		case MSF_TEMPSECRETS:
			return (m->Flags[4]&16);
		//no 32?
		case MSF_NO_DIVING:
			return (m->Flags[4]&64);
		case MSF_NOCARRYOVERFFC:
			return (m->Flags[4]&128);

		//5, flags6
		case MSF_INTERIOR:
			return (m->Flags[5]&1);
		case MSF_DUNGEON:
			return (m->Flags[5]&2);
		case MSF_TRIGPERM:
			return (m->Flags[5]&4);
		case MSF_CONTHERE:
			return (m->Flags[5]&8);
		case MSF_NOCONTINUEWARP:
			return (m->Flags[5]&16);
		case MSF_ALLTRIGFLAGS:
			return (m->Flags[5]&32);
		case MSF_TOGGLERINGS:
			return (m->Flags[5]&64);
		case MSF_WRAPFFC:
			return (m->Flags[5]&128);

		//6, flags7
		case MSF_LAYER3BG:
			return (m->Flags[6]&1);
		case MSF_LAYER2BG:
			return (m->Flags[6]&2);
		case MSF_FALLS:
			return (m->Flags[6]&4);
		case MSF_SIDEVIEW:
			return (m->Flags[6]&8);
		case MSF_NOLINKMARKER:
			return (m->Flags[6]&16);
		case MSF_PALCHANGE:
			return (m->Flags[6]&64);
		case MSF_DRYLAKE:
			return (m->Flags[6]&128);

		//7, flags8
		case MSF_SCRIPT1:
			return (m->Flags[7]&1);
		case MSF_SCRIPT2:
			return (m->Flags[7]&2);
		case MSF_SCRIPT3:
			return (m->Flags[7]&4);
		case MSF_SCRIPT4:
			return (m->Flags[7]&8);
		case MSF_SCRIPT5:
			return (m->Flags[7]&16);
		case MSF_LENSEFFECT:
			return (m->Flags[7]&32);
		case MSF_MAZEOVERRIDE:
			return (m->Flags[7]&64);

		default:
		{
			printf("Invalid flag id (%d) passed to GetMapscreenFlag()\n", flagid); return 0;
		}
	}
}



//Helper function to get mapdata->Flags[] values
//See the enum mapscreenflags for legal flags.
//Accepts a map ID and a screen ID.
bool GetMapscreenFlag(int mapid, int scr, mapscreenflags flagid)
{
	mapdata m = Game->LoadMapData(mapid, scr);
	switch(flagid)
	{
		//0, flags
		case MSF_BLOCKSHUT:
			return (m->Flags[0]&1);
		case MSF_ENEMIES_ITEM:
			return (m->Flags[0]&2);
		case MSF_DARKROOM:
			return (m->Flags[0]&4);
		//8 IS A DUMMY PROC
		case MSF_STAIRS:
			return (m->Flags[0]&16);
		case MSF_ALLOW_LADDER:
			return (m->Flags[0]&32);
		case MSF_MAZEPATHS:
			return (m->Flags[0]&64);
		case MSF_SFXONENTRY:
			return (m->Flags[0]&128);

		//1, flags2
		//what, no 1?
		case MSF_MIDAIR:
			return ((m->Flags[1]>>4)&2);
		case MSF_TRAPS_IGNORE_SOLID:
			return ((m->Flags[1]>>4)&4);
		case MSF_ENEMEIS_SECRET:
			return ((m->Flags[1]>>4)&8);

		//2, flags3
		case MSF_HOLDUP:
			return (m->Flags[2]&1);
		case MSF_CYCLEINIT:
			return (m->Flags[2]&2);
		case MSF_INVISIBLEENEMIES:
			return (m->Flags[2]&4);
		case MSF_INVISLINK:
			return (m->Flags[2]&8);
		case MSF_NOSUBSCREEN:
			return (m->Flags[2]&16);
		case MSF_SPRITECARRY:
			return (m->Flags[2]&32);
		case MSF_NOOFFSET:
			return (m->Flags[2]&64);
		case MSF_EMELIESALWAYSRETURN:
			return (m->Flags[2]&128);

		//3, flags4
		//1 AND 2 ARE APPARENTLY UNUSED?
		case MSF_DIRECTTIMEDWARPS:
			return (m->Flags[3]&4);
		case MSF_SECRETSISABLETIMEWRP:
			return (m->Flags[3]&8);
		case MSF_ENEMIES_SECRET_PERM:
			return (m->Flags[3]&16);
		//32 IS NOT USED
		case MSF_SAVECONTHERE:
			return (m->Flags[3]&64);
		case MSF_SAVEONENTRY:
			return (m->Flags[3]&128);

		//4, flags5
		//no 1?
		case MSF_RANDOMTIMEDWARP:
			return (m->Flags[4]&1);
		case MSF_IGNOREBOOTS:
			return (m->Flags[4]&2);
		case MSF_AUTODIRECT:
			return (m->Flags[4]&4);
		case MSF_SENDSIRECT:
			return (m->Flags[4]&8);
		case MSF_TEMPSECRETS:
			return (m->Flags[4]&16);
		//no 32?
		case MSF_NO_DIVING:
			return (m->Flags[4]&64);
		case MSF_NOCARRYOVERFFC:
			return (m->Flags[4]&128);

		//5, flags6
		case MSF_INTERIOR:
			return (m->Flags[5]&1);
		case MSF_DUNGEON:
			return (m->Flags[5]&2);
		case MSF_TRIGPERM:
			return (m->Flags[5]&4);
		case MSF_CONTHERE:
			return (m->Flags[5]&8);
		case MSF_NOCONTINUEWARP:
			return (m->Flags[5]&16);
		case MSF_ALLTRIGFLAGS:
			return (m->Flags[5]&32);
		case MSF_TOGGLERINGS:
			return (m->Flags[5]&64);
		case MSF_WRAPFFC:
			return (m->Flags[5]&128);

		//6, flags7
		case MSF_LAYER3BG:
			return (m->Flags[6]&1);
		case MSF_LAYER2BG:
			return (m->Flags[6]&2);
		case MSF_FALLS:
			return (m->Flags[6]&4);
		case MSF_SIDEVIEW:
			return (m->Flags[6]&8);
		case MSF_NOLINKMARKER:
			return (m->Flags[6]&16);
		case MSF_PALCHANGE:
			return (m->Flags[6]&64);
		case MSF_DRYLAKE:
			return (m->Flags[6]&128);

		//7, flags8
		case MSF_SCRIPT1:
			return (m->Flags[7]&1);
		case MSF_SCRIPT2:
			return (m->Flags[7]&2);
		case MSF_SCRIPT3:
			return (m->Flags[7]&4);
		case MSF_SCRIPT4:
			return (m->Flags[7]&8);
		case MSF_SCRIPT5:
			return (m->Flags[7]&16);
		case MSF_LENSEFFECT:
			return (m->Flags[7]&32);
		case MSF_MAZEOVERRIDE:
			return (m->Flags[7]&64);

		default:
		{
			printf("Invalid flag id (%d) passed to GetMapscreenFlag()\n", flagid); return 0;
		}
	}
}



//Puts a ZQE Message String into a client array string 'ptr'
void GetMessage(int ID, char32[] ptr)
{
	messagedata md = Game->LoadMessageData(ID);
	int sz = md->Length;
	if(SizeOfArray(ptr) <= sz)
		ResizeArray(ptr, sz+1);
	md->Get(ptr);
	for(; ptr[sz-1] == ' '; --sz);
	ptr[sz] = 0;
}

//Returns true if an npc's Misc. flag is set.
bool GetNPCMiscFlag(npc e, int flag)
{
	return (e->MiscFlags&flag);
}

//Get an NPC's name from an ID
void GetNPCName(int npc_id, char32[] buffer)
{
	//we need npcdata->GetName()
	npcdata nd = Game->LoadNPCData(npc_id);
	nd->GetName(buffer);
	//npc n = Screen->CreateNPC(ID);
	//n->GetName(ptr);
	//Remove(n);
}

//Returns the state of bit 'bit' of Screen->D[] register 'd'
bool GetScreenDBit(int dmap, int screen, int d, int bit)
{
	return ( Game->GetDMapScreenD(dmap, screen, d) & (1L << bit) );
}
bool GetScreenDBit(int screen, int d, int bit)
{
	return ( Game->GetScreenD(screen, d) & (1L << bit) );
}
bool GetScreenDBit(int d, int bit)
{
	return (Screen->D[d] & (1L << bit));
}


//Snaps 'x' to the combo grid
//Equivalent to calling ComboX(ComboAt(x,foo));
int GridX(int x)
{
	return (x >> 4) << 4;
}

//Snaps 'y' to the combo grid
//Equivalent to calling ComboY(ComboAt(foo,y));
int GridY(int y)
{
	return (y >> 4) << 4;
}

//H

//Returns if Link has the map for a given level.
int HasBossKey(int level = -1)
{
	if(level < 0) level = Game->CurLevel;
	return ( ((Game->LItems[level]&LI_BOSSKEY)) ? 1 : 0 );
}

//Returns if Link has the compass for a given level.
int HasCompass(int level = -1)
{
	if(level < 0) level = Game->CurLevel;
	return ( ((Game->LItems[level]&LI_COMPASS)) ? 1 : 0 );
}

bool HasHeavyBoots()
{
	itemdata id;
	for ( int q = 0; q < 256; ++q )
	{
		id = Game->LoadItemData(q);
		if ( id->Family == IC_BOOTS && /*iron*/ id->Flags[1] ) return true;
	}
	return false;
}

int HasMap(int level = -1)
{
	if(level < 0) level = Game->CurLevel;
	return ( ((Game->LItems[level]&LI_MAP)) ? 1 : 0 );
}

bool HasKey(int level = -1)
{
	if(level < 0) level = Game->CurLevel;
	return Game->LKeys[level]>0 || Game->Counter[CR_KEYS]>0;
}

int HasTriforce(int level)
{
	return ( ((Game->LItems[level]&LI_TRIFORCE)) ? 1 : 0 );
}

// Returns the Y coordinate of the bottom edge of the hitbox.
int HitboxBottom(eweapon a)
{
	return (a->Y + a->HitYOffset + a->HitHeight - 1);
}

int HitboxBottom(lweapon a)
{
	return (a->Y + a->HitYOffset + a->HitHeight - 1);
}

int HitboxBottom(item a)
{
	return (a->Y + a->HitYOffset + a->HitHeight - 1);
}

int HitboxBottom(npc a)
{
	return (a->Y + a->HitYOffset + a->HitHeight - 1);
}

//Uses TileWidth and TileHeight for the FFC's bounding box.
int HitboxBottom(ffc a)
{
	return a->Y + (a->TileHeight*16) - 1;
}

// Returns the X coordinate of the left edge of the hitbox.
int HitboxLeft(eweapon a)
{
	return (a->X + a->HitXOffset);
}

int HitboxLeft(lweapon a)
{
	return (a->X + a->HitXOffset);
}

int HitboxLeft(item a)
{
	return (a->X + a->HitXOffset);
}

int HitboxLeft(npc a)
{
	return (a->X + a->HitXOffset);
}

int HitboxLeft(ffc a)
{
	return a->X;
}

// Returns the X coordinate of the right edge of the hitbox.
int HitboxRight(eweapon a)
{
	return (a->X + a->HitXOffset + a->HitWidth - 1);
}

int HitboxRight(lweapon a)
{
	return (a->X + a->HitXOffset + a->HitWidth - 1);
}

int HitboxRight(item a)
{
	return (a->X + a->HitXOffset + a->HitWidth - 1);
}

int HitboxRight(npc a)
{
	return (a->X + a->HitXOffset + a->HitWidth - 1);
}

int HitboxRight(ffc a)
{
	return a->X + a->TileWidth*16 - 1;
}

// Returns the Y coordinate of the top edge of the hitbox.
int HitboxTop(eweapon a)
{
	return (a->Y + a->HitYOffset);
}

int HitboxTop(lweapon a)
{
	return (a->Y + a->HitYOffset);
}

int HitboxTop(item a)
{
	return (a->Y + a->HitYOffset);
}

int HitboxTop(npc a)
{
	return (a->Y + a->HitYOffset);
}

int HitboxTop(ffc a)
{
	return a->Y;
}


//I

//Returns if a layer is set as a background layer for the
//current screen.
bool IsBackgroundLayer(int layer)
{
	switch(layer)
	{
		case 2:
			return ( ((Screen->Flags[SF_VIEW]&(1<<SFV_LAYER2BG)) ^^ (Game->LoadDMapData(Game->CurDMap)->Flagset[DMFS_LAYER2ISBACKGROUND])) ? true : false );
		case 3:
			return ( ((Screen->Flags[SF_VIEW]&(1<<SFV_LAYER3BG)) ^^ (Game->LoadDMapData(Game->CurDMap)->Flagset[DMFS_LAYER3ISBACKGROUND])) ? true : false );
		default: return false;
	}
}

//Returns if a layer is set as a background layer for a
//mapdata pointer.
bool IsBackgroundLayer(int layer, mapdata m)
{
	switch(layer)
	{
		case 2:
			return ( ((m->Flags[SF_VIEW]&(1<<SFV_LAYER2BG)) ^^ (Game->LoadDMapData(Game->CurDMap)->Flagset[DMFS_LAYER2ISBACKGROUND])) ? true : false );
		case 3:
			return ( ((m->Flags[SF_VIEW]&(1<<SFV_LAYER3BG)) ^^ (Game->LoadDMapData(Game->CurDMap)->Flagset[DMFS_LAYER3ISBACKGROUND])) ? true : false );
		default: return false;
	}
}

//Returns the correct offset to be 'dist' pixels away from the front of a sprite facing in the direction 'dir'
int InFrontX(int dir, int dist)
{
	//int x = 0;
	switch(DirNormal(dir))
	{
		case DIR_LEFT: return dist-16;
		case DIR_RIGHT: return 16-dist;
		default: return 0;
	}
	//if(dir == DIR_LEFT) x = -16+dist;
	//else if(dir == DIR_RIGHT) x = 16-dist;
	//return x;
}

int InFrontY(int dir, int dist)
{
	//int y = 0;
	switch(DirNormal(dir))
	{
		case DIR_UP: return dist-16;
		case DIR_DOWN: return 16-dist;
		default: return 0;
	}
	//if(dir == DIR_UP) y = -16+dist;
	//else if(dir == DIR_DOWN) y = 16-dist;
	//return y;
}


//Functions for those who are not comfortable with binary
//Returns true if the left mouse button is pressed
bool InputLeftClick()
{
	return (Link->InputMouseB&MB_LEFTCLICK);
}

//Returns true if the central mouse button (if equipped) is pressed
bool InputMiddleClick()
{
	return (Link->InputMouseB&MB_MIDDLECLICK);
}

//Returns true if the right mouse button is pressed
bool InputRightClick()
{
	return (Link->InputMouseB&MB_RIGHTCLICK);
}

//Returns true if the present screen is a dungen type.
bool IsDungeon()
{
	return ((Screen->Flags[SF_ROOMTYPE] & 1) || Game->LoadDMapData(Game->CurDMap)->Type == DMAP_DUNGEON);
}

//Returns true if Link is on a Dungeon (flagged) screen
bool IsDungeonFlag()
{
	return Screen->Flags[SF_ROOMTYPE] & 1;
}

//Returns true if the integer is even.
bool IsEven(int x)
{
	return (!(x & 1));
}

//Returns true if Link is on an Interior (flagged) screen
bool IsInteriorFlag()
{
	return Screen->Flags[SF_ROOMTYPE] & 2;
}

//Returns true if the integer is odd.
bool IsOdd(int x)
{
	return ((x & 1));
}

// Returns true if the combo at the given position is a pit.
bool IsPit(int position)
{
	int combo=Screen->ComboT[position];
	if ( combo==CT_PIT ) return true;
	if ( combo==CT_PITR ) return true;
	if ( ( combo>=CT_PITB && combo<=CT_PITD) ) return true;
	return false;
}

//Returns true if Link is on a sideview screen
bool IsSideview()
{
	return ((Screen->Flags[SF_ROOMTYPE] & 4) ^^ (Game->LoadDMapData(Game->CurDMap)->Sideview));
}

// Returns true if the combo at the given position is water.
bool IsWater(int position)
{
	int combo=Screen->ComboT[position];
	if ( combo==CT_WATER ) return true;
	if ( combo==CT_SWIMWARP ) return true;
	if ( combo==CT_DIVEWARP ) return true;
	if ((combo>=CT_SWIMWARPB && combo<=CT_DIVEWARPD)) return true;
	return false;
}

//J

//K

//L

//Function to get a distance that would otherwise be too large and overflow Distance().
//Get the distance between two points, divided up by divisor. This avoids causing problems
//with the Distance function doing calculations that go over the max constant
float LargeDistance(int x1, int y1, int x2, int y2, int divisor)
{
	int cx = x1+(x2-x1)/divisor;
	int cy = y1+(y2-y1)/divisor;
	return Distance(x1, y1, cx, cy)*divisor;
}

//Returns the position of the last instance of the given combo flag, or -1.
//Checks inherent flags too!
int LastComboFlagOf(int t, int layer)
{
	if(layer < 0 || layer > 6)
		return -1;
	mapdata m = Game->LoadTempScreen(layer);
	for (int i = 175; i >= 0; --i)
	{
		if(m->ComboF[i] == t || m->ComboI[i] == t)
			return i;
	}
	return -1;
}


//Returns the position of the last instance of the given combo, or -1.
int LastComboTypeOf(int t, int layer)
{
	if(layer < 0 || layer > 6)
		return -1;
	mapdata m = Game->LoadTempScreen(layer);
	for (int i = 175; i >= 0; --i)
	{
		if(m->ComboT[i] == t)
			return i;
	}
	return -1;
}

//Returns the position of the last instance of the given combo, or -1.
int LastComboOf(int t, int layer)
{
	if(layer < 0 || layer > 6)
		return -1;
	mapdata m = Game->LoadTempScreen(layer);
	for (int i = 175; i >= 0; --i)
	{
		if(m->ComboD[i] == t)
			return i;
	}
	return -1;
}

//Returns if Link is left of an npc.
bool LeftOf(npc n){ return Link->X < n->X; }
//Returns if Link is above, below, left of, or right of an ffc.
bool LeftOf(ffc n){ return Link->X < n->X; }
//Returns if Link is above, below, left of, or right of an eweapon.
bool LeftOf(eweapon n){ return Link->X < n->X; }
//Returns if Link is above, below, left of, or right of an lweapon.
bool LeftOf(lweapon n){ return Link->X < n->X; }


// Interpolates between p1 and p2 given 't' clamped within range 0,1.
float Lerp(float p1, float p2, float t)
{
	return (p1 + (p2 - p1) * t);
}

// Returns true if there is a collision between Link's hitbox and the eweapon's.
// This only checks hitboxes.
bool LinkCollision(eweapon b)
{
	int ax = Link->X + Link->HitXOffset;
	int bx = b->X + b->HitXOffset;
	int ay = Link->Y + Link->HitYOffset;
	int by = b->Y + b->HitYOffset;
	return RectCollision(ax, ay, ax+Link->HitWidth-1, ay+Link->HitHeight-1, bx, by, bx+b->HitWidth-1, by+b->HitHeight-1) && (Link->Z + Link->HitZHeight >= b->Z) && (Link->Z <= b->Z + b->HitZHeight);
}

// Returns true if there is a collision between Link's hitbox and the lweapon's.
// This only checks hitboxes.
bool LinkCollision(lweapon b)
{
	int ax = Link->X + Link->HitXOffset;
	int bx = b->X + b->HitXOffset;
	int ay = Link->Y + Link->HitYOffset;
	int by = b->Y + b->HitYOffset;
	return RectCollision(ax, ay, ax+Link->HitWidth-1, ay+Link->HitHeight-1, bx, by, bx+b->HitWidth-1, by+b->HitHeight-1) && (Link->Z + Link->HitZHeight >= b->Z) && (Link->Z <= b->Z + b->HitZHeight);
}

// Returns true if there is a collision between Link's hitbox and the item's.
// This only checks hitboxes.
bool LinkCollision(item b)
{
	int ax = Link->X + Link->HitXOffset;
	int bx = b->X + b->HitXOffset;
	int ay = Link->Y + Link->HitYOffset;
	int by = b->Y + b->HitYOffset;
	return RectCollision(ax, ay, ax+Link->HitWidth-1, ay+Link->HitHeight-1, bx, by, bx+b->HitWidth-1, by+b->HitHeight-1) && (Link->Z + Link->HitZHeight >= b->Z) && (Link->Z <= b->Z + b->HitZHeight);
}

// Returns true if there is a collision between Link's hitbox and the npc's.
// This only checks hitboxes.  Uses TileWidth and TileHeight to find the centre of the FFCs.
bool LinkCollision(npc b)
{
	int ax = Link->X + Link->HitXOffset;
	int bx = b->X + b->HitXOffset;
	int ay = Link->Y + Link->HitYOffset;
	int by = b->Y + b->HitYOffset;
	return RectCollision(ax, ay, ax+Link->HitWidth-1, ay+Link->HitHeight-1, bx, by, bx+b->HitWidth-1, by+b->HitHeight-1) && (Link->Z + Link->HitZHeight >= b->Z) && (Link->Z <= b->Z + b->HitZHeight);
}

// Returns true if there is a collision between Link's hitbox and the FFC's.
// This only checks hitboxes.
bool LinkCollision(ffc f)
{
	int ax = Link->X + Link->HitXOffset;
	int ay = Link->Y + Link->HitYOffset;
	return RectCollision(f->X, f->Y, f->X+(f->TileWidth*16)-1, f->Y+(f->TileHeight*16)-1, ax, ay, ax+Link->HitWidth-1, ay+Link->HitHeight-1);
}

// Returns the first EWeapon of the given type. Use the EW_ constants.
// If none exist, it returns an uninitialised pointer.
eweapon LoadEWeaponOf(int type)
{
	eweapon w;
	for ( int i = Screen->NumEWeapons; i > 0; --i )
	{
		w = Screen->LoadEWeapon(i);
		if (w->ID == type) return w;
	}
	eweapon w2; //NULL
	return w2;
}

// Returns the first LWeapon of the given type. Use the LW_ constants.
// If none exist, it returns an uninitialised pointer.
lweapon LoadLWeaponOf(int type)
{
	lweapon w;
	for ( int i = Screen->NumLWeapons; i > 0; --i )
	{
		w = Screen->LoadLWeapon(i);
		if (w->ID == type) return w;
	}
	lweapon w2; //NULL
	return w2;
}

// Returns the first NPC of the given ID. Use the NPC_ constants.
// If none exist, it returns an uninitialised pointer.
npc LoadNPCOf(int type)
{
	npc n;
	for ( int i = Screen->NumNPCs; i > 0; --i )
	{
		n = Screen->LoadNPC(i);
		if (n->ID == type) return n;
	}
	npc n2; //NULL
	return n2;
}

// Returns the first NPC of the given type. Use the NPCT_ constants.
// If none exist, it returns an uninitialised pointer.
npc LoadNPCOfType(int type)
{
	npc n;
	for ( int i = Screen->NumNPCs; i > 0; --i )
	{
		n = Screen->LoadNPC(i);
		if (n->Type == type) return n;
	}
	npc n2; //NULL
	return n2;
}

//Returns the logarithm of x to the given base
float LogToBase(float x, float base)
{
	return Ln(x)/Ln(base);
}


//Returns a random integer between 0 abd 199,999
int longrand(int max)
{
	int numdigits;
	if ( max > 99999 ) numdigits = 6;
	int curpower = 1; int valdigits[6]; int ret;
	switch(numdigits)
	{
		case 6:
		{
			// curmax = getDigit(max,6); //0, 1, 2 legal
			// valdigits[0] = Rand(curmax);
			valdigits[0] = Rand(1);
		} //fallthrough
		default:
		{
			for ( int q = 1; q < 6; ++q )
			{
				valdigits[q] = Rand(9);
			}
			break;
		}
	}
	for ( int q = 5; q > -1; --q )
	{
		ret += ( valdigits[q] * curpower );
		curpower *= 10;
	}
	return ret;
}

//M

int MapToDMap(int screen, int dmap)
{
	dmapdata dm = Game->LoadDMapData(dmap);
	return screen-dm->Offset;
}

void MakeBlockable(eweapon e)
{
	e->Level &= ~1;
}

void MakeUnblockable(eweapon e)
{
	e->Level |= 1;
}

//Add to a counter max without rollover.
void MCounterAdd(int counter, int amount)
{
	if ( amount + Game->MCounter[counter] > MAX_COUNTER ) Game->MCounter[counter] = MAX_COUNTER;
	else Game->MCounter[counter] += amount;
}

//Reduce a counter max without rollvoer.
void MCounterReduce(int counter, int amount)
{
	if ( Game->MCounter[counter] - amount < 0 ) Game->MCounter[counter] = 0;
	else Game->MCounter[counter] -= amount;
}


// Finds the center of p1 and p2.
float Midpoint(float p1, float p2)
{
	return Lerp(p1, p2, 0.5);
}

//N

//Creates an lweapon at 'distx,disty' away from where Link is facing
lweapon NextToLink(int id, int distx, int disty)
{
	lweapon l = CreateLWeaponAt(id, Link->X+InFrontX(Link->Dir, distx), Link->Y+InFrontY(Link->Dir, disty));
	if(l->isValid())
	{
		l->Dir = Link->Dir;
	}
	return l;
}

//Creates an lweapon 'dist' pixels away from the front of Link
lweapon NextToLink(int id, int dist)
{
	return NextToLink(id, dist, dist);
}

eweapon NextToNPC(npc n, int id, int distx, int disty)
{
	eweapon e = CreateEWeaponAt(id, n->X+InFrontX(n->Dir, distx), n->Y+InFrontY(n->Dir, disty));
	if(e->isValid())
	{
		e->Dir = n->Dir;
	}
	return e;
}
eweapon NextToNPC(npc n, int id, int dist)
{
	return NextToNPC(n, id, dist, dist);
}

//Kills all of Link's inputs
void NoAction()
{
	for ( int q = CB_UP; q < MAX_NOACTION_INPUT; ++q )
	{
		if ( q == CB_MAP && NOACTION_SKIP_MAP ) continue;
		if ( q == CB_START && NOACTION_SKIP_START ) continue;
		Input->Button[q] = false;
		Input->Press[q] = false;
	}
	/*
	Link->InputUp = false; Link->PressUp = false;
	Link->InputDown = false; Link->PressDown = false;
	Link->InputLeft = false; Link->PressLeft = false;
	Link->InputRight = false; Link->PressRight = false;
	Link->InputR = false; Link->PressR = false;
	Link->InputL = false; Link->PressL = false;
	Link->InputA = false; Link->PressA = false;
	Link->InputB = false; Link->PressB = false;
	Link->InputEx1 = false; Link->PressEx1 = false;
	Link->InputEx2 = false; Link->PressEx2 = false;
	Link->InputEx3 = false; Link->PressEx3 = false;
	Link->InputEx4 = false; Link->PressEx4 = false;
	*/
}

//Returns the number of enemy NPCs on the current screen.
int NumberEnemies()
{
	int count;
	for ( int q = Screen->NumNPCs; q > 0; --q )
	{
		npc n = Screen->LoadNPC(q);
		if ( n->Type != NPCT_PROJECTILE )
		{
			unless ( (n->MiscFlags&NPCMF_NOT_BEATABLE) )
			{
				if ( n->Type != NPCT_FAIRY )
				{
					if ( n->Type != NPCT_GUY )
					{
						++count;
					}
				}
			}
		}
	}
	return count;
}

int NumEWeaponsOf(int type)
{
	int ret = 0;
	eweapon w;
	for (int i = Screen->NumEWeapons; i > 0; --i)
	{
		w = Screen->LoadEWeapon(i);
		if (w->ID == type)
			++ret;
	}
	return ret;
}
// Use the I_ constants.
// Warning: these iterate over every onscreen item.
// Iterating over every onscreen lweapon multiple times per frame may
// cause slowdown in Zelda Classic.
int NumItemsOf(int type)
{
	int ret = 0;
	item it;
	for (int i = Screen->NumItems; i > 0 ; --i)
	{
		it = Screen->LoadItem(i);
		if (it->ID == type)
			++ret;
	}
	return ret;
}

//Returns the number of keys that the player has for the level 'level'
int NumKeys(int level = -1)
{
	if(level < 0) level = Game->CurLevel;
	return Game->LKeys[level]+Game->Counter[CR_KEYS];
}

// Use the LW_ constants.
// Warning: these iterate over every onscreen lweapon.
// Iterating over every onscreen lweapon multiple times per frame may
// cause slowdown in Zelda Classic.
int NumLWeaponsOf(int type)
{
	int ret = 0;
	lweapon w;
	for (int i = Screen->NumLWeapons; i > 0; --i)
	{
		w = Screen->LoadLWeapon(i);
		if (w->ID == type)
			++ret;
	}
	return ret;
}

// Valid values for [type]: [NpcType] (`NPCT_`).
int NumNPCsOf(int type)
{
	int ret = 0;
	npc n;
	for (int i = Screen->NumNPCs; i > 0 ; --i)
	{
		n = Screen->LoadNPC(i);
		if (n->ID == type)
			++ret;
	}
	return ret;
}

//Returns the number of Triforce Pieces Link currently has.
//Specify the highest level in your game with arg 'maxlevel'.
int NumTriforcePieces(int maxlevel = 8)
{
	int ret = 0;
	for(int i=1;i<=maxlevel;++i)
		if(Game->LItems[i]&LI_TRIFORCE) ++ret;
	return ret;
}

//OnSidePlatform() is now in std_sideview.zh

//Returns the opposite direction to angle 'dir'
int OppositeDir(int dir)
{
	if(dir > 7 && dir < 16)
	{
		return 8+((dir+4)%8);
	}
	return ( (dir < 4) ? dir^1b : dir^11b );
}

//P

//Q

//R

//The above, but in radians.
float RadianAngle(int x1, int y1, int x2, int y2)
{
	return ArcTan(x2-x1, y2-y1);
}

//The above, but for radian angles.
int RadianAngleDir4(float angle)
{
	return AngleDir4(RadtoDeg(angle));
}

//The above, but for radian angles.
int RadianAngleDir8(float angle)
{
	return AngleDir8(RadtoDeg(angle));
}

//Returns a random integer in the bounds of min and max
int Rand(int min, int max)
{
	if(OLD_RAND_FUNCS)
		return min+(Rand((1+max)-min));
	return RandGen->Rand(max, min);
}

//Returns a random floating point number up to n
float Randf(float n)
{
	if(OLD_RAND_FUNCS)
		return (Rand(0x7fff)/0x7fff)*n;
	return RandGen->LRand(n);
}

//Returns a random floating point number between min and max
float Randf(float n1, float n2)
{
	if(OLD_RAND_FUNCS)
		return n1 + (Rand(0x7fff)/(0x7fff))*(n2-n1);
	return RandGen->LRand(n1, n2);
}

//Generalized and optimized rectangle collision checking function.
//Returns true if the bounding box of box1 and box2 overlap.
bool RectCollision(int box1_x1, int box1_y1, int box1_x2, int box1_y2, int box2_x1, int box2_y1, int box2_x2, int box2_y2)
{
	if( box1_y2 < box2_y1 ) return false;
	else if( box1_y1 > box2_y2 ) return false;
	else if( box1_x2 < box2_x1 ) return false;
	else if( box1_x1 > box2_x2 ) return false;
	return true;
}

//Removes LWeapon 'l' from the screen
void Remove(lweapon l)
{
	unless(l->isValid()) return;
	l->DeadState = WDS_DEAD;
	l->X = 32768;
}

//Removes EWeapon 'e' from the screen
void Remove(eweapon e)
{
	unless(e->isValid()) return;
	e->DeadState = WDS_DEAD;
	e->X = 32768;
}

//Removes Item 'i' from the screen
void Remove(item i)
{
	unless(i->isValid()) return;
	i->X = 32768;
}

//Removes NPC 'n' from the screen
void Remove(npc n)
{
	unless(n->isValid()) return;
	n->X = 32768;
	n->HP = -1000;
}

//Returns if Link is right of an npc.
bool RightOf(npc n){ return Link->X > n->X; }
//Returns if Link is above, below, left of, or right of an ffc.
bool RightOf(ffc n){ return Link->X > n->X; }
//Returns if Link is above, below, left of, or right of an eweapon.
bool RightOf(eweapon n){ return Link->X > n->X; }
//Returns if Link is above, below, left of, or right of an lweapon.
bool RightOf(lweapon n){ return Link->X > n->X; }

//Rounds x to the nearest integer
float Round(float x)
{
	return ( (x<0) ? (((x-.5)<<0)) : (((x+.5)<<0)) );
}

//rotates and scales X about a center point by an amount of degrees
float RotateScalePointX(float x, float y, float centerX, float centerY, float degrees, float scaleX, float scaleY)
{
	float dx = (x - centerX) * scaleX;
	float dy = (y - centerY) * scaleY;
	return (Cos(degrees) * dx) - (Sin(degrees) * dy) + centerX;
}

//rotates and scales Y about a center point by an amount of degrees
float RotateScalePointY(float x, float y, float centerX, float centerY, float degrees, float scaleX, float scaleY)
{
	float dx = (x - centerX) * scaleX;
	float dy = (y - centerY) * scaleY;
	return (Sin(degrees) * dx) - (Cos(degrees) * dy) + centerY;
}

//rotates X about a center point by an amount of degrees
float RotatePointX(float x, float y, float centerX, float centerY, float degrees)
{

	if ( REVISED_ROTATEPOINT_X_FUNCTION )
	{
		int distance = LargeDistance(centerX, centerY, x, y, 10);
		int angle = Angle(centerX, centerY, x, y);
		return centerX+VectorX(distance, angle+degrees);
	}
	else
	{
		float dx = x - centerX;
		float dy = y - centerY;
		return (Cos(degrees) * dx) - (Sin(degrees) * dy) + centerX;
	}
}

//rotates Y about a center point by an amount of degrees
float RotatePointY(float x, float y, float centerX, float centerY, float degrees)
{
	if ( REVISED_ROTATEPOINT_Y_FUNCTION )
	{
		int distance = LargeDistance(centerX, centerY, x, y, 10);
		int angle = Angle(centerX, centerY, x, y);
		return centerY+VectorY(distance, angle+degrees);
	}
	else
	{
		float dx = x - centerX;
		float dy = y - centerY;
		return (Sin(degrees) * dx) - (Cos(degrees) * dy) + centerY;
	}
}

//S

//scales X to centerX by a given scale
float ScalePointX(float x, float centerX, float scale)
{
	return (scale * (x - centerX)) + centerX;
}

//scales Y to centerY by a given scale
float ScalePointY(float y, float centerY, float scale)
{
	return (scale * (y - centerY)) + centerY;
}

mapdata LoadMD(int map, int scr)
{
	if(map == Game->CurMap && scr == Game->CurScreen)
		return Game->LoadTempScreen(0);
	for(int lyr = 1; lyr < 7; ++lyr)
	{
		if(Screen->LayerMap[lyr] == map
			&& Screen->LayerScreen[lyr] == scr)
		{
			return Game->LoadTempScreen(lyr);
		}
	}
	return Game->LoadMapData(map,scr);
}

mapdata LoadMapDataDM(int dmap, int scr)
{
	dmapdata dm = Game->LoadDMapData(dmap);
	int v = (scr&0xF)+dm->Offset;
	if(v < 0 || v > 15)
		return NULL;
	return Game->LoadMapData(dm->Map, scr+dm->Offset);
}

//Copies the combos and csets from one screen to another.
//Only copies layer 0!
void ScreenCopy(int destmap, int destscr, int srcmap, int srcscr)
{
	mapdata destmd = LoadMD(destmap,destscr);
	mapdata srcmd = LoadMD(srcmap,srcscr);
	for (int i = 0; i < 176; ++i)
	{
		destmd->ComboD[i] = srcmd->ComboD[i];
		destmd->ComboC[i] = srcmd->ComboC[i];
	}
}


//Returns 1 if Screen Enemy Flag 'flag' is set from category 'category', 0 if it's not and -1 if an invalid flag is passed
//Flags are numbered starting from 0
int ScreenEFlag(int category, int flag)
{
	int catsizes[] = {SEFSP_LAST,SEFL1_LAST,SEFL2_LAST}; //this is what the editor shows.
	//int catsizes[] = {1,5,4}; //this is what ffscript seems to think, anyway.
	//int catsizes[] = {6,6,5}; //old value, plain wrong. -Z ( 12th February, 2019 )
	if(flag < 0 || flag >= catsizes[category]) return -1;
	return Screen->EFlags[category]&(1<<flag);
}

//Returns 1 if Screen Enemy Flag 'flag' is set from category 'category', 0 if it's not and -1 if an invalid flag is passed
//Flags are numbered starting from 0
int ScreenEFlag(int m, int scr, int category, int flag)
{
	mapdata md = Game->LoadMapData(m,scr);
	int catsizes[] = {SEFSP_LAST,SEFL1_LAST,SEFL2_LAST}; //this is what the editor shows.
	//int catsizes[] = {1,5,4}; //this is what ffscript seems to think, anyway.
	//int catsizes[] = {6,6,5}; //old value, plain wrong. -Z ( 12th February, 2019 )
	if(flag < 0 || flag >= catsizes[category]) return -1;
	return md->EFlags[category]&(1<<flag);
}

//Returns 1 if Screen Enemy Flag 'flag' is set from category 'category', 0 if it's not and -1 if an invalid flag is passed
//Flags are numbered starting from 0
int ScreenEFlag(mapdata md, int category, int flag)
{
	int catsizes[] = {SEFSP_LAST,SEFL1_LAST,SEFL2_LAST}; //this is what the editor shows.
	//int catsizes[] = {1,5,4}; //this is what ffscript seems to think, anyway.
	//int catsizes[] = {6,6,5}; //old value, plain wrong. -Z ( 12th February, 2019 )
	if(flag < 0 || flag >= catsizes[category]) return -1;
	return md->EFlags[category]&(1<<flag);
}

//Returns 1 if Screen Flag 'flag' is set from category 'category', 0 if it's not and -1 if an invalid flag is passed
//Flags are numbered starting from 0
int ScreenFlag(int category, int flag)
{
	int catsizes[] = {SFR_LAST,SFV_LAST,SFS_LAST,SFW_LAST,SFI_LAST,SFC_LAST,SFSV_LAST,SFF_LAST,SFWH_LAST,SFM_LAST}; //according to ffscript.cpp, the last flagset size is 3, but the editor is 7.
	//int catsizes[] = {3,7,5,3,2,4,4,2,3,7}; //old value, plain wrong -Z ( 12th February, 2019 )
	if(flag < 0 || flag >= catsizes[category]) return -1;
	return Screen->Flags[category]&(1<<flag);
}

//Returns 1 if Screen Flag 'flag' is set from category 'category', 0 if it's not and -1 if an invalid flag is passed
//Flags are numbered starting from 0
int ScreenFlag(int m, int scr, int category, int flag)
{
	mapdata md = Game->LoadMapData(m,scr);
	int catsizes[] = {SFR_LAST,SFV_LAST,SFS_LAST,SFW_LAST,SFI_LAST,SFC_LAST,SFSV_LAST,SFF_LAST,SFWH_LAST,SFM_LAST}; //according to ffscript.cpp, the last flagset size is 3, but the editor is 7.
	//int catsizes[] = {3,7,5,3,2,4,4,2,3,7}; //old value, plain wrong -Z ( 12th February, 2019 )
	if(flag < 0 || flag >= catsizes[category]) return -1;
	return md->Flags[category]&(1<<flag);
}

//Returns 1 if Screen Flag 'flag' is set from category 'category', 0 if it's not and -1 if an invalid flag is passed
//Flags are numbered starting from 0
int ScreenFlag(mapdata m, int category, int flag)
{
	int catsizes[] = {SFR_LAST,SFV_LAST,SFS_LAST,SFW_LAST,SFI_LAST,SFC_LAST,SFSV_LAST,SFF_LAST,SFWH_LAST,SFM_LAST}; //according to ffscript.cpp, the last flagset size is 3, but the editor is 7.
	//int catsizes[] = {3,7,5,3,2,4,4,2,3,7}; //old value, plain wrong -Z ( 12th February, 2019 )
	if(flag < 0 || flag >= catsizes[category]) return -1;
	return m->Flags[category]&(1<<flag);
}

//Returns the item ID for the current screen, if there is one.
int ScreenItem()
{
	if ( Screen->RoomType == RT_SPECIALITEM ) return Screen->RoomData;
	return -1;
}

//Sets certain DMap bitwise flags to 'state'
void SetDMapFlag(int dmap, int flag, bool state)
{
	dmapdata dm = Game->LoadDMapData(dmap);
	if(state) dm->Flags |= flag;
	else dm->Flags ~= flag;
}

//Writes items to both the A and the b item slots.
void SetEquipment(int a, int b)
{
	Link->Equipment = (((a&0xFF)|((b&0xFF)<<8)));
}

//Sets an item's Pickup state to 'state'
void SetItemPickup(item i, int pickup, bool state)
{
	if(state) i->Pickup |= pickup;
	else i->Pickup &= ~pickup;
}

//A shorthand way to set a cset on the current layer.
//Layer 0 is the screen itself.
void SetLayerComboC(int layer, int pos, int val)
{
	if (layer < 0 || layer > 6)
	{
		printf("Invalid layer %d passed to SetLayerComboC \n",layer);
		return;
	}

	Game->LoadTempScreen(layer)->ComboC[pos] = val;
}

//A shorthand way to set a combo on the current layer.
//Layer 0 is the screen itself.
void SetLayerComboD(int layer, int pos, int val)
{
	if (layer < 0 || layer > 6)
	{
		printf("Invalid layer %d passed to SetLayerComboD \n",layer);
		return;
	}

	Game->LoadTempScreen(layer)->ComboD[pos] = val;
}

//A shorthand way to set a combo on the current layer.
//Layer 0 is the screen itself.
void SetLayerComboF(int layer, int pos, int val)
{
	if (layer < 0 || layer > 6)
	{
		printf("Invalid layer %d passed to SetLayerComboF \n",layer);
		return;
	}

	Game->LoadTempScreen(layer)->ComboF[pos] = val;
}

//A shorthand way to set a combo on the current layer.
//Layer 0 is the screen itself.
void SetLayerComboI(int layer, int pos, int val)
{
	if (layer < 0 || layer > 6)
	{
		printf("Invalid layer %d passed to SetLayerComboI \n",layer);
		return;
	}

	Game->LoadTempScreen(layer)->ComboI[pos] = val;
}

//A shorthand way to set a combo on the current layer.
//Layer 0 is the screen itself.
void SetLayerComboS(int layer, int pos, int val)
{
	if (layer < 0 || layer > 6)
	{
		printf("Invalid layer %d passed to SetLayerComboS \n",layer);
		return;
	}

	Game->LoadTempScreen(layer)->ComboS[pos] = val;
}

//A shorthand way to set a combo on the current layer.
//Layer 0 is the screen itself.
void SetLayerComboT(int layer, int pos, int val)
{
	if (layer < 0 || layer > 6)
	{
		printf("Invalid layer %d passed to SetLayerComboT \n",layer);
		return;
	}

	Game->LoadTempScreen(layer)->ComboT[pos] = val;
}

//Gives or removes a level item from Link's inventory
void SetLevelItem(int level, int itm, bool state)
{
	if(state) Game->LItems[level] |= itm;
	else Game->LItems[level] &= ~itm;
}
void SetLevelItem(int itm, bool state)
{
	if(state) Game->LItems[Game->CurLevel] |= itm;
	else Game->LItems[Game->CurLevel] &= ~itm;
}

//Helper function to set mapdata->Flags[] bits.
//See the enum mapscreenflags for legal flags.
//Accepts a mapdata pointer.
void SetMapscreenFlag(mapdata m, mapscreenflags flagid, bool state)
{
	switch(flagid)
	{
		//0, flags
		case MSF_BLOCKSHUT:
			(state) ? (m->Flags[0] |=1) : (m->Flags[0] ~=1); break;
		case MSF_ENEMIES_ITEM:
			(state) ? (m->Flags[0] |=2) : (m->Flags[0] ~=2); break;
		case MSF_DARKROOM:
			(state) ? (m->Flags[0] |=4) : (m->Flags[0] ~=4); break;
		//8 IS A DUMMY PROC
		case MSF_STAIRS:
			(state) ? (m->Flags[0] |=16) : (m->Flags[0] ~=16); break;
		case MSF_ALLOW_LADDER:
			(state) ? (m->Flags[0] |=32) : (m->Flags[0] ~=32); break;
		case MSF_MAZEPATHS:
			(state) ? (m->Flags[0] |=64) : (m->Flags[0] ~=64); break;
		case MSF_SFXONENTRY:
			(state) ? (m->Flags[0] |=128) : (m->Flags[0] ~=128); break;

		//1, flags2
		//what, no 1?
		case MSF_MIDAIR:
			(state) ? (m->Flags[1] |=2>>4) : (m->Flags[1] ~=2>>4); break;
		case MSF_TRAPS_IGNORE_SOLID:
			(state) ? (m->Flags[1] |=4>>4) : (m->Flags[1] ~=4>>4); break;
		case MSF_ENEMEIS_SECRET:
			(state) ? (m->Flags[1] |=8>>4) : (m->Flags[1] ~=8>>4); break;

		//2, flags3
		case MSF_HOLDUP:
			(state) ? (m->Flags[2] |=1) : (m->Flags[2] ~=1); break;
		case MSF_CYCLEINIT:
			(state) ? (m->Flags[2] |=2) : (m->Flags[2] ~=2); break;
		case MSF_INVISIBLEENEMIES:
			(state) ? (m->Flags[2] |=4) : (m->Flags[2] ~=4); break;
		case MSF_INVISLINK:
			(state) ? (m->Flags[2] |=8) : (m->Flags[2] ~=8); break;
		case MSF_NOSUBSCREEN:
			(state) ? (m->Flags[2] |=16) : (m->Flags[2] ~=16); break;
		case MSF_SPRITECARRY:
			(state) ? (m->Flags[2] |=32) : (m->Flags[2] ~=32); break;
		case MSF_NOOFFSET:
			(state) ? (m->Flags[2] |=64) : (m->Flags[2] ~=64); break;
		case MSF_EMELIESALWAYSRETURN:
			(state) ? (m->Flags[2] |=128) : (m->Flags[2] ~=128); break;

		//3, flags4
		//1 AND 2 ARE APPARENTLY UNUSED?
		case MSF_DIRECTTIMEDWARPS:
			(state) ? (m->Flags[3] |=4) : (m->Flags[3] ~=4); break;
		case MSF_SECRETSISABLETIMEWRP:
			(state) ? (m->Flags[3] |=8) : (m->Flags[3] ~=8); break;
		case MSF_ENEMIES_SECRET_PERM:
			(state) ? (m->Flags[3] |=16) : (m->Flags[3] ~=16); break;
		//32 IS NOT USED
		case MSF_SAVECONTHERE:
			(state) ? (m->Flags[3] |=64) : (m->Flags[3] ~=64); break;
		case MSF_SAVEONENTRY:
			(state) ? (m->Flags[3] |=128) : (m->Flags[3] ~=128); break;

		//4, flags5
		//no 1?
		case MSF_RANDOMTIMEDWARP:
			(state) ? (m->Flags[4] |=1) : (m->Flags[4] ~=1); break;
		case MSF_IGNOREBOOTS:
			(state) ? (m->Flags[4] |=2) : (m->Flags[4] ~=2); break;
		case MSF_AUTODIRECT:
			(state) ? (m->Flags[4] |=4) : (m->Flags[4] ~=4); break;
		case MSF_SENDSIRECT:
			(state) ? (m->Flags[4] |=8) : (m->Flags[4] ~=8); break;
		case MSF_TEMPSECRETS:
			(state) ? (m->Flags[4] |=16) : (m->Flags[4] ~=16); break;
		//no 32?
		case MSF_NO_DIVING:
			(state) ? (m->Flags[4] |=64) : (m->Flags[4] ~=64); break;
		case MSF_NOCARRYOVERFFC:
			(state) ? (m->Flags[4] |=128) : (m->Flags[4] ~=128); break;


		//5, flags6
		case MSF_INTERIOR:
			(state) ? (m->Flags[5] |=1) : (m->Flags[5] ~=1); break;
		case MSF_DUNGEON:
			(state) ? (m->Flags[5] |=2) : (m->Flags[5] ~=2); break;
		case MSF_TRIGPERM:
			(state) ? (m->Flags[5] |=4) : (m->Flags[5] ~=4); break;
		case MSF_CONTHERE:
			(state) ? (m->Flags[5] |=8) : (m->Flags[5] ~=8); break;
		case MSF_NOCONTINUEWARP:
			(state) ? (m->Flags[5] |=16) : (m->Flags[5] ~=16); break;
		case MSF_ALLTRIGFLAGS:
			(state) ? (m->Flags[5] |=32) : (m->Flags[5] ~=32); break;
		case MSF_TOGGLERINGS:
			(state) ? (m->Flags[5] |=64) : (m->Flags[5] ~=64); break;
		case MSF_WRAPFFC:
			(state) ? (m->Flags[5] |=128) : (m->Flags[5] ~=128); break;

		//6, flags7
		case MSF_LAYER3BG:
			(state) ? (m->Flags[6] |=1) : (m->Flags[6] ~=1); break;
		case MSF_LAYER2BG:
			(state) ? (m->Flags[6] |=2) : (m->Flags[6] ~=2); break;
		case MSF_FALLS:
			(state) ? (m->Flags[6] |=4) : (m->Flags[6] ~=4); break;
		case MSF_SIDEVIEW:
			(state) ? (m->Flags[6] |=8) : (m->Flags[6] ~=8); break;
		case MSF_NOLINKMARKER:
			(state) ? (m->Flags[6] |=16) : (m->Flags[6] ~=16); break;
		//32 IS UNUSED
		case MSF_PALCHANGE:
			(state) ? (m->Flags[6] |=64) : (m->Flags[6] ~=64); break;
		case MSF_DRYLAKE:
			(state) ? (m->Flags[6] |=128) : (m->Flags[6] ~=128); break;

		//7, flags8
		case MSF_SCRIPT1:
			(state) ? (m->Flags[7] |=1) : (m->Flags[7] ~=1); break;
		case MSF_SCRIPT2:
			(state) ? (m->Flags[7] |=2) : (m->Flags[7] ~=2); break;
		case MSF_SCRIPT3:
			(state) ? (m->Flags[7] |=4) : (m->Flags[7] ~=4); break;
		case MSF_SCRIPT4:
			(state) ? (m->Flags[7] |=8) : (m->Flags[7] ~=8); break;
		case MSF_SCRIPT5:
			(state) ? (m->Flags[7] |=16) : (m->Flags[7] ~=16); break;
		case MSF_LENSEFFECT:
			(state) ? (m->Flags[7] |=32) : (m->Flags[7] ~=32); break;
		case MSF_MAZEOVERRIDE:
			(state) ? (m->Flags[7] |=64) : (m->Flags[7] ~=64); break;


		default:
		{
			printf("Invalid flag id (%d) passed to SetMapscreenFlag()\n", flagid);  break;
		}
	}
}

//Helper function to set mapdata->Flags[] bits.
//See the enum mapscreenflags for legal flags.
//Accepts a map ID, and a screen ID.
void SetMapscreenFlag(int mapid, int scr, mapscreenflags flagid, bool state)
{
	mapdata m = Game->LoadMapData(mapid, scr);
	switch(flagid)
	{
		//0, flags
		case MSF_BLOCKSHUT:
			(state) ? (m->Flags[0] |=1) : (m->Flags[0] ~=1); break;
		case MSF_ENEMIES_ITEM:
			(state) ? (m->Flags[0] |=2) : (m->Flags[0] ~=2); break;
		case MSF_DARKROOM:
			(state) ? (m->Flags[0] |=4) : (m->Flags[0] ~=4); break;
		//8 IS A DUMMY PROC
		case MSF_STAIRS:
			(state) ? (m->Flags[0] |=16) : (m->Flags[0] ~=16); break;
		case MSF_ALLOW_LADDER:
			(state) ? (m->Flags[0] |=32) : (m->Flags[0] ~=32); break;
		case MSF_MAZEPATHS:
			(state) ? (m->Flags[0] |=64) : (m->Flags[0] ~=64); break;
		case MSF_SFXONENTRY:
			(state) ? (m->Flags[0] |=128) : (m->Flags[0] ~=128); break;

		//1, flags2
		//what, no 1?
		case MSF_MIDAIR:
			(state) ? (m->Flags[1] |=2>>4) : (m->Flags[1] ~=2>>4); break;
		case MSF_TRAPS_IGNORE_SOLID:
			(state) ? (m->Flags[1] |=4>>4) : (m->Flags[1] ~=4>>4); break;
		case MSF_ENEMEIS_SECRET:
			(state) ? (m->Flags[1] |=8>>4) : (m->Flags[1] ~=8>>4); break;

		//2, flags3
		case MSF_HOLDUP:
			(state) ? (m->Flags[2] |=1) : (m->Flags[2] ~=1); break;
		case MSF_CYCLEINIT:
			(state) ? (m->Flags[2] |=2) : (m->Flags[2] ~=2); break;
		case MSF_INVISIBLEENEMIES:
			(state) ? (m->Flags[2] |=4) : (m->Flags[2] ~=4); break;
		case MSF_INVISLINK:
			(state) ? (m->Flags[2] |=8) : (m->Flags[2] ~=8); break;
		case MSF_NOSUBSCREEN:
			(state) ? (m->Flags[2] |=16) : (m->Flags[2] ~=16); break;
		case MSF_SPRITECARRY:
			(state) ? (m->Flags[2] |=32) : (m->Flags[2] ~=32); break;
		case MSF_NOOFFSET:
			(state) ? (m->Flags[2] |=64) : (m->Flags[2] ~=64); break;
		case MSF_EMELIESALWAYSRETURN:
			(state) ? (m->Flags[2] |=128) : (m->Flags[2] ~=128); break;

		//3, flags4
		//1 AND 2 ARE APPARENTLY UNUSED?
		case MSF_DIRECTTIMEDWARPS:
			(state) ? (m->Flags[3] |=4) : (m->Flags[3] ~=4); break;
		case MSF_SECRETSISABLETIMEWRP:
			(state) ? (m->Flags[3] |=8) : (m->Flags[3] ~=8); break;
		case MSF_ENEMIES_SECRET_PERM:
			(state) ? (m->Flags[3] |=16) : (m->Flags[3] ~=16); break;
		//32 IS NOT USED
		case MSF_SAVECONTHERE:
			(state) ? (m->Flags[3] |=64) : (m->Flags[3] ~=64); break;
		case MSF_SAVEONENTRY:
			(state) ? (m->Flags[3] |=128) : (m->Flags[3] ~=128); break;

		//4, flags5
		//no 1?
		case MSF_RANDOMTIMEDWARP:
			(state) ? (m->Flags[4] |=1) : (m->Flags[4] ~=1); break;
		case MSF_IGNOREBOOTS:
			(state) ? (m->Flags[4] |=2) : (m->Flags[4] ~=2); break;
		case MSF_AUTODIRECT:
			(state) ? (m->Flags[4] |=4) : (m->Flags[4] ~=4); break;
		case MSF_SENDSIRECT:
			(state) ? (m->Flags[4] |=8) : (m->Flags[4] ~=8); break;
		case MSF_TEMPSECRETS:
			(state) ? (m->Flags[4] |=16) : (m->Flags[4] ~=16); break;
		//no 32?
		case MSF_NO_DIVING:
			(state) ? (m->Flags[4] |=64) : (m->Flags[4] ~=64); break;
		case MSF_NOCARRYOVERFFC:
			(state) ? (m->Flags[4] |=128) : (m->Flags[4] ~=128); break;


		//5, flags6
		case MSF_INTERIOR:
			(state) ? (m->Flags[5] |=1) : (m->Flags[5] ~=1); break;
		case MSF_DUNGEON:
			(state) ? (m->Flags[5] |=2) : (m->Flags[5] ~=2); break;
		case MSF_TRIGPERM:
			(state) ? (m->Flags[5] |=4) : (m->Flags[5] ~=4); break;
		case MSF_CONTHERE:
			(state) ? (m->Flags[5] |=8) : (m->Flags[5] ~=8); break;
		case MSF_NOCONTINUEWARP:
			(state) ? (m->Flags[5] |=16) : (m->Flags[5] ~=16); break;
		case MSF_ALLTRIGFLAGS:
			(state) ? (m->Flags[5] |=32) : (m->Flags[5] ~=32); break;
		case MSF_TOGGLERINGS:
			(state) ? (m->Flags[5] |=64) : (m->Flags[5] ~=64); break;
		case MSF_WRAPFFC:
			(state) ? (m->Flags[5] |=128) : (m->Flags[5] ~=128); break;

		//6, flags7
		case MSF_LAYER3BG:
			(state) ? (m->Flags[6] |=1) : (m->Flags[6] ~=1); break;
		case MSF_LAYER2BG:
			(state) ? (m->Flags[6] |=2) : (m->Flags[6] ~=2); break;
		case MSF_FALLS:
			(state) ? (m->Flags[6] |=4) : (m->Flags[6] ~=4); break;
		case MSF_SIDEVIEW:
			(state) ? (m->Flags[6] |=8) : (m->Flags[6] ~=8); break;
		case MSF_NOLINKMARKER:
			(state) ? (m->Flags[6] |=16) : (m->Flags[6] ~=16); break;
		//32 IS UNUSED
		case MSF_PALCHANGE:
			(state) ? (m->Flags[6] |=64) : (m->Flags[6] ~=64); break;
		case MSF_DRYLAKE:
			(state) ? (m->Flags[6] |=128) : (m->Flags[6] ~=128); break;

		//7, flags8
		case MSF_SCRIPT1:
			(state) ? (m->Flags[7] |=1) : (m->Flags[7] ~=1); break;
		case MSF_SCRIPT2:
			(state) ? (m->Flags[7] |=2) : (m->Flags[7] ~=2); break;
		case MSF_SCRIPT3:
			(state) ? (m->Flags[7] |=4) : (m->Flags[7] ~=4); break;
		case MSF_SCRIPT4:
			(state) ? (m->Flags[7] |=8) : (m->Flags[7] ~=8); break;
		case MSF_SCRIPT5:
			(state) ? (m->Flags[7] |=16) : (m->Flags[7] ~=16); break;
		case MSF_LENSEFFECT:
			(state) ? (m->Flags[7] |=32) : (m->Flags[7] ~=32); break;
		case MSF_MAZEOVERRIDE:
			(state) ? (m->Flags[7] |=64) : (m->Flags[7] ~=64); break;


		default:
		{
			printf("Invalid flag id (%d) passed to SetMapscreenFlag()\n", flagid);  break;
		}
	}
}

//Sets bit 'bit' of Screen->D[] register 'd' to 'state'
void SetScreenDBit(int dmap, int screen, int d, int bit, bool state)
{
	int curstate = Game->GetDMapScreenD(dmap, screen, d);
	if(state)	Game->SetDMapScreenD(dmap, screen, d, curstate |  (1L << bit));
	else 		Game->SetDMapScreenD(dmap, screen, d, curstate & ~(1L << bit));
}
void SetScreenDBit(int screen, int d, int bit, bool state)
{
	int curstate = Game->GetScreenD(screen, d);
	if(state)	Game->SetScreenD(screen, d, curstate |  (1L << bit));
	else 		Game->SetScreenD(screen, d, curstate & ~(1L << bit));
}
void SetScreenDBit(int d, int bit, bool state)
{
	if(state)	Screen->D[d] |= (1L << bit);
	else		Screen->D[d] &= ~(1L << bit);
}

//Sets if a screen is visible on the passive subscreen minimap.
//Works on the current screen, on the current DMap.
//Respects DMap Offsets.
void SetVisibleOnDungeonMap(bool state)
{
	dmapdata dm = Game->LoadDMapData(Game->CurDMap);
	int scr = Game->CurScreen;
	int col = (scr % 0x10)-dm->Offset;
	int row = (scr>>4);
	//screen-dm->Offset;
	//could get screen X and Y from curscreen and dmapoffset in a separate function
	(state) ? (dm->Grid[row] |= ((128>>col))) : (dm->Grid[row] ~= ((128>>col)));
}

//Sets if a screen is visible on the passive subscreen minimap.
//Works on a specified screen, on the current DMap.
//Respects DMap Offsets.
void SetVisibleOnDungeonMap(int scr, bool state)
{
	dmapdata dm = Game->LoadDMapData(Game->CurDMap);
	int col = (scr % 0x10)-dm->Offset;
	int row = (scr>>4);
	(state) ? (dm->Grid[row] |= ((128>>col))) : (dm->Grid[row] ~= ((128>>col)));
}

//Sets if a screen is visible on the passive subscreen minimap.
//Works on the current screen, on a specified DMap, passed as a dmapdata pointer.
//Respects DMap Offsets.
void SetVisibleOnDungeonMap(dmapdata dm, bool state)
{
	int scr = Game->CurScreen;
	int col = (scr % 0x10)-dm->Offset;
	int row = (scr>>4);
	(state) ? (dm->Grid[row] |= ((128>>col))) : (dm->Grid[row] ~= ((128>>col)));
}

//Sets if a screen is visible on the passive subscreen minimap.
//Works on a specified screen, on a specified DMap, passed as a dmapdata pointer.
//Respects DMap Offsets.
void SetVisibleOnDungeonMap(dmapdata dm, int scr, bool state)
{
	int col = (scr % 0x10)-dm->Offset;
	int row = (scr>>4);
	(state) ? (dm->Grid[row] |= ((128>>col))) : (dm->Grid[row] ~= ((128>>col)));
}

//Sets if a screen is visible on the passive subscreen minimap.
//Accepts the screen X and Y on a grid of 8x8, on a specified DMap, passed as a dmapdata pointer.
//Offsets are immaterial, as this is direct Grid[] access with x,y of the 8x8 grid.
void SetVisibleOnDungeonMap(dmapdata dm, int x, int y, bool state)
{
	//could get screen X and Y from curscreen and dmapoffset in a separate function
	(state) ? (dm->Grid[y] |= (128>>x)) : (dm->Grid[y] ~= (128>>x));
}

//Sets if a screen is visible on the passive subscreen minimap.
//Works on the current screen, on the current DMap.
//If bool no_offset is set true, the screen position ignores DMap offsets.
void SetVisibleOnDungeonMap(bool no_offset, bool state)
{
	dmapdata dm = Game->LoadDMapData(Game->CurDMap);
	int scr = Game->CurScreen;
	int col = (scr % 0x10) - (no_offset ? 0 : dm->Offset);
	int row = (scr>>4);
	//screen-dm->Offset;
	//could get screen X and Y from curscreen and dmapoffset in a separate function
	(state) ? (dm->Grid[row] |= ((128>>col))) : (dm->Grid[row] ~= ((128>>col)));
}

//Sets if a screen is visible on the passive subscreen minimap.
//Works on a specified screen, on the current DMap.
//If bool no_offset is set true, the screen position ignores DMap offsets.
void SetVisibleOnDungeonMap(int scr, bool no_offset, bool state)
{
	dmapdata dm = Game->LoadDMapData(Game->CurDMap);
	int col = (scr % 0x10) - (no_offset ? 0 : dm->Offset);
	int row = (scr>>4);
	(state) ? (dm->Grid[row] |= ((128>>col))) : (dm->Grid[row] ~= ((128>>col)));
}

//Sets if a screen is visible on the passive subscreen minimap.
//Works on the current screen, on a specified DMap, passed as a dmapdata pointer.
//If bool no_offset is set true, the screen position ignores DMap offsets.
void SetVisibleOnDungeonMap(dmapdata dm, bool no_offset, bool state)
{
	int scr = Game->CurScreen;
	int col = (scr % 0x10) - (no_offset ? 0 : dm->Offset);
	int row = (scr>>4);
	(state) ? (dm->Grid[row] |= ((128>>col))) : (dm->Grid[row] ~= ((128>>col)));
}

//Sets if a screen is visible on the passive subscreen minimap.
//Works on a specified screen, on a specified DMap, passed as a dmapdata pointer.
//If bool no_offset is set true, the screen position ignores DMap offsets.
void SetVisibleOnDungeonMap(dmapdata dm, int scr, bool no_offset, bool state)
{
	int col = (scr % 0x10) - (no_offset ? 0 : dm->Offset);
	int row = (scr>>4);
	(state) ? (dm->Grid[row] |= ((128>>col))) : (dm->Grid[row] ~= ((128>>col)));
}

//Returns the sign of n
int Sign(int n)
{
	if (n > 0) return 1;
	else if (n < 0) return -1;
	else return 0;
}

// Performs a "Smooth" Interpolation given 't' clamped within range 0,1.
float SmoothStep(float p1, float p2, float t)
{
	t = (t * t) * (3.0 - (2.0 * t));
	return Lerp(p1, p2, t);
}

//Converts directions to go round in a circle rather than U, D, L, R
int SpinDir(int dir)
{
	switch(dir)
	{
		case DIR_UP:
			return DIR_RIGHT;
		case DIR_RIGHT:
			return DIR_DOWN;
		case DIR_DOWN:
			return DIR_LEFT;
		case DIR_LEFT:
			return DIR_UP;

		case DIR2_UP:
			return DIR2_RIGHT;
		case DIR2_RIGHT:
			return DIR2_DOWN;
		case DIR2_DOWN:
			return DIR2_LEFT;
		case DIR2_LEFT:
			return DIR2_UP;
		default: return -1;
	}
}
int SpinDir8(int dir)
{
	switch(dir)
	{
		case DIR_UP:
			return DIR_RIGHTUP;
		case DIR_RIGHTUP:
			return DIR_RIGHT;
		case DIR_RIGHT:
			return DIR_RIGHTDOWN;
		case DIR_RIGHTDOWN:
			return DIR_DOWN;
		case DIR_DOWN:
			return DIR_LEFTDOWN;
		case DIR_LEFTDOWN:
			return DIR_LEFT;
		case DIR_LEFT:
			return DIR_LEFTUP;
		case DIR_LEFTUP:
			return DIR_UP;
		case DIR2_UP...DIR2_LEFTUP:
			return 8+((dir+1)%8);
		default: return -1;
	}
}

//Check for collisions of two squares given upper-left coordinates and a side length for each.
bool SquareCollision(int c1x, int c1y, int side1, int c2x, int c2y, int side2)
{
	return RectCollision(c1x, c1y, c1x+side1, c1y+side1, c2x, c2y, c2x+side2, c2y+side2);
}

//Check for collisions of two squares given center coordinates and a halved side length for each.
bool SquareCollision2(int c1x, int c1y, int radius1, int c2x, int c2y, int radius2)
{
	if( c1y + radius1 < c2y - radius2 ) return false;
	else if( c1y - radius1 > c2y + radius2 ) return false;
	else if( c1x + radius1 < c2x - radius2 ) return false;
	else if( c1x - radius1 > c2x + radius2 ) return false;
	return true;
}

//Swaps a block of tiles defined by diagonal corners 'first' and 'last'
//with the block starting with top left tile 'second'
void SwapTileBlock(int first, int last, int second)
{
	if(last < first){
		int swap = first;
		first = last;
		last = swap;
	}
	int w = last%20-first%20;
	if(w < 0){
		first -= w;
		last += w;
		w = -w;
	}
	for(int i=0;i<=last-first;++i) if(i%20 <= w) SwapTile(first+i,second+i);
}

//Swaps a row of tiles of length 'length' between positions 'first' and 'second'
void SwapTileRow(int first, int second, int length)
{
	for(int i=0;i<length;++i) SwapTile(first+i,second+i);
}

//T

// Returns an angle pointing (t)percentage more accurate to the target than the specified radian_angle.
float TurnTowards( int X, int Y, int targetX, int targetY, float radian_angle, float t = 1.0 )
{
	float a = ArcTan( targetX - X, targetY - Y );
	float d = WrapAngle(a - radian_angle);
	if ( d > PI )
		d =-( PI2 - d );
	else if ( d < -PI )
		d = PI2 + d;
	return WrapAngle(radian_angle + d * t);
}

//U

//Returns true if Hero is using item 'id'
bool UsingItem(int id)
{
	return (GetEquipmentA() == id && Hero->InputA)
		|| (GetEquipmentB() == id && Hero->InputB)
		|| (GetEquipmentX() == id && Hero->InputEx1)
		|| (GetEquipmentY() == id && Hero->InputEx2);
}

//V

float vbound(int x, int high, int low)
{
        if ( high < low ) //if high is less than low, invert them
	{
		high = high ^ low;
		low = high ^ low;
		high = high ^ low;
	}
	if(x<low) x=low;
	else if(x>high) x=high;
	return x;
}

//same as Clamp, but with reversed values.
int VBound(int x, int high, int low)
{
	if(x<low) x=low;
	else if(x>high) x=high;
	return x;
}

// Returns the X component of a vector with a degree angle.
// A length of 3 and angle of 0 returns 3.
// A length of 3 and angle of 45 returns approx. 1.57.
// A length of 3 and angle of 90 returns 0.
float VectorX(int len, float angle)
{
	return Cos(angle)*len;
}

// Returns the Y component of a vector with a degree angle.
// A length of 3 and angle of 0 returns 0.
// A length of 3 and angle of 45 returns approx. 1.57.
// A length of 3 and angle of 90 returns 3.
float VectorY(int len, float angle)
{
	return Sin(angle)*len;
}

//Returns if a screen is visible on the passive subscreen minimap.
//Accepts the X and Y positions of a screen, where X and Y are 0 to 8.
bool VisibleOnDungeonMap(int x, int y)
{
	dmapdata dm = Game->LoadDMapData(Game->CurDMap);
	return (dm->Grid[y]&(128>>x));
}

//Returns if a screen is visible on the passive subscreen minimap.
//Uses the current screen.
bool VisibleOnDungeonMap()
{
	dmapdata dm = Game->LoadDMapData(Game->CurDMap);
	int scr = Game->CurScreen;
	int col = (scr % 0x10)-dm->Offset;
	int row = (scr>>4);
	//screen-dm->Offset;
	//could get screen X and Y from curscreen and dmapoffset in a separate function
	return (dm->Grid[row]&((128>>col)));
}

//Returns if a screen is visible on the passive subscreen minimap.
//Accepts a specific screen ID for the current dmap.
bool VisibleOnDungeonMap(int scr)
{
	dmapdata dm = Game->LoadDMapData(Game->CurDMap);
	int col = (scr % 0x10)-dm->Offset;
	int row = (scr>>4);
	return (dm->Grid[row]&((128>>col)));
}

//Returns if a screen is visible on the passive subscreen minimap.
//Uses the current screen on a dmapdata pointer.
bool VisibleOnDungeonMap(dmapdata dm)
{
	int scr = Game->CurScreen;
	int col = (scr % 0x10)-dm->Offset;
	int row = (scr>>4);
	return (dm->Grid[row]&((128>>col)));
}

//Returns if a screen is visible on the passive subscreen minimap.
//Accepts a specific screen ID on a specified dmapdata pointer.
bool VisibleOnDungeonMap(dmapdata dm, int scr)
{
	int col = (scr % 0x10)-dm->Offset;
	int row = (scr>>4);
	return (dm->Grid[row]&((128>>col)));
}

//Returns if a screen is visible on the passive subscreen minimap.
//Accepts the X and Y positions of a screen, where X and Y are 0 to 8,
//using a specified dmapdata pointer.
bool VisibleOnDungeonMap(dmapdata dm, int x, int y)
{
	//could get screen X and Y from curscreen and dmapoffset in a separate function
	return (dm->Grid[y]&(128>>x));
}

//Returns if a screen is visible on the passive subscreen minimap.
//Accepts the X and Y positions of a screen, where X and Y are 0 to 8.
//If bool no_offset is set true, the screen position ignores DMap offsets.
bool VisibleOnDungeonMap(bool no_offset)
{
	dmapdata dm = Game->LoadDMapData(Game->CurDMap);
	int scr = Game->CurScreen;
	int col = (scr % 0x10) - (no_offset ? 0 : dm->Offset);
	int row = (scr>>4);
	//screen-dm->Offset;
	//could get screen X and Y from curscreen and dmapoffset in a separate function
	return (dm->Grid[row]&((128>>col)));
}

//Returns if a screen is visible on the passive subscreen minimap.
//Uses the current screen.
//If bool no_offset is set true, the screen position ignores DMap offsets.
bool VisibleOnDungeonMap(int scr, bool no_offset)
{
	dmapdata dm = Game->LoadDMapData(Game->CurDMap);
	int col = (scr % 0x10) - (no_offset ? 0 : dm->Offset);
	int row = (scr>>4);
	return (dm->Grid[row]&((128>>col)));
}

//Returns if a screen is visible on the passive subscreen minimap.
//Accepts a specific screen ID for the current dmap.
//If bool no_offset is set true, the screen position ignores DMap offsets.
bool VisibleOnDungeonMap(dmapdata dm, bool no_offset)
{
	int scr = Game->CurScreen;
	int col = (scr % 0x10) - (no_offset ? 0 : dm->Offset);
	int row = (scr>>4);
	return (dm->Grid[row]&((128>>col)));
}

//Returns if a screen is visible on the passive subscreen minimap.
//Uses the current screen on a dmapdata pointer.
//If bool no_offset is set true, the screen position ignores DMap offsets.
bool VisibleOnDungeonMap(dmapdata dm, int scr, bool no_offset)
{
	int col = (scr % 0x10) - (no_offset ? 0 : dm->Offset);
	int row = (scr>>4);
	return (dm->Grid[row]&((128>>col)));
}

//Sets if a screen is visible on the passive subscreen minimap.
//Accepts the screen X and Y on a grid of 8x8, on the current DMap.
//Offsets are immaterial, as this is direct Grid[] access with x,y of the 8x8 grid.
void SetVisibleOnDungeonMap(int x, int y, bool state)
{
	dmapdata dm = Game->LoadDMapData(Game->CurDMap);
	(state) ? (dm->Grid[y] |= (128>>x)) : (dm->Grid[y] ~= (128>>x));
}

//NoAction, then Waitframe or (equivalent of) Waitframes
void WaitNoAction()
{
	NoAction();
	Waitframe();
}
void WaitNoAction(int frames)
{
	while(frames-- > 0)
		WaitNoAction();
}

//Turns a WPN_ constant to an EW_ constant
int WeaponTypeToID(int wpnt)
{
	switch(wpnt)
	{
		case WPN_ENEMYFLAME: 		return EW_FIRE;
		case WPN_ENEMYWIND:		return EW_WIND;
		case WPN_ENEMYFIREBALL:		return EW_FIREBALL;
		case WPN_ENEMYARROW:		return EW_ARROW;
		case WPN_ENEMYBRANG:		return EW_BRANG;
		case WPN_ENEMYSWORD:		return EW_BEAM;
		case WPN_ENEMYROCK:		return EW_ROCK;
		case WPN_ENEMYMAGIC:		return EW_MAGIC;
		case WPN_ENEMYBOMB:		return EW_BOMBBLAST; //flipped bomb and lit bomb in older versions of this file. -Z ( 12th February, 2019 )
		case WPN_ENEMYSBOMB:		return EW_SBOMBBLAST;
		case WPN_ENEMYLITBOMB:		return EW_BOMB;
		case WPN_ENEMYLITSBOMB:		return EW_SBOMB;
		case WPN_ENEMYFIRETRAIL:	return EW_FIRETRAIL;
		case WPN_ENEMYFLAME2:		return EW_FIRE2;
		case WPN_ENEMYFIREBALL2:	return EW_FIREBALL2;
		default: { printf("No valid match for wpnt %d provided to WeaponTypeToID \n", wpnt); return -1; }
	}
}

namespace std
{
	//Returns the distance between two sets of coordinates using Pythagoras' Theorem
	float Distance(int x1, int y1, int x2, int y2)
	{
		int x = (x1-x2);
		int y = (y1-y2);
		return Sqrt(x*x+y*y);
	}// Chooses one of the options randomly and fairly.

	float Choose(float a, float b)
	{
		return ( (!Rand(2)) ? a : b );
	}

	float Choose(float a, float b, float c)
	{
		int r = Rand(3);
		switch(r)
		{
			case 0: return a;
			case 1: return b;
			default: return c;
		}
	}

	float Choose(float a, float b, float c, float d)
	{
		int r = Rand(4);
		switch(r)
		{
			case 0: return a;
			case 1: return b;
			case 2: return c;
			default: return d;
		}
	}

	float Choose(float a, float b, float c, float d, float e)
	{
		int r = Rand(5);
		switch(r)
		{
			case 0: return a;
			case 1: return b;
			case 2: return c;
			case 3: return d;
			default: return e;
		}
	}

	float Choose(float a, float b, float c, float d, float e, float f)
	{
		int r = Rand(6);
		switch(r)
		{
			case 0: return a;
			case 1: return b;
			case 2: return c;
			case 3: return d;
			case 4: return e;
			default: return f;
		}
	}
	////clkptr is an array, sized at least [1], frames is the duration on/off, so, 10 would be on for ten frames, then off for ten frames
	bool blink(int[] clkptr, int frames)
	{
	    const int clkIindx = 0;
	    clkptr[clkIindx] = (clkptr[clkIindx]+1)%(frames<<1);
	    return( clkptr[clkIindx]&frames );
	}
}

void getScrTimeName(char32[] buf, int scrtime)
{
	switch(scrtime)
	{
		case SCR_TIMING_START_FRAME:
			strcpy(buf, "SCR_TIMING_START_FRAME");
			break;
		case SCR_TIMING_POST_COMBO_ANIM:
			strcpy(buf, "SCR_TIMING_POST_COMBO_ANIM");
			break;
		case SCR_TIMING_POST_POLL_INPUT:
			strcpy(buf, "SCR_TIMING_POST_POLL_INPUT");
			break;
		case SCR_TIMING_POST_FFCS:
			strcpy(buf, "SCR_TIMING_POST_FFCS");
			break;
		case SCR_TIMING_POST_GLOBAL_ACTIVE:
			strcpy(buf, "SCR_TIMING_POST_GLOBAL_ACTIVE");
			break;
		case SCR_TIMING_POST_PLAYER_ACTIVE:
			strcpy(buf, "SCR_TIMING_POST_PLAYER_ACTIVE");
			break;
		case SCR_TIMING_POST_DMAPDATA_ACTIVE:
			strcpy(buf, "SCR_TIMING_POST_DMAPDATA_ACTIVE");
			break;
		case SCR_TIMING_POST_DMAPDATA_PASSIVESUBSCREEN:
			strcpy(buf, "SCR_TIMING_POST_DMAPDATA_PASSIVESUBSCREEN");
			break;
		case SCR_TIMING_POST_COMBOSCRIPT:
			strcpy(buf, "SCR_TIMING_POST_COMBOSCRIPT");
			break;
		case SCR_TIMING_POST_PUSHBLOCK:
			strcpy(buf, "SCR_TIMING_POST_PUSHBLOCK");
			break;
		case SCR_TIMING_POST_ITEMSPRITE_SCRIPT:
			strcpy(buf, "SCR_TIMING_POST_ITEMSPRITE_SCRIPT");
			break;
		case SCR_TIMING_POST_ITEMSPRITE_ANIMATE:
			strcpy(buf, "SCR_TIMING_POST_ITEMSPRITE_ANIMATE");
			break;
		case SCR_TIMING_POST_NPC_ANIMATE:
			strcpy(buf, "SCR_TIMING_POST_NPC_ANIMATE");
			break;
		case SCR_TIMING_POST_EWPN_ANIMATE:
			strcpy(buf, "SCR_TIMING_POST_EWPN_ANIMATE");
			break;
		case SCR_TIMING_POST_EWPN_SCRIPT:
			strcpy(buf, "SCR_TIMING_POST_EWPN_SCRIPT");
			break;
		case SCR_TIMING_POST_OLD_ITEMDATA_SCRIPT:
			strcpy(buf, "SCR_TIMING_POST_OLD_ITEMDATA_SCRIPT");
			break;
		case SCR_TIMING_POST_PLAYER_ANIMATE:
			strcpy(buf, "SCR_TIMING_POST_PLAYER_ANIMATE");
			break;
		case SCR_TIMING_POST_NEW_ITEMDATA_SCRIPT:
			strcpy(buf, "SCR_TIMING_POST_NEW_ITEMDATA_SCRIPT");
			break;
		case SCR_TIMING_POST_CASTING:
			strcpy(buf, "SCR_TIMING_POST_CASTING");
			break;
		case SCR_TIMING_POST_LWPN_ANIMATE:
			strcpy(buf, "SCR_TIMING_POST_LWPN_ANIMATE");
			break;
		case SCR_TIMING_POST_DECOPARTICLE_ANIMATE:
			strcpy(buf, "SCR_TIMING_POST_DECOPARTICLE_ANIMATE");
			break;
		case SCR_TIMING_POST_COLLISIONS_PALETTECYCLE:
			strcpy(buf, "SCR_TIMING_POST_COLLISIONS_PALETTECYCLE");
			break;
		case SCR_TIMING_WAITDRAW:
			strcpy(buf, "SCR_TIMING_WAITDRAW");
			break;
		case SCR_TIMING_POST_GLOBAL_WAITDRAW:
			strcpy(buf, "SCR_TIMING_POST_GLOBAL_WAITDRAW");
			break;
		case SCR_TIMING_POST_PLAYER_WAITDRAW:
			strcpy(buf, "SCR_TIMING_POST_PLAYER_WAITDRAW");
			break;
		case SCR_TIMING_POST_DMAPDATA_ACTIVE_WAITDRAW:
			strcpy(buf, "SCR_TIMING_POST_DMAPDATA_ACTIVE_WAITDRAW");
			break;
		case SCR_TIMING_POST_DMAPDATA_PASSIVESUBSCREEN_WAITDRAW:
			strcpy(buf, "SCR_TIMING_POST_DMAPDATA_PASSIVESUBSCREEN_WAITDRAW");
			break;
		case SCR_TIMING_POST_SCREEN_WAITDRAW:
			strcpy(buf, "SCR_TIMING_POST_SCREEN_WAITDRAW");
			break;
		case SCR_TIMING_POST_FFC_WAITDRAW:
			strcpy(buf, "SCR_TIMING_POST_FFC_WAITDRAW");
			break;
		case SCR_TIMING_POST_COMBO_WAITDRAW:
			strcpy(buf, "SCR_TIMING_POST_COMBO_WAITDRAW");
			break;
		case SCR_TIMING_POST_ITEM_WAITDRAW:
			strcpy(buf, "SCR_TIMING_POST_ITEM_WAITDRAW");
			break;
		case SCR_TIMING_POST_NPC_WAITDRAW:
			strcpy(buf, "SCR_TIMING_POST_NPC_WAITDRAW");
			break;
		case SCR_TIMING_POST_EWPN_WAITDRAW:
			strcpy(buf, "SCR_TIMING_POST_EWPN_WAITDRAW");
			break;
		case SCR_TIMING_POST_LWPN_WAITDRAW:
			strcpy(buf, "SCR_TIMING_POST_LWPN_WAITDRAW");
			break;
		case SCR_TIMING_POST_ITEMSPRITE_WAITDRAW:
			strcpy(buf, "SCR_TIMING_POST_ITEMSPRITE_WAITDRAW");
			break;
		case SCR_TIMING_PRE_DRAW:
			strcpy(buf, "SCR_TIMING_PRE_DRAW");
			break;
		case SCR_TIMING_POST_DRAW:
			strcpy(buf, "SCR_TIMING_POST_DRAW");
			break;
		case SCR_TIMING_POST_STRINGS:
			strcpy(buf, "SCR_TIMING_POST_STRINGS");
			break;
		case SCR_TIMING_END_FRAME:
			strcpy(buf, "SCR_TIMING_END_FRAME");
			break;
		//(SCR_TIMING_[^,]+),
		//\t\tcase $1:\r\n\t\t\tstrcpy\(buf, "$1"\);\r\n\t\t\tbreak;\r\n
	}
}

//Wrap a value between 0 and a bound
untyped wrap(untyped x, int mod)
{
    if(x < 0)
        return (mod-(-x%mod))%mod;
    return x%mod;
}

eweapon FireEWeaponAngle(int type, int x, int y, int radians, int step, int dmg, int sprite = -1, int sfx = 0, int scriptid = 0, untyped[] args = NULL)
{
	eweapon weap = scriptid ? RunEWeaponScriptAt(type, scriptid, x, y, args) : CreateEWeaponAt(type,x,y);
	weap->Damage = dmg;
	weap->Step = step;
	if(sprite > -1) weap->UseSprite(sprite);
	if(sfx) Audio->PlaySound(sfx);
	
	weap->Angle = radians;
	weap->Angular = true;
	weap->Dir = AngleDir8(weap->DegAngle); //For shields
	return weap;
}
eweapon FireEWeaponDegAngle(int type, int x, int y, int degrees, int step, int dmg, int sprite = -1, int sfx = 0, int scriptid = 0, untyped[] args = NULL)
{
	eweapon weap = scriptid ? RunEWeaponScriptAt(type, scriptid, x, y, args) : CreateEWeaponAt(type,x,y);
	weap->Damage = dmg;
	weap->Step = step;
	if(sprite > -1) weap->UseSprite(sprite);
	if(sfx) Audio->PlaySound(sfx);
	
	weap->DegAngle = degrees;
	weap->Angular = true;
	weap->Dir = AngleDir8(degrees); //For shields
	return weap;
}
eweapon FireEWeaponDir(int type, int x, int y, int dir, int step, int dmg, int sprite = -1, int sfx = 0, int scriptid = 0, untyped[] args = NULL)
{
	eweapon weap = scriptid ? RunEWeaponScriptAt(type, scriptid, x, y, args) : CreateEWeaponAt(type,x,y);
	weap->Damage = dmg;
	weap->Step = step;
	if(sprite > -1) weap->UseSprite(sprite);
	if(sfx) Audio->PlaySound(sfx);
	
	weap->Dir = dir;
	return weap;
}
eweapon FireEWeaponAtHero(int type, int x, int y, bool angular, int step, int dmg, int sprite = -1, int sfx = 0, int scriptid = 0, untyped[] args = NULL)
{
	eweapon weap = scriptid ? RunEWeaponScriptAt(type, scriptid, x, y, args) : CreateEWeaponAt(type,x,y);
	weap->Damage = dmg;
	weap->Step = step;
	if(sprite > -1) weap->UseSprite(sprite);
	if(sfx) Audio->PlaySound(sfx);
	
	weap->Angular = angular;
	int degrees = Angle(x,y,Hero->X,Hero->Y);
	if(angular)
		weap->DegAngle = degrees;
	weap->Dir = AngleDir8(degrees);
	return weap;
}

lweapon FireLWeaponAngle(int type, int x, int y, int radians, int step, int dmg, int sprite = -1, int sfx = 0, int scriptid = 0, untyped[] args = NULL)
{
	lweapon weap = scriptid ? RunLWeaponScriptAt(type, scriptid, x, y, args) : CreateLWeaponAt(type,x,y);
	weap->Damage = dmg;
	weap->Step = step;
	if(sprite > -1) weap->UseSprite(sprite);
	if(sfx) Audio->PlaySound(sfx);
	
	weap->Angle = radians;
	weap->Angular = true;
	weap->Dir = AngleDir8(weap->DegAngle); //For shields
	return weap;
}
lweapon FireLWeaponDegAngle(int type, int x, int y, int degrees, int step, int dmg, int sprite = -1, int sfx = 0, int scriptid = 0, untyped[] args = NULL)
{
	lweapon weap = scriptid ? RunLWeaponScriptAt(type, scriptid, x, y, args) : CreateLWeaponAt(type,x,y);
	weap->Damage = dmg;
	weap->Step = step;
	if(sprite > -1) weap->UseSprite(sprite);
	if(sfx) Audio->PlaySound(sfx);
	
	weap->DegAngle = degrees;
	weap->Angular = true;
	weap->Dir = AngleDir8(degrees); //For shields
	return weap;
}
lweapon FireLWeaponDir(int type, int x, int y, int dir, int step, int dmg, int sprite = -1, int sfx = 0, int scriptid = 0, untyped[] args = NULL)
{
	lweapon weap = scriptid ? RunLWeaponScriptAt(type, scriptid, x, y, args) : CreateLWeaponAt(type,x,y);
	weap->Damage = dmg;
	weap->Step = step;
	if(sprite > -1) weap->UseSprite(sprite);
	if(sfx) Audio->PlaySound(sfx);
	
	weap->Dir = dir;
	return weap;
}

//Gets a switch state for a given level
bool GetLevelSwitchState(int level, int switchNum)
{
    if(level < 0 || level >= NUM_LEVELS || switchNum < 0 || switchNum > 31)
        return false;
    return Game->LSwitches[level]&(1Lb<<switchNum);
}

//Sets or unsets a switch state for a given level
void SetLevelSwitchState(int level, int switchNum, bool state)
{
    if(level < 0 || level >= NUM_LEVELS) printf("Invalid level (%d) passed to SetLevelSwitchState()\n", level);
    else if(switchNum < 0 || switchNum > 31) printf("Invalid switchNum (%d) passed to SetLevelSwitchState()\n", switchNum);
    else if(state) Game->LSwitches[level] |= (1Lb<<switchNum);
    else Game->LSwitches[level] ~= (1Lb<<switchNum);
}


