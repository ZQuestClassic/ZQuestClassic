 /@@@@@@@@  /@@@@@@                      /@@             /@@
|_____ @@  /@@__  @@                    |__/            | @@
     /@@/ | @@  \__/  /@@@@@@@  /@@@@@@  /@@  /@@@@@@  /@@@@@@
    /@@/  |  @@@@@@  /@@_____/ /@@__  @@| @@ /@@__  @@|_  @@_/
   /@@/    \____  @@| @@      | @@  \__/| @@| @@  \ @@  | @@
  /@@/     /@@  \ @@| @@      | @@      | @@| @@  | @@  | @@ /@@
 /@@@@@@@@|  @@@@@@/|  @@@@@@@| @@      | @@| @@@@@@@/  |  @@@@/
|________/ \______/  \_______/|__/      |__/| @@____/    \___/
                                            | @@                                                 
                                            | @@                                                 
                                            |__/                                                 


The following documents the changes, and expansions to the ZScript language in ZC 
	versions 2.55+


 __           _   _                 
/ _\ ___  ___| |_(_) ___  _ __  ___ 
\ \ / _ \/ __| __| |/ _ \| '_ \/ __|
_\ \  __/ (__| |_| | (_) | | | \__ \
\__/\___|\___|\__|_|\___/|_| |_|___/
                                    
1. Syntax
2. Namespaces
3. Global Pointers
4. Datatypes
5. Typedef
6. Custom Datatypes & Enum
7. Arrays
8. Strings
9. New Features
10. Bugfixes
11. Script Types
12. Compiler
13. New Instructions
14. System and Script Timing and Execution Order

////////////////////////////////////////////////////
/// ZSCRIPT PARSER AND LEXER ///////////////////////
////////////////////////////////////////////////////

  _________             __                 
 /   _____/__.__. _____/  |______  ___  ___
 \_____  <   |  |/    \   __\__  \ \  \/  /
 /        \___  |   |  \  |  / __ \_>    < 
/_______  / ____|___|  /__| (____  /__/\_ \
        \/\/         \/          \/      \/

									// Syntax

////////////
// Tokens //
////////////

The ZScript parser supports the following standard and alternative tokens:

//Operational
+		:	Addition
-		: 	Subtraction
*		:	Multiplication
/		:	Division
^^^		:	Power (ex. 3 ^^^ 3 == 27)
++		: 	Increment (Pre, or Post)
--		: 	Decrement (Pre, or Post)

//Assignment
=		: 	Assign
:=		: 	Assign (alternative)
+=		: 	Add-Assign
-=		: 	Subtract-Assign
*=		: 	Multiply-Assign
/=		:	Divide-Assign

//Relational
<		:	Less-Than
>		:	Greater-Than
<=		:	Less-Than-or-Equal
>=		:	More-Than-or-Equal
==		: 	Equal
!=		:	Not-Equal
equals		: 	Equivalent to 	==
not_equal 	:	Equivalent to 	!=
~~		:	Approximately Equal
	
	
Approximately Equal
	Compares if two values are apprxiately equal within aset margin of error.
	The default margin is 0.0100
	You can set a custom margin with:
	#option APPROX_EQUAL_MARGIN <float>
	

//Logical
!		: 	Not
||		:	Logical OR
&&		:	Logical AND
^^		:	Logical XOR
and 		: 	Equivalent to 	&&
xor		: 	Equivalent to 	^^
or 		: 	Equivalent to 	||
not 		: 	Equivalent to 	!
not_eq 		:	Equivalent to 	!=
appx_eq 	:	Equivalent to 	~~
appx_equal 	:	Equivalent to 	~~

//Resolution
.		:	Script Name Scope Resolution
::		:	Namespace Scope Resolution

//Range
..		:	neither-sided range
=..		:	left-sided range
..=		:	right-sided range
=..=		:	two-sided range
...		:	two-sided range (alt)

//Bitwise
&		: 	Bitwise AND
~		: 	Bitwise NOT
|		: 	Bitwise OR
^		: 	Bitwise XOR
|=		:	Bitwise OR-Assign
&=		:	Bitwise AND-Assign
^=		:	Bitwise XOR-Assign
bitand 		: 	Equivalent to 	&
bitor 		: 	Equivalent to 	|
bitxor 		: 	Equivalent to 	^
compl		: 	Equivalent to	~
bitnot		: 	Equivalent to	~
or_eq 		: 	Equivalent to 	|=
or_equal 	: 	Equivalent to 	|=
xor_eq 		: 	Equivalent to 	^=
xor_equal 	: 	Equivalent to 	^=
and_eq 		: 	Equivalent to 	&=
and_equal 	: 	Equivalent to 	&=
~=		:	Equivalent to &= ~
bitnot_eq	:	Equivalent to &= ~
bitnot_equal	:	Equivalent to &= ~

//class
new			:	Used for function constructors
delete		:	Used for function destructors

Notes: Xor abd Logical Xor alternative Tokens
	C lacks logical xor (^^), and thus the alternate token 
	for bitwise xor (^) is 'xor', HOWEVER, all other bitwise 
	alternative tokens are prefixed with 'bit:
		e.g., 'bitand', 'bitor'
		...but the logical operator alternative tokens 
	for logical AND and logical OR (&&, ||) have no prefix:
		i.e. 'and', 'or'.
	Thus, for the sake of **linguistic uniformity**, I changed
	our alternative tokens for bitwise and logical xor.
	
	Now, logical xor (^^) uses 'xor' as an alternative token, and
	bitwise xor (^) uses 'bitxor'.
	
	WHile this differs from C, I feel that this change makes
	the alternative tokens more uniform, and easier to remember.
		-ZoriaRPG ( 28th October, 2019 )
	
	
______                                                                  
 \      \ _____    _____   ____   _________________    ____  ____   ______
 /   |   \\__  \  /     \_/ __ \ /  ___/\____ \__  \ _/ ___\/ __ \ /  ___/
/    |    \/ __ \|  Y Y  \  ___/ \___ \ |  |_> > __ \\  \__\  ___/ \___ \ 
\____|__  (____  /__|_|  /\___  >____  >|   __(____  /\___  >___  >____  >
        \/     \/      \/     \/     \/ |__|       \/     \/    \/     \/ 

									// Namespaces
	
///////////////
// Namespace //
///////////////

ZScript now supports C-style namespaces.

Declaration examples:

namespace foo
{
	int x(){return 16;}
}

namespace bar
{
	int y(){return 32;}
	namespace foobar
	{
		int z(){ return 64;}
	}
}

namespace doh
{
	int xyz(){return 128;}
}

Access examples:

foo::x();
bar::y();
bar::foobar::z();


/////////////////////
// Using Namespace //
/////////////////////

You may invoke the 'using' token to bring the contents of a namespaces
into the current scope, thus ignoring the requirement for scope-resolution
(::) until the end of that scope.

You may also invoke 'using' as 'always using' to make that namespace global; this cannot be undone.

The following scopes are valid:

file
namespace
script
function

Using the above namespaces as examples:
	[example--

	//buffer
	always using namespace doh;
	//now in scope in all files, functions, and scripts
	//never falls out of scope
	//cannot be undone

	///file 1
	using namespace foo;

	//we can now ignore scope resolution for namespace foo
	x(); //now equivalent to foo::x();
	//end of file; namespace falls out of scope.

	//file 2
	using namespace bar::foobar;
	z(); //now equivalent to bar:foobar::z();
	//end of file; namespace falls out of scope.

	//function
	void main()
	{
		using namespace bar;
		y();
	} //namespace falls out of scope

	ffc script f
	{
		using namespace foo; //whole script
		void run()
		{
			using namespace bar; //only in run()
			int v = x();
			int w = y();
		}
		void n()
		{
			int r = y(); //illegal
		}
	}
	
	--end example]
	
Ambigious identifier access is an error that can occur with 'using'.
	[example--
	void foo(){}
	namespace bar
	{
		void foo(){}
	}
	
	void example()
	{
		using namespace bar;
		foo(); //Illegal; which 'foo()' are you trying to call?
	}
	--end example]
	
In this case, you can select which identifier to reference using scope resolution.
	[example--
	void example2()
	{
		using namespace bar;
		bar::foo(); //Calls 'foo()' within namespace 'bar'
		::foo(); //Calls 'foo()' that is not in a namespace
	}
	--end example]
Another example:
	[example--
	namespace bar
	{
		void foo(){}
	}
	namespace foo
	{
		using namespace bar;
		void foo(){}
		void example3()
		{
			foo(); //This is LEGAL.
		}
	}
	--end example]
	In this example, 'foo::foo()' will be called. 'using' namespaces only apply if
	there is no local match. In this case, since 'example3()' is in 'namespace foo',
	functions also in 'namespace foo' are considered local, and prioritiezed over 'using'.

/////////////////////////
// Classes and Objects //
///////////////////////// //class //object

For those familiar with C++ style programming, most of this section will be familiar.
An 'Object' is a collection of functions and variables created by constructing it
	from a 'Class' which is like a template.
Here's an example, labelled in comments:
[example--
class Rect
{
	//These are all variables.
	//Unlike script variables, *each object* gets its' OWN of all of these!
	int x,y;
	int w,h;
	int color;
	bool fill;
	
	//These are constructors. They are used with the 'new' keyword to create objects.
	Rect()
	{
		//Default some values
		w = 16;
		h = 16;
		color = 0x01;
		fill = true;
		//Values default to '0' if not set!
	}
	Rect(int tx, int ty)
	{
		Rect(); //This calls the constructor above this one to use its' code!
		//Set the object's variables to the parameters
		x = tx; y = ty;
	}
	~Rect()
	{
		//This is a destructor. It runs when the object is destroyed.
		//...there's not really much use for a destructor for a rectangle, sooo
		//just gonna trace something?
		printf("Rectangle (%d,%d) %dx%d destroyed!\n",x,y,w,h);
	}
	//This is just a normal function.
	//It can be called from the object with an '->' operator.
	void draw()
	{
		//This just draws a rectangle using the parameters of the object
		Screen->Rectangle(7,x,y,x+w-1,y+h-1,color,1,0,0,0,true,OP_OPAQUE);
	}
}
//Now we're outside the class, let's USE IT!
void some_other_func()
{
	//Construct a Rect using the basic constructor
	Rect a = new Rect();
	//Set a variable of the object
	a->color = 0x0F;
	//Use the other constructor
	Rect b = new Rect(16,0);
	b->color = 0x01;
	
	//Draw them.
	a->draw();
	b->draw();
}
//Or you can even set up loops or such.
Rect arr[176]; //global arrays of objects work fine
void generate_arr()
{
	for(int q = 0; q < 176; ++q)
	{
		Rect r = new Rect(ComboX(q),ComboY(q));
		r->color = 0xE0+((q+Div(q,16))%16);
		arr[q] = r;
	}
}
void draw_arr()
{
	//then to draw, just...
	for(int q = 0; q < 176; ++q)
		arr[q]->draw();
}
--end example]

Some misc notes:

Note that inside the class, the functions do not use an '->' of any kind to access the
variables or functions. They actually are using 'this->', but they are able to do so
automatically because they are smart. (using 'this->' manually still works).

Functions in a class may be declared as "static". This effectively removes them from objects,
making them a 'global function' in the class's name.

[example--
class foo
{
	static void print(){}
	foo()
	{
		print(); //valid, as the function is still in the class scope
		this->print(); //ERROR: function 'print' has not been declared
		foo.print(); //valid
	}
}
void testfunc()
{
	foo.print(); //Valid, even with no object to call the function from.
	foo f = new foo();
	f->print(); //ERROR: function 'print' has not been declared
}
--end example]
So, static functions can only be called either from within the class directly,
	or by using 'classname.funcname()', but NOT from an arrow.
Also noteworthy is that static functions do NOT have access to the class's 'this' pointer.
	(ALL non-static class functions, including constructor/destructor, have 'this')
The max number of objects that can exist at once is 214747, so, *a lot*.

You can also declare arrays within objects, though these behave specially.
[example--
class foo
{
	int arr[5];
	foo()
	{
		strcpy(arr,"Test"); //Works fine
		arr = 2; //Fails; 'arr' cannot be overwritten.
		arr[0] = 'B'; //Succeeds (string reads 'Best')
	}
}
--end example]
These arrays cannot be destroyed with 'DestroyArray', or owned with 'OwnArray'. They are
	always in effect "owned" by their object, and will be destroyed by the object's
	destructor. They will be saved with the object in the save file.
That said, they *have* normal array pointers, and as such can be used by basically anything
	(except the listed exceptions) that uses normal arrays.

(Any further questions about classes can be directed to @EmilyV in the development discord)
(Any ideas on better/further documentation for this are much welcome)



//////////////////////////////
// Object Memory Management //
//////////////////////////////

Pre-3.0, objects had to be manually deleted, but with ZC 3.0 there is now a garbage
collector to automate freeing objects for scripters.

TL;DR for experienced ZScript users: you don't need to use `delete` or `Free()` anymore, and
you probably never need to use `->Own` either. Read on for specifics.

The following types are objects that are tracked by the garbage collector:

* any custom user class
* bitmap
* directory
* file
* paldata
* randgen
* stack
* websocket

Note: there are other object types, but they are never explicitly created or deleted by scripts.

The ZScript garbage collector has two ways for knowing when to delete objects:

1. Reference counting - variables and arrays containing an object count as references, and
   as long as there is one reference to an object it will not be deleted
2. Reachability - objects that are not reachable from a global object, local/global variable,
   or local/global array are considered unreachable, and will be deleted. This is necessary
   to detect objects that may always have a reference count greater than zero (for example:
   two objects holding a reference to each other, but otherwise no longer in use). The process
   of detecting unreachable objects is a "full garbage collection", and only runs occasionally.

Objects made global with "GlobalObject" are never deleted by the garbage collector.

To tie an object to at least the lifetime of the currently running script, use "OwnObject".
This associates a reference to the object with the current script, so when that script ends
if there are no other references to the object it will be destroyed. Only one script may
own a particular object - subsequent calls transfer which script holds the reference.
You shouldn't need this functionality for most usages. One example of it being necessary
is if the only place you store an object is an untyped variable, which does not hold a reference.

Variables only retain a reference to an object if typed as an object. For example, using
`int` or `untyped` to store an object pointer won't count as a reference, so may result in
premature deletion. If you must store objects like that for some reason, call "OwnObject"
so its reference count is always greater than zero (as long as that script is alive), or make
it a global object.

For simple objects with no cyclical references, they are destroyed just after their last
reference is removed (as local variable going out of scope, or being overwritten, etc).

New objects have an implicit reference added to an "autorelease pool" (a construct borrowed
from Objective-C). This reference is removed the next time the script yields (such as by
calling Waitframe). If the object has not been stored somewhere by then, or made global, it
is deleted when the script yields.

For objects with cyclical references (or self-references), their deletion is deferred until
a full garbage collection run. When an object is found to be unreachable by
any global or local variables, it will be deleted. This procedure is much more expensive
than reference counting, so it doesn't run often, and when exactly it runs is subject to change.

You should not expect destructors to run at any specific time, or even at all. You should only
use destructors for debugging purposes, or for deleting/disowning other objects. Exactly when
the garbage collector runs or an object destructor is called is an implementation detail that
may change. Do NOT implement critical game functionality in destructors - doing so will result
in unpredictable behavior, and may break your quest in future versions of ZC.

Script ownership can be revoked by calling "GlobalObject()". Global objects are never deleted
by the garbage collector. You can delete a global object by making it no longer global (call
"Own" on it).

When a script terminates, objects it owns will lose a reference count, calling their
destructors immediately if their reference count is now zero.

When a quest exits, ALL non-global objects are deleted. If the quest is saved,
however, objects made global with "GlobalObject" will be *saved to the save file*,
and will still be valid on reloading the save. This includes all variables and arrays.

Currently objects in a stack do not count as a reference.



  ________.__        ___.          .__    __________      .__        __                       
 /  _____/|  |   ____\_ |__ _____  |  |   \______   \____ |__| _____/  |_  ___________  ______
/   \  ___|  |  /  _ \| __ \\__  \ |  |    |     ___/  _ \|  |/    \   __\/ __ \_  __ \/  ___/
\    \_\  \  |_(  <_> ) \_\ \/ __ \|  |__  |    |  (  <_> )  |   |  \  | \  ___/|  | \/\___ \ 
 \______  /____/\____/|___  (____  /____/  |____|   \____/|__|___|  /__|  \___  >__|  /____  >
        \/                \/     \/                               \/          \/           \/ 

									// Global Pointers
//////////////////
// New Pointers //
//////////////////

	Hero->
	Player->
	
		These are synonymous with the old Link-> pointer, which is now deprecated but retained
		for compatibility purposes. 
	
	Graphics->
		Used for graphical functions.

	Audio->
		Used for sound and music functions.

	Input->
		Used to read and write buttons, and keyboard keys; as well as control states.

	Text->
		Used to get information on fonts, or to display text.

	FileSystem->
		Used to get information on the user filesystem, such as FileExists(), DirExists().
	
	ZInfo->
		Use to read ZInfo strings.
	
	RandGen->
		Use to generate random numbers, using the engine's RNG


________          __          __                                
\______ \ _____ _/  |______ _/  |_ ___.__.______   ____   ______
 |    |  \\__  \\   __\__  \\   __<   |  |\____ \_/ __ \ /  ___/
 |    `   \/ __ \|  |  / __ \|  |  \___  ||  |_> >  ___/ \___ \ 
/_______  (____  /__| (____  /__|  / ____||   __/ \___  >____  >
        \/     \/          \/      \/     |__|        \/     \/ 

									// Datatypes

///////////////////////
/// Basic Datatypes ///
///////////////////////
The following are the current, supported BASIC datatypes in ZScript:

TYPE		LEGAL RANGE
float 		-214748.3648, 214748.3647
int		-214748, 214748
	The basic numeral datatype. Both float and int are identical.
	The different tokens exist purely for local semantics and both 
		resolve to the same type, including for the purpose of
		matching function signatures.
	The legal range depends on a compiler flag. Older versions of ZScript had
		a maximum legal range of -214747.9999, 214747.9999.
	The current version of the ZScript spec expands this to -214748.3648, 214748.3647.
	
bool	false, true
	A general boolean datatype. Internally, true is '1' and false is 0..
	Older versions of ZScript used 0.001 as 'true. The user can
		use this old value set with a compiler flag, should the user
		require it for older scripts.
	When typecasting to bool, any value that is non-zero will
		evaluate as 'true', and values of EXACTLY zero will evaluate as 'false'.
		
char32		-214748, 214748
	Similar to the C type 'char', but 32 bits wide.
	A datatype specifically for individual characters, or for strings.
	String literals are typed as char32.
	This datatype can be used to narrow function signature matching for use of
		SINGLECHAR or STRING as function inputs.
	When doing signature matches, a SINGLECHAR or a STRING LITERAL will
		match FIRST to char32.
		
		Thus:
			void foo(char32 a)
			{
				TraceS(a);
			}
			void foo(int a)
			{
				Trace(a);
			}
			
			foo("str\n"); 	//Will call: foo(char32)
			foo(16);	//Will call: foo(int);

long		-2,147,483,648 -> 2,147,483,647
	Long is a special datatype, which uses special number literals. It gives access to a long integer value,
	taking up a full 32-bits, though has no decimal portion. Bitwise operations on 'long' data will be able to hold 32 bits.
	A long value '502L' is equivalent to a float value '0.0502'.
	Long literals:
		13432423L (== 1343.2423) //Decimal long
		0xFL (== 0.0015, == 15L) //Hex long
		101010Lb (== 0.0042, == 42L) //Binary long
		00011bL (== 0.0003, == 3L) //Binary long
		17oL, 17Lo (== 0.0015, == 15L) //Octal long
		
rgb         0L -> 0xFFFFFFL
	NOTE: if compat QR "Scripts use 6-bit color (0-63) instead of 8-bit (0-255)" is enabled: 0L -> 0x3F3F3FL
	rgb is a special type used by paldata for color operations.
	rgb values cannot inherently cast to other primitive types.
	

untyped : A special datatype that can be cast to and from any other type.
	This has no distinct type of its own.
	
	Example:
		untyped ptrs[4];
		ffc f = Screen->LoadFFC(2);
		npc n = Screen->CreateNPC(16);
		lweapon l = Screen->CreateLWeapon(LW_SCRIPT);
		bitmap bitty = Game->CreateBitmap(160,240);
		
		ptrs[0] = f;
		ptrs[1] = n;
		ptrs[2] = l;
		ptrs[3] = bitty;
		
		//These now contain the raw literal value of the pointers to those objects.
		
		bool a = true;
		untyped b = a; //b == 1
		int c = b; //c == 1
	
	Note: untyped does not retain references to objects. If not careful, object pointers will be
	      deleted if only an untyped variable holds it.


///////////////////////
// Complex Datatypes //
///////////////////////

	ffc:
		Used to create a pointer to one of the 32 freeform combo objects on the current
		screen, and to access its members. You cannot create ffcs.
		The ffc datatype is the 'this' pointer for ffc scripts.
		
	npc: 
		Used to create a pointer to an npc object. 
		You may either load a current (valid) npc on the current screen to the pointer, or create
		a new npc on the screen using this pointer.
		The maximum number of npc objects is defined in std.zh, but you may have multiple pointers
		directed at a single object in memory.
		Use this to access npc varibles, arrays, and functions. 
		The npc datatype is the 'this' pointer for npc scripts.
		
	eweapon:
	lweapon:
		Used to create a pointer to a weapon object. 
		Use eweapon for enemy weapons, and lweapon for player weapons.
		You may either load a current (valid) weapon on the current screen to the pointer, or create
		a new weapon on the screen using this pointer.
		The maximum number of weapon objects (per type) is defined in std.zh, but you may have multiple pointers
		directed at a single object in memory.
		Use this to access lweapon and eweaopon varibles, arrays, and functions. 
		The eweapon datatype is the 'this' pointer for eweapon scripts.
		The lweapon datatype is the 'this' pointer for lweapon scripts.
		Note that while eweapon and lweapon share most members, that some members are unique
		to one or the other, and that these script types are not 1:1 interchangeable.
		
	itemsprite: 
		Used to create a pointer to an itemsprite object. 
		You may either load a current (valid) itemsprite on the current screen to the pointer, or create
		a new itemsprite on the screen using this pointer.
		The maximum number of itemsprite objects is defined in std.zh, but you may have multiple pointers
		directed at a single object in memory.
		Use this to access itemsprite varibles, arrays, and functions.
		NOTE: In previous versions, this type was simply called "item".
	
	itemdata:
		Used to access the Item Editor values.
		You may load item IDs 0 to 255 to a pointer, and edit the values in the Item Editor
		for that item, or read its editor values for other use.
		The itemdata datatype is the 'this' pointer for itemdata (formerly item) scripts.
	
	bitmap:
		Used to create user bitmaps, similar to the old 2.50 Render Target bitmaps,
		but with custom sizing.
		
		Bitmap objects have their own drawing functions, and you may save/load them to/from
		files by script.
		
		There are a maximum of 256 user bitmaps at any one time.
	
	npcdata: 
		Used to access the Enemy/NPC Editor values.
		You may load NPC IDs 0 to 255 to a pointer, and edit the values in the Enemy Editor
		for that npc, or read its editor values for other use.

	combodata:
		Used to access the Combo Editor values.
		You may load Combo IDs 0 to 65279 to a pointer, and edit the values in the Combo Editor
		for that combo, or read its editor values for other use.
		The combodata datatype is the 'this' pointer for combodata (T/B/A) scripts.

	spritedata:
		Used to access the Weapon Sprite Editor values.
		You may load Combo IDs 0 to 255 to a pointer, and edit the values in the Weapon Sprite 
		Editor for that sprite, or read its editor values for other use.

	mapdata: 
		Used to access all data contained on MAPS (mapscreens).
		You may load a mapscreen by referencing the map, and the screen; or load
		tempscreen or scrolling screen layers to a pointer, and edit the values for that screen;
		or read its values for other use.

	dmapdata : 
		Used to access all all DMap Editor data.
		You may load a DMap IDs 0 to 511 to a pointer, and edit the values for that DMap;
		or read its editor values for other use.
		The dmapdata datatype is the 'this' pointer for dmapdata scripts.

	messagedata :
		Used to access all String Editor data.
		You may load a Message String IDs 1 to 65535 to a pointer, and edit the values for
		that message string; or read its editor values for other use.

	shopdata :
		Used to access all Item Shop Editor and Info Shop Editor data.
		You may load a Shop Type IDs 0 to 255, or Info Shop IDs 0 to 255, to a pointer, 
		and edit the values for that shop; or read its editor values for other use.
		
	dropsetdata :
		Used to access all Item Dropset Editor data.
		You may load a Item Dropset Type IDs 0 to 255, to a pointer, and edit the values for 
		the dropset; or read its editor values for other use.
		
	file :
		Object type for accessing files on the system. All files accessed must exist in "[zc root]/files/[questname]/".
		These files can contain either text, or raw binary number data, based on which functions you use.
		
	directory :
		Object type for accessing directories on the system. All directories accessed must exist in "[zc root]/files/[questname]/".
	
	stack :
		Object type for complex data storage.
	
	randgen :
		Object type for seeded random number generation.
	
	websocket :
		Object type for websocket communication (online)
	
	bottledata :
		Object type for modifying bottle type data
	
	bottleshopdata :
		Object type for modifying bottle shop type data
	
	genericdata :
		Object type for managing 'generic scripts'
		
	paldata :
		Object type for storing palettes
	
	portal :
		pointer to one of the on-screen 'portals' (See ZScript_Docs.html)
	
	savedportal :
		Object type for storing portal data that saves with the save file (See ZScript_Docs.html)
	
	subscreendata :
		Object type for reading/modifying engine Subscreens
	subscreenpage :
		Object type for reading/modifying engine Subscreen Pages
	subscreenwidget :
		Object type for reading/modifying engine Subscreen Widgets
	
	//Planned/Incomplete
	warpringdata : t/b/a
		(Planned) Access to all Warpring Editor data.
	doorsetdata : t/b/a
		(Planned) Access to all Doorset Editor data
	misccolorsdata : t/b/a
		(Planned) Access to all Misc Colours dialogue data.
	zcmididata : t/b/a
		(Planned) OBJECT TYPE for working with MIDIs, both in-quest, and as external files.
	palcycledata : t/b/a
		(Planned) Access to all Palette Cycle data.
	gamedata : t/b/a
		(Planned) Access to all global game data (game->, in source)
	cheatsdata : t/b/a
		(Planned) Access to cheat code information.
	

///////////////////////
/// Type Specifiers ///
///////////////////////

const TYPE

If you declare a type constant, one of two things occurs:
	If the ASSIGNED VALUE is also constant at compile time, then the value of the constant is converted to
	a literal during compilation.
	
	e.g.
	const int A = 5; 
	const int B = A; //A is constant at compile time
	int arr[B]; //B is sized to 5 during compilation.
	
	Such a declaration uses no stack space/registers.
	
If the type is NOT constant at compile time, the declaration is treated as a normal variable/array of its type,
	however, its value cannot be modified during runtime.
	
	e.g.
	const int hpcap = Link->MaxHP; //not constant at compile time, but the value of hpcap
		is read-only.
	const char32[]="A String"; //not constant at compile time (true const string isn't available, nor is const array).
		You cannot modify this during runtime.
	void foo(const bool a, const int b)
	{
		a = false; //illegal to write to a
		b = 64; //cannot write to b
	}
	
	This can be useful if you wish to pass params without the risk of code modifying them, especially
	when passing a pointer by reference.

This type specifier can be applied to ALL datatypes, including enum-specified types.


___________                        .___      _____ 
\__    ___/__.__.______   ____   __| _/_____/ ____\
  |    | <   |  |\____ \_/ __ \ / __ |/ __ \   __\ 
  |    |  \___  ||  |_> >  ___// /_/ \  ___/|  |   
  |____|  / ____||   __/ \___  >____ |\___  >__|   
          \/     |__|        \/     \/    \/       
	  
									// Typedef

/////////////
// Typedef //
/////////////

	You can now define your own types using typedef using normal C syntax:

	typedef old_type new_type;

	[example--
		typedef ffc object; //Allows you to declare object vars that are typed to ffc. 		

		typedef const int DEFINE;
		//Allows you to use the token DEFINE to declare constant ints. 
		
	--end example]
	
	
////////////////////
// Script Typedef //
////////////////////

	 You may also typedef script tokens, creating your own types that resolve into existing script types.

	e.g. script typedef hero villain;
	
	You may now declare the script type 'villain script', that resolves into the normal 'hero script' type.



_________                 __                   ________          __          __                                
\_   ___ \ __ __  _______/  |_  ____   _____   \______ \ _____ _/  |______ _/  |_ ___.__.______   ____   ______
/    \  \/|  |  \/  ___/\   __\/  _ \ /     \   |    |  \\__  \\   __\__  \\   __<   |  |\____ \_/ __ \ /  ___/
\     \___|  |  /\___ \  |  | (  <_> )  Y Y  \  |    `   \/ __ \|  |  / __ \|  |  \___  ||  |_> >  ___/ \___ \ 
 \______  /____//____  > |__|  \____/|__|_|  / /_______  (____  /__| (____  /__|  / ____||   __/ \___  >____  >
        \/           \/                    \/          \/     \/          \/      \/     |__|        \/     \/ 

									// Custom Datatypes	
									// Enum
//////////////////////
// Enumerated Lists //
//////////////////////

You can now define enumerated lists of constant values using the
standard C-style syntax of:

	enum { A, B, C, D = 10, E, F, G = 100, H, I = B };

	In this declaration, A == 0, B == 1, C == 2, D == 10, 
		E == 11, F == 12, G == 100, H == 101, and I == 1

By default, enums are constants of type `int`, which auto-increment by `1`.
You can change the type of the enum to a pre-existing type by using the following syntax:
	[example--
	enum = untyped
	{
		A, B, C
	};
	--end example]
If the type of an enum is set to `long`, it will auto-increment by `1L` instead of `1`.
	[example--
	enum = long
	{
		A, //0L
		B, //1L
		C  //2L
	};
	--end example]
		
You can also define a C style enumerated list with an identifier. 
This act defines a pseudo-datatype, with assignable values limited to
the values in the enumerated list.

	enum actiontype { none, walk, attack };
	
	Now, you can declare 'actiontype' as a datatype.
	
	actiontype act;
	
	If you wish to assign a value to it, the value must be validated
	from the enumeration:
		act = walk; //Legal
		act = 7; //Error
		
	You can explicit cast values to these types to circumnavigate the
	restrictions.
		act = <actiontype>7; //this is legal. 
		
	[example--
	
		void foo(actiontype action)
		{
			actiontype newaction = action; 
		}
	
	--end example]
	You can only pass legal values in the actiontype enum to the parameter of this function.
	
	You can further declare functions to return an enum type:
	
	[example--
	
		actiontype walking()
		{
			return walk;
		}
		
	--end example]
	
	
	You can declare enums inside namespaces, and scripts, and then dereference them as any
	other namespace or script scoped component.
	
	[example--
	
		namespace myns
		{
			enum sizeflag { szNone, szSmall, szMedium, szLarge = 4 };
			enum othertype { otA, otB, otC, otD, otE, otF, otG, otH, otI, otJ };
		};
		
		myns::othertype getFlag(myns::sizeflag sz, actiontype act)
		{
			switch(act)
			{
				case none:				
				case walk:
				{
					switch(sz)
					{
						case myns::szNone: return myns::otA;  // Need to dereference the constant, as it 
						case myns::szSmall: return myns::otC; // is part of an enum, inside a namespace.
						case myns::szMedium: return myns::otD;
						case myns::szLarge: return myns::otI;
					}
				}
				case attack:
				{
					switch(sz)
					{
						case myns::szNone: return myns::otA;
						case myns::szSmall: return myns::otE;
						case myns::szMedium: return myns::otG;
						case myns::szLarge: return myns::otH;
					}
				}
				default: return myns::otA;	
			}
		}
	
	--end example]
	
	Because these count as specific types, like int, itemdata, and npc, you can use them as overloads 
	in function signatures, and as long as you always pass the enum constants, you will guarantee a match.
	
	[example--
	
		int myoverloads(int a, npc b, eweapon c);
		myns::othertype myoverloads(actiontype a, npc b, eweapon c);
		
		//If you call:
		
		myoverloads(walk, n, e);
			//This will use 'myns::othertype myoverloads(actiontype a, npc b, eweapon c)'
			
		//If you instead call:
		
		myoverloads(1, n, e);
			//This will use 'myoverloads(int a, npc b, eweapon c)'
		
	--end example]
	
	Thus, enum types allow you very precise control over function overloads.
	
	Last, you can use script-scoping, instead of namespace-scoping, if you wish:
	
	[example--
	
		ffc script foo
		{
			void run(){}
			enum fktype { seNone, seA, seB, seC };
			enum fkflag { sfNone, sfA, sfB, sfC = 4 }; 
		}
		
		int getfakestructflag(foo.fkflag flag)
		{
			int r = <int>flag; //cast to int
			return r;
		}
		
		//Convert a flag to its type ID
		foo.fktype flagtype(foo.fkflag flag)
		{
			switch(flag)
			{
				case foo.sfNone: return foo.seNone; 
				case foo.sfA: return foo.seA; 
				case foo.sfB: return foo.seB; 
				case foo.sfC: return foo.seC; 
			}
		}
	
	--end example]
	
	

   _____                                    
  /  _  \___________________  ___.__. ______
 /  /_\  \_  __ \_  __ \__  \<   |  |/  ___/
/    |    \  | \/|  | \// __ \\___  |\___ \ 
\____|__  /__|   |__|  (____  / ____/____  >
        \/                  \/\/         \/ 

									// Arrays

////////////////////////////////////
// Array Declaration Improvements //
////////////////////////////////////

	Arrays now support being declared with any constant expression.:

	[example--

		int arr[10*4]; 
		//This is now the same as int arr[40];
		
	--end example]

	Nesting array calls should now work properly. (e.g. arrA[ arrB[ arrC[ arrD[4] ] ] ] )

	Further, you may now use constants in array declarations:

	[example--

		const int sARR_MAX = 20;
		int arr[sARR_MAX];
		
	--end example]
	
//////////////////////////
// Array Reverse Access //
//////////////////////////

	Arrays now support negative indexing to access from the back.
	
	[example--
		int arr[] = {0, 3, 7, 2, 5};
		Trace(arr[-1]); //5
		Trace(arr[-2]); //2
		Trace(arr[-3]); //7
		Trace(arr[-4]); //3
		Trace(arr[-5]); //0
		Trace(arr[-6]); // Error: Out of bounds
	--end example]


/////////////////////	
// Datatype Arrays //
/////////////////////

It is legal to create an array of any legal datatype, including complex datatypes.
You may specify an explicit array size, or use an array initialiser to set its size implicitely.

Formats
TYPE IDENTIFIER[SIZE];
TYPE IDENTIFIER[SIZE] = { INITILISERS };

	SIZE may be any constant expression.

TYPE IDENTIFIER[] = { INITIALISERS };

char32 arrays may be initialised with a string:

char32 IDENTIFIER[SIZE] = "string"; //Explicit size.
char32 IDENTIFIER[] = "string"; //Sized implicitely to number of characters +1 for NULL termination.

	Explicitely-sized string arrays must be sized to at least the length + 1 to include a NULL terminator.


  _________ __         .__                      
 /   _____//  |________|__| ____    ____  ______
 \_____  \\   __\_  __ \  |/    \  / ___\/  ___/
 /        \|  |  |  | \/  |   |  \/ /_/  >___ \ 
/_______  /|__|  |__|  |__|___|  /\___  /____  >
        \/                     \//_____/     \/ 

									// Strings

/////////////////////
// String Literals //
/////////////////////

	You may now use C-style string literals at any non-global scope.

	[example--

		TraceS("Trace this string.");
		
	--end example]


	You may use standard C-style escape characters in string literals:

	- \a\b\f\n\r\t\v for the standard values,
	- \" for quotes
	- You can escape a newline to make it not appear in the string

	Additionally, adjacent strings are merged by the compiler.

	[example--

		TraceS("This is a string"
			" on two lines");
		
	--end example]
	

///////////////////////////////////////
// Single Character Escape Sequences //
///////////////////////////////////////

You may now use escape sequences in a SINGLECHAR type:
	char32 tab = '\t';
	
	Valid Escape Characters
	\a     		Alert (Beep, Bell) (added in C89)[1]
	\b    		Backspace
	\f     		Formfeed Page Break
	\n     		Newline (Line Feed); see notes below
	\r     		Carriage Return
	\t     		Horizontal Tab
	\v     		Vertical Tab
	\\     		Backslash
	\'     		Single quotation mark
	\"     		Double quotation mark
	\?     		Question mark (used to avoid trigraphs) 
	\x0 to \xFF   	Normal ANSI characters, as hex value. 
	

	
///////////////////////////////
/// Expanded Array Literals ///
///////////////////////////////

	Array Literals of the following form may be used in lots of places,
	not just array variable declarations.

	{0, 1, 2}
	(int[]){0, 1, 2}
	(int[3]){}
	(int[3]){4}

	[example--
	
		RunFFCScript(script_no, (int[8]){arg1, arg2, arg3});
		
	--end example]
	
	If no type is specified, the array will default to 'untyped'.

///////////////////////
/// Binary Literals ///
///////////////////////

Binary numbers may be specified as '01010101b', or '0b01010101'
	(both representing '84' in this example).

//////////////////////
///  Hex Literals  ///
//////////////////////

Hexadecimal numbers may be specified, prefixed with '0x'.

Ex. 0x22 == 34
    0x4A == 74

//////////////////////
/// Octal Literals ///
//////////////////////

Similarly to hex and binary literals, you can now specify numbers using octal literals.
To specify an octal literal, the digits of the number must be 0-7, and the number must have an 'o' appended.

Ex: 17o == 15
Ex: 47o == 39

Prefixing with '0o' is a valid alternative

Ex: 0o21 ==	17

/////////////////////
/// Long Literals ///
/////////////////////

Long is a special datatype, which uses special number literals. It gives access to a long integer value,
taking up a full 32-bits, though has no decimal portion. Bitwise operations on 'long' data will be able to hold 32 bits.
A long value '502L' is equivalent to a float value '0.0502'.
Long literals:
	13432423L (== 1343.2423) //Decimal long
	0xFL (== 0.0015, == 15L) //Hex long
	101010Lb (== 0.0042, == 42L) //Binary long
	00011bL (== 0.0003, == 3L) //Binary long
	0b01011L (== 0.0011, == 11L) //Binary long
	17oL, 17Lo (== 0.0015, == 15L) //Octal long
	0o27L (== 0.0023, == 23L) //Octal long

 _______                  ___________            __                               
 \      \   ______  _  __ \_   _____/___ _____ _/  |_ __ _________   ____   ______
 /   |   \_/ __ \ \/ \/ /  |    __)/ __ \\__  \\   __\  |  \_  __ \_/ __ \ /  ___/
/    |    \  ___/\     /   |     \\  ___/ / __ \|  | |  |  /|  | \/\  ___/ \___ \ 
\____|__  /\___  >\/\_/    \___  / \___  >____  /__| |____/ |__|    \___  >____  >
        \/     \/              \/      \/     \/                        \/     \/ 

									// New Features

/////////////////////////
// Ternary Expressions //
/////////////////////////

You may now use C-style ternary expressions:

	int x = Rand(6,8);
	int y = x > 7 ? 1 : 0;
	
	Assigns, and operations inside ternary blocks must be in parens:
		bool V = true;
		int b;
		int a = V ? ( b =  5 ) ? ( b = 4 );
		
		int c = V ? ( b -= 2 ) ? 0; 
		
		int y; int z; 
		int x = (y += 10) ? (z = 5) : (a -= 2);
		
	In all of these cases, parens are mandatory. 
	
	Further, compound ternary expressions should be placed in parens:
		int a = (V ? 1 : 0) ? 5 : 6
		
	The default, is to evaluate in a linear sequence.
			
	Thus, 
		bool ? int : int ? bool : int
	...would evaluate as: 
		bool ? int : (int ? bool : int)
	
	Using parens to define your order of operations and scope, is prudent. 


///////////////////////////
// Variable Declarations //
///////////////////////////

You can now declare, and initialise variables on one line, as in C.
	Format:
	TYPE (identifier | identifier ASSIGN NUMBER) comma [repeating] SEMICOLON
	Examples:
		int a, b, c = 9, h = 16, f = c+h;
		float n = 1.04, m = 6.03;
		
		These are equivalent to:
		int a; int b; int c = 9; int h = 16; int f = c+h;
		float n = 1.04; float m = 6.03;


///////////////////
// Explicit Cast //
///////////////////

You may now explicitly cast a value, using a type in angle braces.

	ffc f = Screen->LoadFFC(15);
	int x = <int>f;

	f = <ffc>2;


///////////////////////////
/// Arrow from Function ///
///////////////////////////

You may now use the arrow (->) operator on functions of datatypes/pointers, including
cases where you are not using the base function in an assign.
	Examples:
	int sfx = Game->LoadItemData(16)->UseSound;
	int ilvl = Game->LoadItemData(Screen->LoadLWeapon(1)->Parent)->Level;
	
	Previously, you were required to declare a variable and make an assign
		in multiple stages.#
		e.g., this: 
		int ilvl = Game->LoadItemData(Screen->LoadLWeapon(1)->Parent)->Level;
	
		...used to require:
		
		lweapon l = Screen->LoadLWeapon(1);
		itemdata id = Game->LoadItemData(l->Parent);
		int lvl = id->Level;
		
		You can now skip these useless declarations, unless you have a 
		reason or desire to cache the data in a variable. This saves stack space, 
		and, in some circumstances, may improve performance; however repeated
		use of the same variables may benefit from caching the values in a register.
		
		
////////////////////
// Comment Blocks //
////////////////////

	The ZScript language now supports C-Style comment blocks using the traditional syntax of:

	[example--

		/* 
			COMMENT BLOCK
			
		*/
		
	--end example]


/////////////////////
// Global Pointers //
/////////////////////

	You may now declare any datatype, including arrays for any datatype at a global scope.
	*	Data saved to these may become invalid and require manual cleansing by the user!
	*	Only the value of a pointer is saved, not the struct data associated with that pointer.


////////////
// Unless //
////////////

	This statement runs the code block attached to it if its statement would evaluate false
	in an if statement.
	Aside from the obvious semantical enhancement over 'if(!expression)', the advantage of 
	this, is that 'unless(expression)' is faster (in ASM instructions) than 'if(!expression)'.

	Example: 
		int x = 6; int y;
		unless(x==6)
		{
			y = 1;
		}
	
	In this example, the code block would never run, because x == 6. 
	This is the opposite of 'if', and supports 'else unless' and 'else'
	blocks following the unless statement.

//////////////////////////////////
// Declarations in Conditionals //
//////////////////////////////////

	If statements can now have a single variable declared (must be initialized) inside their conditional check.
	The variable will be accessible during the 'then' block (not the 'else' block, if present). The initial value
		of the variable is read as the condition.

	Example: 
		if(npc n = GetClosestNPC(32))
		{
			DoSomething(n->X, n->Y);
		}
		else
		{
			DoSomethingElse(); //no enemies in range
		}
	
	(For this example, assume that 'GetClosestNPC()' returns 'NULL' if no enemy is found)
	In this example, if the GetClosestNPC() function finds an enemy (i.e. does not return NULL), then
		the 'then' block will run, doing something with the enemy's position.
	If no enemy is found (the function returned NULL), then the else block will run instead.

///////////////////////
// Auto Declarations //
///////////////////////

By declaring a single variable using the type 'auto', it will inherit its
	type from its initializer.

Example:
	auto x = 5; //x is int
	auto n = Screen->LoadNPC(1); //n is npc
	auto l = Screen->CreateLWeapon(LW_FIRE); //l is lweapon
	//auto a = 1, b = 2; //ERROR: cannot use 'auto' to declare multiple variables at once
	//auto c; //ERROR: must use an initializer when using 'auto'

////////////
// Repeat //
////////////

Repeats a command a given number of times.
The value passed to repeat(const int v) must be constant at compile time.

Example:
	const int N = 10;
	int x;
	repeat(N) { ++x; }
	
This is similar to a for loop, but it produces faster ZASM, because the number
of iterations is known at compile-time.


/////////////////////
// Until, do-until //
/////////////////////

	ZScript now supports the Pascal-style token 'until'. 
	This functions as an inverted 'while' statement.
	Aside from the obvious semantical enhancement over 'while(!expression)', the advantage of 
	this, is that 'until(expression)' is faster (in ASM instructions) than 'while(!expression)'.
	
	Examples:
	
		until(x > 7) { DoSomething(); }
		
		do
		{
			Something();
		} until ( x > 7 );



/////////////////
//  Loop-Else  //
/////////////////

	You can now include an 'else' clause after any loop. The else block
	will run if the loop ends naturally, i.e. not via 'return' or 'break'.
	
	[example--
		for(int q = 1; q <= Screen->NumNPCs; ++q)
		{
			npc n = Screen->LoadNPC(q);
			if(Distance(n->X,n->Y,Hero->X,Hero->Y) < 64)
				break;
		}
		else
		{
			//No enemies are within 64 pixels of the hero
			//as the loop never hit a 'break'.
		}
	--end example]

/////////////////
//  For Loop   //
/////////////////

	The classic for loop has a couple new things. In addition to the 'Loop-Else' mentioned above,
		you can now use multiple increment statements with a comma-delimited list.
	[example--
		for(int indx = start, count = 10; count > 0; ++indx, --count)
		{
			//do something
		}
	--end example]

/////////////////
//  For-Each   //
/////////////////

	You can now iterate through each element in an array easily!
	[example--
		int arr[] = {1,10,25,3,6,2};
		for(num : arr)
			Trace(num);
		//or
		for(num in arr)
			Trace(num);
	--end example]

//////////////////////
//  'loop' keyword  //
//////////////////////

	There is a new type of loop, declared using the 'loop' keyword.
	This new loop can be used in a couple of fancy ways, and is designed
		to be optimized, and easily accomplish what you need it to.
	
	Firstly, by simply declaring `loop()`, it creates an infinite loop,
		just like a `while(true)`, but shorter to type.
	
	Secondly, you can loop through Value Ranges!
	
	[example--
		loop(q : 0=..10)
			Trace(q); //Traces 0,1,2,3,4,5,6,7,8,9
	--end example]
	
	When looping through a value range, there are several syntax options to go over.
	
	loop(TYPE NAME IN RANGE, INCREMENT)
	
	- TYPE: You may specify the type of the variable. If it is not specified,
		it will be `const int` by default. Must also specify a NAME if type is specified.
	- NAME: You may specify the name of the variable. If it is not specified,
		it will be `__LOOP_ITER` by default.
	- IN: Either a colon (:) or the `in` keyword. This should only be present
		if the NAME was specified.
	- RANGE: Required. This is the value range to loop through.
	- INCREMENT: The amount to increment by each loop may be specified.
		If it (and the comma before it) are left out, it defaults to '1'.
		If the increment is negative, the loop will start from the high end of the range,
			and work down to the low end.
	
	Some examples:
	[example--
		loop(x in [0,100), 10)
			printf("%d\n",x); //0, 10, 20, 30, 40, 50, 60, 70, 80, 90
		loop(const long x : [0,1), 100L)
			printf("%d\n",x); //0.01, 0.02, 0.03, ... 0.97, 0.98, 0.99
		loop(0=..20)
			Trace(1); //Traces '1' 20 times in a row
	--end example]
	
	The 'Loop-Else' addition listed above also applies to this new loop type.

Available annotations:
	@AlwaysRunEndpoint -
		Value: "int","long", or "float"
		Function: Causes the loop to run an extra time with an extreme value,
			preventing the iterator from overflowing the range without reaching the end.
			If given "int", will truncate to an integer value; otherwise will use
			the end of the range exactly.
		[example--
			loop(x in [0,16), 4)
				Trace(x); //0,4,8,12
			
			@AlwaysRunEndpoint("int")
			loop(x in [0,16), 4)
				Trace(x); //0,4,8,12,15 - 15 is the last integer within the range
			
			@AlwaysRunEndpoint("long") //"float" is the same
			loop(x in [0,16), 4)
				Trace(x); //0,4,8,12,15.9999 - since 16 isn't in the range, 15.9999 is the end.
		--end example]

/////////////////
// Switch-Case //
/////////////////

	ZScript now supports C-style switch statements. Case values must be numeric literals,
	ranges, or constant expressions. Each case should end in a break instruction, or else
	fallthrough can be expected to occur. You may provide a default case.

	[example-- 

		const int SOME_CONST = 11;

		switch(var)
		{
			case 1:
			{
				DoSomething(); 
				break;
			}
			case SOME_CONST:
			{
				DoSomethingElse();
				break;
			}
			case SOME_CONST+(10*2)
			{
				DoOther();
				break;
			}
			default:
			{
				DoDefault();
				break;
			}
		}

	--end example]
	
//////////////////////
// Break - Continue //
//////////////////////
	
	The 'break;' keyword will exit the current loop or switch statement it is inside.
	As of 2.55, you can supply a number to break multiple loops at once:

	[example-- 

		for(int a = 0; a < 50; ++a)
		{
			for(int b = 0; b < 50; ++b)
			{
				if(b == 3)
					break 2; //breaks out of BOTH loops
			}
		}

	--end example]
	
	The 'continue;' keyword, rather than exiting a loop, skips back to the top of it.
	'continue' ignores 'switch' statements, unlike 'break'.
	
	[example-- 

		for(int a = 0; a < 50; ++a)
		{
			for(int b = 0; b < 50; ++b)
			{
				if(b == 3)
					continue 2; //continues to the top of the 'a' loop
			}
		}

	--end example]
	
	
	 _    __      __              ____                       
	| |  / /___ _/ /_  _____     / __ \____ _____  ____ ____ 
	| | / / __ `/ / / / / _ \   / /_/ / __ `/ __ \/ __ `/ _ \
	| |/ / /_/ / / /_/ /  __/  / _, _/ /_/ / / / / /_/ /  __/
	|___/\__,_/_/\__,_/\___/  /_/ |_|\__,_/_/ /_/\__, /\___/ 
	                                            /____/       
						    
	// Value Ranges
	A Value Range represents a constant range of numbers.
	
	Several value range symbols can be used, with slightly different functions:
		A..B	- represents the numbers between A and B, NOT including A or B.
		A..=B	- represents the numbers between A and B, including B but not A.
		A=..B	- represents the numbers between A and B, including A but not B.
		A=..=B	- represents the numbers between A and B, including both A and B.
		A...B	- same as A=..=B
	
	The numbers in this range may have decimal places, and you may use constants
		as the upper and lower bounds of a range.
		
	The left value of a range must be smaller than the right:
		1=..=3
		This is a range of values >= 1.0000 and <= 3.0000
		
		3=..=1
		This is invalid and will generate an error. 
		The values being the same as each other will also generate an error.
	
	Uses:
		Value Ranges can be used in cases of switch statements. If the switch key is
			within the range, that case will execute.
	
	[example-- 
		float a = 1.5;
		const float B = 1.0;
		const float C = 2.5;
		switch(a)
		{
			case B...2.4: DoFirst(); break;
			case C...3: DoSecond(); break;
		}
	--end example]

	As the value of 'a' at this time is 1.5000, it fallswithin the range of the
	first case (B...2.4) and DoFirst() will execute.
	
	Alternatively, to set up a simple percentage roll of randomness:
	[example--
		switch(RandGen->Rand(99)) //0-99 inclusive
		{
			case 0=..10: //10% chance
				break;
			case 10=..30: //20% chance
				break;
			case 30=..60: //30% chance
				break;
			case 60=..100: //40% chance
				break;
		}
	--end example]
	One of the four outcomes will occur, with their respective chances.
	By using the left-sided range '=..', the range includes the left number,
		but not the right number.
	
	  _________ __         .__                      
	 /   _____//  |________|__| ____    ____  ______
	 \_____  \\   __\_  __ \  |/    \  / ___\/  ___/
	 /        \|  |  |  | \/  |   |  \/ /_/  >___ \ 
	/_______  /|__|  |__|  |__|___|  /\___  /____  >
	        \/                     \//_____/     \/ 
	
	You may use switch-case on STRING LITERALS.
	Note: You may use EITHER string literals, OR numeric values, but NOT BOTH.
	
	[example--
		char32 tmp[] = "Test";
		switch(tmp)
		{
			case "foo":
				DoSomething();
				break;
			case "bar":
				DoSomethingElse();
				break;
			case "Test":
				DoThirdThing();
				break;
			default:
				DoDefaultThing();
		}
	--end example]
	
	This will match the string against each literal, looking for an identical string.
	By default, this matches case-sensitively; though if the option 'STRING_SWITCH_CASE_INSENSITIVE'
		is nonzero, it will match case-insensitively.
		
	String literal switches and numeric switches cannot be mixed.
	[example--
		switch(foo)
		{
			case 1:
				DoSomething();
				break;
			case "foo":
				DoSomethingElse();
				break;
		}
	--end example]
	This code will produce a compile error, and is not allowed.
	
///////////////////
/// Logical Xor ///
///////////////////

ZScript now supports logical xor operations using the following tokens:
	^^
	logicalxor
	
	[example--
		if ( a ^^ b ) return true;
		if ( c logicalxor d ) return true;
	--end example]
	
If you chain logical xor operations, they are handled in a linear sequence
for their order of operations.
	[example--
		if ( a ^^ b ^^ c ^^ d )
		becomes
		if ( ( a ^^ b ) ^^ c ) ^^ d ) )
	--end example]
	
	It is prudent therefore, to properly specify order of operations for this operation.

////////////////////
// Exponentiation //
////////////////////

ZScript now supports Exponentiation via the '^^^' operator. Use of this operator works identically to
	calling the 'Pow()' function, except that the compiler can optimize constants at compile-time with
	the operator, which the Pow() function cannot do.

Note that '0^^^0' is defined to be '1'.

In the case that an exponentiation results in too large an output value,
	the minimum float value, '-214748.3648', will be returned.

// Longs
If either of the parameters to the '^^^' operator is of type 'long', a 'long exponentiation'
	will be performed instead. The 'LPow()' function has been added to match this behavior.

This means that '1L' will be treated as '1', meaning the full 32 bits can be used for the exponentiation,
	allowing larger calculations to be returned.
	Ex: '2L ^^^ 2L == 4L', 'LPow(0.0002, 0.0002) == 0.0004' (as 1L == 0.0001)

///////////////
// NOT Token //
///////////////

You may now use the Not (!) token on any datatype, as in C++.
Example:
	ffc f;
	if ( !f ) f = Screen->LoadFFC(3);
	
	bitmap b;
	if ( !b ) b = Game->CreateBitmap(16,16);
	else b->Create(0, 16, 16);
	
This allows checking if a pointer is initialised, easily. 


///////////////////
// Short Circuit //
///////////////////

Fixed short-circuiting. Logical AND and Logical OR now short-circuit as in C,
based on a compiler flag.

If short-circuiting is enabled, the following occurs:

	if ( a && b ) 
		//if 'a' is false, 'b' is skipped.
	if ( a || b )
		//if 'a' is true, 'b' is skipped. 


/////////////////////
// Constant Assert //
/////////////////////

You may now make constant assertions to create custom compile errors.

	[example--
		const int COMBO = 0;
		//
		CONST_ASSERT(COMBO > 0);
	--end example]
	This would cause the compile error:
		"Assert failed!"
	on the line of the assert.
	
You may also include a custom message to be printed with the error.

	[example--
		const int COMBO = 0;
		//
		CONST_ASSERT(COMBO > 0, "COMBO must be > 0!");
	--end example]
	This would cause the compile error:
		"Assert failed! COMBO must be > 0!"
	on the line of the assert.

This can be useful to prevent yourself from making mistakes, or for scripts you share
to ensure that others using your script don't make mistakes when setting constants.

/////////////////////////
//    Include Paths    //
/////////////////////////

You may now add include paths via script.
Include paths are searched when importing/including files. You can set include paths in
	'ZScript->Compiler Settings' as general configs, though now you can also add them to scripts.
	
	[example--
	//File to include is "ZC Folder/foo/foobar.zs"
	#includepath "foo"
	#include "foobar.zs"
	--end example]
	
	All '#includepath's in a file are processed before that file's imports are checked.

/////////////////////////
// Conditional Include //
/////////////////////////

You may now conditionally include a file.

	[example--
	const bool USE_TANGO = true;
	
	#includeif(USE_TANGO, "tango.zh")
	--end example]
	
If the constant expression evaluates to true, the file will be imported.
Otherwise, it will be skipped.

//////////////////////
// Include Checking //
//////////////////////

You may now check if a file is included.

	[example--
	if(IS_INCLUDED("tango.zh"))
	{
		//Show a tango message
	}
	else Screen->Message(5);
	--end example]

This is considered a constant expression.

///////////////////////////
//  Function Prototypes  //
///////////////////////////

You may now declare a 'function prototype', which can (but does not have to) be defined later.
	[example--
	
	int foo(int x, int y);
	
	--end example]

This prototype has no body, unless you later declare the function in full.
	[example--
	
	int bar();
	
	//Later, even in another file
	
	int bar()
	{
		Trace(10);
		return 5;
	}
	
	--end example]

If the function is declared later, then that is what runs; the prototype is effectively ignored.
If the function is NOT declared later, then calls to the prototype will *still compile*, though the prototype will do
	nothing, aside from `return NULL;`.
	
You may also specify the default return value, so it will return a value other than 0!
	[example--
	
	int foo() : default 7;
	
	--end example]
If the function is never fully declared later, then this would simply `return 7;`.
The value used for this default can be any constant expression, so the following are all valid:
	[example--
	
	const int A = 5;
	int foo() : default A;
	
	int bar() : default 5 * 7;
	
	int foobar() : default (IS_INCLUDED("tango.zh") ? 10 : 2);
	
	--end example]

Do note that the type of the default value must match the return type. The default return, 'NULL', is 'untyped', and
	will work for any type.
	
	[example--
	
	ffc foo() : default <ffc>1; //correct
	ffc foo() : default 1; //Type cast error
	ffc foo(); //Returns a null pointer
	ffc foo() : default NULL; //Same as above
	
	void foo() : default 1; //Type cast error
	void foo(); //correct
	--end example]

////////////////////////////////
//  Function Optional Params  //
////////////////////////////////

You may now have optional parameters in functions.
	[example--
	void foo(int x = 25)
	{
		Trace(x*2);
	}
	foo(); //Traces '50'
	foo(10); //Traces '20'
	--end example]

Optional parameters cannot have any non-optional parameters listed after them.
The default value for an optional parameter must be compile-time constant.

////////////////////////////////
//  Function Variadic Params  //
////////////////////////////////

For any function which does NOT use optional paramters, you may instead
	use variadic parameters.
	[example--
	int sum(...int[] args)
	{
		int sum = 0;
		for(x : args)
			sum += x;
		return sum;
	}
	Trace(sum(1,2,3)); //traces 6
	Trace(sum(5,20,3,2)); //traces 30
	--end example]

The variadic parameter can take any number of matching paramters, and stuffs
	them into an array for you. A size 0 array is possible if none are passed.

/////////////////////////////
//  Function Declarations  //
/////////////////////////////
	
You can now declare functions in remote scopes.
	[example--
	
	ffc script foo{}
	//
	void foo.run(int x)
	{
		Trace(x);
	}
	--end example]
This is especially useful with function prototypes!
	[example--
	
	ffc script foo
	{
		void run()
		{
			Trace(bar());
		}
		int bar();
	}
	//Another file
	int foo.bar()
	{
		return 10;
	}
	--end example]

__________              _____.__                      
\______   \__ __  _____/ ____\__|__  ___ ____   ______
 |    |  _/  |  \/ ___\   __\|  \  \/  // __ \ /  ___/
 |    |   \  |  / /_/  >  |  |  |>    <\  ___/ \___ \ 
 |______  /____/\___  /|__|  |__/__/\_ \\___  >____  >
        \/     /_____/                \/    \/     \/ 

									// Bugfixes
	
///////////////////////
// Constant Division //
///////////////////////

Fixed a bug where division of a constant would result in truncation that did not occur in 2.50.x
Fixed issues with division by an integer, where values would be truncated.
Added #option TRUNCATE_DIVISION_BY_LITERAL_BUG as a compiler flag to enable the old, 2.50.x behaviour
Fixed scope resolution for identifiers and variables when used across
	imported files.
	Example:

		//buffer

		import "bar.zs"
		void foo()
		{
			scrid.bar();
		}
		////////////////////end of buffer
		
		//bar.zs
		
		ffc script scrid
		{
			void run(){}
			voud bar(){ Trace(1); }
		}
	
	This worked in 2.50.x, but broke at some point in 2.55, and the
	correct behaviour has been restored. 
		
Script errors will now give line and column references prior to the
	error type.
		
	Old:
		Error S007: Variable X can't have type VOID.
			@ LINE 4 COLUMNS 1-11
		
	New: 
		LINE 4 @ COLUMNS 1-11 - ERROR S007: Variable X can't have type VOID.
Syntax errors have yet to be updated.
		
Fixed some issues where compiler errors improperly carried over. 

Fixed import directive pathing with backslashes:
	Importing in zscript with a path such as scripts\scriptfile.z used to work, in prior versions. 
	As of 2.55, it reads \ as an escape character, and parses the file path improperly. 
	This has now been corrected, so that you may use / or \ as a valid path token, however, / is the better option.


//////////////
// Waitdraw //
//////////////

The Waitdraw() instruction defers further execution of a script (pausing it) until 
	draws to the screen have been rendered for the present frame.
	
The following script types now support Waitdraw():
ffc, screendata, eweapon, itemsprite, itemdata.
You may disable Waitdraw support (for compatibility reasons) for ffc scripts, 
	and itemdata scripts in the ZScript Quest Settings Dialogue.
	
Waitdraw support for npc, and lweapon scripts remains t/b/a.



  _________            .__        __    ___________                            
 /   _____/ ___________|__|______/  |_  \__    ___/__.__.______   ____   ______
 \_____  \_/ ___\_  __ \  \____ \   __\   |    | <   |  |\____ \_/ __ \ /  ___/
 /        \  \___|  | \/  |  |_> >  |     |    |  \___  ||  |_> >  ___/ \___ \ 
/_______  /\___  >__|  |__|   __/|__|     |____|  / ____||   __/ \___  >____  >
        \/     \/         |__|                    \/     |__|        \/     \/ 

 									// Script Types

///////////////////
/// FFC Scripts ///
///////////////////

TOKEN(s):		ffc script
POINTER: 		ffc
InitD:			Yes, [8]
InitD Labels:		No
InitA:			Yes, [2]
Multiple Frames:	Yes
Waitdraw Support:	Yes, depends on QR

* FFC Scripts are the absolute, pure origin og ZScript. Originally called FFScript, and designed 
* to be attached to 'FreeForm Combos' in ZQuest 2.11, FFC scripts still serve this subtle, yet powerful
* purpose to this day.

* The 'this' pointer for ffc scripts is ffc (ri->ffcref).
* You can assign this script type to each of the 32 ffcs on every mapscreen via the menus
* 	Screen>>>Edit FFC>>Script (tab).
*
* In order to run its script, not only must you set the script ID, but the FFC MUST use a combo ID
*	greater than zero. Combo ID 0 cannot run scripts initially, although an already-running
* 	ffc script can write this->Data = 0without the script exiting,
*
* FFC scripts can run for multiple frames, and in addition to the eight standard D[] registers,
*	they have two A[] (address) registers, however the use of A registers is exclusive to ZASM
*	(assembly code) scripts, and there is no benefit to using them in the ZScript C++ style
*	language.
*
*	The purpose of these A registers is to allow ASM-level access to the D-registers of other FFC 
*		scripts running on the same screen.
* In past versions of ZQuest, FFC scripts did not have support for the Waitdraw instruction.
* As of 2.55, Alpha 26, FFCs can use Waitdraw() properly.
* A QR governs this capability: Legacy quests will disable FFC Waitdraw support on quest loading
* 	in ZC Player, and when you load the old quest into the ZQ Editor,
(	New quests created in 2.55 have Waitdraw() support enabled by default.
*	You may enable Waitdraw support in legacy quests by toggling the ZScript setting:'No FFC Waitdraw'.
*	When this setting is enabled, FFC scripts that call Waitdraw() behave as 2.11->2.53 FFC scripts 
* 		that call Waitdraw().



//////////////////////
/// Global Scripts ///
//////////////////////

TOKEN(s):		global script
POINTER: 		n/a
InitD:			No
InitD Labels:		No
InitA:			No
Multiple Frames:	Yes, based on slot.
Waitdraw Support:	Yes, based on slot.

* Global scripts run without context to a specific pointer or datatype.
* There are six, fixed slota; of which you may directly assign scripts
* to five. 
* 
* Slot assignment during compilation to the ~Init Slot (1) is automatic.
* 
* Global scripts do not have InitD args, and parameters listed within the 
* braces of the normal run(...) function are initialised to NULL (0).
* 
* Global scripts are executed automatically when their conditions are valid, 
* based on the script slot to which the user assigns them.

//////////////////////////
// Slot (1) : Game Init //
//////////////////////////

*	SLOT NAME: '~Init'
*
* 	This script runs FOR ONE FRAME, on the first play of a quest.
* 	It is used to initialise global arrays, and the user can create additional
* 	context for it by creating a script named 'global script Init'. 
* 	
* 	During post-compilation slot assignment, any global script with the
* 	EXACT IDENTIFIER 'Init' will be assigned to this slot.
* 
* 	Manual slot assignment to ~Init is possible for ASM script imports,
* 	but doing this may have unintended side-effects.
* 	
* 	Any instructions within the body of the run() function of the script
* 	will execute during game initialisation, but only if the player has not
* 	saved the game.

///////////////////////
// Slot (2) : Active //
///////////////////////

*	SLOT NAME: 'Active'
*
* 	This script can run for multiple frames, and runs during the normal action of the game.
* 	
* 	The typical purpose of this script slot is to tailor the game engine to your needs, and 
* 	the body of its run() function serves as the ZScript equivalent to a main() loop in C.
* 
* 	Generally, the body of this script is an infinite loop, ending in a Waitframe(), although
* 	it may consist of a conditional loop or series of loops, each with instructions to process
* 	during different stages of your game.
* 
* 	Normally, if the player is still playing the quest, then this script is running:
* 		It automatically terminates if you issue a Quit() instruction, if it runs out of scope, 
* 		or under one of the following conditions:
* 	
* 		The player HP falls below '1'. 
* 			Under this circumstance, the script runs for ONE additional frame to allow
* 			your scripts to restore the player HP.
* 			Failing to revive the player will exit this script, and the Hero Scrit Death Slot
* 				will run, followed by the Global Exit Slot (3).
* 				!!VERIFY TIMING
* 		The player triggers the F6 menu.
* 		Any script calls Game->Continue(), or Game->End().
* 
* 	The global active script can run for multiple frames, and supports the Waitdraw() command.

//////////////////////////
// Slot (3) : Game Exit //
//////////////////////////

*	SLOT NAME: 'onExit'
*
* 	This script runs FOR ONE FRAME, after the player dies, or otherwise after the 
* 	game action ends via calling the game over menu.
* 
* 	The purpose of this script slot is to modify global variables or array values prior to 
* 	writing the game save, such as the number of times the polayer has saved his adventure.

///////////////////////////////
// Slot (4) : Load from Save //
///////////////////////////////

*	SLOT NAME: 'onSaveLoad'
*
* 	This script runs FOR ONE FRAME, on every load of a quest from the file select 
* 	screen, AFTER the player has saved the game at least one time.
* 
* 	This script does not run when continuing a game with F6>>>Contunue from the game over
* 	menu, nor when continuing a game with the Game->Continue() ZScript command.
* 
* 	The purpose of this script slot is to reinitialise any user-created conditions, such as re-init
* 	of user bitmaps, re-priming global pointers, or otherwie ensuring that your global or internal
* 	values are correct before the game resumes from a file where values to these variables / pointers
* 	may now be stale, but were saved to the .sav file.

//////////////////////////
// Slot (5) Game Launch //
//////////////////////////

* 	SLOT NAME: 'onLaunch'
*
* 	This script slot runs for MULTIPLE FRAMES, on every load of a quest from the file select 
* 	screen, whether the quest has been previously played, or not. 
* 
* 	This script does not run when continuing a game with F6>>>Contunue from the game over
* 	menu, nor when continuing a game with the Game->Continue() ZScript command.
* 
*	It is similar to slots (1) and (4), and can take the place of either, unless you have timing-specific 
* 	issues that require two scripts to execute.
* 
* 	This script runs after global slot (1) and after Hero script slot (1) on a virgin save slot, 
* 	or directly after global slot (4) if the game has previously been saved.
* 
* 	The purpose of this script slot is to reinitialise any user-created conditions, such as re-init
* 	of user bitmaps, re-priming global pointers, or otherwise ensuring that your global or internal
* 	values are correct before the game resumes from a file where values to these variables / pointers
* 	may now be stale, but were saved to the .sav file.
*
*	This script will run until either you exit the game via a command such as 'Game->End()', or you exit the script.
*	Exiting the script without invoking a command such as 'Game->End()' will proceed to the opening wipe.

/////////////////////////////////////////
// Slot (6) :  Continue Game from Menu //
/////////////////////////////////////////

*	 SLOT NAME: 'onContGame'
*
*	 This script runs FOR ONE FRAME, when the user resumes/reloads an already-running
*	 game either via F6>>>Contunue, or Game->ShowContinueScreen(), from the game over menu, 
*	 or by continuing a game with the Game->Continue() and similar ZScript commands.
* 
*	 This script does not run when loading a game from the file select screen.
* 
*	 The purpose of this script slot is similar to that of slots (2), (4) and (5), but it may also 
*	 be useful in setting minor conditions, such as the player health/magic.
* 
*	 This script slot runs prior to the opening wipe.

/////////////////////
// Slot (7) : Menu //
/////////////////////

*	SLOT NAME: 'onF6Menu'
*
*	This script runs for multiple frames, whenever the player presses F6 or selects the system menu option
*	'Game>>End Game' to display the save screen menu, or runs the 'Game->ShowContinueScreen()' ZScript command,
*	(but not when the player dies; see Hero Slot (3) 'onDeath' for that application.)
*
*	If the compatibility rule 'Old (Instant) F6 Menu' in 'Quest->Rules->Backwards Compatibility' is enabled,
*	this script slot will never be executed.
*
*	The purpose of this script slot is to permit making a drop-in, scripted  replacement for the standard 
*	Continue/Save/Retry menu screen.
*
*	During the execution of this script, all script draws will occur above a static image of the screen as it was
*	before the script began. All engine action, save for this script, and input polling, will be suspended for the duration
*	of the script.
*
*	This script will run until either you exit the game via a command such as 'Game->End()', or you exit the script.
*	Exiting the script without invoking a command such as 'Game->End()' will then open the standard system F6 menu,
*	unless the quest rule 'Skip Continue Screen' in 'Quest->Rules->Other' is active. If the player does not chooses
*	to exit via the standard continue screen, or it is skipped via the aforementioned rule, gameplay will resume
*	exactly where it left off.

//////////////////////
// Slot (8) :  Save //
//////////////////////

*	 SLOT NAME: 'onSave'
*
*	 This script runs FOR ONE FRAME, when the game saves the save data.
*	 This occurs either from F6>>>Save (or GameOver>>>Save), when saving via a Save Point combo type,
*	 as well as from the ZScript commands 'Game->Save()', 'Game->SaveAndQuit()', and 'Game->SaveAndContinue()'.
*	 
*	 This runs AFTER the 'onExit' script, in any condition that would cause both to run.
*	 
*	 The main purpose of this script is to allow saving of custom script data that would NOT be saved to the
*	 save file; such as ZScript files, bitmap images, or SRAM.

   
////////////////////
/// Hero Scripts ///
////////////////////

TOKEN(s):		hero script, player script; link script (deprecated)
POINTER: 		Hero, Player, Link
InitD:			No
InitD Labels:		No
InitA:			No
Multiple Frames:	Yes, based on slot.
Waitdraw Support:	Yes, based on slot.

* You can now compile and assign scripts to the Hero.
* The 'this' pointer is identical to `Hero`, ex. `this->X` `this->Y` `this->HP`
* When you compile this script type, you can assign it to one of the following slots,
* 	which determines when it runs, and how often it runs.
* Hero scripts are executed automatically when their conditions are valid, 
* 	based on the script slot to which the user assigns them.

/////////////////////
// Slot (1) : Init //
/////////////////////

*	SLOT NAME: 'Init'
*
* 	This script runs FOR ONE FRAME at the start whenever the player sprite is initialised, 
*	both at the start of a game, and via F6>>>Continue (or Game->Continue()).
*	
*	It allows you to set up initial values for the player, BEFORE the opening wipe, such as his 
*	Invisibility state, or his screen position.
* 	You can give the player  equipment, and other effects at this time.
*
*	These effects take place BEFORE the engine writes to Screen->EntryX, and Screen->EntryY, 
*	so if you give the player sprite custom starting coordinates by script, reading those values 
*	from the Screen pointer, should give you accurate data.
*

///////////////////////
// Slot (2) : Active //
///////////////////////

*	SLOT NAME: 'Active'
*
*	This script slot runs after (1), and also after the global script (2; active).
*
* 	This script can run for multiple frames, and runs during the normal action of the game.
* 	
* 	The typical purpose of this script slot is to control the player sprite in ways that 
*	extend beyond the normal internal engine mechanics, such as scaling the sprite with the
* 	Z-Axis of the player, or using scripted tiles and animations for diagonal walking.
*
* 	Generally, the body of this script is an infinite loop, ending in a Waitframe(), although
* 	it may consist of a conditional loop or series of loops, each with instructions to process
* 	during different stages of your game.

*	This script can run for multiple frames, until either it runs out of, scope, 
*	you call Quit() inside the script body, or the player presses F6 to open the standard
*	SAVE/CONTINUE/RETRY menu.
*
* 	You may use Waitdraw() in this script type. 
*	
*	If Hero dies, this script halts, and hero script (3), 'onDeath' runs.
*	If Hero wins the game, this script halts, and hero script (4), 'onWin' runs.
*

//////////////////////
// Slot (3) : Death //
//////////////////////

*	SLOT NAME: 'onDeath'
*
*	This script runs when Hero DIES. 
*	It runs BEFORE the GLOBAL EXIT script, and after Hero is DEAD, with no chance of revival.
*		^ If you need to revive the player, such as with a Faerie in a Bottle, use the
*		^ Hero Active script slot for that effect.
*	The script will run before the engine's death animation, unless the quest rule
*	'Hero OnDeath script runs AFTER engine death animation' under 'ZScript->Quest Script Settings' is selected, in which case
*	it will run immediately following this animation.
*
*	This script can run for multiple frames, and is intended to permit you to construct your
*	own Game Over sequences.
*
*	During the execution of this script, all script draws will occur above a static image of the screen as it was
*	before the script began. All engine action, save for this script, and input polling, will be suspended for the duration
*	of the script.
*
*	This script will run until either you exit the game via a command such as 'Game->End()', or you exit the script.
*	Exiting the script without invoking a command such as 'Game->End()' will continue the player's death where it left off.
*	If the script is set to run prior to the engine death animation, exiting via a command such as 'Game->End()' will
*	skip the engine's death animation.

///////////////////////
// Slot (4) : Ending //
///////////////////////

*	SLOT NAME: 'onWin'
*
*	This script runs if the player WINS THE GAME (e.g. via Combo Flag 15).
*	It can run for more than one frame, and it is intended to permit you to make your own
*	Game Ending scenes, or credits scroll.
*
*	You can disable the internal credits scroll, or you can permit that to run normally,
*	after your own credits sequence via the command Game->SkipCredits.


////////////////////
/// DMap Scripts ///
////////////////////
 
TOKEN(s):		dmapdata script
POINTER: 		dmapdata
InitD:			Yes, [8] each (active, scripted subscreen)
InitD Labels:		Yes, [8] each (active, scripted subscreen)
InitA:			No
Multiple Frames:	Yes
Waitdraw Support:	Yes

* You can now compile and assign scripts to DMaps.
* The 'this' pointer for dmapdata scripts is dmapdata (ri->dmapsref).
*
* This script can run for multiple frames, and it runs after the GLOBAL ACTIVE script.
* You may use Waitdraw() in this script type. 
* 
* There are four script slots in the DMap Editor:
*	Active
*		This script runs whenever the player is on the DMap.
*		It has eight InitD args, and eight InitD strings.
*		If the player warps while this script is running, then the engine 
*		will load the DMap Active script from the destination DMap (if any).
*			If using a scripted DMap Active Subscreen script, you have
*			the option that this script continues to run while the scripted
*			subscreen is open.
*	Scripted Subscreen (Active)
*		This script runs, if assigned, when the player presses the
*		START button, IN PLACE OF THE NORMAL ACTIVE SUBSCREEN for this DMap.
*		This script type hasd eight InitD args and eight InitD strings.
*		InitD with this script type is shared with the DMap Passive Subscreen Script Slot.
*		If the player warps while this is running, then the engie will
*		load the Scripted Subscreen (Active) DMap script from the destination DMap (if any).
*		If the destination DMap lacks a Scripted Subscreen (Active) DMap script,
*		then the virtual subscreen will terminate.
*	Scripted Subscreen (Passive)
*		If assigned, this script runs whenever the player is on the DMap.
*		Its purpose is to permit creating a scripted passive subscreen.
*		This script shares its InitD args and its InitD strings with the Scripted
*		Subscreen (Active) DMap slot script.
*		If the player warps while this script is running, then the engine
*		will load the Scripted Subscreen (Passive) script from the destination
*		DMap (if any).
*			If using a scripted DMap Subscreen (Active) script, then you
*			further have the option that this script continues to run while
*			the scripted active subscreen is open.
*	Scripted Map
*		This script runs, if assigned, when the player presses the
*		MAP button, IN PLACE OF THE NORMAL ENGINE MAP.
*		This script type hasd eight InitD args and eight InitD strings.
*		If the player warps while this is running, then the engie will
*		load the Scripted Map DMap script from the destination DMap (if any).
*		If the destination DMap lacks a Scripted Map DMap script,
*		then the virtual map will terminate.
*
*
*
* DMap scripts run only on DMaps where they are set to run.
* Warping to a DMap with a dmap script will start that script.
*
* You can assign this script to a DMap in the DMAPS EDITOR dialogue. 
*	To do this, open the DMAPS EDITOR, and select the 'Scripts' tab.
*
*	DMD_SUBSCREEN_ACTIVE 	= 0;
*	DMD_SUBSCREEN_PASSIVE 	= 1;
*
* DMap Active Scripts have eight InitD[] args, in the DMAP EDITOR for this script type.
* 	You may assign values to these in the DMAP EDITOR, and you may label the fields
* 	for these InitD values in the DMAP EDITOR.
* 	You may also read or write to them by script with dmapdata->InitD[] (or this->InitD[])
*
* DMap Subscreen Scripts have eight InitD[] args, in the DMAP EDITOR for this script type.
*	You may assign values to these in the DMAP EDITOR, and you may label the fields
* 	for these InitD values in the DMAP EDITOR.
* 	Both subscreen script types shjare the InitD values and labels, per DMap.
* 	You may also read from, or write to them by script with dmapdata->SubscreenInitD[].
* 
* Trying to modify the script while it is running with this->Script, is untested.


//////////////////////
/// Screen Scripts ///
//////////////////////

TOKEN(s):		screendata script
POINTER: 		Screen
InitD:			Yes, [8]
InitD Labels:		No
InitA:			No
Multiple Frames:	Yes
Waitdraw Support:	Yes

* You can now compile and assign scripts to individual screens.
* The 'this' pointer for screendata scripts is identical to 'Screen->'.
*
* This script can run for multiple frames, and it runs before ffcs.
* You can enable the tick box 'Run on Screen Init'. if this is enabled, ther script runs as soon as the screen
* starts to scroll into view.
*
* Screen scripts run only on screens where they are set to run.
* Warping to a screen with a screen script will start that script.
*
* You can assign this script to a screen in the SCREEN SCRIPT EDITOR dialogue. 
*	To do this, access the Screen menu, and select the entry 'Script'.
*
* You may assign scripts to screens from other scripts, via Screen->Script, or mapdata->Script
* 	on an initialised mapdata pointer.
*
* Screen Scripts have eight InitD[] args, in the SCREEN SCRIPT EDITOR for this script type.
* 	You may assign values to these in the SCREEN SCRIPT EDITOR, but you may not label the fields
* 	for these InitD values in the SCREEN SCRIPT EDITOR.
* 	You may also read or write to them by script with Screen->InitD[] (or mapdata->InitD[], or this->InitD[]).
*
* Trying to modify the script while it is running with this->Script, is untested.


///////////////////
/// NPC Scripts ///
///////////////////

TOKEN(s):		npc script
POINTER: 		npc
InitD:			Yes, [8]
InitD Labels:		Yes, [8]
InitA:			No
Multiple Frames:	Yes
Waitdraw Support:	No

* You can now compile and assign scripts to npcs. 
* The 'this' pointer for npc scripts is npc (ri->guyref).
* You can assign this script type to enemies in the ENEMY EDITOR:
* 	To do this, select the 'Scripts' tab, and then select the 'Action Script' tab. 
* You may assign scripts to enemies from other scripts, via npc->Script.
*
* You can read, or write to the ENEMY EDITOR data for the script ID, with npcdata->Script
* 	on an initialised npcdata pointer.
*
* Enemies have eight InitD[] args, in the ENEMY EDITOR for this script type.
* 	You may assign values to these in the ENEMY EDITOR, and you may label the fields
* 	for these InitD values in the ENEMY EDITOR.
* 	You may also read or write to them by script with npc->InitD[] (or this->InitD[])
* 	or npcdata->InitD[]. 
* Trying to modify the script while it is running with this->Script, is untested.
* Use of these on Room Guys is untested, but should be feasible. 


///////////////////////
/// EWeapon Scripts ///
///////////////////////

TOKEN(s):		eweapon script
POINTER: 		eweapon
InitD:			Yes, [8]
InitD Labels:		Yes, [8]
InitA:			No
Multiple Frames:	Yes
Waitdraw Support:	No

* You can now compile and assign scripts to eweapons.
* The 'this' pointer for npc scripts is eweapon (ri->ewpn).
* You can assign this script type to the weapon generated by an npc in the ENEMY EDITOR.
* 	To do this, select the 'Scripts' tab, and then select the 'Weapon Script' tab. 
* You may assign scripts to eweapons from other scripts, via eweapon->Script, 
* 	on an initialised eweapon pointer.
*
* You can read, or write to the ENEMY EDITOR data for the script ID, with npcdata->WeaponScript.
*
* Enemy Weapons have eight InitD[] args, in the ENEMY EDITOR for this script type.
* 	You may assign values to these in the ENEMY EDITOR, and you may label the fields
* 	for these InitD values in the ENEMY EDITOR.
* 	You may also read or write to them by script with eweapon->InitD[] (or this->InitD[])
* 	or npcdata->WeaponInitD[]. 
* Trying to modify the script while it is running with this->Script, is untested.


///////////////////////
/// LWeapon Scripts ///
///////////////////////

TOKEN(s):		lweapon script
POINTER: 		lweapon
InitD:			Yes, [8]
InitD Labels:		Yes, [8]
InitA:			No
Multiple Frames:	Yes
Waitdraw Support:	No

* You can now compile and assign scripts to lweapons.
* The 'this' pointer for npc scripts is lweapon (ri->lwpn).
* You can assign this script type to the weapon generated by an item in the ITEM EDITOR.
* 	To do this, select the 'Scripts' tab, and then select the 'Weapon Script' tab (W.Script).
* You may assign scripts to lweapons from other scripts, via lweapon->Script
* 	on an initialised lweapon pointer.
*
* You can read, or write to the ITEM EDITOR data for the script ID, with itemdata->WeaponScript.
*
* Link Weapons have eight InitD[] args, in the ITEM EDITOR for this script type.
* 	You may assign values to these in the ITEM EDITOR, and you may label the fields
* 	for these InitD values in the ITEM EDITOR.
* 	You may also read or write to them by script with lweapon->InitD[] (or this->InitD[])
* 	or itemdata->WeaponInitD[]. 
* Trying to modify the script while it is running with this->Script, is untested.


//////////////////////////
/// itemsprite Scripts ///
//////////////////////////

TOKEN(s):		itemsprite script
POINTER: 		itemsprite
InitD:			Yes, [8]
InitD Labels:		Yes, [8]
InitA:			No
Multiple Frames:	Yes
Waitdraw Support:	Yes

* You can now compile and assign scripts to items that appear on the screen.
* The 'this' pointer for itemsprite scripts is itemsprite (ri->itemsref).
*
* This script can run for multiple frames. It automatically ends if the itemsprite becomes invalid.
*
* You can assign this script to an item in the ITEM EDITOR dialogue. 
*	To do this, open the ITEM EDITOR, and select the 'Scripts' tab.
*       Use the SPRITE SCRIPT lister to set this script type. 
*
* itemsprite Scripts have eight InitD[] args, in the ITEM EDITOR for this script type.
* 	You may assign values to these in the ITEM EDITOR, and you may label the fields
* 	for these InitD values in the ITEM EDITOR.
* 	You may also read or write to them by script with itemsprite->InitD[] (or this->InitD[])
*
* Trying to modify the script while it is running with this->Script, is untested.

t/b/a
Itemdata Script, FFC Script


////////////////////////
/// Itemdata Scripts ///
////////////////////////

TOKEN(s):		itemdata script
POINTER: 		itemdata
InitD:			Yes, [8]
InitD Labels:		Yes, [8]
InitA:			Yes, [2]
Multiple Frames:	Yes, depends on QR or item flag
Waitdraw Support:	Yes, depends on QR

It is now possible to permit itemdata scripts to run for more than one frame.
	To do this, you must enable the Quest Rule, 'Item Scripts Continue to Run', 
	in Quest->Rules->Scripts.
	
	This rule is disabled by default, and disabled for all legacy quests, for compatibility
	reasons.

NOTE: In previous versions, this type was simply called "item script".


/////////////////////
/// Combo Scripts ///
/////////////////////

TOKEN(s):		combodata script
POINTER: 		combodata
InitD:			Yes, [8]
InitD Labels:		No
InitA:			No
Multiple Frames:	Yes
Waitdraw Support:	t/b/a


* Each combo position, on every layer, is capable of running a script. You can set the permitted layers in the
* menu: ZScript >>> Quest Specific Settings >>> Scripts.
* combodata Scripts have eight InitD[] args, in the COMBO EDITOR for this script type.
* 	You may also read or write to them by script with combodata->InitD[] (or this->InitD[])
* Each combo in the Combo Editor may have one script, and twi InitD values, set on the 'Script' tab.
* Combo scripts, and only combo scripts, may call <combodata>this-> Pos(), PosX(), and PosY() to obtain
* coordinates for a combo running a script.


///////////////////////
/// Generic Scripts ///
///////////////////////

TOKEN(s):		generic script
POINTER: 		genericdata
InitD:			(Not *yet*)
InitD Labels:	No
Multiple Frames:	Yes
Waitdraw Support:	Special

A generic script can be run in multiple different ways.

Firstly, it can run 'passively':
	Once a generic script starts running passively, there are 39 different timings throughout each
		frame that they can run. They will first run at the first available timing after being
		launched; after 'Waitframe()', they return to the "Start of Frame" timing.
	The 'WaitTo' function can be used to go to each specific timing, similarly to how
		'Waitdraw' works in other scripts.
	The 'WaitEvent' function can be used to handle specific events.
	The passive running of a generic script is also affected by it's 'ExitState' and 'ReloadState'
		arrays, which can exit the script or restart it from the beginning when certain conditions
		are met (such as changing screens/dmaps, continuing, reloading, ...)

Secondly, it can run 'frozen':
	A 'frozen' run works similar to the dmapdata 'ActiveSubscreen' slot, or global onF6 or onLaunch.
	The script will run frame after frame, with NO other part of the engine running (aside from
		combo animation, which will run unless 'Game->Suspend[]' is used) until the script
		reaches end-of-scope or exits.
	While running frozen, a still image of the screen before the script started will be
		drawn to layer 0 each frame; nothing else other than script draws is drawn.
	A generic script is run frozen using the 'genericdata->RunFrozen()' function.

/////////////////////////
/// Subscreen Scripts ///
/////////////////////////
// 
// TOKEN(s):		subscreendata script
// POINTER: 		subscreendata
// InitD:			Yes, [8]
// InitD Labels:		No
// InitA:			No
// Multiple Frames:	Yes
// Waitdraw Support:	Yes
// 
// Runs on active subcreens



_________                       .__.__                
\_   ___ \  ____   _____ ______ |__|  |   ___________ 
/    \  \/ /  _ \ /     \\____ \|  |  | _/ __ \_  __ \
\     \___(  <_> )  Y Y  \  |_> >  |  |_\  ___/|  | \/
 \______  /\____/|__|_|  /   __/|__|____/\___  >__|   
        \/             \/|__|                \/       

									// Compiler

///////////////////////////
/// Compiler Directives ///
///////////////////////////

	There's a new compile_error directive that ignores the next compiler error/warning of the 
	specified number, that you can use to suppress warnings or halts. 

	Syntax:
	#ignore error(error_number) {error_generating_code}
	#ignore warning(error_number) {error_generating_code}
	catch(error_number) {error_generating_code}
	

//////////////////////
// import, #include //
//////////////////////

The import directive now checks include paths. 
Order and Priority: It first checks an absolute path, then relative to the ZQ binaries,
	then include paths. 
	
The new directive, #include, checks include paths first, then absolute, then relative to the ZQ binaries. 
	

///////////////////
// Header Guards //
///////////////////

The default behaviour for importing duplicate headers / files is now to issue a warning, and ignore the
duplicate import directive. 

You can toggle this behaviour as follows:
	#option HEADER_GUARD warn
		Enables protection, and issues warnings on duplication.
		This is the default.
	#option HEADER_GUARD on
		Enables protection, but issues no warnings.
	#option HEADER_GUARD error
		Halts on finding a duplication.
	#option HEADER_GUARD off
		Halts, and does not give data, as 2.50.
		
If this option is set to anything other than 'off', then the compiler will detail the location of the
original import, and the location of the duplicate, per instance of duplication. 

This option is set in the config files, and not per-quest.
	

///////////////////////////
// Compiler Option Flags //
///////////////////////////

There are now compiler flags that you may enable, or disable, to
emulate old bugs, or to toggle certain actions.

To use these, call the #option directive, followed by the flag macro, and (on | off | error | warn | inherit | default).
	#option LOGGING off
	
	Flag types:
		on : This enables the option.
		off: This disables the option.
		error: Used for certain options.
		warn: Used for certain options.
		inherit: This causes the option to inherit from its last state (e.g., from an importing file). 
		default: Use the default ZQuest value for this option. (Set in 'ZScript->Compiler Settings')
	
	MACROS
	
	NO_LOGGING
		Off by default.
		Valid values: 'on', 'off', 'inherit', 'default'
		If set 'on', then all calls to Trace() type functions will be ignored. 
	
	TRUNCATE_DIVISION_BY_LITERAL_BUG
		Off by default, however on by default for quests made prior to 2.55.
		Valid values: 'on', 'off', 'inherit', 'default'
		Enable this to force scripts to comply to the 2.50.x
			bug, where division by a literal resulted in truncation.
		
	SHORT_CIRCUIT
		On by default, however off by default for quests made prior to 2.55.
		Valid values: 'on', 'off', 'inherit', 'default'
		Enable short-circuiting; see section 'Short Circuiting' above
		
	BOOL_TRUE_RETURN_DECIMAL
		Off by default, however on by default for quests made prior to 2.55.
		Valid values: 'on', 'off', 'inherit', 'default'
		If on, the boolean value 'true' will be represented as '0.0001' instead of '1'.
			This may be necessary for compatibility with some scripts.
			
	HEADER_GUARD
		Warn by default.
		Valid values: 'on', 'off', 'error', 'warn', 'inherit', 'default'
		If on, duplicate import statements will be totally ignored.
		If off, duplicate imports will be processed, as in 2.50.x
		If error, duplicate imports will throw a compiler error.
		If warn, duplicate imports will be ignored, though will throw a compiler warning.
		
	NO_ERROR_HALT
		Off by default.
		Valid values: 'on', 'off', 'inherit', 'default'
		If on, compilation will continue even when a compiler error has been thrown.
			The script will still fail to compile, though it will issue all reachable errors before failing, instead of only the first one it encounters.
		If off, compilation will halt on the first encountered error, as in previous versions.
		
	TRUE_INT_SIZE
		On by default, however off by default for quests made prior to 2.55.
		Valid values: 'on', 'off', 'inherit', 'default'
		If on, the range of int/float constants will be expanded to '-214748,214748' and '-214748.3648,214748.3647' respectively.
		If off, the range will remain '-214747,214747' and '-214747.9999,214747.9999', as in previous versions.
		
	FORCE_INLINE
		Currently unused, pending full implementation of 'inline'
		
	BINARY_32BIT
		Off by default.
		Valid values: 'on', 'off', 'inherit', 'default'
		If on, binary operations and literals will use the true 32-bit values of a number, rather than the ZScript values.
			This means that '1b' == '0.0001' instead of '1'.
			This allows 32 separate bits to be used, which can be usedful for flagsets.
		If off, binary will behave as it did previously.
		This option is FORCED to 'off' for 'std.zh', as it would break a number of functions.
		Be cautious when using this option.
		
	APPROX_EQUAL_MARGIN <float>
		Sets the margin of error for the ~~ (approximately equal) operator.
		The defailt margin of error is 0.0100, so (1.090 ~~ 1.080) == true.
		Set to a foating point value to use a new error margin for ~~.
	
	STRING_SWITCH_CASE_INSENSITIVE
		Off by default.
		Valid values: 'on', 'off', 'inherit', 'default'
		If on, switch-case on string literals will be case-insensitive.
		Else, they will be case-sensitive.
	
	WARN_DEPRECATED
		Off by default.
		Valid values: 'on'/'warn', 'off', 'error', 'inherit', 'default'
		On using a deprecated internal function/variable, a compile
			warning will be thrown.
		If 'off', this is disabled.
		If 'error', a compile error will be thrown instead of a warning.
		
Files default to inheriting the option state of the file that imported them. For the buffer, this will use the defaults.
You may force an option to its' default value by setting it to 'default'
The default values can be modified in ZQuest, under 'ZScript->Compiler Settings'.

Note: 	You can use any constant expression, or constant value that is one to represent 'on',
	and any constant expression, or constant value that is zero to represent 'off'.
	For options which only take 'on' or 'off', any other value is treated as 'on'.
	You can use any constant expression, or constant value that is two to represent 'error',
	and any constant expression, or constant value that is three to represent 'warn'.
	The options 'inherit', and 'default' are specific, and not bound to any literal value. 
	Thus, you cannot create macros for them, or otherwise trigger them with constant expressions.

/////////////////////////////
//       Annotations       //
/////////////////////////////

Annotations allow for metadata to be set in specific circumstances.

An annotation is specified as follows:
	@Key("Value")
Annotations can be listed together to use multiple on the same target, as follows:
	@Key("Value"), @Key2("Value2")

Annotations can be attached to various script elements, and will be listed where appropriate.

//////////////////////////////
//    Script Annotations    //
//////////////////////////////

The following annotations can be attached to any `script`

	[example--
		
		@Author("EmilyV") //This sets the 'Author' metadata of 'script foo' to read 'EmilyV'
		ffc script foo
		{
			void run()
			{
				TraceS("Test");
			}
		}
		
	--end example]

Available annotations:

	@Author -
		Function: Sets the author name metadata field
		Value: String (limit 255 chars)
	
	@Attribute0 - @Attribute9
	@Flag0 - @Flag15
		Function: Sets attribute metadata for the script.
		Editor effect: Combo and Item editor label text
		Value: String (limit 255 chars)
	@Attribyte0 - @Attribyte7
	@Attrishort0 - @Attrishort7
		Function: Sets attribute metadata for the script.
		Editor effect: Combo editor label text
		Value: String (limit 255 chars)
	
	@AttributeHelp0 - @AttributeHelp9
	@FlagHelp0 - @FlagHelp15
		Function: Sets attribute help text metadata for the script.
		Editor effect: Combo and Item editor help text
		Value: String (limit 65535 chars)
	@AttribyteHelp0 - @AttribyteHelp7
	@AttrishortHelp0 - @AttrishortHelp7
		Function: Sets attribute help text metadata for the script.
		Editor effect: Combo editor help text
		Value: String (limit 65535 chars)
	
	@InitD0 - @InitD7
		Function: Set InitD label info.
		Editor effect: Combo, FFC, Item, LWeapon scripts
		Value: String (limit 255 chars)
		Default value: void run() parameter name
	
	@InitDHelp0 - @InitDHelp7
		Function: Set InitD help text.
		Editor effect: Combo, FFC, Item, LWeapon scripts
		Value: String (limit 65535 chars)
	
	@InitDType0 - @InitDType7
		Function: Set InitD field type.
		Editor effect: Combo, FFC, Item, LWeapon scripts
		Value: "D","H","LD","LH","B", or "-1"
		Default value: Based on void run() parameter type-
			int, float, untyped: "D"
			long: "LD"
			bool: "B"
			otherwise: "-1"
	
	@InitScript
		Valid on: Global Scripts
		Function: Mark the script to be merged into the global ~Init slot
		Value: Number, a weight used to determine merge order.
		       (the 'global script Init' has a weight of 0)
		Default value: Unset. Setting this to ANYTHING stops the default
		               behavior, and marks the script to be merged.

//////////////////////////////////
/// Mechanical and AST Changes ///
//////////////////////////////////

	Assignment is now an expression instead of a statement. You can theoretically assign 
	inside of a statement now.
	
	[example--
		
		ffc script foo
		{
			void run()
			{
				int x = 0;
				while( (x+=2) < 20 ) Waitframe();
			}
		}
		
	--end example]

	Constants are now treated as normal (unassignable) variables up through type checking. 
	If at that point the constant's value is known, it is stripped out of the AST and its 
	value is saved to the symbol table, similar to how it worked before.

	If the constant's value is not known at compile time, it is instead treated as a normal, 
	unassignable variable by the parser. (It still uses no stack space.)
		In this case, the value is still not considered compile-time constant, and thus cannot
		be used in statements such as 'repeat' and 'case'.

	Constants can now be declared in any scope, not just global scope, and the constant is only
	valid within its scope, so you may now have constants on a per-script, or per-scope basis. 
	
	[example--
	
		ffc script foo
		{
			void run()
			{
				const int X = 10;
				int a = X;
			}
		}
	
	--end example]
	
	You may assign a value to a constant using any constant expression.
	
	[example--
	
		const int A = 5;
		const int B = 10;
		const int C = A*(Pow(B,2));
	
	--end example]




 _______                  .___                 __                        __  .__                      
 \      \   ______  _  __ |   | ____   _______/  |________ __ __   _____/  |_|__| ____   ____   ______
 /   |   \_/ __ \ \/ \/ / |   |/    \ /  ___/\   __\_  __ \  |  \_/ ___\   __\  |/  _ \ /    \ /  ___/
/    |    \  ___/\     /  |   |   |  \\___ \  |  |  |  | \/  |  /\  \___|  | |  (  <_> )   |  \\___ \ 
\____|__  /\___  >\/\_/   |___|___|  /____  > |__|  |__|  |____/  \___  >__| |__|\____/|___|  /____  >
        \/     \/                  \/     \/                          \/                    \/     \/ 

									// New Instructions

//////////////
//  Global  //
//////////////								// Global

void Waitframe();
 * Pauses the script until the start of the next frame

void Waitframes(int count);
 * Waitframe() for 'count' frames in a row.
 * If 'count <= 0', no wait occurs.
 * 'count' will be rounded up.

void Waitdraw();
 * Attempts to wait until later in a frame. Script-type-dependant.

void WaitTo(int script_timing, bool at_least = false);
 * Only for passively-running 'Generic Scripts'
 * Waits until the specified timing.
 * If 'at_least' is true, any later timing will also end the wait.
 * Use the 'SCR_TIMING_' constants from 'std_constants.zh' for 'script_timing'

int WaitEvent();
 * Only for passively-running 'Generic Scripts'
 * Halts the script until an 'event' occurs, at which point it returns the event number.
 * Compare the return to the 'GENSCR_EVENT_' constants.

void Quit();
 * Exits the current script, ending it.

void QuitNoKill();
 * Exits the current script, ending it, WITHOUT cleaning up its' owned arrays/objects.
 * This should only be used if you know what you are doing!

float Distance(float x1, float y1, float x1, float y2)
 * Returns the distance between two sets of coordinates using Pythagoras' Theorem
 * The old version is now std::Distance(...)
 
float Distance(float x1, float y1, float x2, float y2, int scale)
 * Calculates the distance over a scale 'divisor' that would otherwise overflow Distance(), allowing negative coordinates.
 * The old version is now std::Distance(...) or LargeDistance(...).
   
long LongDistance(long x1, long y1, long x1, long y2)
 * Returns the distance between two sets of coordinates using Pythagoras' Theorem
 * Takes args only as long (e.g. 100L).
 * Retrns a vale as a long.
 
long LongDistance(long x1, long y1, long x1, long y2, long scale)
 * Calculates the distance over a scale 'divisor' that would otherwise overflow Distance(), allowing negative coordinates.
 * Takes args only as long (e.g. 100L).
 * Retrns a vale as a long.
 
constexpr float DegtoRad(float degrees);
constexpr float DegToRad(float degrees);
 * Converts Degrees to Radians. More accurate than the old std_functions DegtoRad.
 * Because radians are mostly decimal and zscript can only have 4 decimals, there is very minor inaccuracies
 * with this conversion that are not feasibly fixable; however, it is still more accurate than the old std.zh conversion function,
 * where the old conversion could potentially be 2 entire degrees off at certain angles, while this version only loses about 0.0004 degrees of accuracy.
 * In addition, casting between DegtoRad and RadtoDeg repeatedly will *not* lose additional precision with each call; only the first call will lose precision.
 
constexpr float RadtoDeg(float radians);
constexpr float RadToDeg(float radians);
 * Converts Radians to Degrees. More accurate than the old std_functions RadtoDeg.
 * See above (DegtoRad) for more details on how this is more accurate.

constexpr float WrapDegrees(float degrees);
constexpr float WrapDeg(float degrees);
 * Wraps a degree value between [-180,180)

constexpr float WrapRadians(float radians);
constexpr float WrapRad(float radians);
constexpr float WrapAngle(float radians);
 * Wraps a radian value between [-PI,PI)

void ArrayCopy(T[] dest, T[] src);
 * Copies the data from array src to array dest. 
 * If the arrays are the same size, then the data of 'dest' will be
 * identical to the data of 'src'.
 * If 'dest' is larger, than any data already in indices above
 * the max index of 'src' is unaffected.
 * If 'dest' is smaller than 'src', then data is copied until
 * 'dest' is full, and verflow is ignored (harmless), but there is 
 * no error or warning on any overflow. 
 * This is an exceptionally fast command, when compared to for loop copying. 

constexpr int Floor(float n);
 * Truncates n to the nearest integer, rounding downwards.

constexpr int Ceiling(float n);
 * Truncates n to the nearest integer, rounding upwards.

constexpr int Truncate(float n);
 * Truncates n to the nearest integer, rounding towards 0.

constexpr int RoundAway(float n);
 * Truncates n to the nearest integer, rounding away from 0.

constexpr int Round(float n);
 * Truncates n to the nearest integer.

int Integer(float n);
 * Truncates n to an integer.

untyped Byte(untyped n);
untyped Int8(untyped n);
 * Clamps and returns 'n' sized to an unsigned byte, with appropriate overflow.
 
untyped Word(untyped n);
untyped Int16(untyped n);
 * Clamps and returns 'n' sized to an unsigned 16-bit integer, with appropriate overflow.

untyped Short(untyped n);
 * Clamps and returns 'n' sized to a signed 16-bit integer, with appropriate overflow.

untyped SignedByte(untyped n);
 * Clamps and returns 'n' sized to a signed byte, with appropriate overflow.

void SaveSRAM(char32[] filename, int flags);
void LoadSRAM(char32[] filename, int flags);
 * Saves or loads the internal datatype dats to a .zcsram file.
 * As of SRAM_VERSION 1, the datatypes (below) are saved.
 * The user can specify which types to save by passing a flagset, 
 * where each type is OR'd together. Pasasing '0' uses all of them:
 * 	TYPE		FLAG
 *	npcdata		0x01
 *	itemdata	0x02
 *	spritedata	0x04
 *	combodata	0x08
 *	dmapdata	0x10
 *	mapdata 	0x20

void SRand(long seed);
 * Sets the current random seed to a given value, input from script. (DOES NOT /10000)

long SRand(); 
 * Generates a random seed, sets it, and returns it.
	
int utol(char32[] str);
 * Converts all uppercase characters in a string to lowercase characters.
 * Returns the pointer to the string.
 * String MUST not be a literal.
 
int ltou(char32[] str);
 * Converts all lowercase characters in a string to uppercase characters.
 * Returns the pointer to the string.
 * String MUST not be a literal.
 
int convcase(char32[] str);
 * Converts all lowercase characters in a string to uppercase characters, and
 * all uppercase characters in a string to lowercase characters.
 * Returns the pointer to the string.
 * String MUST not be a literal.

int ilen(char32[] str);
 * Returns the number of characters used by a number in the string.
 * Includes the sign, if negative. 

int itoa(char32[] dest_str, int value);
 * Places value into a string as char. 
 * Returns the number of characters used in the conversion. 
 * This will be renamed to itoa() in the near future and <string> will be
 * updated to reflect the change. The old <string> function will remain
 * available as std::string::itoa.
 
int xtoa(char32[] dest_str, int value);
 * Places a hexidecimal value into a string as char. 
 * Returns the number of characters used in the conversion. 
 * This will be renamed to xtoa() in the near future and <string> will be
 * updated to reflect the change. The old <string> function will remain
 * available as std::string::xtoa.

int itoacat(char32[] dest_str, int value);
 * Appends value into a string as char, combining itoa() with strcat().
 * Returns the number of characters used in the conversion. 

int strcmp(char32[] string_a, char32[] string_b);
 * Iterates through char32[] string_and string_b until a character is found which is not the same in
 * both strings, and then returns > 0 if the character is larger in str1, and < 0 if it is
 * larger in str2. Returns 0 if the strings are equal.
 * The old string.zh version of this function is still available as:
 * std::string::strcmp(*a, *b).
 
int strncmp(char32[] string_a, char32[] string_b, int num_chars);
 * As strcmp(*a, *b), but compares only the first nth characters, specified as num_chars.
 * The old string.zh version of this function is still available as:
 * std::string::strncmp(*a, *b, int).

int stricmp(char32[] string_a, char32[] string_b);
 * As strcmp(*a, *b), but case-insensitive.

int strnicmp(char32[] string_a, char32[] string_b, int num_chars);
 * As strncmp(*a, *b, num_chars), but case-insensitive.

int strlen(char32[] str);
 * Returns the length of a string in characters.
 * The old string.zh version of this function is still available as:
 * std::string::strlen(*a).

void strcpy(char32[] string_dest, char32[] string_src);
 * Copies string string_src into string_dest.
 * The old string.zh version of this function is still available as:
 * std::string::strcpy(*a,*b).
 
int atoi(char32[] str);
 * Returns the decimal value of a string consisting of a number.
 * e.g. ("26" would return 26).
 
int xtoi(char32[] str);
 * Converts a hexidecimal value presented as a string into an integer. 
 * e.g. ("0x100" would return 256, which is 0x100).
 * This will be renamed to xtoi() in the near future and <string> will be
 * updated to reflect the change. The old <string> function will remain
 * available as std::string::xtoi.
 
int strcat(char32[] string_a, char32[] string_b);
 * Append the contents of string_b onto string_a.
 * Returns the pointer to string_a.
 
int strchr(char32[] str, int chr);
 * Returns the first index in string that matches 'chr'.

int strrchr(char32[] str, int chr);
 * Reverse of strchr, finding the last instance of a character in a string.
 
int strspn(char32[] str, char32[] string_keys);
 * Returns the number of characters in a string before a character not contained in
 * 'string_keys' is found
 
int strcspn(char32[] str, char32[] string_keys);
 * Returns the length of characters in a string before a character contained in
 * 'string_keys' is found

void sprintf(char32[] buf, char32[] format, ...untyped...);
 * Takes a buffer, a format string, and 0+ untyped arguments.
 * The untyped arguments will be inserted to the string at points in the format string.
 * Points are specified using '%'. The letter after is used to determine the type of the arg.
 *     "%i" - Integer. Inserts the number as a string, without decimal places.
 *     "%f" - Float. Inserts the number as a string, with decimal places.
 *     "%l" - Long. Inserts the number as a string, in 'long' integer format.
 *            If the number does not contain decimal places, ".0" will still appear.
 *     "%d" - Number value. Automatically chooses between "%i" and "%f".
 *     "%s" - String value. Parameter must be a valid ZScript string.
 *     "%p" - Pointer value. Identical to "%i".
 *     "%c" - Character value. Inserts a single character.
 *     "%x" - Hexadecimal, lowercase. Inserts the number, not including decimals,
 *            in hexidecimal. Uses lowercase for letters.
 *     "%X" - Hexadecimal, uppercase. Same as above, but uses uppercase for letters.
 *     "%b" - Binary (integer). Inserts the number, not including decimals, in binary.
 *     "%B" - Binary (long). Inserts the number in long binary.
 *     "%a?" - Array (integer). Prints out a full array. Must be followed
 *             by another letter. Each array element will be formatted based on that letter.
 *             Ex: '%al' prints an array of longs, '%08b' prints an array of Binary(integer)
 *                 with a min digits of 8.
 *     "%%" - Inserts a single '%' character, without trying to read it as an argument.
 *     "%" followed by anything other than the above is considered an error. This should never be done.
 * Flags can be used between the '%' and the letter.
 *     "%0#L", where '#' is a number, and 'L' is any letter from 'ifdpxXbB' (numeric points)
 *           - Requires that the integer portion of the number be at least '#' digits long.
 *             This will fill up to the specified length with '0' characters.
 *             The max number allowed is 10 (ex. "%010d").
 *             For 'b' and 'B', the max is 32 (ex. "%032B").
 *           Ex. "%02d" given the argument '1' will print '01'.
 *               "%02d" given the argument '11' will print '11'.
 * The resulting string will be placed in the buffer, which will be resized if it is
 *     too small to hold the output.

void printf(char32 format[], ...untyped...);
 * Takes a format string, and 0+ untyped arguments.
 * Same as 'sprintf', but instead of placing the result in a buffer, will instead
 *     trace the result, as with "TraceS()".

void printfa(char32 format[], untyped[] args);
 * Same as 'printf', but takes an array of args instead of multiple args.
void sprintfa(char32[] buf, char32 format[], untyped[] args);
 * Same as 'sprintf', but takes an array of args instead of multiple args.


constexpr T Min(T val1, T val2, ...T);
 * Takes 2 or more arguments, and returns the lowest value between them.
constexpr T Max(T val1, T val2, ...T);
 * Takes 2 or more arguments, and returns the highest value between them.
T Choose(T first, ...T);
 * Takes 1 or more arguments, and returns a random argument.

int GetSystemTime(int index);
 * Returns the time (Real Time Clock) data from the system on which ZC is running.
 * You may read the following indices: Year, month, day of the month (n/month), day of the week (n/7), 
 * 	hour, minute, second, and day of the year (n/365). 
 * Use the RTC_* constants in std_constants.zh for the index type that you wish to read.

void OverlayTile(int firsttile, int secondtile);		
* Overlay one tile onto another.

int SizeOfArray(T[] arr);
 * Returns the size of an array (any type)

void ResizeArray(T[] arr, int size);
 * Resizes the array 'arr' to size 'size'.
 * If size is <0, the array will be resized to size '0'.

void OwnArray(T[] arr);
 * Grants ownership of the array to the calling script.
 * If the array is a local array, it now will not be deallocated until the current script quits.
 * If the array is a global array, does nothing.

void DestroyArray(T[] arr);
 * Immediately deallocates the specified array, if it is a local array.
 * If the array is a global array, does nothing.

bool ArrayPushBack(T[] arr, T val);
bool ArrayPushFront(T[] arr, T val);
bool ArrayPushAt(T[] arr, T val, int indx);
 * Increases the size of the array by 1, inserting a new value.
 * The new value can either be inserted at the end, start, or an arbitrary index.
 * An invalid index pushes to the end.
 * Returns false if it fails for any reason (ex: array is at max size already)

T ArrayPopBack(T[] arr);
T ArrayPopFront(T[] arr);
T ArrayPopAt(T[] arr, int indx);
 * Decreases the size of the array by 1, removing and returning a value.
 * The new value can either be pulled from the end, start, or an arbitrary index.
 * An invalid index pops from the end.
 * Errors if array size is 0, and returns `-1`.

void OwnObject([Object] obj);
 * Takes an object (see 'Classes and Objects' above)
 * Transfers ownership of the object to the current script.

void GlobalObject([Object] obj);
 * Takes an object (see 'Classes and Objects' above)
 * Transfers ownership of the object to the global scope.
 * Objects owned by the global scope are saved to the save file.

void Trace(untyped value)
 * The Trace() instruction now supports all datatypes.

void ClearTrace();
 * Clears the log file output, and the debug console screen.

untyped Untype(untyped value)
 * Converts the value of any datatype to another, similar to typecasting.
 * Example:
 * ```
 *  int x; 
 *  npc n = Screen->LoadNPC(10);
 *  x = Untype(n);
 * ```
  
bool IsValidArray(untyped[] arr);
 * Returns true if the passed array pointer is valid (usable), false if it is invalid (should not be used).

constexpr int Pow(int a, int b);
 * Returns 'a^^^b' (a raised to the power of b)
 * Ex: Pow(2,2) == 4

constexpr long LPow(long a, long b);
 * Returns 'a^^^b', using 'long', where 0.0001 is 1L.
 * Ex: LPow(2L,2L) == 4L

constexpr int InvPow(int a, int b);
 * Returns 'a^^^(1/b)' (a raised to the inverse power of b)

constexpr int Factorial(int val);
 * Returns the factorial of 'val'
 * If val < 0, this is 0. If val < 2, this is 1.
 * Otherwise, this is the product of every number between 'val' and '1'.

constexpr float Abs(float val);
 * Returns the absolute value of 'val'

constexpr float Sqrt(float val);
 * Returns the square root of 'val'
 * Errors if 'val' is negative

/************************************************************************************************************/


__________      .__        __                    _____                ___.                        
\______   \____ |__| _____/  |_  ___________    /     \   ____   _____\_ |__   ___________  ______
 |     ___/  _ \|  |/    \   __\/ __ \_  __ \  /  \ /  \_/ __ \ /     \| __ \_/ __ \_  __ \/  ___/
 |    |  (  <_> )  |   |  \  | \  ___/|  | \/ /    Y    \  ___/|  Y Y  \ \_\ \  ___/|  | \/\___ \ 
 |____|   \____/|__|___|  /__|  \___  >__|    \____|__  /\___  >__|_|  /___  /\___  >__|  /____  >
                        \/          \/                \/     \/      \/    \/     \/           \/ 

////////////
//  Game  //
//////////// Game

int GetCurScreen();
int CurScreen; //Read-only
 * The current screen, relative to the top-left corner of the map

int CurDMapScreen;
int CurDMScreen; //Read-only
 * The current screen, relative to the top-left corner of the DMap
 * (Accounts for the DMap offset)

int GetCurMap();
int CurMap; //Read-only
 * The current map

int CurDMap;
int CurDMap; //Read-only
 * The current dmap

int GetCurLevel();
int CurLevel; //Read-only
 * The current dmap level

int CurrentItemID(int itemtype, int flags = CIID_FLAG_CHECKCOST);
 * Returns the 'current' item of the selected itemtype. This generally returns the
 *     highest owned of an itemclass, with some exceptions.
 * If 'Game->OverrideItems[itemtype]' is set to an override value, that value will be returned.
 * Use the IC_ constants for itemtype, and the CIID_FLAG_ constants bitwise-or'd for 'flags'.
 * With CIID_FLAG_CHECKCOST, it will ignore items whose usecosts are currently not affordable.
 * With CIID_FLAG_CHECKJINX, it will ignore items which are currently disabled by jinxes.
 * With CIID_FLAG_CHECKBUNNY, it will ignore items which are currently disabled by BunnyClk.
 * Returns '-1' for 'no item'.

int Cheat;
 * The current cheat level activated (0-4)
 * Writing this >0 will enable cheats, even if normally disabled in the quest.
 * Writing this > MaxCheat will automatically raise MaxCheat to match.

int MaxCheat;
 * The current cheat level unlocked in the cheat dialog (0-4)
 * Writing this >0 will enable cheats, even if normally disabled in the quest.
 * Writing this < Cheat will automatically lower Cheat to match.

int MiscSprites[MISCSPR_MAX];
 * The quest's misc sprites. Use the 'MISCSPR_' constants to access this array.

int MiscSFX[MISCSFX_MAX];
 * The quest's misc sfx. Use the 'MISCSFX_' constants to access this array.

int OverrideItems[IC_MAX];
 * The override values for each itemclass.
 * Default value is `-2`. If set to `-2`, no override occurs.
 * If > -2, anything that checks for the "highest level item" of this class,
 *     uses this ID instead.
 * A value of '-1' indicates forcing it to return "no item".
 * If set to an item ID that is of the wrong itemclass, has no effect.

untyped EventData[?];
 * Contains event data for use with 'WaitEvent()' in generic scripts.
 * Use the appropriate set of 'GENEV_' constants based on the event.

int TrigGroups[256];
 * Read-only.
 * The 256 'Trigger Group' values for the current screen.
 * These represent a count of combos that 'Contribute to TrigGroup'
 *     that are present on the screen, layers, and ffcs.

int MouseCursor;
 * Which mouse cursor (ZCM_ constants) should be displayed during gameplay.
 * Default ZCM_BLANK (Resets on visiting title screen)

void SetCustomCursor(bitmap b, int fx, int fy, bool sys_recolor = false, bool user_scale = false);
 * Sets the custom cursor based on the given bitmap. This cursor will be displayed if
 *     `Game->MouseCursor == ZCM_CUSTOM`.
 * fx,fy denotes the "focus point" of the cursor. For a normal cursor, this is usually
 *     the top-left (the engine cursor uses '1,1', which is the transparent pixel directly
 *     pointed to by the arrow). For a crosshair type cursor, this would be the center.
 * If `user_scale` is true, the user's mouse scale config will apply to the custom cursor.
 * If `sys_recolor` is true, some special colors will be replaced based on the current theme.
 * -0xF1 = Cursor Misc
 * -0xF2 = Cursor Outline
 * -0xF3 = Cursor Light
 * -0xF5 = Cursor Dark
 * WARNING: The palette will NOT update on custom cursors automatically. You must call this function again if the cursor should be affected by palette changes.

int SubscreenSpeed;
 * The speed multiplier for the active subscreen falling or raising.
 * The base speed (1) is 3 pixels per frame. The maximum value is 85.

bool Suspend[susptLAST];
 * Each index represents an aspect of the game engine that you 
 * can suspend or resume by writing to this array.
 * See the enum in std.zh containing suspt* constants
 * for a list that you may use. 
 * Reading from this array will return false if the aspect of the
 * game engine is running; or true if it is suspended.
 * Write elements true to suspend them, or false to resume a 
 * suspended element.

int IncrementQuest();
 * Ends the current quest, incrementing the quest ID by +1, and
 * saves. This works as a normal WIN FLAG. except that the normal
 * ending credits do not appear. Instead, there is a fade out, and
 * the player is returned to the file select, but the file in the 
 * current slot is modified to be the next quest in the MODULE.
 *
 * This is exclusively intended to be used for serialised quests
 * in MODULES and requires the use of QUEST NUMBERS to work.

int MaxNPCs();
 * Returns the maximum number of npc sprites that are allowed
 * to be on the screen at one time. 
 
void MaxNPCs(int newmax);
 * Sets the maximum number of npc sprites that are allowed to
 * be on the screen at one time. The current legal range is 
 * 1 to 1024.
 
int MaxLWeapons();
 * Returns the maximum number of lweapon sprites that are allowed
 * to be on the screen at one time. 
 
void MaxLWeapons(int newmax);
 * Sets the maximum number of lweapon sprites that are allowed to
 * be on the screen at one time. The current legal range is 
 * 1 to 1024.
 
int MaxEWeapons();
 * Returns the maximum number of eweapon sprites that are allowed
 * to be on the screen at one time. 
 
void MaxEWeapons(int newmax);
 * Sets the maximum number of eweapon sprites that are allowed to
 * be on the screen at one time. The current legal range is 
 * 1 to 1024.
 
 int MaxItemsprites();
 * Returns the maximum number of itemsprite sprites that are allowed
 * to be on the screen at one time. 
 
void MaxItemsprites(int newmax);
 * Sets the maximum number of itemsprite sprites that are allowed to
 * be on the screen at one time. The current legal range is 
 * 1 to 1024.

float Gravity[3];
 * Read or write to the Game's Gravity values.
 * Use the 'GR_' constants to access this array

int Scrolling[5];
 * Read values related to scrolling. READ-ONLY.
 * Use the 'SCROLL_*' constants to access this array
     * SCROLL_DIR: The direction the screen is scrolling. Returns -1 while not scrolling.
     * SCROLL_NX: The x-offset for the new screen. Returns 0 while not scrolling.
     * SCROLL_NY: The y-offset for the new screen. Returns 0 while not scrolling.
     * SCROLL_OX: The x-offset for the old screen. Returns 0 while not scrolling.
     * SCROLL_OY: The y-offset for the old screen. Returns 0 while not scrolling.

int Game->GetNPCScript(char32[] name);
 * Returns the slot ID of the npc script 'name'.
 * Returns -1 if there is no match.
 
int Game->GetComboScript(char32[] name);
 * Returns the slot ID of the combodata script 'name'.
 * Returns -1 if there is no match.
 
int Game->GetLWeaponScript(char32[] name);
 * Returns the slot ID of the lweapon script 'name'.
 * Returns -1 if there is no match.
 
int Game->GetEWeaponScript(char32[] name);
 * Returns the slot ID of the eweapon script 'name'.
 * Returns -1 if there is no match.
 
int Game->GetHeroScript(char32[] name);
int Game->GetLinkScript(char32[] name);
int Game->GetPlayerScript(char32[] name);
 * Returns the slot ID of the hero script 'name'.
 * Returns -1 if there is no match.

int Game->GetDMapScript(char32[] name);
 * Returns the slot ID of the dmapdata script 'name'.
 * Returns -1 if there is no match.
 
int Game->GetScreenScript(char32[] name);
 * Returns the slot ID of the screendata script 'name'.
 * Returns -1 if there is no match.
 
int Game->GetSubscreenScript(char32[] name);
 * Returns the slot ID of the subscreen script 'name'.
 * Returns -1 if there is no match.
 * Thos script type is not implemented at this time.
 
int Game->GetUntypedScript(char32[] name);
 * Returns 0; not implemented as this script type has no slot assignment at this time.
 
int Game->GetItemSpriteScript(char32[] name);
 * Returns the slot ID of the itemsprite script 'name'.
 * Returns -1 if there is no match.

int Game->GetGenericScript(char32[] name);
 * Returns the slot ID of the generic script 'name'.
 * Returns -1 if there is no match.
 
int Game->GetNPC(char32[] name);
 * Returns the ID of the npc 'name'.
 * Returns -1 if there is no match.
 
int Game->GetItem(char32[] name);
 * Returns the ID of the item 'name'.
 * Returns -1 if there is no match.
 
int Game->GetDMap(char32[] name);
 * Returns the ID of the DMap 'name'.
 * Returns -1 if there is no match.
 
int Game->GetCombo(char32[] name);
 * Returns the ID of the first combo with label 'name'.
 * Returns -1 if there is no match.
 
bool FFRules[800];
 * An array consisting of all quest rules. 

void Continue();
 * As Game->End(), but this continues the game as if the user had selected the
 * CONTINUE option on the game over screen.

void SaveAndContinue();
 * As Game->Continue(), but also saves the game (after onExit has been executed)

void SaveAndQuit();
 * As Game->End(), but also saves the game (after onExit has been executed)

void ShowContinueScreen();
 * As void ShowSaveScreen(), but it shows the base Save/Retry/Continue screen.

void Reload();
 * Similar to 'Game->End()', but, instead of going back to the title screen,
 *     the same save file will be automatically reloaded; allowing a script to quickly
 *     revert to the prior save, without needing the user to re-select the save file.

bool SkipF6;
 * Disables showing the Continue/Retry/Save menu if the player presses F6.
 * The prompt to exit the game is still shown.

bool SkipCredits;
 * If set true, the credits sequence shown at the end of the game is skipped.

bitmap CreateBitmap(int width = 256, int height = 256);
 * Creates a bitmap with a size of height, width, and returns its pointer.

bitmap LoadBitmapID(int id);
 * Loads one of the six internal bitmaps as a ref to a 'bitmap' typed pointer.

bitmap AllocateBitmap();
 * Initialises a bitmap pointer from the pool of unused bitmap IDs in the system.
 * The current maximum number of user bitmaps is 256.
 * Returns 0 to the pointer on failure. 

int LItems[512];
 * The size of this array has been corrected to 512, from the prior size of 256.

int LKeys[512];
 * The size of this array has been corrected to 512, from the prior size of 256.

long LSwitches[512];
 * The crystal switch state for each of the 256 levels
 * All 32 bits are used, wherein '1Lb<<n' represents the 'nth' switch state, for n = 0-31

int GSwitch[256];
 * The 256 global crystal switch TIMERS.
 * If the timer is '< 0', it is active without a timer (same as a normal switch toggle)
 * If the timer is '0', it is inactive
 * If the timer is '> 0', it is active for that many more frames before reverting.

int BottleState[256];
 * The contents of empty bottles, up to 256 slots

combodata LoadComboData(int id);
 * Loads a Combo Editor table data ref for combo 'id', to a 'combodata' typed pointer.

npcdata LoadNPCData(int id);
 * Loads an Enemy Editor table data ref for NPC 'id', to a 'npcdata' typed pointer.

mapdata LoadMapData(int map, int screen);
 * Loads a screen data ref for screen ID 'screen', of Map ID 'map', to a 'mapdata' typed pointer.
 * Valid screens: 0x00 - 0x81

mapdata LoadTempScreen(int layer);
 * Loads a screen data ref for the TEMPORARY data of the layer 'layer'.
 * This can be used to make temporary changes to layers of the current screen, which will not
 *     persist upon leaving the screen.
 * NOTE: All changes to this pointer are lost upon changing screens.

mapdata LoadScrollingScreen(int layer);
 * Loads a screen data ref for the TEMPORARY data of the layer 'layer' used for scrolling.
 * During scrolling, this can be used to change things on the screen you are presently scrolling away from.
 * Not during scrolling, this will point to the last screen you scrolled away from.
 * This pointer will include any temporary changes made while you were on the screen.
 * NOTE: All changes to this pointer are lost upon changing screens.

dmapdata LoadDMapData(int dmap);
 * Loads a dmapdata ref for dmap ID 'dmap' to a 'dmapdata' typed pointer.

dropsetdata LoadDropset(int ID);
 * Loads a dropsetdata ref for dropset number 'ID' to a 'dropset' typed pointer.

bottledata LoadBottleData(int ID);
 * Loads a bottledata ref for bottledata number 'ID' to a 'bottledata' typed pointer.
 * Range 1-64

bottleshopdata LoadBottleShopData(int ID);
 * Loads a bottleshopdata ref for bottleshopdata number 'ID' to a 'bottleshopdata' typed pointer.
 * Range 0-255

spritedata LoadSpriteData(int id);
 * Loads an Weapon Sprite Editor table data ref for sprite 'id', to a 'spritedata' typed pointer.

messagedata LoadMessageData(int id);
 * Loads an String Table Editor table data ref for ZQ Message String 'id', to a 'messagedata' typed pointer.

shopdata LoadShopData(int shop);
 * Loads a Shop Editor table ref for an item shop with an ID of 'id' to a 'shopdata' typed pointer.
	
shopdata LoadInfoShopData(int shop);
 * Loads a Shop Editor table ref for an info shop with an ID of 'id' to a 'shopdata' typed pointer.
 * !! I may make 'infoshopdata' its own type, to prevent conflicts and reduce future shops expansion overhead. -Z

randgen LoadRNG();
 * Opens a free random number generator and returns it.

websocket LoadWebsocket(char32[] url);
 * Opens a websocket to the target URL.
 * URL should begin with 'ws://' or 'wss://' (unsecure, or secure)

stack LoadStack();
 * Opens a free stack object and returns it.

genericdata LoadGenericData(int scriptslot);
 * Loads the 'genericdata' pointer referencing the specified generic script slot.
 * Note that '0' is invalid.

subscreendata LoadASubData(int id);
subscreendata LoadPSubData(int id);
subscreendata LoadOSubData(int id);
 * Loads the 'subscreendata' pointer for the specified active/passive/overlay subscreen.
 * Use id '-1' to load the current subscreen of the type.

int NumActiveSubscreens;
int NumPassiveSubscreens;
int NumOverlaySubscreens;
 * Returns the total number of active/passive/overlay subscreens

bool ActiveSubscreenOpen;
 * Read-only. True if the active subscreen is currently open.
int ActiveSubscreenY;
 * Read-only. The Y offset of the active subscreen, used while it is opening/closing.
 * Value is '-224' if subscreen is closed, '-56' if it is open, or the current draw offset otherwise.

bool TypingMode;
 * If set true, all keyboard presses that would ordinarily perform an in-engine action are suppressed.
 * 	Example: The 'z' key is bound to the 'A Button'; the user presses the 'z' key.
 *	if TypingMode == true, then that keystroke will not cause the engine to register a Button A Press.
 *
 *	Enable this if you wish to create a text prompt using Input->Key[] or Input->ReadKey[].

int HighestStringID;
 * Returns the highest valid ID of the strings in the ZQuest String Editor.

int NumMessages;
 * Returns the number of valid strings in the ZQuest String Editor.

int GameOverScreen[12];
 * INCOMPLETE
 * An array of 12 values that affect the visual, and auditory components of the internal
 *	'Game Over' screen, including fonts, colours, sound effects, and cursor tiles.

int GameOverStrings[3]; //
 * INCOMPLETE
 * An array of 3 values that contain the IDs of custom strings for the 'Game Over' screen.
	
int MapCount()				
 * Returns the number of maps used by a quest. 

void PauseSound(int soundid)	
 * Pauses one of the quest's playing sound effects. Use the SFX_ constants in

void ResumeSound(int soundid)
 * Resumes one of the quest's paused sound effects. Use the SFX_ constants in

void EndSound(int soundid)
 * Kills one of the quest's playing sound effects. Use the SFX_ constants in

void GreyscaleOn()
 * Renders the entire display in greyscale.

int DMapPalette[512]
 * Set or get the Level Palette for each DMap

void SetMessage(int message, int str[])
 * Places string 'str[]' into ZQ Message 'message'.

void SetMapName(int dmap, int str[])
 * Places string 'str[]' into DMap Name for DMap with ID 'dmap'

void SetMapTitle(int dmap, int str[])
 * Places string 'str[]' into DMap Title for DMap with ID 'dmap'

void SetMapIntro(int dmap, int str[])
 * Places string 'str[]' into DMap Intro for DMap with ID 'dmap'

//bool CappedFPS		
//* Check if the game is uncapped. 

int Version;				
 * Returns the version of ZC being used.  

int Build;			
 * Returns the Build ID of the version of ZC being used.  
			
int Beta;				
 * Returns the Beta ID of the version of ZC being used. If the build is not a beta, this returns 0. 

int ZScriptVersion;
 * ZASM command ZSCRIPTVERSION
 * Reads or sets the operating 'last compiled in ZScript Version' value.
 * Writing to this should be limited to editing ASM scripts where it is needed
 * to read and store the correct/current version, and temporarily 
 * modify it during the execution of --that script--, restoring it thereafter.

long Time;
 * Represents the current game time as a 'long', wherein '1L == 1 frame' of the game clock.
 * Only change from 2.50.2 is that the type is now 'long'

bool DisableActiveSubscreen;		
 * If set true, the active subscreen will not fall into view when the player presses Start.

int GetPointer(bool *ptr[]);
 * Returns the pointer of a bool array as a float. 

/* The following have been deprecated by other pointer types.

	int GetScreenEnemy(int map, int screen, int enemy_index)			
	* Reads values from enemy lists anywhere in the game. 

	int SetScreenEnemy(int map, int screen, int enemy_index, int enemy_id)			
	* Sets values to enemy lists anywhere in the game.

	int GetScreenDoor(int map, int screen, int index)			
	* Reads value of a door on any screen in the game environment.

	int SetScreenDoor(int map, int screen, int index, int type)			
	* Sets the value of a door on any screen in the game environment.

	void ContinueSound(int sfx); 					

	void PauseMusic()	
	* Pauses the present, playing MIDI or Enhanced Music file. 

	void ResumeMusic()
	* Resumes the present, playing MIDI or Enhanced Music file. 

*/

/************************************************************************************************************/

/////////////////
///  Input->  ///
/////////////////								// Input

int ModifierKeys;
 * Returns the Allegro Keyboard Modifier Flags:
 *	KB_SHIFT_FLAG = 0x0001;
 *	KB_CTRL_FLAG = 0x0002;
 *	KB_ALT_FLAG = 0x0004;
 *	KB_LWIN_FLAG = 0x0008;
 *	KB_RWIN_FLAG = 0x0010;
 *	KB_MENU_FLAG  = 0x0020;
 *	KB_COMMAND_FLAG  = 0x0040;
 *	KB_SCROLOCK_FLAG  = 0x0100;
 *	KB_NUMLOCK_FLAG = 0x0200;
 *	KB_CAPSLOCK_FLAG = 0x0400;
 *	KB_INALTSEQ_FLAG = 0x0800;
 *	KB_ACCENT1_FLAG = 0x1000; 
 *	KB_ACCENT2_FLAG = 0x2000; 
 *	KB_ACCENT3_FLAG = 0x4000; 
 *	KB_ACCENT4_FLAG = 0x8000; 
 * I am unsure what 0x80 is, if anything. It is not listed in Allegro keyboard.h. -Z
 * Might have been reserved for the Apple Right Command key, but never used. 
 
int KeyBindings[14];
 * Returns the key bound to the 14 possible system keys.
 * Use the CB_* constants to access the array, and the KEY_*
 * constants for values. 
 
bool SimulateKeypress[127];
 * Simulates pressing a key on the keyboard, where the key_id
 * is the index of the array. 
 * Input->SimulateKeypress[KEY_A] = true; will attempt to simulate 
 * the user pressing the A key on their keyboard.
 * Writing this false has no effect. 

bool Button[18];
 * An array of boolean values that correspond to whether a control button is currently held down.
 * Any modifications to this array will be reset to the baseline hardware state on the next frame.
 * Use the CB_* constants to access this array. 
 * Button[] gets set by the engine every frame based on:
 *  1) the current hardware button state (always ignoring what a script did via Button)
 * Note, this value can be temporarily "eaten" (set to false when it is true) for the remainder of the frame,
 * but will be reset to the true hardware value for the next frame.
 *	Replaces Link->Input*.

bool Press[18];
 * An array of boolean values that correspond to whether a control button was pressed this frame.
 * Will be true exactly once for every physical button press, on the first frame.
 * Press[] gets set by the engine every frame based on:
 *   1) current value of Hold (whatever value it is, naturally set or by script)
 *   2) the current hardware button state (always ignoring what a script did via Button)
 * Nothing in-engine accesses these values.
 * Use the CB_* constants to access this array. 
 *	Replaces Link->Press*.
 
bool DisableButton[18];
 * Setting an index of this to 'true' will prevent the ENGINE from reading that button as pressed/held
 * Scripts will still read the button normally, ignoring this
 * This allows disabling the engine's button, while not disabling the button for scripts.
 * Use the CB_* constants to access this array.
 
bool Key[127];
 * Returns true if a key was down this frame.
 * Functions similarly to 'Input->Button[]', but for keys.
 * Read/Write; this will affect most engine functions as well, though
 *     system keys such as 'Esc', 'F3', 'F4', 'F6', 'F7', 'F8', 'F9'
 *     bypass this.
 
bool KeyPress[127];
 * Returns true if a key was pressed this frame.
 * Functions similarly to 'Input->Press[]', but for keys.
 * Read/Write; this will affect most engine functions as well, though
 *     system keys such as 'Esc', 'F3', 'F4', 'F6', 'F7', 'F8', 'F9'
 *     bypass this.
 *     Writing this true for 'F3', 'F4', or 'F6' will trigger the button
 
bool DisableKey[127];
 * Setting an index of this array to 'true' will disable that key for engine input
 * Ex. 'Input->DisableKey[KEY_F6] = true;' will disable the F6 menu from being activated
 * Script key reading, such as 'Input->Key[]', are unaffected.
 * Currently, KEY_F7, KEY_F8, and KEY_F9 cannot be disabled.
 * Use the KEY_* constants to access this array. 
 
bool Joypad[18];
 * Similar to Press, except that it only returns presses from a joystick device, not a keyboard.
 * Use the CB_* constants to access this array. 
 
float Mouse[6];
 * An array of boolean values that correspond to whether a mouse button, was clicked this frame,
 * plus the x/y components of the mouse.
 *	Replaces mouse variables under Link->.
 * indices: 
 * 	float Mouse[0] Mouse X Position
 * 	float Mouse[1] Mouse Y Position
 * 	float Mouse[2] Mouse Z Position
 * 	bool Mouse[3] Left Button
 * 	bool Mouse[4] Right Button
 * 	bool Mouse[5] Middle Button


//int Type //this is a dummy function in the table.

/************************************************************************************************************/

///////////////											// ZInfo
//   ZInfo   //
///////////////

void GetItemClass(char32 buffer[256], int itemclass_id);
 * Copies the name of the specified itemclass to the buffer.
 * Example:
 * 	char32 buf[256];
 * 	ZInfo->GetItemClass(buf, IC_SWORD);
 
 /************************************************************************************************************/

//////////////////
//  FileSystem  //
//////////////////

bool DirExists(char32[] filepath);
 * Returns true if the string passed to 'filepath' is a valid directory path,
 *     relative to the current ZC path.
 * If the quest rule "All bitmap-> and FileSystem-> paths relative to quest 'Files' folder" is on,
 *     then this is relative to "[zc root]/Files/[quest name]/"

bool FileExists(char32[] filepath);
 * Returns true if the string passed to 'filepath' is a valid file path,
 *     relative to the current ZC path.
 * If the quest rule "All bitmap-> and FileSystem-> paths relative to quest 'Files' folder" is on,
 *     then this is relative to "[zc root]/Files/[quest name]/"

bool Remove(char32[] filepath);
 * Deletes the file pointed to by 'filepath'.
 * Regardless of the quest rule "All bitmap-> and FileSystem-> paths relative to quest 'Files' folder",
 *     this will ALWAYS be relative to "[zc root]/Files/[quest name]/"
 
directory LoadDirectory(char32[] path);
 * Opens the directory named by 'path'

/************************************************************************************************************/

////////////////
///   File   ///
////////////////

/*
 * General info:
 * Files opened with 'Open()' or 'Create()', as well as some modes passed to
 *     'OpenMode()', can be Read/Write. In a Read/Write mode, you must call
 *     one of a few certain functions between a read call and a write call.
 *     These functions will list this effect in their description.
 *
 * Writing to files does not write directly to disk, but to a buffer.
 *     It is guaranteed that the contents of this buffer will be written to disk
 *     upon a successful call to 'Flush()', or upon the closing of the file.
 *     Upon exiting the quest, all open files are closed.
 *
 * There is a limit of 256 file pointers. A pointer does not need to have a file
 *     open to count against this limit. Any pointer that returns true from
 *     'isAllocated()' counts against this limit. As long as you don't hold references
 *     to files you no longer need, you won't hit this limit.
 *
 * Remember: POSIX filesystems are Case-SenSitive. 
 */

bool Open(char32[] filepath);
 * If the file pointer has not been allocated, this function will allocate it.
 * Closes any open file connected to the file pointer.
 * Attempts to open the file at "[zc root]/Files/[questname]/[filepath]"
 * Returns true if successful, false if not.
 * File is opened with mode "rb+" (a read/write binary mode)
 *     If the file does not exist, it will fail.
 * For an equivalent text file mode, use 'OpenMode(filepath, "r+")'

bool Create(char32[] filepath);
 * If the file pointer has not been allocated, this function will allocate it.
 * Closes any open file connected to the file pointer.
 * Same as 'Open()', but the file is opened with mode "wb+".
 *     If the file does not exist, it will be created.
 *     If the file DOES exist, all data in the file will be deleted.
 * For an equivalent text file mode, use 'OpenMode(filepath, "w+")'

bool Remove();
 * Deletes the file. This will close it, as with '->Close()', and then delete it from the filesystem.
 * Returns true if successful. The file will be closed even on a failure.

bool OpenMode(char32[] filepath, char32[] mode);
 * If the file pointer has not been allocated, this function will allocate it.
 * Closes any open file connected to the file pointer.
 * Same as 'Open()', but the file is opened with the specified mode.
 * Valid modes (details taken from http://www.cplusplus.com/reference/cstdio/fopen/):
 *     "r"  | read: Open file for input operations. The file must exist.
 *     "w"  | write: Create an empty file for output operations. If a file
 *            with the same name already exists, its contents are discarded
 *            and the file is treated as a new empty file.
 *     "a"  | append: Open file for output at the end of a file. Output operations
 *            always write data at the end of the file, expanding it. Repositioning
 *            operations ('Seek()', 'Rewind()') are ignored. The file is created if
 *            it does not exist.
 *     "r+" | read/update: Open a file for update (both for input and output). The
 *            file must exist.
 *     "w+" | write/update: Create an empty file and open it for update (both for
 *            input and output). If a file with the same name already exists its
 *            contents are discarded and the file is treated as a new empty file.
 *     "a+" | append/update: Open a file for update (both for input and output)
 *            with all output operations writing data at the end of the file.
 *            Repositioning operations (fseek, fsetpos, rewind) affects the next
 *            input operations, but output operations move the position back to the
 *            end of file. The file is created if it does not exist.
 *
 * The letter "b" can be added to the end of any of these (or before the "+", for update modes)
 *     to specify a binary file mode. Not doing this will specify a text file mode.
 * Text files are files containing sequences of lines of text. Depending on the environment
 *     where the application runs, some special character conversion may occur in input/output
 *     operations in text mode to adapt them to a system-specific text file format. Although
 *     on some environments no conversions occur and both text files and binary files are
 *     treated the same way, using the appropriate mode improves portability.

void Close();
 * Closes any open file connected to the file pointer.
 * This does NOT deallocate the pointer; it is still free to open new files on.

void Free();
 * DEPRECATED: This no longer does anything - objects are freed automatically now.
 *             See "Object Memory Management" section
 * Closes any open file connected to the file pointer.
 * This will deallocate the file pointer, so that the pointer ID may be re-used.
 * There is a limit to how many file pointers may be allocated at once.
 * See the 'General Information' at the top of this section for more details.

void Own();
 * Grants 'Ownership' of the pointer to the currently running script.
 * [pre-3.0] When the script terminates (at the same time any Local Arrays in the script
 *     are cleared), the pointer will be automatically freed.
 * See "Object Memory Management" section

bool isAllocated();
 * Returns true if this file pointer is allocated.
 * This does NOT mean it has a file open; the pointer simply has an ID.

bool isValid();
 * Returns true if this file pointer has a file open.

bool Allocate();
 * Attempts to allocate the file pointer. If it was already allocated, this will re-allocate it;
 *     without deallocating the old pointer! This should not be called on already allocated pointers.
 * Returns true if it can allocate; false otherwise. A false return indicates that the maximum
 *     number of allocated files has been reached.

bool Flush();
 * Flushes the buffer of the file being written to.
 * Writes to a file do not actually write to the file immediately; they instead go to a buffer.
 *     Calling this function will force the buffer to be written to disk.

int ReadString(char32[] buf);
 * Reads a section of characters from the file.
 * Will read either until 'buf' is full, an error occurs, End of File is reached, or a newline
 *     character is reached.
 * If it ends due to reaching a newline character, the newline character will be included at the
 *     end of the string.
 * Returns the length of the string read into 'buf'.

int ReadChars(char32[] buf, int count = -1, int pos = 0);
 * Reads a section of characters from the file.
 * Starts placing characters at 'buf[pos]'.
 *     If 'pos' is negative, starts at 'buf[0]'.
 * If 'count' is 0, does nothing and returns 0.
 * If 'count' is negative, reads until it fills 'buf', an error occurs, or End of File is reached.
 * If 'count' is positive, reads 'count' characters into 'buf'.
 * Will always add a null character at the end of the read characters.
 * Returns the number of characters read, excluding the added null character.
 
int ReadBytes(untyped[] buf, int count = -1, int pos = 0);
 * Reads a section of binary data from the file.
 * Starts placing data at 'buf[pos]'.
 *     If 'pos' is negative, starts at 'buf[0]'.
 * If 'count' is 0, does nothing and returns 0.
 * If 'count' is negative, reads until it fills 'buf', an error occurs, or End of File is reached.
 * If 'count' is positive, reads 'count' characters into 'buf'.
 * The binary data read will be 8b; such that reading '1' will place '1' into buf.
 *     This means that the binary data cannot contain decimal places.
 * Returns the number of bytes read.

int ReadInts(untyped[] buf, int count = -1, int pos = 0);
 * Reads a section of binary data from the file.
 * Starts placing data at 'buf[pos]'.
 *     If 'pos' is negative, starts at 'buf[0]'.
 * If 'count' is 0, does nothing and returns 0.
 * If 'count' is negative, reads until it fills 'buf', an error occurs, or End of File is reached.
 * If 'count' is positive, reads 'count' characters into 'buf'.
 * The binary data read will be 32b; such that reading '1' will place '0.0001' into buf.
 *     This means that the binary data can contain decimal places.
 * Returns the number of ints read.

int WriteString(char32[] str);
 * Writes the string stored in 'str' to the file.
 * Returns the number of characters successfully written.

int WriteChars(char32[] buf, int count = -1, int pos = 0);
 * Writes characters from 'buf' to file.
 * Starts at 'buf[pos]'.
 *     If 'pos' is negative, starts at 'buf[0]'.
 * If 'count' is 0, does nothing and returns 0.
 * If 'count' is negative, writes from 'buf' until it finds a null character, or reaches the end of 'buf'.
 * If 'count' is positive, writes 'count' characters from buf.
 * Returns the number of characters successfully written.
 
int WriteBytes(untyped[] arr, int count = -1, int pos = 0);
 * Writes 8b binary data from 'arr' to file.
 * The binary data written will be 8b; such that writing '1' will write '1' to file.
 *     This means that the binary data cannot contain decimal places.
 * Starts at 'arr[pos]'.
 *     If 'pos' is negative, starts at 'arr[0]'.
 * If 'count' is 0, does nothing and returns 0.
 * If 'count' is negative, writes from 'arr' until it reaches the end of 'arr'.
 * If 'count' is positive, writes 'count' ints from arr.
 * Returns the number of bytes successfully written.

int WriteInts(untyped[] arr, int count = -1, int pos = 0);
 * Writes 32b binary data from 'arr' to file.
 * The binary data written will be 32b; such that writing '1' will write '10000' to file.
 *     This means that the binary data can contain decimal places; writing '0.0001' will write '1' to file.
 * Starts at 'arr[pos]'.
 *     If 'pos' is negative, starts at 'arr[0]'.
 * If 'count' is 0, does nothing and returns 0.
 * If 'count' is negative, writes from 'arr' until it reaches the end of 'arr'.
 * If 'count' is positive, writes 'count' ints from arr.
 * Returns the number of 32b integers successfully written.

char32 GetChar();
 * Reads and returns the next character in the file.
 * Returns -1 if it fails; check 'EOF' and 'Error' to see why.

char32 PutChar(char32 c);
 * Writes 'c' to file.
 * Returns -1 if it fails; otherwise returns 'c'.

char32 UngetChar(char32 c);
 * Un-reads 'c' to the input stream.
 * Returns -1 if it fails; otherwise returns 'c'.
 * This is a READ operation, not a WRITE operation. The file will not actually be modified;
 *     but further read operations will find this as the next character to be read.
 * Useful if you read a character, then realize you don't want it.

long Pos;
 * Read-only.
 * This represents the current position in the file.
 * In binary modes ('Open()', 'Create()', or 'OpenMode()' including "b"), this is the number
 *     of bytes into the file, as a long; i.e. '10L' == 10 bytes.
 * In text modes ('OpenMode()' not including "b"),
 *     the numerical value may not be meaningful but can still be used to restore the position
 *     to the same position later using 'Seek()' (if there are characters put back using
 *     'UngetChar()' still pending of being read, the behavior is undefined).

bool Seek(long pos, bool from_current = false);
 * Moves the current position of the file.
 * 'pos' is a 32b value, where '1L' represents 1 byte; similar to 'Pos'.
 * If 'from_current' is true, it moves forward from the current position.
 * Otherwise, it moves so that 'Pos' is equal to 'pos'.
 * Using 'from_current'==true in a file open in text mode ('OpenMode()' not
 *     including "b") is undefined.
 * Returns true if successful, false otherwise.
 * If successful, this function has the following side-effects:
 *     All previous calls to 'UngetChar()' are dropped.
 *     The 'EOF' indicator is set to false.
 *     Allows switching between reading and writing on a read/write file.

void Rewind();
 * Rewinds to the beginning of the file.
 * This function has the following side-effects:
 *     All previous calls to 'UngetChar()' are dropped.
 *     The 'EOF' indicator is set to false.
 *     The 'Error' indicator is set to 0.
 *     Allows switching between reading and writing on a read/write file.

bool EOF;
 * Read-Only. Returns true if a read call attempted to read past the end of the file.
 * If true, no further read calls will succeed until the position has been changed;
 *     i.e. 'Seek()' or 'Rewind()'.

int Error;
 * Read-Only. Returns 0 if the file has not enountered an error.
 * If an error was encountered, returns an error code number.

void ClearError();
 * Clears the active EOF and Error indicators.
 * i.e. this writes 'EOF = false;' and 'Error = 0;'.

void GetError(char32[] buf);
 * Stores a string describing the current error into the buffer provided.
 * Stores an empty string if 'Error == 0'.


/************************************************************************************************************/

/////////////////////
///   Directory   ///
/////////////////////

int Size;
 * The number of files/folders contained in the directory
 
bool GetFilename(int index, char32 buf);
 * Loads the name of the 'index' file (0 <= index < Size)
 * The name will be placed in the buffer
 * Returns true if successful, false if it fails.

void Reload();
 * Refreshes the directory, so that it can 'see' changes to files.

void Free();
 * DEPRECATED: This no longer does anything - objects are freed automatically now.
 *             See "Object Memory Management" section
 * This will deallocate the directory pointer, so that the pointer ID may be re-used.
 * There is a limit to how many directory pointers may be allocated at once,
 *     so be sure to free them when you are no longer using them.

void Own();
 * Grants 'Ownership' of the pointer to the currently running script.
 * [pre-3.0] When the script terminates (at the same time any Local Arrays in the script
 *     are cleared), the pointer will be automatically freed.
 * See "Object Memory Management" section


/************************************************************************************************************/

/////////////////
///   Stack   ///
///////////////// stack

long Size;
 * Read-only. The size of the stack, given as a LONG.
 * This means that a stack with 5 items will have a size of '5L'.

bool Full;
 * Read-only. Returns true if the stack cannot hold any more elements.

void Clear();
 * Clears the stack of all elements.

void PushBack(untyped val);
void PushFront(untyped val);
 * Pushes the given value to the back or front of the stack.
 * If the stack is at max capacity, does nothing.

untyped PopBack();
untyped PopFront();
 * Removes the back or front element of the stack, and returns it.
 * If the stack is empty, '0' is returned.

untyped PeekBack();
untyped PeekFront();
 * Returns the back or front element of the stack, without removing it.
 * If the stack is empty, '0' is returned.

untyped Get(long ind);
 * Returns the element at the index 'ind', which is a LONG value.
 * This means that '0L' is the first element, '1L' is the second, etc.
 * If an invalid index is given, '0' is returned.

void Set(long ind, untyped val);
 * Overwrites the element at the index 'ind', which is a LONG value, with the value 'val'.
 * This means that '0L' is the first element, '1L' is the second, etc.
 * If an invalid index is given, nothing happens.

void Free();
 * DEPRECATED: This no longer does anything - objects are freed automatically now.
 *             See "Object Memory Management" section
 * This will deallocate the stack pointer, so that the pointer ID may be re-used.
 * There is a limit to how many stack pointers may be allocated at once,
 *     so be sure to free them when you are no longer using them.

void Own();
 * Grants 'Ownership' of the pointer to the currently running script.
 * [pre-3.0] When the script terminates (at the same time any Local Arrays in the script
 *     are cleared), the pointer will be automatically freed.
 * See "Object Memory Management" section

/************************************************************************************************************/

/////////////////////
///    randgen    ///
/////////////////////
 * Using a 'NULL' randgen pointer will reference the engine randgen,
 * rather than a script-specific one.
 * The global pointer 'RandGen->' can be used as a null randgen pointer.

int Rand();
 * Returns a random value from -214748 to 214748

int Rand(int bound)
 * Returns a random integer value between '0' and 'bound'.

int Rand(int bound1, int bound2)
 * Returns a random integer value between the two bounds

long LRand();
 * Returns a random long value from -2147483648L to 2147483647L

long LRand(long bound)
 * Returns a random long value between '0' and 'bound'.

long LRand(long bound1, long bound2)
 * Returns a random long value between the two bounds

void SRand(long seed)
 * Seeds this randgen with the provided seed

long SRand()
 * Seeds this randgen with an effectively randomized seed, and returns the chosen seed.

void Free();
 * DEPRECATED: This no longer does anything - objects are freed automatically now.
 *             See "Object Memory Management" section
 * This will deallocate the randgen pointer, so that the pointer ID may be re-used.
 * There is a limit to how many randgen pointers may be allocated at once,
 *     so be sure to free them when you are no longer using them.

void Own();
 * Grants 'Ownership' of the pointer to the currently running script.
 * [pre-3.0] When the script terminates (at the same time any Local Arrays in the script
 *     are cleared), the pointer will be automatically freed.
 * See "Object Memory Management" section

/////////////////////
///   websocket   ///
/////////////////////

int State;
 * Read-Only. Returns the current state of the socket.
 * Compare with the `WEBSOCKET_STATE_` constants.

bool HasMessage;
 * Read-Only. True if the socket has a message waiting to be received.

void GetError(char32[] buf);
 * Gets the current socket error message (if any)

void Send(untyped[] buf, long type = WEBSOCKET_MESSAGE_TYPE_TEXT);
 * Sends a message over the socket.
 * 'type' is a `WEBSOCKET_MESSAGE_TYPE_` constant.
 * - WEBSOCKET_MESSAGE_TYPE_TEXT: send a string
 * - WEBSOCKET_MESSAGE_TYPE_BINARY: send an array

untyped[] Receive();
 * If there's a message waiting to be received (see HasMessage),
 *     returns a pointer to the websocket's internal data array.
 * If no message is waiting, returns NULL.
 * Calling 'Receive()' again will overwrite the contents of this array.
 * The array will be destroyed automatically when the websocket is freed.

void Free();
 * DEPRECATED: This no longer does anything - objects are freed automatically now.
 *             See "Object Memory Management" section
 * This will deallocate the websocket pointer, so that the pointer ID may be re-used.
 * There is a limit to how many websocket pointers may be allocated at once,
 *     so be sure to free them when you are no longer using them.

void Own();
 * Grants 'Ownership' of the pointer to the currently running script.
 * [pre-3.0] When the script terminates (at the same time any Local Arrays in the script
 *     are cleared), the pointer will be automatically freed.
 * See "Object Memory Management" section

/************************************************************************************************************/

////////////////////
///  bottledata  ///
////////////////////

void GetName(char32 str);
 * Loads the name of the bottletype into the provided string
void SetName(char32 str);
 * Sets the name of the bottletype to the provided string (max 31 chars)

int Counter[3];
 * The refill counters of this bottle type
 * Use the 'CR_' constants from std_constants.zh to access this.

int Amount[3];
 * The amount to refill of each counter (0-65535)

bool IsPercent[3];
 * Whether the given counter's refill is a percentage or not

bool Flags[4];
 * A set of flags. Use the 'BTF_' constants from std_constants.zh to access this.

int NextType;
 * What bottle type will be left in the bottle after drinking the current type

/************************************************************************************************************/

////////////////////////
///  bottleshopdata  ///
////////////////////////

void GetName(char32 str);
 * Loads the name of the bottletype into the provided string
void SetName(char32 str);
 * Sets the name of the bottletype to the provided string (max 31 chars)

int Fill[3];
 * Which bottle type the given index fills a bottle with

int Combo[3];
 * Which combo is displayed as the visual for the fill

int CSet[3];
 * Which CSet the combo displays in

int Price[3];
 * The price of the bottle fill (0-65535)

int InfoString[3];
 * The message string to display upon purchasing the given fill.

/************************************************************************************************************/

////////////////
///  Screen  ///
////////////////								// Screen

void Message(int message_id);
 * Triggers the message number 'message_id' from the Strings table to be displayed
 * on the screen.
 * If 'message_id' is 0, any message being displayed will be removed.

int ShowingMessage;
 * READ-ONLY:
 * The message ID of the currently active message. 0 if no message is displayed.

bool SpawnScreenEnemies();
 * Immediately spawns the 10 screen enemies with the screen pattern.
 * Returns true if successful.
 * Fails if enemies are still entering from the sides,
 *     or if the pattern is 'PATTERN_NO_SPAWNING'.

bool TriggerCombo(int layer, int pos);
 * Attempts to trigger the combo at 'layer,pos'.
 * Returns true on success, false on failure.
 * Fails in special cases depending on the combo, as well as if either
 *     layer or pos is invalid.
 * If no 'Triggers' tab behaviors are set, won't do anything.

int Script;
 * The screendata script used for the current screen.

untyped InitD[8];
 * The eight D args used by the screendata script for the current screen.

bool SecretsTriggered();
 * Returns true if the secrets for this screen have been triggered (temp or perm)

int ComboE[176];
 * The effect area bits of each of the 176 combos used on the screen.

bool State[32];
 * The 32 screen states used by this screen. Use the 'ST_' constants to access.
bool ExState[32];
 * The 'Extra States' used by this screen.

bool GetExDoor(int dir, int index);
 * Returns a door state for the screen.
 * Each direction (DIR_UP,DIR_DOWN,DIR_LEFT,DIR_RIGHT) has 8 indexes (0-7)
void SetExDoor(int dir, int index, bool state);
 * Sets a door state for the screen.
 * Each direction (DIR_UP,DIR_DOWN,DIR_LEFT,DIR_RIGHT) has 8 indexes (0-7)

int MovingBlockLayer;
 * The layer of a currently moving pushblock
 * Returns -1 and ignores writes if there is no pushblock currently moving
 * Allows values 0-6 to be written; the block will "settle into place" on this layer.

int GetRenderTarget();
 * Returns the present drawing render target ID.
 * Use in conjunction with SetRenderTarget(int) to cache the present RT, 
 * set a new one, draw, then reset it to its prior value.

bool LayerInvisible[7]; 
 * If true, the current layer is invisible.
 * Writing this true for layers 1 through 6 will make those layers invisible.
 
bool ScriptDraws[8];
 * If true, the ZC engine will perform script draws on the given queue layer. 
 * Each queue layer returns true by default. 
 * Writing this false disables script draws targetted to a specific layer queue. 

int Script; 
 * Returns the ID of the script set to the screen, or sets the script that this screen runs.
 
untyped InitD[8];
 * The eight script args for the script that runs on this screen.

bool isSolidLayer(int x, int y, int layer);
 * As 'Screen->isSolid()', but instead of returning true if there is solidity on layers 0, 1, or 2,
 * returns the solidity only for the specified layer.

lweapon CreateLWeaponDx(int type, int baseitem)
 * Create an lweapon with sprites, sounds, and other values set as if it was generated by a specific item.
 
void WavyIn();
 * Replicates the warping screen wave effect (inbound) from a tile warp. 

void WavyOut();		
 * Replicates the warping screen wave effect (outbound) from a tile warp. 

void ZapIn();			
 * Replicates the warping screen zap effect (inbound) from a tile warp. 

void ZapOut();		
 * Replicates the warping screen zap effect (outbound) from a tile warp. 

void OpeningWipe();
 * Replicates the opening wipe screen effect (using the quest rule for its type) from a tile warp.

void ClosingWipe();
 * Replicates the closing wipe screen effect (using the quest rule for its type) from a tile warp.

void OpeningWipe(int shape);
 * Replicates the opening wipe screen effect from a tile warp, in any given shape
 * Use the 'WIPE_' constants in 'std_constants.zh' for 'shape'

void ClosingWipe(int shape);
 * Replicates the closing wipe screen effect from a tile warp, in any given shape
 * Use the 'WIPE_' constants in 'std_constants.zh' for 'shape'


void DrawBitmapEx	( int layer, 
			int bitmap_id, 
			int source_x, int source_y, int source_w, int source_h, 
			int dest_x, int dest_y, int dest_w, int dest_h, 
			float rotation = 0, int cx = 0, int cy = 0,
			int mode = 0, int lit = 0,  bool mask = true);

 * As DrawBitmap(), except that it can do more things. 
 * Now supports multiple MODES, OR'd together as a bitmask:
 * const int BITDX_NORMAL = 0;
 * const int BITDX_TRANS = 0x01; //Translucent
 * const int BITDX_PIVOT = 0x02; //THe sprite will rotate at a specific point, instead of its centre.
 * const int BITDX_HFLIP = 0x04; //Horizontal Flip
 * const int BITDX_VFLIP = 0x08; //Vertical Flip.
 * You can also set a pivot point for the rotation, using 'int cx' and 'int cy'
 * If these are non-zero, the rotation anchor point will centre on these coordinates.
 * You may specify a colour to 'int lit' to use a lit mode. This tints the entire bitmap using that
 * colour index of the main palette. 


void FastCombo()
void DrawScreen()
void DrawLayer()
 * These now support Combo CSet values.

void DrawTileCloaked(int layer, int x, int y,
		int tile, int blockw, int blockh,
		int flip);
 * As DrawTile(), but draws with a cloaked effect.

void DrawComboCloaked(int layer, int x, int y,
		int combo, int tilewidth, int tileheight,
		int flip);
 * As DrawCombo(), but draws with a cloaked effect.
 
void DrawString(int layer, 
			int x, int y, 
			int font, int color, int background_color, int format, 
			char32[] str, 
			int opacity,
			int shadow_type, int shadow_color);
 * As DrawString(), but includes a shadow on the text.
 * Use the 'SHD_' constants for 'shadow_type'.

void PutPixels(int layer, int ptr[], int rx, int ry, int rangle)
 * Puts multiple pixels to the screen in one function call.
 * PutPixels() expects an array as its arg, with the array in the format of
 * repeating blocks of { x, y, colour, trans }
 *	Example: PutPixels(1, { 25, 10, 5, OP_OPAQUE, 26, 10, 6, OP_OPAQUE }, 0, 0, 0 );
 *	This draws two pixels to the screen.
 *	The first is at coordinates x==25, y == 10, colour == 5, and it is opaque.
 *	The second is at coordinates x==25, y==10, colour == 6, and opaque.
	
void DrawTiles(int layer, int ptr[])
 * Similar to FastTile(), but it draws multiple tiles in one call.
 * The arg *ptr[] should be an array with repeating sets of:
 *	{x,y,tile,colour,opacity} 
 *	...per tile that you want to draw.

void DrawCombos(int layer, int ptr[]);
 * Similar to FastCombo, but draws multiple combos in one call.
 * The arg *ptr[] should be an array with repeating sets of: 
 *	{x,y,combo,cset,opacity} 
 *	...per combo that you want to draw.

void Lines(int layer, int ptr[]);
 * Similar to Line(0, but draws multiple lines in one call.
 * The arg *ptr[] should be an array with repeating sets of: 
 *	{ x, y, x2, y2, colour, scale, rx, ry, angle, opacity }
 *	...per line that you want to draw.
	
void Polygon(int layer, int num_points, int vertices[], int colour, int opacity = OP_OPAQUE);
	ZASM: POLYGON
 * Draws a polygon to the screen, with a number of points specified as int points,
 * with vertices supplied as an array. 
 
void DrawFrame(int layer,
			int x, int y, int tile, int cset,
			int width, int height, bool overlay = true,
			int opacity = OP_OPAQUE);
 * Draws a frame using a 2x2 block of tiles, where the upper-left corner of which is the 'tile' value
 * This works based on how the engine subscreen frame object works, stretching the frame from those tiles
 *     to whatever size you specify.
 * Width/height are in 8-pixel increments; ex. 4,4 would give a 2x2 tile block; 8,8 would give a 4x4.

int Valid;
 * ?

int Guy;
 * The screen guy.

int String;
 * The screen string.

int RoomType;
 * The screen room type.

int Item;
 * The screen item.
 * Note: The NULL value is '0', which is a valid item.
 * 	To determine if there is an item on the screen, if you ever assigned
 * 	item 0 as a valid screen item in your quest, you will also want to read
 * 	HasItem for that screen.

int HasItem; 
 * If not zero, then the item for this screen will be shown.
 * When Link takes the item on a screen, this is set to 0.

int TileWarpType[4];
 * The Tile Warp type for Tile Warps A, B, C, and D; [0], [1], [2], and [3] respectively.
 * See std_constants.zh TWTYPE_* constants for valid types.
	
bool SideWarpOverlay[4];
bool TileWarpOverlay[4];
 * Set or get the overlay state for the warp ID corresponding to the index of this array.

int DoorComboSet;
 * The doorset used by the screen, for NES dungeon doors.
	
int SideWarpReturnSquare[4];
 * The return square (A->D) used by Side Warp[A->D].

int TileWarpReturnSquare[4];	
 * The return square (A->D) used by Tile Warp[A->D].
	
int WarpReturnX[4];
 * The X-component for each of the four 2.50+ (blue) warp return squares.
	
int WarpReturnY[4];
 * The Y-component for each of the four 2.50+ (blue) warp return squares.
	
int WarpReturnC;
 * Stores the information on warp returns, butwise.
 * Deprecated by SideWarpReturnSquare[4] and TileWarpReturnSquare[4].
 * The bits are DDCCBBAADDCCBBAA, where the left section is sidewarp returns, and the right is tilewarp returns.

int StairsX;
 * The X component for where a Stairs secret appears on the screen.
	
int StairsY;
 * The Y component for where a Stairs secret appears on the screen.
	
int ItemX;
 * The X component for the item location on the screen.
	
int ItemY;
 * The Y component for the item location on the screen.

int Palette;
int CSet;
 * The palette for the screen set via 'F4' or 'Screen>>Palette' in ZQuest

int TileWarpDMap[4];
 * The destination DMap for each of the four warp types.
	
int TileWarpScreen[4];
 * The destination screen for each of the four warp types.

int Enemy[10];
 * The IDs of the enemies that spawn on the screen.

int EnemyFlags;
 * A flagset for enemies on the screen (E.Flags).
 * Valid values (ORd) together, are:
 *
 *

int Pattern;
 * The enemy 'Spawn Pattern'.
 * Use the PATTERN_* constants in std.zh for the valid values
 
int SideWarpID[4];
 * Returns the sidewarp ID for a given screen edge, as SideWarpID[dir];
 * Returns -1 if there is no sidewarp in that direction.
 * Use the SIDEWARP_* constants in std.zh for the value of this (read return value, or write value).
 * Use the DIR_* constants in std.zh for the index values.

int SideWarpType[4];
 * The Sidewarp type for Sidewarps A, B, C, and D; [0], [1], [2], and [3] respectively.
 * See std_constants.zh SWTYPE_* constants for valid types.

int SideWarpScreen[4];
 * The destination screen for each of the four sidewarps.
	
int SideWarpDMap[4];
 * The destination DMap for each of the four sidewarps.
	
int SideWarpIndex;
 * The warp return IDs. Deprecated by SideWarpID[].

int WarpArrivalX;
 * The X-component for the pre-2.50 (green) arrival square.
	
int WarpArrivalY;
 * The X-component for the pre-2.50 (green) arrival square.
	
int MazePath[4];
 * The four Maze Path directions.

int ExitDir;
 * The Maze Path 'Exit Direction'.

int UnderCombo;
 * The undercombo ID used by the screen.

int UnderCSet;
 * The CSet of the undercombo used by the screen.

int Catchall;
 * The screen 'Catchall' value. 

int CSensitive;
 * The value of Damage Combo Sensitivity for the screen.
	
int NoReset;
 * The No Reset Flagset. Values are ORd together s follows:
 * Secrets		0x
 * Items		0x
 * Special Item		0x
 * Lock Block		0x
 * Boss Lock Block	0x
 * Chest		0x
 * Secrets		0x
 * Locked Chest		0x
 * Boss Locked Chest	0x
 * Door Up [0]		0x
 * Door Down[1]		0x
 * Door Left [2]	0x
 * Door Right [3]	0x

int NoCarry;
 * The No Carry Over Flagset. Values are ORd together s follows:
 * Secrets		0x
 * Items		0x
 * Special Item		0x
 * Lock Block		0x
 * Boss Lock Block	0x
 * Chest		0x
 * Secrets		0x
 * Locked Chest		0x
 * Boss Locked Chest	0x

int LayerMap[7];
 * The Map IDs used by screen layers 1 through 6, represented as [1] through [6].
 * Index [0] does nothing, and trying to access it will report an error to the log.

int LayerScreen[7];
 * The Screen IDs used by screen layers 1 through 6, represented as [1] through [6].
 * Index [0] does nothing, and trying to access it will report an error to the log.

int LayerOpacity[7];
 * The opacity value for each layer used by this screen.
 * Valid layers are 1 through 6, represented as [1] through [6].
 * Index [0] does nothing, and trying to access it will report an error to the log.

int TimedWarpTimer;
 * The timer used by 'Time Warp Tics' in Screen Data->T.Warp

int CarroverMap;
int NextMap;
 * The map to where secrets on the current mapscreen carry over.
 * Corresponds to the Screen Data>>>Screen State Carryover 'Next Map' 
 * selection in the ZQ Editor.
 
int CarryoverSrceen;
int NextScreen;
 * The screen to where secrets on the current mapscreen carry over.
 * Corresponds to the Screen Data>>>Screen State Carryover 'Next Screen' 
 * selection in the ZQ Editor.

int SecretCombo[128];
 * The Combo IDs used by 'Secret Combos' on this screen.
 * See SECCMB_* in std_constants.zh for more information.
	
int SecretCSet[128];
 * The CSets used by 'Secret Combos' on this screen.
 * See SECCMB_* in std_constants.zh for more information.
	
int SecretFlags[128];
 * The Combo Flags used by 'Secret Combos' on this screen.
 * See SECCMB_* in std_constants.zh for more information.

int AmbientSFX;
 * The 'Ambient Sound' under S.Data2. 

int BossSFX;
 * The Boss Roar sound for this screen.
	
int SecretSFX;
 * The sound that will play on this screen, when secrets are triggered.

int ItemSFX;
 * The sound that will play if Link holds an item over his head on this screen.
	
int MIDI;
 * The MIDI that plays on this screen.

bool LensShows[7];
bool LensHides[7];
 * Arrays of the layers which the lens shows, and hides, respectively.

int GuyCount;
 * Number of enemies remaining alive on this screen.

int DataSize;
 * Read-write, the size of the `Data[]` array.
 * Changes save to the save file.
untyped Data[];
 * Resizable array of data for scripts to use.
 * Changes save to the save file.

/************************************************************************************************************/

/////////////
///  FFC  ///
/////////////									// FFC // ffc

int ID;	
 * The screen ref of the ffc. Used primarily for this->ID.

//bool Running; //need to add this to match mapdata. int val

bool Flags[14];
 * Corrected and expanded the array size from [2] to [14].

void Own(bitmap b);
void Own(paldata pd);
void Own(stack st);
void Own(file f);
void Own(directory dir);
void Own(randgen rnd);
void OwnArray(untyped[] array);
void OwnObject([Object] object);
 * Grants 'Ownership' of the parameter object to the ffc.

/************************************************************************************************************/


  _________            .__  __           ________ ___.        __               __          
 /   _____/____________|__|/  |_  ____   \_____  \\_ |__     |__| ____   _____/  |_  ______
 \_____  \\____ \_  __ \  \   __\/ __ \   /   |   \| __ \    |  |/ __ \_/ ___\   __\/  ___/
 /        \  |_> >  | \/  ||  | \  ___/  /    |    \ \_\ \   |  \  ___/\  \___|  |  \___ \ 
/_______  /   __/|__|  |__||__|  \___  > \_______  /___  /\__|  |\___  >\___  >__| /____  >
        \/|__|                       \/          \/    \/\______|    \/     \/          \/ 
The following are the members for sprite objects (Hero, npc, lweapon, eweapon, and itemsprite).

////////////////////
///  Itemsprite  ///
//////////////////// itemsprite

bool Animation;
 * Normally 'true'. If enabled, the item is animated by the ZC engine.
 * Set this false to disable engine animation.
 
int Max;
 * Returns the maximum number of itemsprite sprites (eweapon and lweapon are
 * separate values, and should be read from the appropriate 
 * pointer type) that are allowed to be on the screen at one time. 

void Max(int newmax);
 * Sets the maximum number of itemsprite sprites (eweapon and lweapon are
 * separate values, and should be read from the appropriate 
 * pointer type) that are allowed to be on the screen at one time. 
 * The current legal range is 
 * 1 to 1024.
 
 
untyped InitD[8];
 * The 8 D args for the itemsprite.
 * Used as this->InitD[] for itemsprite scripts.

bool Gravity;
 * If set true, the itemsprite will fall in sideview gravity.
 * Itemsprites have gravity set true by default.
`
float Scale;
 * The scale factor for this sprited object. 
 * A scale of 0 and a scale of 1 are identical.
 * Scale values are a multiplier: 1.5 == 50% larger (150%).
 * Negative values are undefined.
 * You can only scale sprites if you disable the Compatibility Quest rule 
 *   'Old (Faster) Sprite Drawing'.
 
float Rotation;
 * The rotation factor for this sprited object, in degrees.
 * You can only rotate sprites if you disable the Compatibility Quest rule 
 *  'Old (Faster) Sprite Drawing'.

int Script;
 * The itemsprite script attached to this itemsprite.

int Family;
int Type;
 * The Family (Item Class) of the itemsprite.

untyped Misc[32];
 * The Misc[] array now supports all datatypes, and has been expanded to a size of [32].

int Pickup;
 * The pick-up type for this itemsprite.
	
int PickupString;
 * If this is > 0, then when Link touches the itemsprite, ZC will display a ZQ String Editor message string
 * equal to its value.
 * The precise behaviour of this is affected by PickupFlags.

int PickupStringFlags;
 * A flagset that determines the behaviour of string display.
 * Values are ORd together, as follows:
 *
 *
 *

int SizeFlags;
 * A flagset that determines how internal engine sizing of items is applied.
 * Values are ORd together, as follows:
 *
 *

int AClock 
 * The clock used for the itemsprite's animation cycle. 

int ScriptTile;
 * If set to 0 or higher, then the itemsprite will be drawn with this tile.
 * The default value for this is -1.

int ScriptFlip;
 * If set to 0, or higher, then the engine will use this Flip state to draw the itemsprite.
 * The default value for this is -1. 

int Falling;
 * The timer indicating how long left the itemsprite will be falling
 * If 0, the itemsprite is not falling
 * Max value of 70, which is the value when you begin falling
 * Read-Write

int FallCombo;
 * The pit combo that the itemsprite is falling into
 * Affects the SFX that will occur on the first frame of falling
 * Read-Write

bool MoveFlags[2];
 * Flags relating to movement.
 * See 'ITEMMV_' constants in std_constants.zh for values
 * [0] == Obeys gravity (see ->Gravity)
 * [1] == Can fall in pitfalls
 * Read-Write
 
int LightRadius;
 * The radius of light this object emits in a dark room

int LightShape;
 * The shape of light this object emits in a dark room.

int ShadowSprite;
 * The shadow sprite used by the itemsprite, 0-255

int DroppedBy;
 * The dropset ID that dropped this item.
 * -1 if item was not dropped from a dropset.

void Remove();
 * Instantly DELETES an itemsprite.
 * This will immediately invalidate the itemsprite pointer, as well as update 'Screen->NumItems', and change the indexes for 'Screen->LoadItem()'
 * If called from an itemsprite script on the itemsprite running the script, immediately terminates the script.

bool SwitchHooked;
 * READ-ONLY
 * Returns true if the object is currently grabbed by a switchhook effect
 
bool ForceGrab;
 * If true, the item is being forcibly picked up. This means that it will:
 *  -not draw (invisible)
 *  -immune to falling in pits/water
 *  -immune to being deleted by any means (including scrolling, warps, etc)
 *  -will be picked up by the player as though they stepped on it as soon as possible
 * Some engine effects may set this to true; this value is read/write to scripts.
 
bool NoSound;			
 * If true, picking up the item does not play it's usual pickup sound assigned in the item editor. Does not affect holdup sound.

bool NoHoldSound;			
 * If true, picking up the item does not play the screen's holdup sound. Does not affect the usual pickup sound assigned in the item editor.

bool Switch(int effect);
 * Switch the player with this object
 * Use the 'SW_EFF_' constants from std_constants.zh for 'effect'
 * Returns true if it is successful
 
int FakeZ;
 * Current FakeZ position. This value is treated as a second, separate Z axis;
 * Sprites will be offset upwards by this amount when drawn just like the Z axis and shadows will draw if applicable.
 * However, the sprite's hitbox will not be moved upwards into the Z Axis; instead it will be moved upwards on the Y axis,
 * mimicking how Vires and Pols Voice worked in the original Zelda.
 * This value is affected by FakeJump instead of Jump.
 
int FakeJump;			
 * The current velocity on the FakeZ axis. This value is added to FakeZ every frame; and this value is decreased
 * by the gravity value until it is lower than the terminal velocity value.

void Own(bitmap b);
void Own(paldata pd);
void Own(stack st);
void Own(file f);
void Own(directory dir);
void Own(randgen rnd);
void OwnArray(untyped[] array);
void OwnObject([Object] object);
 * Grants 'Ownership' of the parameter object to the itemsprite.

/************************************************************************************************************/	

/////////////////
///  *weapon  ///
///////////////// weapon

int TotalDrawYOffset;
 * READ-ONLY
 * Calculates the total drawYOffset including special engine effects
 *     (such as switchhook with the 'rise' effect).
 * Does not include Z value in the calculation.

int Power; 
 * The damage/power value of te weapo.
 * Identical to *weapon->Damage, but added for uniformity with itemdata.

bool Animation;
 * Normally 'true'. If enabled, the weapon is animated by the ZC engine.
 * Set this false to disable engine animation.

int Max;
 * Returns the maximum number of weapon sprites (eweapon and lweapon are
 * separate values, and should be read from the appropriate 
 * pointer type) that are allowed to be on the screen at one time. 

void Max(int newmax);
 * Sets the maximum number of weapon sprites (eweapon and lweapon are
 * separate values, and should be read from the appropriate 
 * pointer type) that are allowed to be on the screen at one time. 
 * The current legal range is 
 * 1 to 1024.
 
bool Gravity;
 * If set true, the weapon falls in sideview gravity.
 * Some weapons (e.g. fire, bombs) have this set true by default.

float Scale;
 * The scale factor for this sprited object. 
 * A scale of 0 and a scale of 1 are identical.
 * Scale values are a multiplier: 1.5 == 50% larger (150%).
 * Negative values are undefined.
 * You can only scale sprites if you disable the Compatibility Quest rule 
   'Old (Faster) Sprite Drawing'.
 
float Rotation;
 * The rotation factor for this sprited object, in degrees.
 * You can only rotate sprites if you disable the Compatibility Quest rule 
 *   'Old (Faster) Sprite Drawing'.
   
int Script;
 * The weapon script assigned to this weapon.

untyped InitD[8];
 * The eight InitD values for the weapon script used by this weapon.

int ScriptTile;
 * If set to 0 or higher, then the npc will be drawn with this tile.
 * The default value for this is -1.

int ScriptFlip;
 * If set to 0, or higher, then the engine will use this Flip state to draw the npc.
 * The default value for this is -1. 

int Parent;
npc Parent;
 * The ID of the item, or pointer of the npc (respectively for lweapon, and for eweapon) that created this weapon.
 * Weapons created by script have a default Parent of -1 (lweapon) and <npc>-0.0001 (eweapon). 
 * For lweapons, this value determines what item editor index to read item flags from.
 *     Setting it to an item of a class that does not normally generate the given weapon
 *     type may have unexpected effects.
 
int Level;
 * LWeapons: The Level value associated with the weapon. 
 * EWeapons: The first bit (Level&1) is used to set a 'boss/unblockable'
 * state. If this bit is 1, then the weapon is a boss weapon.
 * Otherwise it is a normal weapon, blocked by standard shield flags.

untyped Misc[32];		
 * Expanded from a size of [16] to [32]. An array of 32 miscellaneous variables for you to use as you please.
 * The Misc[] array now supports all datatypes, and has been expanded to a size of [32].

int Falling;
 * The timer indicating how long left the weapon will be falling
 * If 0, the weapon is not falling
 * Max value of 70, which is the value when you begin falling
 * Read-Write

int FallCombo;
 * The pit combo that the weapon is falling into
 * Affects the SFX that will occur on the first frame of falling
 * Read-Write

bool MoveFlags[2];
 * Flags relating to movement.
 * See 'WPNMV_' constants in std_constants.zh for values
 * [0] == Obeys gravity (see ->Gravity)
 * [1] == Can fall in pitfalls
 * Read-Write
 
int LightRadius;
 * The radius of light this object emits in a dark room

int LightShape;
 * The shape of light this object emits in a dark room.
 
void Remove();
 * Instantly DELETES a weapon.
 * This will immediately invalidate the weapon pointer, as well as update 'Screen->Num*Weapons()', and change the indexes for 'Screen->Load*Weapon()'
 * If called from a weapon script on the weapon running the script, immediately terminates the script.

int Unblockable;
 * A flagset representing the weapon's ability to pierce defenses.
 * Use the 'UNBLOCK_' constants with bitwise operations to get/set this state.

int ShadowSprite;
 * The shadow sprite used by the weapon, 0-255

bool SwitchHooked;
 * READ-ONLY
 * Returns true if the object is currently grabbed by a switchhook effect

int Timeout;
 * If > 0, ticks down each frame. When ticking down to 0, kills the weapon.
 
bool Switch(int effect);
 * Switch the player with this object
 * Use the 'SW_EFF_' constants from std_constants.zh for 'effect'
 * Returns true if it is successful
 
int Vx;
int Vy;
 * Gets the weapons current velocity in that direction in Pixels.
 * Setting either of these will make the weapon angular if it isn't already, and will set it's angle and speed to match it's new Vx and Vy.
 
int DegAngle;
 * Gets the weapon's current angle in degrees. Setting this will convert what you set to radians and set the weapon's angle to that.
 
bool AutoRotate;
 * If true, automatically rotates the weapon's sprite using 360 degree rotation to match either it's angle or direction.
 * Assumes a right-facing sprite is set for the weapon.
 
void MakeAngular();
 * If angular isn't already set, sets angular to true and converts the weapon's direction to an angle.
 * If angular is set, this does nothing.
 
void MakeDirectional();
 * If angular is set, converts the weapon's direction to the closest direction it can find to it's current angle in 8 directions, and unsets angular.
 * If angular isn't set, this does nothing.
 
int FakeZ;
 * Current FakeZ position. This value is treated as a second, separate Z axis;
 * Sprites will be offset upwards by this amount when drawn just like the Z axis and shadows will draw if applicable.
 * However, the sprite's hitbox will not be moved upwards into the Z Axis; instead it will be moved upwards on the Y axis,
 * mimicking how Vires and Pols Voice worked in the original Zelda.
 * This value is affected by FakeJump instead of Jump.
 
int FakeJump;			
 * The current velocity on the FakeZ axis. This value is added to FakeZ every frame; and this value is decreased
 * by the gravity value until it is lower than the terminal velocity value.

bool Flags[WFLAG_MAX];
 * A set of flags for all weapons. See 'WFLAG_' constants in 'std_constants.zh'

int Sprites[WPN_SPRITE_MAX];
 * A set of sprites related to the weapon. See 'WPN_SPRITE_' constants in 'std_constants.zh'

int BurnLightRadius[WPN_SPRITE_MAX];
 * The burning light radii associated with sprites of the weapon. See 'WPN_SPRITE_' constants in 'std_constants.zh'

int DeathItem;
 * If > -1, this item ID will be spawned when the weapon dies.

int DeathDropset;
 * If > -1, this item dropset will be rolled for a drop when the weapon dies.

int DeathItemPFlags;
 * The item '->Pickup' flags for the item dropped by 'DeathItem' or 'DeathDropset'.

int DeathSprite;
 * If this is > -1, that Sprite Data sprite will be displayed when the weapon dies.
 * If this is -2, -3, or -4, Bush, Flower, or Grass clippings respectively will be displayed when the weapon dies.

int DeathSFX;
 * If non-0, this SFX will be played when the weapon dies.

int LiftLevel;
 * If >0, the weapon can be lifted by a lift glove of this level or higher.

int LiftTime;
 * The time it takes to lift this weapon

int LiftHeight;
 * The height this weapon is lifted above the player's head

void Own(bitmap b);
void Own(paldata pd);
void Own(stack st);
void Own(file f);
void Own(directory dir);
void Own(randgen rnd);
void OwnArray(untyped[] array);
void OwnObject([Object] object);
 * Grants 'Ownership' of the parameter object to the weapon.

///////////////////////////
///  EWeapon  Specific  ///
/////////////////////////// eweapon

n/a

///////////////////////////
///  LWeapon  Specific  ///
/////////////////////////// lweapon

int Special;
 * The special info for the lweapon.
 * Used by wind lweapons, instead of Level, to determine their effects. 

int Weapon;
 * The UseWeapon property for this weapon. 
 * If set to a value greater than 0, all collisions with npcs
 * will use this as if it was the weapon's ID for calculating
 * the defence value for it. 
 * e.g., if a LW_MAGIC weapon is set to a Weapon of LW_BRANG, when it
 * collides with an npc, the npc will use Defence[LW_BRANG] to resolve 
 * its effects.
 *
 * Some weapons will also trigger map flags, and screen combos as
 * if the natural weapon was the value set as ->Weapon.,
 * e.g. If you set a LW_BRANG weapon to a ->Weapon of LW_SWORD,
 * it will cut bushes. 

int Defence;
int Defense;
 * The default defence value for this weapon.
 * If set greater than 0, then when this weapon collides with an npc,
 * if that npc has its Defence[n] value set to NONE for this weapon's type,
 * it will resolve using this Defence value (e.g. Stun). 

int Range;
 * NEEDS TO BE REIMPLEMENTED
 * The range of boomerang and hookshot lweapons in pixels; and arrow lweapons in frames.

int AClock 
 * The clock used for the itemsprite's animation cycle. 

/************************************************************************************************************/		

/////////////
///  npc  ///
///////////// npc

bool InvFlicker;			
 * If set false, the npc will neither flash, nor flicker when invincible. 

int Frame;
 * The current frame of the npc's animation.
 
int Fading;
 * The death effect for the npc. Use the enum NPCFadeType in std_constants.
 
int Halt;
 * The clock for how long an npc is halted.
 
int MoveStatus;
 * The movement status of an npc, usually flying. 
 * See enum NPCMoveStatus in <std.zh>.
 
int Dropset;
 * Alias for npc->ItemSet. 
 * Read or write the item dropset used by the npc.

int Random;
 * Corresponds to the Enemy Editor Random Rate value.

bool Animation;
 * Normally 'true'. If enabled, the npc is animated by the ZC engine.
 * Set this false to disable engine animation.

int Max;
 * Returns the maximum number of npc sprites (eweapon and lweapon are
 * separate values, and should be read from the appropriate 
 * pointer type) that are allowed to be on the screen at one time. 

void Max(int newmax);
 * Sets the maximum number of npc sprites (eweapon and lweapon are
 * separate values, and should be read from the appropriate 
 * pointer type) that are allowed to be on the screen at one time. 
 * The current legal range is 
 * 1 to 1024.
 
bool Submerged();
 * Returns if the npc is submerged (in the ground, in the water, or in a wall).
 * Returns true if the npc is FULLY submerged.
 * Returns false as soon as the npc is even partly submerged, and
 * continues to return true until that npc is fully-submerged. 

bool Gravity;
 * If set true, the npc will fall in sideview gravity.
 * Some npcs have this set true by default, others are false by default,
 * based on the npc family.

bool NoSlide;
 * 'false' by default.
 * If this is set to 'true', the npc will ignore engine knockback.

int SlideClock;
 * The timer used for enemy knockback.
 * The first byte is the clock.
 * The second byte is the dir.
 * Enemies that split do not slide. 

bool NoScriptKnockback;
 * 'false' by default.
 * If this is set to 'true', the npc will ignore script knockback via 'npc->Knockback()'

int SlideSpeed;
 * 4 by default
 * The number of pixels per frame this NPC will move during ENGINE knockback
 * Range: 0 to 255

bool Immortal;
 * If true, the enemy will not 'die' even if it has 0hp or is too far off-screen.
 * '->Remove()' will still delete the npc.

float Scale;
 * The scale factor for this sprited object. 
 * A scale of 0 and a scale of 1 are identical.
 * Scale values are a multiplier: 1.5 == 50% larger (150%).
 * Negative values are undefined.
 * You can only scale sprites if you disable the Compatibility Quest rule 
 *  'Old (Faster) Sprite Drawing'.
 
float Rotation;
 * The rotation factor for this sprited object, in degrees.
 * You can only rotate sprites if you disable the Compatibility Quest rule 
 *   'Old (Faster) Sprite Drawing'.

bool isDead();
 * Returns if the NPC is dead, or dying

bool CanSlide();
 * Unimplemented
	
int Slide();
 * Run Engine knockback (Only does anything if a knockback is in-progress)
 * This is automatically called for most engine enemy types
 * Calling this from enemy types such as 'Other' will allow them to recieve knockback
 * This is called as a part of scripted walking functions, such as 'ConstantWalk()', automatically.
 * Return: 0 if no knockback occurred, 1 if scripted knockback ('->Knockback()') occurred, 2 if engine knockback occurred.

bool Knockback(int time, int dir, int speed = 4);
 * Attempt to knock an enemy back.
 * 'time' is the number of frames to knock back.
 * 'speed' is how many pixels per frame the npc will move.
 * Returns true if it was successful, or false if it fails.
 * Will fail if:
 *     The enemy cannot move in that direction
 *     The enemy is already mid-knockback
 *     The enemy is dead
 *     'bool npc->NoScriptKnockback;' was set true for this enemy

int HitDir;
 * Returns a direction constant if the npc is being knocked back.
 * Returns -1 if the npc is not being knockd back.
 * Writing to this has no effect, and is ignored. 
 * This value is set both from engine, and from scripted knockback.

void StopBGSFX();
 * Stops the background sounds that the npc is generating.
	
void Attack();
 * Causes the npc to attack with its weapon.

//Engine enemy movement functions
void NewDir(int arr[]);
 * The npc chooses a new direction.
 * Uses an array literal for its args:
 * 	{ int rate, int homing, int special }

void NewDir8(int arr[]);
 * As NewDir(), but 8-directions.
 * 	{int rate, int homing, int special}
 *	{int rate, int homing, int special, int dx1, int dy1, int dx2, int dy2}

void ConstantWalk(int arr[]);
 * Causes the npc to walk.
 * Uses an array literal for its args.
 * Pass NULL as the pointer to run without args, or use:
 * 	{int rate, int homing, int special}

void ConstantWalk8(int arr[]);
 * As ConstantWalk(), but 8-directions.
 * 	{int rate, int homing, int special}

void VariableWalk(int arr[]);
 * Causes the npc to walk and occasionally change speed.
 * 	{int rate, int homing, int special}

void VariableWalk8(int arr[]);
 * As VariableWalk(), but 8-directions.
 * 	{int rate, int homing, int newclk, int special}
 * 	{int rate, int homing, int newclk, int special, int dx1, int dy1, int dx2, int dy2}

void HaltingWalk(int arr[]);
 * Causes an enemy to walk, and occasionally halt.
 * 	{int rate, int homing, int special, int hrate, int haltcnt}

void HaltingWalk8(int arr[]);
 * As HaltingWalk(), but 8-directions.
 * 	{int newrate, int newhoming, int newclk, int special, int newhrate, int haltcnt}
    
void FloatingWalk(int arr[]);
 * Causes an enemy to move, ignoring solidity on the screen.

bool LinkInRange(int dist_in_pixels);
 * Returns true if Link is within 'range' pixels of the enemy.

bool CanMove(int array[]);
 * Returns true if the npc can move in a given direction.
 * Uses an array literal for varying args.
 * Overloaded for a number of options:
 * 	{int dir}: Dir only, should use the default step distance.
 * 	{int dir, int special} 
 * 	{int ndir, int step, int special} 
 * 	{int ndir,int step,int special,int dx1,int dy1,int dx2,int dy2}
	
int LinedUp(int range, bool dir8 = false);
 * Checks if enemy is lined up with Link.
 * If so, returns direction Link is at as compared to enemy.
 * Returns -1 if not lined up. Range is inclusive.

/* Script-only enemy movement functions (Ghost-based)
 * These functions will simply move the enemy, and check collision; they are not
 *     grid-locked, and have no other side effects.
 */
bool MovePaused();
 * Returns true if the enemy shouldn't be moving
 *   i.e. spawning, dying, stunned, clock active, etc
 * Should be checked before calling movement functions below

bool CanPlace(float nx, float ny, int special = SPW_NONE,
	bool knockback = false, int nw = -1, int nh = -1);
 * Checks if the enemy could be arbitrarily placed (teleported) at 'nx,ny'.
 * If 'nw' or 'nh' are > -1, they will be used as the width/height of the enemy for the check.
 *     Otherwise, the enemy's hitwidth/hitheight are used.
 * Some enemies treat pits/liquid as solid, EXCEPT if they are being knocked back.
 *     'bool knockback' here affects this for the placement checks.
 * Use the 'SPW_' constants to provide a special value;
 *     i.e. 'SPW_FLOATER' for flying enemies.
 * Use 'SPW_NONE' if you don't know what to use.
 * Returns true if the enemy could be placed successfully, false otherwise.
 

bool MoveXY(float dx, float dy, int special = SPW_NONE)
 * Attempts to move the enemy by 'dx, dy'; obeying solidity.
 * Use the 'SPW_' constants to provide a special value;
 *     i.e. 'SPW_FLOATER' for flying enemies.
 * Use 'SPW_NONE' if you don't know what to use.
 * Returns true if the enemy moves the full distance,
 *     false if it is blocked by something.
 
bool CanMoveXY(float dx, float dy, int special = SPW_NONE)
 * Same as above, but doesn't actually move the enemy,
 *     just returns the success state if it were to move.

bool Move(int dir, float pxamnt, int special = SPW_NONE)
 * Attempts to move the enemy by 'pxamnt' pixels in the
 *     'dir' direction; obeying solidity.
 * Use the 'SPW_' constants to provide a special value;
 *     i.e. 'SPW_FLOATER' for flying enemies.
 * Use 'SPW_NONE' if you don't know what to use.
 * Returns true if the enemy moves the full distance,
 *     false if it is blocked by something.
 
bool CanMove(int dir, float pxamnt, int special = SPW_NONE)
 * Same as above, but doesn't actually move the enemy,
 *     just returns the success state if it were to move.

bool MoveAtAngle(float degrees, float pxamnt, int special = SPW_NONE)
 * Attempts to move the enemy by 'pxamnt' pixels in the
 *     'degrees' angle; obeying solidity.
 * Use the 'SPW_' constants to provide a special value;
 *     i.e. 'SPW_FLOATER' for flying enemies.
 * Use 'SPW_NONE' if you don't know what to use.
 * Returns true if the enemy moves the full distance,
 *     false if it is blocked by something.
 
bool CanMoveAtAngle(float degrees, float pxamnt, int special = SPW_NONE)
 * Same as above, but doesn't actually move the enemy,
 *     just returns the success state if it were to move.

//

bool SimulateHit(int array[]); 
 * Simulates hitting the npc with a weapon, another sprite, or an arbitrary set of 
 * values passed as an overloaded array literal.
 * Returns true if that object would hit the npc. 
 * 	{TYPE, pointer} : Specify the type, such as PTR_TYPE_LWEAPON, then pass an object pointer.
 * 	{int tx, int ty, int tz, int txsz, int tysz, int tzsz} : Arbitrary values.
 
npc Create(int array[]); 
 * Similar to Screen->CreateNPC(), except:
 * (1) It uses an arry literal for its args, with varying size.
 * (2) You can either create an npc only by its ID, or you can do
 * 	that and set its spawn coordinates at the same time.
 * (3) It works based on an existing pointer, such as:
 * 	npc n; n->Create{args});
 * 	{ int id } 
 * 	{ int id, int x, int y }
	
void BreathAttack(bool seeklink = false);
 * Fires the breath weapon set to the enemy.

bool Collision(int obj_type, untyped obj_pointer);
 * Returns if either an object is colliding with the npc, or if an arbitrary set of 
 * coordinates would collide.
 * Valid Object Types:
 *obj_type_lweapon, obj_type_eweapon, obj_type_npc, obj_type_link, obj_type_ffc, obj_type_combo_pos, obj_type_item
 *** Not fully implemented!

	
int Family;
int Type;
 * The Family (Enemy Class) of the npc.

int Script; 
 * The npc action script used by this enemy.

untyped InitD[8];
 * The eight InitD args used by the npc action script for this enemy.

int ScriptTile;
 * If set to 0 or higher, then the npc will be drawn with this tile.
 * The default value for this is -1.

int ScriptFlip;
 * If set to 0, or higher, then the engine will use this Flip state to draw the npc.
 * The default value for this is -1. 
                                                        
untyped Attributes[32];
 * Expanded to size [32], and made datatype-insensitive.

int WeaponSprite;
 * The sprite (Quest->Graphics->Sprites->Weapons) used to draw the weapon fired by the npc.

int WeaponSFX;
 * The sfx (Quest->Audio->SFXData) used whenever the npc fires its weapon.

bool Shield[5];
 * The shield status of the enemy.
 * [0] through [3] correspond to DIR* constants (wherein DIR_UP represents FRONT, and DIR_DOWN represents BACK)
 * [4] corresponds to 'Shield can be broken'.

bool Core;
 * This returns true if the NPC is the core segment of a segmented engine enemy.

bool SwitchHooked;
 * READ-ONLY
 * Returns true if the object is currently grabbed by a switchhook effect

**************************************************************

untyped HitBy[10];
 * Stores the ID/UIDs of objects that hurt the npc this frame.
 * Indices:
 *
 * The first four indices are for the *screen index* of objects:
 *
 * Description		Index	Status
 * HIT_BY_NPC 		[0] 	Not used at this time. 
 * HIT_BY_EWEAPON 	[1] 	Not used at this time. 
 * HIT_BY_LWEAPON 	[2]	In use by the engine.
 * HIT_BY_FFC 		[3] 	Not used at this time. 
 *
 * The next four, are for the FFCore 'script' UIDs of objects:
 *
 * Description		Index	Status
 * HIT_BY_NPC_UID 	[4] 	Not used at this time. 
 * HIT_BY_EWEAPON_UID 	[5] 	Not used at this time. 
 * HIT_BY_LWEAPON_UID 	[6]	In use by the engine.
 * HIT_BY_FFC_UID 	[7] 	Not used at this time. 
 *
 * The last two, are reserved for special damage-object types. 
 *
 * Description		Index	Status
 * HIT_BY_COMBO 	[8]	Not used at this time. 
 * HIT_BY_MAPFLAG 	[9] 	Not used at this time. 
 *
 * These indices are uniform across all HitBy[] array members, for any datatype with that member. 
 *
 * Some lweapons, notably some melee weapons such as swords (but not sword beams), and boomerangs
 * are not yet implemented in this mechanic. 

**************************************************************

int Defense[42];
int Defense[MAX_DEFENSE];		
 * Expanded to a size of 42 to cover new defense categories.

untyped Misc[32];		
 * Expanded from a size of [16] to [32]. An array of 32 miscellaneous variables for you to use as you please.
 * The Misc[] array now supports all datatypes, and has been expanded to a size of [32].

int FlashingCSet;
 * This returns the enemy's current displayed cset when taking damage or invincible. If not in one of these states, will return its normal cset.
 * If called before Waitdraw() / enemy update, results may be off by a frame.
 * If the quest rule 'Enemies Flicker When Hit' is checked, this is unused.

bool isFlickerFrame();
 * This returns true if the enemy is currently in a flicker frame (either invisible or color masked).
 * If called before Waitdraw() / enemy update, results may be off by a frame.
 * If the quest rule 'Enemies Flicker When Hit' is unchecked, this is unused.

int FlickerColor;
 * This sets what color the enemy is drawn when flickering.
 * If -1, will use the default from Init Data.
 * If the quest rule 'Enemies Flicker When Hit' is unchecked, this is unused.

int FlickerTransparencyPasses;
 * This sets how many times the transparency effect is applied to the enemy's flicker effect.
 * If -1, will use the default from Init Data. If 0, will use a solid color.
 * If the quest rule 'Enemies Flicker When Hit' is unchecked, this is unused.

int InvFrames;				
 * Returns the number of remaining invincibility frames if the enemy is invincible, otherwise 0. 

int Invincible;			
 * Returns if the enemy is invincible, because of ( superman variable ). 

bool HasItem;				
 * Returns if the enemy is holding the screen item.

bool Ringleader;			
 * Returns if the enemy is a 'ringleader'.

int ItemSet;
int Dropset;
 * The Dropset ID that this enemy will drop from when killed

int Falling;
 * The timer indicating how long left the npc will be falling
 * If 0, the npc is not falling
 * Max value of 70, which is the value when you begin falling
 * Read-Write

int FallCombo;
 * The pit combo that the npc is falling into
 * Affects the SFX that will occur on the first frame of falling
 * Read-Write

bool MoveFlags[3];
 * Flags relating to movement.
 * See 'NPCMV_' constants in std_constants.zh for values
 * [0] == Obeys gravity (see ->Gravity)
 * [1] == Can fall in pitfalls
 * [2] == Can walk over pitfalls

 * Read-Write
 
int LightRadius;
 * The radius of light this object emits in a dark room

int LightShape;
 * The shape of light this object emits in a dark room.

int ShadowSprite;
 * The shadow sprite used by the npc, 0-255
int SpawnSprite;
 * The spawn sprite used by the npc, 0-255
int DeathSprite;
 * The death sprite used by the npc, 0-255
 
void Remove();
 * Instantly DELETES an npc. No items will be dropped, no sound will play; the npc is simply DELETED OUTRIGHT.
 * This will immediately invalidate the npc pointer, as well as update 'Screen->NumNPCs', and change the indexes for 'Screen->LoadNPC()'
 * If called from an NPC script on the NPC running the script, immediately terminates the script.

bool Switch(int effect);
 * Switch the player with this object
 * Use the 'SW_EFF_' constants from std_constants.zh for 'effect'
 * Returns true if it is successful
 
int FakeZ;
 * Current FakeZ position. This value is treated as a second, separate Z axis;
 * Sprites will be offset upwards by this amount when drawn just like the Z axis and shadows will draw if applicable.
 * However, the sprite's hitbox will not be moved upwards into the Z Axis; instead it will be moved upwards on the Y axis,
 * mimicking how Vires and Pols Voice worked in the original Zelda.
 * This value is affected by FakeJump instead of Jump.
 
int FakeJump;			
 * The current velocity on the FakeZ axis. This value is added to FakeZ every frame; and this value is decreased
 * by the gravity value until it is lower than the terminal velocity value.
 
void Own(bitmap b);
void Own(paldata pd);
void Own(stack st);
void Own(file f);
void Own(directory dir);
void Own(randgen rnd);
void OwnArray(untyped[] array);
void OwnObject([Object] object);
 * Grants 'Ownership' of the parameter object to the npc.


/* The following commands are valid, but do not yet have in-engine use, */

// int Frozen;
// * Returns the number of frames for which the npc remains frozen

// int FrozenTile;
// * Unimplemented at this time.
 
// int FrozenCSet;
// * Unimplemented at this time.

// int Movement[32];
// * NPC Movement patterns, and args.

// int WeaponPattern[32];
// * NPC weapon movement patterns and args.

// int FireSound;
// * The sound that plays when the npc fires a weapon.


/************************************************************************************************************/

//////////////
///  Hero  ///
//////////////									// Hero // Player

int CSet;
 * Returns the current CSet used to draw the player sprite.
 * This normally only changes when the player is hurt, and flashing.
 * Writing to this is permitted, but it will be overwritten on the next frame.
 
int ClockTimer;
 * Returns the current ticks of a stopwatch/clock item countdown timer.
 * Writing to this while ClockActive is true sets or changes the duration of
 * the clock effect; if no stopwatch/clock is active, it pre-sets the value
 * so that you may start a timed effect by writing ClockActive = true. 

bool ClockActive;
 * Returns true if a stopwatch/clock is active.
 * Writing to this acts like picking up a stopwatch/clock item, and sets the
 * duration of its effect based on ClockTimer. If ClockTimer is 0, the effect 
 * lasts until the player changes screens.

bool Standing;
 * Returns true if the hero is 'standing', as is used to check if they are capable
 *     of jumping. Automatically accounts for sideview.

int HammerState;
 * Read-only. Returns a value representing the current hammer swing.
 * 0 = not swinging hammer
 * 1 = hammer above head
 * 2 = hammer at angle
 * 3 = hammer hit the ground

int CoyoteTime;
 * The number of frames the hero has been off the ground. Range 0-65535.
 * 0 while standing. When not standing, ticks up by 1 each frame.
 * When jumping, is immediately set to 65535.
 * If this value is < 65535 and < a feather's "Coyote Time" attribute,
 *     the feather will be able to jump despite being in the air.
 * Setting this to 65535 will disable coyote jumps, though this will be set to
 *     0 upon landing on the ground again.

int Steps[8];
 * The number of pixels that the player moves in a frame, based on
 * his present coordinates. The movement is taken from his x and y:
 * as: 
 * x_move_in_pixels = Hero->Step[Hero->X&7]
 * y_move_in_pixels = Hero->Step[Hero->Y&7]
 * The default values are: { 1, 1, 2, 1, 1, 2, 1, 1 };
 * You can double his speed by doubling these values, or adjust it slightly as needed.
 * NOTE: This only affects 4-way movement, and has no effect
 *       if the quest rule 'New Hero Movement' is enabled.

int Step;
 * The steprate that the player moves at. This functions similarly to "npc->Step" and such;
 * a step rate of '100' means that you move '1 pixel per frame'. The default step rate is
 * '150', moving at '1.5 pixels per frame'.
 * NOTE: This affects BOTH 4-way and 8-way movement, but ONLY
 *       if the quest rule "New Player Movement" is enabled.

int ShoveOffset;
 * The offset from corners that the player's movement will 'shove' them around.
 * Only applies if "Newer Player Movement" Quest Rule is enabled.
 * Ranges from 0-16

bool MoveXY(float dx, float dy, bool is_knockback = false,
	bool ignore_sideview = false, bool corner_shove = true);
 * Attempts to move the player by 'dx, dy'; obeying solidity.
 * 'is_knockback' should be true if this movement is the result of some scripted form of knockback.
 *     This currently has no effect for the player... It may in the future?
 * 'ignore_sideview': if this is false, and the current screen is sideview gravity, 'dy' will be
 *     ignored (unless the player is 'Climbing', has walk-through-walls enabled, or is sideview swimming)
 * 'corner_shove': if this is true, and the movement is not diagonal (i.e. one of dx or dy is '0'),
 *     then if the movement pushes the player into the corner of a solid, the player will automatically
 *     be shoved 'around' the corner. (Same as how engine movement does it)
 * Returns true if the full distance was moved, false otherwise.

bool MoveAtAngle(float degrees, float pxamnt, bool is_knockback = false,
	bool ignore_sideview = false, bool corner_shove = false);
 * As 'MoveXY()', but for a 'pxamnt' movement in the 'degrees' angle.

bool Move(int dir, float pxamnt, bool is_knockback = false,
	bool ignore_sideview = false, bool corner_shove = false);
 * As 'MoveXY()', but for a 'pxamnt' movement in the 'dir' direction.


bool CanMoveXY(float dx, float dy, bool is_knockback = false,
	bool ignore_sideview = false, bool corner_shove = true);
 * Same as MoveXY, but does not move the player- instead, just returns true/false based on what
 *     'MoveXY' would return.

bool CanMoveAtAngle(float degrees, float pxamnt, bool is_knockback = false,
	bool ignore_sideview = false, bool corner_shove = true);
 * Same as MoveAtAngle, but does not move the player- instead, just returns true/false based on what
 *     'MoveAtAngle' would return.

bool CanMove(int dir, float pxamnt, bool is_knockback = false,
	bool ignore_sideview = false, bool corner_shove = true);
 * Same as Move, but does not move the player- instead, just returns true/false based on what
 *     'Move' would return.

int ShieldJinx;
 * The time, in frames, that the shield is disabled. Negative values disable indefinitely.

bool Animation;
 * Normally 'true'. If enabled, the player sprite is animated by the ZC engine.
 * Set this false to disable engine animation.

bool NoStepForward;
 * If set true, the player will not take two steps into NES dungeon rooms.
 * This value is reset to false, every time that the hero sprite is initialised,
 * and thus, should be written ideally in the hero init script.
 * !! Future versions may change when this is cleared.

bool Gravity;
 * If set true (the default), the hero falls in sideview gravity.

bool Climbing;
 * Returns as 'true' when the hero is climbing a sideview ladder
 * Setting to 'false' will let go of the ladder, and setting 'true' will grab the ladder
 * While 'true', gravity does not affect the hero

int JumpCount;
 * Returns the number of times the hero has jumped in mid-air since last landing.
 * If this is positive, it will be reset to 0 the next frame the hero is on the ground.
 * Used by Roc's Feather items to determine how many extra jumps the hero has left

bool IsWarping;
 * Returns true if the player is currently being warped
 * Note that as scripts generally do not run in warps, this may not ever return true
 *     during a given warp, depending on the warp type, QRs, script type, etc.

int Immortal;
 * If non-zero, the player will not die, even if their HP drops to 0.
 * This will prevent effects such as bottled fairies from being triggered.
 * If greater than 0, decrements by 1 each frame.
 * If it becomes 0 while the player has 0 hp, it will act as though their HP just dropped
 *     to 0 that frame, and normal effects such as fairies will trigger.

int TileMod;
 * Read-only
 * The current *total* Player Tile Modifier.

void Kill(bool bypass_revive = false);
 * Kills the player. Their HP will be set to 0, and 'Immortal' will be bypassed.
 * If 'bypass_revive' is true, bottles will not be checked for revival items,
 *     and the normal single frame delay before death that is used for script-revival
 *     will also be skipped.
 * Otherwise, revival processes will occur as normal.

float Scale;
 * The scale factor for this sprited object. 
 * A scale of 0 and a scale of 1 are identical.
 * Scale values are a multiplier: 1.5 == 50% larger (150%).
 * Negative values are undefined.
 * You can only scale sprites if you disable the Compatibility Quest rule 
   'Old (Faster) Sprite Drawing'.
 
float Rotation;
 * The rotation factor for this sprited object, in degrees.
 * You can only rotate sprites if you disable the Compatibility Quest rule 
   'Old (Faster) Sprite Drawing'.

bool Item[256];
 * Reading from, or writing to this array no longer causes lag.

untyped Misc[32];		
 * Expanded from a size of [16] to [32]. An array of 32 miscellaneous variables for you to use as you please.
 * The Misc[] array now supports all datatypes, and has been expanded to a size of [32].

int RespawnX;
 * The X-coordinate at which the player will respawn upon drowning or such.
 * The engine may overwrite this value upon changing screens or standing on safe ground.

int RespawnY;
 * The Y-coordinate at which the player will respawn upon drowning or such.
 * The engine may overwrite this value upon changing screens or standing on safe ground.

int RespawnDMap;
 * The DMap at which the player will respawn upon drowning or such.
 * The engine may overwrite this value upon changing screens or standing on safe ground.

int RespawnScreen;
 * The screen at which the player will respawn upon drowning or such.
 * The engine may overwrite this value upon changing screens or standing on safe ground.

int SwitchTimer;
 * READ-ONLY
 * The timer for the switchhook effect. If > 0, a switch effect is active.
 * The player will swap positions with the target when this is equal to
 *     (Hero->SwitchMaxTimer / 2), and the animation completes when this
 *     reaches 0.

int SwitchMaxTimer;
 * READ-ONLY
 * The starting (max) value of the switch timer.

bool SwitchCombo(int pos, int effect);
 * Switch the player with the given combo position
 * Use the 'SW_EFF_' constants from std_constants.zh for 'effect'
 * Returns true if it is successful
 
int FakeZ;
 * Current FakeZ position. This value is treated as a second, separate Z axis;
 * Sprites will be offset upwards by this amount when drawn just like the Z axis and shadows will draw if applicable.
 * However, the sprite's hitbox will not be moved upwards into the Z Axis; instead it will be moved upwards on the Y axis,
 * mimicking how Vires and Pols Voice worked in the original Zelda.
 * This value is affected by FakeJump instead of Jump.
 
int FakeJump;			
 * The current velocity on the FakeZ axis. This value is added to FakeZ every frame; and this value is decreased
 * by the gravity value until it is lower than the terminal velocity value.

int TotalDrawYOffset;
 * READ-ONLY
 * Calculates the total drawYOffset including special engine effects
 *     (such as switchhook with the 'rise' effect).
 * Does not include Z value in the calculation.

int HealthBeep; 
 * The timer for the health beep sound, if it is not constant.
 * Setting this to -2 suspends system control over stopping the sound,
 * and setting this to -4 suspends system control over both stopping, 
 * and starting it.
 * The normal operating range used by the system is 70 to -1, where -1
 * wraps around to zero internally. 

int Stun;
 * Returns the number of frames for which Link will; remain stunned.
 * Writing to this causes Link to be stunned for 'n' frames.
 * This decrements once per frame.

int BunnyClk;
 * Returns the number of frames for which the player will be a Bunny.
 * If -1, the effect will be removed by the engine if the current
 *     dmap does not have the bunny flag, or the player possesses a pearl item.
 * -2 through -99 reserved for potential future engine use
 * If <-100, the effect will last until script-modified
 * If >0, will tick down each frame

int Pushing;
 * Returns the number of frames that Link has been pushing against a solid object.

int Defense[]; 
 * Unused at this time.

int ScriptTile;
 * If this is > 0, then Link will be drawn using this tile ID.
 * The specific tile is drawn. This is not an offset, nor OTile.

int ScriptFlip;
 * If this is > 0, then Link's tile will be drawn using this flip value.

bool DisableItem[256];
 * An array of 256 values that represents whether items are disabled on the current DMap.

int FlashingCSet;
 * This returns Link's current displayed cset when taking damage or invincible. If not in one of these states, will return his normal cset.
 * If called before Waitdraw() / player update, results may be off by a frame.
 * If the quest rule 'Invincible Player Flickers' is checked, this is unused.

bool isFlickerFrame();
 * This returns true if Link is currently in a flicker frame (either invisible or color masked).
 * If called before Waitdraw() / player update, results may be off by a frame.
 * If the quest rule 'Invincible Player Flickers' is unchecked, this is unused.

int FlickerColor;
 * This sets what color Link is drawn when flickering.
 * If -1, will use the default from Init Data.
 * If the quest rule 'Invincible Player Flickers' is unchecked, this is unused.

int FlickerTransparencyPasses;
 * This sets how many times the transparency effect is applied to Link's flicker effect.
 * If -1, will use the default from Init Data. If 0, will use a solid color.
 * If the quest rule 'Invincible Player Flickers' is unchecked, this is unused.

int InvFrames;				 
 * This returns how long Link will remain invincible, 0 if not invincible. Can be set. 

bool InvFlicker;			
 * If set false, Link will neither flash, nor flicker when invincible. 

int HurtSound;				
 * The sound that plays when Link is injured. By default this is '16', but you may change it at any time.  

int Eaten;				
 * Returns 0 if the player is not eaten, otherwise it returns the duration of them being eaten.

bool Grabbed;
 * Returns if the player is grabbed (i.e. by wallmaster)

int Equipment;				
 * Link->Equipment is now read-write, and needs testing.

int ItemA;				
 * Contains the item IDs of what is currently equiped to Link's A button.

int ItemB;				
 * Contains the item IDs of what is currently equiped to Link's B button.

int ItemX;				
 * Contains the item IDs of what is currently equiped to Link's X (Ex1) button.
 
int ItemY;				
 * Contains the item IDs of what is currently equiped to Link's Y (Ex2) button.

int SetItemSlot(int itm_id, int button, int force);				
 * This allows you to set Link's button items without binary operation with options for forcing them.
 * Use the constants ITM_REQUIRE_* and ITM_SLOT_* from <std> when passing values into this function. 

void SelectAWeapon(int dir);
void SelectBWeapon(int dir);
void SelectXWeapon(int dir);
void SelectYWeapon(int dir);
	* Changes the A/B/X/Y button item (respectively), in the same manner the engine subscreen cursor
	* moves. DIR_RIGHT/DIR_LEFT are equivalent to how quickswap cycles.
	* A/X/Y versions do nothing if the QR allowing items to be set for that button is not enabled.

bool Diagonal;	
 * This corresponds to whether 'Diagonal Movement' is enabled, or not. 

bool BigHitbox;		
 * This corresponds to whether 'Big Hitbox' is enabled, or not. 
	
int Attack; 

/* The following have not been ported from 2.future to Canonical ZC:

	int Animation;				
	* Link's Animation style, as set in Quest->Graphics->Sprites->Link
						
	int WalkASpeed;				
	* Link's Walking Animation speed as set in Quest->Graphics->Sprites->Link

	int SwimASpeed;				
	* Link's Swiming Animation speed as set in Quest->Graphics->Sprites->Link

	int HitHeight;				
	* link's Hitbox height in pixels starting from his 0x,0y (upper-left) corner, going down. 
			
	int HitWidth;				
	* Link's Hitbox width in pixels starting from his x0,y0 (upper-left) corner, going right. 

	int HitXOffset;				
	* The X offset of Link's hitbox, or collision rectangle.
		
	int HitYOffset;				
	* The Y offset of Link's hitbox, or collision rectangle.

	int Extend;			
	* Sets the extend value for all of Link's various actions.
*/

void Warp(int DMap, int screen);
 * Warps link to the given screen in the given DMap, just like if he'd
 * triggered an 'Insta-Warp'-type warp.
 * Uses warp return square A, unless compat rule `Old 'Hero->Warp' Return Square' is on,
 *    in which case it uses the warp return square of the current screen's Sidewarp A.

void WarpEx(int ptr[])

* Similar to Link->Warp, but with more options. This takes an array, or
  an array literal as its arguments. 
  
  Valid array params are:
	Link->WarpEx({type,dmap,screen,x,y,effect,sound,flags})
	and
	Link->WarpEx({type,dmap,screen,x,y,effect,sound,flags,forcedir})

	type:
		WT_IWARP: Acts like a tile warp.
		WT_ENTRANCEEXIT: An entrance/exit warp.
		WT_SCROLLING: A scrolling warp.
			
	dmap:
		The Destination DMap
		
	screen: 
		The Destination Screen
		
	x, y:
		Either raw pixel coordinates, or a warp return square ID.
		
			Link->WarpEx() Coordinates Versus Warp Return Square:
				- If 'x' and 'y' are both > -1, then they are raw coordinates as always.
				- If 'x' < 0, THEN 'y' is the warp return square type, using positive integers.

					This allows using the warp return constants in std.zh, and it prevents a 
					possible ID clash from both values trying to establish the square ID. 
				- If BOTH are < 0, then it acts as a pitwarp (player stays in place)

	effect:
		Warp Effects are:
		WARPEFFECT_NONE: No visual effect.
		WARPEFFECT_ZAP: Zap Effects
		WARPEFFECT_WAVE: Wave Effects
		WARPEFFECT_INSTANT: Black screen.
		WARPEFFECT_OPENWIPE: Calls the opening wipe.

	sound:
		You may play a special sound (e.g. Magic Mirror) during the warp.

	flags:
		Warp Flags are:
		WARP_FLAG_SCRIPTDRAW: Don't kill script drawing during the warp.
		WARP_FLAG_PLAYSOUNDS: Don't kill playing sounds during the warp.
		WARP_FLAG_PLAYMUSIC: Don't kill playing music during the warp.
		WARP_FLAG_SETENTRANCESCREEN:
		WARP_FLAG_SETENTRANCEDMAP:
		WARP_FLAG_SETCONTINUESCREEN:
		WARP_FLAG_SETCONTINUEDMAP:
		These flags can be OR'd (|) together.

	forcedir:
		You can either accept the engine's setting for what Link's Dir should be
		after warping him, or force a dir.

int PitPullDir;
 * Returns the direction that the Hero is being pulled in by a pit
 * Read-only

int PitPullTimer;
 * A timer related to pits pulling the hero
 * The pit will only pull the hero on frames where 'PitPullTimer % PitSensitivity == 0'
 * The Pit Sensitivity is an attribyte on the pit combo
 * Read-Write

int Falling;
 * The timer indicating how long left the Hero will be falling
 * If 0, the Hero is not falling
 * Max value of 70, which is the value when you begin falling
 * Writing 'Hero->Action = LA_FALLING' is identical to setting this to 70.
 * Read-Write

int FallCombo;
 * The pit combo that the Hero is falling into
 * If non-zero, this combo's attributes will affect things such as if the Hero will warp,
 *     and how much damage they will take upon finishing falling.
 * If ==0, the Hero will take 1/4 heart of damage, and not warp
 * Writing 'Hero->Action = LA_FALLING' will overwrite this value
 * Writing to '->Falling' will overwrite this value
 * Read-Write

bool MoveFlags[2];
 * Flags relating to movement.
 * See 'HEROMV_' constants in std_constants.zh for values
 * [0] == Obeys gravity (see ->Gravity)
 * [1] == Can fall in pitfalls
 * Read-Write

float IceVx;
float IceVy;
 * The player's ice velocity (in pixels per frame).
 * Read/write, has no effect unless the player is Sliding.
 * If the player is not Sliding, the engine will clear these to '0'.

int IceEntryFrames;
int IceEntryMaxFrames;
 * Read/write, 0-255, has no effect unless the player is Sliding.
 * Used to grant the player some leeway when first entering the ice.
 * On entering the ice, these are set to the same value, and 'IceEntryFrames'
 *     then ticks down each frame to 0. Instantly goes to 0 if the player is still.
 * Based on the ratio between these values, the player's deceleration
 *     will be somewhere between the IceCombo's deceleration and half of the player's step speed.

int Sliding;
 * Read-only. One of the 'SLD_' constants:
 * SLD_NONE (0) - not sliding
 * SLD_ICE (1) - sliding on the ground, on ice
 * SLD_AIR (2) - sliding in the air (momentum from ice)

int IceCombo;
 * Read-only. The icy combo the player is sliding on.

int ScriptIceCombo;
 * Read-write. If nonzero, this combo is used instead of the IceCombo (can be used to force the player to slide).
 * If the specified combo is not an Icy Floor combo that affects the player, no sliding will occur.

**************************************************************

untyped HitBy[10];
 * Stores the ID/UIDs of objects that hurt the Link this frame.

 * Indices:

 * The first four indices are for the *screen index* of objects:

 * Description		Index	Status
 * HIT_BY_NPC 		[0] 	In use by the engine. 
 * HIT_BY_EWEAPON 	[1] 	In use by the engine.
 * HIT_BY_LWEAPON 	[2]		In use by the engine.
 * HIT_BY_FFC 		[3] 	Not used at this time. 

 * The next four, are for the FFCore 'script' UIDs of objects:

 * Description			Index	Status
 * HIT_BY_NPC_UID 		[4] 	In use by the engine. 
 * HIT_BY_EWEAPON_UID 	[5] 	In use by the engine.
 * HIT_BY_LWEAPON_UID 	[6]		In use by the engine.
 * HIT_BY_FFC_UID 		[7] 	Not used at this time. 

 * The last two, are reserved for special damage-object types. 

 * Description		Index	Status
 * HIT_BY_COMBO 	[8]		Not used at this time. 
 * HIT_BY_MAPFLAG 	[9] 	Not used at this time. 

 * These indices are uniform across all HitBy[] array members, for any datatype with that member.

**************************************************************

/************************************************************************************************************/

________          __             _________ __                        __          
\______ \ _____ _/  |______     /   _____//  |________ __ __   _____/  |_  ______
 |    |  \\__  \\   __\__  \    \_____  \\   __\_  __ \  |  \_/ ___\   __\/  ___/
 |    `   \/ __ \|  |  / __ \_  /        \|  |  |  | \/  |  /\  \___|  |  \___ \ 
/_______  (____  /__| (____  / /_______  /|__|  |__|  |____/  \___  >__| /____  >
        \/     \/          \/          \/                         \/          \/ 
The following are the members of data struct pointers (combo, sprite, item, npc, message, game, cheat, warpring, shop, map, and dmap data).

//////////////////
///  itemdata  ///
//////////////////								// Itemdata

int ID;		
 * Returns the item number of the item in question.

bool EquipmentItem;
 * Identical to bool Keep, but with more logical naming.

int PickupSound;
 * The pickup sound

int SpriteScript;
 * The itemsprite script

bool Gradual;
 * The gradual checkbox from the pickup tabs

int Damage;
 * The damage produced by weapons generated from tis item.
 * Identical to itemdata->Power, provided for uniformity it weapons.

void RunScript(int mode = ISCR_RUN);
 * Runs the script assigned to this item at any arbitrary time.
 * Mode Settings:
 * 0 : ISCR_KILL 
 * 	THIS TERMINATES THE RUNNING SCRIPT.
 * 1: ISCR_RUN
 * 	Runs the script either once, or perpetually, based on the ZScript Rule.
 * 2: ISCR_PERPETUAL
 * 	Runs the script perpetually, even if the QR if off. 

int Family;
int Type;
 * The Family (Item Class) of the item.

int WeaponScript;
 * The weapon action script assigned to this item.

int WeaponInitD[8];
 * The eight InitD args used by the weapon script for this item.

int TileMod;
 * The Player Tile Modifier

int Tile;	
 * The tile used by the item.

int CSet;	
 * The CSet of the tile used by the item.
	
int Flash;		
 * The Flash value for the CSet
	
int AFrames;		
 * The number of animation frames in the item's tile animation. 

int ASpeed;		
 * The speed of the item's animation.
	
int Delay;	
 * The Delay value, before the animation begins. 

int Script;		
 * The Action Script for the item.

int PScript;	
 * The Pickup Script for the item.

int MinHearts;		
 * The minimum number of hearts required to pick up the item.

untyped Attributes[10];
 * The item's Attributes, accessed as 'untyped' values.
 * WARNING: Larger values may be cut off!

long LAttributes[10];
 * The item's Attributes, accesses as 'long' values
 * An editor value of '1' will read as '1L', or '0.0001'. This allows all values to "fit".

int Sprites[10]
 * An array of ten integers that correspond to the ten sprite pulldowns on the item editor Action tab.

int BurnSprites[ITM_BURNSPR_MAX];
 * The burning sprites from 'Graphics->Sprites->Burning'. Use the 'ITM_BURNSPR_' constants.

int BurnLightRadius[ITM_BURNSPR_MAX];
 * The burning light radii from 'Graphics->Sprites->Burning'. Use the 'ITM_BURNSPR_' constants.

bool Flags[16]
 * An array of 16 boolean flags that correspond to the 16 flag tickboxes on the item editor Flags tab.

bool ConstantScript;
 * Corresponds to the 'Constant Script' box on the Flags tab of the item editor.
bool SideSwimDisabled;
 * Corresponds to the 'Disabled In Sideview Water' box on the Flags tab of the item editor.
bool BunnyUsable;
 * Corresponds to the 'Usable as a Bunny' box on the Flags tab of the item editor.
bool JinxImmune;
 * Corresponds to the 'Immune to jinxes' box on the Flags tab of the item editor.
bool JinxSwapped;
 * Corresponds to the 'Uses Other Jinx' box on the Flags tab of the item editor.
bool UseBurnSprites;
 * Corresponds to the 'Use Burning Sprites' box on the Graphics tab of the item editor

bool Combine;	
 * Corresponds to 'Upgrade when collected twice'.
	
bool Downgrade;	
 * Corresponds to the 'Remove When Used' option on the Action tab of the item editor. 
	
bool KeepOld;
 * Corresponds to 'Keep Lower Level Items' on the Pickup tab of the item editor. 
 
bool Validate;
 * Corresponds to 'Only Validate Cost' on the Action tab of the item editor
bool Validate2;
 * Corresponds to 'Only Validate Cost2' on the Action tab of the item editor

bool Edible;	
 * Corresponds to the 'Can be Eaten by Enemies' box on the Flags tab of the item editor. 
	
bool GainLower;	
 * Corresponds to the 'Gain All Lower Level Items' box on the Pickup tab of the item editor. 

untyped InitD[8];
 * The eight D* args used by both item scripts. Accepts all datatypes.

int Family;
 * The item class.

int Level;
 * The item's Level.

int Power; 
 * The amount of damage generated by the primary weapon for this item, if any.

int Amount;
int Max; 
int MaxIncrement;
int Keep;
int Counter; //should be renamed to IncreaseCounter

int MagicCostTimer;
int CostTimer;
 * The number of frames between counter decrements, when using an item with a perpetual 
 * 	upkeep cost, such as Boots and Cane items.

int CostTimer2;
 * The number of frames between counter decrements, for the second cost.

int UseSound;
 * The sound that may play when the item is used. When it plays differs depending on itemclass.
int UseSound2;
 * A second sound that may play when the item is used. When it plays differs depending on itemclass.

int Pickup; 
 * The Pickup type for this item See IP_* in std_constants.zh.
	
int PickupFlags;
 * A flagset used by the Item Editor UI to determine special conditions for item pick-up.
 * Values are ORd together:
 *
 *

int PickupString;
 * The ZQ String Editor (message) string that will appear when Link collects this item.
 * Note: The exact nature of hw frequently the string will be shown per game session can be
 *	modified using 'int PickupStringFlags'.

int PickupStringFlags;
 * A flagset that determines how frequently the PickupString for an item is displayed per game session.
 * You may set the string to always show, only show once per game session, or other intervals
 * using the following flagset (values are ORd together):
 *
 *
 *

int MagicCost;
int Cost;
 * The cost of the item, in units. Whenever the item is used, this value is decremented from 
 * 	the counter supplied to 'CostCounter'. 
 * If the item runs for more than one frame, this amount will be decremented every n frames,
 * 	where n is the value of 'CostTimer'.

int Cost2;
 * The second cost of the item, in units.
 * Charged in addition to the first cost.

int CostCounter;
 * The counter to use when decrementing the item cost. The default is 'CR_MAGIC'.

int CostCounter2;
 * The counter to use when decrementing the second cost. The default is 'CR_NONE'.
 * Charged in addition to the first cost.

int DrawXOffset;
 * The horizontal draw offset of the item. 
 * Note: SizeFlags[??] must be enabled for this to function.
	
int DrawYOffset;
 * The vertical draw offset of the item. 
 * Note: SizeFlags[??] must be enabled for this to function.

int HitXOffset;
 * The horizontal hitbox offset of the item. 
 * Note: SizeFlags[??] must be enabled for this to function.

int HitYOffset;
 * The vertical hitbox offset of the item. 
 * Note: SizeFlags[??] must be enabled for this to function.

int HitWidth;
 * The hitbox width (X component), in pixels, for the enemy.
 * Note: SizeFlags[??] must be enabled for this to function.

int HitHeight;
 * The hitbox height (Y component), in pixels, for the enemy. 
 * Note: SizeFlags[??] must be enabled for this to function.

int TileWidth;
 * The drawn width (X component) of the item in increments of one tile.
 * Note: SizeFlags[??] must be enabled for this to function.
	
int TileHeight;
 * The drawn height (Y component) of the item in increments of one tile.
 * Note: SizeFlags[??] must be enabled for this to function.

int Weapon;
 * The weapon type that this weapon mimics for the purpose of 
 * calculating the defence outcome when the weapon strikes an enemy,
 * and for determining what combos and secrets it can trigger. 
 * Set to -1 to disable and use the real weapon type/ID.

int Defense;
int Defence;
 * The default defence resolution (e.g. OHKO) that the weapon uses
* when it strikes an enemy. If this is set to anythin gother than -1,
* and the enemy had a defence resolution of 'None', then this default
* defence resolution is used in place of 'None'. 

untyped WeaponInitD[8];
 * An array of the eight D[] args used by the script attached to this weapon.
 
untyped WeaponMisc[32];
 * An array the 32 Misc[] values used by the weapon. 
 * This may be only partially implemented. 
 
int WeaponScript;
 * The weapon script attached to this weapon, when the item generates it.
 
int WeapomnHitXOffset
 * The default HitXOffset used by this weapon when the item generates it.
 
int WeaponHitYOffset;
 * The default HitYOffset used by this weapon when the item generates it.
 
int WeaponHitHeight;
 * The default HitHeight used by this weapon when the item generates it.
 
int WeaponHitWidth;
 * The default HitWidth used by this weapon when the item generates it.
 
int WeaponHitZHeight;
 * The default HitZHeight used by this weapon when the item generates it.
 
int WeaponDrawXOffset; 
 * The default DrawXOffset used by this weapon when the item generates it.
 
int WeaponDrawYOffset;
 * The default DrawYOffset used by this weapon when the item generates it.
 
int WeaponDrawZOffset;
 * The default DrawZOffset used by this weapon when the item generates it.

int OverrideFlags;
int SizeFlags;
 * A flagset that determines which Item Editor 'Size' tab attribute values are applied to the
 * item, overriding engine defaults.
 
int WeaponOverrideFlags;
 * A flagset that determines which Item Editor 'Size' tab attribute values are applied to the
 * weapon generated by this item, overriding engine defaults. 

void GetName(char32 buffer[]);
 * Loads the item's name into 'buffer'.

void GetDisplayName(char32 buf[]);
 * Fills the buffer with the item's Display Name.

void SetDisplayName(char32 buf[]);
 * Sets the item's Display Name to the contents of the buffer.

void GetShownName(char32 buf[]);
 * Fills the buffer with the name of the item as shown on the subscreen.
 * This automatically handles display names, including special instances
 *     such as the contents of Bottles.

//! NOT IMPLEMENTED, or NOT FULLY-IMPLEMENTED. 
 
int Range;
 * The distance that the weapon is allowed to travel. 
 * See weapon->Distance;
 * Not implemented at this time.
 
int Duration;
 * The duration of the weapon.
 * See weapon->Duration.
 * Not implemented at this time.
 
int Duplicates;
 * The number of extra weapons that this weapon creates.
 * Not implemented at this time.
 
int DrawLayer; 
 * The layer used to draw the weapon to the screen.
 * Not implemented at this time.
 
int CollectFlags;
 * The items (in CSV format, using a SCV list ID) that the weapon created
 * by this item, collects on contact.
 * Not implemented at this time.

t/b/a
itemdata GetItem(char32[] name);

/************************************************************************************************************/

/////////////////////
///  messagedata  ///
/////////////////////								// Messagedata

void Set(int buffer[]);
 * Assigns the ZString buffer[] to the messagedata pointer's string.

void Get(int buffer[]);
 * Copies the string value from the messagedata pointer, to the array buffer[].


int buffer_str[80];

int Next;
 * Next message in list.

int Tile;
 * The tile for the background

int CSet;
 * The CSet for the background

int Font;
 * The message font

int X;
 * The messagebox X position

int Y;
 * The messagebox Y position

int Width;
 * The messagebox Width

int Height;
 * The messagebox Height

int Sound;
 * The text advancing SFX

int ListPosition;
 * The position in the list

int VSpace;
 * The space vertically between lines, in pixels

int HSpace;
 * The space horizontally between characters, in pixels

int Margins[4];
 * The margins, in pixels, from each side of the message box.

bool Flags[7];
 * A set of flags
 * MSGFLAG_WRAP         - If the text wraps around the bounding box
 * MSGFLAG_CONT         - If the message is the continuation of a previous one
 * MSGFLAG_CENTER       - Reserved
 * MSGFLAG_RIGHT        - Reserved
 * MSGFLAG_FULLTILE     - If the background tile should be treated as the UL of a tile block,
 *                        instead of the UL of a 2x2 adjustable frame
 * MSGFLAG_TRANS_BG     - If the background should be translucent
 * MSGFLAG_TRANS_FG     - If the text should be translucent

int PortraitTile;
 * The upper-left corner tile of the portrait.
 * If 0, no portrait will be displayed.

int PortraitCSet;
 * The CSet of the portrait

int PortraitX;
 * The X position of the portrait

int PortraitY;
 * The Y position of the portrait

int PortraitTileWidth;
 * The Tile Width of the portrait.
 * If 0, no portrait will be displayed.
 * Max value 16

int PortraitTileHeight;
 * The Tile Width of the portrait.
 * If 0, no portrait will be displayed.
 * Max value 14

int TextWidth();
 * Returns the width, in pixels, of the message.
 * This uses the font and text as set in the 'Strings' editor,
 * 	and ignores both trailing spaces and line breaks.

int TextHeight();
 * Returns the height, in pixels, of the message.
 * This uses the font as set in the 'Strings' editor, and ignores line breaks.

int Length;
 * Returns the length, in characters, of the message string text
 * Read-Only
	
//////////////////
///  dmapdata  ///
////////////////// dmapdata

	1.	Sideview Gravity on All Screens (uses Dmaps[].sideview, new var.
	2.	Layer 3 is Background on All Screens (uses DMaps[].flgs&dmfLAYER3BG)
	3.	Layer 2 is Background on All Screens (uses DMaps[].flgs&dmfLAYER2BG
	
int ID;
 * Read-only. 
 * This returns the DMap ID for a given dmapdata pointer.

int Map;
 * The game map used by the dmap.
 
int Level;
 * The Level ID of the DMap.
 
int Offset;
 * The DMap offset.
 
int Compass;
 * The screen where the compass marker appears in the minimap.
 
int Palette;
 * The level palette used by the dmap. 
 * Equivalent to Game->DMapPalette[this->ID].
 
int MIDI;
 * The MIDI ID used by the DMap.
 
int Continue;
 * The screen on which the player spawns on the DMap.
 
int Type;
 * The DMap type. Legal types are:
 * 0: NES Dungeon
 * 1: NES Overworld
 * 2: Interior
 * 3: BS Overworld
 
int MusicTrack;
 * The enhanced music tracker file track ID.

float MusicLoopStart;
 * The starting loop point for enhanced music in seconds.
 * CURRENTLY ONLY SUPPORTS MP3 / OGG / IT / XM / S3M / MOD

float MusicLoopEnd;
 * The ending loop point for enhanced music in seconds.
 * CURRENTLY ONLY SUPPORTS MP3 / OGG / IT / XM / S3M / MOD

int MusicCrossfadeIn;
 * The number of frames enhanced music fades in for

int MusicCrossfadeOut;
 * The number of frames enhanced music fades out for
 
int ActiveSubscreen;
 * The active subscreen ID.
 
int PassiveSubscreen;
 * The passive subscreen ID.

int OverlaySubscreen;
 * The overlay subscreen ID.
 
int Grid[8];
 * The rooms displayed either when the player has the map item,
 * or when visiting rooms, marked in the DMap editor.
 * See the functions in dmapgrid.zh to access these values.
 
int MiniMapTile[2];
 * The first tile ID used by passive subscreen minimap tile block.
 * Index [0] is the small minimap without the map item, and [1] is the minimap with the map item.
 
int MiniMapCSet[2];
 * The CSet used by the passive subscreen minimap tiles.
 * Index [0] is the small minimap without the map item, and [1] is the minimap with the map item.
 
int MapTile[2];
 * The first tile ID used by active subscreen dungeon map tile block.
 * Index [0] is the map without the map item, and [1] is the map with the map item.
 
int MapCSet[2];
 * The CSet used by the active subscreen dungeon map tiles.
 * Index [0] is the map without the map item, and [1] is the map with the map item.
 
int DisabledItems[256];
 * The items that are disabled on the active subscreen for this DMap.

int Flagset[32];
 * This is similar to int FLags, but Flags cannot handle enough bits for the now current
 * number of bits used by the engine. Thus, this replaces it. 
 * Indices in use:
	DMFS_CAVESNOTCELLARS		= 0; //Use caves instead of item cellars
	DMFS_3STAIRWARPS		= 1; //Allow 3-stair warps
	DMFS_WWIND			= 2; //Allow whistle whirlwinds
	DMFS_GUYCAVES			= 3; //Special rooms and guys are in caves only
	DMFS_NOCOMPASS			= 4; //Don't display compass marker in minimap
	DMFS_WAVY 			= 5; //Underwater wave effect
	DMFS_WWINDRET			= 6; //Whistle whirlwind returns Link to start
	DMFS_ALWAYSINTROMSG		= 7; //Always display intro string
	DMFS_VIEWMAP       		= 8; //View overworld map by pressing 'Map'
	DMFS_DMAPMAP         		= 9; //...But only show screens marked in minimap
	DMFS_MINIMAPCOLORFIX 		= 10; //Use minimap foreground colour 2
	DMFS_MINIMAPCOLOURFIX 		= 11; //Use minimap foreground colour 2
	DMFS_SCRIPT1 			= 12; //DMap Script Flags
	DMFS_SCRIPT2 			= 13;
	DMFS_SCRIPT3 			= 14;
	DMFS_SCRIPT4 			= 15;
	DMFS_SCRIPT5 			= 16;
	DMFS_SIDEVIEW 			= 17; //DMap is Sideview
	DMFS_LAYER3ISBACKGROUND 	= 18; //Layer 3 is Background
	DMFS_LAYER2ISBACKGROUND 	= 19; //Layer 2 is bBackground
	DMFS_TRUECELLARENEMIES 		= 20; //True Cellar Enemies
 * Indices 21 to 31 are reserved for future expansion. Please do not use these. 

int Flags;
 * The flags used by the DMap. These are OR'd together. 
 * The values are:
 * #define dmfCAVES			0x0001
 * #define dmf3STAIR			0x0002
 * #define dmfWHIRLWIND			0x0004
 * #define dmfGUYCAVES			0x0008
 * #define dmfNOCOMPASS			0x0010
 * #define dmfWAVY 			0x0020
 * #define dmfWHIRLWINDRET		0x0040
 * #define dmfALWAYSMSG   		0x0080
 * #define dmfVIEWMAP       		0x0100
 * #define dmfDMAPMAP         		0x0200
 * #define dmfMINIMAPCOLORFIX 		0x0400
 * #define dmfSCRIPT1 			0x0800
 * #define dmfSCRIPT2 			0x1000
 * #define dmfSCRIPT3 			0x2000
 * #define dmfSCRIPT4 			0x4000
 * #define dmfSCRIPT5 			0x8000
 
bool Sideview;
 * If true, all screens on the DMap are treated as sideview
 * UNLESS the screen flag Toggle Sideview is enabled.
 * If calse, all screens on the DMap are treated as overhead
 * UNLESS the screen flag Toggle Sideview is enabled.

int MirrorDMap;
 * The mirror DMap for this dmap.
 
int Script;
 * The standard DMap Active Script ID.

untyped InitD[8];
 * The eight script args for the dmapdata active script that runs 
 * on this DMap. 

int ASubScript;
 * The 'Active Subscreen' script slot ID
int PSubScript;
 * The 'Passive Subscreen' script slot ID

untyped SubInitD[8];
 * The eight script args shared by the active/passive subscreen
 * script slots on this DMap.

int MapScript;
 * The 'Scripted Map' script slot ID

untyped MapInitD[8];
 * The eight script args for the scripted map that runs
 * on this DMap.

int Charted[128];
 * Stores map exploration data for each screen on the DMap.
 * Does not work on overworld dmaps at present.
 * Data is stored bitwise, using the 'CHRT_' constants in std_constants.zh
 *     Ex: To read visited state, use 'dm->Charted[scr] & CHRT_VISITED'
 * If the screen value is off the edge of the dmap, it will return '-1'.
 * If the screen values is >127 or the dmapref is invalid,
 *     an error will be logged, and it will return '-1'.

	
void SetName(char32 buffer[]);
 * Copies the contents of the client array 'buffer' over the original 
 * DMap name. 
 
void GetName(char32 buffer[]);
 * Copies the name of the DMap into a client string 'buffer'.

void SetTitle(char32 buffer[]);
 * Copies the contents of the client array 'buffer' over the original 
 * DMap title. 
 
void GetTitle(char32 buffer[]);
 * Copies the title of the DMap into a client string 'buffer'.
 
void SetIntro(char32 buffer[]);
 * Copies the contents of the client array 'buffer' over the original 
 * DMap intro text. 
 
void GetIntro(char32 buffer[]);
 * Copies the intro text of the DMap into a client string 'buffer'.

void SetMusic(char32[] filename); 
 * Sets the enhanced music used by the DMap to a specified filename.
 
void GetMusic(char32[] buffer);
 * Copies the filename of the DMap enhanced music into a client string 'buffer'.


//////////////////
///  shopdata  ///
//////////////////								// Shopdata

int Type;
 * Returns the shop type for the current shopdata pointer where:
 * 0: Invalid
 * 1: Item Shhop
 * 2: Info Shop
 * This is read-only and solely based on the internal value of the pointer.
 
int Price[3];
 * Valid for both item and innformation shop types.
 * The trhree prices for items or information in the shop. 
 * [0] is leftmost, [1] is middle, [2] is rightmost.
 
int String[3];
 * Valid for both item and innformation shop types.
 * For info shops, these are the IDs of the three hint strings that you can buy.
 * For item shops, these are the IDs of the three strings displayed when you buy an item.
 * [0] is leftmost, [1] is middle, [2] is rightmost.

int Item[3];
 * Valid ONLY for item shop types.
 * The IDs of the items sold by the shop.
 * [0] is leftmost, [1] is middle, [2] is rightmost.
 
bool HasItem[3];
 * Valid ONLY for item shop types.
 * Enables the sale of items in each of the three positions.
 * [0] is leftmost, [1] is middle, [2] is rightmost.
 
Note: The message displayed when entering a shop is Screen->String, or mapdata->String.

/////////////////
///  mapdata  ///
/////////////////								// Mapdata

int Map;
 * Returns the map that this mapdata points to
 * Read-Only

int Screen;
 * Returns the screen that this mapdata points to
 * Read-Only

bool LayerInvisible[7];
 * If true, the current layer is invisible.
 * Writing this true for layers 1 through 6 will make those layers invisible.
 
bool ScriptDraws[8];
 * If true, the ZC engine will perform script draws ont he given
 * queue layer. 
 * Each queue layer returns true by default. 
 * Writing this false disables script draws targetted to a specific layer queue. 

int Script; 
 * Returns the ID of the script set to the mapscreen, or sets the script that this mapscreen runs.
 
untyped InitD[8];
 * The eight script args for the script that runs on this mapscreen.

bool isSolid(int x, int y);
 * As Screen->isSolid(int x, int y), for any mapscreen.

bool isSolidLayer(int x, int y, int layer);
 * As Screen->isSolidLayer(int x, int y, int layer), for any mapscreen.

int Valid;
 * ?

int Guy;
 * The screen guy.

int String;
 * The screen string.

int RoomType;
 * The screen room type.

int Item; 
 * The screen item.
 * Note: The NULL value is '0', which is a valid item.
 * 	To determine if there is an item on the screen, if you ever assigned
 * 	item 0 as a valid screen item in your quest, you will also want to read
 * 	HasItem for that screen.

int HasItem;
 * If not zero, then the item for this screen will be shown.
 * When Link takes the item on a screen, this is set to 0.

int TileWarpType[4];
 * The Tile Warp type for Tile Warps A, B, C, and D; [0], [1], [2], and [3] respectively.
 * See std_constants.zh WT_* constants for valid types.
	
bool SideWarpOverlay[4];
bool TileWarpOverlay[4];
 * Set or get the overlay state for the warp ID corresponding to the index of this array.

int DoorComboSet;
 * The doorset used by the screen, for NES dungeon doors.

int SideWarpReturnSquare[4];
 * The return square (A->D) used by Side Warp[A->D].

int TileWarpReturnSquare[4];	
 * The return square (A->D) used by Tile Warp[A->D].

int WarpReturnX[4];
 * The X-component for each of the four 2.50+ (blue) warp return squares.
	
int WarpReturnY[4];
 * The Y-component for each of the four 2.50+ (blue) warp return squares.
	
int WarpReturnC;
 * Stores the information on warp returns, butwise.
 * Deprecated by SideWarpReturnSquare[4] and TileWarpReturnSquare[4].
 * The bits are DDCCBBAADDCCBBAA, where the left section is sidewarp returns, and the right is tilewarp returns.

int StairsX;
 * The X component for where a Stairs secret appears on the screen.
	
int StairsY;
 * The Y component for where a Stairs secret appears on the screen.
	
int ItemX;
 * The X component for the item location on the screen.
	
int ItemY;
 * The Y component for the item location on the screen.

int Palette;
int CSet;
 * The screen palette.

int Door[4];
 * The door state for the screen. See D_* constants for direction and door type.
	
int TileWarpDMap[4];
 * The destination DMap for each of the four warp types.
	
int TileWarpScreen[4];
 * The destination screen for each of the four warp types.

int Enemy[10];
 * The IDs of the enemies that spawn on the screen.

int EnemyFlags;
 * A flagset for enemies on the screen (E.Flags).
 * Valid values (ORd) together, are:
 *
 *

int Pattern;
 * This enemy 'Spawn Pattern'.
 * Use the PATTERN_* constants in std.zh for the valid values

int SideWarpID[4];
 * Returns the sidewarp ID for a given screen edge, as SideWarpID[dir];
 * Returns -1 if there is no sidewarp in that direction.
 * Use the SIDEWARP_* constants in std.zh for the value of this (read return value, or write value).
 * Use the DIR_* constants in std.zh for the index values.

int SideWarpType[4];
 * The Sidewarp type for Sidewarps A, B, C, and D; [0], [1], [2], and [3] respectively.
 * See std_constants.zh WT_* constants for valid types.
	
int SideWarpScreen[4];
 * The destination screen for each of the four sidewarps.
	
int SideWarpDMap[4];
 * The destination DMap for each of the four sidewarps.
	
int SideWarpIndex;
 * The warp return IDs. Deprecated by SideWarpID[].

int WarpArrivalX;
 * The X-component for the pre-2.50 (green) arrival square.
	
int WarpArrivalY;
 * The X-component for the pre-2.50 (green) arrival square.
	
int MazePath[4]; 
 * The four Maze Path directions.

int ExitDir;
 * The Maze Path 'Exit Direction'.

int UnderCombo;
 * The undercombo ID used by the screen.

int UnderCSet;
 * The CSet of the undercombo used by the screen.

int Catchall;
 * The screen 'Catchall' value. 

int CSensitive;
 * The value of Damage Combo Sensitivity for the screen.
	
int NoReset;
 * The No Reset Flagset. Values are ORd together s follows:
 * Secrets		0x
 * Items		0x
 * Special Item		0x
 * Lock Block		0x
 * Boss Lock Block	0x
 * Chest		0x
 * Secrets		0x
 * Locked Chest		0x
 * Boss Locked Chest	0x
 * Door Up [0]		0x
 * Door Down[1]		0x
 * Door Left [2]	0x
 * Door Right [3]	0x

int NoCarry;
 * The No Carry Over Flagset. Values are ORd together s follows:
 * Secrets		0x
 * Items		0x
 * Special Item		0x
 * Lock Block		0x
 * Boss Lock Block	0x
 * Chest		0x
 * Secrets		0x
 * Locked Chest		0x
 * Boss Locked Chest	0x

int LayerMap[7];
 * The Map IDs used by screen layers 1 through 6, represented as [1] through [6].
 * Index [0] does nothing, and trying to access it will report an error to the log.

int LayerScreen[7];
 * The Screen IDs used by screen layers 1 through 6, represented as [1] through [6].
 * Index [0] does nothing, and trying to access it will report an error to the log.

int LayerOpacity[7];
 * The opacity value for each layer used by this screen.
 * Valid layers are 1 through 6, represented as [1] through [6].
 * Index [0] does nothing, and trying to access it will report an error to the log.

int TimedWarpTimer;
 * The timer used by 'Time Warp Tics' in Screen Data->T.Warp

int CarroverMap;
int NextMap;
 * The map to where secrets on the current mapscreen carry over.
 * Corresponds to the Screen Data>>>Screen State Carryover 'Next Map' 
 * selection in the ZQ Editor.
 
int CarryoverSrceen;
int NextScreen;
 * The screen to where secrets on the current mapscreen carry over.
 * Corresponds to the Screen Data>>>Screen State Carryover 'Next Screen' 
 * selection in the ZQ Editor.

int SecretCombo[128];
 * The Combo IDs used by 'Secret Combos' on this screen.
 * See SECCMB_* in std_constants.zh for more information.
	
int SecretCSet[128];
 * The CSets used by 'Secret Combos' on this screen.
 * See SECCMB_* in std_constants.zh for more information.
	
int SecretFlags[128];
 * The Combo Flags used by 'Secret Combos' on this screen.
 * See SECCMB_* in std_constants.zh for more information.

int OceanSFX;
 * The 'Ambient Sound' under S.Data2. 
 * Rename this to AmbientSFX, or just SFX.

int BossSFX;
 * The Boss Roar sound for this screen.
	
int SecretSFX;
 * The sound that will play on this screen, when secrets are triggered.

int ItemSFX;
 * The sound that will play if Link holds an item over his head on this screen.
	
int MIDI;
 * The MIDI that plays on this screen.

bool LensShows[7];
bool LensHides[7];
 * Arrays of the layers which the lens shows, and hides, respectively.

int GuyCount;
 * Number of enemies remaining alive on this screen.

int DataSize;
 * Read-write, the size of the `Data[]` array.
 * Changes save to the save file.
untyped Data[];
 * Resizable array of data for scripts to use.
 * Changes save to the save file.

int Flags[10];
 * A set of flagsets that contain special data for thiws screen.
 * These represent S.Flags1 and S.Flags2 flags.
 * See std_constants.zh (SFG* for the screen flag group, 
 *	and SFX* for the screen flag value) for more information. 
	
int D[8];
 * Improperly implemented. Was meant to relate as Screen->D, except that
 * 	Screen->D is not bound to layermap.

int ComboD[176];
 * The IDs of each of the 176 combos used on the screen.

int ComboC[176];
 * The CSets of each of the 176 combos used on the screen.

int ComboF[176];
 * The placed (map) flags for each of the 176 combo positions used by this screen.

int ComboI[176];
 * The inherent flags of each of the 176 combos used on the screen.
 
int ComboS[176];
 * The solidity bits of each of the 176 combos used on the screen.
 
int ComboE[176];
 * The effect area bits of each of the 176 combos used on the screen.

bool State[32];
 * The screen states used by this screen. Identical to Screen->State[], but for mapdata screens.
bool ExState[32];
 * The 'Extra States' used by this screen. Identical to Screen->ExState[], but for mapdata screens.

bool GetExDoor(int dir, int index);
 * Returns a door state for the screen.
 * Each direction DIR_UP,DIR_DOWN,DIR_LEFT,DIR_RIGHT has 8 indexes (0-7)
void SetExDoor(int dir, int index, bool state);
 * Sets a door state for the screen.
 * Each direction DIR_UP,DIR_DOWN,DIR_LEFT,DIR_RIGHT has 8 indexes (0-7)

int EFlags[3];
 * The Screen Data E.Flags flagsets. 
 * Values are:
 *

int FFCEffectWidth[MAX_FFC];
 * The EffectWidth variable for each of the ffcs on the screen.
 * See ffc->EffectWidth for more details. 
		
int FFCEffectHeight[MAX_FFC];
 * The EffectHeight variable for each of the ffcs on the screen.
 * See ffc->EffectHeight for more details. 
	
int FFCTileWidth[MAX_FFC];
 * The TileWidth variable for each of the ffcs on the screen.
 * See ffc->TilwWidth for more details. 
	
int FFCTileHeight[MAX_FFC];
 * The TileHeighr variable for each of the ffcs on the screen.
 * See ffc->TilwHeight for more details. 

int FFCData[MAX_FFC];
 * The Data (combo ID) variable for each of the ffcs on the screen.
 * See ffc->Data for more details. 
	
int FFCCSet[MAX_FFC];
 * The CSet variable for each of the ffcs on the screen.
 * See ffc->CSet for more details. 
	
int FFCDelay[MAX_FFC];
 * The Delay variable for each of the ffcs on the screen.
 * See ffc->Delay for more details. 
	
int FFCX[MAX_FFC];
 * The X variable for each of the ffcs on the screen.
 * See ffc->X for more details. 
	
int FFCY[MAX_FFC];
 * The Y variable for each of the ffcs on the screen.
 * See ffc->Y for more details. 
	
int FFCVx[MAX_FFC];
 * The Vx variable for each of the ffcs on the screen.
 * See ffc->Vx for more details. 
	
int FFCVy[MAX_FFC];
 * The Vy variable for each of the ffcs on the screen.
 * See ffc->Vy for more details. 
	
int FFCAx[MAX_FFC];
 * The Ax variable for each of the ffcs on the screen.
 * See ffc->Ax for more details. 
	
int FFCAy[MAX_FFC];
 * The Vy variable for each of the ffcs on the screen.
 * See ffc->Vy for more details. 
	
int FFCFlags[MAX_FFC];
 * The Flags variable for each of the ffcs on the screen.
 * See ffc->Flags for more details. 
	
int FFCLink[MAX_FFC];
 * The Link variable for each of the ffcs on the screen.
 * See ffc->Link for more details. 
	
int FFCScript[MAX_FFC];
 * The Script variable for each of the ffcs on the screen.
 * See ffc->Script for more details. 
	
bool FFCRunning[MAX_FFC];
 * Returns true if the specified ffc is running a script?
 * May be used to pause/resume ffc script execution?
 * This needs to be cloned over to ffc->Running

 //Functions
int GetFFCInitD(int ffc_index, int n);
 * Returns the value of InitD[n] for the ffc on the screen with an ID of ffc_index.
 * This needs to be converted to the type 'untyped' to comply
 * 	with the change of float ffc->InitD[] to untyped ffc->InitD[]
 * 	Note: Expressed as a function due to lack of 2D arrays in ZScript. 
 * 	With 2D arrays, this would simply be FFCInitD[32][8].

void SetFFCInitD(int ffc_index, int n, float value);
 * Sets the value of InitD[n] for the ffc on the screen with an ID of ffc_index.
 * 'int value' needs to be converted to the type 'untyped' to comply
 * 	with the change of float ffc->InitD[] to untyped ffc->InitD[]
 * 	Note: Expressed as a function due to lack of 2D arrays in ZScript. 
 * 	With 2D arrays, this would simply be FFCInitD[32][8].


int GetFFCInitA(int ffc_index, int n);
 * Returns the value of InitA[n] for the ffc on the screen with an ID of ffc_index.
 * 	Note: Expressed as a function due to lack of 2D arrays in ZScript. 
 * 	With 2D arrays, this would simply be FFCInitA[32][2].


void SetFFCInitA(int ffc_index, int init_a, float value);
 * Sets the value of InitA[n] for the ffc on the screen with an ID of ffc_index.
 * 	Note: Expressed as a function due to lack of 2D arrays in ZScript. 
 * 	With 2D arrays, this would simply be FFCInitA[32][2].


///////////////////
///  combodata  ///
///////////////////								// Combodata

int Layer();
int Layer;
 * Returns the layer the combo is on in a combodata script, from the 'this->' pointer as 'this->Layer'
 * Using this from any other combodata variable is illegal and undefined.

int Pos();
int Pos;
 * Returns the combo screen index of a combo from a combodata script, from the 'this->'
 * pointer as 'this->Pos()'.
 * Using this from any other combodata variable is illegal and undefined.
 * Read-only

int PosX();
int X;
 * Returns the X-coordinate of a combo from a combodata script, from the 'this->'
 * pointer as 'this->PosX()'.
 * Using this from any other combodata variable is illegal and undefined.
 * Read-only

int PosY();
int Y;
 * Returns the Y-coordinate of a combo from a combodata script, from the 'this->'
 * pointer as 'this->PosY()'.
 * Using this from any other combodata variable is illegal and undefined.
 * Read-only

int Script;
 * The combodata script used by this combo.

untyped InitD[8];
 * The 8 InitD args used by the combodata script for this combo.

int ID;
 * Returns the combo ID associated with the current combodata pointer.

int Type; 
 * The 'type' of the combo, in the Combo Editor. 
 * Setting this changes the combo type variables. ?

int OriginalTile; 
 * The original tile of the combo's animation. Writing to this will cause the combo
 * 	to shift to the new animation immediately.
 * Writing this variable is undefined if the quest rule 'New Combo Animation' is off.
 
int Tile; 
 * The tile ID used by the current animation frame of the combo.
 * Writing to this will cause the tile you write to display for at least 1 frame.
 * Writing this variable is undefined if the quest rule 'New Combo Animation' is off.
 
int Frame;
 * The frame of the combo's animation that is presently showing. Writing to this will skip in the animation.
 * Using this variable is undefined if the quest rule 'New Combo Animation' is off.

int AClk;
 * The clock used for the combo's animation cycle.

int ASpeed;
 * The animation speed of the combo. 
 
int Flip; 
 * The flip settings for the combo tile.
	
int Walk;
 * The walkability flags value.
 * ???
 
int Effect;
 * The effect area flags value.
 * Uses the same binary values as 'Walk' above

int CSet2; 
 * The CSet2 Offset value for the combo

int CSet2Flags; 
 * The CSet2 flags value
 * ???

int Frames; 
 * The number of frames of animation.

int NextData;
 * 

int NextCSet;
 *

int NextTimer;
 *

int Flag;
 * The inherent flag bound to the combo.

int SkipAnim; //needs to be renamed to SkipAnimX
 * Corresponds to 'A.SkipX' in the Combo Editor.

int SkipAnimY;
 * Corresponds to 'A.SkipX' in the Combo Editor.

int AnimFlags;
 * This contains flag data for the Combo Editor settings:
 *  AF_FRESH       Refresh Animation on Room Entry
 *  AF_CYCLE       Refresh Animation When Cycled To
 *  AF_CYCLENOCSET Cycle ignores CSet
 *  AF_TRANSPARENT Toggle Transparent
 * Use bitwise operators with these constants to read/set these flags.

int Expansion[6];
 * Reserved for future use by the Combo Editor.
	
int Attributes[4];
 * Corresponds to Attributes[0] through Attributes[3] on the 'Attributes'
 * 	tab in the Combo Editor.
 * Min value MIN_FLOAT, max value MAX_FLOAT.
 
 int Attribytes[8];
 * Corresponds to Attribytes[0] through Attribytes[7] on the 'Attribytes'
 * 	tab in the Combo Editor.
 * Min value MIN_BYTE, max value MAX_BYTE.
 
 int Attrishorts[8];
 * Corresponds to Attrishorts[0] through Attrishorts[7] on the 'Attrishorts'
 * 	tab in the Combo Editor.
 * Min value MIN_SHORT, max value MAX_SHORT.

bool Flags[16];
 * The 16 user flags of the combo

bool GenFlags[2];
 * The generic flags of the combo
 * Use the 'GENFLAG_' constants from 'std_constants.zh'

bool TrigFlags[96];
 * The trigger flags of the combo
 * Use the 'TRIGFLAG_' constants from 'std_constants.zh'

bool TriggerButton[8];
 * The trigger button(s) of the combo
 * Use the 'INTBTN_' constants from 'std_constants.zh'

int TriggerLevel; 
 * Corresponds to the 'Minimum Level' field on the 'Triggers' tab of 
 *	the Combo Editor.

int TriggerItem;
 * The required item ID for triggering the combo.
 * If 0, no item is required.
 * Related:
 * TriggerFlags[TRIGFLAG_INVERT_ITEMREQ] (require NOT having the item),
 * TriggerFlags[TRIGFLAG_CONSUME_ITEMREQ] (consume the item)

int TriggerProximity;
 * The required player proximity for triggering the combo.
 * If 0, proximity requirement is disabled.
 * Related:
 * TriggerFlags[TRIGFLAG_INVERT_PROXIMITY] (require being farther instead of closer)

int TriggerTimer;
 * The timer for timed combo triggers. If 0, no timed trigger will occur.
 * The combo will be triggered every 'n' frames, timer unique to each combo position.

int TrigLightBeam;
 * The light beam trigger set that (may) trigger this combo.
 * 0 means any beams, 1-32 mean only matching beams.
 * Related:
 * TriggerFlags[TRIGFLAG_LIGHTON] (trigger when hit by matching light)
 * TriggerFlags[TRIGFLAG_LIGHTOFF] (trigger when NOT hit by matching light)

int TriggerCounter;
 * The counter used for counter-based triggerflags
int TriggerCtrAmount;
 * The amount used for counter-based triggerflags
 * Related:
 * TriggerFlags[TRIGFLAG_COUNTER_GE]
 * TriggerFlags[TRIGFLAG_COUNTER_LT]
 * TriggerFlags[TRIGFLAG_COUNTER_EAT]
 * TriggerFlags[TRIGFLAG_COUNTER_NOT_ONLY_TRIG_EAT]

int TrigSFX;
 * The SFX to play when the combo is triggered. If 0, no SFX will be played.

int TrigChange;
 * The amount the combo will change by when triggered.
 * Ex. '1' acts as '->Next', '-1' acts as '->Prev'.
 * If '0', no change occurs.
int TrigCSetChange;
 * The amount the cset will change by when triggered.

int TrigCooldown;
 * The combo's cooldown between triggers

int TrigCopycat;
 * If > 0, triggering this combo triggers all other combos with matching TrigCopycat.

int TrigExState;
 * If > -1, the ExState that the combo is linked to.
int TrigExDoorDir;
 * If > -1, the direction of ExDoor that the combo is linked to
int TrigExDoorIndex;
 * If 'TrigExDoorDir' is > -1, the index of that direction of ExDoor that the combo is linked to.

int TrigSpawnEnemy;
 * If > 0, the enemy ID spawned when the combo is triggered.
int TrigSpawnItem;
 * If > 0, the item ID (or dropset ID) spawned when the combo is triggered.
int TrigSpawnItemPickup;
 * The item pickup flags for the spawned item
 * Only the flags IP_HOLDUP, IP_TIMEOUT, IP_TRIGGERSECRETS, IP_ALWAYSGRAB are used.

int TrigLevelState;
 * The LevelState used for the `TRIGFLAG_TRIGLEVELSTATE` and `TRIGFLAG_LEVELSTATE`
 *     flags. 0-31, inclusive.
int TrigGlobalState;
 * The GlobalState used for the `TRIGFLAG_TRIGGLOBALSTATE` and `TRIGFLAG_GLOBALSTATE`
 *     flags. 0-255, inclusive.
int TrigGStateTimer;
 * If `> 0`,  the global trigger caused by `TRIGFLAG_GLOBALSTATE` will set to
 *     the 'on' state with this value as a timer in frames.
 * If this value is 0, it instead toggles the state as normal.

int TrigGroup;
 * The Trigger Group used for the `TRIGFLAG_TGROUP_CONTRIB`, `TRIGFLAG_TGROUP_LESS`, and `TRIGFLAG_TGROUP_GREATER` flags.
 * 0-255, inclusive.
int TrigGroupVal;
 * The value used for the `TRIGFLAG_TGROUP_LESS` and `TRIGFLAG_TGROUP_GREATER` flags.
 * 0-65535, inclusive.

int TrigLItems;
 * 'LI_' flags used by the `TRIGFLAG_LITEM_REQUIRE`,`TRIGFLAG_LITEM_INV_REQUIRE`,`TRIGFLAG_LITEM_SET`,`TRIGFLAG_LITEM_UNSET` flags.
int TrigDMapLvl;
 * The 'Level' used by 'TrigLItems'.
 * -1 represents the 'current level', otherwise a valid dmap level indicates that level.

int TrigTintR;
int TrigTintG;
int TrigTintB;
 * The R/G/B values to tint the palette by when triggered. -255 to 255.
 * If compat QR "Scripts use 6-bit color (0-63) instead of 8-bit (0-255)" is enabled,
   then it is -63 to 63.

int TrigLvlPal;
 * The level palette to change to when triggered. -1 for none.
int TrigBossPal;
 * The boss palette to change to when triggered. -1 for none.
int TrigQuakeTimer;
 * The quake timer to set when triggered. -1 for none.
int TrigWavyTimer;
 * The wavy timer to set when triggered. -1 for none.

int TrigSwordJinx;
 * The duration to Sword Jinx the player for. -2 for none, -1 for 'until cured', 0 to cure.
int TrigItemJinx;
 * The duration to Item Jinx the player for. -2 for none, -1 for 'until cured', 0 to cure.
int TrigShieldJinx;
 * The duration to Shield Jinx the player for. -2 for none, -1 for 'until cured', 0 to cure.
int TrigStun;
 * The duration to Stun the player for. -2 for none, -1 for 'until cured', 0 to cure.
int TrigBunny;
 * The duration to Bunny the player for. -2 for none, -1 for 'until cured', 0 to cure.

int TrigPushTime;
 * The duration that the combo must be pushed against for the 'Push->' trigger flag to take effect.

int TrigGenScript;
 * When triggered, this generic script will be run in the 'RunFrozen' mode.

int LiftGFXCombo;
 * The 'Other Combo GFX' field
int LiftGFXCSet;
 * The 'Other Combo GFX' field's CSet
int LiftGFXSprite;
 * The 'Sprite Data GFX' field

int LiftUnderCombo;
 * The combo that appears under the lifted combo
int LiftUnderCSet;
 * The cset that appears under the lifted combo

int LiftDamage;
 * The damage value of the lifted combo as an lweapon

int LiftLevel;
 * The required level of lift glove to lift this combo

int LiftItem;
 * The item (or dropset) dropped when lifting the combo

bool LiftFlags[7];
 * A set of flags related to lifting (use LF_ constants)

int LiftGFXType;
 * The type of GFX to use when lifting the combo.

int LiftSFX;
 * The SFX played when lifting.
 * If 0, uses the sfx set on the Lift Glove instead.

int LiftBreakSprite;
 * The sprite data index to display on the object breaking
int LiftBreakSFX;
 * The SFX to play when the object breaks

int LiftHeight;
 * The height above the player's head the object is held

int LiftTime;
 * The time, in frames, it takes to completely lift the combo.
 * This is also the duration of the player's Lifting animation
 *   when lifting this combo.

// t/b/a
//void GetLabel() / GetName()
//void SetLabel / SetName()
//combodata GetCombo(int label[])
//int Game->GetCombo(int name[])

	triggerflags[3]
	combodata->Attributes[] and Screen->GetComboAttribute(pos, indx) / SetComboAttribute(pos, indx)
	combodata->Flags and Screen->ComboFlags[pos] -- Maybe ComboMisc[pos] to avoid confusion?
	Combo QR rules will become ComboMisc[] ! 

	
/////////////////
///  npcdata  ///
/////////////////								// NPCData

/*
The npcdata datatype allows the user to load and manipulate Enemy Editor
data, and to r/w that information.

Like itemdata, this persists only until the quest exits.

To use npcdata, you must declare an npcdata typed pointer, then load a npc ID
to that pointer. 

npcdata nd = Game->LoadNPCData(1); // Load enemy ID 1 to the pointer 'nd'.

From here, you may access the member functions, and variables as normal:

nd->HP = 32;

*/

void GetName(int ptr[]);
 * Puts the text of the Enemy Name field into string 'ptr'.

int Family;
int Type;
 * The Family (Enemy Class) of the npc.

int Script; 
 * The npc action script used by this enemy.

untyped InitD[8];
 * The eight InitD args used by the npc action script for this enemy.

int WeaponScript;
 * The weapon action script assigned to this enemy.

untyped WeaponInitD[8];
 * The eight InitD args assigned to the weapon script used by this enemy.

int Tile;
 * The base tile used by the enemy.

int Flags, 
int Flags2, 

int Width;
 * The 'width' (W) of base tile used by the enemy.

int Height;
 * The 'height' (H) of base tile used by the enemy.

int STile;
 * The base 'special' tile used by the enemy.

int SWidth;
 * The 'width' (W) of base 'special' tile used by the enemy.

int SHeight;
 * The 'height' (H) of base 'special' tile used by the enemy.

int ExTile;
 * The base EXPANDED ('New') tile used by the enemy.

int ExWidth;
 * The 'width' (W) of base EXPANDED ('New') tile used by the enemy.

int ExHeight;
 * The 'height' (H) of base EXPANDED ('New') tile used by the enemy.

int HP;
 * The enemy's base hit points.

int Family;
 * The 'Type' of the enemy.

int CSet, 
 * Thge CSet used to render the enemy.

int Anim;
 * The 'O.Anim' used by the enemy.

int ExAnim;
 * The 'E.Anim' used by the enemy.

int Framerate;
 * The 'O.Anim' animation framerate used by the enemy.

int ExFramerate;
 * The 'E.Anim' animation framerate used by the enemy.

int TouchDamage;
 * The amount of contact damage that the enemy causes when it collides with Link.

int WeaponDamage;
 * The power of the weapons fired by the enemy.

int Weapon;
 * The weapon type used by the enemy.

int Random;
 * The 'random rate' of the enemy.

int Haltrate;
 * The 'turn frequency' used by the enemy during its movement phase.

int Step;
 * The enem's step speed.

int Homing;
 * The homing factor of the enemy. Greater values home more keenly on Link. 

int Hunger;
 * The 'hunger' value of the enemy. 
 * Higher values make it more likely that the enemy is attracted to Bait.
 * Valid only for NPCT_WALKING enemies.

int Dropset;
 * The dropset used by the enemy.

int BGSFX;
 * The Ambient sound that the enemy emits.

int DeathSFX;
 * The sound that is played when the enemy dies.

int HitSFX;
 * The sound that is played when the enemy is hit by an lweapon.

int DrawXOffset;
 * The horizontal draw offset of the enemy. 
 * Note: SizeFlag[??] must be enabled for this to function.
	
int DrawYOffset;
 * The vertical draw offset of the enemy. 
 * Note: SizeFlag[??] must be enabled for this to function.

int TotalDrawYOffset;
 * READ-ONLY
 * Calculates the total drawYOffset including special engine effects
 *     (such as switchhook with the 'rise' effect).
 * Does not include Z value in the calculation.
	
int DrawZOffset;
 * The depth draw offset of the enemy. 
 * Note: SizeFlag[??] must be enabled for this to function.
	
int HitXOffset;
 * The horizontal hitbox offset of the enemy. 
 * Note: SizeFlag[??] must be enabled for this to function.

int HitYOffset;
 * The vertical hitbox offset of the enemy. 
 * Note: SizeFlag[??] must be enabled for this to function.

int HitWidth;
 * The hitbox width (X component), in pixels, for the enemy.
 * Note: SizeFlag[??] must be enabled for this to function.

int HitHeight;
 * The hitbox height (Y component), in pixels, for the enemy. 
 * Note: SizeFlag[??] must be enabled for this to function.

int HitZHeight;
 * The hitbox height (Z component), in pixels, for the enemy. 
 * Note: SizeFlag[??] must be enabled for this to function.
	
int TileWidth;
 * The drawn width (X component) of the enemy in increments of one tile.
 * Note: SizeFlag[??] must be enabled for this to function.
	
int TileHeight;
 * The drawn height (Y component) of the enemy in increments of one tile.
 * Note: SizeFlag[??] must be enabled for this to function.
	
int WeaponSprite;
 * The sprite used to draw the enemy weapon.

 int WeaponSFX;
 * The sfx used when the enemy fires its weapon.

int Defense[42];
 * The defense categories for the enemy.

int SizeFlag[2];
 * A set of flags that determine if the values for the Enemy Editor 'Size' tab
 * 	are rendered by the engine.

int Attributes[32];
 * The 'Misc. Attributes' of the enemy; now 32 of these; and datatype-insensitive.

bool Shield[5];
 * The shield status of the enemy.
 * [0] through [3] correspond to DIR* constants (wherein DIR_UP represents FRONT, and DIR_DOWN represents BACK)
 * [4] corresponds to 'Shield can be broken'.

int FrozenTile;
 * The base tile used to draw the enemy, when the enemy is frozen solid. //Not yet implemented in-engine.

int FrozenCSet;
 * The CSet value used to render the enemy, when the enemy is frozen solid. //Not yet implemented in-engine.

int ShadowSprite;
 * The shadow sprite used by the enemy, 0-255
int SpawnSprite;
 * The spawn sprite used by the enemy, 0-255
int DeathSprite;
 * The death sprite used by the enemy, 0-255



////////////////////
///  spritedata  ///
////////////////////								// Spritedata

/*
The spritedata datatype allows the user to load and manipulate weapon sprite struct
data, and to r/w that information.

Like itemdata, this persists only until the quest exits.

To use spritedata, you must declare a spritedata typed pointer, then load a sprite ID
to that pointer. 

spritedata sd = Game->LoadSpriteData(1); // Load weapon sprite 1 to the pointer 'sd'.

From here, you may access the member functions, and variables as normal:

sd->Tile = 600;

*/

int ID;
 * The read-only ID of the sprite.

int Tile;
 * The tile used by the weapon sprite.

int CSet;
 * The CSet used by the sprite.
int FlashCSet;
 * The FlashCSet used by the sprite.

int Frames;
 * The number of frames in the animation cycle.

int Speed;
 * The speed of the animation cycle.

int Type;
 * The Misc Type.
 
bool Flags[5];
 * The flags of the sprite - 'SPRFL_' constants

/////////////////////
///  dropsetdata  ///
/////////////////////								// Dropsetdata

int Choose();
 * Returns a random item ID from the dropset
 * Returns -1 if 'nothing' is chosen.

int Items[10];
 * The item IDs stored in the dropset

int Chances[10];
 * The chances of each item stored in the dropset
 * These are not direct percentages, but weights.

int NothingChance;
 * The chance of nothing being dropped
 * This is not a percentage, but a weighted value

/* The following are planned, but yet to be implemented
	itemsprite Create(int x, int y);
	itemsprite Create(int x, int y, int z);
	 * Creates a random item from the dropset at the given coordinates
	 * Returns NULL if 'nothing' is chosen, as no item is created.

	void GetName(char[] buf);
	 * Loads the name of the dropset into the buffer

	void SetName(char[] buf);
	 * Sets the name of the dropset from the buffer
*/

  ________                    .__    .__                  ____      _________                        .___
 /  _____/___________  ______ |  |__ |__| ____   ______  /  _ \    /   _____/ ____  __ __  ____    __| _/
/   \  __\_  __ \__  \ \____ \|  |  \|  |/ ___\ /  ___/  >  _ </\  \_____  \ /  _ \|  |  \/    \  / __ | 
\    \_\  \  | \// __ \|  |_> >   Y  \  \  \___ \___ \  /  <_\ \/  /        (  <_> )  |  /   |  \/ /_/ | 
 \______  /__|  (____  /   __/|___|  /__|\___  >____  > \_____\ \ /_______  /\____/|____/|___|  /\____ | 
        \/           \/|__|        \/        \/     \/         \/         \/                  \/      \/ 
Commands for graphics, sound, text, and bitmap objects.

////////////////////
///  Graphics->  ///
////////////////////								// Graphics

int GetPixel(bitmap b, int x, int y);
 * Returns the palette index value for a pixel on a bitmap, at coordinates x, y on that bitmap.

int NumDraws;
 * Returns the number of script draws that have been executed during the current frame.
 
int MaxDraws();
 * Returns the maximum number of script draws per frame that you can execute in the current build.
 
void Monochrome(int mode);
 * Sets the entire display to monochrome output, using a hue mode that you may select, and either distributed,
 * or uniform colour distribution.
 * This respects the current DMap (level) palette, and it affects the entire main game palette. 

void MonochromeHue(int red, int green, int blue, bool distributed = true);
 * Sets the entire display to monochrome output, using either distributed using a uniform mode, or
 * a differential mode selected from `bool distributed`, using a hue based on the values that you supply
 * as `red`, `green`, and `blue`. 
 * This respects the current DMap (level) palette, and it affects the entire main game palette. 

void Tint(int red, int green, int blue);
 * Tints the entire display with a palette shift using the values that you supply as `red`, `green`, and `blue`.
 * This respects the current DMap (level) palette, and it affects the entire main game palette. 

void ClearTint();
 * Clears all tints, and monochrome/greyscale states back to the original game palette, and normalises it for
   the given DMap palette. 

void Wavy(bool wavyin); 
 * Creates a wavy visual effect, identical to 'Wavy' Warp effects.
 * There are two styles, 'WavyIn', and 'WavyOut'. Select from these using parameter 1. 

void Zap(bool zapin);
 * Creates a wavy visual effect, identical to 'Zap' Warp effects.
 * There are two styles, 'ZapIn', and 'ZapOut'. Select from these using parameter 1. 

void Greyscale(bool enable);
 * Converts the game to monochrome greyscale, or reverts from greyscale to colour.
 * This is useful for simulating 'Gameboy' style displays.
	
int IsBlankTile[214500];
 * Returns 1 is the tile supplied as an index is blank, 0 is it is not blank.
 * Returns -1 if the user passed an invalid tile ID to the index.
 * READ-ONLY

int Is8BitTile[214500];
 * Returns 1 is the tile supplied as an index is 8-bit, 0 is it is 4-bit.
 * Returns -1 if the user passed an invalid tile ID to the index.
 * READ-ONLY

int GetTilePixel(int tile, int x, int y, int cset = 0);
 * Returns the color index at an x,y coordinate of a tile.
 * If the tile isn't 8-bit, will return a color in the cset specified.

void SetTilePixel(int tile, int x, int y, int color);
 * Sets the color index an an x,y coordinate of a tile.
 * If writing an 8-bit color to a 4-bit tile, the cset bits will be discarded.
 * This is not considered a draw command and is not affected by deferred draw timing.
 * It will run instantly, before any draws for the frame.

paldata CreatePalData();
 * Creates a new empty paldata.

paldata CreatePalData(rgb color);
 * Creates a new paldata with all colors filled to the same rgb value.

rgb MixColor(rgb clr_start, rgb clr_end, float percent, int color_space = CSPACE_RGB);
 * Interpolates a color between clr_start and clr_end and then returns the resulting rgb.
 * The value of percent should range from 0-1, with 0 representing the starting color.
 * Color space specifies a color space to interpolate through, changing the resulting average.
 * See CSPACE_ constants in std_constants.zh

rgb CreateRGB(int r, int g, int b);
 * Returns an rgb based on the R/G/B values
 * Values range 0-255
 * If compat QR "Scripts use 6-bit color (0-63) instead of 8-bit (0-255)" is enabled,
   then it is 0-63

rgb CreateRGB(long hexcode);
 * Returns an rgb based on a long hexcode (0xRRGGBBL), where each color component ranges
   from 0 to FF (255).
 * When compat QR "Scripts use 6-bit color (0-63) instead of 8-bit (0-255)" is disabled,
   the RGB values are converted from 0-255 to 0-63

void ConvertRGBTo(float[] buf, rgb clr, int color_space)
 * Converts an rgb into another color space and copies the values into the buffer.
 * The buffer should be at least size 3 (or 4 for CMYK).

rgb ConvertRGBFrom(float[] buf, int color_space)
 * Converts the contents of the buffer from a color space back to rgb.
 * The buffer should be at least size 3 (or 4 for CMYK).

/////////////////
///  Audio->  ///
/////////////////								// Audio

int GetMusicPos();
 * Returns the current seek position of the currently playing enhanced music in seconds.
 * CURRENTLY ONLY SUPPORTS MP3 / OGG / IT / XM / S3M / MOD

void SetMusicPos(int new_pos);
 * Sets the play position for the currently playing enhanced music in seconds.
 * CURRENTLY ONLY SUPPORTS MP3 / OGG / IT / XM / S3M / MOD
 
void SetMusicSpeed(int newspeed);
 * Sets the playback speed of the currently playing enhanced music.
 * CURRENTLY ONLY SUPPORTS MP3 / OGG / IT / XM / S3M / MOD

void GetMusicLength();
 * Returns the length of the current playing enhanced music in seconds.
 * CURRENTLY ONLY SUPPORTS MP3 / OGG / IT / XM / S3M / MOD
 
void SetMusicLoop(float start, float end);
 * Loops the currently playing enhanced music between two timestamps in seconds.
 * CURRENTLY ONLY SUPPORTS MP3 / OGG / IT / XM / S3M / MOD

void PlaySound(int soundid);

 * Plays one of the quest's sound effects. Use the SFX_ constants in
 * std.zh as values of soundid.

	
void EndSound(int soundid);
 * If sfx_id is playing, calling this immediately stops that sound.

void PauseSound(int soundid);
 * If sfx_id is playing, calling this pauses it, halting it from playing, in
 * a manner that you may later resume it from the point at which it was paused.
 * See also: Audio->ResumeSound(int sfx_id) and Audio->ContinueSound(int sfx_id).

void ResumeSound(int soundid); 
 * Resumes a sound effect with an ID of sfx_id, that has been paused.

void ContinueSound(int soundid);
 * Resumes a sound effect with an ID of sfx_id, that has been paused.

void AdjustMusicVolume(int percent); 
 * Adjusts a multiplier for the volume of all MIDI, DIGI, and Enhanced Music.
 * The parameter 'int percent' is the percentage of its present volume.
 * Values range from 0 (mute) to 100 (the player's max volume setting).
 * If the quest rule "Old (Buggy) ZScript Volume Access" is on,
 * this will use deprecated behavior and may not function properly.

void AdjustSFXVolume(int percent);
 * Adjusts a multiplier for the volume of all Sound Effects (WAV).
 * The parameter 'int percent' is the percentage of its present volume.
 * Values range from 0 (mute) to 100 (the player's max volume setting).
 * If the quest rule "Old (Buggy) ZScript Volume Access" is on,
 * this will use deprecated behavior and may not function properly.

void PlaySoundEx(int id, int volume, int pan = 0, long freq = -1L, bool loop = false);
 * Play a sound with different properties.
 * Volume ranges from 0 (mute) to 100 (the player's max volume setting)
 * Pan ranges from -128 (left) to 127 (right)
 * If freq is <0, will use the sound's default frequency
 * If loop is true, the sound will repeat infinitely until played again
 * or terminated with EndSound()

void AdjustSound(int id, int volume, int pan = 0, long freq = -1L, bool loop = false);
 * Same as above, but does not restart the sound

float GetSoundCompletion(int id);
 * Returns a rough completion percentage (0-100) for how much of a sound has played.
 * Returns -1 if the sound is not currently playing. 

void PauseCurMIDI();
 * Pauses the current MIDI in a manner that permits resuming it.
 * Note: This does not affect Enhanced Music playback.
 * See also: Audio->ResumeCurMIDI().

void ResumeCurMIDI();
 * Resumes MIDI playback, if it has been paused.
 * Note: This does not affect Enhanced Music playback.
 * See also: Audio->PauseCurMIDI().

void PlayMIDI(int MIDIid);
	/**
	* Changes the current screen MIDI to MIDIid.
	* Will revert to the DMap (or screen) MIDI upon leaving the screen.
	*/ Example Use: !#!

bool PlayEnhancedMusic(int filename[], int track);
* Play the specified enhanced music if it's available. If the music
* cannot be played, the current music will continue. The music will
* revert to normal upon leaving the screen.
* Returns true if the music file was loaded successfully.
* The filename cannot be more than 255 characters. If the music format
* does not support multiple tracks, the track argument will be ignored.

 Example Use: 
	
		int music[]="myfile.mp3"; // Make a string with the filename of the music to play.
		if ( !Game->PlayEnhancedMusic(music, 1) ) Audio->PlayMIDI(midi_id);
		
		// Plays the enhanced music file 'myfle.mp3', track 1. 
		// If the file is mssing, the game will instead play 
		// the midi specified as midi_id.

void CrossfadeEnhancedMusic(int filename[], int track, int fadeoutframes, int fadeinframes, 
				int delayframes = 0, float startpos = 0);
 * Crossfade to the specified enhanced music if it's available. If the music
 * cannot be played, the current music will continue. The music will
 * revert to normal upon leaving the screen.
 * Returns true if the music file was loaded successfully.
 * The filename cannot be more than 255 characters. 
 * Currently only supports OGG, MP3, and some types of trackers.

int PanStyle;
 * Set or get the audio panning. See PAN_* constants in std_constants.zh for valid values.

int MusicRefresh;
 * Set or get how frequently the currently playing music should update to
 * the current DMap's music when warping.
 * Use with the following constants from std_constants.zh
 *   MR_SCREEN: Refresh on every screen transition (default behavior)
 *   MR_DMAP: Refresh on dmap change
 *   MR_LEVEL: Refresh on level change
 *   MR_NEVER: Never refresh on warps

bool MusicRefreshFlags[2];
 * A set of flags handling extra effects for MusicRefresh.
 *   MRF_NOCUT: Warp types that cut to silence, don't do that
 *   MRF_REVERT: Upon taking a warp that triggers refresh, revert to MR_SCREEN


////////////////
///  Text->  ///
////////////////								// Text

int FontHeight(int font);
int StringHeight(char32 ptr, int font);
int CharHeight(char32 chr, int font);
 * Returns the height, in pixels, of the given font.

int StringWidth(char32 ptr, int font);
 * Returns the width, in pixels, of the string pointed to by 'ptr', in the given font.
 * This is the width as DrawString() will draw it, so some special characters such as '\n' may not be fully accurate, as DrawString() does not draw these properly.

int CharWidth(char32 chr, int font);
 * Returns the width, in pixels, of the character 'chr', in the given font.
 * This is the width as DrawString() will draw it, so some special characters such as '\n' may not be fully accurate, as DrawString() does not draw these properly.

int MessageWidth(int msg);
 * Returns the width, in pixels, of the internal string at index 'msg'.
 * This uses the font and text as set in the 'Strings' editor, and ignores both trailing spaces and line breaks.

int MessageHeight(int msg);
 * Returns the height, in pixels, of the internal string at index 'msg'.
 * This uses the font as set in the 'Strings' editor, and ignores line breaks.


////////////////
///  bitmap  ///
////////////////								// Bitmap

void DrawPlane(int layer, bitmap src, int src_x, int src_y, int dest_x,
			int dest_y, int dest_w, int dest_h, int space_z, int horizon, 
			float scale_x = 1, float scale_y = 1, bool mask = true);
 * Draws a scaled 'Mode 7' style effect, line-by-line, where each raster is scaled down toward a horizon point.
 
int Width;
 * Returns the width of the bitmap, in pixels. 
 * READ-ONLY. Bitmaps cannot be resized by writing to this. 
 
int Height;
 * Returns the height of the bitmap, in pixels. 
 * READ-ONLY. Bitmaps cannot be resized by writing to this. 

void Free();
 * DEPRECATED: This no longer does anything - objects are freed automatically now.
 *             See "Object Memory Management" section
 * If the bitmap is allocated, frees the bitmap.
 *     This means that this bitmap ID is able to be returned by subsequent
 *     calls to 'Game->AllocateBitmap()' and such.
 * Note: The bitmap will remain allocated until script draws are next cleared.
 *       This generally occurs at the end of each frame, unless 'Game->Suspend[]'
 *       is used to prevent it.
 * Once the bitmap is freed, any image data on it is deleted.

void Own();
 * Requires an allocated bitmap.
 * Grants 'Ownership' of the bitmap to the currently running script.
 * [pre-3.0] When the script terminates (at the same time any Local Arrays in the script are cleared), the bitmap will be automatically freed.

bool isValid();
 * Returns true if the bitmap points to a valid bitmap
 * A bitmap is valid when it has been created, and can be written to
 * A bitmap returned from `Game->AllocateBitmap()` is NOT valid, until it is created.
 
bool isAllocated();
 * Returns true if the bitmap points to an allocated bitmap
 * A bitmap which has not been allocated should not be used, and should be allocated with `Game->AllocateBitmap()` or created with `Game->CreateBitmap()`
 * A bitmap which has been allocated, but is not valid, cannot be written to; however, it can be used with `bitmap->Create()` or `bitmap->Read()`
 
int GetPixel(int x, int y);
 * Returns the palette index value of a pixel on the current bitmap pointer.

void Create(int layer = 0, int width = 256, int height = 256);
 * Creates a bitmap on a bitmap pointer, with a size of height, width.
 * Destroys any existing bitmap on that pointer before creating a new one.
 * You can use this on an initialized bitmap pointer; either one allocated with 'Game->AllocateBitmap()', or a bitmap pointer that has a valid bitmap on it.
 * You can ALSO use this on an uninitialised pointer, and it will attempt to initialize it. The layer arg will be ignored when this is used on an uninitialised pointer.
 * Note: The 'layer' arg in this function is exclusively for ordering. This WILL NOT clear a specific 'layer' of a bitmap. Layers in ZC are only an expression of drawing order/sequence!
 
void Clear(int layer = 0);
 * Clears the bitmap to colour 0. 
 * Note: The 'layer' arg in this function is exclusively for ordering. This WILL NOT write out a specific 'layer' of a bitmap. Layers in ZC are only an expression of drawing order/sequence!
 
void ClearToColor(int layer, int color);
 * Clears the bitmap to the chosen color.
 * Note: The 'layer' arg in this function is exclusively for ordering. This WILL NOT write out a specific 'layer' of a bitmap. Layers in ZC are only an expression of drawing order/sequence!
 
void Read(int layer, char32[] filename);
 * Reads a valid graphic file into a bitmap pointer.
 * If used on an uninitialised pointer, it will first attempt to allocate it.
 *     If it fails to allocate the pointer, it will not attempt the read operation.
 * If the filename provided is invalid (e.g., the file is missing), the pointer
 * will be initialised with a blank bitmap at a size of 256x176.
 * If the quest rule "All bitmap-> and FileSystem-> paths relative to quest 'Files' folder" is on,
 *     then this will read a file relative to "[zc root]/Files/[quest name]/" instead of relative
 *     to "[zc root]".
 * Read() will fail if:
 *	The file is corrupt:
		PNG, JPEG, or other 'compressed' formats may abort if the file is corrupt.
 * 		Formats such as .BMP or .TGA may read up until missing data, as they are linear.
 * 	The file is missing.
 * 	The filename is incorrect. Remember that POSIX filesystems are Case-SenSitive. 
 
void Write(int layer, char32[] filename, bool allow_overwrite = false);
 * Writes a bitmap out as a graphic file.
 * This supports the following formats/extensions:
 *     .png, .gif, .pcx, .tgx, and .bmp. 
 * The provided filename string MUST include one of these extensions, as this
 *     both sets the output filetype, and validates the write.
 * Any other extension, or a lack of a valid extension will result in
 *     logging an error and failing to write the file.
 * Will not replace an existing file unless allow_overwrite is true.
 * Will fail on an uninitialised pointer.
 * Will create any missing directories on the path.
 * Note: The 'layer' arg in this function is exclusively for ordering. 
 *       This WILL NOT write out a specific 'layer' of a bitmap.
 *        Layers in ZC are only an expression of drawing order/sequence!
 * If the quest rule "All bitmap-> and FileSystem-> paths relative to quest 'Files' folder" is on,
 *     then this will write a file relative to "[zc root]/Files/[quest name]/" instead of relative
 *     to "[zc root]".
 * Remember that POSIX filesystems are Case-SenSitive. 

void WriteTile( int layer, int x, int y, int tile, bool is8bit = true, bool mask = false);
 * Writes a 16x16 area from (x,y) of the bitmap at layer 'layer' 
 *     TO the tile page, overwriting the tile 'tile', either 4 or 8 bit.
 * If 'mask' is true, overlays instead of overwrites

void MaskedDraw( int layer, bitmap mask, int color );
 * Draws 'color' to the bitmap, on any pixels that are non-color-0 on the mask.
 * The mask's `0,0` is overlayed at `0,0` of the destination.
void MaskedDraw( int layer, bitmap mask, int color, int maskColor );
 * Same as above, but instead of any non-0 pixels, pixels that match 'maskColor' are used
void MaskedDraw( int layer, bitmap mask, int color, int startMaskColor, int endMaskColor );
 * Same as above, but colors c such that 'startMaskColor <= c <= endMaskColor' will be used as the mask.

void MaskedBlit( int layer, bitmap mask, bitmap pattern, bool repeatPattern );
void MaskedBlit( int layer, bitmap mask, bitmap pattern, bool repeatPattern, int maskColor );
void MaskedBlit( int layer, bitmap mask, bitmap pattern, bool repeatPattern, int startMaskColor, int endMaskColor );
 * Same as 'MaskedDraw', but instead of drawing a color to the masked portions, draws from
 * a supplied 'pattern' bitmap.
 * If 'repeatPattern' is false, the pattern will be drawn at `0,0` with the width/height of the pattern bitmap, and nowhere else.
 * If 'repeatPattern' is true, the pattern will repeat in a tiled manner, starting from `0,0`, up to the width/height of the destination bitmap.
 * 'repeatPattern' does not affect the mask bitmap.

void Dither( int layer, bitmap mask, int color, int ditherType, int ditherArg )
 * Draws 'color' to the bitmap, using a dithering pattern, only on pixels that are
 * non-color-0 on the mask bitmap.
 * Use 'DITH_' constants from std_constants.zh for 'ditherType'.

void ReplaceColors( int layer, int color, int startCol, int endCol )
 * Replaces colors >= startCol and <= endCol with 'color'
 
void ShiftColors( int layer, int shift, int startCol, int endCol )
 * Adds 'shift' to colors >= startCol and <= endCol

int CountColor(bitmap mask, int x, int y, int checkColor, int maskColor = -1);
 * Checks the area of the bitmap specified by the mask for the specified 'checkColor', returning how many pixels match.
 * If 'maskColor' is '-1', any non-0 portion of the mask bitmap will be checked. Otherwise, only areas of the mask bitmap that match the maskColor will be checked.
 * The area checked is from `x,y` to `x+mask->Width,y+mask->Height`. If this goes out of bounds, the out of bounds area is ignored.
 * As this is not a drawing function, draws that occur this frame will *NOT* be read-only whatever was drawn to the bitmap at the end of the previous frame will (similar to GetPixel())

void Blit(int layer, bitmap target,
		int source_x, int source_y, int source_w, int source_h,
		int dest_x, int dest_y, int dest_w, int dest_h,
		float rotation = 0, int cx = 0, int cy = 0,
		int mode = 0, int lit = 0,  bool mask = true);
 * BLITS THE BITMAP ON POINTER 'b' TO A TARGET BITMAP.
 * As DrawBitmapEx(), except that it draws FROM an initialised bitmap pointer,
 * TO a target bitmap, which may be a user-created bitmap, or it may be the screen.
 * To draw to the screen, or to one of the old system bitmaps, use the RT_* value from std_constants.zh as the argument to 'bitmap target'.
 * To draw to a user created bitmap, pass its pointer to 'bitmap target'.
 * Blit supports multiple MODES, OR'd together as a bitmask:
 * ```
 * const int BITDX_NORMAL = 0;
 * const int BITDX_TRANS = 0x01; //Translucent
 * const int BITDX_PIVOT = 0x02; //THe sprite will rotate at a specific point, instead of its centre.
 * const int BITDX_HFLIP = 0x04; //Horizontal Flip
 * const int BITDX_VFLIP = 0x08; //Vertical Flip.
 * ```
 * You can also set a pivot point for the rotation, using 'int cx' and 'int cy'
 * If these are non-zero, the rotation anchor point will centre on these coordinates.
 * You may specify a colour to 'int lit' to use a lit mode. This tints the entire bitmap using that colour index of the main palette.


void BlitTo(int layer, bitmap source,
		int source_x, int source_y, int source_w, int source_h,
		int dest_x, int dest_y, int dest_w, int dest_h,
		float rotation = 0, int cx = 0, int cy = 0,
		int mode = 0, int lit = 0,  bool mask = true);
 * BLITS ANOTHER BITMAP TO THE POINTER 'b'.
 * As Blit(), except that it draws TO an initialised bitmap pointer,
 * FROM a source bitmap, which may be a user-created bitmap, or it may be the screen.
 * To draw to the screen, or to one of the old system bitmaps, use the RT_* value from std_constants.zh
 *	as the argument to 'bitmap source'.
 * To draw from a user created bitmap, pass its pointer to 'bitmap source.
 * BlitTo supports multiple MODES, OR'd together as a bitmask:
 * ```
 * const int BITDX_NORMAL = 0;
 * const int BITDX_TRANS = 0x01; //Translucent
 * const int BITDX_PIVOT = 0x02; //THe sprite will rotate at a specific point, instead of its centre.
 * const int BITDX_HFLIP = 0x04; //Horizontal Flip
 * const int BITDX_VFLIP = 0x08; //Vertical Flip.
 * ```
 * You can also set a pivot point for the rotation, using 'int cx' and 'int cy'
 * If these are non-zero, the rotation anchor point will centre on these coordinates.
 * You may specify a colour to 'int lit' to use a lit mode. This tints the entire bitmap using that colour index of the main palette. 

void Rectangle(int layer,
			int x, int y, int x2, int y2,
			int color, float scale = 1,
			int rx = 0, int ry = 0, int rangle = 0,
			bool fill = true, int opacity = OP_OPAQUE);
 * Identical to Screen->Rectangle(), but it draws to a target bitmap.

void Circle(int layer,
		int x, int y, int radius,
		int color, float scale = 1,
		int rx = 0, int ry = 0, int rangle = 0,
		bool fill = true, int opacity = OP_OPAQUE);
 * Identical to Screen->Circle(), but it draws to a target bitmap.

void Arc(int layer, 
		int x, int y, int radius, int startangle, int endangle, 
		int color, float scale = 1, 
		int rx = 0, int ry = 0, int rangle = 0, 
		bool closed = true, bool fill = true, int opacity = OP_OPAQUE);
 * Identical to Screen->Arc(), but it draws to a target bitmap.

void Ellipse(int layer, 
		int x, int y, int xradius, int yradius, 
		int color, float scale = 1,
		int rx = 0, int ry = 0, int rangle = 0,
		bool fill = true, int opacity = OP_OPAQUE);
 * Identical to Screen->Ellipse(), but it draws to a target bitmap.

void Line(int layer, int x, int y, int x2, int y2, 
		int color, float scale = 1,
		int rx = 0, int ry = 0, int rangle = 0,
		int opacity = OP_OPAQUE);
 * Identical to Screen->Line(), but it draws to a target bitmap.

void Spline(int layer, 
		int x1, int y1, int x2, int y2,
		int x3, int y3,int x4, int y4, 
		int color, int opacity = OP_OPAQUE);
 * Identical to Screen->Spline(), but it draws to a target bitmap.

void PutPixel(int layer, int x, int y, 
		int color, 
		int rx = 0, int ry = 0, int rangle = 0,
		int opacity = OP_OPAQUE);
 * Identical to Screen->PutPixel(), but it draws to a target bitmap.

void DrawCharacter(int layer, int x, int y, 
			int font, int color, int background_color, 
			int width, int height, int char, 
			int opacity = OP_OPAQUE);
 * Identical to Screen->DrawCharacter(), but it draws to a target bitmap.

void DrawInteger(int layer, int x, int y, 
			int font, int color, int background_color, 
			int width, int height, int number, int number_decimal_places = 0, 
			int opacity = OP_OPAQUE);
 * Identical to Screen->DrawInteger(), but it draws to a target bitmap.

void DrawTile(int layer, int x, int y,
		int tile, int blockw, int blockh,
		int cset, int xscale = -1, int yscale = -1,
		int rx = 0, int ry = 0, int rangle = 0,
		int flip = 0,
		bool transparency = true, int opacity = OP_OPAQUE);
 * Identical to Screen->DrawTile(), but it draws to a target bitmap.

void DrawTileCloaked(int layer, int x, int y,
		int tile, int blockw, int blockh,
		int flip = 0);
 * Identical to Screen->DrawTileCloaked(), but it draws to a target bitmap.

void DrawComboCloaked(int layer, int x, int y,
		int combo, int tilewidth, int tileheight,
		int flip = 0);
 * Identical to Screen->DrawComboCloaked(), but it draws to a target bitmap.

void DrawCombo(int layer, int x, int y,
		int combo, int w, int h,
		int cset, int xscale = -1, int yscale = -1,
		int rx = 0, int ry = 0, int rangle = 0,
		int flip = 0,
		bool transparency = true, int opacity = OP_OPAQUE);
 * Identical to Screen->DrawCombo(), but it draws to a target bitmap.

void DrawString(int layer, 
			int x, int y, 
			int font, int color, int background_color, int format, 
			char32[] str, 
			int opacity = OP_OPAQUE);
 * Identical to Screen->DrawString(), but it draws to a target bitmap.
 
void DrawString(int layer, 
			int x, int y, 
			int font, int color, int background_color, int format, 
			char32[] str, 
			int opacity,
			int shadow_type, int shadow_color);
 * Identical to Screen->DrawString(), but it draws to a target bitmap.

void DrawLayer(int layer, 
			int source_map, int source_screen, int source_layer, 
			int x, int y, float rotation = 0, int opacity = OP_OPAQUE);
 * Identical to Screen->DrawLayer(), but it draws to a target bitmap.
 
void DrawFrame(int layer,
			int x, int y, int tile, int cset,
			int width, int height, bool overlay = true,
			int opacity = OP_OPAQUE);
 * Identical to Screen->DrawFrame(), but it draws to a target bitmap.

void Quad( int layer, 
	int x1, int y1, int x2, int y2, 
	int x3, int y3, int x4, int y4,
	int w, int h, int cset, int flip, 
	int texture, int render_mode, bitmap render_source = NULL)
 * Identical to Screen->Quad(), but it draws to a target bitmap, and you can specify a bitmap as your texture.
 * Pass the bitmap pointer that you want to use to 'bitmap render_source'.
 * If you do not wish to use a bitmap as a texture, pass NULL to the arg 'bitmap render_source'.
 * Use PT_TEXTURE or a similar polytype, to render your bitmap as a texture.
 * For bitmap textures, specify the exact height and width of the texture as args 'w' and 'h'.
 * If rendering a bitmap as a texture, the 'h' and 'w' args need not be a power of 2. 
 * If `bitmap render_source` != NULL, then it will use this as the texture, instead of a tile or combo.
 * If the pointer supplied to render_source is invalid (contains no data), then this function will default to using a tile. 

void Triangle	( int layer, 
			int x1, int y1, int x2, 
			int y2, int x3, int y3,
			int w, int h, int cset, 
			int flip, int texture, 
			int render_mode, bitmap render_source);
			
 * Identical to Screen->Triangle(), but it draws to a target bitmap, and you can specify a bitmap as your texture.
 * Pass the bitmap pointer that you want to use to 'bitmap render_source'.
 * If you do not wish to use a bitmap as a texture, pass NULL to the arg 'bitmap render_source'.
 * Use PT_TEXTURE or a similar polytype, to render your bitmap as a texture. 
 * For bitmap textures, specify the exact height and width of the texture as args 'w' and 'h'.
 * If rendering a bitmap as a texture, the 'h' and 'w' args need not be a power of 2. 
 * If `bitmap render_source` != NULL, then it will use this as the texture, instead of a tile or combo.
 * If the pointer supplied to render_source is invalid (contains no data), then this function will default to using a tile. 

void Quad3D( int layer, 
			int pos[12], int uv[8], int cset[4], int size[2], 
			int flip, int texture, int polytype, bitmap render_source );
 * Identical to Screen->Quad(), but it draws to a target bitmap, and you can specify a bitmap as your texture.
 * Pass the bitmap pointer that you want to use to 'bitmap render_source'.
 * If you do not wish to use a bitmap as a texture, pass NULL to the arg 'bitmap render_source'.
 * Use PT_TEXTURE or a similar polytype, to render your bitmap as a texture. 
 * For bitmap textures, specify the exact height and width of the texture as args 'w' and 'h'.
 * If rendering a bitmap as a texture, the 'h' and 'w' args need not be a power of 2. 
 * If `bitmap render_source` != NULL, then it will use this as the texture, instead of a tile or combo.
 * If the pointer supplied to render_source is invalid (contains no data), then this function will default to using a tile.

void Triangle3D( int layer, 
			int pos[9], int uv[6], int csets[3], int size[2], 
			int flip, int tile, int polytype, bitmap render_source);
			
 * Identical to Screen->Triangle(), but it draws to a target bitmap, and you can specify a bitmap as your texture.
 * Pass the bitmap pointer that you want to use to 'bitmap render_source'.
 * If you do not wish to use a bitmap as a texture, pass NULL to the arg 'bitmap render_source'.
 * Use PT_TEXTURE or a similar polytype, to render your bitmap as a texture. 
 * For bitmap textures, specify the exact height and width of the texture as args 'w' and 'h'.
 * If rendering a bitmap as a texture, the 'h' and 'w' args need not be a power of 2. 
 * If `bitmap render_source` != NULL, then it will use this as the texture, instead of a tile or combo.
 * If the pointer supplied to render_source is invalid (contains no data), then
 * this function will default to using a tile.

void FastTile(int layer, int x, int y, 
		int tile, int cset, 
		int opacity = OP_OPAQUE);
 * Identical to Screen->FastTile(), but it draws to a target bitmap.

void FastCombo(int layer, int x, int y, 
		int combo, int cset, 
		int opacity = OP_OPAQUE);
 * Identical to Screen->FastCombo(), but it draws to a target bitmap.

void Polygon(int layer, int num_points, int vertices[], int colour, int opacity = OP_OPAQUE);
	ZASM: POLYGON
 * Draws a polygon to the bitmap, with a number of points specified as int points,
 * with vertices supplied as an array. 
 
 
void DrawScreen	(int layer, 
			int map, int source_screen, 
			int x, int y, float rotation = 0);
			
 * Draws an entire screen from screen on map on the specified layer of the bitmap at (x,y).
 * If rotation is not zero, it(the entire screen) will rotate about its center.

void DrawScreenSolid	(int layer, 
			int map, int source_screen, 
			int x, int y, float rotation = 0);
			
 * Draws the solidity mask entire screen from screen on map on the specified layer of the bitmap at (x,y) in colour index 1.
 * If rotation is not zero, it(the entire screen) will rotate about its center.

void DrawScreenSolidity	(int layer, 
			int map, int source_screen, 
			int x, int y, float rotation = 0);
			
 * Draws the solidity value for each combo position of an entire screen from screen on map on 
 * the specified layer of the bitmap at (x,y).
 * Each combo position will be drawn in the palette index equal to its value as ComboS[].
 * If rotation is not zero, it(the entire screen) will rotate about its center.
 
void DrawScreenComboTypes	(int layer, 
			int map, int source_screen, 
			int x, int y, float rotation = 0);
			
 * Draws the combo type value for each combo position of an entire screen from screen on map on 
 * the specified layer of the bitmap at (x,y).
 * Each combo position will be drawn in the palette index equal to its value as ComboT[].
 * If rotation is not zero, it(the entire screen) will rotate about its center.

void DrawScreenComboFlags	(int layer, 
			int map, int source_screen, 
			int x, int y, float rotation = 0);
			
 * Draws the combo flag value for each combo position of an entire screen from screen on map on 
 * the specified layer of the bitmap at (x,y).
 * Each combo position will be drawn in the palette index equal to its value as ComboF[].
 * If rotation is not zero, it(the entire screen) will rotate about its center.

void DrawScreenComboIFlags	(int layer, 
			int map, int source_screen, 
			int x, int y, float rotation = 0);
			
 * Draws the combo inh.flag value for each combo position of an entire screen from screen on map on 
 * the specified layer of the bitmap at (x,y).
 * Each combo position will be drawn in the palette index equal to its value as ComboI[].
 * If rotation is not zero, it(the entire screen) will rotate about its center.


	
// Destroy()
// All screen drawing instructions.
// Resize?
// int Depth (read-only)
// Transform() 
// RenderTo(target, mode, args[])
// RenderFrom(target, mode, args[])


/////////////////////
///  genericdata  ///
///////////////////// genericdata

bool RunFrozen();
 * Attempts to run the given generic script in frozen mode.
 * Returns true if successful, false otherwise.

bool Running;
 * Reads as whether or not the script is currently running passively
 * If written to false, kills the script
 * If written to true, launches (or restarts) the script

bool ExitState[GENSCR_NUMST];
 * An array of exit states. Each exit state, if true, specifies a condition for the script
 *     to stop running passively. Use the 'GENSCR_ST_' constants from 'std_constants.zh'.
 * All states default to 'false'

bool ReloadState[GENSCR_NUMST];
 * An array of reload states. Each reload state, if true, specifies a condition for the script
 *     to exit and relaunch if running. Use the 'GENSCR_ST_' constants from 'std_constants.zh'.
 * All states default to 'false'
 * GENSCR_ST_RELOAD: Exits/Reloads upon exiting to the save select screen.
 * GENSCR_ST_CONTINUE: Exits/Reloads upon 'F6->Continue' or similar.
 * GENSCR_ST_CHANGE_SCREEN: Exits/Reloads upon loading a new screen
 * GENSCR_ST_CHANGE_DMAP: Exits/Reloads upon loading a new dmap
 * GENSCR_ST_CHANGE_LEVEL: Exits/Reloads upon loading a new dmap level

bool EventListen[GENSCR_NUMEVENT];
 * An array of event listen states. Each state, if true, specifies an event that 'WaitEvent()'
 *     will respond to for this script.
 * All states default to 'false'
 * GENSCR_EVENT_NIL:            N/A (error value)
 * GENSCR_EVENT_INIT:           When loading in from a save/new quest
 * GENSCR_EVENT_CONTINUE:       When F6->Continue
 * GENSCR_EVENT_FFC_PRELOAD:    When FFCs run 'on screen init'
 * GENSCR_EVENT_CHANGE_SCREEN:  When the screen changes (before opening wipe)
 * GENSCR_EVENT_CHANGE_DMAP:    When the dmap changes
 * GENSCR_EVENT_CHANGE_LEVEL:   When the level changes

int DataSize;
 * Represents the size of the 'Data[]' array.
 * Read/Write, result saves to the save file.
 * If written larger than current size, 'new' space will be zeroed out.
 * Default 0, range 0-214748.

untyped Data[DataSize];
 * An array of variable size, settable in 'DataSize' above.
 * This data is saved to the save file.
 * Attempting to access any index '>= DataSize' results in an error.

untyped InitD[8];
 * Access to the InitD[] for this script slot
 * This is shared by the passive and frozen modes


///////////////
//  paldata  //
/////////////// paldata

rgb Color[256]; 
 * Access the color values of the paldata.
 * Will return INVALID_COLOR if the color is invalid.

int R[256];
int G[256];
int B[256];
 * Access the R/G/B values of the paldata.
 * Will return -1 if the color is invalid.

void ClearColor(int index);
 * Clears the color at index on the paldata 
 * Cleared colors will be skipped when writing to a palette.

void ClearCSet(int index);
 * Clears a cset on the paldata 
 * Cleared colors will be skipped when writing to a palette.

bool ColorValid(int index);
 * Returns true if the color at index is valid.

void LoadLevelPalette(int pal);
 * Loads a level's palette to the paldata.
 * CSets will be arranged as they appear on the main palette, so CSet 2 starts at index 0x20, ect.

void LoadSpritePalette(int pal);
 * Loads a page of sprite palettes to the paldata.
 * Currently only values of 0 and 1 are valid. 

void LoadMainPalette();
 * Loads the main palette to the paldata.
 * Will load colors that have been changed by Tint() and Greyscale()

void LoadCyclePalette(int pal);
 * Loads a level's cycle/dark room palette to the paldata.
 * CSets will be arranged as they appear in the level palette editor so the first four csets
 *     will be left blank.

void LoadBitmapPalette(char32[] path);
 * Loads the palette from an image.
 * Currently only BMP, PCX, and TGA are supported.

void WriteLevelPalette(int pal);
 * Writes the paldata to a level palette. 
 * Empty color indices will be skipped.

void WriteLevelCSet(int pal, int cset);
 * Writes a cset of the paldata to a level palette.
 * Empty color indices will be skipped.

void WriteSpritePalette(int page);
 * Writes the paldata to a sprite palette page.
 * Empty color indices will be skipped. 
 * This will copy over the whole page at once.

void WriteSpriteCSet(int page, int cset);
 * Writes a cset of the paldata to a sprite palette page.
 * Empty color indices will be skipped.

void WriteMainPalette();
 * Writes the paldata to the main palette.
 * Empty color indices will be skipped. 

void WriteMainCSet(int cset);
 * Writes a cset of the paldata to the main palette.
 * Empty color indices will be skipped. 

void WriteCyclePalette(int pal);
 * Writes the paldata to a level's cycle/dark room palette. 
 * Empty color indices will be skipped.

void WriteCycleCSet(int pal, int cset);
 * Writes a cset of the paldata to a level's cycle/dark room palette.
 * Empty color indices will be skipped.

void Mix(paldata start, paldata end, float percent = 0.5, int color_space = CSPACE_RGB);
 * Interpolates all the colors on a paldata between start and end.
 * The value of percent should range from 0-1, with 0 representing the starting color.
 * Color space specifies a color space to interpolate through, changing the resulting average.
 * See CSPACE_ constants in std_constants.zh

void MixCSet(paldata start, paldata end, int cset, float percent = 0.5, int color_space = CSPACE_RGB);
 * Interpolates all the colors in a cset on a paldata between start and end.
 * The value of percent should range from 0-1, with 0 representing the starting color.
 * Color space specifies a color space to interpolate through, changing the resulting average.
 * See CSPACE_ constants in std_constants.zh

void Copy(paldata target);
 * Copies all the colors from this paldata to the target. 

void CopyCSet(paldata target, int src_cset, int dest_cset);
 * Copies all the colors from one cset on this paldata to another on the target. 

void Free();
 * DEPRECATED: This no longer does anything - objects are freed automatically now.
 *             See "Object Memory Management" section
 * This will deallocate the paldata pointer, so that the pointer ID may be re-used.
 * There is a limit to how many paldata pointers may be allocated at once,
 *     so be sure to free them when you are no longer using them.

void Own();
 * Grants 'Ownership' of the pointer to the currently running script.
 * [pre-3.0] When the script terminates (at the same time any Local Arrays in the script
 *     are cleared), the pointer will be automatically freed.
 * See "Object Memory Management" section

/////////////////////
//  subscreendata  //
///////////////////// subscreendata

//For any subscreen type:

int CurPage;
 * The currently selected page.

int NumPages;
 * The total number of pages

subscreenpage Pages[];
 * Read-only. The array containing the pages

int Type;
 * Read-only. Compare with the 'SSTYPE_' constants.
 * The type of the subscreen.

bool Flags[];
 * The flags of the subscreen. Use the 'SSFL_*_' constants to access.

void GetName(char32[] buf);
 * Puts the subscreen's name in the buffer.
 * If the buffer is too small, resizes it for you!

void SetName(char32[] buf);
 * Sets the subscreen's name from the buffer.

//
// Only on the CURRENTLY OPEN ACTIVE SUBSCREEN:
//
int TransClock;
 * The timer clock used by the currently active transition.
 * '-1' indicates no transition. Writing to '-1' clears the current transition.
 * Writing a positive value starts a transition if none is currently active.
int TransType;
 * The transition type currently active.
 * Compare with the 'TRANS_TY_' constants.
bool TransFlags[];
 * The flags for the current transition.
 * Use the 'TRANSFLAG_' constants to access these.
int TransArgs[];
 * The arguments used for the current transition.
 * Use the 'TRANS_*_ARG_' constants to access these
int TransFromPage;
int TransToPage;
 * The page the currently active transition is going from/to.

//
// Only on ACTIVE subscreens:
//

void SwapPages(int index1, int index2);
 * Swaps the pages at the two indexes.

int CursorPos;
 * The position value of the selector.

int Script;
 * The subscreen's script.
untyped InitD[8];
 * The subscreen's InitD[] parameters

bool BtnPageLeft[8];
 * Use the 'INTBTN_' constants to index this array.
 * The 'true' buttons here, when pressed, change pages leftwards.
bool BtnPageRight[8];
 * Use the 'INTBTN_' constants to index this array.
 * The 'true' buttons here, when pressed, change pages rightwards.



int TransLeftType;
int TransRightType;
 * The transition type for left/right transitions.
 * Compare with the 'TRANS_TY_' constants.

int TransLeftSFX;
int TransRightSFX;
 * The transition sfx for left/right transitions.

bool TransLeftFlags[];
bool TransRightFlags[];
 * The flags for left/right transitions.
 * Use the 'TRANSFLAG_' constants to access these.

int TransLeftArgs[];
int TransRightArgs[];
 * The arguments used for left/right transitions.
 * Use the 'TRANS_*_ARG_' constants to access these


int SelectorDestX;
int SelectorDestY;
int SelectorDestW;
int SelectorDestH;
 * The X/Y/W/H offsets for the selector on this subscreen, if the selector is overridden (see `Flags[]`).
 * These values will be ADDED to the x/y/w/h that the selector would normally draw to.

int SelectorWid[2];
int SelectorHei[2];
int SelectorTile[2];
int SelectorCSet[2];
int SelectorFlashCSet[2];
int SelectorFrames[2];
int SelectorASpeed[2];
int SelectorDelay[2];
 * The pixel-size, tile, cset/flashcset, and animation information for the two selector overrides.
 * These will be used by the selector on this subscreen, if the selector is overridden (see `Flags[]`).

/////////////////////
//  subscreenpage  //
///////////////////// subscreenpage

int Index;
 * Read-only. The index of this page within the subscreen.

int NumWidgets;
 * Read-only. The number of widgets on the page.

subscreenwidget Widgets[];
 * Read-only. The widgets on the page, ordered by their index.

subscreenwidget GetWidget(char32[] label);
 * Returns the first widget with a matching label, or NULL if none exists.

subscreendata SubData;
 * Read-only. The subscreendata that owns this page.

subscreenwidget CreateWidget(int type);
 * Adds a new widget of the specified type to the end of the page.
 * Returns that widget, or NULL if fails.

void SwapWidgets(int index1, int index2);
 * Swaps the widgets at the two indexes.

int SelectorMove(int cursor_pos, int dir, int flags)
 * Returns the new cursor position found by moving in 'dir' from 'cursor_pos'.
 * 'flags' determines:
 *   - SUBSEL_FLAG_NO_NONEQUIP: Skip widgets that are "Non-equippable"
 *   - SUBSEL_FLAG_NEED_ITEM: Skip widgets that currently have no equippable item

void Delete();
 * Deletes the page.
 * If it is the last page, an empty page will be created in its' place.

//
// Only on ACTIVE subscreens:
//

int CursorPos;
 * The position value of the selector.

subscreenwidget FindWidget(int cursor_pos);
 * Returns the widget designated by the specified cursor position,
 *     or NULL if it fails.

///////////////////////
//  subscreenwidget  //
/////////////////////// subscreenwidget

int Type;
 * Read-only. The widget's type, using 'SUBWIDG_' constants.

int Index;
 * Read-only. The index of this widget within the page.

int DisplayItem;
int EquipItem;
 * Read-only. The display/equip item ID for the widget.
 * Reads as -1 if no item exists, the widget is of a type that has no item, etc

subscreenpage Page;
 * Read-only. The page this widget is within.

bool VisibleFlags[];
 * Flags related to the visibility of the widget.
 * Use the 'SUBVISIB_' constants to access.

int X;
int Y;
 * The X/Y position of the widget within the subscreen.
 * Some types ignore these values.

int W;
int H;
 * The width/height of the widget within the subscreen.
 * This is USUALLY in pixels, but some types use different values!
 * ex. for 2x2 frame, this is in minitiles, so 8 times less than pixels.
 * Some types ignore these values altogether.

int DispX;
int DispY;
int DispW;
int DispH;
 * Read-Only. Gets the 'display' x/y/width/height, in pixels.
 * The rectangle represented by this is the same as the bounding box
 *     shown in the subscreen editor in ZQ.

bool GenFlags[];
 * The general flags for subscreen widgets.
 * These are usually applicable regardless of widget type.
 * Use the 'SUBW_GENFL_' constants to access.

bool Flags[];
 * The type-specific flags for subscreen widgets.
 * There is a different set of constants for this for each widget type.

//Selectable widget stuff
int Pos;
 * The selector position of this flag.
 * Only used if the widget is selectable (see 'GenFlags[]').

int PosDirs[4];
 * The 4 directional positions for the selector.
 * Use the 'DIR_' constants to index.
 * Only used if the widget is selectable (see 'GenFlags[]').

void GetSelTextOverride(char32[] buf);
 * Gets the selected text override for this widget.
 * If the buffer provided is too small, it will *automatically be resized to fit*.
void SetSelTextOverride(char32[] str);
 * Sets the selected text override for this widget.
 * A blank string represents no override.

void GetLabel(char32[] buf);
 * Gets the label for this widget.
 * If the buffer provided is too small, it will *automatically be resized to fit*.
void SetLabel(char32[] str);
 * Sets the label for this widget.

//Selector override stuff
int SelectorDestX;
int SelectorDestY;
int SelectorDestW;
int SelectorDestH;
 * The X/Y/W/H offsets for the selector on this widget,
 *     if the selector is overridden (see 'GenFlags[]').
 * These values will REPLACE the x/y/w/h that the
 *     selector would normally draw to.

int SelectorWid[2];
int SelectorHei[2];
int SelectorTile[2];
int SelectorCSet[2];
int SelectorFlashCSet[2];
int SelectorFrames[2];
int SelectorASpeed[2];
int SelectorDelay[2];
 * The pixel-size, tile, cset/flashcset, and animation information for the two selector overrides.
 * These will be used by the selector on this widget,
 *     if the selector is overridden (see 'GenFlags[]').

//Press Script stuff
int PressScript;
 * The generic script that will run when a specified button
 *     is pressed while this widget is selected.

untyped PressInitD[8];
 * The 8 InitD[] args for the PressScript

bool BtnPressScript[8];
 * Use the 'INTBTN_' constants to index this array.
 * The 'true' buttons here, when pressed while this
 *     widget is selected, run the press script.

//Press PageChange Stuff

bool BtnPageChange[8];
 * Use the 'INTBTN_' constants to index this array.
 * The 'true' buttons here, when pressed while this
 *     widget is selected, change the current page
 *     based on the PageMode.

int PageMode;
 * The type of page change that will occur when a specified
 *     button is pressed while this widget is selected.
 * Use the 'SUB_PGMODE_' constants for this value.

int TargetPage;
 * The page to change to when using PageMode of 'SUB_PGMODE_TARG'

//Transition info
int PageTransType;
 * The transition type for the PageMode transition.
 * Compare with the 'TRANS_TY_' constants.

int PageTransSFX;
 * The transition sfx for the PageMode transition.

bool PageTransFlags[];
 * The flags for the PageMode transition.
 * Use the 'TRANSFLAG_' constants to access these.

int PageTransArgs[];
 * The arguments used for the PageMode transition.
 * Use the 'TRANS_*_ARG_' constants to access these

//
// TYPE SPECIFIC
// The following are only available for
//     some widget types, as listed.
//

int Tile[];
 * The widget's tile(s).
 * For SUBWIDG_MINITILE, can use the 'SUB_SPTILE_' constant values.
 * VALID WIDGETS:
 *
 *  SUBWIDG_FRAME[1], SUBWIDG_MCGUFF[1], SUBWIDG_TILEBLOCK[1], SUBWIDG_MINITILE[1], SUBWIDG_MISCGAUGE[4], SUBWIDG_LGAUGE[4], SUBWIDG_MGAUGE[4]

int CSet[];
 * The widget's cset(s).
 * For SUBWIDG_FRAME,SUBWIDG_MCGUFF,SUBWIDG_TILEBLOCK,SUBWIDG_MINITILE: can use the 'SUB_CS_' constants.
 * VALID WIDGETS:
 *
 *  SUBWIDG_FRAME[1], SUBWIDG_MCGUFF[1], SUBWIDG_TILEBLOCK[1], SUBWIDG_MINITILE[1], SUBWIDG_MISCGAUGE[4], SUBWIDG_LGAUGE[4], SUBWIDG_MGAUGE[4]

int Flip;
 * The widget's flip value.
 * VALID WIDGETS:
 *
 *  SUBWIDG_MCGUFF, SUBWIDG_TILEBLOCK, SUBWIDG_MINITILE

int Font;
 * The widget's Font, use the 'FONT_' constants.
 * VALID WIDGETS:
 *
 *  SUBWIDG_TEXT, SUBWIDG_TEXTBOX, SUBWIDG_TIME, SUBWIDG_COUNTER, SUBWIDG_OLDCTR, SUBWIDG_BTNCOUNTER, SUBWIDG_MMAPTITLE, SUBWIDG_SELECTEDTEXT

int Align;
 * The widget's Alignment, use the 'TF_' constants.
 * VALID WIDGETS:
 *
 *  SUBWIDG_TEXT, SUBWIDG_TEXTBOX, SUBWIDG_TIME, SUBWIDG_COUNTER, SUBWIDG_BTNCOUNTER, SUBWIDG_MMAPTITLE, SUBWIDG_SELECTEDTEXT

int ShadowType;
 * The widget's Shadow Type, use the 'SHD_' constants.
 * VALID WIDGETS:
 *
 *  SUBWIDG_TEXT, SUBWIDG_TEXTBOX, SUBWIDG_TIME, SUBWIDG_COUNTER, SUBWIDG_OLDCTR, SUBWIDG_BTNCOUNTER, SUBWIDG_MMAPTITLE, SUBWIDG_SELECTEDTEXT

void GetText(char32[] buf);
void SetText(char32[] str);
 * Gets/Sets the text for this widget.
 * If the buffer provided for GetText() is too small,
 *     it will *automatically be resized to fit*.
 * VALID WIDGETS:
 *
 * SUBWIDG_TEXT, SUBWIDG_TEXTBOX

int ColorText;
 * The widget's color index used for Text
 * VALID WIDGETS:
 *
 *  SUBWIDG_TEXT, SUBWIDG_TEXTBOX, SUBWIDG_TIME, SUBWIDG_COUNTER, SUBWIDG_OLDCTR, SUBWIDG_BTNCOUNTER, SUBWIDG_MMAPTITLE, SUBWIDG_SELECTEDTEXT, SUBWIDG_MCGUFF_FRAME

int ColorShadow;
 * The widget's color index used for Shadows
 * VALID WIDGETS:
 *
 *  SUBWIDG_TEXT, SUBWIDG_TEXTBOX, SUBWIDG_TIME, SUBWIDG_COUNTER, SUBWIDG_OLDCTR, SUBWIDG_BTNCOUNTER, SUBWIDG_MMAPTITLE, SUBWIDG_SELECTEDTEXT

int ColorBG;
 * The widget's color index used for background
 * VALID WIDGETS:
 *
 *  SUBWIDG_TEXT, SUBWIDG_TEXTBOX, SUBWIDG_TIME, SUBWIDG_COUNTER, SUBWIDG_OLDCTR, SUBWIDG_BTNCOUNTER, SUBWIDG_MMAPTITLE, SUBWIDG_SELECTEDTEXT, SUBWIDG_BGCOLOR

int ColorOutline;
 * The widget's color index used for outline
 * VALID WIDGETS:
 *
 *  SUBWIDG_LINE, SUBWIDG_RECT, SUBWIDG_MCGUFF_FRAME

int ColorFill;
 * The widget's color index used for fill
 * VALID WIDGETS:
 *
 *  SUBWIDG_RECT

int ColorPlayer;
 * The widget's color index used to indicate the player
 * VALID WIDGETS:
 *
 *  SUBWIDG_MMAP, SUBWIDG_LMAP

int ColorCompassBlink;
 * The widget's color index used to indicate the blinking compass
 * VALID WIDGETS:
 *
 *  SUBWIDG_MMAP

int ColorCompassOff;
 * The widget's color index used to indicate the off compass
 * VALID WIDGETS:
 *
 *  SUBWIDG_MMAP

int ColorRoom;
 * The widget's color index used to indicate rooms
 * VALID WIDGETS:
 *
 *  SUBWIDG_LMAP

int Button;
 * The item button associated with the widget.
 * Use the 'ITMBTN_' constants for this value.
 * VALID WIDGETS:
 *
 *  SUBWIDG_BTNITM, SUBWIDG_BTNCOUNTER

int Counter[];
 * The counter(s) associated with the widget.
 * Use the 'CR_' constants for the values.
 * VALID WIDGETS:
 *
 *  SUBWIDG_COUNTER[3], SUBWIDG_MISCGAUGE[1]

int MinDigits;
 * The minimum digits of the widget.
 * VALID WIDGETS:
 *
 *  SUBWIDG_COUNTER, SUBWIDG_OLDCTR, SUBWIDG_BTNCOUNTER

int MaxDigits;
 * The maximum digits of the widget.
 * VALID WIDGETS:
 *
 *  SUBWIDG_COUNTER, SUBWIDG_BTNCOUNTER

int InfiniteItem;
 * The infinite item of the widget.
 * VALID WIDGETS:
 *
 *  SUBWIDG_COUNTER, SUBWIDG_OLDCTR, SUBWIDG_LGAUGE, SUBWIDG_MGAUGE, SUBWIDG_MISCGAUGE

char32 InfiniteChar;
 * The infinite character of the widget.
 * VALID WIDGETS:
 *
 *  SUBWIDG_COUNTER, SUBWIDG_OLDCTR, SUBWIDG_BTNCOUNTER

int CostIndex;
 * The index of cost to use for this widget
 * VALID WIDGETS:
 *
 *  SUBWIDG_BTNCOUNTER

int ItemClass;
 * The itemclass used by the widget (0 <= ItemClass < IC_MAXUSABLE)
 * VALID WIDGETS:
 *
 *  SUBWIDG_ITEMSLOT

int ItemID;
 * The item ID used by the widget (-1 <= ItemID < NUM_ITEMDATA)
 * VALID WIDGETS:
 *
 *  SUBWIDG_ITEMSLOT

int FrameTile;
int PieceTile;
int FrameCSet;
int PieceCSet;
 * The frame/piece tile/cset used by the widget.
 * VALID WIDGETS:
 *
 *  SUBWIDG_MCGUFF_FRAME

int Number;
 * The number associated with the widget.
 * VALID WIDGETS:
 *
 *  SUBWIDG_MCGUFF

int Corner[];
 * The corner(s) associated with the widget.
 * VALID WIDGETS:
 *
 *  SUBWIDG_MINITILE[1], SUBWIDG_LGAUGE[4], SUBWIDG_MGAUGE[4], SUBWIDG_MISCGAUGE[4]

int Frames;
 * The widget's frames
 * VALID WIDGETS:
 *
 *  SUBWIDG_LGAUGE, SUBWIDG_MGAUGE, SUBWIDG_MISCGAUGE

int Speed;
 * The widget's speed
 * VALID WIDGETS:
 *
 *  SUBWIDG_LGAUGE, SUBWIDG_MGAUGE, SUBWIDG_MISCGAUGE

int Delay;
 * The widget's delay
 * VALID WIDGETS:
 *
 *  SUBWIDG_LGAUGE, SUBWIDG_MGAUGE, SUBWIDG_MISCGAUGE

int Container;
 * The widget's container number
 * VALID WIDGETS:
 *
 *  SUBWIDG_LGAUGE, SUBWIDG_MGAUGE, SUBWIDG_MISCGAUGE

int GaugeWid;
int GaugeHei;
 * The widget's gauge width/height
 * VALID WIDGETS:
 *
 *  SUBWIDG_LGAUGE, SUBWIDG_MGAUGE, SUBWIDG_MISCGAUGE

int Units;
 * The widgets unit value
 * VALID WIDGETS:
 *
 *  SUBWIDG_LGAUGE, SUBWIDG_MGAUGE, SUBWIDG_MISCGAUGE
 
int HSpace;
int VSpace;
 * The widget's hspace/vspace
 * VALID WIDGETS:
 *
 *  SUBWIDG_LGAUGE, SUBWIDG_MGAUGE, SUBWIDG_MISCGAUGE

int GridX;
int GridY;
 * The widget's grid x/y
 * VALID WIDGETS:
 *
 *  SUBWIDG_LGAUGE, SUBWIDG_MGAUGE, SUBWIDG_MISCGAUGE

int AnimVal;
 * The widget's animation value
 * VALID WIDGETS:
 *
 *  SUBWIDG_LGAUGE, SUBWIDG_MGAUGE, SUBWIDG_MISCGAUGE

int TabSize;
 * The widget's tabsize value
 * VALID WIDGETS:
 *
 *  SUBWIDG_TEXT, SUBWIDG_TEXTBOX

int ShowDrain;
 * The magic drain rate this widget will be visible at (-1 for any)
 * VALID WIDGETS:
 *
 *  SUBWIDG_MGAUGE

int PerContainer;
 * The counter amount per "container" for the widget
 * VALID WIDGETS:
 *
 *  SUBWIDG_MISCGAUGE

////////////////////////////////////
////////////////////////////////////
________        ___.                       .__                
\______ \   ____\_ |__  __ __  ____   ____ |__| ____    ____  
 |    |  \_/ __ \| __ \|  |  \/ ___\ / ___\|  |/    \  / ___\ 
 |    `   \  ___/| \_\ \  |  / /_/  > /_/  >  |   |  \/ /_/  >
/_______  /\___  >___  /____/\___  /\___  /|__|___|  /\___  / 
        \/     \/    \/     /_____//_____/         \//_____/  
Functions for debugging, and raw access to the internal ZASM stack and mechanics. 

/////////////////
///  Debug->  ///
///////////////// Debug

bool Testing;
 * Returns true if this instance of ZC was launched from the 'Quest->Test' option in ZQ.

void Breakpoint(char[] string = NULL);
 * If the ZASM debugger is open, this will break execution, and print the given string.
 * Break controls:
 *     'Insert' - break, or step forward if broken
 *     'Shift+Insert' - Step forward until next breakpoint, or start of next script, whichever comes first
 *     'Ctrl+Shift+Insert' - Same as above, but, doesn't print any ZASM until it breaks.
 *     'Alt+Insert' - Step forward until next breakpoint
 *     'Ctrl+Alt+Insert' - Same as above, but, doesn't print any ZASM until it breaks.
 *     'Ctrl+Insert' - Exit the ZASM debugger entirely
 * If the ZASM debugger is not open, this instruction does NOTHING.
 * Passing NULL to this function will not produce an error, instead printing no label
 * In ZASM scripts, passing the 'NUL' register to this instruction will not produce an error, instead printing no label

float D[256];
 * This is the value of the ri->d[] registers. 
 * These vary depending on the function, or the instruction.
 * For variable access, SETTER: ri->d[0] is the value being passed to the variable.
 * For variable access, GETTER: ri->d[0] *MIGHT BE* the value read from ther variable. (Need to verify.)
 * For array access, SETTER: ri->d[0] is the array index, and ri->d[1] is the value.
 * For array access, GETTER: ri->d[0] is the array index. Not sure on the RVal at this time.

 * For functions, ri->d[n] are the args passed to the functions.
 * 	Typically, the order is ri->d[0] for the first parameter, and each additional param is one index higher.
 *	Some functions might pop values in weird ways. 
 *	It should be possible to purely write functions as SETTER and GETTER types, so that their params
 * 	are simply the ri->d[] values, in order. 

 * Script drawing commands use sdci[] (&script_drawing_commands[n1][n2]), which is different.
 * Their params should still be available via ri->d[], but some values, may not. 
 * 	The frirst param for any script drawing instruction is the BITMAP that it uses. 
 * 	For bitmap-> pointer drawing commands, the bitmap ID is ri->bitmapref, set by Game->LoadBitmapID().
 * 	Otherwise, the BITMAP pointer is set by SetRenderTarget(), qand held in sdci[18].
 *	The other params follow, as inputs from the instruction (function params passed to it).
 *	last, the playfield offsets typically follow the function params.
 * 	Of these, on;y the sdci[] values would be available to ri->d[], if nothing eats them beforehand.

GDR[256]
Debug->GetFFCPointer(), SetFFCPointer(), GetItemPointer(), SetItemPointer(), GetItemdataPointer(), SetItemdataPointer()
	GetNPCPointer(), SetNPCPointer(), GetLWeaponPointer(), SetLWeaponPointer(), GetEWeaponPointer(),
	SetEWeaponPointer(), RefFFC, RefItem, RefItemdata, RefLWeapon, RefEWeapon, RefNPC, SP
,


**********************************************************************************************************/

SetRenderSource(int target, int x, int y, int w, int h)

/************************************************************************************************************/

//To add:
Game->Freeze(int type) or Game->Suspend() 
datatype->Create(), Load(), Destroy()



   _____            __                    _______           _            
  / ___/__  _______/ /____  ____ ___     /_  __(_)___ ___  (_)___  ____ _
  \__ \/ / / / ___/ __/ _ \/ __ `__ \     / / / / __ `__ \/ / __ \/ __ `/
 ___/ / /_/ (__  ) /_/  __/ / / / / /    / / / / / / / / / / / / / /_/ / 
/____/\__, /____/\__/\___/_/ /_/ /_/    /_/ /_/_/ /_/ /_/_/_/ /_/\__, /  
     /____/                                                     /____/   


2.55 Script Timing
19th December, 2019 for Alpha 48

1. (If firstplay) Global Init; allocate global arrays and variables.
2. (If firstplay) Link Init
3. (If loading from a saved file) Global OnLoadSave
4. Global onLaunch (if not F6 continue)
5. Global Continue Game (if F6 Continue)
6. FFCs by Screen Index (1 to 32)
7. Global Active (prior to Waitdraw)
8. Link Active  (prior to Waitdraw)
9. DMap Active (prior  to Waitdraw)
10. DMap Passive Subscreen
11. Itemsprite Scripts (by screen index)
12. NPC Active (by screen index)
13. EWeapon Active (by screen index)
14. Clear script one-frame conditions: Clears HitBy[]
15. Link.animate() : During this function, global, Link, and DMap scripts are run during screen scrolling)
15a. Global active during scrolling
15b. Link active, during scrolling, waitdraw may apply
15c. DMap Active, during scrolling, waitdraw may apply
15d. DMap Subscreen Passive, during scrolling, waitdraw may apply.
15e. DMap Subscreen Active, is the player pressed the Start button or the script was already running. 
	Running this script executes is its own isolated event loop. 
	If the DMap Subscreen Active script is running:
		(a) DMap Active (if the QR to run it is enabled)
		(b) DMap Subscreen Passive (if the QR to run it is enabled)
		(c) DMap Subscreen Active
		(d) Waitdraw
		(e) DMap Active (after waitdraw, if the QR to run it is enabled)
		(f) DMap Subscreen Passive (after waitdraw, if the QR to run it is enabled)
		(g) DMap Subscreen Active (after waitdraw)
16. Item Collect Scripts
17. Item Action scripts
18. Continual item scripts, after first frame (ordered by item ID)
19. LWeapon scripts (by screen index)
20. WAITDRAW
21. Global Active (after Waitdraw pause)
22. Link Active (after Waitdraw pause)
23. DMap Active (after Waitdraw pause)
24. DMap Subscreen passive (after Waitdraw pause)
25. FFcs after Waitdraw (if rule enabled_
26. Itemdata scripts after Waitdraw (if rule enabled)
27. NPC Scripts after Waitdraw.
29. EWeapon Scripts after Waitdraw.
30. LWeapon Scripts after Waitdraw.
31. Itemsprite Scripts after Waitdraw.
32.0. Global Exit  (if applicable)
32.1. Link Death (if applicable)
32.2.  Link Win (if Applicable)
33. Global F6 Script (if the player pressed F6)
