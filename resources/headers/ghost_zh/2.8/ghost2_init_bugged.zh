// ghost.zh
// Version 2.8.15


void Ghost_Init(ffc this, npc ghost)
{
    __Ghost_InitInternal(this, ghost, false, this->Data, this->CSet);
}


npc Ghost_InitCreate(ffc this, int enemyID)
{
    npc ghost=Screen->CreateNPC(enemyID);
    __Ghost_InitInternal(this, ghost, false, this->Data, this->CSet);
    return ghost;
}


npc Ghost_InitWait(ffc this, int enemyIndex, bool useEnemyPos)
{
    int combo=this->Data;
    this->Data=GH_INVISIBLE_COMBO;
    
    // Wait until there are enough enemies
    for(int i=0; i<4; i++)
    {
        if(Screen->NumNPCs>=enemyIndex)
        {
            npc ghost=Screen->LoadNPC(enemyIndex);
            __Ghost_InitInternal(this, ghost, useEnemyPos, combo, this->CSet);
            return ghost;
        }
        Waitframe();
    }

    // Didn't find the enemy, so quit
    __GhCleanUp(this);
    Quit();
}


npc Ghost_InitWait2(ffc this, int enemyID, bool useEnemyPos)
{
    int combo=this->Data;
    npc ghost;
    this->Data=GH_INVISIBLE_COMBO;
    
    for(int i=0; i<4; i++)
    {
        // Find the right enemy
        for(int j=1; j<=Screen->NumNPCs; j++)
        {
            ghost=Screen->LoadNPC(j);
            
            // Wrong ID or already in use
            if(ghost->ID!=enemyID)
                continue;
            if((ghost->Misc[__GHI_NPC_DATA]&0x10000)!=0)
                continue;

            __Ghost_InitInternal(this, ghost, useEnemyPos, combo, this->CSet);
            return ghost;
        }
        Waitframe();
    }

    // Didn't find the enemy, so quit
    __GhCleanUp(this);
    Quit();
}


npc Ghost_InitSpawn(ffc this, int enemyID)
{
    npc ghost=SpawnNPC(enemyID);
    __Ghost_InitInternal(this, ghost, false, this->Data, this->CSet);
}


npc Ghost_InitAutoGhost(ffc this, int enemyID)
{
    npc ghost;
    
    // Find the right enemy
    for(int i=1; i<=Screen->NumNPCs; i++)
    {
        ghost=Screen->LoadNPC(i);
        
        // Wrong ID or already in use
        if(ghost->ID!=enemyID)
            continue;
        if((ghost->Misc[__GHI_NPC_DATA]&0x10000)!=0)
            continue;
        
        __Ghost_InitInternal(this, ghost, true,
          ghost->Misc[__GHI_NPC_DATA]&0xFFFF, ghost->CSet);
        
        if((ghost->MiscFlags&100000000b)!=0) // That's "Is Transparent"
            this->Flags[FFCF_TRANS]=true;
        return ghost;
    }
    
    // No enemy found, so quit. This shouldn't ever happen, so log it.
    int error1[]="ghost.zh: AutoGhost initialization failed - enemy missing.\n";
    int error2[30]="  DMap %d, screen %X\n";
    int error3[30]="  Script %d, enemy ID %d\n";
    printf(error1);
    printf(error2, Game->CurDMap, Game->CurDMapScreen);
    printf(error3, this->Script, enemyID);
    
    __GhCleanUp(this);
    Quit();
}


// Does the actual initialization for the init functions
void __Ghost_InitInternal(ffc this, npc ghost, bool useEnemyPos, int combo, int cset)
{
    if(combo==__GH_INVISIBLE_ALT || combo==__GH_INVISIBLE_EXTEND)
        combo=GH_INVISIBLE_COMBO;
    
    this->Data=combo;
    Ghost_Data=combo;
    this->CSet=cset;
    Ghost_CSet=cset;
    
    if(useEnemyPos)
    {
        Ghost_X=ghost->X;
        Ghost_Y=ghost->Y;
        Ghost_Z=ghost->Z;
        Ghost_Jump=ghost->Jump;
    }
    else
    {
        Ghost_X=this->X;
        Ghost_Y=this->Y;
        Ghost_Z=0;
        Ghost_Jump=0;
        
        ghost->Z=0;
        ghost->Jump=0;
    }
    
    Ghost_SetPosition(this, ghost);
    Ghost_Dir=ghost->Dir;
    
    Ghost_Vx=0;
    Ghost_Vy=0;
    Ghost_Ax=0;
    Ghost_Ay=0;
    __Ghost_PrevX=Ghost_X;
    __Ghost_PrevY=Ghost_Y;
    
    Ghost_TileWidth=this->TileWidth;
    Ghost_TileHeight=this->TileHeight;
    __Ghost_XOffsets=0;
    __Ghost_YOffsets=0;
    
    if(combo!=GH_INVISIBLE_COMBO)
    {
        if(GH_PREFER_GHOST_ZH_SHADOWS == 0)
            ghost->Extend=3;
        else
            ghost->Extend=4; // Disables built-in shadows
        ghost->OriginalTile=GH_BLANK_TILE;
        ghost->TileWidth=Ghost_TileWidth;
        ghost->TileHeight=Ghost_TileHeight;
        ghost->HitWidth=16*Ghost_TileWidth;
        ghost->HitHeight=16*Ghost_TileHeight;
    }
    
    ghost->DrawXOffset=0;
    
    if((ghost->MiscFlags&100000b)!=0)
        this->Flags[FFCF_LENSVIS]=true;
    else
        this->Flags[FFCF_LENSVIS]=false;
    
    Ghost_HP=ghost->HP;
    
    __Ghost_Flags=0;
    __Ghost_Flags2=0;
    __Ghost_FlashCounter=0;
    __Ghost_KnockbackCounter=0;
    __Ghost_InternalFlags=0;
    
    __Ghost_AdditionalCombos[0]=0;
    ghost->Misc[__GHI_NPC_DATA]=0x10000;
    
    if(__GH_USE_DRAWCOMBO==0)
        // Remember that this is a ghost script so it can be cleared
        // when Link dies. This works by setting a single bit in
        // __Ghost_Scripts corresponding to the script number.
        __Ghost_Scripts[this->Script>>4]|=1<<(this->Script&1111b);
}
