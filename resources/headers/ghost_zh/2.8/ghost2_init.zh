// ghost.zh
// Version 2.8.15


void Ghost_Init(ffc this, npc ghost)
{
    __Ghost_InitInternal(this, ghost, false, this->Data, this->CSet);
}


npc Ghost_InitCreate(ffc this, int enemyID)
{
    npc ghost;
    if(enemyID < AUTOGHOST_MIN_ENEMY_ID || enemyID > AUTOGHOST_MAX_ENEMY_ID )
    {
	int errnonpc[]="Could not create npc ID %d\n";
	printf(errnonpc, enemyID);
	__GhCleanUp(this);
	return ghost;
	//Quit();    
    }
    ghost = Screen->CreateNPC(enemyID);
    __Ghost_InitInternal(this, ghost, false, this->Data, this->CSet);
    //if(!ghost->isValid)
    //{
	//int errnonpc[]="Could not create npc ID %d\n";
	//printf(errnonpc, enemyID);
	//__GhCleanUp(this);
	//return ghost;
	//	//Quit();
	    
    //}
    return ghost;
}

npc Ghost_InitCreateAt(ffc this, int enemyID, int x, int y)
{
    npc ghost;
    if(enemyID < AUTOGHOST_MIN_ENEMY_ID || enemyID > AUTOGHOST_MAX_ENEMY_ID )
    {
	int errnonpc[]="Could not create npc ID %d\n";
	printf(errnonpc, enemyID);
	__GhCleanUp(this);
	return ghost;
	//Quit();    
    }
    ghost = Screen->CreateNPC(enemyID);
    if(!(ghost->isValid())) 
    {
	int errnonpc[]="Could not create npc ID %d\n";
	printf(errnonpc, enemyID);
	__GhCleanUp(this);
	return ghost;
	//Quit();
    }
    __Ghost_InitInternal(this, ghost, false, this->Data, this->CSet);
    ghost->X = x;
    ghost->Y = y;
    return ghost;
}


npc Ghost_InitWait(ffc this, int enemyIndex, bool useEnemyPos)
{
    int combo=this->Data;
    this->Data=GH_INVISIBLE_COMBO;
    
    // Wait until there are enough enemies
    for(int i=0; i<4; i++)
    {
        if(Screen->NumNPCs()>=enemyIndex)
        {
            npc ghost=Screen->LoadNPC(enemyIndex);
            __Ghost_InitInternal(this, ghost, useEnemyPos, combo, this->CSet);
            return ghost;
        }
        Waitframe();
    }

    // Didn't find the enemy, so quit
    __GhCleanUp(this);
    Quit();
}


npc Ghost_InitWait2(ffc this, int enemyID, bool useEnemyPos)
{
    int combo=this->Data;
    npc ghost;
    this->Data=GH_INVISIBLE_COMBO;
    
    for(int i=0; i<4; i++)
    {
        // Find the right enemy
        for(int j=1; j<=Screen->NumNPCs(); j++)
        {
            ghost=Screen->LoadNPC(j);
            
            // Wrong ID or already in use
            if(ghost->ID!=enemyID)
                continue;
            if((ghost->Misc[__GHI_NPC_DATA]&0x10000)!=0)
                continue;

            __Ghost_InitInternal(this, ghost, useEnemyPos, combo, this->CSet);
            return ghost;
        }
        Waitframe();
    }

    // Didn't find the enemy, so quit
    __GhCleanUp(this);
    Quit();
}


npc Ghost_InitSpawn(ffc this, int enemyID)
{
	npc ghost=SpawnNPC(enemyID);
	__Ghost_InitInternal(this, ghost, false, this->Data, this->CSet);
	return ghost;
}

/*
npc Ghost_InitAutoGhost(ffc this, int enemyID)
{
    npc ghost; bool found = true;
    
    // Find the right enemy
    for(int i=Screen->NumNPCs(); i>0; --i)
    {
        ghost=Screen->LoadNPC(i);
        
        // Wrong ID or already in use
        if(ghost->ID!=enemyID)
	{
	    found = false;
            continue;
	}
        //if((ghost->Misc[__GHI_NPC_DATA]&0x10000)!=0)
        if((ghost->Misc[__GHI_NPC_DATA]&0x10000))
	{
		int sss[]="ghost->Misc[__GHI_NPC_DATA]&0x10000 is %d\n";
		printf(sss, (ghost->Misc[__GHI_NPC_DATA]&0x10000));
	    found = false;
            continue;
	}
        //int log1[]="Reached __Ghost_InitInternal call\n";
	//printf(log1);
	
        __Ghost_InitInternal(this, ghost, true, ghost->Misc[__GHI_NPC_DATA]&0xFFFF, ghost->CSet);
        
        //if((ghost->MiscFlags&100000000b)!=0) // That's "Is Transparent"
        if((ghost->MiscFlags&100000000b)) // That's "Is Transparent"
	{
            this->Flags[FFCF_TRANS]=true;
	}
	//int log2[]="Reached Ghost_InitAutoGhost return\n";
	//printf(log2);
	if ( found ) 
	{
		return ghost;
	}
    }
    
    if ( found ) 
    {
	return ghost;
    }
    else
    {
	// No enemy found, so quit. This shouldn't ever happen, so log it.
	int error1[]="ghost.zh: AutoGhost initialization failed - enemy missing.\n";
	int error2[30]="  DMap %d, screen %X\n";
	int error3[30]="  Script %d, enemy ID %d\n";
	printf(error1);
	printf(error2, Game->GetCurDMap(), Game->GetCurDMapScreen());
	printf(error3, this->Script, enemyID);
	    
	__GhCleanUp(this);
	Quit();
    }
}
*/

npc Ghost_InitAutoGhost(ffc this, int enemyID)
{
	npc ghost; bool found;
	
	// Find the right enemy
	for(int i=Screen->NumNPCs(); i>0; --i)
	{
		ghost=Screen->LoadNPC(i);
		
		// Wrong ID or already in use
		if(ghost->ID!=enemyID)
		{
			found = false; 
			continue;
		}
		else found = true;
		if((ghost->Misc[__GHI_NPC_DATA]&0x10000)!=0)
		{
			found = false; 
			continue;
		}
		if(found)
		{
			__Ghost_InitInternal(this, ghost, true,
			  ghost->Misc[__GHI_NPC_DATA]&0xFFFF, ghost->CSet);
			
			if((ghost->MiscFlags&100000000b)!=0) // That's "Is Transparent"
				this->Flags[FFCF_TRANS]=true;
			return ghost;
		}
		else break;
	}
	// No enemy found, so quit. This shouldn't ever happen, so log it.
	int error1[]="ghost.zh: AutoGhost initialization failed - enemy missing.\n";
	int error2[30]="  DMap %d, screen %X\n";
	int error3[30]="  Script %d, enemy ID %d\n";
	printf(error1);
	printf(error2, Game->GetCurDMap(), Game->GetCurDMapScreen());
	printf(error3, this->Script, enemyID);
	
	this->Data=0;
	Quit();
}




// Does the actual initialization for the init functions
void __Ghost_InitInternal(ffc this, npc ghost, bool useEnemyPos, int combo, int cset)
{
    if(combo==__GH_INVISIBLE_ALT || combo==__GH_INVISIBLE_EXTEND)
        combo=GH_INVISIBLE_COMBO;
    
    this->Data=combo;
    Ghost_Data=combo;
    this->CSet=cset;
    Ghost_CSet=cset;
    
    if(useEnemyPos)
    {
        Ghost_X=ghost->X;
        Ghost_Y=ghost->Y;
        Ghost_Z=ghost->Z;
        Ghost_Jump=ghost->Jump;
    }
    else
    {
        Ghost_X=this->X;
        Ghost_Y=this->Y;
        Ghost_Z=0;
        Ghost_Jump=0;
        
        ghost->Z=0;
        ghost->Jump=0;
    }
    
    Ghost_SetPosition(this, ghost);
    Ghost_Dir=ghost->Dir;
    
    Ghost_Vx=0;
    Ghost_Vy=0;
    Ghost_Ax=0;
    Ghost_Ay=0;
    __Ghost_PrevX=Ghost_X;
    __Ghost_PrevY=Ghost_Y;
    
    Ghost_TileWidth=this->TileWidth;
    Ghost_TileHeight=this->TileHeight;
    __Ghost_XOffsets=0;
    __Ghost_YOffsets=0;
    
    if(combo!=GH_INVISIBLE_COMBO)
    {
        if(GH_PREFER_GHOST_ZH_SHADOWS == 0)
            ghost->Extend=3;
        else
            ghost->Extend=4; // Disables built-in shadows
        ghost->OriginalTile=GH_BLANK_TILE;
	if ( __GH_FIX_255_ANONE )
	{
		ghost->Tile=GH_BLANK_TILE;
	}
        ghost->TileWidth=Ghost_TileWidth;
        ghost->TileHeight=Ghost_TileHeight;
        ghost->HitWidth=16*Ghost_TileWidth;
        ghost->HitHeight=16*Ghost_TileHeight;
    }
    
    ghost->DrawXOffset=0;
    
    if((ghost->MiscFlags&100000b)!=0)
        this->Flags[FFCF_LENSVIS]=true;
    else
        this->Flags[FFCF_LENSVIS]=false;
    
    Ghost_HP=ghost->HP;
    
    __Ghost_Flags=0;
    __Ghost_Flags2=0;
    __Ghost_FlashCounter=0;
    __Ghost_KnockbackCounter=0;
    __Ghost_InternalFlags=0;
    
    __Ghost_AdditionalCombos[0]=0;
    ghost->Misc[__GHI_NPC_DATA]=0x10000;
    
    if(__GH_USE_DRAWCOMBO==0)
        // Remember that this is a ghost script so it can be cleared
        // when Link dies. This works by setting a single bit in
        // __Ghost_Scripts corresponding to the script number.
        __Ghost_Scripts[this->Script>>4]|=1<<(this->Script&1111b);
}
