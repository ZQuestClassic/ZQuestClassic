#include <cstdint>
#include <deque>
#include <string>
#include <sstream>
#include <math.h>
#include <cstdio>
#include <ranges>
//
#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>
#include <fstream>
#include <filesystem>
#include <fmt/format.h>
//

#include "allegro/mouse.h"
#include "base/general.h"
#include "base/qrs.h"
#include "base/dmap.h"
#include "base/msgstr.h"
#include "base/packfile.h"
#include "base/misctypes.h"
#include "base/initdata.h"
#include "base/version.h"
#include "zasm/serialize.h"
#include "zasm/table.h"
#include "zc/replay.h"
#include "zc/zasm_optimize.h"
#include "zc/zasm_utils.h"
#include "zc/zc_ffc.h"
#include "zc/zc_sys.h"
#include "zc/jit.h"
#include "zc/script_debug.h"
#include "base/zc_alleg.h"
#include "base/zc_math.h"
#include "base/zc_array.h"
#include "zc/ffscript.h"
#include "zc/render.h"
#include "zc/zc_subscr.h"
#include <time.h>
#include "zc/script_drawing.h"
#include "base/util.h"
#include "zc/ending.h"
#include "base/module.h"
#include "zc/combos.h"
#include "drawing.h"
#include "base/colors.h"
#include "pal.h"
#include "zinfo.h"
#include "subscr.h"
#include "zc_list_data.h"
#include "music_playback.h"
#include <sstream>

#include "zc/zelda.h"
#include "particles.h"
#include "zc/hero.h"
#include "zc/guys.h"
#include "gamedata.h"
#include "zc/zc_init.h"
#include "base/zsys.h"
#include "base/misctypes.h"
#include "zc/title.h"
#include "zscriptversion.h"

#include "pal.h"
#include "base/zdefs.h"
#include "zc/rendertarget.h"

#include "zc/zc_custom.h"
#include "qst.h"
#include "zc/websocket_pool.h"

using namespace util;

#ifdef _WIN32
#define SCRIPT_FILE_MODE	(_S_IREAD | _S_IWRITE)
#else
	#include <fcntl.h>
	#include <unistd.h>
	#include <iostream>
	#define SCRIPT_FILE_MODE	(S_ISVTX | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#endif

//Define this register, so it can be treated specially
#define NUL		5
#define MAX_ZC_ARRAY_SIZE 214748

using namespace util;
using std::ostringstream;

struct ScriptEngineData {
	refInfo ref;
	int32_t stack[MAX_SCRIPT_REGISTERS];
	bounded_vec<word, int32_t> ret_stack {65535};
	// This is used as a boolean for all but ScriptType::Item.
	byte doscript = true;
	bool waitdraw;
	bool initialized;

	void reset()
	{
		// No need to zero the stack.
		ref = refInfo();
		doscript = true;
		waitdraw = false;
		initialized = false;
	}
};

// (type, index) => ScriptEngineData
static std::map<std::pair<ScriptType, word>, ScriptEngineData> scriptEngineDatas;

static int allocations_since_last_gc;
static int deallocations_since_last_gc;

extern byte use_dwm_flush;
uint8_t using_SRAM = 0;

int32_t hangcount = 0;
bool can_neg_array = true;

extern byte monochrome_console;

static std::map<script_id, ScriptDebugHandle> script_debug_handles;
ScriptDebugHandle* runtime_script_debug_handle;
// Values may be null.
static std::map<std::pair<zasm_script*, refInfo*>, JittedScriptHandle*> jitted_scripts;
int32_t jitted_uncompiled_command_count;

CScriptDrawingCommands scriptdraws;
FFScript FFCore;
extern ZModule zcm;
extern zcmodule moduledata;

// Returns true if an id is not usable for an object id.
bool is_reserved_object_id(uint32_t id)
{
	// Used by internal bitmaps (see do_loadbitmapid).
	if (id >= 9 && id <= 16)
		return true;

	return false;
}

static std::map<uint32_t, std::unique_ptr<user_abstract_obj>> script_objects;
static std::map<script_object_type, std::vector<uint32_t>> script_object_ids_by_type;
static std::vector<uint32_t> script_object_autorelease_pool;
static std::vector<uint32_t> next_script_object_id_freelist;

uint32_t get_next_script_object_id()
{
	const auto ID_FREELIST_FILL_AMOUNT = 1000;

	if (next_script_object_id_freelist.empty())
	{
		// Don't start at 1 because the first objects are expected to remain allocated.
		uint32_t id = 1000;
		while (next_script_object_id_freelist.size() < ID_FREELIST_FILL_AMOUNT)
		{
			if (!script_objects.contains(id))
				next_script_object_id_freelist.push_back(id);
			id++;
		}
	}

	// ~4 billion objects is a lot, so it's unlikely this condition will ever be true.
	// But just in case...
	if (next_script_object_id_freelist.empty())
		Z_error_fatal("Ran out of storage for script objects\n");

	auto id = next_script_object_id_freelist.back();
	next_script_object_id_freelist.pop_back();
	return id;
}

template <typename T>
static T* create_script_object(script_object_type type, uint32_t id = -1)
{
	if (id == -1)
		id = get_next_script_object_id();

	auto object = new T{};
	object->type = type;
	object->id = id;
	script_objects[id] = std::unique_ptr<T>(object);
	script_object_ids_by_type[type].push_back(id);

	allocations_since_last_gc++;
	object->ref_count = 1;
	script_object_autorelease_pool.push_back(id);

	return object;
}

static user_abstract_obj* get_script_object(uint32_t id)
{
	auto it = script_objects.find(id);
	if (it != script_objects.end())
		return it->second.get();
	return nullptr;
}

static user_abstract_obj* get_script_object_checked(uint32_t id)
{
	if (is_reserved_object_id(id))
		return nullptr;

	auto object = get_script_object(id);
	if (!object)
		Z_error_fatal("Invalid object pointer used in get_script_object_checked\n");
	return object;
}

static void script_object_ref_inc(user_abstract_obj* object)
{
	object->ref_count++;
}

static void script_object_ref_inc(uint32_t id)
{
	if (!id)
		return;

	auto object = get_script_object_checked(id);
	if (object)
		script_object_ref_inc(object);
}

static void delete_script_object(uint32_t id);

static void script_object_ref_dec(user_abstract_obj* object)
{
	assert(object->ref_count > 0);
	object->ref_count--;

	if (auto usr_object = dynamic_cast<user_object*>(object))
		if (usr_object->isGlobal())
			return;

	if (ZScriptVersion::gc() && object->ref_count == 0)
		delete_script_object(object->id);
}

static void script_object_ref_dec(uint32_t id)
{
	if (!id)
		return;

	auto object = get_script_object_checked(id);
	if (object)
		script_object_ref_dec(object);
}

static void delete_script_object(uint32_t id)
{
	auto it = script_objects.find(id);
	if (it == script_objects.end())
		return;

	auto& object = it->second;

	// Bitmap objects can't be deleted right away, since drawing operations are deferred slightly.
	// We must wait for the script drawing to be done with it, which is signaled by script_bitmaps::update
	if (object->type == script_object_type::bitmap)
	{
		auto bitmap = static_cast<user_bitmap*>(object.get());
		if (!bitmap->can_del())
		{
			bitmap->free_obj();
			return;
		}
	}

	if (object->type == script_object_type::object)
	{
		auto usr_object = static_cast<user_object*>(object.get());
		for (int i = 0; i < usr_object->owned_vars; i++)
		{
			if (usr_object->isMemberObjectType(i))
				script_object_ref_dec(usr_object->data[i]);
		}

		usr_object->destruct.execute();
		usr_object->clear_nodestruct();
	}

	util::remove_if_exists(script_object_ids_by_type[object->type], id);
	script_objects.erase(it);
	deallocations_since_last_gc++;

	if (next_script_object_id_freelist.size() < 10000)
		next_script_object_id_freelist.push_back(id);
}

static void own_script_object(user_abstract_obj* object, ScriptType type, int i)
{
	if (!ZScriptVersion::gc())
	{
		object->own(type, i);
		return;
	}

	bool was_owned = object->owned_type != ScriptType::None;
	object->own(type, i);
	bool is_owned = type != ScriptType::None;
	if (was_owned && !is_owned)
		script_object_ref_dec(object);
	else if (!was_owned && is_owned)
		script_object_ref_inc(object);
}

static void free_script_object(uint32_t id)
{
	if (!ZScriptVersion::gc())
		delete_script_object(id);
}

// Find unreachable objects via mark-and-sweep, and destroy them.
// This handles cyclical objects.
// It should not be called very often as it can be expensive.
// Note: Most objects are cleared up via reference counting
// (when ref_count is zero in script_object_ref_dec).
static void run_gc()
{
	std::vector<user_abstract_obj*> all_objects;
	for (auto& [id, object] : script_objects)
		all_objects.push_back(object.get());

	std::set<uint32_t> live_object_ids;

	for (auto& object : all_objects)
	{
		if (object->type != script_object_type::object)
			continue;

		auto usr_object = static_cast<user_object*>(object);
		if (usr_object->isGlobal())
			live_object_ids.insert(object->id);
	}
	for (auto& aptr : game->globalRAM)
	{
		if (aptr.HoldsObjects())
		{
			for (int i = 0; i < aptr.Size(); i++)
			{
				live_object_ids.insert(aptr[i]);
			}
		}
	}
	for (auto& aptr : localRAM)
	{
		if (aptr.HoldsObjects())
		{
			for (int i = 0; i < aptr.Size(); i++)
			{
				live_object_ids.insert(aptr[i]);
			}
		}
	}
	for (size_t i = 0; i < MAX_SCRIPT_REGISTERS; i++)
	{
		if (game->global_d_types[i] != script_object_type::none)
			live_object_ids.insert(game->global_d[i]);
	}
	for (auto& data : scriptEngineDatas | std::views::values)
	{
		for (int i : data.ref.stack_pos_is_object)
			live_object_ids.insert(data.stack[i]);
	}

	// Insert all root objects into worklist.
	std::set<user_abstract_obj*> worklist;
	for (auto& id : live_object_ids)
	{
		if (is_reserved_object_id(id))
			continue;

		auto object = get_script_object(id);
		assert(id == 0 || object);
		if (!object)
			continue;

		bool can_hold_objects = false;
		switch (object->type)
		{
			case script_object_type::object:
			// TODO: handle stacks?
			// case script_object_type::stack:
				can_hold_objects = true;
				break;
		}
		if (!can_hold_objects)
			continue;

		auto usr_object = dynamic_cast<user_object*>(object);
		assert(usr_object);
		if (!usr_object)
			continue;

		worklist.insert(usr_object);
	}

	// Find all the reachable objects.
	while (worklist.size())
	{
		auto base_object = *worklist.begin();
		worklist.erase(worklist.begin());

		// Currently only user objects retain references.
		if (base_object->type != script_object_type::object)
			continue;

		auto object = static_cast<user_object*>(base_object);
		for (int i = 0; i < object->owned_vars; i++)
		{
			if (!object->isMemberObjectType(i))
				continue;

			auto id = object->data[i];
			if (id && !live_object_ids.contains(id))
			{
				live_object_ids.insert(id);
				worklist.insert(get_script_object(id));
			}
		}

		for (int i = object->owned_vars; i < object->data.size(); i++)
		{
			auto ptr = object->data[i]/10000;
			if (ptr == 0)
				continue;

			auto& aptr = objectRAM.at(-ptr);
			if (!aptr.HoldsObjects())
				continue;

			for (int i = 0; i < aptr.Size(); i++)
			{
				auto id = aptr[i];
				if (id && !live_object_ids.contains(id))
				{
					live_object_ids.insert(id);
					worklist.insert(get_script_object(id));
				}
			}
		}
	}

	// Delete unreachable objects.
	for (auto& object : all_objects)
	{
		if (live_object_ids.contains(object->id))
			continue;

		// This object is not reachable.

		if (auto usr_object = dynamic_cast<user_object*>(object))
		{
			// To avoid problems when `delete_script_object` deletes the object, clear the
			// members here.
			// Any references held in members are also not reachable, so this is fine to do
			// because they will also be deleted by this gc call.
			for (int i = usr_object->owned_vars; i < usr_object->data.size(); i++)
			{
				auto ptr = usr_object->data[i]/10000;
				void destroy_object_arr(int32_t ptr, bool dec_refs);
				destroy_object_arr(ptr, false);
			}
			usr_object->owned_vars = 0;
			usr_object->data.clear();
		}

		util::remove_if_exists(script_object_autorelease_pool, object->id);
		delete_script_object(object->id);
	}

	allocations_since_last_gc = 0;
	deallocations_since_last_gc = 0;
}

static void maybe_run_gc()
{
	if (allocations_since_last_gc - deallocations_since_last_gc > 700)
		run_gc();
}

void init_script_objects()
{
	next_script_object_id_freelist.clear();
	// See `is_reserved_object_id` for why ids do not begin at 1.
	for (uint32_t id = 1000; id >= 100; id--)
		next_script_object_id_freelist.push_back(id);
	script_objects.clear();
	script_object_ids_by_type.clear();
	script_object_autorelease_pool.clear();
	allocations_since_last_gc = 0;
	deallocations_since_last_gc = 0;

	// Load globals and set their reference counts.
	// Only custom user objects can be restored right now, so
	// any other object type will be set to NULL.
	game->load_user_objects();
	if (!ZScriptVersion::gc())
		return;
	for (size_t i = 0; i < MAX_SCRIPT_REGISTERS; i++)
	{
		auto type = game->global_d_types[i];
		if (type == script_object_type::object && script_objects.contains(game->global_d[i]))
			script_object_ref_inc(game->global_d[i]);
		else if (type != script_object_type::none)
			game->global_d[i] = 0;
	}
	for (auto& aptr : game->globalRAM)
	{
		if (!aptr.HoldsObjects())
			continue;

		if (aptr.ObjectType() != script_object_type::object)
		{
			for (int i = 0; i < aptr.Size(); i++)
				aptr[i] = 0;
			continue;
		}

		for (int i = 0; i < aptr.Size(); i++)
		{
			if (script_objects.contains(aptr[i]))
				script_object_ref_inc(aptr[i]);
			else
				aptr[i] = 0;
		}
	}
	// This covers any arrays held by saved objects.
	for (auto& aptr : objectRAM | std::views::values)
	{
		if (!aptr.HoldsObjects())
			continue;

		if (aptr.ObjectType() != script_object_type::object)
		{
			for (int i = 0; i < aptr.Size(); i++)
				aptr[i] = 0;
			continue;
		}

		for (int i = 0; i < aptr.Size(); i++)
		{
			if (script_objects.contains(aptr[i]))
				script_object_ref_inc(aptr[i]);
			else
				aptr[i] = 0;
		}
	}
	for (auto& object : FFCore.get_user_objects())
	{
		assert(object->isGlobal());
		for (int i = 0; i < object->owned_vars; i++)
		{
			if (!object->isMemberObjectType(i))
				continue;

			if (object->var_types[i] == script_object_type::object && script_objects.contains(object->data[i]))
				script_object_ref_inc(object->data[i]);
			else
				object->data[i] = 0;
		}
	}
}

template <typename T, uint32_t Max>
struct UserDataContainer
{
	script_object_type type;
	const char* name;

	T& operator[](uint32_t id)
	{
		auto& t = script_objects.at(id);
		assert(t->type == type);
		T* ptr = static_cast<T*>(t.get());
		return *ptr;
	}

	void clear()
	{
		auto ids = script_object_ids_by_type[type];
		for (auto id : ids)
			delete_script_object(id);
	}

	T* create(bool skipError = false)
	{
		if (script_object_ids_by_type[type].size() >= Max)
			run_gc();

		if (script_object_ids_by_type[type].size() >= Max)
		{
			if (!skipError) Z_scripterrlog("could not find a valid free %s pointer!\n", name);
			return nullptr;
		}

		return create_script_object<T>(type);
	}

	uint32_t get_free(bool skipError = false)
	{
		T* object = create(skipError);
		if (!object) return 0;
		return object->id;
	}

	T* check(uint32_t id, const char* what, bool skipError = false)
	{
		if (util::contains(script_object_ids_by_type[type], id))
		{
			auto& t = script_objects.at(id);
			return static_cast<T*>(t.get());
		}

		if (skipError) return NULL;

		Z_scripterrlog("Script attempted to reference a nonexistent %s!\n", name);
		if (what)
			Z_scripterrlog("You were trying to reference the '%s' of a %s with UID = %ld\n", what, name, id);
		else
			Z_scripterrlog("You were trying to reference with UID = %ld\n", id);
		return NULL;
	}
};

static UserDataContainer<user_dir, MAX_USER_DIRS> user_dirs = {script_object_type::dir, "directory"};
static UserDataContainer<user_file, MAX_USER_FILES> user_files = {script_object_type::file, "file"};
static UserDataContainer<user_object, MAX_USER_OBJECTS> user_objects = {script_object_type::object, "object"};
static UserDataContainer<user_paldata, MAX_USER_PALDATAS> user_paldatas = {script_object_type::paldata, "paldata"};
static UserDataContainer<user_rng, MAX_USER_RNGS> user_rngs = {script_object_type::rng, "rng"};
static UserDataContainer<user_stack, MAX_USER_STACKS> user_stacks = {script_object_type::stack, "stack"};
static UserDataContainer<user_bitmap, MAX_USER_BITMAPS> user_bitmaps = {script_object_type::bitmap, "bitmap"};

void script_bitmaps::update()
{
	auto ids = script_object_ids_by_type[user_bitmaps.type];
	for (auto id : ids)
	{
		auto& bitmap = user_bitmaps[id];
		if (bitmap.is_freeing())
		{
			bitmap.mark_can_del();
			delete_script_object(id);
		}
	}
}

user_bitmap& script_bitmaps::get(int32_t id)
{
	static user_bitmap fake;
	if (auto bitmap = user_bitmaps.check(id, "script drawing"))
		return *bitmap;
	return fake;
}

struct user_websocket : public user_abstract_obj
{
	~user_websocket()
	{
		if (connection_id != -1)
			websocket_pool_close(connection_id);
		if (message_arrayptr)
			FFScript::deallocateZScriptArray(message_arrayptr);
	}

	bool connect(std::string url)
	{
		connection_id = websocket_pool_connect(url, err);
		this->url = url;
		return connection_id != -1;
	}

	void send(WebSocketMessageType type, std::string message)
	{
		if (connection_id == -1 || type == WebSocketMessageType::None) return;
		websocket_pool_send(connection_id, type, message);
	}

	bool has_message()
	{
		if (connection_id == -1) return false;
		return websocket_pool_has_message(connection_id);
	}

	std::string receive_message()
	{
		if (connection_id == -1) return "";
		auto [type, message] = websocket_pool_receive(connection_id);
		last_message_type = type;
		return message;
	}

	WebSocketStatus get_state() const
	{
		if (connection_id == -1) return WebSocketStatus::Closed;
		return websocket_pool_status(connection_id);
	}

	std::string get_error() const
	{
		if (connection_id == -1) return err;
		return websocket_pool_error(connection_id);
	}

	int connection_id = -1;
	std::string url;
	std::string err;
	int message_arrayptr;
	WebSocketMessageType last_message_type;
};
#define MAX_USER_WEBSOCKETS 3
static UserDataContainer<user_websocket, MAX_USER_WEBSOCKETS> user_websockets = {script_object_type::websocket, "websocket"};

user_object& FFScript::create_user_object(uint32_t id)
{
	auto& vec = next_script_object_id_freelist;
	vec.erase(std::remove(vec.begin(), vec.end(), id), vec.end());
	create_script_object<user_object>(script_object_type::object, id);
	return user_objects[id];
}

std::vector<user_object*> FFScript::get_user_objects()
{
	std::vector<user_object*> result;
	for (auto id : script_object_ids_by_type[user_objects.type])
	{
		result.push_back(&user_objects[id]);
	}
	return result;
}

user_object* FFScript::get_user_object(uint32_t id)
{
	return user_objects.check(id, "", true);
}

script_bitmaps scb;
user_rng nulrng;
zc_randgen script_rnggens[MAX_USER_RNGS];

FONT *get_zc_font(int index);

int32_t combopos_modified = -1;
static word combo_id_cache[7*176] = {0};

void user_dir::setPath(const char* buf)
{
	if(!list)
	{
		list = (FLIST *) malloc(sizeof(FLIST));
	}
	filepath = std::string(buf) + "/";
	regulate_path(filepath);
	list->load(filepath.c_str());
}

int32_t CScriptDrawingCommands::GetCount()
{
	al_trace("current number of draws is: %d\n", count);
	return count;
}
//Advances the game frame without checking 'Quit' variable status.
//Used for making scripts such as Player's onWin and onDeath scripts
//run for multiple frames.

void FFScript::Waitframe(bool allowwavy, bool sfxcleanup)
{
	if(zcmusic!=NULL)
	{
		zcmusic_poll();
	}
	zcmixer_update(zcmixer, emusic_volume, FFCore.usr_music_volume, get_qr(qr_OLD_SCRIPT_VOLUME));
	
	while(Paused && !Advance && !Quit)
	{
		// have to call this, otherwise we'll get an infinite loop
		syskeys();
		// to keep fps constant
		updatescr(allowwavy);
		zc_throttle_fps();
		
#ifdef _WIN32
		
		if(use_dwm_flush)
		{
			do_DwmFlush();
		}
		
#endif
		
		// to keep music playing
		if(zcmusic!=NULL)
		{
			zcmusic_poll();
		}
		zcmixer_update(zcmixer, emusic_volume, FFCore.usr_music_volume, get_qr(qr_OLD_SCRIPT_VOLUME));

		update_hw_screen();
	}
	
	//if(Quit)
	//	return;
	/*
	if(Playing && game->get_time()<MAXTIME)
		game->change_time(1);
	*/
	Advance=false;
	++frame;
	
	syskeys();
	// Someday... maybe install a Turbo button here?
	updatescr(allowwavy);
	zc_throttle_fps();
	
#ifdef _WIN32
	
	if(use_dwm_flush)
	{
		do_DwmFlush();
	}
	
#endif
	
	//textprintf_ex(screen,font,0,72,254,BLACK,"%d %d", lastentrance, lastentrance_dmap);
	if(sfxcleanup)
		sfx_cleanup();
}

mapscr* GetMapscr(int32_t mapref)
{
	switch(mapref)
	{
		case MAPSCR_TEMP0: return FFCore.tempScreens[0]; //Temp layer 0
		case MAPSCR_TEMP1: return FFCore.tempScreens[1]; //Temp layer 1
		case MAPSCR_TEMP2: return FFCore.tempScreens[2]; //Temp layer 2
		case MAPSCR_TEMP3: return FFCore.tempScreens[3]; //Temp layer 3
		case MAPSCR_TEMP4: return FFCore.tempScreens[4]; //Temp layer 4
		case MAPSCR_TEMP5: return FFCore.tempScreens[5]; //Temp layer 5
		case MAPSCR_TEMP6: return FFCore.tempScreens[6]; //Temp layer 6
		case MAPSCR_SCROLL0: return FFCore.ScrollingScreens[0]; //Temp scrolllayer 0
		case MAPSCR_SCROLL1: return FFCore.ScrollingScreens[1]; //Temp scrolllayer 1
		case MAPSCR_SCROLL2: return FFCore.ScrollingScreens[2]; //Temp scrolllayer 2
		case MAPSCR_SCROLL3: return FFCore.ScrollingScreens[3]; //Temp scrolllayer 3
		case MAPSCR_SCROLL4: return FFCore.ScrollingScreens[4]; //Temp scrolllayer 4
		case MAPSCR_SCROLL5: return FFCore.ScrollingScreens[5]; //Temp scrolllayer 5
		case MAPSCR_SCROLL6: return FFCore.ScrollingScreens[6]; //Temp scrolllayer 6
		default:
		{
			if(mapref < 0) return NULL; //Bad negative value
			else return &TheMaps[mapref]; //Standard mapdata
		}
	}
}

int32_t getMap(int32_t ref)
{
	switch(ref)
	{
		case MAPSCR_TEMP0:
			return currmap+1;
		case MAPSCR_TEMP1:
			return FFCore.tempScreens[0]->layermap[0];
		case MAPSCR_TEMP2:
			return FFCore.tempScreens[0]->layermap[1];
		case MAPSCR_TEMP3:
			return FFCore.tempScreens[0]->layermap[2];
		case MAPSCR_TEMP4:
			return FFCore.tempScreens[0]->layermap[3];
		case MAPSCR_TEMP5:
			return FFCore.tempScreens[0]->layermap[4];
		case MAPSCR_TEMP6:
			return FFCore.tempScreens[0]->layermap[5];
		case MAPSCR_SCROLL0:
			return scrolling_map+1;
		case MAPSCR_SCROLL1:
			return FFCore.ScrollingScreens[0]->layermap[0];
		case MAPSCR_SCROLL2:
			return FFCore.ScrollingScreens[0]->layermap[1];
		case MAPSCR_SCROLL3:
			return FFCore.ScrollingScreens[0]->layermap[2];
		case MAPSCR_SCROLL4:
			return FFCore.ScrollingScreens[0]->layermap[3];
		case MAPSCR_SCROLL5:
			return FFCore.ScrollingScreens[0]->layermap[4];
		case MAPSCR_SCROLL6:
			return FFCore.ScrollingScreens[0]->layermap[5];
		default:
			return (ref / MAPSCRS + 1);
	}
}
int32_t getScreen(int32_t ref)
{
	switch(ref)
	{
		case MAPSCR_TEMP0:
			return currscr;
		case MAPSCR_TEMP1:
			return FFCore.tempScreens[0]->layerscreen[0];
		case MAPSCR_TEMP2:
			return FFCore.tempScreens[0]->layerscreen[1];
		case MAPSCR_TEMP3:
			return FFCore.tempScreens[0]->layerscreen[2];
		case MAPSCR_TEMP4:
			return FFCore.tempScreens[0]->layerscreen[3];
		case MAPSCR_TEMP5:
			return FFCore.tempScreens[0]->layerscreen[4];
		case MAPSCR_TEMP6:
			return FFCore.tempScreens[0]->layerscreen[5];
		case MAPSCR_SCROLL0:
			return scrolling_scr;
		case MAPSCR_SCROLL1:
			return FFCore.ScrollingScreens[0]->layerscreen[0];
		case MAPSCR_SCROLL2:
			return FFCore.ScrollingScreens[0]->layerscreen[1];
		case MAPSCR_SCROLL3:
			return FFCore.ScrollingScreens[0]->layerscreen[2];
		case MAPSCR_SCROLL4:
			return FFCore.ScrollingScreens[0]->layerscreen[3];
		case MAPSCR_SCROLL5:
			return FFCore.ScrollingScreens[0]->layerscreen[4];
		case MAPSCR_SCROLL6:
			return FFCore.ScrollingScreens[0]->layerscreen[5];
		default:
			return (ref % MAPSCRS);
	}
}

dword get_subref(int sub, byte ty, byte pg = 0, word ind = 0)
{
	byte s;
	if(sub == -1) //special; load current
	{
		s = new_sub_indexes[ty];
		if(s < 0) return 0;
	}
	else if(unsigned(sub) < 256)
		s = sub;
	else return 0;
	++ty; //type is offset by 1
	return (s<<24)|(pg<<16)|((ty&0x7)<<13)|(ind&0x1FFF);
}
std::tuple<byte,int8_t,byte,word> from_subref(dword ref)
{
	byte type = (ref>>13)&0x07;
	if(!type)
		return { 0, -1, 0, 0 };
	
	byte sub = (ref>>24)&0xFF;
	byte pg = (ref>>16)&0xFF;
	word ind = (ref)&0x1FFF;
	return { sub, type-1, pg, ind };
}

std::tuple<ZCSubscreen*,SubscrPage*,SubscrWidget*,byte> load_subscreen_ref(dword ref)
{
	auto [sub,ty,pg,ind] = from_subref(ref);
	ZCSubscreen* sbscr = nullptr;
	SubscrPage* sbpg = nullptr;
	SubscrWidget* sbwidg = nullptr;
	switch(ty)
	{
		case sstACTIVE:
			if(sub < subscreens_active.size())
				sbscr = &subscreens_active[sub];
			break;
		case sstPASSIVE:
			if(sub < subscreens_passive.size())
				sbscr = &subscreens_passive[sub];
			break;
		case sstOVERLAY:
			if(sub < subscreens_overlay.size())
				sbscr = &subscreens_overlay[sub];
			break;
	}
	if(sbscr)
	{
		if(pg < sbscr->pages.size())
			sbpg = &sbscr->pages[pg];
	}
	else return { nullptr, nullptr, nullptr, -1 }; //no subscreen
	if(sbpg)
	{
		if(ind < sbpg->size())
			sbwidg = sbpg->at(ind);
	}
	return { sbscr, sbpg, sbwidg, ty };
}
std::pair<ZCSubscreen*,byte> load_subdata(dword ref)
{
	auto [sub,_pg,_widg,ty] = load_subscreen_ref(ref);
	return { sub, ty };
}
std::pair<SubscrPage*,byte> load_subpage(dword ref)
{
	auto [_sub,pg,_widg,ty] = load_subscreen_ref(ref);
	return { pg, ty };
}
std::pair<SubscrWidget*,byte> load_subwidg(dword ref)
{
	auto [_sub,_pg,widg,ty] = load_subscreen_ref(ref);
	return { widg, ty };
}

#include "zconsole/ConsoleLogger.h"

//no ifdef here
extern CConsoleLoggerEx zscript_coloured_console;
	
int32_t FFScript::UpperToLower(std::string *s)
{
	if ( s->size() < 1 ) 
	{
		Z_scripterrlog("String passed to UpperToLower() is too small. Size is: %d \n", s->size());
		return 0;
	}
	for ( size_t q = 0; q < s->size(); ++q )
	{
		//if ( s->at(q) >= 'A' || s->at(q) <= 'Z' )
		//{
		//	s->at(q) += 32;
		//}
		s->at(q) += 32 * (s->at(q) >= 'A' && s->at(q) <= 'Z');
	}
	return 1;
}

int32_t FFScript::LowerToUpper(std::string *s)
{
	if ( s->size() < 1 ) 
	{
		Z_scripterrlog("String passed to LowerToUpper() is too small. Size is: %d \n", s->size());
		return 0;
	}
	for ( size_t q = 0; q < s->size(); ++q )
	{
		//if ( s->at(q) >= 'a' || s->at(q) <= 'z' )
		//{
		//	s->at(q) -= 32;
		//}
		s->at(q) -= 32 * (s->at(q) >= 'a' && s->at(q) <= 'z');
	}
	return 1;
}

int32_t FFScript::ConvertCase(std::string *s)
{
	if ( s->size() < 1 ) 
	{
		Z_scripterrlog("String passed to UpperToLower() is too small. Size is: %d \n", s->size());
		return 0;
	}
	for ( size_t q = 0; q < s->size(); ++q )
	{
		if ( s->at(q) >= 'a' || s->at(q) <= 'z' )
		{
			s->at(q) -= 32;
		}
		else if ( s->at(q) >= 'A' || s->at(q) <= 'Z' )
		{
			s->at(q) += 32;
		}
	}
	zprint("FFScript::ConvertCase(std::string s), post-conversion, string is: %s\n", s->c_str());
	return 1;
}

bool FFScript::isNumber(char chr)
{
	if ( chr >= '0' )
	{
		if ( chr <= '9' ) return true;
	}
	return false;
}

int32_t FFScript::ilen(char *p)
{
	int32_t ret = 0; int32_t pos = 0;
	if(p[pos] == '-')
		ret++;
	for(; FFCore.isNumber(p[pos + ret]); ++ret);
	return ret;
}

int32_t FFScript::zc_strlen(char *p)
{
	int32_t count = 0;
 
	while(*p!='\0')
	{
		count++;
		p++;
	}
 
	return count;
}

int32_t FFScript::atox(char *ip_str)
{
	char tmp[2]={'2','\0'};
	int32_t op_val=0, i=0, ip_len = FFCore.zc_strlen(ip_str);

	if(strncmp(ip_str, "0x", 2) == 0)
	{
		ip_str +=2;
		ip_len -=2;
	}

	for(i=0;i<ip_len;i++)
	{
		op_val *= 0x10;
		switch(ip_str[i])
		{
			case 'a':
			op_val += 0xa;
			break;
			case 'b':
			op_val += 0xb;
			break;
			case 'c':
			op_val += 0xc;
			break;
			case 'd':
			op_val += 0xd;
			break;
			case 'e':
			op_val += 0xe;
			break;
			case 'f':
			op_val += 0xf;
			break;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			tmp[0] = ip_str[i];
			op_val += atoi(tmp);
			break;
			default :
			op_val += 0x0;
			break;
		}
	}
	return op_val;
}

char runningItemScripts[256] = {0};
 
//item *FFCore.temp_ff_item = NULL;
//enemy *FFCore.temp_ff_enemy = NULL;
//weapon *FFCore.temp_ff_lweapon = NULL;
//weapon *FFCore.temp_ff_eweapon = NULL;

extern int32_t directItemA;
extern int32_t directItemB;
extern int32_t directItemX;
extern int32_t directItemY;


#ifdef _MSC_VER
#pragma warning ( disable : 4800 ) //int32_t to bool town. population: lots.
#endif

#define NUMSHOPS 256
#define NUMINFOSHOPS 511

//! New datatype vars for 2.54:

//spritedata sp->member


using std::string;

extern particle_list particles;
extern HeroClass Hero;
extern char *guy_string[];
extern int32_t skipcont;

PALETTE tempgreypal; //Palettes go here. This is used for Greyscale() / Monochrome()
PALETTE userPALETTE[256]; //Palettes go here. This is used for Greyscale() / Monochrome()
PALETTE tempblackpal; //Used for storing the palette while fading to black

FFScript ffengine;

byte FF_hero_action; //This way, we can make safe replicas of internal Hero actions to be set by script. 
	
int32_t FF_screenbounds[4]; //edges of the screen, left, right, top, bottom used for where to scroll. 
int32_t FF_screen_dimensions[4]; //height, width, displaywidth, displayheight
int32_t FF_subscreen_dimensions[4];
int32_t FF_eweapon_removal_bounds[4]; //left, right, top, bottom coordinates for automatic eweapon removal. 
int32_t FF_lweapon_removal_bounds[4]; //left, right, top, bottom coordinates for automatic lweapon removal. 
int32_t FF_clocks[FFSCRIPTCLASS_CLOCKS]; //Will be used for Heroaction, anims, and so forth 
byte ScriptDrawingRules[SCRIPT_DRAWING_RULES];
int32_t FF_UserMidis[NUM_USER_MIDI_OVERRIDES]; //MIDIs to use for Game Over, and similar to override system defaults. 

int32_t get_int_arr(const int32_t ptr, int32_t indx);
void set_int_arr(const int32_t ptr, int32_t indx, int32_t val);
int32_t sz_int_arr(const int32_t ptr);

//We gain some speed by not passing as arguments
int32_t sarg1 = 0;
int32_t sarg2 = 0;
int32_t sarg3 = 0;
vector<int32_t> *sargvec;
string *sargstr;
refInfo *ri = NULL;
script_data *curscript = NULL;
int32_t(*stack)[MAX_SCRIPT_REGISTERS] = NULL;
bounded_vec<word, int32_t>* ret_stack;
vector<int32_t> zs_vargs;
ScriptType curScriptType;
word curScriptNum;
int32_t curScriptIndex;
bool script_funcrun = false;
string* destructstr = nullptr;
size_t gen_frozen_index = 0;

static vector<ScriptType> curScriptType_cache;
static vector<int32_t> curScriptNum_cache;
static vector<int32_t> curScriptIndex_cache;
static vector<int32_t> sarg1cache;
static vector<int32_t> sarg2cache;
static vector<int32_t> sarg3cache;
static vector<vector<int32_t>*> sargvec_cache;
static vector<string*> sargstr_cache;
static vector<refInfo*> ricache;
static vector<script_data*> sdcache;
static vector<int32_t(*)[MAX_SCRIPT_REGISTERS]> stackcache;
static vector<bounded_vec<word, int32_t>*> ret_stack_cache;
void push_ri()
{
	sarg1cache.push_back(sarg1);
	sarg2cache.push_back(sarg2);
	sarg3cache.push_back(sarg3);
	curScriptType_cache.push_back(curScriptType);
	curScriptNum_cache.push_back(curScriptNum);
	curScriptIndex_cache.push_back(curScriptIndex);
	sargvec_cache.push_back(sargvec);
	sargstr_cache.push_back(sargstr);
	ricache.push_back(ri);
	sdcache.push_back(curscript);
	stackcache.push_back(stack);
	ret_stack_cache.push_back(ret_stack);
}
void pop_ri()
{
	sarg1 = sarg1cache.back(); sarg1cache.pop_back();
	sarg2 = sarg2cache.back(); sarg2cache.pop_back();
	sarg3 = sarg3cache.back(); sarg3cache.pop_back();
	curScriptType = curScriptType_cache.back(); curScriptType_cache.pop_back();
	curScriptNum = curScriptNum_cache.back(); curScriptNum_cache.pop_back();
	curScriptIndex = curScriptIndex_cache.back(); curScriptIndex_cache.pop_back();
	sargvec = sargvec_cache.back(); sargvec_cache.pop_back();
	sargstr = sargstr_cache.back(); sargstr_cache.pop_back();
	ri = ricache.back(); ricache.pop_back();
	curscript = sdcache.back(); sdcache.pop_back();
	stack = stackcache.back(); stackcache.pop_back();
	ret_stack = ret_stack_cache.back(); ret_stack_cache.pop_back();
}

dword pc_calc(dword pc)
{
	if(curscript->meta.ffscript_v < 24)
		return pc + curscript->pc;
	return pc;
}

//START HELPER FUNCTIONS
///-------------------------------------//
//           Helper Functions           //
///-------------------------------------//

//ScriptHelper
class SH
{

///-----------------------------//
//           Errors             //
///-----------------------------//

public:

	enum __Error
	{
		_NoError, //OK!
		_Overflow, //script array too small
		_InvalidPointer, //passed NULL pointer or similar
		_OutOfBounds, //library array out of bounds
		_InvalidSpriteUID //bad npc, ffc, etc.
	};
	
#define INVALIDARRAY localRAM[0]  //localRAM[0] is never used
	
	//only if the player is messing with their pointers...
	static ZScriptArray& InvalidError(const int32_t ptr)
	{
		Z_scripterrlog("Invalid pointer (%i) passed to array (don't change the values of your array pointers)\n", ptr);
		return INVALIDARRAY;
	}
	
	static void write_stack(const uint32_t stackoffset, const int32_t value)
	{
		if(stackoffset >= MAX_SCRIPT_REGISTERS)
		{
			Z_scripterrlog("Stack over or underflow, stack pointer = %ld\n", stackoffset);
			return;
		}
		
		(*stack)[stackoffset] = value;
	}
	
	static int32_t read_stack(const uint32_t stackoffset)
	{
		if(stackoffset >= MAX_SCRIPT_REGISTERS)
		{
			Z_scripterrlog("Stack over or underflow, stack pointer = %ld\n", stackoffset);
			return -10000;
		}
		
		return (*stack)[stackoffset];
	}
	
	static INLINE int32_t get_arg(int32_t arg, bool v)
	{
		return v ? arg : get_register(arg);
	}
};

///----------------------------//
//           Misc.             //
///----------------------------//

byte flagpos;
int32_t flagval;
void clear_ornextflag()
{
	flagpos = 0;
	flagval = 0;
}
void ornextflag(bool flag)
{
	if(flag) flagval |= 1<<flagpos;
	++flagpos;
}

int32_t get_screenflags(mapscr *m, int32_t flagset)
{
	clear_ornextflag();
	
	switch(flagset)
	{
		case 0: // Room Type
			ornextflag(m->flags6&1);
			ornextflag(m->flags6&2);
			ornextflag(m->flags7&8);
			break;
			
		case 1: // View
			ornextflag(m->flags3&8);
			ornextflag(m->flags7&16);
			ornextflag(m->flags3&16);
			ornextflag(m->flags3&64);
			ornextflag(m->flags7&2);
			ornextflag(m->flags7&1);
			ornextflag(m->flags&fDARK);
			ornextflag(m->flags9&fDARK_DITHER);
			ornextflag(m->flags9&fDARK_TRANS);
			break;
			
		case 2: // Secrets
			ornextflag(m->flags&1);
			ornextflag(m->flags5&16);
			ornextflag(m->flags6&4);
			ornextflag(m->flags6&32);
			break;
			
		case 3: // Warp
			ornextflag(m->flags5&4);
			ornextflag(m->flags5&8);
			ornextflag(m->flags&64);
			ornextflag(m->flags8&64);
			ornextflag(m->flags3&32);
			ornextflag(m->flags9&fDISABLE_MIRROR);
			break;
			
		case 4: // Item
			ornextflag(m->flags3&1);
			ornextflag(m->flags7&4);
			ornextflag(m->flags8&0x40);
			ornextflag(m->flags8&0x80);
			ornextflag(m->flags9&0x01);
			ornextflag(m->flags9&0x02);
			ornextflag(m->flags9&0x04);
			break;
			
		case 5: // Combo
			ornextflag((m->flags2>>4)&2);
			ornextflag(m->flags3&2);
			ornextflag(m->flags5&2);
			ornextflag(m->flags6&64);
			break;
			
		case 6: // Save
			ornextflag(m->flags4&64);
			ornextflag(m->flags4&128);
			ornextflag(m->flags6&8);
			ornextflag(m->flags6&16);
			break;
			
		case 7: // FFC
			ornextflag(m->flags6&128);
			ornextflag(m->flags5&128);
			break;
			
		case 8: // Whistle
			ornextflag(m->flags&16);
			ornextflag(m->flags7&64);
			ornextflag(m->flags7&128);
			break;
			
		case 9: // Misc
			ornextflag(m->flags&32);
			ornextflag(m->flags5&64);
			flagval |= m->flags8<<2;
			break;
	}
	
	return flagval*10000;
}

int32_t get_screeneflags(mapscr *m, int32_t flagset)
{
	clear_ornextflag();
	
	switch(flagset)
	{
		case 0:
			flagval |= m->enemyflags&0x1F;
			break;
			
		case 1:
			ornextflag(m->enemyflags&32);
			ornextflag(m->enemyflags&64);
			ornextflag(m->flags3&4);
			ornextflag(m->enemyflags&128);
			ornextflag((m->flags2>>4)&4);
			break;
			
		case 2:
			ornextflag(m->flags3&128);
			ornextflag(m->flags&2);
			ornextflag((m->flags2>>4)&8);
			ornextflag(m->flags4&16);
			ornextflag(m->flags9&fENEMY_WAVES);
			break;
	}
	
	return flagval*10000;
}

int32_t get_mi(int32_t ref = MAPSCR_TEMP0)
{
	if(ref >= 0)
	{
		if(ref%MAPSCRS >= MAPSCRSNORMAL) return -1;
		return ref - (8*(ref / MAPSCRS));
	}
	switch(ref)
	{
		case MAPSCR_TEMP0: case MAPSCR_TEMP1: case MAPSCR_TEMP2: case MAPSCR_TEMP3: 
		case MAPSCR_TEMP4: case MAPSCR_TEMP5: case MAPSCR_TEMP6:
			if(homescr >= MAPSCRSNORMAL) return -1;
			return (currmap*MAPSCRSNORMAL)+homescr;
		case MAPSCR_SCROLL0: case MAPSCR_SCROLL1: case MAPSCR_SCROLL2: case MAPSCR_SCROLL3:
		case MAPSCR_SCROLL4: case MAPSCR_SCROLL5: case MAPSCR_SCROLL6:
			if(scrolling_scr >= MAPSCRSNORMAL) return -1;
			return (scrolling_map*MAPSCRSNORMAL)+scrolling_scr;
	}
	return -1;
}

int32_t get_total_mi(int32_t ref = MAPSCR_TEMP0)
{
	if(ref >= 0)
		return ref;
	switch(ref)
	{
		case MAPSCR_TEMP0: case MAPSCR_TEMP1: case MAPSCR_TEMP2: case MAPSCR_TEMP3: 
		case MAPSCR_TEMP4: case MAPSCR_TEMP5: case MAPSCR_TEMP6:
			return (currmap*MAPSCRS)+currscr;
		case MAPSCR_SCROLL0: case MAPSCR_SCROLL1: case MAPSCR_SCROLL2: case MAPSCR_SCROLL3:
		case MAPSCR_SCROLL4: case MAPSCR_SCROLL5: case MAPSCR_SCROLL6:
			return (scrolling_map*MAPSCRS)+scrolling_scr;
	}
	return -1;
}

///------------------------------------------------//
//           Bounds Checking Functions             //
///------------------------------------------------//

//Bounds Checker
class BC : public SH
{
public:

	static INLINE int32_t checkMapID(const int32_t ID, const char * const str)
	{
		//return checkBounds(ID, 0, map_count-1, str);
		if(ID < 0 || ID > map_count-1)
		{
			Z_scripterrlog("Invalid value (%i) passed to '%s'\n", ID+1, str);
			return _OutOfBounds;
		}
		
		return _NoError;
	}
	
	static INLINE int32_t checkDMapID(const int32_t ID, const char * const str)
	{
		return checkBounds(ID, 0, MAXDMAPS-1, str);
	}
	
	static INLINE int32_t checkComboPos(const int32_t pos, const char * const str)
	{
		return checkBoundsPos(pos, 0, 175, str);
	}
	
	static INLINE int32_t checkTile(const int32_t pos, const char * const str)
	{
		return checkBounds(pos, 0, NEWMAXTILES-1, str);
	}
	
	static INLINE int32_t checkCombo(const int32_t pos, const char * const str)
	{
		return checkBounds(pos, 0, MAXCOMBOS-1, str);
	}
	
	static INLINE int32_t checkMisc(const int32_t a, const char * const str)
	{
		return checkBounds(a, 0, 15, str);
	}
	
	 static INLINE int32_t checkMisc32(const int32_t a, const char * const str)
	{
		return checkBounds(a, 0, 31, str);
	}
	
	static INLINE int32_t checkMessage(const int32_t ID, const char * const str)
	{
		return checkBounds(ID, 0, msg_strings_size-1, str);
	}
	
	static INLINE int32_t checkLayer(const int32_t layer, const char * const str)
	{
		return checkBounds(layer, 0, 6, str);
	}
	
	static INLINE int32_t checkFFC(const int32_t ffc, const char * const str)
	{
		return checkBounds(ffc, 0, MAXFFCS-1, str);
	}
	
	static INLINE int32_t checkGuyIndex(const int32_t index, const char * const str)
	{
		return checkBoundsOneIndexed(index, 0, guys.Count()-1, str);
	}
	
	static INLINE int32_t checkItemIndex(const int32_t index, const char * const str)
	{
		return checkBoundsOneIndexed(index, 0, items.Count()-1, str);
	}
	
	static INLINE int32_t checkEWeaponIndex(const int32_t index, const char * const str)
	{
		return checkBoundsOneIndexed(index, 0, Ewpns.Count()-1, str);
	}
	
	static INLINE int32_t checkLWeaponIndex(const int32_t index, const char * const str)
	{
		return checkBoundsOneIndexed(index, 0, Lwpns.Count()-1, str);
	}
	
	static INLINE int32_t checkGuyID(const int32_t ID, const char * const str)
	{
		//return checkBounds(ID, 0, MAXGUYS-1, str); //Can't create NPC ID 0
		return checkBounds(ID, 1, MAXGUYS-1, str);
	}
	
	static INLINE int32_t checkItemID(const int32_t ID, const char * const str)
	{
		return checkBounds(ID, 0, MAXITEMS-1, str);
	}
	
	static INLINE int32_t checkWeaponID(const int32_t ID, const char * const str)
	{
		return checkBounds(ID, 0, MAXWPNS-1, str);
	}
	
	static INLINE int32_t checkWeaponMiscSprite(const int32_t ID, const char * const str)
	{
		return checkBounds(ID, 0, MAXWPNS-1, str);
	}
	
	static INLINE int32_t checkSFXID(const int32_t ID, const char * const str)
	{
		return checkBounds(ID, 0, WAV_COUNT-1, str);
	}
	
	static INLINE int32_t checkBounds(const int32_t n, const int32_t boundlow, const int32_t boundup, const char * const funcvar)
	{
		if(n < boundlow || n > boundup)
		{
			Z_scripterrlog("Invalid value (%i) passed to '%s'\n", n, funcvar);
			return _OutOfBounds;
		}
		
		return _NoError;
	}
	
	static INLINE int32_t checkBoundsPos(const int32_t n, const int32_t boundlow, const int32_t boundup, const char * const funcvar)
	{
		if(n < boundlow || n > boundup)
		{
			Z_scripterrlog("Invalid position [%i] used to read to '%s'\n", n, funcvar);
			return _OutOfBounds;
		}
        
		return _NoError;
	}
	
	static INLINE int32_t checkBoundsOneIndexed(const int32_t n, const int32_t boundlow, const int32_t boundup, const char * const funcvar)
	{
		if(n < boundlow || n > boundup)
		{
			Z_scripterrlog("Invalid value (%i) passed to '%s'\n", n+1, funcvar);
			return _OutOfBounds;
		}
		
		return _NoError;
	}
	
	static INLINE int32_t checkUserArrayIndex(const int32_t index, const dword size, const bool neg = false)
	{
		
		if(index < (neg ? -int32_t(size) : 0) || index >= int32_t(size))
		{
			Z_scripterrlog("Invalid index (%ld) to local array of size %ld\n", index, size);
			return _OutOfBounds;
		}
		
		return _NoError;
	}
};

///------------------------------------------------//
//           Pointer Handling Functions          //
///------------------------------------------------//
//MUST call AND check load functions before trying to use other functions


	

//Guy Helper
class GuyH : public SH
{

public:
	static int32_t loadNPC(const int32_t eid, const char * const funcvar)
	{
		if ( !eid ) 
		{
			//can never be zero?
			Z_scripterrlog("The npc pointer used for %s is NULL or uninitialised.", funcvar);
			return _InvalidSpriteUID;
		}
		tempenemy = (enemy *) guys.getByUID(eid);
		
		if(tempenemy == NULL)
		{
			Z_scripterrlog("Invalid NPC with UID %ld passed to %s\nNPCs on screen have UIDs ", eid, funcvar);
			
			for(word i = 0; i < guys.Count(); i++)
				Z_scripterrlog("%ld ", guys.spr(i)->getUID());
				
			Z_scripterrlog("\n");
			return _InvalidSpriteUID;
		}
		
		return _NoError;
	}
	
	static INLINE enemy *getNPC()
	{
		return tempenemy;
	}
	
	// Currently only used in a context where the enemy is known to be valid,
	// so there's no need to print an error
	static int32_t getNPCIndex(const int32_t eid)
	{
		for(word i = 0; i < guys.Count(); i++)
		{
			if(guys.spr(i)->getUID() == eid)
				return i;
		}
		
		return -1;
	}
	
	static int32_t getNPCDMisc(const byte a)
	{
		switch(a)
		{
			case 0: return tempenemy->dmisc1;
			case 1: return tempenemy->dmisc2;
			case 2: return tempenemy->dmisc3;
			case 3: return tempenemy->dmisc4;
			case 4: return tempenemy->dmisc5;
			case 5: return tempenemy->dmisc6;
			case 6: return tempenemy->dmisc7;
			case 7: return tempenemy->dmisc8;
			case 8: return tempenemy->dmisc9;
			case 9: return tempenemy->dmisc10;
			case 10: return tempenemy->dmisc11;
			case 11: return tempenemy->dmisc12;
			case 12: return tempenemy->dmisc13;
			case 13: return tempenemy->dmisc14;
			case 14: return tempenemy->dmisc15;
			case 15: return tempenemy->dmisc16;
			case 16: return tempenemy->dmisc17;
			case 17: return tempenemy->dmisc18;
			case 18: return tempenemy->dmisc19;
			case 19: return tempenemy->dmisc20;
			case 20: return tempenemy->dmisc21;
			case 21: return tempenemy->dmisc22;
			case 22: return tempenemy->dmisc23;
			case 23: return tempenemy->dmisc24;
			case 24: return tempenemy->dmisc25;
			case 25: return tempenemy->dmisc26;
			case 26: return tempenemy->dmisc27;
			case 27: return tempenemy->dmisc28;
			case 28: return tempenemy->dmisc29;
			case 29: return tempenemy->dmisc30;
			case 30: return tempenemy->dmisc31;
			case 31: return tempenemy->dmisc32;
		}
		
		return 0;
	}
	
	static bool hasHero()
	{
		if(tempenemy->family == eeWALLM)
			return ((eWallM *) tempenemy)->hashero;
			
		if(tempenemy->family == eeWALK)
			return ((eStalfos *) tempenemy)->hashero;
			
		return false;
	}
	
	static int32_t getMFlags()
	{
		clear_ornextflag();
		flagpos = 5;
		// Must be in the same order as in the Enemy Editor pane
		ornextflag(tempenemy->flags&(lens_only));
		ornextflag(tempenemy->flags2&(guy_flashing));
		ornextflag(tempenemy->flags2&(guy_blinking));
		ornextflag(tempenemy->flags2&(guy_transparent));
		ornextflag(tempenemy->flags&(inv_front));
		ornextflag(tempenemy->flags&(inv_left));
		ornextflag(tempenemy->flags&(inv_right));
		ornextflag(tempenemy->flags&(inv_back));
		ornextflag(tempenemy->flags&(guy_bkshield));
		return (tempenemy->flags&0x1F) | flagval;
	}
	
	static INLINE void clearTemp()
	{
		tempenemy = NULL;
	}
	
private:

	static enemy *tempenemy;
};

enemy *GuyH::tempenemy = NULL;

//Item Helper
class ItemH : public SH
{

public:
	static int32_t loadItem(const int32_t iid, const char * const funcvar)
	{
		if ( !iid ) 
		{
			//can never be zero?
			Z_scripterrlog("The item pointer used for %s is NULL or uninitialised.", funcvar);
			return _InvalidSpriteUID;
		}
		
		tempitem = (item *) items.getByUID(iid);
		
		if(tempitem == NULL)
		{
			Z_scripterrlog("Invalid item with UID %ld passed to %s\nItems on screen have UIDs ", iid, funcvar);
			
			for(word i = 0; i < items.Count(); i++)
				Z_scripterrlog("%ld ", items.spr(i)->getUID());
				
			Z_scripterrlog("\n");
			return _InvalidSpriteUID;
		}
		
		return _NoError;
	}
	
	static int32_t getItemIndex(const int32_t iid)
	{
		for(word i = 0; i < items.Count(); i++)
		{
			if(items.spr(i)->getUID() == iid)
				return i;
		}
		
		return -1;
	}
	
	static INLINE item* getItem()
	{
		return tempitem;
	}
	
	static INLINE void clearTemp()
	{
		tempitem = NULL;
	}
	
private:

	static item *tempitem;
};

item *ItemH::tempitem = NULL;

//LWeapon Helper
class LwpnH : public SH
{

public:
	

	static defWpnSprite getDefWeaponSprite(weapon *wp)
	{
		switch(wp->id)
		{
			case wNone: return ws_0;
			case wSword: return ws_0;
			case wBeam: return wsBeam;
			case wBrang : return wsBrang;
			case wBomb: return wsBomb;
			case wSBomb: return wsSBomb;
			case wLitBomb: return wsBombblast;
			case wLitSBomb: return wsBombblast;
			case wArrow: return wsArrow;
			case wRefArrow: return wsArrow;
			case wFire: return wsFire;
			case wRefFire: return wsFire;
			case wRefFire2: return wsFire;
			case wWhistle: return wsUnused45;
			case wBait: return wsBait;
			case wWand: return wsWandHandle;
			case wMagic: return wsMagic;
			case wCatching: return wsUnused45;
			case wWind: return wsWind;
			case wRefMagic: return wsRefMagic;
			case wRefFireball: return wsRefFireball;
			case wRefRock: return wsRock;
			case wHammer: return wsHammer;
			case wHookshot: return wsHookshotHead;
			case wHSHandle: return wsHookshotHandle;
			case wHSChain: return wsHookshotChainH;
			case wSSparkle: return wsSilverSparkle;
			case wFSparkle: return wsGoldSparkle;
			case wSmack: return wsHammerSmack;
			case wPhantom: return wsUnused45;
			case wCByrna: return wsByrnaCane;
			case wRefBeam: return wsRefBeam;
			case wStomp: return wsUnused45;
			case lwMax: return wsUnused45;
			case wScript1: 
			case wScript2:
			case wScript3:
			case wScript4:
			case wScript5:
			case wScript6:
			case wScript7:
			case wScript8:
			case wScript9:
			case wScript10: return ws_0;
			case wIce: return wsIce; //new
			case wFlame: return wsEFire2; //new
			//not implemented; t/b/a
			case wSound:
			case wThrown: 
			case wPot:
			case wLit:
			case wBombos:
			case wEther:
			case wQuake:
			case wSword180:
			case wSwordLA:  return wsUnused45;
		
			case ewFireball: return wsFireball2;
			case ewArrow: return wsEArrow;
			case ewBrang: return wsBrang;
			case ewSword: return wsEBeam;
			case ewRock: return wsRock;
			case ewMagic: return wsEMagic;
			case ewBomb: return wsEBomb;
			case ewSBomb: return wsESbomb;
			case ewLitBomb: return wsEBombblast;
			case ewLitSBomb: return wsESbombblast;
			case ewFireTrail: return wsEFiretrail;
			case ewFlame: return wsEFire;
			case ewWind: return wsEWind;
			case ewFlame2: return wsEFire2;
			case ewFlame2Trail: return wsEFiretrail2;
			case ewIce: return wsIce;
			case ewFireball2: return wsFireball2;
			default: return wsUnused45;
		}
	};
	
	static int32_t loadWeapon(const int32_t wid, const char * const funcvar)
	{
		if ( !wid ) 
		{
			//can never be zero?
			Z_scripterrlog("The lweapon pointer used for %s is NULL or uninitialised.", funcvar);
			return _InvalidSpriteUID;
		}
		tempweapon = (weapon *) Lwpns.getByUID(wid);
		
		if(tempweapon == NULL)
		{
			Z_scripterrlog("Invalid lweapon with UID %ld passed to %s\nLWeapons on screen have UIDs ", wid, funcvar);
			
			for(word i = 0; i < Lwpns.Count(); i++)
				Z_scripterrlog("%ld ", Lwpns.spr(i)->getUID());
				
			Z_scripterrlog("\n");
			return _InvalidSpriteUID;
		}
		
		return _NoError;
	}
	
	static int32_t getLWeaponIndex(const int32_t lwid)
	{
		for(word i = 0; i < Lwpns.Count(); i++)
		{
			if(Lwpns.spr(i)->getUID() == lwid)
				return i;
		}
		
		return -1;
	}
	
	static INLINE weapon *getWeapon()
	{
		return tempweapon;
	}
	
	static INLINE void clearTemp()
	{
		tempweapon = NULL;
	}
	
private:

	static weapon *tempweapon;
};

weapon *LwpnH::tempweapon = NULL;

//EWeapon Helper
class EwpnH : public SH
{

public:
	
	defWpnSprite getDefWeaponSprite(weapon *wp)
	{
		switch(wp->id)
		{
			case wNone: return ws_0;
			case wSword: return ws_0;
			case wBeam: return wsBeam;
			case wBrang : return wsBrang;
			case wBomb: return wsBomb;
			case wSBomb: return wsSBomb;
			case wLitBomb: return wsBombblast;
			case wLitSBomb: return wsBombblast;
			case wArrow: return wsArrow;
			case wRefArrow: return wsArrow;
			case wFire: return wsFire;
			case wRefFire: return wsFire;
			case wRefFire2: return wsFire;
			case wWhistle: return wsUnused45;
			case wBait: return wsBait;
			case wWand: return wsWandHandle;
			case wMagic: return wsMagic;
			case wCatching: return wsUnused45;
			case wWind: return wsWind;
			case wRefMagic: return wsRefMagic;
			case wRefFireball: return wsRefFireball;
			case wRefRock: return wsRock;
			case wHammer: return wsHammer;
			case wHookshot: return wsHookshotHead;
			case wHSHandle: return wsHookshotHandle;
			case wHSChain: return wsHookshotChainH;
			case wSSparkle: return wsSilverSparkle;
			case wFSparkle: return wsGoldSparkle;
			case wSmack: return wsHammerSmack;
			case wPhantom: return wsUnused45;
			case wCByrna: return wsByrnaCane;
			case wRefBeam: return wsRefBeam;
			case wStomp: return wsUnused45;
			case lwMax: return wsUnused45;
			case wScript1: 
			case wScript2:
			case wScript3:
			case wScript4:
			case wScript5:
			case wScript6:
			case wScript7:
			case wScript8:
			case wScript9:
			case wScript10: return ws_0;
			case wIce: return wsIce; //new
			case wFlame: return wsEFire2; //new
			//not implemented; t/b/a
			case wSound:
			case wThrown: 
			case wPot:
			case wLit:
			case wBombos:
			case wEther:
			case wQuake:
			case wSword180:
			case wSwordLA:  return wsUnused45;
		
			case ewFireball: return wsFireball2;
			case ewArrow: return wsEArrow;
			case ewBrang: return wsBrang;
			case ewSword: return wsEBeam;
			case ewRock: return wsRock;
			case ewMagic: return wsEMagic;
			case ewBomb: return wsEBomb;
			case ewSBomb: return wsESbomb;
			case ewLitBomb: return wsEBombblast;
			case ewLitSBomb: return wsESbombblast;
			case ewFireTrail: return wsEFiretrail;
			case ewFlame: return wsEFire;
			case ewWind: return wsEWind;
			case ewFlame2: return wsEFire2;
			case ewFlame2Trail: return wsEFiretrail2;
			case ewIce: return wsIce;
			case ewFireball2: return wsFireball2;
			default: return wsUnused45;
		}
	};

	static int32_t loadWeapon(const int32_t wid, const char * const funcvar)
	{
		if ( !wid ) 
		{
			//can never be zero?
			Z_scripterrlog("The eweapon pointer used for %s is NULL or uninitialised.", funcvar);
			return _InvalidSpriteUID;
		}
		tempweapon = (weapon *) Ewpns.getByUID(wid);
		
		if(tempweapon == NULL)
		{
			Z_scripterrlog("Invalid eweapon with UID %ld passed to %s\nEWeapons on screen have UIDs ", wid, funcvar);
			
			for(word i = 0; i < Ewpns.Count(); i++)
				Z_scripterrlog("%ld ", Ewpns.spr(i)->getUID());
				
			Z_scripterrlog("\n");
			return _InvalidSpriteUID;
		}
		
		return _NoError;
	}
	
	static int32_t getEWeaponIndex(const int32_t ewid)
	{
		for(word i = 0; i < Ewpns.Count(); i++)
		{
			if(Ewpns.spr(i)->getUID() == ewid)
				return i;
		}
		
		return -1;
	}
	
	static INLINE weapon *getWeapon()
	{
		return tempweapon;
	}
	
	static INLINE void clearTemp()
	{
		tempweapon = NULL;
	}
	
private:

	static weapon *tempweapon;
};

weapon *EwpnH::tempweapon = NULL;

void clearScriptHelperData()
{
	GuyH::clearTemp();
	ItemH::clearTemp();
	LwpnH::clearTemp();
	EwpnH::clearTemp();
}
////END HELPER FUNCTIONS

static int32_t numInstructions = 0; // Used to detect hangs
static bool scriptCanSave = true;

static ScriptEngineData& get_script_engine_data(ScriptType type, int index)
{
	if (type == ScriptType::DMap || type == ScriptType::OnMap || type == ScriptType::ScriptedPassiveSubscreen || type == ScriptType::ScriptedActiveSubscreen)
	{
		// `index` is used for dmapref, not for different script engine data.
		index = 0;
	}
	if (type == ScriptType::EngineSubscreen)
	{
		// `index` is used for subdataref, not for different script engine data.
		index = 0;
	}
	
	return scriptEngineDatas[{type, index}];
}

static ScriptEngineData& get_script_engine_data(ScriptType type)
{
	return get_script_engine_data(type, 0);
}

void FFScript::clear_script_engine_data()
{
	scriptEngineDatas.clear();
}

void FFScript::reset_script_engine_data(ScriptType type, int index)
{
	get_script_engine_data(type, index).reset();
}

void on_reassign_script_engine_data(ScriptType type, int index)
{
	auto& data = get_script_engine_data(type, index);
	data.ref.Clear();
	data.initialized = false;
	FFScript::deallocateAllScriptOwned(type, index);
}

void FFScript::clear_script_engine_data(ScriptType type, int index)
{
	if (type == ScriptType::DMap || type == ScriptType::OnMap || type == ScriptType::ScriptedPassiveSubscreen || type == ScriptType::ScriptedActiveSubscreen)
	{
		// `index` is used for dmapref, not for different script engine data.
		index = 0;
	}
	if (type == ScriptType::EngineSubscreen)
	{
		// `index` is used for subdataref, not for different script engine data.
		index = 0;
	}

	auto it = scriptEngineDatas.find({type, index});
	if (it != scriptEngineDatas.end())
	{
		scriptEngineDatas.erase(it);
	}
}

void FFScript::clear_script_engine_data_of_type(ScriptType type)
{
	std::erase_if(scriptEngineDatas, [&](auto& kv) { return kv.first.first == type; });
}

refInfo& FFScript::ref(ScriptType type, int index)
{
	return get_script_engine_data(type, index).ref;
}

byte& FFScript::doscript(ScriptType type, int index)
{
	if (type == ScriptType::Generic && unsigned(index) < NUMSCRIPTSGENERIC)
		return user_genscript::get(index).doscript();
	return get_script_engine_data(type, index).doscript;
}

bool& FFScript::waitdraw(ScriptType type, int index)
{
	return get_script_engine_data(type, index).waitdraw;
}

// Returns true if registers had to be initialized.
static bool set_current_script_engine_data(ScriptType type, int script, int index)
{
	bool got_initialized = false;

	auto& data = get_script_engine_data(type, index);
	ri = &data.ref;
	stack = &data.stack;
	ret_stack = &data.ret_stack;
	
	switch (type)
	{
		case ScriptType::FFC:
		{
			curscript = ffscripts[script];

			if (!data.initialized)
			{
				got_initialized = true;
				memcpy(ri->d, tmpscr->ffcs[index].initd, 8 * sizeof(int32_t));
				memcpy(ri->a, tmpscr->ffcs[index].inita, 2 * sizeof(int32_t));
				data.initialized = true;
			}

			ri->ffcref = index;
		}
		break;
		
		case ScriptType::NPC:
		{
			auto indx = GuyH::getNPCIndex(index);
			enemy *spr = (enemy*)guys.spr(indx);
			curscript = guyscripts[script];
			
			if (!data.initialized)
			{
				got_initialized = true;
				memcpy(ri->d, spr->initD, 8 * sizeof(int32_t));
				data.initialized = 1;
			}
			
			ri->guyref = index;
		}
		break;
		
		case ScriptType::Lwpn:
		{
			auto indx = LwpnH::getLWeaponIndex(index);
			weapon *spr = (weapon*)Lwpns.spr(indx);
			curscript = lwpnscripts[script];
			
			if (!data.initialized)
			{
				got_initialized = true;
				memcpy(ri->d, spr->weap_initd, 8 * sizeof(int32_t));
				data.initialized = 1;
			}
			
			ri->lwpn = index;
		}
		break;
		
		case ScriptType::Ewpn:
		{
			auto indx = EwpnH::getEWeaponIndex(index);
			weapon *spr = (weapon*)Ewpns.spr(indx);
			curscript = ewpnscripts[script];
			
			if (!data.initialized)
			{
				got_initialized = true;
				memcpy(ri->d, spr->weap_initd, 8 * sizeof(int32_t));
				data.initialized = 1;
			}
			
			ri->ewpn = index;
		}
		break;
		
		case ScriptType::ItemSprite:
		{
			auto indx = ItemH::getItemIndex(index);
			item *spr = (item*)items.spr(indx);
			curscript = itemspritescripts[script];
			
			if (!data.initialized)
			{
				got_initialized = true;
				memcpy(ri->d, spr->initD, 8 * sizeof(int32_t));
				data.initialized = 1;
			}
			
			ri->itemref = index;
		}
		break;
		
		case ScriptType::Item:
		{
			int32_t i = index;
			int32_t new_i = 0;
			bool collect = ( ( i < 1 ) || (i == COLLECT_SCRIPT_ITEM_ZERO) );
			new_i = ( collect ) ? (( i != COLLECT_SCRIPT_ITEM_ZERO ) ? (i * -1) : 0) : i;

			curscript = itemscripts[script];
			
			if (!data.initialized)
			{
				got_initialized = true;
				memcpy(ri->d, ( collect ) ? itemsbuf[new_i].initiald : itemsbuf[i].initiald, 8 * sizeof(int32_t));
				memcpy(ri->a, ( collect ) ? itemsbuf[new_i].initiala : itemsbuf[i].initiala, 2 * sizeof(int32_t));
				data.initialized = true;
			}			
			ri->idata = ( collect ) ? new_i : i; //'this' pointer
		}
		break;
		
		case ScriptType::Global:
		{
			curscript = globalscripts[script];
			if (!data.initialized)
			{
				got_initialized = true;
				data.initialized = 1;
			}
		}
		break;
		
		case ScriptType::Generic:
		{
			user_genscript& scr = user_genscript::get(script);
			curscript = genericscripts[script];
			scr.waitevent = false;
			if(!data.initialized)
			{
				got_initialized = true;
				scr.initd.copy_to(ri->d, 8);
				data.initialized = true;
			}
			ri->genericdataref = script;
		}
		break;
		
		case ScriptType::GenericFrozen:
		{
			user_genscript& scr = user_genscript::get(script);
			curscript = genericscripts[script];
			if(!data.initialized)
			{
				got_initialized = true;
				scr.initd.copy_to(ri->d, 8);
				data.initialized = true;
			}
			ri->genericdataref = script;
		}
		break;
		
		case ScriptType::Player:
		{
			curscript = playerscripts[script];
			if (!data.initialized)
			{
				got_initialized = true;
				data.initialized = 1;
			}
		}
		break;
		
		case ScriptType::DMap:
		{
			curscript = dmapscripts[script];
			ri->dmapsref = index;
			//how do we clear initialised on dmap change?
			if ( !data.initialized )
			{
				got_initialized = true;
				for ( int32_t q = 0; q < 8; q++ ) 
				{
					ri->d[q] = DMaps[ri->dmapsref].initD[q];// * 10000;
				}
				data.initialized = true;
			}
		}
		break;
		
		case ScriptType::OnMap:
		{
			curscript = dmapscripts[script];
			ri->dmapsref = index;
			if (!data.initialized)
			{
				got_initialized = true;
				for ( int32_t q = 0; q < 8; q++ ) 
				{
					ri->d[q] = DMaps[ri->dmapsref].onmap_initD[q];
				}
				data.initialized = true;
			}
		}
		break;
		
		case ScriptType::ScriptedActiveSubscreen:
		{
			curscript = dmapscripts[script];
			ri->dmapsref = index;
			if (!data.initialized)
			{
				got_initialized = true;
				for ( int32_t q = 0; q < 8; q++ ) 
				{
					ri->d[q] = DMaps[ri->dmapsref].sub_initD[q];
				}
				data.initialized = true;
			}
		}
		break;
		
		case ScriptType::ScriptedPassiveSubscreen:
		{
			curscript = dmapscripts[script];
			ri->dmapsref = index;
			if (!data.initialized)
			{
				got_initialized = true;
				for ( int32_t q = 0; q < 8; q++ ) 
				{
					ri->d[q] = DMaps[ri->dmapsref].sub_initD[q];
				}
				data.initialized = true;
			}
		}
		break;
		case ScriptType::EngineSubscreen:
		{
			curscript = subscreenscripts[script];
			ri->subdataref = get_subref(-1, sstACTIVE);
			auto [ptr,_ty] = load_subdata(ri->subdataref);
			
			if (ptr && !data.initialized)
			{
				got_initialized = true;
				for ( int32_t q = 0; q < 8; q++ ) 
				{
					ri->d[q] = ptr->initd[q];
				}
				data.initialized = true;
			}
		}
		break;
		
		case ScriptType::Screen:
		{
			curscript = screenscripts[script];

			if (!data.initialized)
			{
				got_initialized = true;
				for ( int32_t q = 0; q < 8; q++ ) 
				{
					ri->d[q] = tmpscr->screeninitd[q];// * 10000;
				}
				data.initialized = true;
			}
		}
		break;
		
		case ScriptType::Combo:
		{
			curscript = comboscripts[script];

			int32_t pos = combopos_ref_to_pos(index);
			int32_t lyr = combopos_ref_to_layer(index);
			int32_t id = FFCore.tempScreens[lyr]->data[pos];
			if (!data.initialized)
			{
				got_initialized = true;
				memset(ri->d, 0, 8 * sizeof(int32_t));
				for ( int32_t q = 0; q < 8; q++ )
					ri->d[q] = combobuf[id].initd[q];
				data.initialized = true;
			}

			ri->combosref = id; //'this' pointer
			ri->comboposref = index; //used for X(), Y(), Layer(), and so forth.
			break;
		}
	}
	
	if(got_initialized)
		ri->pc = curscript->pc;
	
	return got_initialized;
}

int32_t ffmisc[MAXFFCS][16];

int32_t genscript_timing = SCR_TIMING_START_FRAME;
static word max_valid_genscript;

void user_genscript::clear()
{
	wait_atleast = true;
	waituntil = SCR_TIMING_START_FRAME;
	waitevent = false;
	exitState = 0;
	reloadState = 0;
	eventstate = 0;
	initd.clear();
	data.clear();
	quit();
}
void user_genscript::launch()
{
	quit();
	doscript() = true;
	wait_atleast = true;
	waituntil = SCR_TIMING_START_FRAME;
	waitevent = false;
}
void user_genscript::quit()
{
	if(indx > -1)
	{
		FFCore.clear_script_engine_data(ScriptType::Generic, indx);
		FFCore.deallocateAllScriptOwned(ScriptType::Generic, indx);
	}
	_doscript = false;
}
byte& user_genscript::doscript()
{
	return _doscript;
}
byte const& user_genscript::doscript() const
{
	return _doscript;
}


user_genscript& user_genscript::get(int ind)
{
	if(ind < 1 || ind >= NUMSCRIPTSGENERIC)
		ind = 0;
	user_scripts[ind].indx = ind;
	return user_scripts[ind];
}
user_genscript user_genscript::user_scripts[NUMSCRIPTSGENERIC];

void countGenScripts()
{
	max_valid_genscript = 0;
	for(auto q = 1; q < NUMSCRIPTSGENERIC; ++q)
	{
		if(genericscripts[q] && genericscripts[q]->valid())
			max_valid_genscript = q;
	}
}
void timeExitAllGenscript(byte exState)
{
	for(auto q = 1; q <= max_valid_genscript; ++q)
		user_genscript::get(q).timeExit(exState);
}
void throwGenScriptEvent(int32_t event)
{
	for(auto q = 1; q <= max_valid_genscript; ++q)
	{
		user_genscript& scr = user_genscript::get(q);
		if(!scr.doscript()) continue;
		if(!genericscripts[q]->valid()) continue;
		if(!scr.waitevent) continue;
		if(scr.eventstate & (1<<event))
		{
			auto& data = get_script_engine_data(ScriptType::Generic, q);
			data.ref.d[rEXP1] = event*10000;
			scr.waitevent = false;
			
			//Run the script!
			ZScriptVersion::RunScript(ScriptType::Generic, q, q);
		}
	}
}

void load_genscript(const gamedata& gd)
{
	for(size_t q = 0; q < NUMSCRIPTSGENERIC; ++q)
	{
		user_genscript& gen = user_genscript::get(q);
		gen.clear();
		gen.doscript() = gd.gen_doscript.get(q);
		gen.exitState = gd.gen_exitState[q];
		gen.reloadState = gd.gen_reloadState[q];
		gen.eventstate = gd.gen_eventstate[q];
		gen.initd = gd.gen_initd[q];
		gen.data = gd.gen_data[q];
	}
}
void load_genscript(const zinitdata& zd)
{
	for(size_t q = 0; q < NUMSCRIPTSGENERIC; ++q)
	{
		user_genscript& gen = user_genscript::get(q);
		gen.clear();
		gen.doscript() = zd.gen_doscript.get(q);
		gen.exitState = zd.gen_exitState[q];
		gen.reloadState = zd.gen_reloadState[q];
		gen.eventstate = zd.gen_eventstate[q];
		gen.initd = zd.gen_initd[q];
		gen.data = zd.gen_data[q];
	}
}

void save_genscript(gamedata& gd)
{
	for(size_t q = 0; q < NUMSCRIPTSGENERIC; ++q)
	{
		user_genscript const& gen = user_genscript::get(q);
		gd.gen_doscript.set(q, gen.doscript());
		gd.gen_exitState[q] = gen.exitState;
		gd.gen_reloadState[q] = gen.reloadState;
		gd.gen_eventstate[q] = gen.eventstate;
		gd.gen_initd[q] = gen.initd;
		gd.gen_data[q] = gen.data;
	}
}

void FFScript::runGenericPassiveEngine(int32_t scrtm)
{
	if(!max_valid_genscript) return; //No generic scripts in the quest!
	//zprint2("Processing timing %d\n", scrtm);
	bool init = (scrtm == SCR_TIMING_INIT);
	if(!init)
	{
		if(genscript_timing != scrtm)
		{
			//zprint2("Generic script timing jump: expected '%d', found '%d'\n", genscript_timing, scrtm);
			while(genscript_timing != scrtm)
				runGenericPassiveEngine(genscript_timing);
		}
	}
	for(auto q = 1; q <= max_valid_genscript; ++q)
	{
		user_genscript& scr = user_genscript::get(q);
		if(!scr.doscript()) continue;
		if(!genericscripts[q]->valid()) continue;
		if(scr.waitevent) continue;
		if(!init && (scr.waituntil > scrtm || (!scr.wait_atleast && scr.waituntil != scrtm)))
			continue;
		
		//Run the script!
		ZScriptVersion::RunScript(ScriptType::Generic, q, q);
	}
	if(init || genscript_timing >= SCR_TIMING_END_FRAME)
		genscript_timing = SCR_TIMING_START_FRAME;
	else ++genscript_timing;
}

void FFScript::initZScriptDMapScripts()
{
	scriptEngineDatas[{ScriptType::DMap, 0}] = ScriptEngineData();
	scriptEngineDatas[{ScriptType::ScriptedPassiveSubscreen, 0}] = ScriptEngineData();
}

void FFScript::initZScriptSubscreenScript()
{
	scriptEngineDatas[{ScriptType::EngineSubscreen, 0}] = ScriptEngineData();
}
void FFScript::initZScriptScriptedActiveSubscreen()
{
	scriptEngineDatas[{ScriptType::ScriptedActiveSubscreen, 0}] = ScriptEngineData();
}

void FFScript::initZScriptOnMapScript()
{
	scriptEngineDatas[{ScriptType::OnMap, 0}] = ScriptEngineData();
}

void FFScript::initZScriptHeroScripts()
{
	scriptEngineDatas[{ScriptType::Player, 0}] = ScriptEngineData();
}

void FFScript::initZScriptItemScripts()
{
	for ( int32_t q = 0; q < 256; q++ )
	{
		auto& data = get_script_engine_data(ScriptType::Item, q);
		data.reset();
		data.doscript = (itemsbuf[q].flags&ITEM_PASSIVESCRIPT) && game->item[q];
	}

	for ( int32_t q = -256; q < 0; q++ )
	{
		auto& data = get_script_engine_data(ScriptType::Item, q);
		data.reset();
		data.doscript = 0;
	}
}

static int get_mouse_state(int index)
{
	int value = 0;
	if (replay_is_replaying())
	{
		value = replay_get_mouse(index);
	}
	else if (index == 0)
	{
		value = script_mouse_x;
	}
	else if (index == 1)
	{
		value = script_mouse_y;
	}
	else if (index == 2)
	{
		value = script_mouse_z;
	}
	else if (index == 3)
	{
		value = script_mouse_b;
	}

	if (replay_is_recording())
	{
		replay_set_mouse(index, value);
	}

	return value;
}

///---------------------------------------------//
//           Array Helper Functions           //
///---------------------------------------------//

#define ZCARRAY_MAX_SIZE 214748
class ArrayManager
{
public:
	ArrayManager(int32_t ptr, bool neg);
	ArrayManager(int32_t ptr);
	
	int32_t get(int32_t indx) const;
	void set(int32_t indx, int32_t val);
	int32_t size() const;
	
	bool resize(size_t newsize);
	bool resize_min(size_t minsz);
	bool can_resize();
	bool push(int32_t val, int indx = -1);
	int32_t pop(int indx = -1);
	
	bool invalid() const {return _invalid;}
	bool internal() const {return !_invalid && !aptr;}
	
	std::string asString(std::function<char const*(int32_t)> formatter, const size_t& limit) const;
	
	bool negAccess;
private:
	int32_t ptr;
	ZScriptArray* aptr;
	bool _invalid;
};

//Array Helper
class ArrayH : public SH
{
public:
	static size_t getSize(const int32_t ptr)
	{
		ArrayManager am(ptr);
		return am.size();
	}
	
	//Can't you get the std::string and then check its length?
	static int32_t strlen(const int32_t ptr)
	{
		ArrayManager am(ptr);
		if (am.invalid() || am.size() == 0)
			return -1;
			
		word count;
		size_t sz = am.size();
		for(count = 0; BC::checkUserArrayIndex(count, sz) == _NoError
			&& am.get(count) != '\0'; count++);
		
		return count;
	}
	
	//Returns values of a zscript array as an std::string.
	static void getString(const int32_t ptr, string &str, dword num_chars = ZSCRIPT_MAX_STRING_CHARS, dword offset = 0)
	{
		ArrayManager am(ptr);
		
		if(am.invalid())
		{
			str.clear();
			return;
		}
		
		str.clear();
		size_t sz = am.size();
		for(word i = offset; BC::checkUserArrayIndex(i, sz) == _NoError && am.get(i) != '\0' && num_chars != 0; i++)
		{
			int32_t c = am.get(i) / 10000;
			if(byte(c) != c)
			{
				Z_scripterrlog("Illegal char value (%d) at position [%d] in string pointer %d\n", c, i, ptr);
				Z_scripterrlog("Value of invalid char will overflow.\n");
			}
			str += byte(c);
			--num_chars;
		}
	}
	
	//Used for issues where reading the ZScript array floods the console with errors 'Accessing array index [12] size of 12.
	//Happens with Quad3D and some other functions, and I have no clue why. -Z ( 28th April, 2019 )
	//Like getString but for an array of longs instead of chars. *(arrayPtr is not checked for validity)
	static void getValues2(const int32_t ptr, int32_t* arrayPtr, dword num_values, dword offset = 0) //a hack -Z
	{
		ArrayManager am(ptr);
		
		if(am.invalid())
			return;
		
		size_t sz = am.size();
		for(word i = offset; BC::checkUserArrayIndex(i, sz+1) == _NoError && num_values != 0; i++)
		{
			arrayPtr[i] = (am.get(i) / 10000);
			num_values--;
		}
	}
	
	//Like getString but for an array of longs instead of chars. *(arrayPtr is not checked for validity)
	static void getValues(const int32_t ptr, int32_t* arrayPtr, dword num_values, dword offset = 0)
	{
		ArrayManager am(ptr);
		
		if (am.invalid())
			return;
		size_t sz = am.size();
		for(word i = offset; num_values != 0 && BC::checkUserArrayIndex(i, sz) == _NoError; i++)
		{
			arrayPtr[i] = (am.get(i) / 10000);
			num_values--;
		}
	}
	
	static void copyValues(const int32_t ptr, const int32_t ptr2, size_t num_values)
	{
		ArrayManager am1(ptr), am2(ptr2);
		if(am1.invalid() || am2.invalid())
			return;
		size_t sz = std::min(am1.size(),am2.size());
		for(word i = 0; (BC::checkUserArrayIndex(i, sz) == _NoError) && num_values != 0; i++)
		{
			am1.set(i,am2.get(i));
			num_values--;
		}
	}
	//Get element from array
	static INLINE int32_t getElement(const int32_t ptr, int32_t offset,
		const bool neg = false)
	{
		ArrayManager am(ptr,neg);
		return am.get(offset);
	}
	
	//Set element in array
	static INLINE void setElement(const int32_t ptr, int32_t offset,
		const int32_t value, const bool neg = false)
	{
		ArrayManager am(ptr,neg);
		am.set(offset,value);
	}
	
	//Puts values of a zscript array into a client <type> array. returns 0 on success. Overloaded
	template <typename T>
	static int32_t getArray(const int32_t ptr, T *refArray)
	{
		return getArray(ptr, getSize(ptr), 0, 0, 0, refArray);
	}
	
	template <typename T>
	static int32_t getArray(const int32_t ptr, const size_t size, T *refArray)
	{
		return getArray(ptr, size, 0, 0, 0, refArray);
	}
	
	template <typename T>
	static int32_t getArray(const int32_t ptr, const size_t size, size_t userOffset, const size_t userStride, const size_t refArrayOffset, T *refArray)
	{
		ArrayManager am(ptr);
		
		if (am.invalid())
			return _InvalidPointer;
			
		size_t j = 0, k = userStride;
		
		size_t sz = am.size();
		for(size_t i = 0; j < size; i++)
		{
			if(i >= sz)
				return _Overflow;
				
			if(userOffset-- > 0)
				continue;
				
			if(k > 0)
				k--;
			else if(BC::checkUserArrayIndex(i, sz) == _NoError)
			{
				refArray[j + refArrayOffset] = T(am.get(i));
				k = userStride;
				j++;
			}
		}
		
		return _NoError;
	}
	
	static int32_t setArray(const int32_t ptr, string const& s2, bool resize = false)
	{
		ArrayManager am(ptr);
		
		if (am.invalid())
			return _InvalidPointer;
		
		size_t i;
		
		if(am.can_resize() && resize)
			am.resize_min(s2.size()+1);
		
		size_t sz = am.size();
		for(i = 0; i < s2.size(); i++)
		{
			if(i >= sz)
			{
				am.set(sz-1,'\0');
				return _Overflow;
			}
			
			if(BC::checkUserArrayIndex(i, sz) == _NoError)
				am.set(i,s2[i] * 10000);
		}
		
		if(BC::checkUserArrayIndex(i, sz) == _NoError)
			am.set(i,'\0');
			
		return _NoError;
	}
	
	//Puts values of a client <type> array into a zscript array. returns 0 on success. Overloaded
	template <typename T>
	static int32_t setArray(const int32_t ptr, const size_t size, T *refArray, bool x10k = true, bool resize = false)
	{
		return setArray(ptr, size, 0, 0, 0, refArray, x10k, resize);
	}
	
	template <typename T>
	static int32_t setArray(const int32_t ptr, const size_t size, word userOffset, const word userStride, const word refArrayOffset, T *refArray, bool x10k = true, bool resize = false)
	{
		ArrayManager am(ptr);
		
		if (am.invalid())
			return _InvalidPointer;
		
		if(am.can_resize() && resize)
			am.resize_min((userStride+1)*size);
			
		word j = 0, k = userStride;
		size_t sz = am.size();
		for(word i = 0; j < size; i++)
		{
			if(i >= sz)
				return _Overflow; //Resize?
				
			if (userOffset > 0)
			{
				--userOffset;
				continue;
			}
				
			if(k > 0)
				k--;
			else if(BC::checkUserArrayIndex(i, sz) == _NoError)
			{
				am.set(i,int32_t(refArray[j + refArrayOffset]) * (x10k ? 10000 : 1));
				k = userStride;
				j++;
			}
		}
		
		return _NoError;
	}
};

ArrayManager::ArrayManager(int32_t ptr, bool neg) : negAccess(neg), ptr(ptr)
{
	_invalid = false;
	if(ptr >= INTARR_OFFS)
	{
		aptr = nullptr;
		if(sz_int_arr(ptr) < 0)
			_invalid = true;
	}
	else if(ptr == 0)
	{
		aptr = &INVALIDARRAY;
		_invalid = true;
	}
	else if(ptr < 0) //An object array?
	{
		int32_t objptr = -ptr;
		auto it = objectRAM.find(objptr);
		if(it == objectRAM.end())
		{
			aptr = &INVALIDARRAY;
			_invalid = true;
		}
		else aptr = &(it->second);
	}
	else if(ptr >= NUM_ZSCRIPT_ARRAYS) //Then it's a global
	{
		dword gptr = ptr - NUM_ZSCRIPT_ARRAYS;
		
		if(gptr > game->globalRAM.size())
		{
			aptr = &INVALIDARRAY;
			_invalid = true;
		}
		else aptr = &(game->globalRAM[gptr]);
	}
	else
	{
		if(!localRAM[ptr].Valid())
		{
			aptr = &INVALIDARRAY;
			_invalid = true;
		}
		else aptr = &(localRAM[ptr]);
	}
	if(_invalid)
	{
		Z_scripterrlog("Invalid pointer (%i) passed to array "
			"(don't change the values of your array pointers)\n", ptr);
	}
}
ArrayManager::ArrayManager(int32_t ptr) : ArrayManager(ptr,can_neg_array){}

int32_t ArrayManager::get(int32_t indx) const
{
	if(_invalid) return -10000;
	int32_t sz = size();
	if(aptr)
	{
		if(BC::checkUserArrayIndex(indx, sz, negAccess) == SH::_NoError)
		{
			if(indx < 0)
				indx += sz; //[-1] becomes [size-1] -Em
			return (*aptr)[indx];
		}
	}
	else //internal special array
	{
		if(sz >= 0 && BC::checkUserArrayIndex(indx, sz, negAccess) == SH::_NoError)
		{
			if(indx < 0)
				indx += sz; //[-1] becomes [size-1] -Em
			return get_int_arr(ptr, indx);
		}
	}
	return -10000;
}
void ArrayManager::set(int32_t indx, int32_t val)
{
	if(_invalid) return;
	int32_t sz = size();
	if(aptr)
	{
		if(BC::checkUserArrayIndex(indx, sz, negAccess) == SH::_NoError)
		{
			if(indx < 0)
				indx += sz; //[-1] becomes [size-1] -Em
			if (aptr->HoldsObjects())
			{
				int id = (*aptr)[indx];
				script_object_ref_dec(id);
			}
			(*aptr)[indx] = val;
			if (aptr->HoldsObjects())
				script_object_ref_inc(val);
		}
	}
	else //internal special array
	{
		if(sz >= 0 && BC::checkUserArrayIndex(indx, sz, negAccess) == SH::_NoError)
		{
			if(indx < 0)
				indx += sz; //[-1] becomes [size-1] -Em
			set_int_arr(ptr, indx, val);
		}
	}
}
int32_t ArrayManager::size() const
{
	if(_invalid) return -1;
	if(aptr)
		return aptr->Size();
	else // Internal special
	{
		int32_t sz = sz_int_arr(ptr);
		if(sz < 0)
			return -1;
		return sz;
	}
}

bool ArrayManager::resize(size_t newsize)
{
	if(_invalid) return false;
	if(!aptr)
	{
		Z_scripterrlog("Special internal array '%d' not valid for operation 'Resize'\n", ptr);
		return false;
	}
	if (aptr->HoldsObjects())
	{
		for (int i = newsize; i < aptr->Size(); i++)
		{
			auto id = (*aptr)[i];
			script_object_ref_dec(id);
		}
	}
	aptr->Resize(newsize);
	return true;
}
bool ArrayManager::resize_min(size_t newsize)
{
	if(size() >= newsize)
		return true;
	return resize(newsize);
}
bool ArrayManager::can_resize()
{
	if(_invalid || !aptr)
		return false;
	return true;
}

bool ArrayManager::push(int32_t val, int indx)
{
	if(_invalid) return false;
	if(!aptr)
	{
		Z_scripterrlog("Special internal array '%d' not valid for operation 'Push'\n", ptr);
		return false;
	}
	if(aptr->Size() == ZCARRAY_MAX_SIZE)
		return false;
	aptr->Push(val,indx);
	if (aptr->HoldsObjects())
		script_object_ref_inc(val);
	return true;
}
int32_t ArrayManager::pop(int indx)
{
	if(_invalid) return -10000;
	if(!aptr)
	{
		Z_scripterrlog("Special internal array '%d' not valid for operation 'Push'\n", ptr);
		return -10000;
	}
	if(aptr->Empty())
	{
		Z_scripterrlog("Array %d had nothing to Pop!\n",ptr);
		return -10000;
	}
	int32_t val = aptr->Pop(indx);
	if (aptr->HoldsObjects())
		script_object_ref_dec(val);
	return val;
}

std::string ArrayManager::asString(std::function<char const*(int32_t)> formatter, const size_t& limit) const
{
	if(_invalid) return "{ INVALID ARRAY }";
	std::ostringstream oss;
	oss << "{ ";
	size_t s = size();
	bool overflow = limit < s;
	if(overflow)
		s = limit;
	
	for(auto q = 0; q < s; ++q)
	{
		oss << formatter(get(q));
		if (q + 1 < s)
			oss << ", ";
	}
	if (overflow)
		oss << ", ...";
	oss << " }";
	return oss.str();
}

// TODO: this is a dupe of FFScript::deallocateZScriptArray
// Called to deallocate arrays when a script stops running
void deallocateArray(const int32_t ptrval)
{
	if(ptrval == 0) return;
	if(ptrval==0 || ptrval >= NUM_ZSCRIPT_ARRAYS)
		Z_scripterrlog("Script tried to deallocate memory at invalid address %ld\n", ptrval);
	else if(ptrval<0)
		Z_scripterrlog("Script tried to deallocate memory at object-based address %ld\n", ptrval);
	else
	{
		if(arrayOwner[ptrval].specOwned) return; //ignore this deallocation
		if(arrayOwner[ptrval].specCleared) return;
		arrayOwner[ptrval].clear();
		
		if(!localRAM[ptrval].Valid())
			Z_scripterrlog("Script tried to deallocate memory that was not allocated at address %ld\n", ptrval);
		else
		{
			if (localRAM[ptrval].HoldsObjects())
			{
				auto&& aptr = localRAM[ptrval];
				for (int i = 0; i < aptr.Size(); i++)
				{
					auto id = aptr[i];
					script_object_ref_dec(id);
				}
			}
			localRAM[ptrval].Clear();
		}
	}
}

void FFScript::deallocateAllScriptOwned(ScriptType scriptType, const int32_t UID, bool requireAlways)
{
	std::vector<uint32_t> ids_to_clear;
	for (auto& script_object : script_objects | std::views::values)
	{
		if (script_object->own_clear(scriptType, UID))
		{
			ids_to_clear.push_back(script_object->id);
		}
	}
	if (ZScriptVersion::gc())
	{
		for (auto id : ids_to_clear)
			script_object_ref_dec(id);
	}
	else
	{
		for (auto id : ids_to_clear)
			delete_script_object(id);
	}

	if(requireAlways && !get_qr(qr_ALWAYS_DEALLOCATE_ARRAYS))
	{
		//Keep 2.50.2 behavior if QR unchecked.
		switch(scriptType)
		{
			case ScriptType::FFC:
			case ScriptType::Item:
			case ScriptType::Global:
				return;
		}
	}
	//Z_eventlog("Attempting array deallocation from %s UID %d\n", script_types[scriptType], UID);
	for(int32_t i = 1; i < NUM_ZSCRIPT_ARRAYS; i++)
	{
		if(arrayOwner[i].own_clear(scriptType,UID))
			deallocateArray(i);
	}
}

void FFScript::deallocateAllScriptOwned()
{
	std::vector<uint32_t> ids_to_clear;
	for (auto& script_object : script_objects | std::views::values)
	{
		if (script_object->own_clear_any())
		{
			ids_to_clear.push_back(script_object->id);
		}
	}
	if (ZScriptVersion::gc())
	{
		for (auto id : ids_to_clear)
			script_object_ref_dec(id);
	}
	else
	{
		for (auto id : ids_to_clear)
			delete_script_object(id);
	}

	//No QR check here- always deallocate on quest exit.
	for(int32_t i = 1; i < NUM_ZSCRIPT_ARRAYS; i++)
	{
		if(localRAM[i].Valid())
		{
			// Unowned arrays are ALSO deallocated!
			arrayOwner[i].clear();
			deallocateArray(i);
		}
	}
}

void FFScript::deallocateAllScriptOwnedCont()
{
	std::vector<uint32_t> ids_to_clear;
	for (auto& script_object : script_objects | std::views::values)
	{
		if (script_object->own_clear_cont())
		{
			ids_to_clear.push_back(script_object->id);
		}
	}
	if (ZScriptVersion::gc())
	{
		for (auto id : ids_to_clear)
			script_object_ref_dec(id);
	}
	else
	{
		for (auto id : ids_to_clear)
			delete_script_object(id);
	}

	//No QR check here- always deallocate on quest exit.
	for(int32_t i = 1; i < NUM_ZSCRIPT_ARRAYS; i++)
	{
		if(localRAM[i].Valid())
		{
			if(arrayOwner[i].own_clear_cont())
				deallocateArray(i);
		}
	}
}

item *checkItem(int32_t iid)
{
	item *s = (item *)items.getByUID(iid);
	
	if(s == NULL)
	{
		Z_eventlog("Script attempted to reference a nonexistent item!\n");
		Z_eventlog("You were trying to reference an item with UID = %ld; Items on screen are UIDs ", iid);
		
		for(int32_t i=0; i<items.Count(); i++)
		{
			Z_eventlog("%ld ", items.spr(i)->getUID());
		}
		
		Z_eventlog("\n");
		return NULL;
	}
	
	return s;
}

weapon *checkLWpn(int32_t eid, const char *what)
{
	weapon *s = (weapon *)Lwpns.getByUID(eid);
	if(s == NULL) //check lifted weapon
	{
		weapon* lw = Hero.lift_wpn;
		if(lw && lw->getUID() == eid)
			s = lw;
	}
	if(s == NULL)
	{
	
		Z_eventlog("Script attempted to reference a nonexistent LWeapon!\n");
		Z_eventlog("You were trying to reference the %s of an LWeapon with UID = %ld; LWeapons on screen are UIDs ", what, eid);
		
		for(int32_t i=0; i<Lwpns.Count(); i++)
		{
			Z_eventlog("%ld ", Lwpns.spr(i)->getUID());
		}
		
		Z_eventlog("\n");
		return NULL;
	}
	
	return s;
}

weapon *checkEWpn(int32_t eid, const char *what)
{
	weapon *s = (weapon *)Ewpns.getByUID(eid);
	
	if(s == NULL)
	{
	
		Z_eventlog("Script attempted to reference a nonexistent EWeapon!\n");
		Z_eventlog("You were trying to reference the %s of an EWeapon with UID = %ld; EWeapons on screen are UIDs ", what, eid);
		
		for(int32_t i=0; i<Ewpns.Count(); i++)
		{
			Z_eventlog("%ld ", Ewpns.spr(i)->getUID());
		}
		
		Z_eventlog("\n");
		return NULL;
	}
	
	return s;
}

user_file *checkFile(int32_t ref, const char *what, bool req_file = false, bool skipError = false)
{
	user_file* file = user_files.check(ref, what, skipError);
	if (file && req_file && !file->file)
	{
		if (skipError) return NULL;
		Z_scripterrlog("Script attempted to reference an invalid file!\n");
		Z_scripterrlog("File with UID = %ld does not have an open file connection!\n", ref);
		Z_scripterrlog("Use '->Open()' or '->Create()' to hook to a system file.\n");
		return NULL;
	}
	return file;
}

user_object *checkObject(int32_t ref, bool skipError = false)
{
	return user_objects.check(ref, nullptr, skipError);
}

user_genscript *checkGenericScr(int32_t ref, const char *what)
{
	if(ref < 1 || ref >= NUMSCRIPTSGENERIC)
	{
		Z_scripterrlog("Invalid gendata pointer access (%ld) for '->%s'\n", ref, what);
		return NULL;
	}
	return &user_genscript::get(ref);
}
extern portal mirror_portal;
portal *checkPortal(int32_t ref, const char *what, bool skiperr = false)
{
	if(ref == -1)
		return &mirror_portal;
	portal* p = (portal*)portals.getByUID(ref);
	if(!p)
	{
		if(!skiperr)
			Z_scripterrlog("Invalid portal pointer access (%ld) for '->%s'\n", ref, what);
		return nullptr;
	}
	return p;
}

savedportal *checkSavedPortal(int32_t ref, const char* what, bool skiperr = false)
{
	savedportal* sp = game->getSavedPortal(ref);
	if(!sp)
	{
		if(!skiperr)
			Z_scripterrlog("Invalid savedportal pointer access (%ld) for '->%s'\n", ref, what);
		return nullptr;
	}
	return sp;
}
int32_t getPortalFromSaved(savedportal* p)
{
	if(p == &(game->saved_mirror_portal))
		return -1;
	portal* prtl = nullptr;
	portals.forEach([&](sprite& spr)
	{
		portal* tmp = (portal*)&spr;
		if(p->getUID() == tmp->saved_data)
		{
			prtl = tmp;
			return true;
		}
		return false;
	});
	return prtl ? prtl->getUID() : 0;
}

user_dir *checkDir(int32_t ref, const char *what, bool skipError = false)
{
	return user_dirs.check(ref, what, skipError);
}

user_stack *checkStack(int32_t ref, const char *what, bool skipError = false)
{
	return user_stacks.check(ref, nullptr, skipError);
}

user_rng *checkRNG(int32_t ref, const char *what, bool skipError = false)
{
	// A null RNG pointer is special-case, access engine rng.
	if (ref == 0) return &nulrng;
	return user_rngs.check(ref, nullptr, skipError);
}

user_paldata* checkPalData(int32_t ref, const char* what, bool skipError = false)
{
	return user_paldatas.check(ref, what, skipError);
}

bottletype *checkBottleData(int32_t ref, const char *what, bool skipError = false)
{
	if(ref > 0 && ref <= 64)
	{
		return &QMisc.bottle_types[ref-1];
	}
	if(skipError) return NULL;
	Z_scripterrlog("Script attempted to reference a nonexistent BottleData!\n");
	Z_scripterrlog("You were trying to reference the '%s' of a BottleData with UID = %ld\n", what, ref);
	return NULL;
}

bottleshoptype *checkBottleShopData(int32_t ref, const char *what, bool skipError = false)
{
	if(ref > 0 && ref <= 256)
	{
		return &QMisc.bottle_shop_types[ref-1];
	}
	if(skipError) return NULL;
	Z_scripterrlog("Script attempted to reference a nonexistent BottleShopData!\n");
	Z_scripterrlog("You were trying to reference the '%s' of a BottleShopData with UID = %ld\n", what, ref);
	return NULL;
}

user_bitmap *checkBitmap(int32_t ref, const char *what, bool req_valid = false, bool skipError = false)
{
	switch (ref - 10)
	{
		case rtSCREEN:
		case rtBMP0:
		case rtBMP1:
		case rtBMP2:
		case rtBMP3:
		case rtBMP4:
		case rtBMP5:
		case rtBMP6:
			zprint2("Internal error: 'checkBitmap()' recieved ref pointing to system bitmap!\n");
			zprint2("Please report this as a bug!\n");

			if(skipError) return NULL;
			Z_scripterrlog("Script attempted to reference a nonexistent bitmap!\n");
			if(what)
				Z_scripterrlog("You were trying to reference the '%s' of a bitmap with UID = %ld\n", what, ref);
			else
				Z_scripterrlog("You were trying to reference with UID = %ld\n", ref);
			return NULL;
			break;

		default:
		{
			user_bitmap* b = user_bitmaps.check(ref, what, skipError);
			if (req_valid && (!b || !b->u_bmp))
			{
				if (skipError) return NULL;
				Z_scripterrlog("Script attempted to reference an invalid bitmap!\n");
				Z_scripterrlog("Bitmap with UID = %ld does not have a valid memory bitmap!\n",ref);
				Z_scripterrlog("Use '->Create()' to create a memory bitmap.\n");
				return NULL;
			}
			return b;
		}
	}
}

extern const std::string subscr_names[sstMAX];
ZCSubscreen *checkSubData(int32_t ref, const char *what, int req_ty = -1)
{
	auto [ptr,ty] = load_subdata(ref);
	if(ptr)
	{
		if(req_ty < 0 || req_ty == ty)
			return ptr;
		else
		{
			Z_scripterrlog("Wrong type of SubscreenData accessed! Expecting type '%s', but found '%s'\n",
				subscr_names[req_ty].c_str(), subscr_names[ty].c_str());
		}
	}
	else Z_scripterrlog("Script attempted to reference a nonexistent SubscreenData!\n");
	
	Z_scripterrlog("You were trying to reference the '%s' of a SubscreenData with UID = %ld\n", what, ref);
	return NULL;
}
SubscrPage *checkSubPage(int32_t ref, const char *what, int req_ty = -1)
{
	auto [ptr,ty] = load_subpage(ref);
	if(ptr)
	{
		if(req_ty < 0 || req_ty == ty)
			return ptr;
		else
		{
			Z_scripterrlog("Wrong type of Subscreen accessed! Expecting type '%s', but found '%s'\n",
				subscr_names[req_ty].c_str(), subscr_names[ty].c_str());
		}
	}
	else Z_scripterrlog("Script attempted to reference a nonexistent SubscreenPage!\n");
	
	Z_scripterrlog("You were trying to reference the '%s' of a SubscreenPage with UID = %ld\n", what, ref);
	return NULL;
}
SubscrWidget *checkSubWidg(int32_t ref, const char *what, int req_widg_ty = -1, int req_sub_ty = -1)
{
	auto [ptr,ty] = load_subwidg(ref);
	if(ptr)
	{
		if(req_sub_ty < 0 || req_sub_ty == ty)
		{
			if(req_widg_ty < 0 || req_widg_ty == ptr->getType())
				return ptr;
			else
			{
				auto listdata = GUI::ZCListData::subscr_widgets();
				Z_scripterrlog("Wrong type of SubscreenWidget accessed! Expecting type '%s', but found '%s'\n",
					listdata.findText(req_widg_ty).c_str(), listdata.findText(ptr->getType()).c_str());
			}
		}
		else
		{
			Z_scripterrlog("Wrong type of Subscreen accessed! Expecting subscreen type '%s', but found '%s'\n",
				subscr_names[req_sub_ty].c_str(), subscr_names[ty].c_str());
		}
	}
	else Z_scripterrlog("Script attempted to reference a nonexistent SubscreenWidget!\n");
	
	Z_scripterrlog("You were trying to reference the '%s' of a SubscreenWidget with UID = %ld\n", what, ref);
	return NULL;
}

void bad_subwidg_type(string const& name, bool func, byte type)
{
	auto tyname = type < widgMAX ? subwidg_internal_names[type].c_str() : "";
	Z_scripterrlog("Widget type %d '%s' does not have a '%s' %s!\n",
		type, tyname, name.c_str(),
		func ? "function" : "value");
}

// If scr is currently being used as a layer, return that layer no.
int32_t whichlayer(int32_t scr)
{
	for(int32_t i = 0; i < 6; i++)
	{
		if(scr == (tmpscr->layermap[i] - 1) * MAPSCRS + tmpscr->layerscreen[i])
			return i;
	}
	
	return -1;
}

sprite *s;

int32_t item_flag(int32_t flag)
{
	if(unsigned(ri->idata) >= MAXITEMS)
	{
		Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
		return 0;
	}
	return (itemsbuf[ri->idata].flags & flag) ? 10000 : 0;
}
void item_flag(int32_t flag, bool val)
{
	if(unsigned(ri->idata) >= MAXITEMS)
	{
		Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
		return;
	}
	SETFLAG(itemsbuf[ri->idata].flags, flag, val);
}

//Forward decl
int32_t do_msgheight(int32_t msg, char const* str);
int32_t do_msgwidth(int32_t msg, char const* str);
//

int32_t earlyretval = -1;
int32_t get_register(int32_t arg)
{
	int32_t ret = 0;
	
	//Macros
	
	#define GET_SPRITEDATA_VAR_INT(member, str) \
	{ \
		if(unsigned(ri->spritesref) > (MAXWPNS-1) )    \
		{ \
			ret = -10000; \
			Z_scripterrlog("Invalid Sprite ID passed to spritedata->%s: %d\n", str, (ri->spritesref*10000));\
		} \
		else \
			ret = (wpnsbuf[ri->spritesref].member * 10000); \
	}
	
	switch(arg)
	{
		
		case INCQST:
		{
			//zprint2("Incrementing Quest\n");
			int32_t newqst = 0;
			if ( game->get_quest() < 255 )  //255 is a custom quest
			{
				newqst = (game->get_quest()+1);
			}
			else
			{
				newqst = 1;
			}
			//zprint2("newqst is: %d\n", newqst);
			if ( newqst < 11 ) 
			{
			
				ret = newqst * 10000;
				Quit = qINCQST;
				//ending();
			
			}
			else ret = -10000;
			break;
		}
		//Debug->Null()
		case DONULL: 
			ret = 0;
			break;
		case DEBUGTESTING:
			ret = use_testingst_start ? 10000 : 0;
			break;
		
		//debug ri->d[]
		case DEBUGD:
		{
			int32_t a = ri->d[rINDEX] / 10000;
			ret = ri->d[a] * 10000;
			break;
		}
		
		///----------------------------------------------------------------------------------------------------//
		//FFC Variables
		case DATA:
			if(BC::checkFFC(ri->ffcref, "ffc->Data") == SH::_NoError)
				ret = tmpscr->ffcs[ri->ffcref].data *10000;
			break;
			
		case FFSCRIPT:
			if(BC::checkFFC(ri->ffcref, "ffc->Script") == SH::_NoError)
				ret = tmpscr->ffcs[ri->ffcref].script*10000;
			break;
			
		case FCSET:
			if(BC::checkFFC(ri->ffcref, "ffc->CSet") == SH::_NoError)
				ret = tmpscr->ffcs[ri->ffcref].cset*10000;
			break;
			
		case DELAY:
			if(BC::checkFFC(ri->ffcref, "ffc->Delay") == SH::_NoError)
				ret = tmpscr->ffcs[ri->ffcref].delay*10000;
			break;
			
		case FX:
			if(BC::checkFFC(ri->ffcref, "ffc->X") == SH::_NoError)
				ret = tmpscr->ffcs[ri->ffcref].x.getZLong();
			break;
			
		case FY:
			if(BC::checkFFC(ri->ffcref, "ffc->Y") == SH::_NoError)
				ret = tmpscr->ffcs[ri->ffcref].y.getZLong();
			break;
			
		case XD:
			if(BC::checkFFC(ri->ffcref, "ffc->Vx") == SH::_NoError)
				ret = tmpscr->ffcs[ri->ffcref].vx.getZLong();
			break;
			
		case YD:
			if(BC::checkFFC(ri->ffcref, "ffc->Vy") == SH::_NoError)
				ret = tmpscr->ffcs[ri->ffcref].vy.getZLong();
			break;
		case FFCID:
			if(BC::checkFFC(ri->ffcref, "ffc->ID") == SH::_NoError)
				ret=(ri->ffcref*10000)+10000;
			break;
			
		case XD2:
			if(BC::checkFFC(ri->ffcref, "ffc->Ax") == SH::_NoError)
				ret = tmpscr->ffcs[ri->ffcref].ax.getZLong();
			break;
			
		case YD2:
			if(BC::checkFFC(ri->ffcref, "ffc->Ay") == SH::_NoError)
				ret = tmpscr->ffcs[ri->ffcref].ay.getZLong();
			break;
			
		case FFFLAGSD:
			if(BC::checkFFC(ri->ffcref, "ffc->Flags[]") == SH::_NoError)
				ret=((tmpscr->ffcs[ri->ffcref].flags >> (ri->d[rINDEX] / 10000))&1) ? 10000 : 0;
			break;
			
		case FFCWIDTH:
			if(BC::checkFFC(ri->ffcref, "ffc->EffectWidth") == SH::_NoError)
				ret=(tmpscr->ffcs[ri->ffcref].hit_width*10000);
			break;
			
		case FFCHEIGHT:
			if(BC::checkFFC(ri->ffcref, "ffc->EffectHeight") == SH::_NoError)
				ret=(tmpscr->ffcs[ri->ffcref].hit_height*10000);
			break;
			
		case FFTWIDTH:
			if(BC::checkFFC(ri->ffcref, "ffc->TileWidth") == SH::_NoError)
				ret=(tmpscr->ffcs[ri->ffcref].txsz*10000);
			break;
			
		case FFTHEIGHT:
			if(BC::checkFFC(ri->ffcref, "ffc->TileHeight") == SH::_NoError)
				ret=(tmpscr->ffcs[ri->ffcref].tysz*10000);
			break;
			
		case FFLINK:
			if(BC::checkFFC(ri->ffcref, "ffc->Link") == SH::_NoError)
				ret=(tmpscr->ffcs[ri->ffcref].link)*10000;
			break;
			
		case FFMISCD:
		{
			int32_t a = ri->d[rINDEX] / 10000;
			
			if(BC::checkMisc(a, "ffc->Misc") != SH::_NoError)
				ret = -10000;
			else
			{
				if(BC::checkFFC(ri->ffcref, "ffc->Misc[]") == SH::_NoError)
					ret = ffmisc[ri->ffcref][a];
			}
		}
		break;
		
		case FFINITDD:
		{
			int32_t a = ri->d[rINDEX] / 10000;
			
			if(BC::checkBounds(a, 0, 7, "ffc->InitD") != SH::_NoError)
				ret = -10000;
			else
			{
				if(BC::checkFFC(ri->ffcref, "ffc->InitD[]") == SH::_NoError)
				ret = tmpscr->ffcs[ri->ffcref].initd[a];
			}
		}
		break;
		
		///----------------------------------------------------------------------------------------------------//
		//Hero's Variables
		case LINKX:
		{
			if (get_qr(qr_SPRITEXY_IS_FLOAT))
			{
				//double lx = (double)Hero.getX();
				//Z_scripterrlog("lx: %f\n", lx);
				
				//ret = lx * 10000;
				//zfix lx = Hero.getX();
				//Z_scripterrlog("lx: %d\n", lx);
				ret = Hero.getX().getZLong();
			}
			else ret = int32_t(Hero.getX()) * 10000;

			break;
		}
		
		case LINKCSET:
		{
			ret = Hero.cs * 10000;
			break;
		}		
		case LINKY:
		{
			if (get_qr(qr_SPRITEXY_IS_FLOAT))
			{
				ret = Hero.getY().getZLong();
			}
			else ret = int32_t(Hero.getY()) * 10000;

			break;
		}    
		case LINKZ:
		{
			if (get_qr(qr_SPRITEXY_IS_FLOAT))
			{
				ret = Hero.getZ().getZLong();
			}
			else ret = int32_t(Hero.getZ()) * 10000;

			break;
		} 
		case LINKJUMP:
			// -fall/100*10000, but doing it that way screwed up the result
			ret = Hero.getFall().getZLong() / -100;
			break;
			
		case HEROFAKEJUMP:
			ret = Hero.getFakeFall().getZLong() / -100;
			break;
			
		case LINKDIR:
			ret=(int32_t)(Hero.dir)*10000;
			break;
			
		case LINKHITDIR:
			ret=(int32_t)(Hero.getHitDir())*10000;
			break;
			
		case LINKHP:
			ret=(int32_t)(game->get_life())*10000;
			break;
		
		case LINKGRAVITY:
			ret = ( (Hero.moveflags & FLAG_OBEYS_GRAV) ? 10000 : 0 );
			break;
		
		case HERONOSTEPFORWARD:
			ret = ( (FFCore.nostepforward) ? 10000 : 0 );
			break;
			
		case LINKMP:
			ret=(int32_t)(game->get_magic())*10000;
			break;
			
		case LINKMAXHP:
			ret=(int32_t)(game->get_maxlife())*10000;
			break;
			
		case LINKMAXMP:
			ret=(int32_t)(game->get_maxmagic())*10000;
			break;
			
		case LINKACTION:
		{
			//Z_scripterrlog("The present FFCore action is: %d\n", FFCore.getHeroAction());
			//int32_t act = FFCore.getHeroAction() * 10000;
			ret = FFCore.getHeroAction() * 10000;
			//Z_scripterrlog("The present 'action' return value is: %d\n", act);
			//ret = act;
			//ret=(int32_t)(Hero.getAction())*10000;
			break;
		}
		
		case HEROHEALTHBEEP:
		{
			//Z_scripterrlog("The present FFCore action is: %d\n", FFCore.getHeroAction());
			//int32_t act = FFCore.getHeroAction() * 10000;
			ret = heart_beep ? ( heart_beep_timer * 10000 ) : 0;
			//Z_scripterrlog("The present 'action' return value is: %d\n", act);
			//ret = act;
			//ret=(int32_t)(Hero.getAction())*10000;
			break;
		}
			
		case LINKHELD:
			ret = (int32_t)(Hero.getHeldItem())*10000;
			break;
			
		case LINKITEMD:
			ret = game->item[vbound(ri->d[rINDEX]/10000, 0, MAXITEMS-1)] ? 10000 : 0;
			break;
		
		case HEROSTEPS:
			ret = lsteps[vbound(ri->d[rINDEX]/10000, 0, 7)] * 10000;
			break;
		
		case HEROSTEPRATE:
			ret = Hero.getStepRate() * 10000;
			break;
		case HEROSHOVEOFFSET:
			ret = Hero.shove_offset.getZLong();
			break;
			
		case LINKEQUIP:
			ret = ((Awpn&0xFF)|((Bwpn&0xFF)<<8))*10000;
			break;
			
		case LINKINVIS:
			ret = (((int32_t)(Hero.getDontDraw())) ? 10000 : 0);
			break;
			
		case LINKINVINC:
			ret = (int32_t)(Hero.scriptcoldet)*10000;
			break;
		
		case LINKENGINEANIMATE:
			ret = (int32_t)(Hero.do_animation)*10000;
			break;
			
		case LINKLADDERX:
			ret=(int32_t)(Hero.getLadderX())*10000;
			break;
			
		case LINKLADDERY:
			ret=(int32_t)(Hero.getLadderY())*10000;
			break;
			
		case LINKSWORDJINX:
			ret = (int32_t)(Hero.getSwordClk())*10000;
			break;
			
		case LINKITEMJINX:
			ret = (int32_t)(Hero.getItemClk())*10000;
			break;
			
		case LINKDRUNK:
			ret = (int32_t)(Hero.DrunkClock())*10000;
			break;
			
		case LINKMISCD:
			ret = (int32_t)(Hero.miscellaneous[vbound(ri->d[rINDEX]/10000,0,31)]); //Was this buffed before? -Z
			break;
		
		
		case LINKHITBY:
		{
			int32_t indx = ri->d[rINDEX]/10000;
			switch(indx)
			{
				//screen indices of objects
				case 0:
				case 1:
				case 2:
				case 3:
				case 8:
				case 9:
				case 10:
				case 11:
				case 12:
				case 16:
				{
					ret = (int32_t)(Hero.gethitHeroUID(indx))* 10000;
					break;
				}
				//uids of objects
				case 4:
				case 5:
				case 6:
				case 7:
				case 13:
				case 14:
				case 15:
				{
					ret = (int32_t)(Hero.gethitHeroUID(indx)); //do not multiply by 10000! UIDs are not *10000!
					break;
				}
				default: { Z_scripterrlog("Invalid index passed to Player->HitBy[%d]/n", indx); ret = -1; break; }
			}
			break;
		}
		case LINKDEFENCE:
			ret = (int32_t)(Hero.get_defence(vbound(ri->d[rINDEX]/10000,0,255)))* 10000;
			break;
			
			
		case LINKROTATION:
			if ( get_qr(qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"Player->Rotation");
				ret = -1; break;
			}
			ret = (int32_t)(Hero.rotation)*10000;
			break;
		
		case LINKSCALE:
		{
			if ( get_qr(qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"Player->Scale");
				ret = -1; break;
			}
			//al_trace("Player's scale is: %d\n", Hero.scale);
			ret = (int32_t)(Hero.scale*100.0);
			break;
		}
		

		case LINKHXOFS:
			ret = (int32_t)(Hero.hxofs)*10000;
			break;
			
		case LINKHYOFS:
			ret = (int32_t)(Hero.hyofs)*10000;
			break;
			
		case LINKXOFS:
			ret = (int32_t)(Hero.xofs)*10000;
			break;
			
		case LINKYOFS:
			ret = (int32_t)(Hero.yofs-(get_qr(qr_OLD_DRAWOFFSET)?playing_field_offset:original_playing_field_offset))*10000;
			break;
			
		case HEROSHADOWXOFS:
			ret = (int32_t)(Hero.shadowxofs)*10000;
			break;
			
		case HEROSHADOWYOFS:
			ret = (int32_t)(Hero.shadowyofs)*10000;
			break;
			
		case HEROTOTALDYOFFS:
			ret = 10000*(((int32_t)(Hero.yofs-(get_qr(qr_OLD_DRAWOFFSET)?playing_field_offset:original_playing_field_offset)))
				+ ((Hero.switch_hooked && Hero.switchhookstyle == swRISE)
					? -(8-(abs(Hero.switchhookclk-32)/4)) : 0));
			break;
			
		case LINKZOFS:
			ret = (int32_t)(Hero.zofs)*10000;
			break;
			
		case LINKHXSZ:
			ret = (int32_t)(Hero.hit_width)*10000;
			break;
			
		case LINKHYSZ:
			ret = (int32_t)(Hero.hit_height)*10000;
			break;
			
		case LINKHZSZ:
			ret = (int32_t)(Hero.hzsz)*10000;
			break;
			
		case LINKTXSZ:
			ret = (int32_t)(Hero.txsz)*10000;
			break;
			
		case LINKTYSZ:
			ret = (int32_t)(Hero.tysz)*10000;
			break;
			
		case LINKTILE:
			ret = (int32_t)(Hero.tile)*10000;
			break;
			
		case LINKFLIP:
			ret = (int32_t)(Hero.flip)*10000;
			break;
		
		case LINKINVFRAME:
			ret = (int32_t)Hero.getHClk()*10000;
			break;
		
		case LINKCANFLICKER:
			ret= Hero.getCanFlicker()?10000:0;
			break;
		case LINKHURTSFX:
			ret = (int32_t)Hero.getHurtSFX()*10000;
			break;
		
		/*
		case LINKUSINGITEM:
			ret = (int32_t)Hero.getDirectItem()*10000;
			break;
		
		case LINKUSINGITEMA:
			ret = (int32_t)Hero.getDirectItemA()*10000;
			break;
		
		case LINKUSINGITEMB:
			ret = (int32_t)Hero.getDirectItemB()*10000;
			break;
		*/
			
		case LINKEATEN:
			ret=(int32_t)Hero.getEaten()*10000;
			break;
		case LINKGRABBED:
			ret = Hero.inwallm ? 10000 : 0;
			break;
		case HEROBUNNY:
			ret = Hero.BunnyClock()*10000;
			break;
		case LINKPUSH:
			ret=(int32_t)Hero.getPushing()*10000;
			break;
		case LINKSTUN:
			ret=(int32_t)Hero.StunClock()*10000;
			break;
		case LINKSCRIPTTILE:
			ret=script_hero_sprite*10000;
			break;
		
		case HEROSCRIPTCSET:
			ret=script_hero_cset*10000;
			break;
		case LINKSCRIPFLIP:
			ret=script_hero_flip*10000;
			break;
			
			
		case LINKITEMB:
			//Hero->setBButtonItem(vbound((value/10000),0,(MAXITEMS-1)));
			ret = Bwpn*10000;
			break;
		
		case LINKITEMA:
			//Hero->setBButtonItem(vbound((value/10000),0,(MAXITEMS-1)));
			ret = Awpn *10000;
			break;
		
		case LINKITEMX:
			//Hero->setBButtonItem(vbound((value/10000),0,(MAXITEMS-1)));
			ret = Xwpn *10000;
			break;
		
		case LINKITEMY:
			//Hero->setBButtonItem(vbound((value/10000),0,(MAXITEMS-1)));
			ret = Ywpn *10000;
			break;
		
		case LINKTILEMOD:
			ret = Hero.getTileModifier() * 10000;
			break;
		
		case LINKDIAG:
			ret=Hero.getDiagMove()?10000:0;
			break;
		
		case LINKBIGHITBOX:
			ret=Hero.getBigHitbox()?10000:0;
			break;
		
		case LINKCLIMBING:
			ret = Hero.getOnSideviewLadder()?10000:0;
			break;
			
		case HEROJUMPCOUNT:
			ret = Hero.extra_jump_count * 10000;
			break;
		
		case HEROPULLDIR:
			ret = Hero.pit_pulldir * 10000;
			break;
		
		case HEROPULLCLK:
			ret = Hero.pit_pullclk * 10000;
			break;
		
		case HEROFALLCLK:
			ret = Hero.fallclk * 10000;
			break;
		
		case HEROFALLCMB:
			ret = Hero.fallCombo * 10000;
			break;
			
		case HERODROWNCLK:
			ret = Hero.drownclk * 10000;
			break;
		
		case HERODROWNCMB:
			ret = Hero.drownCombo * 10000;
			break;
			
		case HEROFAKEZ:
		{
			if (get_qr(qr_SPRITEXY_IS_FLOAT))
			{
				ret = Hero.getFakeZ().getZLong();
			}
			else ret = int32_t(Hero.getFakeZ()) * 10000;

			break;
		} 
		case HEROMOVEFLAGS:
		{
			int32_t indx = ri->d[rINDEX]/10000;
			if(BC::checkBounds(indx, 0, 10, "Hero->MoveFlags[]") != SH::_NoError)
				ret = 0; //false
			else
			{
				//All bits, in order, of a single byte; just use bitwise
				ret = (Hero.moveflags & (1<<indx)) ? 10000 : 0;
			}
			break;
		}
		case HEROLIFTFLAGS:
		{
			int32_t indx = ri->d[rINDEX]/10000;
			if(BC::checkBounds(indx, 0, NUM_LIFTFL-1, "Hero->LiftFlags[]") != SH::_NoError)
				ret = 0; //false
			else
			{
				ret = (Hero.liftflags & (1<<indx)) ? 10000 : 0;
			}
			break;
		}
		
		case HEROSHIELDJINX:
			ret = Hero.shieldjinxclk * 10000;
			break;
		
		case HEROISWARPING:
			ret = Hero.is_warping ? 10000L : 0L;
			break;
		
		case CLOCKACTIVE:
			ret=watch?10000:0;
			break;
		
		case CLOCKCLK:
			ret=clockclk*10000;
			break;
			
		case HERORESPAWNX:
		{
			ret = Hero.respawn_x.getZLong();
			break;
		}
		
		case HERORESPAWNY:
		{
			ret = Hero.respawn_y.getZLong();
			break;
		}
		
		case HERORESPAWNDMAP:
		{
			ret = Hero.respawn_dmap * 10000;
			break;
		}
		
		case HERORESPAWNSCR:
		{
			ret = Hero.respawn_scr * 10000;
			break;
		}
		
		case HEROSWITCHTIMER:
		{
			ret = Hero.switchhookclk * 10000;
			break;
		}
		
		case HEROSWITCHMAXTIMER:
		{
			ret = Hero.switchhookmaxtime * 10000;
			break;
		}
		
		case HEROIMMORTAL:
		{
			ret = Hero.immortal * 10000;
			break;
		}
		
		case HEROSTANDING:
		{
			ret = Hero.isStanding(true) ? 10000 : 0;
			break;
		}
		
		case HEROCOYOTETIME:
		{
			ret = Hero.coyotetime*10000;
			break;
		}
		
		case HEROLIFTEDWPN:
		{
			ret = Hero.lift_wpn ? Hero.lift_wpn->getUID() : 0;
			break;
		}
		case HEROLIFTTIMER:
		{
			ret = Hero.liftclk * 10000;
			break;
		}
		case HEROLIFTMAXTIMER:
		{
			ret = Hero.tliftclk * 10000;
			break;
		}
		case HEROLIFTHEIGHT:
		{
			ret = Hero.liftheight.getZLong();
			break;
		}
		case HEROHAMMERSTATE:
		{
			ret = Hero.getHammerState() * 10000;
			break;
		}
		case HEROFLICKERCOLOR:
			ret = (int32_t)(Hero.flickercolor) * 10000; break;
		case HEROFLASHINGCSET:
			ret = (int32_t)(Hero.getFlashingCSet()) * 10000; break;
		case HEROFLICKERTRANSP:
			ret = (int32_t)(Hero.flickertransp) * 10000; break;
		
		case HEROSLIDING:
			ret = Hero.sliding*10000; break;
		case HEROICECMB:
			ret = Hero.ice_combo*10000; break;
		case HEROSCRICECMB:
			ret = Hero.script_ice_combo*10000; break;
		case HEROICEVX:
			ret = Hero.ice_vx.getZLong(); break;
		case HEROICEVY:
			ret = Hero.ice_vy.getZLong(); break;
		case HEROICEENTRYFRAMES:
			ret = Hero.ice_entry_count*10000; break;
		case HEROICEENTRYMAXFRAMES:
			ret = Hero.ice_entry_mcount*10000; break;
		
		///----------------------------------------------------------------------------------------------------//
		//Input States
		case INPUTSTART:
			ret=control_state[6]?10000:0;
			break;
			
		case INPUTMAP:
			ret=control_state[9]?10000:0;
			break;
			
		case INPUTUP:
			ret=control_state[0]?10000:0;
			break;
			
		case INPUTDOWN:
			ret=control_state[1]?10000:0;
			break;
			
		case INPUTLEFT:
			ret=control_state[2]?10000:0;
			break;
			
		case INPUTRIGHT:
			ret=control_state[3]?10000:0;
			break;
			
		case INPUTA:
			ret=control_state[4]?10000:0;
			break;
			
		case INPUTB:
			ret=control_state[5]?10000:0;
			break;
			
		case INPUTL:
			ret=control_state[7]?10000:0;
			break;
			
		case INPUTR:
			ret=control_state[8]?10000:0;
			break;
			
		case INPUTEX1:
			ret=control_state[10]?10000:0;
			break;
			
		case INPUTEX2:
			ret=control_state[11]?10000:0;
			break;
			
		case INPUTEX3:
			ret=control_state[12]?10000:0;
			break;
			
		case INPUTEX4:
			ret=control_state[13]?10000:0;
			break;
			
		case INPUTAXISUP:
			ret=control_state[14]?10000:0;
			break;
			
		case INPUTAXISDOWN:
			ret=control_state[15]?10000:0;
			break;
			
		case INPUTAXISLEFT:
			ret=control_state[16]?10000:0;
			break;
			
		case INPUTAXISRIGHT:
			ret=control_state[17]?10000:0;
			break;
			
		case INPUTMOUSEX:
		{
			ret=get_mouse_state(0)*10000;
			break;
		}
		
		case INPUTMOUSEY:
		{
			int32_t mousequakeoffset = 56+((int32_t)(zc::math::Sin((double)(quakeclk*int64_t(2)-frame))*4));
			int32_t tempoffset = (quakeclk > 0) ? mousequakeoffset : (get_qr(qr_OLD_DRAWOFFSET)?playing_field_offset:original_playing_field_offset);
			ret=((get_mouse_state(1)-tempoffset))*10000;
			break;
		}
		
		case INPUTMOUSEZ:
			ret=(get_mouse_state(2))*10000;
			break;
			
		case INPUTMOUSEB:
			ret=(get_mouse_state(3))*10000;
			break;
		
		case INPUTPRESSSTART:
			ret=button_press[6]?10000:0;
			break;
			
		case INPUTPRESSMAP:
			ret=button_press[9]?10000:0;
			break;
			
		case INPUTPRESSUP:
			ret=button_press[0]?10000:0;
			break;
			
		case INPUTPRESSDOWN:
			ret=button_press[1]?10000:0;
			break;
			
		case INPUTPRESSLEFT:
			ret=button_press[2]?10000:0;
			break;
			
		case INPUTPRESSRIGHT:
			ret=button_press[3]?10000:0;
			break;
			
		case INPUTPRESSA:
			ret=button_press[4]?10000:0;
			break;
			
		case INPUTPRESSB:
			ret=button_press[5]?10000:0;
			break;
			
		case INPUTPRESSL:
			ret=button_press[7]?10000:0;
			break;
			
		case INPUTPRESSR:
			ret=button_press[8]?10000:0;
			break;
			
		case INPUTPRESSEX1:
			ret=button_press[10]?10000:0;
			break;
			
		case INPUTPRESSEX2:
			ret=button_press[11]?10000:0;
			break;
			
		case INPUTPRESSEX3:
			ret=button_press[12]?10000:0;
			break;
			
		case INPUTPRESSEX4:
			ret=button_press[13]?10000:0;
			break;
			
		case INPUTPRESSAXISUP:
			ret=button_press[14]?10000:0;
			break;
			
		case INPUTPRESSAXISDOWN:
			ret=button_press[15]?10000:0;
			break;
			
		case INPUTPRESSAXISLEFT:
			ret=button_press[16]?10000:0;
			break;
			
		case INPUTPRESSAXISRIGHT:
			ret=button_press[17]?10000:0;
			break;
			
		case FFRULE:
		{
			int32_t ruleid = vbound((ri->d[rINDEX]/10000),0,qr_MAX);
			ret = get_qr(ruleid)?10000:0;
		}
		break;
		
		case BUTTONPRESS:
			// DUkey, DDkey, DLkey, DRkey, Akey, Bkey, Skey, Lkey, Rkey, Pkey, Exkey1, Exkey2, Exkey3, Exkey4 };
		{
			//Read-only
			int32_t button = vbound((ri->d[rINDEX]/10000),0,17);
			ret = button_press[button]?10000:0;
		}
		break;

		case BUTTONINPUT:
		{
			//Read-only
			int32_t button = vbound((ri->d[rINDEX]/10000),0,17);
			ret=control_state[button]?10000:0;
		}
		break;

		case BUTTONHELD:
		{
			//Read-only
			int32_t button = vbound((ri->d[rINDEX]/10000),0,17);
			ret = button_hold[button]?10000:0;
		}
		break;

		case RAWKEY:
		{	//Game->KeyPressed[], read-only
			//if ( !keypressed() ) break; //Don;t return values set by setting Hero->Input/Press
			//hmm...no, this won;t return properly for modifier keys. 
			int32_t keyid = ri->d[rINDEX]/10000;
			//key = vbound(key,0,n);
			bool pressed = key_current_frame[keyid] != 0;
			ret = pressed?10000:0;
		}
		break;
		
		case KEYINPUT:
		{
			ret = KeyInput[ri->d[rINDEX]/10000] ? 10000 : 0;
			break;
		}
		case KEYPRESS:
		{
			ret = KeyPress[ri->d[rINDEX]/10000] ? 10000 : 0;
			break;
		}
		
		case KEYMODIFIERS:
		{
			ret = (key_shifts*10000);
			break;
		}
		
		case KEYBINDINGS:
		{
			int32_t keyid = ri->d[rINDEX]/10000;
			switch(keyid)
			{
				case 0: ret = DUkey * 10000; break;
				case 1: ret = DDkey * 10000; break; 
				case 2: ret = DLkey * 10000; break;
				case 3: ret = DRkey * 10000; break;
				case 4: ret = Akey * 10000; break;
				case 5: ret = Bkey * 10000; break;
				case 6: ret = Skey * 10000; break;
				case 7: ret = Lkey * 10000; break;
				case 8: ret = Rkey * 10000; break;
				case 9: ret = Pkey * 10000; /*map*/ break; 
				case 10: ret = Exkey1 * 10000; break;
				case 11: ret = Exkey2 * 10000; break;
				case 12: ret = Exkey3 * 10000; break;
				case 13: ret = Exkey4 * 10000; break;
				
				default: { Z_scripterrlog("Invalid index [%d] passed to Input->KeyBindings[]\n", keyid); ret = 0; break; }
			}
			break;
		}

		case READKEY:
		{
			//Game->ReadKey(int32_t key), also clears it. 
			int32_t keyid = ri->d[rINDEX]/10000;
			bool pressed = zc_readkey(keyid, true);
			ret = pressed?10000:0;
		}
		break;
		
		case DISABLEKEY:
		{
			//Input->DisableKey(int32_t key)
			int32_t keyid = ri->d[rINDEX]/10000;
			ret = disabledKeys[keyid]?10000:0;
			break;
		}
		
		case DISABLEBUTTON:
		{
			//Input->DisableButton(int32_t cb)
			int32_t cbid = ri->d[rINDEX]/10000;
			ret = disable_control[cbid]?10000:0;
			break;
		}

		case JOYPADPRESS:
		{
			//Checks if a press is from the joypad, not keyboard. 
			int32_t button = ri->d[rINDEX]/10000;
			ret = joybtn(button)?10000:0;
		}
		break;
		
		
		case MOUSEARR:
		{	
			int32_t indx = (ri->d[rINDEX]/10000);
			int32_t rv;
			switch (indx)
			{
				case 0: //MouseX
				{
					rv=get_mouse_state(0)*10000;
					break;	
				}
				case 1: //MouseY
				{
					int32_t mousequakeoffset = 56+((int32_t)(zc::math::Sin((double)(quakeclk*int64_t(2)-frame))*4));
					int32_t tempoffset = (quakeclk > 0) ? mousequakeoffset : (get_qr(qr_OLD_DRAWOFFSET)?playing_field_offset:original_playing_field_offset);
					int32_t topOffset= (112-tempoffset);
					rv=(get_mouse_state(1)-topOffset)*10000;
					break;
				}
				case 2: //MouseZ
				{
					rv=(get_mouse_state(2))*10000;
					break;
				}
				case 3: //Left Click
				{
					rv=((get_mouse_state(3)&0x1))*10000;
					break;
				}
				case 4: //Right Click
				{
					rv=((get_mouse_state(3)&0x2))*10000;
					break;
				}
				case 5: //Middle Click
				{
					rv=((get_mouse_state(3)&0x4))*10000;
					break;
				}
				default:
				{
					Z_scripterrlog("Invalid index passed to Input->Mouse[]: %d\n", indx);
					rv = -10000;
					break;
				}
			}
				
			//bool pressed = key[keyid] != 0;
			//ret = pressed?10000:0;
			ret = rv;
		}
		break;
			
		///----------------------------------------------------------------------------------------------------//
		//Item Variables
		case ITEMSCALE:
			if ( get_qr(qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"item->Scale");
				ret = -1; break;
			}
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((int32_t)((item*)(s))->scale)*100.0;
			}
			break;
		
		case ITEMX:
		{
			if(0!=(s=checkItem(ri->itemref)))
			{
				zfix x;
				bool is_fairy = itemsbuf[s->id].family==itype_fairy && itemsbuf[s->id].misc3;
				if (is_fairy)
				{
					enemy* fairy = (enemy*) guys.getByUID(((item*)(s))->fairyUID);
					x = fairy ? fairy->x : s->x;
				}
				else
				{
					x = s->x;
				}

				if ( get_qr(qr_SPRITEXY_IS_FLOAT) )
				{
					ret=x.getZLong();
				}
				else ret = (int32_t)x * 10000;
			}
		}
		break;

		case ITEMY:
		{
			if(0!=(s=checkItem(ri->itemref)))
			{
				zfix y;
				bool is_fairy = itemsbuf[s->id].family==itype_fairy && itemsbuf[s->id].misc3;
				if (is_fairy)
				{
					enemy* fairy = (enemy*) guys.getByUID(((item*)(s))->fairyUID);
					y = fairy ? fairy->y : s->y;
				}
				else
				{
					y = s->y;
				}

				if ( get_qr(qr_SPRITEXY_IS_FLOAT) )
				{
					ret=y.getZLong();
				}
				else ret = (int32_t)y * 10000;
			}
		}
		break;
		
		case ITEMSPRITESCRIPT:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((int32_t)((item*)(s))->script)*10000;
			}
			break;
		
		case ITEMSPRITEINITD:
			if(0!=(s=checkItem(ri->itemref)))
			{
				int32_t a = vbound(ri->d[rINDEX]/10000,0,7);
				ret=((int32_t)((item*)(s))->initD[a]);
			}
			break;
		
		case ITEMFAMILY:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((int32_t)((item*)(s))->family)*10000;
			}
			break;
		
		case ITEMLEVEL:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((int32_t)((item*)(s))->lvl)*10000;
			}
			break;
			
		case SPRITEMAXITEM:
		{
			//No bounds check, as this is a universal function and works from NULL pointers!
			ret = items.getMax() * 10000;
			break;
		}
		
		case ITEMSCRIPTUID:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((int32_t)((item*)(s))->script_UID); //Literal, not *10000
			}
			break;
		
			
		case ITEMZ:
			if(0!=(s=checkItem(ri->itemref)))
			{
				if ( get_qr(qr_SPRITEXY_IS_FLOAT) )
				{
					ret=(((item*)(s))->z).getZLong();    
				}
				else 
					ret=((int32_t)((item*)(s))->z)*10000;
			}
			break;
			
		case ITEMJUMP:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret = ((item*)(s))->fall.getZLong() / -100;
				if (get_qr(qr_SPRITE_JUMP_IS_TRUNCATED)) ret = trunc(ret / 10000) * 10000;
			}
			break;
		
		case ITEMFAKEJUMP:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret = ((item*)(s))->fakefall.getZLong() / -100;
				if (get_qr(qr_SPRITE_JUMP_IS_TRUNCATED)) ret = trunc(ret / 10000) * 10000;
			}
			break;
			
		case ITEMDRAWTYPE:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->drawstyle*10000;
			}
			break;
		  
		case ITEMGRAVITY:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((((item*)(s))->moveflags & FLAG_OBEYS_GRAV) ? 10000 : 0);
			}
			break;
			
		case ITEMID:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->id*10000;
			}
			break;
			
		case ITEMTILE:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->tile*10000;
			}
			break;
			
		case ITEMSCRIPTTILE:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->scripttile*10000;
			}
			break;
			
		case ITEMSCRIPTFLIP:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->scriptflip*10000;
			}
			break;
		
		case ITEMPSTRING:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->pstring*10000;
			}
			break;
		case ITEMPSTRINGFLAGS:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->pickup_string_flags*10000;
			}
			break;
		case ITEMOVERRIDEFLAGS:
			ret=0;
			break;
			
		case ITEMOTILE:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->o_tile*10000;
			}
			break;
			
		case ITEMCSET:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=(((item*)(s))->o_cset&15)*10000;
			}
			break;
			
		case ITEMFLASHCSET:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=(((item*)(s))->o_cset>>4)*10000;
			}
			break;
			
		case ITEMFRAMES:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->frames*10000;
			}
			break;
			
		case ITEMFRAME:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->aframe*10000;
			}
			break;
		
		case ITEMACLK:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->aclk*10000;
			}
			break;    
		
		case ITEMASPEED:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->o_speed*10000;
			}
			break;
			
		case ITEMDELAY:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->o_delay*10000;
			}
			break;
			
		case ITEMFLIP:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->flip*10000;
			}
			break;
			
		case ITEMFLASH:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->flash*10000;
			}
			break;
			
		case ITEMHXOFS:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=(((item*)(s))->hxofs)*10000;
			}
			break;

		case ITEMROTATION:
			if ( get_qr(qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"item->Rotation");
				ret = -1; break;
			}
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=(((item*)(s))->rotation)*10000;
			}
			break;

		case ITEMHYOFS:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=(((item*)(s))->hyofs)*10000;
			}
			break;
			
		case ITEMXOFS:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((int32_t)(((item*)(s))->xofs))*10000;
			}
			break;
			
		case ITEMYOFS:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((int32_t)(((item*)(s))->yofs-(get_qr(qr_OLD_DRAWOFFSET)?playing_field_offset:original_playing_field_offset)))*10000;
			}
			break;
		
		case ITEMSHADOWXOFS:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((int32_t)(((item*)(s))->shadowyofs))*10000;
			}
			break;
			
		case ITEMSHADOWYOFS:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((int32_t)(((item*)(s))->shadowxofs))*10000;
			}
			break;
			
			
		case ITEMZOFS:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((int32_t)(((item*)(s))->zofs))*10000;
			}
			break;
			
		case ITEMHXSZ:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=(((item*)(s))->hit_width)*10000;
			}
			break;
			
		case ITEMHYSZ:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=(((item*)(s))->hit_height)*10000;
			}
			break;
			
		case ITEMHZSZ:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=(((item*)(s))->hzsz)*10000;
			}
			break;
			
		case ITEMTXSZ:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=(((item*)(s))->txsz)*10000;
			}
			break;
			
		case ITEMTYSZ:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=(((item*)(s))->tysz)*10000;
			}
			break;
			
		case ITEMCOUNT:
			ret=(items.Count())*10000;
			break;
		
		case GETRENDERTARGET:
			ret=(zscriptDrawingRenderTarget->GetCurrentRenderTarget())*10000;
			break;
			
		case ITEMEXTEND:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->extend*10000;
			}
			break;
			
		case ITEMPICKUP:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->pickup*10000;
			}
			break;
			
			
		case ITEMMISCD:
			if(0!=(s=checkItem(ri->itemref)))
			{
				int32_t a = vbound(ri->d[rINDEX]/10000,0,31);
				ret=(((item*)(s))->miscellaneous[a]);
			}
			break;
		
		case ITEMFALLCLK:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret = ((item*)(s))->fallclk * 10000;
			}
			break;
		
		case ITEMFALLCMB:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret = ((item*)(s))->fallCombo * 10000;
			}
			break;
		
		case ITEMDROWNCLK:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret = ((item*)(s))->drownclk * 10000;
			}
			break;
		
		case ITEMDROWNCMB:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret = ((item*)(s))->drownCombo * 10000;
			}
			break;
		
		case ITEMFAKEZ:
			if(0!=(s=checkItem(ri->itemref)))
			{
				if ( get_qr(qr_SPRITEXY_IS_FLOAT) )
				{
					ret=(((item*)(s))->fakez).getZLong();    
				}
				else 
					ret=((int32_t)((item*)(s))->fakez)*10000;
			}
			break;
			
		
		case ITEMMOVEFLAGS:
		{
			if(0!=(s=checkItem(ri->itemref)))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(BC::checkBounds(indx, 0, 10, "itemsprite->MoveFlags[]") != SH::_NoError)
					ret = 0; //false
				else
				{
					//All bits, in order, of a single byte; just use bitwise
					ret = (((item*)(s))->moveflags & (1<<indx)) ? 10000 : 0;
				}
			}
			break;
		}
		
		case ITEMGLOWRAD:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret = ((item*)(s))->glowRad * 10000;
			}
			break;
			
		case ITEMGLOWSHP:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret = ((item*)(s))->glowShape * 10000;
			}
			break;
			
		case ITEMDIR:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret = ((item*)(s))->dir * 10000;
			}
			break;
			
		case ITEMENGINEANIMATE:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret = int32_t(((item*)(s))->do_animation) * 10000;
			}
			break;
			
		case ITEMSHADOWSPR:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret = int32_t(((item*)(s))->spr_shadow) * 10000;
			}
			break;
		case ITEMDROPPEDBY:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret = int32_t(((item*)(s))->from_dropset) * 10000;
			}
			break;
		case ITMSWHOOKED:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret = s->switch_hooked ? 10000 : 0;
			}
			break;
		case ITEMFORCEGRAB:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret = ((item*)s)->get_forcegrab() ? 10000 : 0;
			}
			break;
			
		case ITEMNOSOUND:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->noSound ? 10000 : 0;
			}
			break;
			
		case ITEMNOHOLDSOUND:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->noHoldSound ? 10000 : 0;
			}
			break;
		///----------------------------------------------------------------------------------------------------//
		//Itemdata Variables
		
		
		case IDATAUSEWPN:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].useweapon)*10000;
			break;
		case IDATAUSEDEF:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].usedefence)*10000;
			break;
		case IDATAWRANGE:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].weaprange)*10000;
			break;
		case IDATAMAGICTIMER:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].magiccosttimer[0])*10000;
			break;
		case IDATAMAGICTIMER2:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].magiccosttimer[1])*10000;
			break;
		case IDATAUSEMVT:
		{
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			int32_t a = vbound((ri->d[rINDEX] / 10000),0,(ITEM_MOVEMENT_PATTERNS-1));
			ret=(itemsbuf[ri->idata].weap_pattern[a])*10000;
		}
		break;
		
		case IDATADURATION:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].weapduration)*10000;
			break;
		
		case IDATADUPLICATES:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].duplicates)*10000;
			break;
		case IDATADRAWLAYER:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].drawlayer)*10000;
			break;
		case IDATACOLLECTFLAGS:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = 0;
				break;
			}
			ret=(itemsbuf[ri->idata].collectflags)*10000;
			break;
		case IDATAWEAPONSCRIPT:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].weaponscript)*10000;
			break;
		case IDATAMISCD:
		{
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			int32_t a = vbound((ri->d[rINDEX] / 10000),0,31);
			ret=(itemsbuf[ri->idata].wpn_misc_d[a])*10000;
		}
		break;
		case IDATAWPNINITD:
		{
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			int32_t a = vbound((ri->d[rINDEX] / 10000),0,7);
			ret=(itemsbuf[ri->idata].weap_initiald[a]);
		}
		break;
		case IDATAWEAPHXOFS:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].weap_hxofs)*10000;
			break;
		case IDATAWEAPHYOFS:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].weap_hyofs)*10000;
			break;
		case IDATAWEAPHXSZ:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].weap_hxsz)*10000;
			break;
		case IDATAWEAPHYSZ:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].weap_hysz)*10000;
			break;
		case IDATAWEAPHZSZ:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].weap_hzsz)*10000;
			break;
		case IDATAWEAPXOFS:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].weap_xofs)*10000;
			break;
		case IDATAWEAPYOFS:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].weap_yofs)*10000;
			break;
		case IDATAHXOFS:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].hxofs)*10000;
			break;
		case IDATAHYOFS:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].hyofs)*10000;
			break;
		case IDATAHXSZ:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].hxsz)*10000;
			break;
		case IDATAHYSZ:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].hysz)*10000;
			break;
		case IDATAHZSZ:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].hzsz)*10000;
			break;
		case IDATADXOFS:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].xofs)*10000;
			break;
		case IDATADYOFS:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].yofs)*10000;
			break;
		case IDATATILEW:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].tilew)*10000;
			break;
		case IDATATILEH:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].tileh)*10000;
			break;
		case IDATAPICKUP:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].pickup)*10000;
			break;
		case IDATAOVERRIDEFL:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = 0;
				break;
			}
			ret=(itemsbuf[ri->idata].overrideFLAGS)*10000;
			break;

		case IDATATILEWWEAP:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].weap_tilew)*10000;
			break;
		case IDATATILEHWEAP:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].weap_tileh)*10000;
			break;
		case IDATAOVERRIDEFLWEAP:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = 0;
				break;
			}
			ret=(itemsbuf[ri->idata].weapoverrideFLAGS)*10000;
			break;
		
		case IDATAFAMILY:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].family)*10000;
			break;
			
		case IDATALEVEL:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].fam_type)*10000;
			break;
			
		case IDATAKEEP:
			ret = item_flag(ITEM_GAMEDATA);
			break;
			
		case IDATAAMOUNT:
		{
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			int32_t v = itemsbuf[ri->idata].amount;
			ret = ((v&0x4000)?-1:1)*(v & 0x3FFF)*10000;
			break;
		}
		case IDATAGRADUAL:
		{
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret = (itemsbuf[ri->idata].amount&0x8000) ? 10000 : 0;
			break;
		}
		case IDATACONSTSCRIPT:
			ret = item_flag(ITEM_PASSIVESCRIPT);
			break;
		case IDATASSWIMDISABLED:
			ret = item_flag(ITEM_SIDESWIM_DISABLED);
			break;
		case IDATABUNNYABLE:
			ret = item_flag(ITEM_BUNNY_ENABLED);
			break;
		case IDATAJINXIMMUNE:
			ret = item_flag(ITEM_JINX_IMMUNE);
			break;
		case IDATAJINXSWAP:
			ret = item_flag(ITEM_FLIP_JINX);
			break;
		case IDATAUSEBURNSPR:
			ret = item_flag(ITEM_BURNING_SPRITES);
			break;
			
		case IDATASETMAX:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].setmax)*10000;
			break;
			
		case IDATAMAX:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].max)*10000;
			break;
			
		case IDATACOUNTER:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].count)*10000;
			break;
			
		case IDATAPSOUND:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].playsound)*10000;
			break;
		case IDATAUSESOUND:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].usesound)*10000;
			break;
			
		case IDATAUSESOUND2:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].usesound2)*10000;
			break;
			
		case IDATAPOWER:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].power)*10000;
			break;
		
		//Get the ID of an item.
		case IDATAID:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				//Don't error here //Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=ri->idata*10000;
			break;
		
		//Get the script assigned to an item (active)
		case IDATASCRIPT:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].script)*10000;
			break;
		case IDATASPRSCRIPT:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].sprite_script)*10000;
			break;
		//Get the ->Attributes[] of an item
		case IDATAATTRIB:
		case IDATAATTRIB_L:
		{
			int vscale = (arg==IDATAATTRIB_L)?1:10000;
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -1*vscale;
				break;
			}
			int32_t index = vbound(ri->d[rINDEX]/10000,0,9);
			switch(index)
			{
				case 0:
					ret=(itemsbuf[ri->idata].misc1); break;
				case 1:
					ret=(itemsbuf[ri->idata].misc2); break;
				case 2:
					ret=(itemsbuf[ri->idata].misc3); break;
				case 3:
					ret=(itemsbuf[ri->idata].misc4); break;
				case 4:
					ret=(itemsbuf[ri->idata].misc5); break;
				case 5:
					ret=(itemsbuf[ri->idata].misc6); break;
				case 6:
					ret=(itemsbuf[ri->idata].misc7); break;
				case 7:
					ret=(itemsbuf[ri->idata].misc8); break;
				case 8:
					ret=(itemsbuf[ri->idata].misc9); break;
				case 9:
					ret=(itemsbuf[ri->idata].misc10); break;
				default: 
					ret = -1; break;
			}
			ret *= vscale;
			break;
		}
		//Get the ->Sprite[] of an item.
		case IDATASPRITE:
		{
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			int32_t index = ri->d[rINDEX]/10000;
			switch(index)
			{
				case 0:
					ret=(itemsbuf[ri->idata].wpn)*10000; break;
				case 1:
					ret=(itemsbuf[ri->idata].wpn2)*10000; break;
				case 2:
					ret=(itemsbuf[ri->idata].wpn3)*10000; break;
				case 3:
					ret=(itemsbuf[ri->idata].wpn4)*10000; break;
				case 4:
					ret=(itemsbuf[ri->idata].wpn5)*10000; break;
				case 5:
					ret=(itemsbuf[ri->idata].wpn6)*10000; break;
				case 6:
					ret=(itemsbuf[ri->idata].wpn7)*10000; break;
				case 7:
					ret=(itemsbuf[ri->idata].wpn8)*10000; break;
				case 8:
					ret=(itemsbuf[ri->idata].wpn9)*10000; break;
				case 9:
					ret=(itemsbuf[ri->idata].wpn10)*10000; break;
				default:
					Z_scripterrlog("Invalid index to itemdata->Sprites[]: %d\n", index);
					ret = -10000;
					break;
			}
			break;
		}
		case IDATABURNINGSPR:
		{
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			int32_t index = ri->d[rINDEX]/10000;
			if(index < 0 || index >= BURNSPR_MAX)
			{
				Z_scripterrlog("Invalid index to itemdata->BurnSprites[]: %d\n", index);
				ret = -10000;
				break;
			}
			ret = itemsbuf[ri->idata].burnsprs[index]*10000;
			break;
		}
		case IDATABURNINGLIGHTRAD:
		{
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			int32_t index = ri->d[rINDEX]/10000;
			if(index < 0 || index >= BURNSPR_MAX)
			{
				Z_scripterrlog("Invalid index to itemdata->BurnLightRadius[]: %d\n", index);
				ret = -10000;
				break;
			}
			ret = itemsbuf[ri->idata].light_rads[index]*10000;
			break;
		}
		//Hero TIle modifier
		case IDATALTM:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = 0;
				break;
			}
			ret=(itemsbuf[ri->idata].ltm)*10000;
			break;
		//Pickup script
		case IDATAPSCRIPT:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].collect_script)*10000;
			break;
		//Pickup string
		case IDATAPSTRING:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].pstring)*10000;
			break;
		case IDATAPFLAGS:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = 0;
				break;
			}
			ret=(itemsbuf[ri->idata].pickup_string_flags)*10000;
			break;
		//Magic cost
		case IDATAMAGCOST:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].cost_amount[0])*10000;
			break;
		case IDATACOST2:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].cost_amount[1])*10000;
			break;
		//cost counter ref
		case IDATACOSTCOUNTER:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].cost_counter[0])*10000;
			break;
		case IDATACOSTCOUNTER2:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].cost_counter[1])*10000;
			break;
		//Min Hearts to Pick Up
		case IDATAMINHEARTS:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].pickup_hearts)*10000;
			break;
		//Tile used by the item
		case IDATATILE:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].tile)*10000;
			break;
		//itemdata->Flash
		case IDATAMISC:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].misc_flags)*10000;
			break;
		//->CSet
		case IDATACSET:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].csets)*10000;
			break;
		//->A.Frames
		case IDATAFRAMES:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].frames)*10000;
			break;
		/*
		case IDATAFRAME:
			ret=(itemsbuf[ri->idata].frame)*10000;
			break;
		*/ 
		//->A.Speed
		case IDATAASPEED:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].speed)*10000;
			break;
		//->Delay
		case IDATADELAY:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			ret=(itemsbuf[ri->idata].delay)*10000;
			break;
		// teo of this item upgrades
		case IDATACOMBINE:
			ret = item_flag(ITEM_COMBINE);
			break;
		//Use item, and get the lower level one
		case IDATADOWNGRADE:
			ret = item_flag(ITEM_DOWNGRADE);
			break;
		//Only validate the cost, don't charge it
		case IDATAVALIDATE:
			ret = item_flag(ITEM_VALIDATEONLY);
			break;
		case IDATAVALIDATE2:
			ret = item_flag(ITEM_VALIDATEONLY2);
			break;
		//->Flags[5]
		case IDATAFLAGS:
		{
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = 0;
				break;
			}
			int32_t index = ri->d[rINDEX]/10000;
			switch(index)
			{
				case 0:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG1)?10000:0; break;
				case 1:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG2)?10000:0; break;
				case 2:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG3)?10000:0; break;
				case 3:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG4)?10000:0; break;
				case 4:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG5)?10000:0; break;
				case 5:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG6)?10000:0; break;
				case 6:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG7)?10000:0; break;
				case 7:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG8)?10000:0; break;
				case 8:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG9)?10000:0; break;
				case 9:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG10)?10000:0; break;
				case 10:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG11)?10000:0; break;
				case 11:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG12)?10000:0; break;
				case 12:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG13)?10000:0; break;
				case 13:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG14)?10000:0; break;
				case 14:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG15)?10000:0; break;
				case 15:
					ret=(itemsbuf[ri->idata].flags & ITEM_PASSIVESCRIPT)?10000:0; break;
				
				
				default:
					Z_scripterrlog("Invalid itemdata->Flags[] index: %d\n", index);
					ret = 0;
					break;
			}
			break;
		}
			
		//->Keep Old
		case IDATAKEEPOLD:
			ret = item_flag(ITEM_KEEPOLD);
			break;
		//Use rupees instead of magic
		case IDATARUPEECOST:
			ret = item_flag(ITEM_RUPEE_MAGIC);
			break;
		//Can be eaten
		case IDATAEDIBLE:
			ret = item_flag(ITEM_EDIBLE);
			break;
		//currently unused
		case IDATAFLAGUNUSED:
			ret = item_flag(ITEM_UNUSED);
			break;
		//Gain lower level items when collected
		case IDATAGAINLOWER:
			ret = item_flag(ITEM_GAINOLD);
			break;
		//Unchanged from master
		case IDATAINITDD:
		{
			int32_t a = ri->d[rINDEX] / 10000;
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				ret = -10000;
				break;
			}
			
			if(BC::checkBounds(a, 0, 7, "itemdata->InitD") != SH::_NoError)
				ret = -10000;
			else
				ret = itemsbuf[ri->idata].initiald[a];
		}
		break;
		
		///----------------------------------------------------------------------------------------------------//
		//NPC Variables

		//Reduces accessing integer members to one line
		#define GET_NPC_VAR_INT(member, str) \
		{ \
			if(GuyH::loadNPC(ri->guyref, str) != SH::_NoError) \
				ret = -10000; \
			else \
				ret = GuyH::getNPC()->member * 10000; \
		}

		case NPCDIR:
			if(GuyH::loadNPC(ri->guyref, "npc->Dir") != SH::_NoError)
				ret = -10000;
			else
				ret = zc_max(GuyH::getNPC()->dir * 10000, 0);
				
			break;
			
		case NPCHITDIR:
			if(GuyH::loadNPC(ri->guyref, "npc->HitDir") != SH::_NoError)
				ret = -10000;
			else
				ret = (GuyH::getNPC()->hitdir * 10000);
				
			break;
			
		case NPCSLIDECLK:
			if(GuyH::loadNPC(ri->guyref, "npc->SlideClock") != SH::_NoError)
				ret = -10000;
			else
				ret = (GuyH::getNPC()->sclk * 10000);
				
			break;
			
		case NPCHALTCLK:
			if(GuyH::loadNPC(ri->guyref, "npc->Halt") != SH::_NoError)
				ret = -10000;
			else
				ret = (GuyH::getNPC()->clk2 * 10000);
				
			break;
			
		case NPCFRAME:
			if(GuyH::loadNPC(ri->guyref, "npc->Frame") != SH::_NoError)
				ret = -10000;
			else
				ret = (GuyH::getNPC()->clk * 10000);
				
			break;
			
		case NPCMOVESTATUS:
			if(GuyH::loadNPC(ri->guyref, "npc->MoveStatus") != SH::_NoError)
				ret = -10000;
			else
				ret = (GuyH::getNPC()->movestatus * 10000);
				
			break;
			
		case NPCFADING:
			if(GuyH::loadNPC(ri->guyref, "npc->Fading") != SH::_NoError)
				ret = -10000;
			else
				ret = (GuyH::getNPC()->fading * 10000);
				
			break;
			
		case NPCRATE:
			GET_NPC_VAR_INT(rate, "npc->Rate") break;
			
		case NPCHOMING:
			GET_NPC_VAR_INT(homing, "npc->Homing") break;
			
		case NPCFRAMERATE:
			GET_NPC_VAR_INT(frate, "npc->ASpeed") break;
			
		case NPCHALTRATE:
			GET_NPC_VAR_INT(hrate, "npc->HaltRate") break;
		
		case NPCRANDOM:
			GET_NPC_VAR_INT(rate, "npc->Random") break;
			
		case NPCDRAWTYPE:
			GET_NPC_VAR_INT(drawstyle, "npc->DrawStyle") break;
		
		case NPCHP:
			GET_NPC_VAR_INT(hp, "npc->HP") break;

		case NPCORIGINALHP:
			GET_NPC_VAR_INT(starting_hp, "npc->OriginalHP") break;
			
		case NPCCOLLDET:
			GET_NPC_VAR_INT(scriptcoldet, "npc->ColDetection") break;
		
		case NPCENGINEANIMATE:
			GET_NPC_VAR_INT(do_animation, "npc->Animation") break;
			
		case NPCSTUN:
			GET_NPC_VAR_INT(stunclk, "npc->Stun") break;
			
		case NPCHUNGER:
			GET_NPC_VAR_INT(grumble, "npc->Hunger") break;
		
		case NPCWEAPSPRITE:
			GET_NPC_VAR_INT(wpnsprite, "npc->WeaponSprite") break;
			
		case NPCTYPE:
			GET_NPC_VAR_INT(family, "npc->Type") break;
			
		case NPCDP:
			GET_NPC_VAR_INT(dp, "npc->Damage") break;
			
		case NPCWDP:
			GET_NPC_VAR_INT(wdp, "npc->WeaponDamage") break;
			
		case NPCOTILE:
			GET_NPC_VAR_INT(o_tile, "npc->OriginalTile") break;
			
		case NPCTILE:
			GET_NPC_VAR_INT(tile, "npc->Tile") break;
		
		case NPCSCRIPTTILE:
			GET_NPC_VAR_INT(scripttile, "npc->ScriptTile") break;
			
		case NPCSCRIPTFLIP:
			GET_NPC_VAR_INT(scriptflip, "npc->ScriptFlip") break;
			
		case NPCWEAPON:
			GET_NPC_VAR_INT(wpn, "npc->Weapon") break;
			
		case NPCITEMSET:
			GET_NPC_VAR_INT(item_set, "npc->ItemSet") break;
			
		case NPCCSET:
			GET_NPC_VAR_INT(cs, "npc->CSet") break;
			
		case NPCBOSSPAL:
			GET_NPC_VAR_INT(bosspal, "npc->BossPal") break;
			
		case NPCBGSFX:
			GET_NPC_VAR_INT(bgsfx, "npc->SFX") break;
			
		case NPCEXTEND:
			GET_NPC_VAR_INT(extend, "npc->Extend") break;
			
		case NPCHXOFS:
			GET_NPC_VAR_INT(hxofs, "npc->HitXOffset") break;
			
		case NPCHYOFS:
			GET_NPC_VAR_INT(hyofs, "npc->HitYOffset") break;
			
		case NPCHXSZ:
			GET_NPC_VAR_INT(hit_width, "npc->HitWidth") break;
			
		case NPCHYSZ:
			GET_NPC_VAR_INT(hit_height, "npc->HitHeight") break;
			
		case NPCHZSZ:
			GET_NPC_VAR_INT(hzsz, "npc->HitZHeight") break;
		
		case NPCROTATION:
			if ( get_qr(qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"npc->Rotation");
				ret = -1; break;
			}
			GET_NPC_VAR_INT(rotation, "npc->Rotation") break;

		case NPCTXSZ:
			GET_NPC_VAR_INT(txsz, "npc->TileWidth") break;
			
		case NPCTYSZ:
			GET_NPC_VAR_INT(tysz, "npc->TileHeight") break;
			
		//And zfix
		#define GET_NPC_VAR_FIX(member, str) \
		{ \
			if(GuyH::loadNPC(ri->guyref, str) != SH::_NoError) \
			{ \
				ret = -10000; \
				break; \
			} \
			else \
				ret = (int32_t(GuyH::getNPC()->member) * 10000); \
		}

		case NPCX:
		//GET_NPC_VAR_FIX(x, "npc->X") break;     
		{
			if(GuyH::loadNPC(ri->guyref, "X") != SH::_NoError) 
			{
				ret = -10000; 
			}
			else 
			{
				if ( get_qr(qr_SPRITEXY_IS_FLOAT) )
				{
					ret = ((GuyH::getNPC()->x).getZLong()); 
				}
				else
				{
					ret = (int32_t(GuyH::getNPC()->x) * 10000);   
				}
			}
			break;
		}
		
		case SPRITEMAXNPC:
		{
			//No bounds check, as this is a universal function and works from NULL pointers!
			ret = guys.getMax() * 10000;
			break;
		}
		
		case NPCSUBMERGED:
		{
			if(GuyH::loadNPC(ri->guyref, "Submerged()") != SH::_NoError) 
			{
				ret = -10000; 
			}    
			else
			{
				ret = ((GuyH::getNPC()->isSubmerged()) ? 10000 : 0);
				
			}
			break;	
		}
			
			
		case NPCY:
			//GET_NPC_VAR_FIX(y, "npc->Y") break;
		{
			if(GuyH::loadNPC(ri->guyref, "Y") != SH::_NoError) 
			{
				ret = -10000; 
			}
			else 
			{
				if ( get_qr(qr_SPRITEXY_IS_FLOAT) )
				{
					ret = ((GuyH::getNPC()->y).getZLong()); 
				}
				else
				{
					ret = (int32_t(GuyH::getNPC()->y) * 10000);   
				}
			}
			break;
		}
		
			
		case NPCZ:
			//GET_NPC_VAR_FIX(z, "npc->Z") break;
		{
			if(GuyH::loadNPC(ri->guyref, "Z") != SH::_NoError) 
			{
				ret = -10000; 
			}
			else 
			{
				if ( get_qr(qr_SPRITEXY_IS_FLOAT) )
				{
					ret = ((GuyH::getNPC()->z).getZLong()); 
				}
				else
				{
					ret = (int32_t(GuyH::getNPC()->z) * 10000);   
				}
			}
			break;
		}
			
		case NPCXOFS:
			GET_NPC_VAR_FIX(xofs, "npc->DrawXOffset") break;
			
		case NPCYOFS:
			GET_NPC_VAR_FIX(yofs, "npc->DrawYOffset") ret-=(get_qr(qr_OLD_DRAWOFFSET)?playing_field_offset:original_playing_field_offset)*10000;
			break;
		case NPCSHADOWXOFS:
			GET_NPC_VAR_FIX(shadowxofs, "npc->ShadowXOffset") break;
			
		case NPCSHADOWYOFS:
			GET_NPC_VAR_FIX(shadowyofs, "npc->ShadowYOffset") break;
			
		case NPCTOTALDYOFFS:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->TotalDYOffset") != SH::_NoError)
			{
				ret = -10000;
			}
			else
			{
				ret = ((int32_t(GuyH::getNPC()->yofs - (get_qr(qr_OLD_DRAWOFFSET)?playing_field_offset:original_playing_field_offset))
					+ ((GuyH::getNPC()->switch_hooked && Hero.switchhookstyle == swRISE)
						? -(8-(abs(Hero.switchhookclk-32)/4)) : 0)) * 10000);
			}
			break;
		}
			
		case NPCZOFS:
			GET_NPC_VAR_FIX(zofs, "npc->DrawZOffset") break;
			
			//These variables are all different to the templates (casting for jump and step is slightly non-standard)
		case NPCJUMP:
			if(GuyH::loadNPC(ri->guyref, "npc->Jump") != SH::_NoError)
				ret = -10000;
			else
			{
				ret = GuyH::getNPC()->fall.getZLong() / -100;
				if (get_qr(qr_SPRITE_JUMP_IS_TRUNCATED)) ret = trunc(ret / 10000) * 10000;
			}
				
			break;
		
		case NPCFAKEJUMP:
			if(GuyH::loadNPC(ri->guyref, "npc->FakeJump") != SH::_NoError)
				ret = -10000;
			else
			{
				ret = GuyH::getNPC()->fakefall.getZLong() / -100;
				if (get_qr(qr_SPRITE_JUMP_IS_TRUNCATED)) ret = trunc(ret / 10000) * 10000;
			}
				
			break;
		
		
		case NPCSCALE:
			if ( get_qr(qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"npc->Scale");
				ret = -1; break;
			}
			if(GuyH::loadNPC(ri->guyref, "npc->Scale") != SH::_NoError)
				ret = -10000;
			else
				ret = (int32_t(GuyH::getNPC()->scale) * 100.0);
				
			break;
		
		case NPCIMMORTAL:
			if(GuyH::loadNPC(ri->guyref, "npc->Immortal") != SH::_NoError)
				ret = -10000;
			else
				ret = GuyH::getNPC()->immortal ? 10000 : 0;
			break;
		
		case NPCNOSLIDE:
			if(GuyH::loadNPC(ri->guyref, "npc->NoSlide") != SH::_NoError)
				ret = -10000;
			else
				ret = (GuyH::getNPC()->knockbackflags & FLAG_NOSLIDE) ? 10000 : 0;
			break;
		
		case NPCNOSCRIPTKB:
			if(GuyH::loadNPC(ri->guyref, "npc->NoScriptKnockback") != SH::_NoError)
				ret = -10000;
			else
				ret = (GuyH::getNPC()->knockbackflags & FLAG_NOSCRIPTKNOCKBACK) ? 10000 : 0;
			break;
		
		case NPCKNOCKBACKSPEED:
			if(GuyH::loadNPC(ri->guyref, "npc->SlideSpeed") != SH::_NoError)
				ret = -10000;
			else
				ret = GuyH::getNPC()->knockbackSpeed * 10000;
			break;
			
		case NPCSTEP:
			if(GuyH::loadNPC(ri->guyref, "npc->Step") != SH::_NoError)
				ret = -10000;
			else
			{
				if ( get_qr(qr_STEP_IS_FLOAT) || replay_is_active() )
				{
					ret = ( ( (GuyH::getNPC()->step).getZLong() ) * 100 );
				}
				//old, buggy code replication, round two: Go! -Z
				//else ret = ( ( (GuyH::getNPC()->step) * 100.0 ).getZLong() );
				else 
				{
					double s2 = ( (GuyH::getNPC()->step).getZLong() );
					ret = int32_t(s2*100);
					//ret = int32_t( ( (GuyH::getNPC()->step) * 100.0 )) * 10000;
				}
				//else ret = int32_t(GuyH::getNPC()->step * fix(100.0)) * 10000;
				
				//else 
				//{
					//old, buggy code replication, round THREE: Go! -Z
				//	double tmp = ( (GuyH::getNPC()->step) ) * 1000000.0;
				//	ret = (int32_t)tmp;
				//}
			}
				
			break;
		
		case NPCGRAVITY:
			if(GuyH::loadNPC(ri->guyref, "npc->Gravity") != SH::_NoError)
				ret = -10000;
			else
				ret = ((GuyH::getNPC()->moveflags & FLAG_OBEYS_GRAV) ? 10000 : 0);
				
			break;
		
			
		case NPCID:
			if(GuyH::loadNPC(ri->guyref, "npc->ID") != SH::_NoError)
				ret = -10000;
			else
				ret = (GuyH::getNPC()->id & 0xFFF) * 10000;
				
			break;
		
		case NPCISCORE:
			if(GuyH::loadNPC(ri->guyref, "npc->isCore") != SH::_NoError)
				ret = -10000;
			else
				ret = ((GuyH::getNPC()->isCore) ? 10000 : 0);
				
			break;
		
		case NPCSCRIPTUID:
			if(GuyH::loadNPC(ri->guyref, "npc->ScriptUID") != SH::_NoError)
				ret = -10000;
			else
				ret = ((GuyH::getNPC()->getScriptUID())); //literal, not *10000
				
			break;
		
		case NPCPARENTUID:
			if(GuyH::loadNPC(ri->guyref, "npc->ParentUID") != SH::_NoError)
				ret = -10000;
			else
				ret = ((GuyH::getNPC()->parent_script_UID)); //literal, not *10000
				
			break;
		
		//case EWPNPARENTUID:
			//if(0!=(s=checkEWpn(ri->ewpn, "ScriptUID")))
			//	ret=(((weapon*)(s))->parent_script_UID); //literal, not *10000
				
			
		case NPCMFLAGS:
			if(GuyH::loadNPC(ri->guyref, "npc->MiscFlags") != SH::_NoError)
				ret = -10000;
			else
				ret = GuyH::getMFlags() * 10000;
				
			break;
			
		//Indexed (two checks)
		case NPCDEFENSED:
		{
			int32_t a = ri->d[rINDEX] / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->Defense[]") != SH::_NoError ||
					BC::checkBounds(a, 0, (edefLAST255), "npc->Defense[]") != SH::_NoError)
				ret = -10000;
			else
				ret = GuyH::getNPC()->defense[a] * 10000;
		}
		break;
		
		case NPCHITBY:
		{
			int32_t indx = ri->d[rINDEX] / 10000;

			if(GuyH::loadNPC(ri->guyref, "npc->HitBy[]") != SH::_NoError )
			{
				ret = -10000; break;
			}
			else
			{
				switch(indx)
				{
					//screen indixes
					case 0:
					case 1:
					case 2:
					case 3:
					case 8:
					case 9:
					case 10:
					case 11:
					case 12:
					case 16:
					{
						ret = GuyH::getNPC()->hitby[indx] * 10000; // * 10000; //do not multiply by 10000! UIDs are not *10000!
						break;
					}
					//UIDs
					case 4:
					case 5:
					case 6:
					case 7:
					case 13:
					case 14:
					case 15:
					{
						ret = GuyH::getNPC()->hitby[indx]; // * 10000; //do not multiply by 10000! UIDs are not *10000!
						break;
					}
					default: { Z_scripterrlog("Invalid index used for npc->HitBy[%d]. /n", indx); ret = -10000; break; }
				}
				break;
			}
		}
		
		//2.fuure compat.
		
		case NPCSCRDEFENSED:
		{
			int32_t a = ri->d[rINDEX] / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->ScriptDefense") != SH::_NoError ||
					BC::checkBounds(a, 0, edefSCRIPTDEFS_MAX, "npc->ScriptDefense") != SH::_NoError)
				ret = -10000;
			else
				ret = GuyH::getNPC()->defense[a+edefSCRIPT01] * 10000;
		}
		break;
		
		
		case NPCMISCD:
		{
			int32_t a = ri->d[rINDEX] / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->Misc") != SH::_NoError ||
					BC::checkMisc32(a, "npc->Misc") != SH::_NoError)
				ret = -10000;
			else
				ret = GuyH::getNPC()->miscellaneous[a];
		}
		break;
		case NPCINITD:
		{
			int32_t a = ri->d[rINDEX] / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->InitD[]") != SH::_NoError )
				ret = -10000;
			else
			{
				//enemy *e = (enemy*)guys.spr(ri->guyref);
				ret = (int32_t)GuyH::getNPC()->initD[a];
			}
		}
		break;
		
		case NPCSCRIPT:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->Script") != SH::_NoError )
				ret = -10000;
			else
			{
				//enemy *e = (enemy*)guys.spr(ri->guyref);
				ret = (int32_t)GuyH::getNPC()->script * 10000;
			}
		}
		break;
		
		case NPCDD: //Fized the size of this array. There are 15 total attribs, [0] to [14], not [0] to [9]. -Z
		{
			int32_t a = ri->d[rINDEX] / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->Attributes") != SH::_NoError ||
					BC::checkBounds(a, 0, ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ? 31 : 15 ), "npc->Attributes") != SH::_NoError)
				ret = -10000;
			else
				ret = GuyH::getNPCDMisc(a) * 10000;
		}
		break;
		
			case NPCINVINC:
			if(GuyH::loadNPC(ri->guyref, "npc->InvFrames") != SH::_NoError)
				ret = -10000;
			else
				ret = (int32_t)GuyH::getNPC()->hclk * 10000;
				
			break;
		
		case NPCHASITEM:
			if(GuyH::loadNPC(ri->guyref, "npc->HasItem") != SH::_NoError)
				ret = 0;
			else
				ret = GuyH::getNPC()->itemguy?10000:0;
				
			break;
		
		case NPCRINGLEAD:
			if(GuyH::loadNPC(ri->guyref, "npc->Ringleader") != SH::_NoError)
				ret = 0;
			else
				ret = GuyH::getNPC()->leader?10000:0;
				
			break;
		
		case NPCSUPERMAN:
			if(GuyH::loadNPC(ri->guyref, "npc->Invincible") != SH::_NoError)
				ret = -10000;
			else
				ret = (int32_t)GuyH::getNPC()->superman * 10000;
				
			break;
		
		case NPCSHIELD:
		{
			int32_t indx = ri->d[rINDEX];
			if(GuyH::loadNPC(ri->guyref, "npc->Shield[]") == SH::_NoError)
			{
				switch(indx)
				{
					case 0:
					{
						ret = ((GuyH::getNPC()->flags&inv_front) ? 10000 : 0);
						break;
					}
					case 1:
					{
						ret = ((GuyH::getNPC()->flags&inv_left) ? 10000 : 0);
						break;
					}
					case 2:
					{
						ret = ((GuyH::getNPC()->flags&inv_right) ? 10000 : 0);
						break;
					}
					case 3:
					{
						ret = ((GuyH::getNPC()->flags&inv_back) ? 10000 : 0);
						break;
					}
					case 4: //shield can be broken
					{
						ret = ((GuyH::getNPC()->flags&guy_bkshield) ? 10000 : 0);
						break;
					}
					default:
					{
						Z_scripterrlog("Invalid Array Index passed to npc->Shield[]: %d\n", indx); 
						break;
					}
				}
			}
			else
			{
				ret = -10000;
				break;
			}
		}
		break;
		
		case NPCFROZENTILE:
			GET_NPC_VAR_INT(frozentile, "npc->FrozenTile"); break;
		
		case NPCFROZENCSET:
			GET_NPC_VAR_INT(frozencset, "npc->FrozenCSet"); break;
		
		case NPCFROZEN:
			GET_NPC_VAR_INT(frozenclock, "npc->Frozen"); break;
		
		
		case NPCBEHAVIOUR: 
		{
			if(GuyH::loadNPC(ri->guyref, "npc->Behaviour[]") != SH::_NoError) 
			{
				ret = -10000;
				break;
			}
			
			int32_t index = vbound(ri->d[rINDEX]/10000,0,4);
			switch(index)
			{
				case 0:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG1)?10000:0; break;
				case 1:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG2)?10000:0; break;
				case 2:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG3)?10000:0; break;
				case 3:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG4)?10000:0; break;
				case 4:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG5)?10000:0; break;
				case 5:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG6)?10000:0; break;
				case 6:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG7)?10000:0; break;
				case 7:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG8)?10000:0; break;
				case 8:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG9)?10000:0; break;
				case 9:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG10)?10000:0; break;
				case 10:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG11)?10000:0; break;
				case 11:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG12)?10000:0; break;
				case 12:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG13)?10000:0; break;
				case 13:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG14)?10000:0; break;
				case 14:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG15)?10000:0; break;
				case 15:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG16)?10000:0; break;
				
				default: 
					ret = 0; break;
			}
				
			break;
		}
		
		case NPCFALLCLK:
			if(GuyH::loadNPC(ri->guyref, "npc->Falling") == SH::_NoError)
			{
				ret = GuyH::getNPC()->fallclk * 10000;
			}
			break;
		
		case NPCFALLCMB:
			if(GuyH::loadNPC(ri->guyref, "npc->FallCombo") == SH::_NoError)
			{
				ret = GuyH::getNPC()->fallCombo * 10000;
			}
			break;
			
		case NPCDROWNCLK:
			if(GuyH::loadNPC(ri->guyref, "npc->Drowning") == SH::_NoError)
			{
				ret = GuyH::getNPC()->drownclk * 10000;
			}
			break;
		
		case NPCDROWNCMB:
			if(GuyH::loadNPC(ri->guyref, "npc->DrownCombo") == SH::_NoError)
			{
				ret = GuyH::getNPC()->drownCombo * 10000;
			}
			break;
		
		case NPCFAKEZ:
		{
			if(GuyH::loadNPC(ri->guyref, "FakeZ") != SH::_NoError) 
			{
				ret = -10000; 
			}
			else 
			{
				if ( get_qr(qr_SPRITEXY_IS_FLOAT) )
				{
					ret = ((GuyH::getNPC()->fakez).getZLong()); 
				}
				else
				{
					ret = (int32_t(GuyH::getNPC()->fakez) * 10000);   
				}
			}
			break;
		}
		
		case NPCMOVEFLAGS:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->MoveFlags[]") == SH::_NoError)
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(BC::checkBounds(indx, 0, 15, "npc->MoveFlags[]") != SH::_NoError)
					ret = 0; //false
				else
				{
					//All bits, in order, of a single byte; just use bitwise
					ret = (GuyH::getNPC()->moveflags & (1<<indx)) ? 10000 : 0;
				}
			}
			break;
		}
		
		case NPCGLOWRAD:
			if(GuyH::loadNPC(ri->guyref, "npc->LightRadius") == SH::_NoError)
			{
				ret = GuyH::getNPC()->glowRad * 10000;
			}
			break;
			
		case NPCGLOWSHP:
			if(GuyH::loadNPC(ri->guyref, "npc->LightShape") == SH::_NoError)
			{
				ret = GuyH::getNPC()->glowShape * 10000;
			}
			break;
			
		case NPCSHADOWSPR:
			if(GuyH::loadNPC(ri->guyref, "npc->ShadowSprite") == SH::_NoError)
			{
				ret = GuyH::getNPC()->spr_shadow * 10000;
			}
			break;
		case NPCSPAWNSPR:
			if(GuyH::loadNPC(ri->guyref, "npc->SpawnSprite") == SH::_NoError)
			{
				ret = GuyH::getNPC()->spr_spawn * 10000;
			}
			break;
		case NPCDEATHSPR:
			if(GuyH::loadNPC(ri->guyref, "npc->DeathSprite") == SH::_NoError)
			{
				ret = GuyH::getNPC()->spr_death * 10000;
			}
			break;
		case NPCSWHOOKED:
			if(GuyH::loadNPC(ri->guyref, "npc->SwitchHooked") == SH::_NoError)
			{
				ret = GuyH::getNPC()->switch_hooked ? 10000 : 0;
			}
			break;
		case NPCCANFLICKER:
			if(GuyH::loadNPC(ri->guyref, "npc->InvFlicker") == SH::_NoError)
			{
				ret = GuyH::getNPC()->getCanFlicker() ? 10000 : 0;
			}
			break;
		case NPCFLICKERCOLOR:
			GET_NPC_VAR_INT(flickercolor, "npc->FlickerColor") break;
		case NPCFLASHINGCSET:
		{
			if (GuyH::loadNPC(ri->guyref, "npc->FlashingCSet") != SH::_NoError)
				ret = -10000;
			else
				ret = GuyH::getNPC()->getFlashingCSet() * 10000;
			break;
		}
		case NPCFLICKERTRANSP:
			GET_NPC_VAR_INT(flickertransp, "npc->FlickerTransparencyPasses") break;
		
		
		
		///----------------------------------------------------------------------------------------------------//
		//LWeapon Variables
		case LWPNSPECIAL:
			if(0!=(s=checkLWpn(ri->lwpn,"Special")))
				ret=((int32_t)((weapon*)(s))->specialinfo)*10000;
			
				
			break;
			
		case LWPNSCALE:
			if ( get_qr(qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"lweapon->Scale");
				ret = -1; break;
			}
			if(0!=(s=checkLWpn(ri->lwpn,"Scale")))
				ret=((int32_t)((weapon*)(s))->scale)*100.0;
				
			break;
		
		case LWPNX:
			if(0!=(s=checkLWpn(ri->lwpn,"X")))
			{
				if ( get_qr(qr_SPRITEXY_IS_FLOAT) )
				{
					ret=(((weapon*)(s))->x).getZLong();  
				}
				else 
					ret=((int32_t)((weapon*)(s))->x)*10000;
			}
				
			break;
		
		case SPRITEMAXLWPN:
		{
			//No bounds check, as this is a universal function and works from NULL pointers!
			ret = Lwpns.getMax() * 10000;
			break;
		}
	
		case LWPNY:
			if(0!=(s=checkLWpn(ri->lwpn,"Y")))
			{
				if ( get_qr(qr_SPRITEXY_IS_FLOAT) )
				{
					ret=(((weapon*)(s))->y).getZLong();  
				}
				else 
					ret=((int32_t)((weapon*)(s))->y)*10000;
			}
			break;
			
		case LWPNZ:
			if(0!=(s=checkLWpn(ri->lwpn,"Z")))
			{
				if ( get_qr(qr_SPRITEXY_IS_FLOAT) )
				{
					ret=(((weapon*)(s))->z).getZLong();  
				}
				else 
					ret=((int32_t)((weapon*)(s))->z)*10000;
			}
				
			break;
			
		case LWPNJUMP:
			if(0!=(s=checkLWpn(ri->lwpn,"Jump")))
			{
				ret = ((weapon*)(s))->fall.getZLong() / -100;
				if (get_qr(qr_SPRITE_JUMP_IS_TRUNCATED)) ret = trunc(ret / 10000) * 10000;
			}
				
			break;
		
		case LWPNFAKEJUMP:
			if(0!=(s=checkLWpn(ri->lwpn,"FakeJump")))
			{
				ret = ((weapon*)(s))->fakefall.getZLong() / -100;
				if (get_qr(qr_SPRITE_JUMP_IS_TRUNCATED)) ret = trunc(ret / 10000) * 10000;
			}
				
			break;
			
		case LWPNDIR:
			if(0!=(s=checkLWpn(ri->lwpn,"Dir")))
				ret=((weapon*)(s))->dir*10000;
				
			break;
		 
		case LWPNGRAVITY:
			if(0!=(s=checkLWpn(ri->lwpn,"Gravity")))
				ret= (((weapon*)(s))->moveflags & FLAG_OBEYS_GRAV) ? 10000 : 0;
				
			break;
			
		case LWPNSTEP:
			if(0!=(s=checkLWpn(ri->lwpn,"Step")))
			{
				if ( get_qr(qr_STEP_IS_FLOAT) || replay_is_active() )
				{
					ret=((weapon*)s)->step.getZLong() * 100;
				}
				//old, buggy code replication, round two: Go! -Z
				//else ret = ( ( ( ((weapon*)s)->step ) * 100.0 ).getZLong() );
				
				//else 
				//{
					//old, buggy code replication, round THREE: Go! -Z
				//	double tmp = ( ((weapon*)s)->step.getFloat() ) * 1000000.0;
				//	ret = (int32_t)tmp;
				//}
				
				//old, buggy code replication, round FOUR: Go! -Z
				else ret = (int32_t)((float)((weapon*)s)->step * 1000000.0);
			}
			break;
			
		case LWPNANGLE:
			if(0!=(s=checkLWpn(ri->lwpn,"Angle")))
				ret=(int32_t)(((weapon*)(s))->angle*10000);
				
			break;
		
		case LWPNDEGANGLE:
			if(0!=(s=checkLWpn(ri->lwpn,"DegAngle")))
			{
				ret=(int32_t)(((weapon*)(s))->angle*(180.0 / PI)*10000);
			}
				
			break;
			
		case LWPNVX:
			if(0!=(s=checkLWpn(ri->lwpn,"Vx")))
			{
				if (((weapon*)(s))->angular)
					ret = int32_t(zc::math::Cos(((weapon*)s)->angle)*10000.0*((weapon*)s)->step);
				else
				{
					switch(NORMAL_DIR(((weapon*)(s))->dir))
					{
						case l_up:
						case l_down:
						case left:
							ret = int32_t(-10000.0*((weapon*)s)->step);
							break;
							
						case r_down:
						case r_up:
						case right:
							ret = int32_t(10000.0*((weapon*)s)->step);
							break;
						
						default:
							ret = 0;
							break;
					}
				}
			}
				
			break;
		
		case LWPNVY:
			if(0!=(s=checkLWpn(ri->lwpn,"Vy")))
			{
				if (((weapon*)(s))->angular)
					ret = int32_t(zc::math::Sin(((weapon*)s)->angle)*10000.0*((weapon*)s)->step);
				else
				{
					switch(NORMAL_DIR(((weapon*)(s))->dir))
					{
						case l_up:
						case r_up:
						case up:
							ret = int32_t(-10000.0*((weapon*)s)->step);
							break;
						case l_down:
						case r_down:
						case down:
							ret = int32_t(10000.0*((weapon*)s)->step);
							break;
							
						default:
							ret = 0;
							break;
					}
				}
			}
				
			break;
				
		case LWPNANGULAR:
			if(0!=(s=checkLWpn(ri->lwpn,"Angular")))
				ret=((weapon*)(s))->angular*10000;
				
			break;
			
		case LWPNAUTOROTATE:
			if(0!=(s=checkLWpn(ri->lwpn,"AutoRotate")))
				ret=((weapon*)(s))->autorotate*10000;
				
			break;
			
		case LWPNBEHIND:
			if(0!=(s=checkLWpn(ri->lwpn,"Behind")))
				ret=((weapon*)(s))->behind*10000;
				
			break;
			
		case LWPNDRAWTYPE:
			if(0!=(s=checkLWpn(ri->lwpn,"DrawStyle")))
				ret=((weapon*)(s))->drawstyle*10000;
				
			break;
			
		case LWPNPOWER:
			if(0!=(s=checkLWpn(ri->lwpn,"Damage")))
				ret=((weapon*)(s))->power*10000;
				
			break;
		/*
		case LWPNRANGE:
			if(0!=(s=checkLWpn(ri->lwpn,"Range")))
				ret=((weapon*)(s))->scriptrange*10000;
				
			break;
		*/        
		case LWPNDEAD:
			if(0!=(s=checkLWpn(ri->lwpn,"DeadState")))
				ret=((weapon*)(s))->dead*10000;
				
			break;
			
		case LWPNID:
			if(0!=(s=checkLWpn(ri->lwpn,"ID")))
				ret=((weapon*)(s))->id*10000;
				
			break;
			
		case LWPNTILE:
			if(0!=(s=checkLWpn(ri->lwpn,"Tile")))
				ret=((weapon*)(s))->tile*10000;
				
			break;
		
		case LWPNSCRIPTTILE:
			if(0!=(s=checkLWpn(ri->lwpn,"ScriptTile")))
				ret=((weapon*)(s))->scripttile*10000;
				
			break;
		
		case LWPNSCRIPTFLIP:
			if(0!=(s=checkLWpn(ri->lwpn,"ScriptFlip")))
				ret=((weapon*)(s))->scriptflip*10000;
				
			break;
			
		case LWPNCSET:
			if(0!=(s=checkLWpn(ri->lwpn,"CSet")))
				ret=((weapon*)(s))->cs*10000;
				
			break;
			
		case LWPNFLASHCSET:
			if(0!=(s=checkLWpn(ri->lwpn,"FlashCSet")))
				ret=(((weapon*)(s))->o_cset>>4)*10000;
				
			break;
			
		case LWPNFRAMES:
			if(0!=(s=checkLWpn(ri->lwpn,"NumFrames")))
				ret=((weapon*)(s))->frames*10000;
				
			break;
			
		case LWPNFRAME:
			if(0!=(s=checkLWpn(ri->lwpn,"Frame")))
				ret=((weapon*)(s))->aframe*10000;
				
			break;
			
		case LWPNASPEED:
			if(0!=(s=checkLWpn(ri->lwpn,"ASpeed")))
				ret=((weapon*)(s))->o_speed*10000;
				
			break;
			
		case LWPNFLASH:
			if(0!=(s=checkLWpn(ri->lwpn,"Flash")))
				ret=((weapon*)(s))->flash*10000;
				
			break;
			
		case LWPNFLIP:
			if(0!=(s=checkLWpn(ri->lwpn,"Flip")))
				ret=((weapon*)(s))->flip*10000;
				
			break;
			
		case LWPNCOUNT:
			ret=Lwpns.Count()*10000;
			break;
			
		case LWPNEXTEND:
			if(0!=(s=checkLWpn(ri->lwpn,"Extend")))
				ret=((weapon*)(s))->extend*10000;
				
			break;
			
		case LWPNOTILE:
			if(0!=(s=checkLWpn(ri->lwpn,"OriginalTile")))
				ret=((weapon*)(s))->o_tile*10000;
				
			break;
			
		case LWPNOCSET:
			if(0!=(s=checkLWpn(ri->lwpn,"OriginalCSet")))
				ret=(((weapon*)(s))->o_cset&15)*10000;
				
			break;
			
		case LWPNHXOFS:
			if(0!=(s=checkLWpn(ri->lwpn,"HitXOffset")))
				ret=(((weapon*)(s))->hxofs)*10000;
				
			break;
			
		case LWPNHYOFS:
			if(0!=(s=checkLWpn(ri->lwpn,"HitYOffset")))
				ret=(((weapon*)(s))->hyofs)*10000;
				
			break;
			
		case LWPNXOFS:
			if(0!=(s=checkLWpn(ri->lwpn,"DrawXOffset")))
				ret=((int32_t)(((weapon*)(s))->xofs))*10000;
				
			break;
			
		case LWPNYOFS:
			if(0!=(s=checkLWpn(ri->lwpn,"DrawYOffset")))
				ret=((int32_t)(((weapon*)(s))->yofs-(get_qr(qr_OLD_DRAWOFFSET)?playing_field_offset:original_playing_field_offset)))*10000;
				
			break;
			
		case LWPNSHADOWXOFS:
			if(0!=(s=checkLWpn(ri->lwpn,"ShadowXOffset")))
				ret=((int32_t)(((weapon*)(s))->shadowxofs))*10000;
				
			break;
			
		case LWPNSHADOWYOFS:
			if(0!=(s=checkLWpn(ri->lwpn,"ShadowYOffset")))
				ret=((int32_t)(((weapon*)(s))->shadowyofs))*10000;
				
			break;
			
		case LWPNTOTALDYOFFS:
			if(0!=(s=checkLWpn(ri->lwpn,"TotalDYOffset")))
				ret = ((int32_t)(((weapon*)(s))->yofs-(get_qr(qr_OLD_DRAWOFFSET)?playing_field_offset:original_playing_field_offset))
					+ ((((weapon*)(s))->switch_hooked && Hero.switchhookstyle == swRISE)
						? -(8-(abs(Hero.switchhookclk-32)/4)) : 0)) * 10000;
			break;
			
		case LWPNZOFS:
			if(0!=(s=checkLWpn(ri->lwpn,"DrawZOffset")))
				ret=((int32_t)(((weapon*)(s))->zofs))*10000;
				
			break;
			
		case LWPNHXSZ:
			if(0!=(s=checkLWpn(ri->lwpn,"HitWidth")))
				ret=(((weapon*)(s))->hit_width)*10000;
				
			break;
			
		case LWPNHYSZ:
			if(0!=(s=checkLWpn(ri->lwpn,"HitHeight")))
				ret=(((weapon*)(s))->hit_height)*10000;
				
			break;
			
		case LWPNHZSZ:
			if(0!=(s=checkLWpn(ri->lwpn,"HitZHeight")))
				ret=(((weapon*)(s))->hzsz)*10000;
				
			break;
			
		case LWPNTXSZ:
			if(0!=(s=checkLWpn(ri->lwpn,"TileWidth")))
				ret=(((weapon*)(s))->txsz)*10000;
				
			break;
			
		case LWPNTYSZ:
			if(0!=(s=checkLWpn(ri->lwpn,"TileHeight")))
				ret=(((weapon*)(s))->tysz)*10000;
				
			break;
			
		case LWPNMISCD:
			if(0!=(s=checkLWpn(ri->lwpn,"Misc")))
			{
				int32_t a = vbound(ri->d[rINDEX]/10000,0,31);
				ret=(((weapon*)(s))->miscellaneous[a]);
			}
			
			break;
			
		case LWPNCOLLDET:
			if(0!=(s=checkLWpn(ri->lwpn,"CollDetection")))
				ret=(((weapon*)(s))->scriptcoldet)*10000;
				
			break;
		
		case LWPNENGINEANIMATE:
			if(0!=(s=checkLWpn(ri->lwpn,"Animation")))
				ret=(((weapon*)(s))->do_animation)*10000;
				
			break;
		
		case LWPNPARENT:
			if(0!=(s=checkLWpn(ri->lwpn,"Parent")))
				ret=(((weapon*)(s))->parentitem)*10000;
				
			break;

		case LWPNLEVEL:
			if(0!=(s=checkLWpn(ri->lwpn,"Level")))
				ret=(((weapon*)(s))->type)*10000;
				
			break;
		
		case LWPNSCRIPT:
			if(0!=(s=checkLWpn(ri->lwpn,"Script")))
				ret=(((weapon*)(s))->weaponscript)*10000;
				
			break;
		
		case LWPNUSEWEAPON:
			if(0!=(s=checkLWpn(ri->lwpn,"Weapon")))
				ret=(((weapon*)(s))->useweapon)*10000;
				
			break;
		
		case LWPNUSEDEFENCE:
			if(0!=(s=checkLWpn(ri->lwpn,"Defense")))
				ret=(((weapon*)(s))->usedefence)*10000;
				
			break;
		
		case LWPNINITD:
		{
			int32_t a = vbound((ri->d[rINDEX] / 10000),0,7);
			if(0!=(s=checkLWpn(ri->lwpn,"InitD[]")))
			{
				ret=(((weapon*)(s))->weap_initd[a]);
			}
			break;
		}
		
		case LWEAPONSCRIPTUID:
			if(0!=(s=checkLWpn(ri->lwpn,"ScriptUID")))
				ret=(((weapon*)(s))->script_UID); //literal, not *10000
				
			break;

		case LWPNROTATION:
			if ( get_qr(qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"lweapon->Rotation");
				ret = -1; break;
			}
			if(0!=(s=checkLWpn(ri->lwpn,"Rotation")))
				ret=((weapon*)(s))->rotation*10000;
				
			break;
		
		case LWPNFALLCLK:
			if(0!=(s=checkLWpn(ri->lwpn,"Falling")))
			{
				ret = ((weapon*)(s))->fallclk * 10000;
			}
			break;
		
		case LWPNFALLCMB:
			if(0!=(s=checkLWpn(ri->lwpn,"FallCombo")))
			{
				ret = ((weapon*)(s))->fallCombo * 10000;
			}
			break;
		
		case LWPNDROWNCLK:
			if(0!=(s=checkLWpn(ri->lwpn,"Drowning")))
			{
				ret = ((weapon*)(s))->drownclk * 10000;
			}
			break;
		
		case LWPNDROWNCMB:
			if(0!=(s=checkLWpn(ri->lwpn,"DrownCombo")))
			{
				ret = ((weapon*)(s))->drownCombo * 10000;
			}
			break;
			
		case LWPNFAKEZ:
			if(0!=(s=checkLWpn(ri->lwpn,"FakeZ")))
			{
				if ( get_qr(qr_SPRITEXY_IS_FLOAT) )
				{
					ret=(((weapon*)(s))->fakez).getZLong();  
				}
				else 
					ret=((int32_t)((weapon*)(s))->fakez)*10000;
			}
			break;
		
		case LWPNMOVEFLAGS:
		{
			if(0!=(s=checkLWpn(ri->lwpn,"MoveFlags[]")))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(BC::checkBounds(indx, 0, 10, "lweapon->MoveFlags[]") != SH::_NoError)
					ret = 0; //false
				else
				{
					//All bits, in order, of a single byte; just use bitwise
					ret = (((weapon*)(s))->moveflags & (1<<indx)) ? 10000 : 0;
				}
			}
			break;
		}
		case LWPNFLAGS:
		{
			if(0!=(s=checkLWpn(ri->lwpn,"Flags[]")))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(BC::checkBounds(indx, 0, WFLAG_MAX-1, "lweapon->Flags[]") != SH::_NoError)
					ret = 0; //false
				else
				{
					//All bits, in order, of a single byte; just use bitwise
					ret = (((weapon*)(s))->misc_wflags & (1<<indx)) ? 10000 : 0;
				}
			}
			break;
		}
		case LWPNSPRITES:
		{
			if(0!=(s=checkLWpn(ri->lwpn,"Sprites[]")))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(BC::checkBounds(indx, 0, WPNSPR_MAX-1, "lweapon->Sprites[]") != SH::_NoError)
					ret = -10000;
				else
					ret = ((weapon*)(s))->misc_wsprites[indx]*10000;
			}
			break;
		}
		case LWPNBURNLIGHTRADIUS:
		{
			if(0!=(s=checkLWpn(ri->lwpn,"BurnLightRadius[]")))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(BC::checkBounds(indx, 0, WPNSPR_MAX-1, "lweapon->BurnLightRadius[]") != SH::_NoError)
					ret = -10000;
				else
					ret = ((weapon*)(s))->light_rads[indx]*10000;
			}
			break;
		}
		
		case LWPNGLOWRAD:
			if(0!=(s=checkLWpn(ri->lwpn,"LightRadius")))
			{
				ret = ((weapon*)(s))->glowRad * 10000;
			}
			break;
			
		case LWPNGLOWSHP:
			if(0!=(s=checkLWpn(ri->lwpn,"LightShape")))
			{
				ret = ((weapon*)(s))->glowShape * 10000;
			}
			break;
			
		case LWPNUNBL:
			if(0!=(s=checkLWpn(ri->lwpn,"Unblockable")))
			{
				ret = ((weapon*)(s))->unblockable * 10000;
			}
			break;
			
		case LWPNSHADOWSPR:
			if(0!=(s=checkLWpn(ri->lwpn,"ShadowSprite")))
			{
				ret = ((weapon*)(s))->spr_shadow * 10000;
			}
			break;
		case LWSWHOOKED:
			if(0!=(s=checkLWpn(ri->lwpn,"SwitchHooked")))
			{
				ret = s->switch_hooked ? 10000 : 0;
			}
			break;
		case LWPNTIMEOUT:
			if(0!=(s=checkLWpn(ri->lwpn,"Timeout")))
			{
				ret = ((weapon*)(s))->weap_timeout * 10000;
			}
			break;
		case LWPNDEATHITEM:
			if(0!=(s=checkLWpn(ri->lwpn,"DeathItem")))
			{
				ret = ((weapon*)(s))->death_spawnitem * 10000;
			}
			break;
		case LWPNDEATHDROPSET:
			if(0!=(s=checkLWpn(ri->lwpn,"DeathDropset")))
			{
				ret = ((weapon*)(s))->death_spawndropset * 10000;
			}
			break;
		case LWPNDEATHIPICKUP:
			if(0!=(s=checkLWpn(ri->lwpn,"DeathItemPFlags")))
			{
				ret = ((weapon*)(s))->death_item_pflags * 10000;
			}
			break;
		case LWPNDEATHSPRITE:
			if(0!=(s=checkLWpn(ri->lwpn,"DeathSprite")))
			{
				ret = ((weapon*)(s))->death_sprite * 10000;
			}
			break;
		case LWPNDEATHSFX:
			if(0!=(s=checkLWpn(ri->lwpn,"DeathSFX")))
			{
				ret = ((weapon*)(s))->death_sfx * 10000;
			}
			break;
		case LWPNLIFTLEVEL:
			if(0!=(s=checkLWpn(ri->lwpn,"LiftLevel")))
			{
				ret = ((weapon*)(s))->lift_level * 10000;
			}
			break;
		case LWPNLIFTTIME:
			if(0!=(s=checkLWpn(ri->lwpn,"LiftTime")))
			{
				ret = ((weapon*)(s))->lift_time * 10000;
			}
			break;
		case LWPNLIFTHEIGHT:
			if(0!=(s=checkLWpn(ri->lwpn,"LiftHeight")))
			{
				ret = ((weapon*)(s))->lift_height.getZLong();
			}
			break;
			
		///----------------------------------------------------------------------------------------------------//
		//EWeapon Variables
		case EWPNSCALE:
			if ( get_qr(qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"eweapon->Scale");
				ret = -1; break;
			}
			if(0!=(s=checkEWpn(ri->ewpn, "Scale")))
				ret=((int32_t)((weapon*)(s))->scale)*100.0;
				
			break;

		case EWPNX:
			if(0!=(s=checkEWpn(ri->ewpn, "X")))
			{
				if ( get_qr(qr_SPRITEXY_IS_FLOAT) )
				{
					ret=(((weapon*)(s))->x).getZLong();
				}
				else 
					ret=((int32_t)((weapon*)(s))->x)*10000;
			}
			break;
			
		case SPRITEMAXEWPN:
		{
			//No bounds check, as this is a universal function and works from NULL pointers!
			ret = Ewpns.getMax() * 10000;
			break;
		}
	
		case EWPNY:
			if(0!=(s=checkEWpn(ri->ewpn, "Y")))
			{
				if ( get_qr(qr_SPRITEXY_IS_FLOAT) )
				{
					ret=(((weapon*)(s))->y).getZLong();
				}
				else 
					 ret=((int32_t)((weapon*)(s))->y)*10000;
			}
			break;
			
		case EWPNZ:
			if(0!=(s=checkEWpn(ri->ewpn, "Z")))
			{
				if ( get_qr(qr_SPRITEXY_IS_FLOAT) )
				{
					ret=(((weapon*)(s))->z).getZLong();
				}
				else 
					ret=((int32_t)((weapon*)(s))->z)*10000;
			}
			break;
			
		case EWPNJUMP:
			if(0!=(s=checkEWpn(ri->ewpn, "Jump")))
			{
				ret = ((weapon*)(s))->fall.getZLong() / -100;
				if (get_qr(qr_SPRITE_JUMP_IS_TRUNCATED)) ret = trunc(ret / 10000) * 10000;
			}
				
			break;
		
		case EWPNFAKEJUMP:
			if(0!=(s=checkEWpn(ri->ewpn, "FakeJump")))
			{
				ret = ((weapon*)(s))->fakefall.getZLong() / -100;
				if (get_qr(qr_SPRITE_JUMP_IS_TRUNCATED)) ret = trunc(ret / 10000) * 10000;
			}
				
			break;
			
		case EWPNDIR:
			if(0!=(s=checkEWpn(ri->ewpn, "Dir")))
				ret=((weapon*)(s))->dir*10000;
				
			break;
			
		case EWPNLEVEL:
			if(0!=(s=checkEWpn(ri->ewpn, "Level")))
				ret=((weapon*)(s))->type*10000;
				
			break;
			
		case EWPNGRAVITY:
			if(0!=(s=checkEWpn(ri->ewpn, "Gravity")))
				ret=((((weapon*)(s))->moveflags & FLAG_OBEYS_GRAV) ? 10000 : 0);
				
			break;
			
		case EWPNSTEP:
			if(0!=(s=checkEWpn(ri->ewpn, "Step")))
			{
				if ( get_qr(qr_STEP_IS_FLOAT) || replay_is_active() )
				{
					ret=((weapon*)s)->step.getZLong() * 100;
				}
				//old, buggy code replication, round two: Go! -Z
				//else ret = ( ( ( ((weapon*)s)->step ) * 100.0 ).getZLong() );
				//old, buggy code replication, round FOUR: Go! -Z
				else ret = (int32_t)((float)((weapon*)s)->step * 1000000.0);
			}
			//else 
			//{
				//old, buggy code replication, round THREE: Go! -Z
			//	double tmp = ( ((weapon*)s)->step.getFloat() ) * 1000000.0;
			//	ret = int32_t(tmp);
			//}
			break;
			
		case EWPNANGLE:
			if(0!=(s=checkEWpn(ri->ewpn,"Angle")))
				ret=(int32_t)(((weapon*)(s))->angle*10000);
				
			break;
			
		case EWPNDEGANGLE:
			if(0!=(s=checkEWpn(ri->ewpn,"DegAngle")))
			{
				ret=(int32_t)(((weapon*)(s))->angle*(180.0 / PI)*10000);
			}
				
			break;
			
		case EWPNVX:
			if(0!=(s=checkEWpn(ri->ewpn,"Vx")))
			{
				if (((weapon*)(s))->angular)
					ret = int32_t(zc::math::Cos(((weapon*)s)->angle)*10000.0*((weapon*)s)->step);
				else
				{
					switch(NORMAL_DIR(((weapon*)(s))->dir))
					{
						case l_up:
						case l_down:
						case left:
							ret = int32_t(-10000.0*((weapon*)s)->step);
							break;
						case r_up:
						case r_down:
						case right:
							ret = int32_t(10000.0*((weapon*)s)->step);
							break;
							
						default:
							ret = 0;
							break;
					}
				}
			}
				
			break;
		
		case EWPNVY:
			if(0!=(s=checkEWpn(ri->ewpn,"Vy")))
			{
				if (((weapon*)(s))->angular)
					ret = int32_t(zc::math::Sin(((weapon*)s)->angle)*10000.0*((weapon*)s)->step);
				else
				{
					switch(NORMAL_DIR(((weapon*)(s))->dir))
					{
						case l_up:
						case r_up:
						case up:
							ret = int32_t(-10000.0*((weapon*)s)->step);
							break;
						case l_down:
						case r_down:
						case down:
							ret = int32_t(10000.0*((weapon*)s)->step);
							break;
							
						default:
							ret = 0;
							break;
					}
				}
			}
				
			break;
			
			
		case EWPNANGULAR:
			if(0!=(s=checkEWpn(ri->ewpn,"Angular")))
				ret=((weapon*)(s))->angular*10000;
				
			break;
			
		case EWPNAUTOROTATE:
			if(0!=(s=checkEWpn(ri->ewpn,"AutoRotate")))
				ret=((weapon*)(s))->autorotate*10000;
				
			break;
			
		case EWPNBEHIND:
			if(0!=(s=checkEWpn(ri->ewpn,"Behind")))
				ret=((weapon*)(s))->behind*10000;
				
			break;
			
		case EWPNDRAWTYPE:
			if(0!=(s=checkEWpn(ri->ewpn,"DrawStyle")))
				ret=((weapon*)(s))->drawstyle*10000;
				
			break;
			
		case EWPNPOWER:
			if(0!=(s=checkEWpn(ri->ewpn,"Damage")))
				ret=((weapon*)(s))->power*10000;
				
			break;
			
		case EWPNDEAD:
			if(0!=(s=checkEWpn(ri->ewpn,"DeadState")))
				ret=((weapon*)(s))->dead*10000;
				
			break;
			
		case EWPNID:
			if(0!=(s=checkEWpn(ri->ewpn,"ID")))
				ret=((weapon*)(s))->id*10000;
				
			break;
			
		case EWPNTILE:
			if(0!=(s=checkEWpn(ri->ewpn,"Tile")))
				ret=((weapon*)(s))->tile*10000;
				
			break;
		
		case EWPNSCRIPTTILE:
			if(0!=(s=checkEWpn(ri->ewpn,"ScriptTile")))
				ret=((weapon*)(s))->scripttile*10000;
				
			break;
		
		case EWPNSCRIPTFLIP:
			if(0!=(s=checkEWpn(ri->ewpn,"ScriptFlip")))
				ret=((weapon*)(s))->scriptflip*10000;
				
			break;
			
		case EWPNCSET:
			if(0!=(s=checkEWpn(ri->ewpn,"CSet")))
				ret=((weapon*)(s))->cs*10000;
				
			break;
			
		case EWPNFLASHCSET:
			if(0!=(s=checkEWpn(ri->ewpn,"FlashCSet")))
				ret=(((weapon*)(s))->o_cset>>4)*10000;
				
			break;
			
		case EWPNFRAMES:
			if(0!=(s=checkEWpn(ri->ewpn,"NumFrames")))
				ret=((weapon*)(s))->frames*10000;
				
			break;
			
		case EWPNFRAME:
			if(0!=(s=checkEWpn(ri->ewpn,"Frame")))
				ret=((weapon*)(s))->aframe*10000;
				
			break;
			
		case EWPNASPEED:
			if(0!=(s=checkEWpn(ri->ewpn,"ASpeed")))
				ret=((weapon*)(s))->o_speed*10000;
				
			break;
			
		case EWPNFLASH:
			if(0!=(s=checkEWpn(ri->ewpn,"Flash")))
				ret=((weapon*)(s))->flash*10000;
				
			break;
			
		case EWPNFLIP:
			if(0!=(s=checkEWpn(ri->ewpn,"Flip")))
				ret=((weapon*)(s))->flip*10000;
				
			break;

		case EWPNROTATION:
			if ( get_qr(qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"eweapon->Rotation");
				break;
			}
			if(0!=(s=checkEWpn(ri->ewpn,"Rotation")))
				ret=((weapon*)(s))->rotation*10000;
				
			break;

		case EWPNCOUNT:
			ret=Ewpns.Count()*10000;
			break;
			
		case EWPNEXTEND:
			if(0!=(s=checkEWpn(ri->ewpn,"Extend")))
				ret=((weapon*)(s))->extend*10000;
				
			break;
			
		case EWPNOTILE:
			if(0!=(s=checkEWpn(ri->ewpn,"OriginalTile")))
				ret=((weapon*)(s))->o_tile*10000;
				
			break;
			
		case EWPNOCSET:
			if(0!=(s=checkEWpn(ri->ewpn,"OriginalCSet")))
				ret=(((weapon*)(s))->o_cset&15)*10000;
				
			break;
			
		case EWPNHXOFS:
			if(0!=(s=checkEWpn(ri->ewpn,"HitXOffset")))
				ret=(((weapon*)(s))->hxofs)*10000;
				
			break;
			
		case EWPNHYOFS:
			if(0!=(s=checkEWpn(ri->ewpn,"HitYOffset")))
				ret=(((weapon*)(s))->hyofs)*10000;
				
			break;
			
		case EWPNXOFS:
			if(0!=(s=checkEWpn(ri->ewpn,"DrawXOffset")))
				ret=((int32_t)(((weapon*)(s))->xofs))*10000;
				
			break;
			
		case EWPNYOFS:
			if(0!=(s=checkEWpn(ri->ewpn,"DrawYOffset")))
				ret=((int32_t)(((weapon*)(s))->yofs-(get_qr(qr_OLD_DRAWOFFSET)?playing_field_offset:original_playing_field_offset)))*10000;
				
			break;
			
		case EWPNSHADOWXOFS:
			if(0!=(s=checkEWpn(ri->ewpn,"ShadowXOffset")))
				ret=((int32_t)(((weapon*)(s))->shadowxofs))*10000;
				
			break;
			
		case EWPNSHADOWYOFS:
			if(0!=(s=checkEWpn(ri->ewpn,"ShadowYOffset")))
				ret=((int32_t)(((weapon*)(s))->shadowyofs))*10000;
				
			break;
		case EWPNTOTALDYOFFS:
			if(0!=(s=checkLWpn(ri->ewpn,"TotalDYOffset")))
				ret = ((int32_t)(((weapon*)(s))->yofs-(get_qr(qr_OLD_DRAWOFFSET)?playing_field_offset:original_playing_field_offset))
					+ ((((weapon*)(s))->switch_hooked && Hero.switchhookstyle == swRISE)
						? -(8-(abs(Hero.switchhookclk-32)/4)) : 0) * 10000);
			break;
			
		case EWPNZOFS:
			if(0!=(s=checkEWpn(ri->ewpn,"DrawZOffset")))
				ret=((int32_t)(((weapon*)(s))->zofs))*10000;
				
			break;
			
		case EWPNHXSZ:
			if(0!=(s=checkEWpn(ri->ewpn,"HitWidth")))
				ret=(((weapon*)(s))->hit_width)*10000;
				
			break;
			
		case EWPNHYSZ:
			if(0!=(s=checkEWpn(ri->ewpn,"HitHeight")))
				ret=(((weapon*)(s))->hit_height)*10000;
				
			break;
			
		case EWPNHZSZ:
			if(0!=(s=checkEWpn(ri->ewpn,"HitZHeight")))
				ret=(((weapon*)(s))->hzsz)*10000;
				
			break;
			
		case EWPNTXSZ:
			if(0!=(s=checkEWpn(ri->ewpn,"TileWidth")))
				ret=(((weapon*)(s))->txsz)*10000;
				
			break;
			
		case EWPNTYSZ:
			if(0!=(s=checkEWpn(ri->ewpn,"TileHeight")))
				ret=(((weapon*)(s))->tysz)*10000;
				
			break;
			
		case EWPNMISCD:
			if(0!=(s=checkEWpn(ri->ewpn,"Misc")))
			{
				int32_t a = vbound(ri->d[rINDEX]/10000,0,31);
				ret=(((weapon*)(s))->miscellaneous[a]);
			}
			
			break;
			
		case EWPNCOLLDET:
			if(0!=(s=checkEWpn(ri->ewpn,"CollDetection")))
				ret=(((weapon*)(s))->scriptcoldet)*10000;
				
			break;
		
		case EWPNENGINEANIMATE:
			if(0!=(s=checkEWpn(ri->ewpn,"Animation")))
				ret=(((weapon*)(s))->do_animation)*10000;
				
			break;
		
		case EWPNPARENT:
			if(0!=(s=checkEWpn(ri->ewpn, "Parent")))
				ret= ((get_qr(qr_OLDEWPNPARENT)) ? (((weapon*)(s))->parentid)*10000 : (((weapon*)(s))->parentid));
		
			break;
		
		case EWEAPONSCRIPTUID:
			if(0!=(s=checkEWpn(ri->ewpn, "ScriptUID")))
				ret=(((weapon*)(s))->script_UID); //literal, not *10000
				
			break;
		
		case EWPNPARENTUID:
			if(0!=(s=checkEWpn(ri->ewpn, "ParentUID")))
				ret=(((weapon*)(s))->parent_script_UID); //literal, not *10000
				
			break;
		
		case EWPNSCRIPT:
			if(0!=(s=checkEWpn(ri->ewpn,"Script")))
				ret=(((weapon*)(s))->weaponscript)*10000;
				
			break;
		
		case EWPNINITD:
		{
			int32_t a = vbound((ri->d[rINDEX] / 10000),0,7);
			if(0!=(s=checkEWpn(ri->ewpn,"InitD[]")))
			{
				ret=(((weapon*)(s))->weap_initd[a]);
			}
			break;
		}
		
		case EWPNFALLCLK:
			if(0!=(s=checkEWpn(ri->ewpn,"Falling")))
			{
				ret = ((weapon*)(s))->fallclk * 10000;
			}
			break;
		
		case EWPNFALLCMB:
			if(0!=(s=checkEWpn(ri->ewpn,"FallCombo")))
			{
				ret = ((weapon*)(s))->fallCombo * 10000;
			}
			break;
		
		case EWPNDROWNCLK:
			if(0!=(s=checkEWpn(ri->ewpn,"Drowning")))
			{
				ret = ((weapon*)(s))->drownclk * 10000;
			}
			break;
		
		case EWPNDROWNCMB:
			if(0!=(s=checkEWpn(ri->ewpn,"DrownCombo")))
			{
				ret = ((weapon*)(s))->drownCombo * 10000;
			}
			break;
		case EWPNFAKEZ:
			if(0!=(s=checkEWpn(ri->ewpn, "FakeZ")))
			{
				if ( get_qr(qr_SPRITEXY_IS_FLOAT) )
				{
					ret=(((weapon*)(s))->fakez).getZLong();
				}
				else 
					ret=((int32_t)((weapon*)(s))->fakez)*10000;
			}
			break;
		
		case EWPNMOVEFLAGS:
		{
			if(0!=(s=checkEWpn(ri->ewpn,"MoveFlags[]")))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(BC::checkBounds(indx, 0, 10, "eweapon->MoveFlags[]") != SH::_NoError)
					ret = 0; //false
				else
				{
					//All bits, in order, of a single byte; just use bitwise
					ret = (((weapon*)(s))->moveflags & (1<<indx)) ? 10000 : 0;
				}
			}
			break;
		}
		case EWPNFLAGS:
		{
			if(0!=(s=checkEWpn(ri->ewpn,"Flags[]")))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(BC::checkBounds(indx, 0, WFLAG_MAX-1, "eweapon->Flags[]") != SH::_NoError)
					ret = 0; //false
				else
				{
					//All bits, in order, of a single byte; just use bitwise
					ret = (((weapon*)(s))->misc_wflags & (1<<indx)) ? 10000 : 0;
				}
			}
			break;
		}
		case EWPNSPRITES:
		{
			if(0!=(s=checkEWpn(ri->ewpn,"Sprites[]")))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(BC::checkBounds(indx, 0, WPNSPR_MAX-1, "eweapon->Sprites[]") != SH::_NoError)
					ret = -10000;
				else
					ret = ((weapon*)(s))->misc_wsprites[indx]*10000;
			}
			break;
		}
		case EWPNBURNLIGHTRADIUS:
		{
			if(0!=(s=checkEWpn(ri->ewpn,"BurnLightRadius[]")))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(BC::checkBounds(indx, 0, WPNSPR_MAX-1, "eweapon->BurnLightRadius[]") != SH::_NoError)
					ret = -10000;
				else
					ret = ((weapon*)(s))->light_rads[indx]*10000;
			}
			break;
		}
		
		case EWPNGLOWRAD:
			if(0!=(s=checkEWpn(ri->ewpn,"LightRadius")))
			{
				ret = ((weapon*)(s))->glowRad * 10000;
			}
			break;
			
		case EWPNGLOWSHP:
			if(0!=(s=checkEWpn(ri->ewpn,"LightShape")))
			{
				ret = ((weapon*)(s))->glowShape * 10000;
			}
			break;
			
		case EWPNUNBL:
			if(0!=(s=checkEWpn(ri->ewpn,"Unblockable")))
			{
				ret = ((weapon*)(s))->unblockable * 10000;
			}
			break;
			
		case EWPNSHADOWSPR:
			if(0!=(s=checkEWpn(ri->ewpn,"ShadowSprite")))
			{
				ret = ((weapon*)(s))->spr_shadow * 10000;
			}
			break;
		case EWSWHOOKED:
			if(0!=(s=checkEWpn(ri->ewpn,"SwitchHooked")))
			{
				ret = s->switch_hooked ? 10000 : 0;
			}
			break;
		case EWPNTIMEOUT:
			if(0!=(s=checkEWpn(ri->ewpn,"Timeout")))
			{
				ret = ((weapon*)(s))->weap_timeout * 10000;
			}
			break;
		case EWPNDEATHITEM:
			if(0!=(s=checkEWpn(ri->ewpn,"DeathItem")))
			{
				ret = ((weapon*)(s))->death_spawnitem * 10000;
			}
			break;
		case EWPNDEATHDROPSET:
			if(0!=(s=checkEWpn(ri->ewpn,"DeathDropset")))
			{
				ret = ((weapon*)(s))->death_spawndropset * 10000;
			}
			break;
		case EWPNDEATHIPICKUP:
			if(0!=(s=checkEWpn(ri->ewpn,"DeathItemPFlags")))
			{
				ret = ((weapon*)(s))->death_item_pflags * 10000;
			}
			break;
		case EWPNDEATHSPRITE:
			if(0!=(s=checkEWpn(ri->ewpn,"DeathSprite")))
			{
				ret = ((weapon*)(s))->death_sprite * 10000;
			}
			break;
		case EWPNDEATHSFX:
			if(0!=(s=checkEWpn(ri->ewpn,"DeathSFX")))
			{
				ret = ((weapon*)(s))->death_sfx * 10000;
			}
			break;
		case EWPNLIFTLEVEL:
			if(0!=(s=checkEWpn(ri->ewpn,"LiftLevel")))
			{
				ret = ((weapon*)(s))->lift_level * 10000;
			}
			break;
		case EWPNLIFTTIME:
			if(0!=(s=checkEWpn(ri->ewpn,"LiftTime")))
			{
				ret = ((weapon*)(s))->lift_time * 10000;
			}
			break;
		case EWPNLIFTHEIGHT:
			if(0!=(s=checkEWpn(ri->ewpn,"LiftHeight")))
			{
				ret = ((weapon*)(s))->lift_height.getZLong();
			}
			break;
		
		/*
		case LWEAPONSCRIPTUID:
			if(0!=(s=checkLWpn(ri->lwpn,"ScriptUID")))
				ret=(((weapon*)(s))->getScriptUID()); //literal, not *10000
				
			break;
		case EWEAPONSCRIPTUID:
			if(0!=(s=checkLWpn(ri->ewpn,"ScriptUID")))
				ret=(((weapon*)(s))->getScriptUID()); //literal, not *10000
				
			break;
		*/
			
		///----------------------------------------------------------------------------------------------------//
		//Game Info
		
		
		case GAMEPLAYFIELDOFS:
			ret = playing_field_offset*10000;
			break;
		
		case GETPIXEL:
			ret=FFCore.do_getpixel();
			break;

		
		case ZELDAVERSION:
		{
			auto version = getVersion();
			ret = version.major * 10000 + version.minor * 100 + version.patch; //Do *not* multiply by 10,000!
			break;
		}
		case ZELDABUILD:
			ret = (int32_t)VERSION_BUILD*10000;
			break;
		
		case ZSCRIPTVERSION: 
		{
			ret = (FFCore.quest_format[vLastCompile]) * 10000;
			break;
		}
		
		case ZELDABETATYPE:
		{
			ret = int32_t(getAlphaState()*10000);
			break;
		}
		case ZELDABETA:
		{
			int ver = 120;
			ret = int32_t(ver*10000);
			break;
		}
		case GAMEDEATHS:
			ret=game->get_deaths()*10000;
			break;
			
		case GAMECHEAT:
			ret=cheat*10000;
			break;
			
		case GAMEMAXCHEAT:
			ret=maxcheat*10000;
			break;
			
		case GAMETIME:
			ret=game->get_time();
			break;// Can't multiply by 10000 or the maximum result is too big
		case ACTIVESSSPEED:
			ret=Hero.subscr_speed*10000;
			break;// Can't multiply by 10000 or the maximum result is too big
			
		case GAMETIMEVALID:
			ret=game->get_timevalid()?10000:0;
			break;
			
		case GAMEHASPLAYED:
			ret=game->get_hasplayed()?10000:0;
			break;
		
		case TYPINGMODE:
			ret=FFCore.kb_typing_mode?10000:0;
			break;
		
		case SKIPCREDITS:
			ret=FFCore.skip_ending_credits?10000:0;
			break;
		
		case SKIPF6:
			ret=get_qr(qr_NOCONTINUE)?10000:0;
			break;
			
		case GAMESTANDALONE:
			ret=standalone_mode?10000:0;
			break;
			
		case GAMEGUYCOUNT:
		{
			int32_t mi = (currmap*MAPSCRSNORMAL)+(ri->d[rINDEX]/10000);
			ret=game->guys[mi]*10000;
		}
		break;
		
		case GAMECONTSCR:
			ret=game->get_continue_scrn()*10000;
			break;
			
		case GAMECONTDMAP:
			ret=game->get_continue_dmap()*10000;
			break;
			
		case GAMEENTRSCR:
			ret=lastentrance*10000;
			break;
			
		case GAMEENTRDMAP:
			ret=lastentrance_dmap*10000;
			break;
			
		case GAMECOUNTERD:
			ret=game->get_counter((ri->d[rINDEX])/10000)*10000;
			break;
			
		case GAMEMCOUNTERD:
			ret=game->get_maxcounter((ri->d[rINDEX])/10000)*10000;
			break;
			
		case GAMEDCOUNTERD:
			ret=game->get_dcounter((ri->d[rINDEX])/10000)*10000;
			break;
			
		case GAMEGENERICD:
		{
			auto indx = ri->d[rINDEX] / 10000;
			switch(indx)
			{
				case genCONTHP:
				{
					if(!get_qr(qr_SCRIPT_CONTHP_IS_HEARTS) || game->get_cont_percent())
						ret = game->get_generic(indx)*10000;
					else
						ret = (game->get_generic(indx)/game->get_hp_per_heart())*10000;
					break;
				}
				default:
					ret = game->get_generic(indx)*10000;
					break;
			}
			break;
		}
		
		case GAMEMISC:
		{
			int32_t indx = ri->d[rINDEX]/10000;
			if ( indx < 0 || indx > 31 )
			{
				ret = -10000;
				Z_scripterrlog("Invalid index used to access Game->Misc: %d\n", indx);
			}
			else
			{
				ret = QMisc.questmisc[indx]*((get_qr(qr_OLDQUESTMISC)) ? 10000 : 1);
			}
			break;
		}
			
		case GAMEITEMSD:
			ret=(game->item[(ri->d[rINDEX])/10000] ? 10000 : 0);
			break;
		case DISABLEDITEM:
			ret = (game->items_off[(ri->d[rINDEX])/10000] ? 10000 : 0);
			break;
		case GAMESUSPEND:
		{
			int32_t inx = (ri->d[rINDEX])/10000;
			if ( (unsigned) inx > (susptLAST-1) )
			{
				Z_scripterrlog("Invalid array index [%d] passed to Game->Suspend[]\n");
			}
			ret = (( FFCore.system_suspend[inx] ) ? 10000 : 0);
			break;
		}
		case GAMELITEMSD:
		{
			size_t index = ri->d[rINDEX] / 10000;
			if (index >= game->lvlitems.size())
			{
				ret = 0;
				Z_scripterrlog("Invalid array index [%d] passed to Game->LItems[]\n", index);
				break;
			}
			ret=game->lvlitems[index]*10000;
			break;
		}
		case GAMELSWITCH:
		{
			int32_t ind = (ri->d[rINDEX])/10000;
			if(unsigned(ind) >= MAXLEVELS)
				ret = 0;
			else ret=game->lvlswitches[ind];
			break;
		}
		case GAMEGSWITCH:
		{
			int32_t ind = (ri->d[rINDEX])/10000;
			if(unsigned(ind) >= NUM_GSWITCHES)
				ret = 0;
			else ret=game->gswitch_timers[ind]*10000;
			break;
		}
		case GAMEBOTTLEST:
			ret=game->get_bottle_slot((ri->d[rINDEX])/10000)*10000;
			break;
			
		case GAMELKEYSD:
			ret=game->lvlkeys[(ri->d[rINDEX])/10000]*10000;
			break;

		case TANGOARR:
		{
			int32_t inx = (ri->d[rINDEX])/10000;
			if ( ((unsigned)inx) > 255 )
			{
				Z_scripterrlog("Invalid index %d supplied to Game->Tango[].\n", inx);
				ret = -10000;
				break;
			}
			else
			{
				ret=FFCore.TangoArray[inx]*10000;
				break;
			}
		}
		case GHOSTARR:
		{
			int32_t inx = (ri->d[rINDEX])/10000;
			if ( ((unsigned)inx) > 255 )
			{
				Z_scripterrlog("Invalid index %d supplied to Game->Ghost[].\n", inx);
				ret = -10000;
				break;
			}
			else
			{
				ret=FFCore.GhostArray[inx]*10000;
				break;
			}
		}
		case STDARR:
		{
			int32_t inx = (ri->d[rINDEX])/10000;
			if ( ((unsigned)inx) > 255 )
			{
				Z_scripterrlog("Invalid index %d supplied to Game->STD[].\n", inx);
				ret = -10000;
				break;
			}
			else
			{
				ret=FFCore.StdArray[inx]*10000;
				break;
			}
		}
		
		case GAMEMISCSPR:
		{
			int32_t inx = (ri->d[rINDEX])/10000;
			if ( ((unsigned)inx) > sprMAX )
			{
				Z_scripterrlog("Invalid index %d supplied to Game->MiscSprites[].\n", inx);
				ret = -10000;
			}
			else
			{
				ret = QMisc.sprites[inx] * 10000;
			}
			break;
		}
		case GAMEMISCSFX:
		{
			int32_t inx = (ri->d[rINDEX])/10000;
			if ( ((unsigned)inx) > sfxMAX )
			{
				Z_scripterrlog("Invalid index %d supplied to Game->MiscSFX[].\n", inx);
				ret = -10000;
			}
			else
			{
				ret = QMisc.miscsfx[inx] * 10000;
			}
			break;
		}
		case GAMEOVERRIDEITEMS:
		{
			int32_t ind = (ri->d[rINDEX])/10000;
			if(unsigned(ind) >= itype_max)
			{
				Z_scripterrlog("Invalid index %d supplied to Game->OverrideItems[].\n", ind);
				ret = -20000;
			}
			else ret = game->OverrideItems[ind] * 10000;
			break;
		}
		case GAMEEVENTDATA:
		{
			int32_t inx = (ri->d[rINDEX])/10000;
			ret = 0;
			if ( ((unsigned)inx) < FFCore.eventData.size() )
			{
				ret = FFCore.eventData[inx];
			}
			break;
		}
		case GAMEMOUSECURSOR:
		{
			ret = game_mouse_index*10000;
			break;
		}
		case GAMETRIGGROUPS:
		{
			int32_t ind = (ri->d[rINDEX])/10000;
			if(unsigned(ind)>255)
				Z_scripterrlog("Invalid index %d supplied to Game->TrigGroups[]\n",ind);
			ret = cpos_trig_group_count(ind)*10000;
			break;
		}
		
		case GAMEGRAVITY:
		{
			int32_t indx = ri->d[rINDEX]/10000;
			if ( ((unsigned)indx) > 3 )
			//if(indx < 0 || indx > 2)
			{
				ret = -10000;
				Z_scripterrlog("Invalid index used to access Game->Gravity[]: %d\n", indx);
			}
			else
			{
				switch(indx)
				{
					case 0: //Gravity Strength
						ret = zinit.gravity;
						break;
					case 1: //Terminal Velocity
						ret = zinit.terminalv * 100;
						break;
					case 2: //Sprite Layer Threshold
						ret = zinit.jump_hero_layer_threshold * 10000;
						break;
					case 3: //Air Drag
						ret = zinit.air_drag.getZLong();
						break;
				}
			}
			break;
		}
		
		case GAMESCROLLING:
		{
			int32_t indx = ri->d[rINDEX]/10000;
			if ( ((unsigned)indx) >= SZ_SCROLLDATA )
			//if(indx < 0 || indx >= SZ_SCROLLDATA)
			{
				Z_scripterrlog("Invalid index used to access Game->Scrolling[]: %d\n", indx);
			}
			else
			{
				ret = FFCore.ScrollingData[indx] * 10000L;
			}
			break;
		}
		
		
		case SCREENSTATED:
		{
			int32_t mi = get_mi(MAPSCR_TEMP0);
			if(mi<0) {ret = 0;break;}
			ret=((game->maps[mi]>>((ri->d[rINDEX]/10000)))&1)?10000:0;
		}
		break;
		case SCREENEXSTATED:
		{
			int32_t mi = get_mi(MAPSCR_TEMP0);
			if(mi<0) {ret = 0;break;}
			ret=((game->xstates[mi]>>((ri->d[rINDEX]/10000)))&1)?10000:0;
		}
		break;
		case SCREENLENSSHOWS:
		{
			int ind = ri->d[rINDEX]/10000;
			if(ind < 0 || ind > 6)
				Z_scripterrlog("Bad index Screen->LensShows[%d]\n",ind);
			else ret = (tmpscr->lens_show & (1<<ind)) ? 10000 : 0;
			break;
		}
		case SCREENLENSHIDES:
		{
			int ind = ri->d[rINDEX]/10000;
			if(ind < 0 || ind > 6)
				Z_scripterrlog("Bad index Screen->LensHides[%d]\n",ind);
			else ret = (tmpscr->lens_hide & (1<<ind)) ? 10000 : 0;
			break;
		}
		case SCREENSCRDATASIZE:
		{
			auto mi = get_total_mi();
			if(mi < 0) break;
			ret = 10000*game->scriptDataSize(mi);
			break;
		}
		case SCREENSCRDATA:
		{
			auto mi = get_total_mi();
			if(mi < 0) break;
			size_t indx = ri->d[rINDEX]/10000;
			if(indx >= game->scriptDataSize(mi))
			{
				Z_scripterrlog("Invalid index passed to Screen->Data[]: %d\n", indx);
				break;
			}
			ret = game->screen_data[mi][indx];
			break;
		}
		
		case DISTANCE: 
		{
			double x1 = double(ri->d[rSFTEMP] / 10000.0);
			double y1 = double(ri->d[rINDEX] / 10000.0);
			double x2 = double(ri->d[rINDEX2] / 10000.0);
			double y2 = double(ri->d[rEXP1] / 10000.0);
			
			
			
			int32_t result = FFCore.Distance(x1, y1, x2, y2);
			ret = (result);
		
			break;
		}
		case LONGDISTANCE: 
		{
			double x1 = double(ri->d[rSFTEMP]);
			double y1 = double(ri->d[rINDEX]);
			double x2 = double(ri->d[rINDEX2]);
			double y2 = double(ri->d[rEXP1]);
			
			
			
			int32_t result = FFCore.LongDistance(x1, y1, x2, y2);
			ret = (result);
		
			break;
		}
		
		case DISTANCESCALE: 
		{
			double x1 = (double)(ri->d[rSFTEMP] / 10000.0);
			double y1 = (double)(ri->d[rINDEX] / 10000.0);
			double x2 = (double)(ri->d[rINDEX2] / 10000.0);
			double y2 = (double)(ri->d[rEXP1] / 10000.0);
			
			int32_t scale = (ri->d[rWHAT_NO_7]/10000);
			
			if ( !scale ) scale = 10000;
			int32_t result = FFCore.Distance(x1, y1, x2, y2, scale);
			ret = (result);
			
			break;
		}
		case LONGDISTANCESCALE: 
		{
			double x1 = (double)(ri->d[rSFTEMP]);
			double y1 = (double)(ri->d[rINDEX]);
			double x2 = (double)(ri->d[rINDEX2]);
			double y2 = (double)(ri->d[rEXP1]);
			
			int32_t scale = (ri->d[rWHAT_NO_7]);
			
			if ( !scale ) scale = 1;
			int32_t result = FFCore.LongDistance(x1, y1, x2, y2, scale);
			ret = (result);
			
			break;
		}
		
		case SCREENSTATEDD:
		{
			// Gah! >:(  Screen state is stored in game->maps, which uses 128 screens per map,
			// but the compiler multiplies the map number by 136, so it has to be corrected here.
			// Yeah, the compiler could be fixed, but that wouldn't cover existing quests...
			int32_t mi = ri->d[rINDEX] / 10000;
			mi -= 8*((ri->d[rINDEX] / 10000) / MAPSCRS);
			
			if(BC::checkMapID(mi>>7, "Game->GetScreenState") == SH::_NoError)
				ret=(game->maps[mi] >> (ri->d[rINDEX2] / 10000) & 1) ? 10000 : 0;
			else
				ret=0;
				
			break;
		}
		
		case GAMEGUYCOUNTD:
			ret=game->guys[(currmap * MAPSCRSNORMAL) + (ri->d[rINDEX] / 10000)]*10000;
			break;
			
		case CURMAP:
			ret=(1+currmap)*10000;
			break;
			
		case CURSCR:
			ret=currscr*10000;
			break;
			
		case ALLOCATEBITMAPR:
			ret=FFCore.get_free_bitmap();
			break;
			
		case GETMIDI:
			ret=(currmidi-(ZC_MIDI_COUNT-1))*10000;
			break;
			
		case CURDSCR:
		{
			int32_t di = (get_currscr()-DMaps[get_currdmap()].xoff);
			ret=(DMaps[get_currdmap()].type==dmOVERW ? currscr : di)*10000;
		}
		break;
		
		case GAMEMAXMAPS:
			ret = (map_count)*10000;
			break;
		case GAMENUMMESSAGES:
			ret = (msg_count-1) * 10000; 
			break;
		
		case CURDMAP:
			ret=currdmap*10000;
			break;
			
		case CURLEVEL:
			ret=DMaps[get_currdmap()].level*10000;
			break;
			
		case GAMECLICKFREEZE:
			ret=disableClickToFreeze?0:10000;
			break;
			
		
		case NOACTIVESUBSC:
			ret=Hero.stopSubscreenFalling()?10000:0;
			break;///----------------------------------------------------------------------------------------------------//
	//BottleTypes
		case BOTTLECOUNTER:
		{
			if(bottletype* ptr = checkBottleData(ri->bottletyperef, "Counter[]"))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(unsigned(indx) > 2)
				{
					Z_scripterrlog("Invalid index %d supplied to bottledata->Counter[].\n", indx);
					ret = -10000L;
					break;
				}
				ret = 10000L * ptr->counter[indx];
			}
			else ret = -10000L;
		}
		break;
		
		case BOTTLEAMOUNT:
		{
			if(bottletype* ptr = checkBottleData(ri->bottletyperef, "Amount[]"))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(unsigned(indx) > 2)
				{
					Z_scripterrlog("Invalid index %d supplied to bottledata->Amount[].\n", indx);
					ret = -10000L;
					break;
				}
				ret = 10000L * ptr->amount[indx];
			}
			else ret = -10000L;
		}
		break;
		
		case BOTTLEPERCENT:
		{
			if(bottletype* ptr = checkBottleData(ri->bottletyperef, "IsPercent[]"))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(unsigned(indx) > 2)
				{
					Z_scripterrlog("Invalid index %d supplied to bottledata->IsPercent[].\n", indx);
					ret = -10000L;
					break;
				}
				ret = (ptr->flags & (1<<indx)) ? 10000L : 0;
			}
			else ret = -10000L;
		}
		break;
		
		case BOTTLEFLAGS:
		{
			if(bottletype* ptr = checkBottleData(ri->bottletyperef, "Flags[]"))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(unsigned(indx) > 3)
				{
					Z_scripterrlog("Invalid index %d supplied to bottledata->Flags[].\n", indx);
					ret = -10000L;
					break;
				}
				int32_t flag = 0;
				switch(indx)
				{
					case 0: flag = BTFLAG_AUTOONDEATH; break;
					case 1: flag = BTFLAG_ALLOWIFFULL; break;
					case 2: flag = BTFLAG_CURESWJINX; break;
					case 3: flag = BTFLAG_CUREITJINX; break;
				}
				ret = (ptr->flags & flag) ? 10000L : 0;
			}
			else ret = -10000L;
		}
		break;
		
		case BOTTLENEXT:
		{
			if(bottletype* ptr = checkBottleData(ri->bottletyperef, "NextType"))
			{
				ret = 10000L * ptr->next_type;
			}
			else ret = -10000L;
		}
		break;
	///----------------------------------------------------------------------------------------------------//
	//BottleShops
		case BSHOPFILL:
		{
			if(bottleshoptype* ptr = checkBottleShopData(ri->bottleshopref, "Fill[]"))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(unsigned(indx) > 2)
				{
					Z_scripterrlog("Invalid index %d supplied to bottleshopdata->Fill[].\n", indx);
					ret = -10000L;
					break;
				}
				ret = 10000L * ptr->fill[indx];
			}
			else ret = -10000L;
		}
		break;
		
		case BSHOPCOMBO:
		{
			if(bottleshoptype* ptr = checkBottleShopData(ri->bottleshopref, "Combo[]"))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(unsigned(indx) > 2)
				{
					Z_scripterrlog("Invalid index %d supplied to bottleshopdata->Combo[].\n", indx);
					ret = -10000L;
					break;
				}
				ret = 10000L * ptr->comb[indx];
			}
			else ret = -10000L;
		}
		break;
		
		case BSHOPCSET:
		{
			if(bottleshoptype* ptr = checkBottleShopData(ri->bottleshopref, "CSet[]"))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(unsigned(indx) > 2)
				{
					Z_scripterrlog("Invalid index %d supplied to bottleshopdata->CSet[].\n", indx);
					ret = -10000L;
					break;
				}
				ret = 10000L * ptr->cset[indx];
			}
			else ret = -10000L;
		}
		break;
		
		case BSHOPPRICE:
		{
			if(bottleshoptype* ptr = checkBottleShopData(ri->bottleshopref, "Price[]"))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(unsigned(indx) > 2)
				{
					Z_scripterrlog("Invalid index %d supplied to bottleshopdata->Price[].\n", indx);
					ret = -10000L;
					break;
				}
				ret = 10000L * ptr->price[indx];
			}
			else ret = -10000L;
		}
		break;
		
		case BSHOPSTR:
		{
			if(bottleshoptype* ptr = checkBottleShopData(ri->bottleshopref, "InfoString[]"))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(unsigned(indx) > 2)
				{
					Z_scripterrlog("Invalid index %d supplied to bottleshopdata->InfoString[].\n", indx);
					ret = -10000L;
					break;
				}
				ret = 10000L * ptr->str[indx];
			}
			else ret = -10000L;
		}
		break;
		
		///----------------------------------------------------------------------------------------------------//
		//DMap Information

		#define GET_DMAP_VAR(member, str) \
		{ \
			int32_t ID = ri->d[rINDEX] / 10000; \
			if(BC::checkDMapID(ID, str) != SH::_NoError) \
				ret = -10000; \
			else \
				ret = DMaps[ID].member * 10000; \
		}

		case DMAPFLAGSD:
			GET_DMAP_VAR(flags,   "Game->DMapFlags")    break;
			
		case DMAPLEVELD:
			GET_DMAP_VAR(level,   "Game->DMapLevel")    break;
			
		case DMAPCOMPASSD:
			GET_DMAP_VAR(compass, "Game->DMapCompass")  break;
			
		case DMAPCONTINUED:
			GET_DMAP_VAR(cont,    "Game->DMapContinue") break;
		
		case DMAPLEVELPAL:
			GET_DMAP_VAR(color,   "Game->DMapPalette")    break; 
			
		case DMAPOFFSET:
			GET_DMAP_VAR(xoff,    "Game->DMapOffset")   break;
			
		case DMAPMAP:
		{
			int32_t ID = ri->d[rINDEX] / 10000;
			
			if(BC::checkDMapID(ID, "Game->DMapMap") != SH::_NoError)
				ret = -10000;
			else
				ret = (DMaps[ID].map+1) * 10000;
				
			break;
		}
		
		case DMAPMIDID:
		{
			int32_t ID = ri->d[rINDEX] / 10000;
			
			if(BC::checkDMapID(ID, "Game->DMapMIDI") == SH::_NoError)
			{
				// Based on play_DmapMusic
				switch(DMaps[ID].midi)
				{
				case 2:
					ret = -60000;
					break; // Dungeon
					
				case 3:
					ret = -30000;
					break; // Level 9
					
				case 1:
					ret = -20000;
					break; // Overworld
					
				case 0:
					ret = 0;
					break; // None
					
				default:
					ret = (DMaps[ID].midi - 3) * 10000;
				}
			}
			else
				ret = -10000; // Which is valid, but whatever.
				
			break;
		}
		
		///----------------------------------------------------------------------------------------------------//
		//Screen->ComboX
		#define GET_COMBO_VAR(member, str) \
		{ \
		int32_t pos = ri->d[rINDEX] / 10000; \
		if(BC::checkComboPos(pos, str) != SH::_NoError) \
		{ \
		    ret = -10000; \
		} \
		else \
		    ret = tmpscr->member[pos]*10000; \
		}

		case COMBODD:
			GET_COMBO_VAR(data,  "Screen->ComboD[]") break;
			
		case COMBOCD:
			GET_COMBO_VAR(cset,  "Screen->ComboC[]") break;
			
		case COMBOFD:
			GET_COMBO_VAR(sflag, "Screen->ComboF[]") break;
			
		#define GET_COMBO_VAR_BUF(member, str) \
		{ \
		    int32_t pos = ri->d[rINDEX] / 10000; \
		    if(BC::checkComboPos(pos, str) != SH::_NoError) \
		    { \
			ret = -10000; \
		    } \
		    else \
			ret = combobuf[tmpscr->data[pos]].member * 10000; \
		}
			
		case COMBOTD:
			GET_COMBO_VAR_BUF(type, "Screen->ComboT[]") break;
			
		case COMBOID:
			GET_COMBO_VAR_BUF(flag, "Screen->ComboI[]") break;
			
		case COMBOSD:
		{
			int32_t pos = ri->d[rINDEX] / 10000;
			
			if(BC::checkComboPos(pos, "Screen->ComboS[]") != SH::_NoError)
				ret = -10000;
			else
				ret = (combobuf[tmpscr->data[pos]].walk & 0xF) * 10000;
		}
		break;
			
		case COMBOED:
		{
			int32_t pos = ri->d[rINDEX] / 10000;
			
			if(BC::checkComboPos(pos, "Screen->ComboE[]") != SH::_NoError)
				ret = -10000;
			else
				ret = ((combobuf[tmpscr->data[pos]].walk & 0xF0)>>4) * 10000;
		}
		break;

		///----------------------------------------------------------------------------------------------------//
		//Region

		case REGION_WIDTH:
		{
			ret = 256 * 10000;
		}
		break;

		case REGION_HEIGHT:
		{
			ret = 176 * 10000;
		}
		break;

		case REGION_SCREEN_WIDTH:
		{
			ret = 1 * 10000;
		}
		break;

		case REGION_SCREEN_HEIGHT:
		{
			ret = 1 * 10000;
		}
		break;

		case REGION_NUM_COMBOS:
		{
			ret = 176 * 10000;
		}
		break;

		case REGION_ID:
		{
			ret = 0 * 10000;
		}
		break;

		case REGION_ORIGIN_SCREEN:
		{
			ret = currscr * 10000;
		}
		break;
		
		///----------------------------------------------------------------------------------------------------//
		//Game->GetComboX
		
		case COMBODDM:
		{
			int32_t pos = (ri->d[rINDEX])/10000;
			int32_t sc = (ri->d[rEXP1]/10000);
			int32_t m = (ri->d[rINDEX2]/10000)-1;
			int32_t scr = zc_max(m*MAPSCRS+sc,0);
			int32_t layr = whichlayer(scr);
			
			if(pos < 0 || pos >= 176) 
			{
				Z_scripterrlog("Invalid combo position (%d) passed to GetComboData", pos);
				ret = -10000;
			}
			else if(scr < 0) 
			{
				Z_scripterrlog("Invalid Screen ID (%d) passed to GetComboData", scr);
				ret = -10000;
			}
			else if(sc >= MAPSCRS) 
			{
				Z_scripterrlog("Invalid Screen ID (%d) passed to GetComboData", sc);
				ret = -10000;
			}
			else if(m >= map_count) 
			{
				Z_scripterrlog("Invalid Map ID (%d) passed to GetComboData", m);
				ret = -10000;
			}
			else if(m < 0) ret = 0; //No layer present
					
			//if(pos >= 0 && pos < 176 && scr >= 0 && sc < MAPSCRS && m < map_count)
			else
			{
				if(scr==(currmap*MAPSCRS+currscr))
					ret=tmpscr->data[pos]*10000;
				else if(layr>-1)
					ret=tmpscr2[layr].data[pos]*10000;
				else ret=TheMaps[scr].data[pos]*10000;
			}
			
		}
		break;
		
		case COMBOCDM:
		{
			int32_t pos = (ri->d[rINDEX])/10000;
			int32_t sc = (ri->d[rEXP1]/10000);
			int32_t m = (ri->d[rINDEX2]/10000)-1;
			int32_t scr = zc_max(m*MAPSCRS+sc,0);
			int32_t layr = whichlayer(scr);
			
			if(pos < 0 || pos >= 176) 
			{
				Z_scripterrlog("Invalid combo position (%d) passed to GetComboCSet", pos);
				ret = -10000;
			}
			else if(scr < 0) 
			{
				Z_scripterrlog("Invalid Screen ID (%d) passed to GetComboCSet", scr);
				ret = -10000;
			}
			else if(sc >= MAPSCRS) 
			{
				Z_scripterrlog("Invalid Screen ID (%d) passed to GetComboCSet", sc);
				ret = -10000;
			}
			else if(m >= map_count) 
			{
				Z_scripterrlog("Invalid Map ID (%d) passed to GetComboCSet", m);
				ret = -10000;
			}
			else if(m < 0) ret = 0; //No layer present
			
			//if(pos >= 0 && pos < 176 && scr >= 0 && sc < MAPSCRS && m < map_count)
			else
			{
				if(scr==(currmap*MAPSCRS+currscr))
					ret=tmpscr->cset[pos]*10000;
				else if(layr>-1)
					ret=tmpscr2[layr].cset[pos]*10000;
				else ret=TheMaps[scr].cset[pos]*10000;
			}
			
		}
		break;
		
		case COMBOFDM:
		{
			int32_t pos = (ri->d[rINDEX])/10000;
			int32_t sc = (ri->d[rEXP1]/10000);
			int32_t m = (ri->d[rINDEX2]/10000)-1;
			int32_t scr = zc_max(m*MAPSCRS+sc,0);
			int32_t layr = whichlayer(scr);
			
			if(pos < 0 || pos >= 176) 
			{
				Z_scripterrlog("Invalid combo position (%d) passed to GetComboFlag", pos);
				ret = -10000;
			}
			else if(scr < 0) 
			{
				Z_scripterrlog("Invalid Screen ID (%d) passed to GetComboFlag", scr);
				ret = -10000;
			}
			else if(sc >= MAPSCRS) 
			{
				Z_scripterrlog("Invalid Screen ID (%d) passed to GetComboFlag", sc);
				ret = -10000;
			}
			else if(m >= map_count) 
			{
				Z_scripterrlog("Invalid Map ID (%d) passed to GetComboFlag", m);
				ret = -10000;
			}
			else if(m < 0) ret = 0; //No layer present
			//if(pos >= 0 && pos < 176 && scr >= 0 && sc < MAPSCRS && m < map_count)
			else
			{
				if(scr==(currmap*MAPSCRS+currscr))
					ret=tmpscr->sflag[pos]*10000;
				else if(layr>-1)
					ret=tmpscr2[layr].sflag[pos]*10000;
				else ret=TheMaps[scr].sflag[pos]*10000;
			}
			
		}
		break;
		
		case COMBOTDM:
		{
			int32_t pos = (ri->d[rINDEX])/10000;
			int32_t sc = (ri->d[rEXP1]/10000);
			int32_t m = (ri->d[rINDEX2]/10000)-1;
			int32_t scr = zc_max(m*MAPSCRS+sc,0);
			int32_t layr = whichlayer(scr);
			
			if(pos < 0 || pos >= 176) 
			{
				Z_scripterrlog("Invalid combo position (%d) passed to GetComboType", pos);
				ret = -10000;
			}
			else if(scr < 0) 
			{
				Z_scripterrlog("Invalid Screen ID (%d) passed to GetComboType", scr);
				ret = -10000;
			}
			else if(sc >= MAPSCRS) 
			{
				Z_scripterrlog("Invalid Screen ID (%d) passed to GetComboType", sc);
				ret = -10000;
			}
			else if(m >= map_count) 
			{
				Z_scripterrlog("Invalid Map ID (%d) passed to GetComboType", m);
				ret = -10000;
			}
			else if(m < 0) ret = 0; //No layer present
			
			//if(pos >= 0 && pos < 176 && scr >= 0 && sc < MAPSCRS && m < map_count)
			else
			{
				if(scr==(currmap*MAPSCRS+currscr))
					ret=combobuf[tmpscr->data[pos]].type*10000;
				else if(layr>-1)
					ret=combobuf[tmpscr2[layr].data[pos]].type*10000;
				else ret=combobuf[
								 TheMaps[scr].data[pos]].type*10000;
			}
		}
		break;
		
		case COMBOIDM:
		{
			int32_t pos = (ri->d[rINDEX])/10000;
			int32_t sc = (ri->d[rEXP1]/10000);
			int32_t m = (ri->d[rINDEX2]/10000)-1;
			int32_t scr = zc_max(m*MAPSCRS+sc,0);
			int32_t layr = whichlayer(scr);
			
			if(pos < 0 || pos >= 176) 
			{
				Z_scripterrlog("Invalid combo position (%d) passed to GetComboInherentFlag", pos);
				ret = -10000;
			}
			else if(scr < 0) 
			{
				Z_scripterrlog("Invalid Screen ID (%d) passed to GetComboInherentFlag", scr);
				ret = -10000;
			}
			else if(sc >= MAPSCRS) 
			{
				Z_scripterrlog("Invalid Screen ID (%d) passed to GetComboInherentFlag", sc);
				ret = -10000;
			}
			else if(m >= map_count) 
			{
				Z_scripterrlog("Invalid Map ID (%d) passed to GetComboInherentFlag", m);
				ret = -10000;
			}
			else if(m < 0) ret = 0; //No layer present
			
			//if(pos >= 0 && pos < 176 && scr >= 0 && sc < MAPSCRS && m < map_count)
			else
					{
				if(scr==(currmap*MAPSCRS+currscr))
					ret=combobuf[tmpscr->data[pos]].flag*10000;
				else if(layr>-1)
					ret=combobuf[tmpscr2[layr].data[pos]].flag*10000;
				else ret=combobuf[TheMaps[scr].data[pos]].flag*10000;
			}
		}
		break;
		
		case COMBOSDM:
		{
			int32_t pos = (ri->d[rINDEX])/10000;
			int32_t sc = (ri->d[rEXP1]/10000);
			int32_t m = (ri->d[rINDEX2]/10000)-1;
			int32_t scr = zc_max(m*MAPSCRS+sc,0);
			int32_t layr = whichlayer(scr);
			
			if(pos < 0 || pos >= 176) 
			{
				Z_scripterrlog("Invalid combo position (%d) passed to GetComboSolid", pos);
				ret = -10000;
			}
			else if(scr < 0) 
			{
				Z_scripterrlog("Invalid Screen ID (%d) passed to GetComboSolid", scr);
				ret = -10000;
			}
			else if(sc >= MAPSCRS) 
			{
				Z_scripterrlog("Invalid Screen ID (%d) passed to GetComboSolid", sc);
				ret = -10000;
			}
			else if(m >= map_count) 
			{
				Z_scripterrlog("Invalid Map ID (%d) passed to GetComboSolid", m);
				ret = -10000;
			}
			else if(m < 0) ret = 0; //No layer present
			
			//if(pos >= 0 && pos < 176 && scr >= 0 && sc < MAPSCRS && m < map_count)
			else
			{
				if(scr==(currmap*MAPSCRS+currscr))
					ret=(combobuf[tmpscr->data[pos]].walk&15)*10000;
				else if(layr>-1)
					ret=(combobuf[tmpscr2[layr].data[pos]].walk&15)*10000;
				else ret=(combobuf[TheMaps[scr].data[pos]].walk&15)*10000;
			}
		
		}
		break;
		

		
		
		///----------------------------------------------------------------------------------------------------//
		//Screen Information
		
			#define	GET_SCREENDATA_VAR_INT32(member, str) \
		{ \
			ret = (tmpscr->member *10000); \
		} \

		#define	GET_SCREENDATA_VAR_INT16(member, str) \
		{ \
			ret = (tmpscr->member *10000); \
		} \

		#define	GET_SCREENDATA_VAR_BYTE(member, str) \
		{ \
			ret = (tmpscr->member *10000); \
		} \
		
		#define GET_SCREENDATA_VAR_INDEX32(member, str, indexbound) \
		{ \
			int32_t indx = ri->d[rINDEX] / 10000; \
			ret = (tmpscr->member[indx] *10000); \
		} \
		
		#define GET_SCREENDATA_VAR_INDEX16(member, str, indexbound) \
		{ \
			int32_t indx = ri->d[rINDEX] / 10000; \
			ret = (tmpscr->member[indx] *10000); \
		} \
		
		#define GET_SCREENDATA_BYTE_INDEX(member, str, indexbound) \
		{ \
			int32_t indx = ri->d[rINDEX] / 10000; \
			ret = (tmpscr->member[indx] *10000); \
		} \
		
		//byte
		#define GET_SCREENDATA_LAYER_INDEX(member, str, indexbound) \
		{ \
			int32_t indx = ri->d[rINDEX] / 10000; \
			if ( FFCore.quest_format[vFFScript] < 11 ) ++indx; \
			if(indx < 1 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to Screen->%s[]: %d\n", str, indx); \
				ret = -10000; \
			} \
			else \
			{ \
				ret = (tmpscr->member[indx-1] *10000); \
			} \
		} \
		
		
		#define GET_SCREENDATA_BOOL_INDEX(member, str, indexbound) \
		{ \
			int32_t indx = ri->d[rINDEX] / 10000; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to Screen->%s[]: %d\n", (indx), str); \
				ret = -10000; \
			} \
			else \
			{ \
				ret = (tmpscr->member[indx]?10000:0); \
			} \
		} \

		#define GET_FFC_BOOL_INDEX(member, str, indexbound) \
		{ \
			int32_t indx = ri->d[rINDEX] / 10000; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to Screen->%s[]: %d\n", (indx), str); \
				ret = -10000; \
			} \
			else \
			{ \
				ret = (tmpscr->ffcs[indx].member?10000:0); \
			} \
		} \
		
		
		#define GET_SCREENDATA_FLAG(member, str, indexbound) \
		{ \
			int32_t flag =  (value/10000);  \
			ret = (tmpscr->member&flag) ? 10000 : 0); \
		} \
		
		case SCREENDATAVALID:		GET_SCREENDATA_VAR_BYTE(valid, "Valid"); break;		//b
		case SCREENDATAGUY: 		GET_SCREENDATA_VAR_BYTE(guy, "Guy"); break;		//b
		case SCREENDATASTRING:		GET_SCREENDATA_VAR_INT32(str, "String"); break;		//w
		case SCREENDATAROOM: 		GET_SCREENDATA_VAR_BYTE(room, "RoomType");	break;		//b
		case SCREENDATAITEM:
		{
			if(tmpscr->hasitem)
				ret = (tmpscr->item *10000);
			else ret = -10000;
			break;
		}
		case SCREENDATAHASITEM: 		GET_SCREENDATA_VAR_BYTE(hasitem, "HasItem"); break;	//b
		case SCREENDATATILEWARPTYPE: 	GET_SCREENDATA_BYTE_INDEX(tilewarptype, "TileWarpType", 3); break;	//b, 4 of these
		//case SCREENDATATILEWARPOVFLAGS: 	GET_SCREENDATA_VAR_BYTE(tilewarpoverlayflags, "TileWarpOverlayFlags"); break;	//b, tilewarpoverlayflags
		case SCREENDATADOORCOMBOSET: 	GET_SCREENDATA_VAR_INT32(door_combo_set, "DoorComboSet"); break;	//w
		case SCREENDATAWARPRETX:	 	GET_SCREENDATA_BYTE_INDEX(warpreturnx, "WarpReturnX", 3); break;	//b, 4 of these
		case SCREENDATAWARPRETY:	 	GET_SCREENDATA_BYTE_INDEX(warpreturny, "WarpReturnY", 3); break;	//b, 4 of these
		case SCREENDATAWARPRETURNC: 	GET_SCREENDATA_VAR_INT32(warpreturnc, "WarpReturnC"); break;	//w
		case SCREENDATASTAIRX: 		GET_SCREENDATA_VAR_BYTE(stairx, "StairsX"); break;	//b
		case SCREENDATASTAIRY: 		GET_SCREENDATA_VAR_BYTE(stairy, "StairsY"); break;	//b
		case SCREENDATAITEMX:		GET_SCREENDATA_VAR_BYTE(itemx, "ItemX"); break; //itemx
		case SCREENDATAITEMY:		GET_SCREENDATA_VAR_BYTE(itemy, "ItemY"); break;	//itemy
		case SCREENDATACOLOUR: 		GET_SCREENDATA_VAR_INT32(color, "CSet"); break;	//w
		case SCREENDATAENEMYFLAGS: 	GET_SCREENDATA_VAR_BYTE(enemyflags, "EnemyFlags");	break;	//b
		case SCREENDATADOOR: 		GET_SCREENDATA_BYTE_INDEX(door, "Door", 3); break;	//b, 4 of these
		case SCREENDATATILEWARPDMAP: 	GET_SCREENDATA_VAR_INDEX32(tilewarpdmap, "TileWarpDMap", 3); break;	//w, 4 of these
		case SCREENDATATILEWARPSCREEN: 	GET_SCREENDATA_BYTE_INDEX(tilewarpscr, "TileWarpScreen", 3); break;	//b, 4 of these
		case SCREENDATAEXITDIR: 		GET_SCREENDATA_VAR_BYTE(exitdir, "ExitDir"); break;	//b
		case SCREENDATAENEMY: 		GET_SCREENDATA_VAR_INDEX32(enemy, "Enemy", 9); break;	//w, 10 of these
		case SCREENDATAPATTERN: 		GET_SCREENDATA_VAR_BYTE(pattern, "Pattern"); break;	//b
		case SCREENDATASIDEWARPTYPE: 	GET_SCREENDATA_BYTE_INDEX(sidewarptype, "SideWarpType", 3); break;	//b, 4 of these
		//case SCREENDATASIDEWARPOVFLAGS: 	GET_SCREENDATA_VAR_BYTE(sidewarpoverlayflags, "SideWarpOverlayFlags"); break;	//b
		case SCREENDATAWARPARRIVALX: 	GET_SCREENDATA_VAR_BYTE(warparrivalx, "WarpArrivalX"); break;	//b
		case SCREENDATAWARPARRIVALY: 	GET_SCREENDATA_VAR_BYTE(warparrivaly, "WarpArrivalY"); break;	//b
		case SCREENDATAPATH: 		GET_SCREENDATA_BYTE_INDEX(path, "MazePath", 3); break;	//b, 4 of these
		case SCREENDATASIDEWARPSC: 	GET_SCREENDATA_BYTE_INDEX(sidewarpscr, "SideWarpScreen", 3); break;	//b, 4 of these
		case SCREENDATASIDEWARPDMAP: 	GET_SCREENDATA_VAR_INDEX32(sidewarpdmap, "SideWarpDMap", 3); break;	//w, 4 of these
		case SCREENDATASIDEWARPINDEX: 	GET_SCREENDATA_VAR_BYTE(sidewarpindex, "SideWarpIndex"); break;	//b
		case SCREENDATAUNDERCOMBO: 	GET_SCREENDATA_VAR_INT32(undercombo, "Undercombo"); break;	//w
		case SCREENDATAUNDERCSET:	 	GET_SCREENDATA_VAR_BYTE(undercset,	"UnderCSet"); break; //b
		case SCREENDATACATCHALL:	 	GET_SCREENDATA_VAR_INT32(catchall,	"Catchall"); break; //W

		case SCREENDATACSENSITIVE: 	GET_SCREENDATA_VAR_BYTE(csensitive, "CSensitive"); break;	//B
		case SCREENDATANORESET: 		GET_SCREENDATA_VAR_INT32(noreset, "NoReset"); break;	//W
		case SCREENDATANOCARRY: 		GET_SCREENDATA_VAR_INT32(nocarry, "NoCarry"); break;	//W
		case SCREENDATALAYERMAP:	 	GET_SCREENDATA_LAYER_INDEX(layermap, "LayerMap", 6); break;	//B, 6 OF THESE
		case SCREENDATALAYERSCREEN: 	GET_SCREENDATA_LAYER_INDEX(layerscreen, "LayerScreen", 6); break;	//B, 6 OF THESE
		case SCREENDATALAYEROPACITY: 	GET_SCREENDATA_LAYER_INDEX(layeropacity, "LayerOpacity", 6); break;	//B, 6 OF THESE
		case SCREENDATALAYERINVIS: 	
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if(indx < 0 || indx > 6 )
			{
				Z_scripterrlog("Invalid Index passed to Screen->LayerInvisible[]: %d\n", indx);
				ret = 0;
			}
			else
			{
				ret = ((tmpscr->hidelayers >> indx) & 1) *10000;
			}
			break;
		}
		case SCREENDATASCRIPTDRAWS: 	
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if(indx < 0 || indx > 7 )
			{
				Z_scripterrlog("Invalid Index passed to Screen->HideScriptLayer[]: %d\n", indx);
				ret = 0;
			}
			else
			{
				ret = ((tmpscr->hidescriptlayers >> indx) & 1) ? 0 : 10000;
			}
			break;
		}
		case SCREENDATATIMEDWARPTICS: 	GET_SCREENDATA_VAR_INT32(timedwarptics, "TimedWarpTimer"); break;	//W
		case SCREENDATANEXTMAP: 		GET_SCREENDATA_VAR_BYTE(nextmap, "NextMap"); break;	//B
		case SCREENDATANEXTSCREEN: 	GET_SCREENDATA_VAR_BYTE(nextscr, "NextScreen"); break;	//B
		case SCREENDATASECRETCOMBO: 	GET_SCREENDATA_VAR_INDEX32(secretcombo, "SecretCombo", 127); break;	//W, 128 OF THESE
		case SCREENDATASECRETCSET: 	GET_SCREENDATA_BYTE_INDEX(secretcset, "SecretCSet", 127); break;	//B, 128 OF THESE
		case SCREENDATASECRETFLAG: 	GET_SCREENDATA_BYTE_INDEX(secretflag, "SecretFlags", 127); break;	//B, 128 OF THESE
		case SCREENDATAVIEWX: 		break;//GET_SCREENDATA_VAR_INT32(viewX, "ViewX"); break;	//W
		case SCREENDATAVIEWY: 		break;//GET_SCREENDATA_VAR_INT32(viewY, "ViewY"); break; //W
		case SCREENDATASCREENWIDTH: 	break;//GET_SCREENDATA_VAR_BYTE(scrWidth, "Width"); break;	//B
		case SCREENDATASCREENHEIGHT: 	break;//GET_SCREENDATA_VAR_BYTE(scrHeight,	"Height"); break;	//B
		case SCREENDATAENTRYX: 		GET_SCREENDATA_VAR_BYTE(entry_x, "EntryX"); break;	//B
		case SCREENDATAENTRYY: 		GET_SCREENDATA_VAR_BYTE(entry_y, "EntryY"); break;	//B
		//Number of ffcs that are in use (have valid data
		case SCREENDATANUMFF: 	
		{
			uint32_t indx = ri->d[rINDEX] / 10000;
			if (!indx || indx > MAXFFCS)
			{
				Z_scripterrlog("Invalid Index passed to Screen->NumFFCs[%d].\n Valid indices are 1 through %d.\n", indx, MAXFFCS);
				ret = 0;
			}
			else
			{
				--indx;
				ret = (tmpscr->ffcs[indx].data != 0) ? 10000 : 0;
			}
			break;
		}
			//inita	//INT32, 32 OF THESE, EACH WITH 2
		case SCREENDATAFFINITIALISED: 	{
			int32_t indx = ri->d[rINDEX] / 10000;
			if (indx < 0 || indx > MAXFFCS-1)
			{
				Z_scripterrlog("Invalid Index passed to Screen->%s[]: %d\n", indx, "FFCRunning");
				ret = -10000;
			}
			else
			{
				ret = get_script_engine_data(ScriptType::FFC, indx).initialized ? 10000 : 0;
			}
		}
		break;

		case SCREENDATASCRIPTENTRY: 	GET_SCREENDATA_VAR_INT32(script_entry, "ScriptEntry"); break;	//W
		case SCREENDATASCRIPTOCCUPANCY: 	GET_SCREENDATA_VAR_INT32(script_occupancy,	"ScriptOccupancy");  break;//W
		case SCREENDATASCRIPTEXIT: 	GET_SCREENDATA_VAR_INT32(script_exit, "ExitScript"); break;	//W
		case SCREENDATAOCEANSFX:	 	GET_SCREENDATA_VAR_BYTE(oceansfx, "OceanSFX"); break;	//B
		case SCREENDATABOSSSFX: 		GET_SCREENDATA_VAR_BYTE(bosssfx, "BossSFX"); break;	//B
		case SCREENDATASECRETSFX:	 	GET_SCREENDATA_VAR_BYTE(secretsfx, "SecretSFX"); break;	//B
		case SCREENDATAHOLDUPSFX:	 	GET_SCREENDATA_VAR_BYTE(holdupsfx,	"ItemSFX"); break; //B
		case SCREENDATASCREENMIDI:
		{
			ret = ((tmpscr->screen_midi+(MIDIOFFSET_MAPSCR-MIDIOFFSET_ZSCRIPT)) *10000);
			break;
		}
		case SCREENDATALENSLAYER:	 	GET_SCREENDATA_VAR_BYTE(lens_layer, "LensLayer"); break;	//B, OLD QUESTS ONLY?

		case SCREENSIDEWARPID: 
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			
			ret = (((tmpscr->flags2 >> indx) & 1)
				? (tmpscr->sidewarpindex >> (2*indx)) & 3 //Return which warp is set
				: -1 //Returns -1 if no warp is set
				)*10000;
			break;
		}

		case SCREENDATATILEWARPOVFLAGS: 
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if ( ((unsigned)indx) > 3 ) 
			{
				Z_scripterrlog("Invalid index passed to TileWarpOverlayFlags[%d].\n. Valid indices are [0] through [3].\n", indx);
				ret = 0;
			}
			else
			{
				ret = (tmpscr->tilewarpoverlayflags & (1<<indx))?10000:0;
			}
			break;
		}

		case SCREENDATASIDEWARPOVFLAGS: 
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if ( ((unsigned)indx) > 3 ) 
			{
				Z_scripterrlog("Invalid index passed to SideWarpOverlayFlags[%d].\n. Valid indices are [0] through [3].\n", indx);
				ret = 0;
			}
			else
			{
				ret = (tmpscr->sidewarpoverlayflags & (1<<indx))?10000:0;
			}
			break;
		}

		case SCREENDATATWARPRETSQR:
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if ( ((unsigned)indx) > 3)
			{
				ret = -10000;
				Z_scripterrlog("Invalid Array Index passed to Screen->TileWarpReturnSquare[]: %d\n", indx);
				
			}
			else 
			{
				ret = ((tmpscr->warpreturnc>>(indx*2))&3) * 10000;
			}
			break;
		}


		case SCREENDATASWARPRETSQR:
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if ( ((unsigned)indx) > 3)
			{
				ret = -10000;
				Z_scripterrlog("Invalid Array Index passed to Screen->SideWarpReturnSquare[]: %d\n", indx);
				
			}
			else 
			{
				ret = ((tmpscr->warpreturnc>>(8+(indx*2)))&3) * 10000;
			}
			break;
		}

		case SCREENDATAFLAGS: 
		{
			int32_t flagid = (ri->d[rINDEX])/10000;
			//bool valtrue = ( value ? 10000 : 0);
			switch(flagid)
			{
				case 0: ret = (tmpscr->flags * 10000); break;
				case 1: ret = (tmpscr->flags2 * 10000); break;
				case 2: ret = (tmpscr->flags3 * 10000); break;
				case 3: ret = (tmpscr->flags4 * 10000); break;
				case 4: ret = (tmpscr->flags5 * 10000); break;
				case 5: ret = (tmpscr->flags6 * 10000); break;
				case 6: ret = (tmpscr->flags7 * 10000); break;
				case 7: ret = (tmpscr->flags8 * 10000); break;
				case 8: ret = (tmpscr->flags9 * 10000); break;
				case 9: ret = (tmpscr->flags10 * 10000); break;
				default:
				{
					Z_scripterrlog("Invalid index passed to mapdata->flags[]: %d\n", flagid); 
					ret = -10000;
					break;
					
				}
			}
			break;
			//GET_SCREENDATA_BYTE_INDEX	//B, 11 OF THESE, flags, flags2-flags10
		}

		case SCREENSECRETSTRIGGERED:
		{
			ret = triggered_screen_secrets ? 10000L : 0L;
			break;
		}
		
		case SCREENDATAGUYCOUNT:
		{
			int mi = get_mi();
			if(mi < 0)
				ret = -10000;
			else ret = game->guys[mi] * 10000;
			break;
		}
		case SCREENDATAEXDOOR:
		{
			ret = 0;
			int mi = get_mi();
			if(mi < 0) break;
			int dir = SH::read_stack(ri->sp+1) / 10000;
			int ind = SH::read_stack(ri->sp+0) / 10000;
			if(unsigned(dir) > 3)
				Z_scripterrlog("Invalid dir '%d' passed to 'Screen->GetExDoor()'; must be 0-3\n", dir);
			else if(unsigned(ind) > 7)
				Z_scripterrlog("Invalid index '%d' passed to 'Screen->GetExDoor()'; must be 0-7\n", ind);
			else
			{
				int bit = 1<<ind;
				ret = (game->xdoors[mi][dir]&bit) ? 10000 : 0;
			}
			break;
		}
		
		case SHOWNMSG:
		{
			ret = ((msg_active || msg_onscreen) ? msgstr : 0) * 10000L;
			break;
		}

		case SDD:
		{
			int32_t di = ((get_currdmap())<<7) + get_currscr()-(DMaps[get_currdmap()].type==dmOVERW ? 0 : DMaps[get_currdmap()].xoff);
			ret=FFScript::get_screen_d(di, ri->d[rINDEX]/10000);
		}
		break;
		
		case SDDD:
			ret=FFScript::get_screen_d((ri->d[rINDEX])/10000 + ((get_currdmap())<<7), ri->d[rINDEX2] / 10000);
			break;
		
		case LINKOTILE:
			ret=FFCore.getHeroOTile(ri->d[rINDEX]/10000, ri->d[rINDEX2] / 10000);
			break;
			
		case SDDDD:
			ret=FFScript::get_screen_d(ri->d[rINDEX2] / 10000 + ((ri->d[rINDEX]/10000)<<7), ri->d[rEXP1] / 10000);
			break;
			
		case SCRDOORD:
			ret=tmpscr->door[ri->d[rINDEX]/10000]*10000;
			break;
		
		case SCREENSCRIPT:
			ret=tmpscr->script*10000;
			break;
		
		case SCREENINITD:
			ret = tmpscr->screeninitd[ri->d[rINDEX]/10000];
			break;
		
		case MAPDATAINITDARRAY:
		{
			if ( ri->mapsref == MAX_SIGNED_32 ) 
			{ 
				Z_scripterrlog("Script attempted to use a mapdata->InitD[%d] on a pointer that is uninitialised\n",ri->d[rINDEX]/10000); 
				break; 
			} 
			else 
			{ 
				mapscr *m = GetMapscr(ri->mapsref); 
				ret = m->screeninitd[ri->d[rINDEX]/10000];
			} 
			break;
		}
		
		case MAPDATALAYERINVIS: 	
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if(indx < 0 || indx > 6 )
			{
				Z_scripterrlog("Invalid Index passed to mapdata->LayerInvisible[]: %d\n", indx);
				ret = 0;
			}
			else
			{
				if ( ri->mapsref == MAX_SIGNED_32 )
				{
						Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","LayerInvisible");
						ret = -10000;
				}
				else
				{
					mapscr *m = GetMapscr(ri->mapsref);
					ret = ((m->hidelayers >> indx) & 1) *10000;
				}
			}
			break;
		}
		case MAPDATASCRIPTDRAWS: 	
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if(indx < 0 || indx > 7 )
			{
				Z_scripterrlog("Invalid Index passed to mapdata->DisableScriptDraws[]: %d\n", indx);
				ret = 0;
			}
			else
			{
				if ( ri->mapsref == MAX_SIGNED_32 )
				{
						Z_scripterrlog("Script attempted to use a mapdata->DisableScriptDraws on a pointer that is uninitialised\n");
						ret = -10000;
				}
				else
				{
					mapscr *m = GetMapscr(ri->mapsref);
					ret = ((m->hidescriptlayers >> indx) & 1) ? 0 : 10000;
				}
			}
			break;
		}
		
		//These use the same method as GetScreenD -Z
		case SCREENWIDTH:
			// ret=FFScript::get_screenWidth(&TheMaps[(ri->d[rINDEX2] / 10000) * MAPSCRS + (ri->d[rINDEX]/10000)]);
			break;

		case SCREENHEIGHT:
			// ret=FFScript::get_screenHeight(&TheMaps[(ri->d[rINDEX2] / 10000) * MAPSCRS + (ri->d[rINDEX]/10000)]);
			break;

		case SCREENVIEWX:
			// ret=get_screenViewX(&TheMaps[(ri->d[rINDEX2] / 10000) * MAPSCRS + (ri->d[rINDEX]/10000)]);
			break;

		case SCREENVIEWY:
			// ret=get_screenViewY(&TheMaps[(ri->d[rINDEX2] / 10000) * MAPSCRS + (ri->d[rINDEX]/10000)]);
			break;

		case SCREENGUY:
			ret=get_screenGuy(&TheMaps[(ri->d[rINDEX2] / 10000) * MAPSCRS + (ri->d[rINDEX]/10000)]);
			break;

		case SCREENSTRING:
			ret=get_screenString(&TheMaps[(ri->d[rINDEX2] / 10000) * MAPSCRS + (ri->d[rINDEX]/10000)]);
			break;

		case SCREENROOM:
			ret=get_screenRoomtype(&TheMaps[(ri->d[rINDEX2] / 10000) * MAPSCRS + (ri->d[rINDEX]/10000)]);
			break;

		case SCREENENTX:
			ret=get_screenEntryX(&TheMaps[(ri->d[rINDEX2] / 10000) * MAPSCRS + (ri->d[rINDEX]/10000)]);
			break;

		case SCREENENTY:
			ret=get_screenEntryY(&TheMaps[(ri->d[rINDEX2] / 10000) * MAPSCRS + (ri->d[rINDEX]/10000)]);
			break;

		case SCREENITEM:
			ret=get_screenitem(&TheMaps[(ri->d[rINDEX2] / 10000) * MAPSCRS + (ri->d[rINDEX]/10000)]);
			break;

		case SCREENUNDCMB:
			ret=get_screenundercombo(&TheMaps[(ri->d[rINDEX2] / 10000) * MAPSCRS + (ri->d[rINDEX]/10000)]);
			break;

		case SCREENUNDCST:
			ret=get_screenundercset(&TheMaps[(ri->d[rINDEX2] / 10000) * MAPSCRS + (ri->d[rINDEX]/10000)]);
			break;

		case SCREENCATCH:
			ret=get_screenatchall(&TheMaps[(ri->d[rINDEX2] / 10000) * MAPSCRS + (ri->d[rINDEX]/10000)]);
			break;
	 
			
		case LIT:
			ret= get_lights() ? 10000 : 0;
			break;
			
		case WAVY:
			ret = wavy*10000;
			break;
			
		case QUAKE:
			ret = quakeclk*10000;
			break;
			
		case SCREENFLAGSD:
			ret = get_screenflags(tmpscr,vbound(ri->d[rINDEX] / 10000,0,9));
			break;
			
		case SCREENEFLAGSD:
			ret = get_screeneflags(tmpscr,vbound(ri->d[rINDEX] / 10000,0,2));
			break;
			
		case NPCCOUNT:
			ret = guys.Count()*10000;
			break;
			
		case ROOMDATA:
			ret = tmpscr->catchall*10000;
			break;
			
		case ROOMTYPE:
			ret = tmpscr->room*10000;
			break;
			
		case PUSHBLOCKX:
			ret = mblock2.active() ? int32_t(mblock2.x)*10000 : -10000;
			break;
			
		case PUSHBLOCKY:
			ret = mblock2.active() ? int32_t(mblock2.y)*10000 : -10000;
			break;
		
		case PUSHBLOCKLAYER:
			ret = mblock2.active() ? int32_t(mblock2.blockLayer)*10000 : -10000;
			break;
			
		case PUSHBLOCKCOMBO:
			ret = mblock2.bcombo*10000;
			break;
			
		case PUSHBLOCKCSET:
			ret = mblock2.cs*10000;
			break;
			
		case UNDERCOMBO:
			ret = tmpscr->undercombo*10000;
			break;
			
		case UNDERCSET:
			ret = tmpscr->undercset*10000;
			break;
		
		//Creates an lweapon using an iemdata struct values to generate its properties.
		//Useful in conjunction with the new weapon editor. 
		case CREATELWPNDX:
		{
			//Z_message("Trying to get Player->SetExtend().\n");
			int32_t ID = (ri->d[rINDEX] / 10000);
			int32_t itemid = (ri->d[rINDEX2]/10000);
			itemid = vbound(itemid,0,(MAXITEMS-1));
			
			//Z_scripterrlog("GetHeroExtend rid->[2] is (%i), trying to use for '%s'\n", ri->d[rEXP1], "ri->d[rEXP1]");
			//Z_scripterrlog("GetHeroExtend rid->[1] is (%i), trying to use for '%s'\n", state, "state");
			//Z_scripterrlog("GetHeroExtend rid->[0] is (%i), trying to use for '%s'\n", dir, "dir");
			if ( Lwpns.Count() < 256 )
			{
				
				Lwpns.add
				(
					new weapon
					(
						(zfix)0, /*X*/
						(zfix)0, /*Y*/
						(zfix)0, /*Z*/
						ID,	 /*id*/
						0,	 /*type*/
						0,	 /*power*/
						0,	 /*dir*/
						-1,	 /*Parentid*/
						Hero.getUID(), /*prntid*/
						false,	 /*isdummy*/
						1,	 /*script_gen*/
						1,  /*islwpn*/
						(ID==wWind?1:0)  /*special*/
					)
				);
				ri->lwpn = Lwpns.spr(Lwpns.Count() - 1)->getUID();
				
				weapon *w = (weapon*)Lwpns.spr(Lwpns.Count()-1); //last created
				//w->LOADGFX(FFCore.getDefWeaponSprite(ID)); //What the fuck Zoria, this broke old quests...
				w->ScriptGenerated = 1;
				w->isLWeapon = 1;
				if(ID == wWind) w->specialinfo = 1;
				//weapon *w = (weapon*)Lwpns.spr(Lwpns.Count()-1); //last created
				//w->LOADGFX(FFCore.getDefWeaponSprite(ID)); //not needed here because this has access to wpn->prent
			}
			else
			{
				Z_scripterrlog("Tried to create too many LWeapons on the screen. The current LWeapon count is: %d\n", Lwpns.Count());
				ri->lwpn = 0;
			}
			
			/* Z_scripterrlog("CreateLWeaponDx ri->d[rINDEX] is (%i), trying to use for '%s'\n", ID, "ID");
			Z_scripterrlog("CreateLWeaponDx ri->d[rINDEX2] is (%i), trying to use for '%s'\n", itemid, "itemid");
			Z_scripterrlog("CreateLWeaponDx ri->lwpn is (%i), trying to use for '%s'\n", ri->lwpn, "ri->lwpn"); */
			
			ret = ri->lwpn; 
		}
		break;
		
		/*
		//Screen->CollisionDx(int32_t enemy_index, int32_t lweapon_type, int32_t power, int32_t x, int32_t y, int32_t weapon_dir, int32_t parent_item);
		//Handles collision between an npc at screen index 'enemy_index', and an arbitrary lweapon that may or may not exist.
		//Does damage, and returns true a value collision is valid. Returns a different value otherwise. 
		
		// take damage or ignore it
		// -1: damage (if any) dealt
		// 1: blocked
		// 0: weapon passes through unhindered
		// 2: heal enemy? -ZoriaRPG
		
		//THis function should automatically check for shields blocking the weapon, and calculate enemy defences.
		//In theory, scritped swords, and other melee weapons could use this, as coudl any weapon, and it may simplify
		//collision routines. 
		case COLLISIONDX:
		{
			//Z_message("Trying to get Player->SetExtend().\n");
			int32_t index = (ri->d[rINDEX] / 10000);
			int32_t lweapon_type = (ri->d[rINDEX2] / 10000);
			int32_t power = (ri->d[rEXP1]/10000);
			
			int32_t wpnx = ri->4[3]/10000, wpny = ri->d[rSFRAME]/10000;
			int32_t dir = ri->d[rNUL]/10000;
			int32_t parentitem = (ri->d[rSFTEMP]/10000);
			lweapon_type = vbound(lweapon_type,0,40); //Are we at 40, or higher now>
			parentitem = vbound(itemid,0,255);
			
			//Log the stack events:
			Z_scripterrlog("CollisionDx ri->d[rINDEX] is (%i), trying to use for '%s'\n", index, "index");
			Z_scripterrlog("CollisionDx ri->d[rINDEX2] is (%i), trying to use for '%s'\n", lweapon_type, "lweapon_type");
			Z_scripterrlog("CollisionDx ri->d[rEXP1] is (%i), trying to use for '%s'\n", power, "power");
			Z_scripterrlog("CollisionDx ri->d[rEXP2] is (%i), trying to use for '%s'\n", wpnx, "wpnx");
			Z_scripterrlog("CollisionDx ri->d[rSFRAME] is (%i), trying to use for '%s'\n", wpny, "wpny");
			Z_scripterrlog("CollisionDx ri->d[rNUL] is (%i), trying to use for '%s'\n", dir, "dir");
			Z_scripterrlog("CollisionDx ri->d[rINDEX] is (%i), trying to use for '%s'\n", parentitem, "parentitem");
			
			weapon *w = new weapon((zfix)wpnx,(zfix)wpny,(zfix)0,lweapon_type,0,power,dir,parentitem,-1,false);
			int32_t retval = ((enemy*)guys.spr(index))->takehit(w); 
				//TakeHit, as I recall, applies damage and returns the hit status. Gold.
			delete w;
			ret = retval;
		}
		break;
		
		*/
		case DEBUGREFFFC:
		{
			int32_t r = -1;
			if ( ri->ffcref ) r = ri->ffcref;
				ret = r * 10000;
			break;
		}
			
		case DEBUGREFITEM:
		{
			int32_t r = -1;
			if ( ri->itemref ) r = ri->itemref;
				ret = r * 10000;
			break;
		}
			
		case DEBUGREFITEMDATA:
		{
			int32_t r = -1;
			if ( ri->idata ) r = ri->idata;
				ret = r * 10000;
			break;
		}
			
		case DEBUGREFLWEAPON:
		{
			int32_t r = -1;
			if ( ri->lwpn ) r = ri->lwpn;
				ret = r * 10000;
			break;
		}
			
		case DEBUGREFEWEAPON:
		{
			int32_t r = -1;
			if ( ri->ewpn ) r = ri->ewpn;
				ret = r * 10000;
			break;
		}
			
		case DEBUGREFNPC:
		{
			int32_t r = -1;
			if ( ri->guyref ) r = ri->guyref;
				ret = r * 10000;
			break;
		}    
			
		case DEBUGSP:
		{
			ret = SH::read_stack(ri->sp) * 10000;
			break;
		}   
		case DEBUGGDR:
		{
			int32_t a = vbound(ri->d[rINDEX]/10000,0,15);
			int32_t r = -1;
			if ( game->global_d[a] ) r = game->global_d[a];
				ret = r * 10000;
			break;
		}
		
		///----------------------------------------------------------------------------------------------------//
		//New Datatype Variables
			
		///----------------------------------------------------------------------------------------------------//
		//spritedata sp-> Variables
			
		case SPRITEDATATILE: GET_SPRITEDATA_VAR_INT(tile, "Tile") break;
		case SPRITEDATAMISC: GET_SPRITEDATA_VAR_INT(misc, "Misc") break;
		case SPRITEDATACSETS:
		{
			if(unsigned(ri->spritesref) > (MAXWPNS-1) )
			{
				ret = -10000;
				Z_scripterrlog("Invalid Sprite ID passed to spritedata->CSet: %d\n", (ri->spritesref*10000));
			}
			else
				ret = ((wpnsbuf[ri->spritesref].csets & 0xF) * 10000);
			break;
		}
		case SPRITEDATAFLCSET:
		{
			if(unsigned(ri->spritesref) > (MAXWPNS-1) )
			{
				ret = -10000;
				Z_scripterrlog("Invalid Sprite ID passed to spritedata->%s: %d\n", (ri->spritesref*10000), "FlashCSet");
				break;
			}
			ret = (((wpnsbuf[ri->spritesref].csets & 0xF0)>>4) * 10000);
			break;
		}
		case SPRITEDATAFRAMES: GET_SPRITEDATA_VAR_INT(frames, "Frames") break;
		case SPRITEDATASPEED: GET_SPRITEDATA_VAR_INT(speed, "Speed") break;
		case SPRITEDATATYPE: GET_SPRITEDATA_VAR_INT(type, "Type") break;
		case SPRITEDATAFLAGS:
		{
			if(unsigned(ri->spritesref) > (MAXWPNS-1) )
			{
				ret = 0;
				Z_scripterrlog("Invalid Sprite ID passed to spritedata->Flags[]: %d\n", (ri->spritesref*10000));
				break;
			}
			int32_t index = ri->d[rINDEX]/10000;
			if(unsigned(index) >= 5)
			{
				ret = 0;
				Z_scripterrlog("Invalid index passed to spritedata->Flags[]: %d\n", index);
				break;
			}
			ret = (wpnsbuf[ri->spritesref].misc & (1<<index)) ? 10000 : 0;
			break;
		}
		case SPRITEDATAID:
		{
			if(unsigned(ri->spritesref) > (MAXWPNS-1) )
			{
				ret = -10000;
				Z_scripterrlog("Invalid Sprite ID passed to spritedata->ID: %d\n", (ri->spritesref*10000));
				break;
			}
			ret = ri->spritesref*10000;
			break;
		}
		
		///----------------------------------------------------------------------------------------------------//
		//mapdata m-> variables
		#define	GET_MAPDATA_VAR_INT32(member, str) \
		{ \
			if ( mapscr *m = GetMapscr(ri->mapsref) ) \
			{ \
				ret = (m->member *10000); \
			} \
			else \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n",str); \
				ret = -10000; \
			} \
		} \

		#define	GET_MAPDATA_VAR_INT16(member, str) \
		{ \
			if ( mapscr *m = GetMapscr(ri->mapsref) ) \
			{ \
				ret = (m->member *10000); \
			} \
			else \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n",str); \
				ret = -10000; \
			} \
		} \

		#define	GET_MAPDATA_VAR_BYTE(member, str) \
		{ \
			if ( mapscr *m = GetMapscr(ri->mapsref) ) \
			{ \
				ret = (m->member *10000); \
			} \
			else \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n",str); \
				ret = -10000; \
			} \
		} \
		
		#define GET_MAPDATA_VAR_INDEX32(member, str, indexbound) \
		{ \
			int32_t indx = ri->d[rINDEX] / 10000; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, indx); \
				ret = -10000; \
			} \
			else \
			{ \
				if (mapscr *m = GetMapscr(ri->mapsref)) \
				{ \
					ret = (m->member[indx] *10000); \
				} \
				else \
				{ \
					Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n",str); \
					ret = -10000; \
				} \
			} \
		} \
		
		#define GET_MAPDATA_VAR_INDEX16(member, str, indexbound) \
		{ \
			int32_t indx = ri->d[rINDEX] / 10000; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, indx); \
				ret = -10000; \
			} \
			else \
			{ \
				if (mapscr *m = GetMapscr(ri->mapsref)) \
				{ \
					ret = (m->member[indx] *10000); \
				} \
				else \
				{ \
					Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n",str); \
					ret = -10000; \
				} \
			} \
		} \
		
		#define GET_MAPDATA_BYTE_INDEX(member, str, indexbound) \
		{ \
			int32_t indx = ri->d[rINDEX] / 10000; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, indx); \
				ret = -10000; \
			} \
			else \
			{ \
				if (mapscr *m = GetMapscr(ri->mapsref)) \
				{ \
					ret = (m->member[indx] *10000); \
				} \
				else \
				{ \
					Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n",str); \
					ret = -10000; \
				} \
			} \
		} \
		
		/*
		#define GET_MAPDATA_LAYER_INDEX(member, str, indexbound) \
		{ \
			int32_t indx = ri->d[rINDEX] / 10000; \
			mapscr *m = GetMapscr(ri->mapsref); \
			if ( indx == 0 ) \
			{ \
				\
			} \
			else \
			{ \
				ret = (m->member[indx-1] *10000); \
			} \
		} \
		*/
		
		#define GET_MAPDATA_LAYER_INDEX(member, str, indexbound) \
		{ \
			int32_t indx = ri->d[rINDEX] / 10000; \
			if ( FFCore.quest_format[vFFScript] < 11 ) ++indx; \
			if(indx < 1 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, indx); \
				ret = -10000; \
			} \
			else \
			{ \
				if (mapscr *m = GetMapscr(ri->mapsref)) \
				{ \
					ret = (m->member[indx-1] *10000); \
				} \
				else \
				{ \
					Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n",str); \
					ret = -10000; \
				} \
			} \
		} \
		
		#define GET_MAPDATA_BOOL_INDEX(member, str, indexbound) \
		{ \
			int32_t indx = ri->d[rINDEX] / 10000; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, indx); \
				ret = -10000; \
			} \
			else \
			{ \
				if (mapscr *m = GetMapscr(ri->mapsref)) \
				{ \
					ret = (m->member[indx]?10000:0); \
				} \
				else \
				{ \
					Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n",str); \
					ret = -10000; \
				} \
			} \
		} \

		#define GET_FFC_MAPDATA_BOOL_INDEX(member, str, indexbound) \
		{ \
			int32_t indx = ri->d[rINDEX] / 10000; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, indx); \
				ret = -10000; \
			} \
			else \
			{ \
				if (mapscr *m = GetMapscr(ri->mapsref)) \
				{ \
					ret = (m->ffcs[indx].member?10000:0); \
				} \
				else \
				{ \
					Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n",str); \
					ret = -10000; \
				} \
			} \
		} \
		
		#define GET_MAPDATA_FLAG(member, str) \
		{ \
			int32_t flag =  (value/10000);  \
			if (mapscr *m = GetMapscr(ri->mapsref)) \
			{ \
				ret = (m->member&flag) ? 10000 : 0); \
			} \
			else \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n",str); \
				ret = -10000; \
			} \
		} \
		
		#define GET_SCREENDATA_COMBO_VAR(member, str) \
		{ \
			if (mapscr *m = GetMapscr(ri->mapsref)) \
			{ \
				int32_t pos = ri->d[rINDEX] / 10000; \
				if(BC::checkComboPos(pos, str) != SH::_NoError) \
					ret = -10000; \
				else \
					ret = m->member[pos]*10000; \
			} \
			else \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n",str); \
				ret = -10000; \
			} \
		} \

		#define GET_MAPDATA_COMBO_VAR_BUF(member, str) \
		{ \
			if (mapscr *m = GetMapscr(ri->mapsref)) \
			{ \
				int32_t pos = ri->d[rINDEX] / 10000; \
				if(BC::checkComboPos(pos, str) != SH::_NoError) \
					ret = -10000; \
				else \
					ret = combobuf[m->data[pos]].member * 10000; \
			} \
			else \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n",str); \
				ret = -10000; \
			} \
		} \
		
		#define GET_MAPDATA_FFCPOS_INDEX32(member, str, indexbound) \
		{ \
			int32_t indx = (ri->d[rINDEX] / 10000)-1; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", (indx+1), str); \
				ret = -10000; \
			} \
			else if (mapscr *m = GetMapscr(ri->mapsref)) \
			{ \
				ret = (m->ffcs[indx].member).getZLong(); \
			} \
			else \
			{ \
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","str"); \
				ret = -10000; \
			} \
		} \
		
		#define GET_MAPDATA_FFC_INDEX32(member, str, indexbound) \
		{ \
			int32_t indx = (ri->d[rINDEX] / 10000)-1; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", (indx+1), str); \
				ret = -10000; \
			} \
			else if (mapscr *m = GetMapscr(ri->mapsref)) \
			{ \
				ret = (m->ffcs[indx].member)*10000; \
			} \
			else \
			{ \
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","str"); \
				ret = -10000; \
			} \
		} \

		#define GET_MAPDATA_FFC_INDEX32(member, str, indexbound) \
		{ \
			int32_t indx = (ri->d[rINDEX] / 10000)-1; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", (indx+1), str); \
				ret = -10000; \
			} \
			else if (mapscr *m = GetMapscr(ri->mapsref)) \
			{ \
				ret = (m->ffcs[indx].member)*10000; \
			} \
			else \
			{ \
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","str"); \
				ret = -10000; \
			} \
		} \
			
		case LOADMAPDATA:
				ret=FFScript::loadMapData();
				break;

		case NPCCOLLISION:
				ret=FFCore.npc_collision();
				break;

		case NPCLINEDUP:
				ret=FFCore.npc_linedup();
				break;

		case CREATEBITMAP:
		{
			ret=FFCore.do_create_bitmap();
			break;
		}


		case MAPDATAVALID:		GET_MAPDATA_VAR_BYTE(valid, "Valid"); break;		//b
		case MAPDATAGUY: 		GET_MAPDATA_VAR_BYTE(guy, "Guy"); break;		//b
		case MAPDATASTRING:		GET_MAPDATA_VAR_INT32(str, "String"); break;		//w
		case MAPDATAROOM: 		GET_MAPDATA_VAR_BYTE(room, "RoomType");	break;		//b
		case MAPDATAITEM:
		{
			if ( mapscr *m = GetMapscr(ri->mapsref) )
			{
				if(m->hasitem)
					ret = (m->item *10000);
				else ret = -10000;
			}
			else
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","Item"); \
				ret = -10000;
			}
			break;
		}
		case MAPDATAHASITEM: 		GET_MAPDATA_VAR_BYTE(hasitem, "HasItem"); break;	//b
		case MAPDATATILEWARPTYPE: 	GET_MAPDATA_BYTE_INDEX(tilewarptype, "TileWarpType", 3); break;	//b, 4 of these
		//case MAPDATATILEWARPOVFLAGS: 	GET_MAPDATA_VAR_BYTE(tilewarpoverlayflags, "TileWarpOverlayFlags"); break;	//b, tilewarpoverlayflags
		case MAPDATADOORCOMBOSET: 	GET_MAPDATA_VAR_INT32(door_combo_set, "DoorComboSet"); break;	//w
		case MAPDATAWARPRETX:	 	GET_MAPDATA_BYTE_INDEX(warpreturnx, "WarpReturnX", 3); break;	//b, 4 of these
		case MAPDATAWARPRETY:	 	GET_MAPDATA_BYTE_INDEX(warpreturny, "WarpReturnY", 3); break;	//b, 4 of these
		case MAPDATAWARPRETURNC: 	GET_MAPDATA_VAR_INT32(warpreturnc, "WarpReturnC"); break;	//w
		case MAPDATASTAIRX: 		GET_MAPDATA_VAR_BYTE(stairx, "StairsX"); break;	//b
		case MAPDATASTAIRY: 		GET_MAPDATA_VAR_BYTE(stairy, "StairsY"); break;	//b
		case MAPDATAITEMX:		GET_MAPDATA_VAR_BYTE(itemx, "ItemX"); break; //itemx
		case MAPDATAITEMY:		GET_MAPDATA_VAR_BYTE(itemy, "ItemY"); break;	//itemy
		case MAPDATACOLOUR: 		GET_MAPDATA_VAR_INT32(color, "CSet"); break;	//w
		case MAPDATAENEMYFLAGS: 	GET_MAPDATA_VAR_BYTE(enemyflags, "EnemyFlags");	break;	//b
		case MAPDATADOOR: 		GET_MAPDATA_BYTE_INDEX(door, "Door", 3); break;	//b, 4 of these
		case MAPDATATILEWARPDMAP: 	GET_MAPDATA_VAR_INDEX32(tilewarpdmap, "TileWarpDMap", 3); break;	//w, 4 of these
		case MAPDATATILEWARPSCREEN: 	GET_MAPDATA_BYTE_INDEX(tilewarpscr, "TileWarpScreen", 3); break;	//b, 4 of these
		case MAPDATAEXITDIR: 		GET_MAPDATA_VAR_BYTE(exitdir, "ExitDir"); break;	//b
		case MAPDATAENEMY: 		GET_MAPDATA_VAR_INDEX32(enemy, "Enemy", 9); break;	//w, 10 of these
		case MAPDATAPATTERN: 		GET_MAPDATA_VAR_BYTE(pattern, "Pattern"); break;	//b
		case MAPDATASIDEWARPTYPE: 	GET_MAPDATA_BYTE_INDEX(sidewarptype, "SideWarpType", 3); break;	//b, 4 of these
		//case MAPDATASIDEWARPOVFLAGS: 	GET_MAPDATA_VAR_BYTE(sidewarpoverlayflags, "SideWarpOverlayFlags"); break;	//b
		case MAPDATAWARPARRIVALX: 	GET_MAPDATA_VAR_BYTE(warparrivalx, "WarpArrivalX"); break;	//b
		case MAPDATAWARPARRIVALY: 	GET_MAPDATA_VAR_BYTE(warparrivaly, "WarpArrivalY"); break;	//b
		case MAPDATAPATH: 		GET_MAPDATA_BYTE_INDEX(path, "MazePath", 3); break;	//b, 4 of these
		case MAPDATASIDEWARPSC: 	GET_MAPDATA_BYTE_INDEX(sidewarpscr, "SideWarpScreen", 3); break;	//b, 4 of these
		case MAPDATAINITD:	 	GET_MAPDATA_VAR_INDEX32(screeninitd, "InitD", 8); break;	//w, 4 of these
		case MAPDATASIDEWARPDMAP: 	GET_MAPDATA_VAR_INDEX32(sidewarpdmap, "SideWarpDMap", 3); break;	//w, 4 of these
		case MAPDATASIDEWARPINDEX: 	GET_MAPDATA_VAR_BYTE(sidewarpindex, "SideWarpIndex"); break;	//b
		case MAPDATAUNDERCOMBO: 	GET_MAPDATA_VAR_INT32(undercombo, "UnderCombo"); break;	//w
		case MAPDATAUNDERCSET:	 	GET_MAPDATA_VAR_BYTE(undercset,	"UnderCSet"); break; //b
		case MAPDATACATCHALL:	 	GET_MAPDATA_VAR_INT32(catchall,	"Catchall"); break; //W

		case MAPDATACSENSITIVE: 	GET_MAPDATA_VAR_BYTE(csensitive, "CSensitive"); break;	//B
		case MAPDATANORESET: 		GET_MAPDATA_VAR_INT32(noreset, "NoReset"); break;	//W
		case MAPDATANOCARRY: 		GET_MAPDATA_VAR_INT32(nocarry, "NoCarry"); break;	//W
		case MAPDATALAYERMAP:	 	GET_MAPDATA_LAYER_INDEX(layermap, "LayerMap", 6); break;	//B, 6 OF THESE
		case MAPDATALAYERSCREEN: 	GET_MAPDATA_LAYER_INDEX(layerscreen, "LayerScreen", 6); break;	//B, 6 OF THESE
		case MAPDATALAYEROPACITY: 	GET_MAPDATA_LAYER_INDEX(layeropacity, "LayerOpacity", 6); break;	//B, 6 OF THESE
		case MAPDATATIMEDWARPTICS: 	GET_MAPDATA_VAR_INT32(timedwarptics, "TimedWarpTimer"); break;	//W
		case MAPDATANEXTMAP: 		GET_MAPDATA_VAR_BYTE(nextmap, "NextMap"); break;	//B
		case MAPDATANEXTSCREEN: 	GET_MAPDATA_VAR_BYTE(nextscr, "NextScreen"); break;	//B
		case MAPDATASECRETCOMBO: 	GET_MAPDATA_VAR_INDEX32(secretcombo, "SecretCombo", 127); break;	//W, 128 OF THESE
		case MAPDATASECRETCSET: 	GET_MAPDATA_BYTE_INDEX(secretcset, "SecretCSet", 127); break;	//B, 128 OF THESE
		case MAPDATASECRETFLAG: 	GET_MAPDATA_BYTE_INDEX(secretflag, "SecretFlags", 127); break;	//B, 128 OF THESE

		case MAPDATAVIEWX: 		break;//GET_MAPDATA_VAR_INT32(viewX, "ViewX"); break;	//W
		case MAPDATASCRIPT: 		GET_MAPDATA_VAR_INT32(script, "Script"); break;	//W
		case MAPDATAVIEWY: 		break;//GET_MAPDATA_VAR_INT32(viewY, "ViewY"); break; //W
		case MAPDATASCREENWIDTH: 	break;//GET_MAPDATA_VAR_BYTE(scrWidth, "Width"); break;	//B
		case MAPDATASCREENHEIGHT: 	break;//GET_MAPDATA_VAR_BYTE(scrHeight,	"Height"); break;	//B
		case MAPDATAENTRYX: 		GET_MAPDATA_VAR_BYTE(entry_x, "EntryX"); break;	//B
		case MAPDATAENTRYY: 		GET_MAPDATA_VAR_BYTE(entry_y, "EntryY"); break;	//B
		case MAPDATAFFDATA:         GET_MAPDATA_FFC_INDEX32(data, "FFCData", MAXFFCS-1); break;  //W, MAXFFCS OF THESE
		case MAPDATAFFCSET:         GET_MAPDATA_FFC_INDEX32(cset, "FFCCSet", MAXFFCS-1); break;  //B, MAXFFCS
		case MAPDATAFFDELAY:        GET_MAPDATA_FFC_INDEX32(delay, "FFCDelay", MAXFFCS-1); break;    //W, MAXFFCS
		case MAPDATAFFX:        GET_MAPDATA_FFCPOS_INDEX32(x, "FFCX", MAXFFCS-1); break; //INT32, MAXFFCS OF THESE
		case MAPDATAFFY:        GET_MAPDATA_FFCPOS_INDEX32(y, "FFCY", MAXFFCS-1); break; //..
		case MAPDATAFFXDELTA:       GET_MAPDATA_FFCPOS_INDEX32(vx, "FFCVx", MAXFFCS-1); break;   //..
		case MAPDATAFFYDELTA:       GET_MAPDATA_FFCPOS_INDEX32(vy, "FFCVy", MAXFFCS-1); break;   //..
		case MAPDATAFFXDELTA2:      GET_MAPDATA_FFCPOS_INDEX32(ax, "FFCAx", MAXFFCS-1); break;  //..
		case MAPDATAFFYDELTA2:      GET_MAPDATA_FFCPOS_INDEX32(ay, "FFCAy", MAXFFCS-1); break;  //..
		case MAPDATAFFFLAGS:        GET_MAPDATA_FFC_INDEX32(flags, "FFCFlags", MAXFFCS-1); break;    //INT16, MAXFFCS OF THESE
		case MAPDATASIDEWARPID: 
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if (mapscr *m = GetMapscr(ri->mapsref))
			{
				ret = (((m->flags2 >> indx) & 1)
					? (m->sidewarpindex >> (2*indx)) & 3 //Return which warp is set
					: -1 //Returns -1 if no warp is set
					)*10000;
			}
			else
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","SideWarpID");
				ret = -10000;
			} 
			break;
		}
		//Number of ffcs that are in use (have valid data
		case MAPDATANUMFF: 	
		{
			uint32_t indx = ri->d[rINDEX] / 10000;
			if (!indx || indx > MAXFFCS)
			{
				Z_scripterrlog("Invalid Index passed to mapdata->NumFFCs[%d].\n Valid indices are 1 through %d.\n", indx, MAXFFCS);
				ret = 0;
			}
			else if (mapscr *m = GetMapscr(ri->mapsref))
			{
				--indx;
				ret = (m->ffcs[indx].data != 0) ? 10000 : 0;
			}
			else
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","NumFFCs[]");
				ret = 0;
			}
			break;
		}

		case MAPDATATILEWARPOVFLAGS: 
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if ( ((unsigned)indx) > 3 ) 
			{
				Z_scripterrlog("Invalid index passed to TileWarpOverlayFlags[%d].\n. Valid indices are [0] through [3].\n", indx);
				ret = 0;
			}
			else if (mapscr *m = GetMapscr(ri->mapsref))
			{
				ret = (m->tilewarpoverlayflags & (1<<indx))?10000:0;
			}
			else
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","NumFFCs[]");
				ret = 0;
			}
			break;
		}

		case MAPDATASIDEWARPOVFLAGS: 
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if ( ((unsigned)indx) > 3 ) 
			{
				Z_scripterrlog("Invalid index passed to SideWarpOverlayFlags[%d].\n. Valid indices are [0] through [3].\n", indx);
				ret = 0;
			}
			else if (mapscr *m = GetMapscr(ri->mapsref))
			{
				ret = (m->sidewarpoverlayflags & (1<<indx))?10000:0;
			}
			else
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","NumFFCs[]");
				ret = 0;
			}
			break;
		}

		case MAPDATATWARPRETSQR:
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if ( ((unsigned)indx) > 3)
			{
				ret = -10000;
				Z_scripterrlog("Invalid Array Index passed to mapdata->TileWarpReturnSquare[]: %d\n", indx);
				
			}
			else if (mapscr *m = GetMapscr(ri->mapsref))
			{
				ret = ((m->warpreturnc>>(indx*2))&3) * 10000;
			}
			else 
			{ 
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","str"); 
				ret = -10000;
			}
			break;
		}

		case MAPDATASWARPRETSQR:
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if ( ((unsigned)indx) > 3)
			{
				ret = -10000;
				Z_scripterrlog("Invalid Array Index passed to mapdata->TileWarpReturnSquare[]: %d\n", indx);
				
			}
			else if (mapscr *m = GetMapscr(ri->mapsref))
			{
				ret = ((m->warpreturnc>>(8+(indx*2)))&3) * 10000;
			}
			else 
			{
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","str"); 
				ret = -10000; 
			}
			break;
		}
		
		case MAPDATAFFWIDTH:       
		{
			if (mapscr *m = GetMapscr(ri->mapsref))
			{
				int32_t indx = (ri->d[rINDEX] / 10000)-1;
				if ( indx < 0 || indx > MAXFFCS-1 )
				{
					Z_scripterrlog("Invalid FFC Index passed to MapData->FFCTileWidth[]: %d\n", indx+1);
					ret = -10000;
					break;
				}
				ret=(m->ffTileWidth(indx))*10000;
			}
			else
			{
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","FFCTileWidth[]");
				ret = -10000;
			}
			break;
		}
		
		case MAPDATAFFHEIGHT:      
		{
			if (mapscr *m = GetMapscr(ri->mapsref))
			{
				int32_t indx = (ri->d[rINDEX] / 10000)-1;
				if ( indx < 0 || indx > MAXFFCS-1 )
				{
					Z_scripterrlog("Invalid FFC Index passed to MapData->FFCTileHeight[]: %d\n", indx+1);
					ret = -10000;
					break;
				}
				ret=(m->ffTileHeight(indx))*10000;
			}
			else
			{
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","FFCTileHeight[]");
				ret = -10000;
			}
			break;
			
		}
		 
		case MAPDATAFFEFFECTWIDTH:     
		{
			if (mapscr *m = GetMapscr(ri->mapsref))
			{
				int32_t indx = (ri->d[rINDEX] / 10000)-1;
				if ( indx < 0 || indx > MAXFFCS-1 )
				{
					Z_scripterrlog("Invalid FFC Index passed to MapData->FFCEffectWidth[]: %d\n", indx+1);
					ret = -10000;
					break;
				}
				ret=(m->ffEffectWidth(indx))*10000;
			}
			else
			{
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","FFCEffectWidth[]");
				ret = -10000;
			}
			break;
		}
		
		case MAPDATAFFEFFECTHEIGHT:
		{
			if (mapscr *m = GetMapscr(ri->mapsref))
			{
				int32_t indx = (ri->d[rINDEX] / 10000)-1;
				if ( indx < 0 || indx > MAXFFCS-1 )
				{
					Z_scripterrlog("Invalid FFC Index passed to MapData->FFCEffectHeight[]: %d\n", indx+1);
					ret = -10000;
					break;
				}
				ret=(m->ffEffectHeight(indx))*10000;
			}
			else
			{
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","FFCEffectHeight[]");
				ret = -10000;
			}
			break;
		}
			
		 
		case MAPDATAFFLINK:         GET_MAPDATA_FFC_INDEX32(link, "FFCLink", MAXFFCS-1); break;  //B, MAXFFCS OF THESE
		case MAPDATAFFSCRIPT:       GET_MAPDATA_FFC_INDEX32(script, "FFCScript", MAXFFCS-1); break;  //W, MAXFFCS OF THESE

		case MAPDATAINTID: 	 //Same form as SetScreenD()
			//SetFFCInitD(ffindex, d, value)
		{
			if (mapscr *m = GetMapscr(ri->mapsref))
			{
				int32_t ffid = (ri->d[rINDEX]/10000) -1;
				int32_t indx = ri->d[rINDEX2]/10000;
					
				if ( (unsigned)ffid > MAXFFCS-1 ) 
				{
					Z_scripterrlog("Invalid FFC id passed to mapdata->FFCInitD[]: %d",ffid); 
					ret = -10000;
				}
				else if ( (unsigned)indx > 7 )
				{
					Z_scripterrlog("Invalid InitD[] index passed to mapdata->FFCInitD[]: %d",indx);
					ret = -10000;
				}
				else
				{ 
					ret = (m->ffcs[ffid].initd[indx]);
				}
				
				//int32_t ffindex = ri->d[rINDEX]/10000;
				//int32_t d = ri->d[rINDEX2]/10000;
				//int32_t v = (value/10000);
			}
			else
			{
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","GetFFCInitD()");
				ret = -10000; 
			}	
			break;
		}	



		//initd	//INT32 , 32 OF THESE, EACH WITH 10 INDICES. 

		case MAPDATAINITA: 		
			//same form as SetScreenD
		{
			if (mapscr *m = GetMapscr(ri->mapsref))
			{
				//int32_t ffindex = ri->d[rINDEX]/10000;
				//int32_t d = ri->d[rINDEX2]/10000;
				//int32_t v = (value/10000);
				
				int32_t ffid = (ri->d[rINDEX]/10000) -1;
				int32_t indx = ri->d[rINDEX2]/10000;
					
				if ( (unsigned)ffid > MAXFFCS-1 ) 
				{
					Z_scripterrlog("Invalid FFC id passed to mapdata->FFCInitD[]: %d",ffid); 
					ret = -10000;
				}
				else if ( (unsigned)indx > 1 )
				{
					Z_scripterrlog("Invalid InitD[] index passed to mapdata->FFCInitD[]: %d",indx);
					ret = -10000;
				}
				else
				{ 
					ret = (m->ffcs[ffid].inita[indx]);
				}
			}
			else
			{
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","GetFFCInitD()");
				ret = -10000;
			}
			break;
		}	

			//inita	//INT32, 32 OF THESE, EACH WITH 2
		
		case MAPDATAFFINITIALISED:
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if (indx < 0 || indx > MAXFFCS-1)
			{
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", "FFCRunning", indx);
				ret = -10000;
			}
			else
			{
				if (mapscr *m = GetMapscr(ri->mapsref))
				{
					ret = get_script_engine_data(ScriptType::FFC, indx).initialized ? 10000 : 0;
				}
				else
				{
					Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n", "FFCRunning");
					ret = -10000;
				}
			}
		}
		break;

		case MAPDATASCRIPTENTRY: 	GET_MAPDATA_VAR_INT32(script_entry, "ScriptEntry"); break;	//W
		case MAPDATASCRIPTOCCUPANCY: 	GET_MAPDATA_VAR_INT32(script_occupancy,	"ScriptOccupancy");  break;//W
		case MAPDATASCRIPTEXIT: 	GET_MAPDATA_VAR_INT32(script_exit, "ExitScript"); break;	//W
		case MAPDATAOCEANSFX:	 	GET_MAPDATA_VAR_BYTE(oceansfx, "OceanSFX"); break;	//B
		case MAPDATABOSSSFX: 		GET_MAPDATA_VAR_BYTE(bosssfx, "BossSFX"); break;	//B
		case MAPDATASECRETSFX:	 	GET_MAPDATA_VAR_BYTE(secretsfx, "SecretSFX"); break;	//B
		case MAPDATAHOLDUPSFX:	 	GET_MAPDATA_VAR_BYTE(holdupsfx,	"ItemSFX"); break; //B
		case MAPDATASCREENMIDI:
		{
			if (mapscr *m = GetMapscr(ri->mapsref))
			{
				ret = ((m->screen_midi+(MIDIOFFSET_MAPSCR-MIDIOFFSET_ZSCRIPT)) *10000);
			}
			else
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","MIDI");
				ret = -10000;
			}
			break;
		}
		case MAPDATALENSLAYER:	 	GET_MAPDATA_VAR_BYTE(lens_layer, "LensLayer"); break;	//B, OLD QUESTS ONLY?
		case MAPDATAMAP:
		{
			if (mapscr *m = GetMapscr(ri->mapsref))
			{
				ret = getMap(ri->mapsref) * 10000;
			}
			else
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","Map");
				ret = -10000;
			}
			break;
		}
		case MAPDATASCREEN:
		{
			if (mapscr *m = GetMapscr(ri->mapsref))
			{
				ret = getScreen(ri->mapsref) * 10000;
			}
			else
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","Screen");
				ret = -10000;
			}
			break;
		}

		case MAPDATAFLAGS: 
		{
			if(mapscr *m = GetMapscr(ri->mapsref))
			{
				if ( get_qr(qr_OLDMAPDATAFLAGS) )
				{
					ret = get_screenflags(m,vbound(ri->d[rINDEX] / 10000,0,9));
				}
				else
				{
					int32_t flagid = (ri->d[rINDEX])/10000;
					//bool valtrue = ( value ? 10000 : 0);
					switch(flagid)
					{
						case 0: ret = (m->flags * 10000); break;
						case 1: ret = (m->flags2 * 10000); break;
						case 2: ret = (m->flags3 * 10000); break;
						case 3: ret = (m->flags4 * 10000); break;
						case 4: ret = (m->flags5 * 10000); break;
						case 5: ret = (m->flags6 * 10000); break;
						case 6: ret = (m->flags7 * 10000); break;
						case 7: ret = (m->flags8 * 10000); break;
						case 8: ret = (m->flags9 * 10000); break;
						case 9: ret = (m->flags10 * 10000); break;
						default:
						{
							Z_scripterrlog("Invalid index passed to mapdata->flags[]: %d\n", flagid); 
							ret = -10000;
							break;
							
						}
					}
				}
			}
			else
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","Flags[]");
				ret = -10000;
			}
			
			break;
			//GET_MAPDATA_BYTE_INDEX	//B, 11 OF THESE, flags, flags2-flags10
		}

		case MAPDATAMISCD:
		{
			int32_t indx = (ri->d[rINDEX])/10000;
			int32_t mi = get_mi(ri->mapsref);
			if(unsigned(mi) >= MAX_MI)
			{
				ret = 0;
				break;
			}
			if( ((unsigned)indx) > 7 )
			{
				Z_scripterrlog("You were trying to reference an out-of-bounds array index for a screen's D[] array (%ld); valid indices are from 0 to 7.\n", indx);
				ret = -10000;
			}
			else if (mapscr *m = GetMapscr(ri->mapsref))
			{
				ret = (game->screen_d[mi][indx]) * 10000;
			}
			else
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","D[]");
				ret = -10000;
			}
			break;
		}

		case MAPDATACOMBODD:
		{
			if (mapscr *m = GetMapscr(ri->mapsref))
			{
				int32_t pos = ri->d[rINDEX] / 10000;
				if(BC::checkComboPos(pos, "mapdata->ComboD[pos]") != SH::_NoError)
				{
					ret = -10000;
				}
				else
				{
					ret = m->data[pos] * 10000;
				}
			}
			else
			{
				Z_scripterrlog("Mapdata->%s pointer (%d) is either invalid or uninitialised.\n","ComboD[]",ri->mapsref);
				ret = -10000;
			}
			break;
			//GET_SCREENDATA_COMBO_VAR(data,  "mapdata->ComboD") break;
		}
			
		case MAPDATACOMBOCD:
		{
			if (mapscr *m = GetMapscr(ri->mapsref))
			{
				//int32_t ffindex = ri->d[rINDEX]/10000;
				//int32_t d = ri->d[rINDEX2]/10000;
				//int32_t v = (value/10000);
				int32_t pos = ri->d[rINDEX] / 10000;
				if(BC::checkComboPos(pos, "mapdata->ComboC[pos]") != SH::_NoError)
				{
					ret = -10000;
				}
				else
				{
					ret = m->cset[pos] * 10000;
				}
			}
			else
			{
				Z_scripterrlog("Mapdata->%s pointer (%d) is either invalid or uninitialised.\n","ComboC[]",ri->mapsref);
				ret = -10000;
			}
			break;
		}
			//GET_SCREENDATA_COMBO_VAR(cset,  "mapdata->ComboC") break;
			
		case MAPDATACOMBOFD:
		{
			if (mapscr *m = GetMapscr(ri->mapsref))
			{
				//int32_t ffindex = ri->d[rINDEX]/10000;
				//int32_t d = ri->d[rINDEX2]/10000;
				//int32_t v = (value/10000);
				int32_t pos = ri->d[rINDEX] / 10000;
				if(BC::checkComboPos(pos, "mapdata->ComboF[pos]") != SH::_NoError)
				{
					ret = -10000;
				}
				else
				{
					ret = m->sflag[pos] * 10000;
				}
			}
			else
			{
				Z_scripterrlog("Mapdata->%s pointer (%d) is either invalid or uninitialised.\n","ComboF[]",ri->mapsref);
				ret = -10000;
			}
			break;
		}
			//GET_SCREENDATA_COMBO_VAR(sflag, "mapdata->ComboF") break;
			

			
		case MAPDATACOMBOTD:
		{
			if (mapscr *m = GetMapscr(ri->mapsref))
			{
				//int32_t ffindex = ri->d[rINDEX]/10000;
				//int32_t d = ri->d[rINDEX2]/10000;
				//int32_t v = (value/10000);
				int32_t pos = ri->d[rINDEX] / 10000;
				if(BC::checkComboPos(pos, "mapdata->ComboT[pos]") != SH::_NoError)
				{
					ret = -10000;
					
				}
				else
				{
					ret = combobuf[m->data[pos]].type * 10000;
				}
			}
			else
			{
				Z_scripterrlog("Mapdata->%s pointer (%d) is either invalid or uninitialised.\n","ComboT[]",ri->mapsref);
				ret = -10000;
			}
			break;
		}
			//GET_MAPDATA_COMBO_VAR_BUF(type, "mapdata->ComboT") break;
			
		case MAPDATACOMBOID:
		{
			if (mapscr *m = GetMapscr(ri->mapsref))
			{
				//int32_t ffindex = ri->d[rINDEX]/10000;
				//int32_t d = ri->d[rINDEX2]/10000;
				//int32_t v = (value/10000);
				int32_t pos = ri->d[rINDEX] / 10000;
				if(BC::checkComboPos(pos, "mapdata->ComboI[pos]") != SH::_NoError)
				{
					ret = -10000;
				}
				else
				{
					ret = combobuf[m->data[pos]].flag * 10000;
				}
			}
			else
			{
				Z_scripterrlog("Mapdata->%s pointer (%d) is either invalid or uninitialised.\n","ComboI[]",ri->mapsref);
				ret = -10000;
			}
			break;
			//GET_SCREENDATA_COMBO_VAR(data,  "mapdata->ComboD") break;
		}
			//GET_MAPDATA_COMBO_VAR_BUF(flag, "mapdata->ComboI") break;
			
		case MAPDATACOMBOSD:
		{
			if (mapscr *m = GetMapscr(ri->mapsref))
			{
				//int32_t ffindex = ri->d[rINDEX]/10000;
				//int32_t d = ri->d[rINDEX2]/10000;
				//int32_t v = (value/10000);
				int32_t pos = ri->d[rINDEX] / 10000;
				if(BC::checkComboPos(pos, "mapdata->ComboS[pos]") != SH::_NoError)
				{
					ret = -10000;
				}
				else
				{
					ret = (combobuf[m->data[pos]].walk & 0xF) * 10000;
				}	
			}
			else
			{
				Z_scripterrlog("Mapdata->%s pointer (%d) is either invalid or uninitialised.\n","ComboS[]", ri->mapsref);
				ret = -10000;
			}
			break;
		}
			
		case MAPDATACOMBOED:
		{
			if (mapscr *m = GetMapscr(ri->mapsref))
			{
				//int32_t ffindex = ri->d[rINDEX]/10000;
				//int32_t d = ri->d[rINDEX2]/10000;
				//int32_t v = (value/10000);
				int32_t pos = ri->d[rINDEX] / 10000;
				if(BC::checkComboPos(pos, "mapdata->ComboE[pos]") != SH::_NoError)
				{
					ret = -10000;
				}
				else
				{
					ret = ((combobuf[m->data[pos]].walk & 0xF0)>>4) * 10000;
				}	
			}
			else
			{
				Z_scripterrlog("Mapdata->%s pointer (%d) is either invalid or uninitialised.\n","ComboE[]", ri->mapsref);
				ret = -10000;
			}
			break;
		}
		
		case MAPDATASCREENSTATED:
		{
			if (mapscr *m = GetMapscr(ri->mapsref))
			{
				int32_t mi = get_mi(ri->mapsref);
				if(mi<0) {ret = 0;break;}
				ret=((game->maps[mi]>>((ri->d[rINDEX]/10000)))&1)?10000:0;
			}
			else
			{
				Z_scripterrlog("Mapdata->%s pointer (%d) is either invalid or uninitialised.\n","State[]", ri->mapsref);
				ret = 0;
			}
			break;
		}
		case MAPDATAEXSTATED:
		{
			if (mapscr *m = GetMapscr(ri->mapsref))
			{
				int32_t mi = get_mi(ri->mapsref);
				if(mi<0) {ret = 0;break;}
				ret=((game->xstates[mi]>>((ri->d[rINDEX]/10000)))&1)?10000:0;
			}
			else
			{
				Z_scripterrlog("Mapdata->%s pointer (%d) is either invalid or uninitialised.\n","State[]", ri->mapsref);
				ret = 0;
			}
			break;
		}
		case MAPDATALENSSHOWS:
		{
			ret = 0;
			int ind = ri->d[rINDEX]/10000;
			if(ind < 0 || ind > 6)
				Z_scripterrlog("Bad index mapdata->LensShows[%d]\n",ind);
			else if(mapscr *m = GetMapscr(ri->mapsref))
				ret = (m->lens_show & (1<<ind)) ? 10000 : 0;
			else Z_scripterrlog("mapdata->LensShows[] pointer (%d) is either invalid or uninitialised.\n", ri->mapsref);
			break;
		}
		case MAPDATALENSHIDES:
		{
			ret = 0;
			int ind = ri->d[rINDEX]/10000;
			if(ind < 0 || ind > 6)
				Z_scripterrlog("Bad index mapdata->LensHides[%d]\n",ind);
			else if(mapscr *m = GetMapscr(ri->mapsref))
				ret = (m->lens_hide & (1<<ind)) ? 10000 : 0;
			else Z_scripterrlog("mapdata->LensHides[] pointer (%d) is either invalid or uninitialised.\n", ri->mapsref);
			break;
		}
		case MAPDATASCRDATASIZE:
		{
			ret = -10000;
			if(mapscr *m = GetMapscr(ri->mapsref))
			{
				auto mi = get_total_mi(ri->mapsref);
				if(mi < 0) break;
				ret = 10000*game->scriptDataSize(mi);
			}
			else Z_scripterrlog("mapdata->DataSize pointer (%d) is either invalid or uninitialised.\n", ri->mapsref);
			break;
		}
		case MAPDATASCRDATA:
		{
			ret = -10000;
			if(mapscr *m = GetMapscr(ri->mapsref))
			{
				auto mi = get_total_mi(ri->mapsref);
				if(mi < 0) break;
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= game->scriptDataSize(mi))
					Z_scripterrlog("Invalid index passed to mapdata->Data[]: %d\n", indx);
				else ret = game->screen_data[mi][indx];
			}
			else Z_scripterrlog("mapdata->Data[] pointer (%d) is either invalid or uninitialised.\n", ri->mapsref);
			break;
		}
		case MAPDATASCREENFLAGSD:
		{
			if(mapscr *m = GetMapscr(ri->mapsref))
			{
				ret = get_screenflags(m,vbound(ri->d[rINDEX] / 10000,0,9));
			}
			else
			{
				Z_scripterrlog("Mapdata->%s pointer (%d) is either invalid or uninitialised.\n","SFlags[]", ri->mapsref);
				ret = -10000;
			}
			break;
		}
			
		case MAPDATASCREENEFLAGSD:
		{
			if(mapscr *m = GetMapscr(ri->mapsref))
			{
				ret = get_screeneflags(m,vbound(ri->d[rINDEX] / 10000,0,2));
			}
			else
			{
				Z_scripterrlog("Mapdata->%s pointer (%d) is either invalid or uninitialised.\n","EFlags[]", ri->mapsref);
				ret = -10000;
			}
			break;
		}
		case MAPDATAGUYCOUNT:
		{
			if(mapscr *m = GetMapscr(ri->mapsref))
			{
				int mi = get_mi(ri->mapsref);
				if(mi > -1)
				{
					ret = game->guys[mi] * 10000;
					break;
				}
			}
			ret = -10000;
			Z_scripterrlog("Mapdata->%s pointer (%d) is either invalid or uninitialised.\n","GuyCount", ri->mapsref);
			break;
		}
		case MAPDATAEXDOOR:
		{
			ret = 0;
			if(mapscr *m = GetMapscr(ri->mapsref))
			{
				int mi = get_mi(ri->mapsref);
				if(mi < 0) break;
				int dir = SH::read_stack(ri->sp+1) / 10000;
				int ind = SH::read_stack(ri->sp+0) / 10000;
				if(unsigned(dir) > 3)
					Z_scripterrlog("Invalid dir '%d' passed to 'mapdata->GetExDoor()'; must be 0-3\n", dir);
				else if(unsigned(ind) > 7)
					Z_scripterrlog("Invalid index '%d' passed to 'mapdata->GetExDoor()'; must be 0-7\n", ind);
				else
				{
					int bit = 1<<ind;
					ret = (game->xdoors[mi][dir]&bit) ? 10000 : 0;
				}
			}
			else Z_scripterrlog("mapdata->GetExDoor pointer (%d) is either invalid or uninitialised.\n", ri->mapsref);
			break;
		}

		///----------------------------------------------------------------------------------------------------//
		//shopdata sd-> variables
	
		case SHOPDATATYPE:
		{
			int32_t ref = ri->shopsref; 
			if ( ref > NUMINFOSHOPS || ref < 0 ) ret = 0;
			else ret = ( ( ref <= NUMSHOPS ) ? 10000 : 20000 ); 
			break;
		}
		case SHOPDATAITEM:
		{ 
			
			int32_t ref = ri->shopsref; 
			bool isInfo = ( ref > NUMSHOPS && ref <= NUMINFOSHOPS ); 
			int32_t indx = ri->d[rINDEX] / 10000; 
			if ( indx < 0 || indx > 2 ) 
			{ 
				Z_scripterrlog("Invalid Array Index passed to shopdata->%s: %d\n", indx, "Item");
				ret = -10000;
			} 
			else 
			{ 
				if ( isInfo ) 
				{ 
					Z_scripterrlog("Attempted to load an 'item' from an infoshop, using shop ID: %d\n", ri->shopsref); 
					ret = -10000;
				} 
				else 
				{ 
					ret = ((int32_t)(QMisc.shop[ref].item[indx]) * 10000); 
				} 
			} 
			break;
		} 
		
		
		// GET_SHOPDATA_VAR_INDEX(item, "Item", 2); break;
		case SHOPDATAHASITEM: 
		{ 
			
			int32_t ref = ri->shopsref; 
			bool isInfo = ( ref > NUMSHOPS && ref <= NUMINFOSHOPS ); 
			int32_t indx = ri->d[rINDEX] / 10000; 
			if ( indx < 0 || indx > 2 ) 
			{ 
				Z_scripterrlog("Invalid Array Index passed to shopdata->%s: %d\n", indx, "HasItem"); 
				ret = -10000;
			} 
			else 
			{ 
				if ( isInfo ) 
				{ 
					Z_scripterrlog("Attempted to load 'hasitem' from an infoshop, using shop ID: %d\n", ri->shopsref); 
					ret = -10000;
				} 
				else 
				{ 
					ret = ((int32_t)(QMisc.shop[ref].hasitem[indx]) * 10000); 
				} 
			} 
			break;
		} 
		
			
		//GET_SHOPDATA_VAR_INDEX(hasitem, "HasItem", 2); break;
		case SHOPDATAPRICE: 
		{ 
			
			int32_t ref = ri->shopsref; 
			bool isInfo = ( ref > NUMSHOPS && ref <= NUMINFOSHOPS ); 
			int32_t indx = ri->d[rINDEX] / 10000; 
			if ( indx < 0 || indx > 2 ) 
			{ 
				Z_scripterrlog("Invalid Array Index passed to shopdata->%s: %d\n", indx, "Price"); 
				ret = -10000;
			} 
			else 
			{ 
				if ( isInfo ) 
				{ 
					ret = ((int32_t)(QMisc.info[ref - NUMSHOPS].price[indx]) * 10000); 
				} 
				else 
				{ 
					ret = ((int32_t)(QMisc.shop[ref].price[indx]) * 10000); 
				} 
			} 
			break;
		} 
		
		
		//GET_SHOPDATA_VAR_INDEX(price, "Price", 2); break;
		//Pay for info
		case SHOPDATASTRING:
		{
			int32_t ref = ri->shopsref;
			if (ref < NUMSHOPS || ref > NUMINFOSHOPS)
			{
				Z_scripterrlog("Invalid shop pointer passed to shopdata->String[]: %d\n", ref); 
				ret = -10000;
			}
			else 
			{
				bool isInfo = ( ref > NUMSHOPS && ref <= NUMINFOSHOPS ); 
				int32_t indx = ri->d[rINDEX] / 10000; 
				if ( indx < 0 || indx > 2 ) 
				{ 
					Z_scripterrlog("Invalid Array Index passed to shopdata->%s: %d\n", indx, "String"); 
				} 
				else 
				{ 
					if ( isInfo ) 
					{ 
						ret = ((int32_t)(QMisc.info[ref - NUMSHOPS].str[indx]) * 10000); 
					} 
					else 
					{ 
						ret = ((int32_t)(QMisc.shop[ref].str[indx]) * 10000); 
					} 
				} 
		
		
			}
				
			//GET_SHOPDATA_VAR_INDEX(str, String, 2); break;
			break;
		}
		
		
		///----------------------------------------------------------------------------------------------------//
		//dmapdata dmd-> variables

		//getter
		case DMAPDATAID: ret = ri->dmapsref*10000; break; //read-only, equal to CurrentDMap
			
		case DMAPDATAMAP: 	//byte
		{
			ret = ((byte)DMaps[ri->dmapsref].map + 1) * 10000; break;
		}
		case DMAPDATALEVEL:	//word
		{
			ret = ((word)DMaps[ri->dmapsref].level) * 10000; break;
		}
		case DMAPDATAOFFSET:	//char
		{
			ret = ((char)DMaps[ri->dmapsref].xoff) * 10000; break;
		}
		case DMAPDATACOMPASS:	//byte
		{
			ret = ((byte)DMaps[ri->dmapsref].compass) * 10000; break;
		}
		case DMAPDATAPALETTE:	//word
		{
			ret = ((word)DMaps[ri->dmapsref].color) * 10000; break;
		}
		case DMAPSCRIPT:	//word
		{
			ret = (DMaps[ri->dmapsref].script) * 10000; break;
		}
		case DMAPDATAMIDI:	//byte
		{
			ret = (DMaps[ri->dmapsref].midi-MIDIOFFSET_DMAP) * 10000; break;
		}
		case DMAPDATACONTINUE:	//byte
		{
			ret = ((byte)DMaps[ri->dmapsref].cont) * 10000; break;
		}
		case DMAPDATATYPE:	//byte
		{
			ret = ((byte)DMaps[ri->dmapsref].type&dmfTYPE) * 10000; break;
		}
		case DMAPDATASIDEVIEW:	//byte
		{
			ret = ((DMaps[ri->dmapsref].sideview) ? 10000 : 0); break;
		}
		case DMAPDATAGRID:	//byte[8] --array
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if ( indx < 0 || indx > 7 ) 
			{
				Z_scripterrlog("Invalid index supplied to dmapdata->Grid[]: %d\n", indx);
				ret = -10000;
				break;
			}
			else
			{
				ret = ((byte)DMaps[ri->dmapsref].grid[indx]) * 10000;  break;
			}
		}
		case DMAPINITD:	//byte[8] --array
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if ( indx < 0 || indx > 7 ) 
			{
				Z_scripterrlog("Invalid index supplied to dmapdata->InitD[]: %d\n", indx);
				ret = -10000;
				break;
			}
			else
			{
				ret = DMaps[ri->dmapsref].initD[indx]; break;
			}
		}
		case DMAPDATAMINIMAPTILE:	//word - two of these, so let's do MinimapTile[2]
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			switch(indx)
			{
				case 0: { ret = ((word)DMaps[ri->dmapsref].minimap_1_tile) * 10000; break; }
				case 1: { ret = ((word)DMaps[ri->dmapsref].minimap_2_tile) * 10000; break; }
				default: 
				{
					Z_scripterrlog("Invalid index supplied to dmapdata->MiniMapTile[]: %d\n", indx);
					ret = -10000;
					break;
				}
			}
			break;
		}
		case DMAPDATAMINIMAPCSET:	//byte - two of these, so let's do MinimapCSet[2]
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			switch(indx)
			{
				case 0: { ret = ((byte)DMaps[ri->dmapsref].minimap_1_cset) * 10000; break; }
				case 1: { ret = ((byte)DMaps[ri->dmapsref].minimap_2_cset) * 10000; break; }
				default: 
				{
					Z_scripterrlog("Invalid index supplied to dmapdata->MiniMapCSet[]: %d\n", indx);
					ret = -10000;
					break;
				}
			}
			break;
		}
		case DMAPDATALARGEMAPTILE:	//word -- two of these, so let's to LargemapTile[2]
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			switch(indx)
			{
				case 0: { ret = ((word)DMaps[ri->dmapsref].largemap_1_tile) * 10000; break; }
				case 1: { ret = ((word)DMaps[ri->dmapsref].largemap_2_tile) * 10000; break; }
				default: 
				{
					Z_scripterrlog("Invalid index supplied to dmapdata->MapTile[]: %d\n", indx);
					ret = -10000;
					break;
				}
			}
			break;
		}
		case DMAPDATALARGEMAPCSET:	//word -- two of these, so let's to LargemaCSet[2]
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			switch(indx)
			{
				case 0: { ret = ((byte)DMaps[ri->dmapsref].largemap_1_cset) * 10000; break; }
				case 1: { ret = ((byte)DMaps[ri->dmapsref].largemap_2_cset) * 10000; break; }
				default: 
				{
					Z_scripterrlog("Invalid index supplied to dmapdata->MapCSet[]: %d\n", indx);
					ret = -10000;
					break;
				}
			}
			break;
		}
		case DMAPDATAMUISCTRACK:	//byte
		{
			ret = ((byte)DMaps[ri->dmapsref].tmusictrack) * 10000; break;
		}
		case DMAPDATASUBSCRA:
		{
			ret = ((byte)DMaps[ri->dmapsref].active_subscreen) * 10000; break;
		}
		case DMAPDATASUBSCRP:
		{
			ret = ((byte)DMaps[ri->dmapsref].passive_subscreen) * 10000; break;
		}
		case DMAPDATASUBSCRO:
		{
			ret = ((byte)DMaps[ri->dmapsref].overlay_subscreen) * 10000; break;
		}
		case DMAPDATADISABLEDITEMS:	 //byte[MAXITEMS]
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if ( indx < 0 || indx > (MAXITEMS-1) ) 
			{
				Z_scripterrlog("Invalid index supplied to dmapdata->Grid[]: %d\n", indx);
				ret = -10000;
				break;
			}
			else
			{
				ret = ((byte)DMaps[ri->dmapsref].disableditems[indx]) * 10000; break;
			}
		}
		case DMAPDATAFLAGARR:	 //int32_t
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if ( ((unsigned)indx) > 31 )
			{
				Z_scripterrlog("Invalid index supplied to dmapdata->Flags[]: %d\n", indx);
				ret = -10000;
				break;
			}
			ret = ((DMaps[ri->dmapsref].flags&(1<<indx)) ? 10000:0);
			break;
		}
		case DMAPDATAFLAGS:	 //int32_t
		{
			ret = (DMaps[ri->dmapsref].flags) * 10000; break;
		}
		case DMAPDATAMIRRDMAP:
		{
			ret = (DMaps[ri->dmapsref].mirrorDMap) * 10000; break;
		}
		case DMAPDATALOOPSTART:
		{
			ret = (DMaps[ri->dmapsref].tmusic_loop_start); break;
		}
		case DMAPDATALOOPEND:
		{
			ret = (DMaps[ri->dmapsref].tmusic_loop_end); break;
		}
		case DMAPDATAXFADEIN:
		{
			ret = (DMaps[ri->dmapsref].tmusic_xfade_in * 10000); break;
		}
		case DMAPDATAXFADEOUT:
		{
			ret = (DMaps[ri->dmapsref].tmusic_xfade_out * 10000); break;
		}
		case DMAPDATAINTROSTRINGID:
		{
			ret = (DMaps[ri->dmapsref].intro_string_id * 10000); break;
		}
		case MUSICUPDATECOND:
		{
			ret = ((byte)FFCore.music_update_cond) * 10000; break;
		}
		case MUSICUPDATEFLAGS:
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if (indx < 0 || indx > 2)
			{
				Z_scripterrlog("Invalid Index passed to Audio->MusicRefreshFlags[]: %d\n", indx);
			}
			ret = ((FFCore.music_update_flags >> indx) & 1) ? 10000 : 0; break;
		}
		case DMAPDATAASUBSCRIPT:	//word
		{
			ret = (DMaps[ri->dmapsref].active_sub_script) * 10000; break;
		}
		case DMAPDATAMAPSCRIPT:	//byte
		{
			ret = (DMaps[ri->dmapsref].onmap_script) * 10000; break;
		}
		case DMAPDATAPSUBSCRIPT:	//word
		{
			ret = (DMaps[ri->dmapsref].passive_sub_script) * 10000; break;
		}
		case DMAPDATASUBINITD:	//byte[8] --array
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if ( indx < 0 || indx > 7 ) 
			{
				Z_scripterrlog("Invalid index supplied to dmapdata->SubInitD[]: %d\n", indx);
				ret = -10000;
				break;
			}
			else
			{
				ret = DMaps[ri->dmapsref].sub_initD[indx]; break;
			}
		}
		
		case DMAPDATAMAPINITD:	//byte[8] --array
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if ( indx < 0 || indx > 7 ) 
			{
				Z_scripterrlog("Invalid index supplied to dmapdata->MapInitD[]: %d\n", indx);
				ret = -10000;
				break;
			}
			else
			{
				ret = DMaps[ri->dmapsref].onmap_initD[indx]; break;
			}
		}
		
		case DMAPDATACHARTED:
		{
			int32_t scr = ri->d[rINDEX] / 10000;
			ret = -10000;
			if(ri->dmapsref >= MAXDMAPS)
			{
				Z_scripterrlog("Invalid DMap reference used for dmapdata->Charted[]: %d\n", ri->dmapsref);
			}
			// else if((DMaps[get_currdmap()].type&dmfTYPE) == dmOVERW)
			// {
				// Z_scripterrlog("dmapdata->Charted[] cannot presently be used on Overworld-type dmaps\n");
			// }
			else if(((unsigned)(scr)) > 127)
			{
				Z_scripterrlog("Invalid index supplied to dmapdata->Charted[]: %d\n", scr);
			}
			else 
			{
				int32_t col = (scr&15)-(DMaps[ri->dmapsref].type==dmOVERW ? 0 : DMaps[ri->dmapsref].xoff);
				if((DMaps[ri->dmapsref].type&dmfTYPE)!=dmOVERW ? (((unsigned)col) > 7) : (((unsigned)col) > 15))
					break; //Out-of-bounds; don't attempt read!
				int32_t di = (ri->dmapsref << 7) + (scr & 0x7F);
				ret = 10000 * game->bmaps[di];
			}
			break;
		}
		//case DMAPDATAGRAVITY:	 //unimplemented
		//case DMAPDATAJUMPLAYER:	 //unimplemented
			
		///----------------------------------------------------------------------------------------------------//
		//messagedata msgd-> variables
		case MESSAGEDATANEXT: //W
		{
			int32_t ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Next") != SH::_NoError)
			{
				ret = -10000; break;
			}
			else 
			{
				ret = ((int32_t)MsgStrings[ID].nextstring) * 10000;
				break;
			}
		}	

		case MESSAGEDATATILE: //W
		{
			int32_t ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Tile") != SH::_NoError)
				ret = -10000;
			else 
				ret = ((int32_t)MsgStrings[ID].tile) * 10000;
			break;
		}	

		case MESSAGEDATACSET: //b
		{
			int32_t ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->CSet") != SH::_NoError)
				ret = -10000;
			else 
				ret = ((int32_t)MsgStrings[ID].cset) * 10000;
			break;
		}	
		case MESSAGEDATATRANS: //BOOL
		{
			int32_t ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Transparent") != SH::_NoError)
				ret = -10000;
			else 
				ret = ((MsgStrings[ID].trans)?10000:0);
			break;
		}	
		case MESSAGEDATAFONT: //B
		{
			int32_t ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Font") != SH::_NoError)
				ret = -10000;
			else 
				ret = (int32_t)MsgStrings[ID].font * 10000;
			break;
		}	
		case MESSAGEDATAX: //SHORT
		{
			int32_t ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->X") != SH::_NoError)
				ret = -10000;
			else 
				ret = ((int32_t)MsgStrings[ID].x) * 10000;
			break;
		}	
		case MESSAGEDATAY: //SHORT
		{
			int32_t ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Y") != SH::_NoError)
				ret = -10000;
			else 
				ret = ((int32_t)MsgStrings[ID].y) * 10000;
			break;
		}	
		case MESSAGEDATAW: //UNSIGNED SHORT
		{
			int32_t ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Width") != SH::_NoError)
				ret = -10000;
			else 
				ret = ((int32_t)MsgStrings[ID].w) * 10000;
			break;
		}	
		case MESSAGEDATAH: //UNSIGNED SHORT
		{
			int32_t ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Height") != SH::_NoError)
				ret = -10000;
			else 
				ret = ((int32_t)MsgStrings[ID].h) * 10000;
			break;
		}	
		case MESSAGEDATASFX: //BYTE
		{
			int32_t ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Sound") != SH::_NoError)
				ret = -10000;
			else 
				ret = ((int32_t)MsgStrings[ID].sfx) * 10000;
			break;
		}	
		case MESSAGEDATALISTPOS: //WORD
		{
			int32_t ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->ListPosition") != SH::_NoError)
				ret = -10000;
			else 
				ret = ((int32_t)MsgStrings[ID].listpos) * 10000;
			break;
		}	
		case MESSAGEDATAVSPACE: //BYTE
		{
			int32_t ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->VSpace") != SH::_NoError)
				ret = -10000;
			else 
				ret = ((int32_t)MsgStrings[ID].vspace) * 10000;
			break;
		}	
		case MESSAGEDATAHSPACE: //BYTE
		{
			int32_t ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->HSpace") != SH::_NoError)
				ret = -10000;
			else 
				ret = ((int32_t)MsgStrings[ID].hspace) * 10000;
			break;
		}	
		case MESSAGEDATAFLAGS: //BYTE
		{
			int32_t ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Flags") != SH::_NoError)
				ret = -10000;
			else 
				ret = ((int32_t)MsgStrings[ID].stringflags) * 10000;
			break;
		}
		case MESSAGEDATAMARGINS: //BYTE, 4
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if ( indx < 0 || indx > 3 ) 
			{
				Z_scripterrlog("Invalid index supplied to messagedata->Margins[]: %d\n", indx);
				ret = -10000;
				break;
			}
			int32_t ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->Margins[]") != SH::_NoError)
				ret = -10000;
			else
				ret = ((int32_t)MsgStrings[ID].margins[indx]) * 10000;
			break;
		}
		case MESSAGEDATAPORTTILE: //INT
		{
			int32_t ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->PortraitTile") != SH::_NoError)
				ret = -10000;
			else
				ret = ((int32_t)MsgStrings[ID].portrait_tile) * 10000;
			break;
		}
		case MESSAGEDATAPORTCSET: //BYTE
		{
			int32_t ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->PortraitCSet") != SH::_NoError)
				ret = -10000;
			else
				ret = ((int32_t)MsgStrings[ID].portrait_cset) * 10000;
			break;
		}
		case MESSAGEDATAPORTX: //BYTE
		{
			int32_t ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->PortraitX") != SH::_NoError)
				ret = -10000;
			else
				ret = ((int32_t)MsgStrings[ID].portrait_x) * 10000;
			break;
		}
		case MESSAGEDATAPORTY: //BYTE
		{
			int32_t ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->PortraitY") != SH::_NoError)
				ret = -10000;
			else
				ret = ((int32_t)MsgStrings[ID].portrait_y) * 10000;
			break;
		}
		case MESSAGEDATAPORTWID: //BYTE
		{
			int32_t ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->PortraitTileWidth") != SH::_NoError)
				ret = -10000;
			else
				ret = ((int32_t)MsgStrings[ID].portrait_tw) * 10000;
			break;
		}
		case MESSAGEDATAPORTHEI: //BYTE
		{
			int32_t ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->PortraitTileHeight") != SH::_NoError)
				ret = -10000;
			else
				ret = ((int32_t)MsgStrings[ID].portrait_th) * 10000;
			break;
		}
		case MESSAGEDATATEXTLEN: //BYTE
		{
			int32_t ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->PortraitTileHeight") != SH::_NoError)
				ret = -10000;
			else
				ret = int32_t(MsgStrings[ID].s.size()) * 10000;
			break;
		}
		case MESSAGEDATATEXTWID:
		{
			ret = do_msgwidth(ri->zmsgref, "messagedata->TextWidth")*10000;
			break;
		}
		case MESSAGEDATATEXTHEI:
		{
			ret = do_msgheight(ri->zmsgref, "messagedata->TextHeight")*10000;
			break;
		}
		case MESSAGEDATAFLAGSARR: //BOOL, 7
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			int32_t ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->Flags[]") != SH::_NoError)
				ret = -10000;
			else
			{
				switch(indx)
				{
					case 0:
						ret = (MsgStrings[ID].stringflags & STRINGFLAG_WRAP)!=0 ? 10000 : 0;
						break;
					case 1:
						ret = (MsgStrings[ID].stringflags & STRINGFLAG_CONT)!=0 ? 10000 : 0;
						break;
					case 2: //Not implemented
						ret = 0;//ret = (MsgStrings[ID].stringflags & STRINGFLAG_CENTER)!=0 ? 10000 : 0;
						break;
					case 3: //Not implemented
						ret = 0;//ret = (MsgStrings[ID].stringflags & STRINGFLAG_RIGHT)!=0 ? 10000 : 0;
						break;
					case 4:
						ret = (MsgStrings[ID].stringflags & STRINGFLAG_FULLTILE)!=0 ? 10000 : 0;
						break;
					case 5:
						ret = (MsgStrings[ID].stringflags & STRINGFLAG_TRANS_BG)!=0 ? 10000 : 0;
						break;
					case 6:
						ret = (MsgStrings[ID].stringflags & STRINGFLAG_TRANS_FG)!=0 ? 10000 : 0;
						break;
					default:
						Z_scripterrlog("Invalid index supplied to messagedata->Flags[]: %d\n", indx);
						ret = -10000;
				}
			}
			break;
		}

		///----------------------------------------------------------------------------------------------------//
		//combodata cd-> Getter variables
		#define	GET_COMBO_VAR_INT(member, str) \
		{ \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
				ret = -10000; \
			} \
			else \
			{ \
				ret = (combobuf[ri->combosref].member *10000); \
			} \
		} \

		#define	GET_COMBO_VAR_BYTE(member, str) \
		{ \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
				ret = -10000; \
			} \
			else \
			{ \
				ret = (combobuf[ri->combosref].member *10000); \
			} \
		} \
		
		#define	GET_COMBO_VAR_DWORD(member, str) \
		{ \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
				ret = -10000; \
			} \
			else \
			{ \
				ret = (combobuf[ri->combosref].member *10000); \
			} \
		} \
		
		#define GET_COMBO_VAR_INDEX(member, str, indexbound) \
		{ \
				int32_t indx = ri->d[rINDEX] / 10000; \
				if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
				{ \
					Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
					ret = -10000; \
				} \
				else if ( indx < 0 || indx >= indexbound ) \
				{ \
					Z_scripterrlog("Invalid Array Index passed to combodata->%s: %d\n", indx, str); \
					ret = -10000; \
				} \
				else \
				{ \
					ret = (combobuf[ri->combosref].member[indx] * 10000); \
				} \
		}

		#define GET_COMBO_BYTE_INDEX(member, str, indexbound) \
		{ \
				int32_t indx = ri->d[rINDEX] / 10000; \
				if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
				{ \
					Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
					ret = -10000; \
				} \
				else if ( indx < 0 || indx >= indexbound ) \
				{ \
					Z_scripterrlog("Invalid Array Index passed to combodata->%s: %d\n", indx, str); \
					ret = -10000; \
				} \
				else \
				{ \
					ret = (combobuf[ri->combosref].member[indx] * 100000); \
				} \
		}
		
		#define GET_COMBO_FLAG(member, str, indexbound) \
		{ \
			int32_t flag =  (value/10000);  \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
			} \
			else \
			{ \
				ret = (combobuf[ri->combosref].member&flag) ? 10000 : 0); \
			} \
		} \

		//comboclass macros

		#define	GET_COMBOCLASS_VAR_INT(member, str) \
		{ \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
				ret = -10000; \
			} \
			else \
			{ \
				ret = (combo_class_buf[combobuf[ri->combosref].type].member *10000); \
			} \
		} \

		#define	GET_COMBOCLASS_VAR_BYTE(member, str) \
		{ \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
				ret = -10000; \
			} \
			else \
			{ \
				ret = (combo_class_buf[combobuf[ri->combosref].type].member *10000); \
			} \
		} \
		
		#define	GET_COMBOCLASS_VAR_DWORD(member, str) \
		{ \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
				ret = -10000; \
			} \
			else \
			{ \
				ret = (combo_class_buf[combobuf[ri->combosref].type].member *10000); \
			} \
		} \
		
		#define GET_COMBOCLASS_VAR_INDEX(member, str, indexbound) \
		{ \
				int32_t indx = ri->d[rINDEX] / 10000; \
				if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
				{ \
					Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
					ret = -10000; \
				} \
				else if ( indx < 0 || indx > indexbound ) \
				{ \
					Z_scripterrlog("Invalid Array Index passed to combodata->%s: %d\n", indx, str); \
					ret = -10000; \
				} \
				else \
				{ \
					ret = (combo_class_buf[combobuf[ri->combosref].type].member[indx] * 10000); \
				} \
		}

		#define GET_COMBOCLASS_BYTE_INDEX(member, str, indexbound) \
		{ \
				int32_t indx = ri->d[rINDEX] / 10000; \
				if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
				{ \
					Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
					ret = -10000; \
				} \
				else if ( indx < 0 || indx > indexbound ) \
				{ \
					Z_scripterrlog("Invalid Array Index passed to combodata->%s: %d\n", indx, str); \
					ret = -10000; \
				} \
				else \
				{ \
					ret = (combo_class_buf[combobuf[ri->combosref].type].member[indx] * 100000); \
				} \
		}
		
		#define GET_COMBOCLASS_FLAG(member, str, indexbound) \
		{ \
			int32_t flag =  (value/10000);  \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
			} \
			else \
			{ \
				ret = (combo_class_buf[combobuf[ri->combosref].type].member&flag) ? 10000 : 0); \
			} \
		} \
		
		case COMBOXR:
		{
			//ri->combosref = id; //'this' pointer
			//ri->comboposref = i; //used for X(), Y(), Layer(), and so forth.
			if ( curScriptType == ScriptType::Combo )
			{
				int pos = combopos_ref_to_pos(ri->comboposref);
				ret = (( COMBOX(pos) ) * 10000); //comboscriptstack[i]
				//this may be wrong...may need a special new var for this, storing the exact combopos
				//i is the current script number
			}
			else
			{
				Z_scripterrlog("combodata->X() can only be called by combodata scripts, but you tried to use it from script type %s, script token %s\n", ScriptTypeToString(curScriptType), comboscriptmap[ri->combosref].scriptname.c_str() );
				ret = -10000;
			}
			break;
		}

		case COMBOYR:
		{
			if ( curScriptType == ScriptType::Combo )
			{
				int pos = combopos_ref_to_pos(ri->comboposref);
				ret = (( COMBOY(pos) ) * 10000); //comboscriptstack[i]
			}
			else
			{
				Z_scripterrlog("combodata->Y() can only be called by combodata scripts, but you tried to use it from script type %s, script token %s\n", ScriptTypeToString(curScriptType), comboscriptmap[ri->combosref].scriptname.c_str() );
				ret = -10000;
			}
			break;
		}
		case COMBOPOSR:
		{
			if ( curScriptType == ScriptType::Combo )
			{
				int pos = combopos_ref_to_pos(ri->comboposref);
				ret = pos * 10000; //comboscriptstack[i]
			}
			else
			{
				Z_scripterrlog("combodata->Pos() can only be called by combodata scripts, but you tried to use it from script type %s, script token %s\n", ScriptTypeToString(curScriptType), comboscriptmap[ri->combosref].scriptname.c_str() );
				ret = -10000;
			}
			break;
		}
		case COMBOLAYERR:
		{
			if ( curScriptType == ScriptType::Combo )
			{
				ret = (( ((ri->comboposref)/176) ) * 10000); //comboscriptstack[i]
			}
			else
			{
				Z_scripterrlog("combodata->Pos() can only be called by combodata scripts, but you tried to use it from script type %s, script token %s\n", ScriptTypeToString(curScriptType), comboscriptmap[ri->combosref].scriptname.c_str() );
				ret = -10000;
			}
			break;
		}
		
		//NEWCOMBO STRUCT
		case COMBODTILE:		GET_COMBO_VAR_DWORD(tile, "Tile"); break;					//word
		case COMBODOTILE:		GET_COMBO_VAR_DWORD(o_tile, "OriginalTile"); break;			//word
		case COMBODFRAME:		GET_COMBO_VAR_BYTE(cur_frame, "Frame"); break;				//char
		case COMBODACLK:		GET_COMBO_VAR_BYTE(aclk, "AClk"); break;				//char
		case COMBODASPEED:		GET_COMBO_VAR_BYTE(speed, "ASpeed"); break;					//char
		case COMBODFLIP:		GET_COMBO_VAR_BYTE(flip, "Flip"); break;					//char
		case COMBODWALK:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "Walk");
				ret = -10000;
			}
			else
			{
				ret = ((combobuf[ri->combosref].walk&0x0F) *10000);
			}
			break;
		}
		case COMBODEFFECT:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "Effect");
				ret = -10000;
			}
			else
			{
				ret = (((combobuf[ri->combosref].walk&0xF0)>>4) *10000);
			}
			break;
		}
		case COMBODTYPE:		GET_COMBO_VAR_BYTE(type, "Type"); break;					//char
		case COMBODCSET:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "CSet2");
				ret = -10000;
			}
			else
			{
				bool neg = combobuf[ri->combosref].csets&0x8;
				ret = ((combobuf[ri->combosref].csets&0x7) * (neg ? -10000 : 10000));
			}
			break;
		}
		case COMBODCSET2FLAGS:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "CSet2Flags");
			}
			else
			{
				ret = ((combobuf[ri->combosref].csets & 0xF0) >> 4) * 10000;
			}
			break;
		}
		case COMBODFOO:			break;						//W
		case COMBODATASCRIPT:			GET_COMBO_VAR_DWORD(script, "Script"); break;						//W
		case COMBODFRAMES:		GET_COMBO_VAR_BYTE(frames, "Frames"); break;					//C
		case COMBODNEXTD:		GET_COMBO_VAR_DWORD(speed, "NextData"); break;					//W
		case COMBODNEXTC:		GET_COMBO_VAR_BYTE(nextcombo, "NextCSet"); break;				//C
		case COMBODFLAG:		GET_COMBO_VAR_BYTE(nextcset, "Flag"); break;					//C
		case COMBODSKIPANIM:		GET_COMBO_VAR_BYTE(skipanim, "SkipAnim"); break;				//C
		case COMBODNEXTTIMER:		GET_COMBO_VAR_DWORD(nexttimer, "NextTimer"); break;				//W
		case COMBODAKIMANIMY:		GET_COMBO_VAR_BYTE(skipanimy, "SkipAnimY"); break;				//C
		case COMBODANIMFLAGS:		GET_COMBO_VAR_BYTE(animflags, "AnimFlags"); break;				//C
		case COMBODEXPANSION:		GET_COMBO_BYTE_INDEX(expansion, "Expansion[]", 6); break;				//C , 6 INDICES
		case COMBODATTRIBUTES:
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "Attributes[]");
				ret = -10000;
			}
			else if ( indx < 0 || indx > 4 )
			{
				Z_scripterrlog("Invalid Array Index passed to combodata->%s: %d\n", indx, "Attributes[]");
				ret = -10000;
			}
			else
			{
				ret = (combobuf[ri->combosref].attributes[indx]);
			}
		}
		break;
		//case COMBODATAINITD: 		GET_COMBO_VAR_INDEX(initd,	"InitD[]", 2); break;			//LONG, 4 INDICES, INDIVIDUAL VALUES
		case COMBODATAINITD:
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "InitD[]");
				ret = -10000;
			}
			else if ( ((unsigned)indx) > 8 )
			{ 
				Z_scripterrlog("Invalid Array Index passed to combodata->%s: %d\n", indx, "InitD[]"); 
				ret = -10000;
			} 
			else 
			{ 
				ret = (combobuf[ri->combosref].initd[indx] * (get_qr(qr_COMBODATA_INITD_MULT_TENK) ? 10000 : 1)); 
			} 
			break;
		}
		case COMBODATTRIBYTES: 		GET_COMBO_VAR_INDEX(attribytes,	"Attribytes[]", 8); break;			//LONG, 4 INDICES, INDIVIDUAL VALUES
		case COMBODATTRISHORTS: 		GET_COMBO_VAR_INDEX(attrishorts,	"Attrishorts[]", 8); break;			//LONG, 4 INDICES, INDIVIDUAL VALUES
		case COMBODUSRFLAGARR:
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if (ri->combosref < 0 || ri->combosref >(MAXCOMBOS - 1))
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", "Flags[]", (ri->combosref * 10000));
				ret = 0;
			}
			else if (((unsigned)indx) > 15)
			{
				Z_scripterrlog("Invalid Array Index passed to combodata->%s: %d\n", "Flags[]", indx);
				ret = 0;
			}
			else
			{
				ret = (combobuf[ri->combosref].usrflags & 1 << indx) ? 10000L : 0L;
			}
			break;
		}
		case COMBODGENFLAGARR:
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if (ri->combosref < 0 || ri->combosref >(MAXCOMBOS - 1))
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", "GenFlags[]", (ri->combosref * 10000));
				ret = 0;
			}
			else if (((unsigned)indx) > 1)
			{
				Z_scripterrlog("Invalid Array Index passed to combodata->%s: %d\n", "GenFlags[]", indx);
				ret = 0;
			}
			else
			{
				ret = (combobuf[ri->combosref].genflags & (1 << indx)) ? 10000L : 0L;
			}
			break;
		}
		case COMBODUSRFLAGS:		GET_COMBO_VAR_INT(usrflags, "UserFlags"); break;				//LONG
		case COMBODTRIGGERFLAGS:	GET_COMBO_VAR_INDEX(triggerflags, "TriggerFlags[]", 6);	break;			//LONG 3 INDICES AS FLAGSETS
		case COMBODTRIGGERFLAGS2:
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "TrigFlags[]");
			}
			else if ( unsigned(indx) >= 32*6 )
			{
				Z_scripterrlog("Invalid Array Index passed to combodata->%s: %d\n", indx, "TrigFlags[]");
			}
			else
			{
				ret = (combobuf[ri->combosref].triggerflags[indx/32] & (1<<indx%32)) ? 10000L : 0L;
			}
			break;
		}
		case COMBODTRIGGERBUTTON:
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "TriggerButton[]");
			}
			else if ( unsigned(indx) >= 8 )
			{
				Z_scripterrlog("Invalid Array Index passed to combodata->%s: %d\n", indx, "TriggerButton[]");
			}
			else
			{
				ret = (combobuf[ri->combosref].triggerbtn & (1<<indx)) ? 10000L : 0L;
			}
			break;
		}
		case COMBODTRIGGERITEM:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "TriggerItem");
			}
			else ret = (combobuf[ri->combosref].triggeritem) * 10000;
			break;
		}
		case COMBODTRIGGERTIMER:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "TriggerTimer");
			}
			else ret = (combobuf[ri->combosref].trigtimer) * 10000;
			break;
		}
		case COMBODTRIGGERSFX:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "TriggerSFX");
			}
			else ret = (combobuf[ri->combosref].trigsfx) * 10000;
			break;
		}
		case COMBODTRIGGERCHANGECMB:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "TriggerChange");
			}
			else ret = (combobuf[ri->combosref].trigchange) * 10000;
			break;
		}
		case COMBODTRIGGERPROX:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "TriggerProximity");
			}
			else ret = (combobuf[ri->combosref].trigprox) * 10000;
			break;
		}
		case COMBODTRIGGERLIGHTBEAM:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "TriggerLightBeam");
			}
			else ret = (combobuf[ri->combosref].triglbeam) * 10000;
			break;
		}
		case COMBODTRIGGERCTR:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "TriggerCounter");
			}
			else ret = (combobuf[ri->combosref].trigctr) * 10000;
			break;
		}
		case COMBODTRIGGERCTRAMNT:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "TriggerCtrAmount");
			}
			else ret = (combobuf[ri->combosref].trigctramnt) * 10000;
			break;
		}
		case COMBODTRIGGERCOOLDOWN:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TriggerCooldown: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].trigcooldown) * 10000;
			break;
		}
		case COMBODTRIGGERCOPYCAT:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TriggerCopycat: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].trigcopycat) * 10000;
			break;
		}
		case COMBODTRIGITEMPICKUP:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TriggerSpawnItemPickup: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].spawnip) * 10000;
			break;
		}
		case COMBODTRIGEXSTATE:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigExState: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].exstate) * 10000;
			break;
		}
		case COMBODTRIGEXDOORDIR:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigExDoorDir: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].exdoor_dir) * 10000;
			break;
		}
		case COMBODTRIGEXDOORIND:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigExDoorIndex: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].exdoor_ind) * 10000;
			break;
		}
		case COMBODTRIGSPAWNENEMY:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigSpawnEnemy: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].spawnenemy) * 10000;
			break;
		}
		case COMBODTRIGSPAWNITEM:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigSpawnItem: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].spawnitem) * 10000;
			break;
		}
		case COMBODTRIGCSETCHANGE:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigCSetChange: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].trigcschange) * 10000;
			break;
		}
		case COMBODTRIGLITEMS:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigLItems: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].trig_levelitems) * 10000;
			break;
		}
		case COMBODTRIGDMAPLVL:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigDMapLvl: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].trigdmlevel) * 10000;
			break;
		}
		case COMBODTRIGTINTR:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigTintR: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].trigtint[0]) * 10000;
			break;
		}
		case COMBODTRIGTINTG:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigTintG: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].trigtint[1]) * 10000;
			break;
		}
		case COMBODTRIGTINTB:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigTintG: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].trigtint[2]) * 10000;
			break;
		}
		case COMBODTRIGLVLPAL:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigLvlPal: %d\n", (ri->combosref*10000));
			}
			else ret = 10000 * combobuf[ri->combosref].triglvlpalette;
			break;
		}
		case COMBODTRIGBOSSPAL:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigBossPal: %d\n", (ri->combosref*10000));
			}
			else ret = 10000 * combobuf[ri->combosref].trigbosspalette;
			break;
		}
		case COMBODTRIGQUAKETIME:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigQuakeTimer: %d\n", (ri->combosref*10000));
			}
			else ret = 10000 * combobuf[ri->combosref].trigquaketime;
			break;
		}
		case COMBODTRIGWAVYTIME:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigWavyTimer: %d\n", (ri->combosref*10000));
			}
			else ret = 10000 * combobuf[ri->combosref].trigwavytime;
			break;
		}
		case COMBODTRIGSWORDJINX:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigSwordJinx: %d\n", (ri->combosref*10000));
			}
			else ret = 10000 * combobuf[ri->combosref].trig_swjinxtime;
			break;
		}
		case COMBODTRIGITEMJINX:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigItemJinx: %d\n", (ri->combosref*10000));
			}
			else ret = 10000 * combobuf[ri->combosref].trig_itmjinxtime;
			break;
		}
		case COMBODTRIGSTUN:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigStun: %d\n", (ri->combosref*10000));
			}
			else ret = 10000 * combobuf[ri->combosref].trig_stuntime;
			break;
		}
		case COMBODTRIGBUNNY:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigBunny: %d\n", (ri->combosref*10000));
			}
			else ret = 10000 * combobuf[ri->combosref].trig_bunnytime;
			break;
		}
		case COMBODTRIGPUSHTIME:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigPushTime: %d\n", (ri->combosref*10000));
			}
			else ret = 10000 * combobuf[ri->combosref].trig_pushtime;
			break;
		}
		case COMBODLIFTGFXCOMBO:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftGFXCombo: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].liftcmb) * 10000;
			break;
		}
		case COMBODLIFTGFXCCSET:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftGFXCSet: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].liftcs) * 10000;
			break;
		}
		case COMBODLIFTUNDERCMB:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftUnderCombo: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].liftundercmb) * 10000;
			break;
		}
		case COMBODLIFTUNDERCS:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftUnderCSet: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].liftundercs) * 10000;
			break;
		}
		case COMBODLIFTDAMAGE:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftDamage: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].liftdmg) * 10000;
			break;
		}
		case COMBODLIFTLEVEL:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftLevel: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].liftlvl) * 10000;
			break;
		}
		case COMBODLIFTITEM:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftItem: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].liftitm) * 10000;
			break;
		}
		case COMBODLIFTFLAGS:
		{
			ret = -10000;
			int32_t indx = ri->d[rINDEX] / 10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftFlags[]: %d\n", (ri->combosref*10000));
				break;
			}
			if ( unsigned(indx) > 7 ) 
			{
				Z_scripterrlog("Invalid index supplied to combodata->LiftFlags[]: %d\n", indx);
				break;
			}
			ret = (combobuf[ri->combosref].liftflags & (1<<indx)) ? 10000 : 0;
			break;
		}
		case COMBODLIFTGFXTYPE:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftGFXType: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].liftgfx) * 10000;
			break;
		}
		case COMBODLIFTGFXSPRITE:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftGFXSprite: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].liftsprite) * 10000;
			break;
		}
		case COMBODLIFTSFX:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftSFX: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].liftsfx) * 10000;
			break;
		}
		case COMBODLIFTBREAKSPRITE:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftBreakSprite: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].liftbreaksprite) * 10000;
			break;
		}
		case COMBODLIFTBREAKSFX:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftBreakSFX: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].liftbreaksfx) * 10000;
			break;
		}
		case COMBODLIFTHEIGHT:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftHeight: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].lifthei) * 10000;
			break;
		}
		case COMBODLIFTTIME:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftTime: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].lifttime) * 10000;
			break;
		}
		case COMBODLIFTWEAPONITEM:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftWeaponItem: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].lift_parent_item) * 10000;
			break;
		}
		case COMBODTRIGGERLSTATE:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigLevelState: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].trig_lstate) * 10000;
			break;
		}
		case COMBODTRIGGERGSTATE:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigGlobalState: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].trig_gstate) * 10000;
			break;
		}
		case COMBODTRIGGERGROUP:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigGroup: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].trig_group) * 10000;
			break;
		}
		case COMBODTRIGGERGROUPVAL:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigGroupVal: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].trig_group_val) * 10000;
			break;
		}
		case COMBODTRIGGERGTIMER:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigGStateTimer: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].trig_statetime) * 10000;
			break;
		}
		case COMBODTRIGGERGENSCRIPT:
		{
			ret = -10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigGenScript: %d\n", (ri->combosref*10000));
			}
			else ret = (combobuf[ri->combosref].trig_genscr) * 10000;
			break;
		}
		
		case COMBODTRIGGERLEVEL:	GET_COMBO_VAR_INT(triggerlevel, "TriggerLevel"); break;				//LONG
		case COMBODATAID: 		ret = (ri->combosref*10000); break;
		//COMBOCLASS STRUCT
		//case COMBODNAME:		//CHAR[64], STRING
		case COMBODBLOCKNPC:		GET_COMBOCLASS_VAR_BYTE(block_enemies, "BlockNPC"); break;			//C
		case COMBODBLOCKHOLE:		GET_COMBOCLASS_VAR_BYTE(block_hole, "BlockHole"); break;			//C
		case COMBODBLOCKTRIG:		GET_COMBOCLASS_VAR_BYTE(block_trigger,	"BlockTrigger"); break; 		//C
		case COMBODBLOCKWEAPON:		GET_COMBOCLASS_BYTE_INDEX(block_weapon,	"BlockWeapon[]", 32); break;		//C, 32 INDICES
		case COMBODCONVXSPEED:		GET_COMBOCLASS_VAR_DWORD(conveyor_x_speed, "ConveyorSpeedX"); break;		//SHORT
		case COMBODCONVYSPEED:		GET_COMBOCLASS_VAR_DWORD(conveyor_y_speed, "ConveyorSpeedY"); break;		//SHORT
		case COMBODSPAWNNPC:		GET_COMBOCLASS_VAR_DWORD(create_enemy, "SpawnNPC"); break;			//W
		case COMBODSPAWNNPCWHEN:	GET_COMBOCLASS_VAR_BYTE(create_enemy_when, "SpawnNPCWhen"); break;		//C
		case COMBODSPAWNNPCCHANGE:	GET_COMBOCLASS_VAR_INT(create_enemy_change, "SpawnNPCChange"); break;		//LONG
		case COMBODDIRCHANGETYPE:	GET_COMBOCLASS_VAR_BYTE(directional_change_type, "DirChange"); break;		//C
		case COMBODDISTANCECHANGETILES:	GET_COMBOCLASS_VAR_INT(distance_change_tiles, "DistanceChangeTiles"); break; 	//LONG
		case COMBODDIVEITEM:		GET_COMBOCLASS_VAR_DWORD(dive_item, "DiveItem"); break;				//SHORT
		case COMBODDOCK:		GET_COMBOCLASS_VAR_BYTE(dock, "Dock"); break;					//C
		case COMBODFAIRY:		GET_COMBOCLASS_VAR_BYTE(fairy, "Fairy"); break;					//C
		case COMBODFFATTRCHANGE:	GET_COMBOCLASS_VAR_BYTE(ff_combo_attr_change, "FFCAttributeChange"); break;	//C
		case COMBODFOORDECOTILE:	GET_COMBOCLASS_VAR_INT(foot_decorations_tile, "DecorationTile"); break;		//LONG
		case COMBODFOORDECOTYPE:	GET_COMBOCLASS_VAR_BYTE(foot_decorations_type, "DecorationType"); break;	//C
		case COMBODHOOKSHOTPOINT:	GET_COMBOCLASS_VAR_BYTE(hookshot_grab_point, "Hookshot"); break;		//C
		case COMBODLADDERPASS:		GET_COMBOCLASS_VAR_BYTE(ladder_pass, "Ladder"); break;				//C
		case COMBODLOCKBLOCK:		GET_COMBOCLASS_VAR_BYTE(lock_block_type, "LockBlock"); break;			//C
		case COMBODLOCKBLOCKCHANGE:	GET_COMBOCLASS_VAR_INT(lock_block_change, "LockBlockChange"); break;		//LONG
		case COMBODMAGICMIRROR:		GET_COMBOCLASS_VAR_BYTE(magic_mirror_type, "Mirror"); break;			//C
		case COMBODMODHPAMOUNT:		GET_COMBOCLASS_VAR_DWORD(modify_hp_amount, "DamageAmount"); break;		//SHORT
		case COMBODMODHPDELAY:		GET_COMBOCLASS_VAR_BYTE(modify_hp_delay, "DamageDelay"); break;			//C
		case COMBODMODHPTYPE:		GET_COMBOCLASS_VAR_BYTE(modify_hp_type,	"DamageType"); break; 			//C
		case COMBODNMODMPAMOUNT:	GET_COMBOCLASS_VAR_DWORD(modify_mp_amount, "MagicAmount"); break;		//SHORT
		case COMBODMODMPDELAY:		GET_COMBOCLASS_VAR_BYTE(modify_mp_delay, "MagicDelay"); break;			//C
		case COMBODMODMPTYPE:		GET_COMBOCLASS_VAR_BYTE(modify_mp_type,	"MagicType");	break;			//C
		case COMBODNOPUSHBLOCK:		GET_COMBOCLASS_VAR_BYTE(no_push_blocks, "NoPushBlocks"); break;			//C
		case COMBODOVERHEAD:		GET_COMBOCLASS_VAR_BYTE(overhead, "Overhead"); break;				//C
		case COMBODPLACENPC:		GET_COMBOCLASS_VAR_BYTE(place_enemy, "PlaceNPC"); break;			//C
		case COMBODPUSHDIR:		GET_COMBOCLASS_VAR_BYTE(push_direction,	"PushDir"); break; 			//C
		case COMBODPUSHWAIT:		GET_COMBOCLASS_VAR_BYTE(push_wait, "PushDelay"); break;				//C
		case COMBODPUSHHEAVY:		GET_COMBOCLASS_VAR_BYTE(push_weight, "PushHeavy"); break;				//C
		case COMBODPUSHED:		GET_COMBOCLASS_VAR_BYTE(pushed, "Pushed"); break;				//C
		case COMBODRAFT:		GET_COMBOCLASS_VAR_BYTE(raft, "Raft"); break;					//C
		case COMBODRESETROOM:		GET_COMBOCLASS_VAR_BYTE(reset_room, "ResetRoom"); break;			//C
		case COMBODSAVEPOINTTYPE:	GET_COMBOCLASS_VAR_BYTE(save_point_type, "SavePoint"); break;			//C
		case COMBODSCREENFREEZETYPE:	GET_COMBOCLASS_VAR_BYTE(screen_freeze_type, "FreezeScreen"); break;		//C
		case COMBODSECRETCOMBO:		GET_COMBOCLASS_VAR_BYTE(secret_combo, "SecretCombo"); break;			//C
		case COMBODSINGULAR:		GET_COMBOCLASS_VAR_BYTE(singular, "Singular"); break;				//C
		case COMBODSLOWWALK:		GET_COMBOCLASS_VAR_BYTE(slow_movement, "SlowWalk"); break;			//C
		case COMBODSTATUETYPE:		GET_COMBOCLASS_VAR_BYTE(statue_type, "Statue"); break;				//C
		case COMBODSTEPTYPE:		GET_COMBOCLASS_VAR_BYTE(step_type, "Step"); break;				//C
		case COMBODSTEPCHANGEINTO:	GET_COMBOCLASS_VAR_INT(step_change_to, "StepChange"); break;			//LONG
		case COMBODSTRIKEWEAPONS:	GET_COMBOCLASS_BYTE_INDEX(strike_weapons, "Strike[]", 32); break;			//BYTE, 32 INDICES. 
		case COMBODSTRIKEREMNANTS:	GET_COMBOCLASS_VAR_INT(strike_remnants,	"StrikeRemnants"); break;		//LONG
		case COMBODSTRIKEREMNANTSTYPE:	GET_COMBOCLASS_VAR_BYTE(strike_remnants_type, "StrikeRemnantsType"); break;	//C
		case COMBODSTRIKECHANGE:	GET_COMBOCLASS_VAR_INT(strike_change, "StrikeChange"); break;			//LONG
		case COMBODSTRIKEITEM:		GET_COMBOCLASS_VAR_DWORD(strike_item, "StrikeItem"); break;			//SHORT
		case COMBODTOUCHITEM:		GET_COMBOCLASS_VAR_DWORD(touch_item, "TouchItem"); break;			//SHORT
		case COMBODTOUCHSTAIRS:		GET_COMBOCLASS_VAR_BYTE(touch_stairs, "TouchStairs"); break;			//C
		case COMBODTRIGGERTYPE:		GET_COMBOCLASS_VAR_BYTE(trigger_type, "TriggerType"); break;			//C
		case COMBODTRIGGERSENS:		GET_COMBOCLASS_VAR_BYTE(trigger_sensitive, "TriggerSensitivity"); break;	//C
		case COMBODWARPTYPE:		GET_COMBOCLASS_VAR_BYTE(warp_type, "Warp"); break;				//C
		case COMBODWARPSENS:		GET_COMBOCLASS_VAR_BYTE(warp_sensitive,	"WarpSensitivity"); break; 		//C
		case COMBODWARPDIRECT:		GET_COMBOCLASS_VAR_BYTE(warp_direct, "WarpDirect"); break;			//C
		case COMBODWARPLOCATION:	GET_COMBOCLASS_VAR_BYTE(warp_location, "WarpLocation"); break;			//C
		case COMBODWATER:		GET_COMBOCLASS_VAR_BYTE(water, "Liquid"); break;					//C
		case COMBODWHISTLE:		GET_COMBOCLASS_VAR_BYTE(whistle, "Whistle"); break;				//C
		case COMBODWINGAME:		GET_COMBOCLASS_VAR_BYTE(win_game, "WinGame"); break; 				//C
		case COMBODBLOCKWPNLEVEL:	GET_COMBOCLASS_VAR_BYTE(block_weapon_lvl, "BlockWeaponLevel"); break;		//C


		
		///----------------------------------------------------------------------------------------------------//
		//npcdata nd-> variables
			
		//npcdata nd->member variable
		#define	GET_NPCDATA_VAR_INT32(member, str) \
		{ \
			if( (unsigned) ri->npcdataref > (MAXNPCS-1) ) \
			{ \
				Z_scripterrlog("Invalid NPC ID passed to npcdata->%s: %d\n", str, (ri->npcdataref*10000)); \
				ret = -10000; \
			} \
			else \
			{ \
				ret = (guysbuf[ri->npcdataref].member *10000); \
			} \
		} \

		#define	GET_NPCDATA_VAR_BYTE(member, str) \
		{ \
			if( (unsigned) ri->npcdataref > (MAXNPCS-1) ) \
			{ \
				Z_scripterrlog("Invalid NPC ID passed to npcdata->%s: %d\n", str, (ri->npcdataref*10000)); \
				ret = -10000; \
			} \
			else \
			{ \
				ret = (guysbuf[ri->npcdataref].member *10000); \
			} \
		} \
		
		#define	GET_NPCDATA_VAR_INT16(member, str) \
		{ \
			if( (unsigned) ri->npcdataref > (MAXNPCS-1) ) \
			{ \
				Z_scripterrlog("Invalid NPC ID passed to npcdata->%s: %d\n", str, (ri->npcdataref*10000)); \
				ret = -10000; \
			} \
			else \
			{ \
				ret = (guysbuf[ri->npcdataref].member *10000); \
			} \
		} \
		
		#define GET_NPCDATA_VAR_INDEX(member, str, indexbound) \
		{ \
				int32_t indx = ri->d[rINDEX] / 10000; \
				if( (unsigned) ri->npcdataref > (MAXNPCS-1) ) \
				{ \
					Z_scripterrlog("Invalid NPC ID passed to npcdata->%s: %d\n", str, (ri->npcdataref*10000)); \
					ret = -10000; \
				} \
				else if ( (unsigned)indx > indexbound ) \
				{ \
					Z_scripterrlog("Invalid Array Index passed to npcdata->%s: %d\n", str, indx); \
					ret = -10000; \
				} \
				else \
				{ \
					ret = (guysbuf[ri->npcdataref].member[indx] * 10000); \
				} \
		}

		#define GET_NPCDATA_BYTE_INDEX(member, str, indexbound) \
		{ \
				int32_t indx = ri->d[rINDEX] / 10000; \
				if( (unsigned) ri->npcdataref > (MAXNPCS-1) ) \
				{ \
					Z_scripterrlog("Invalid NPC ID passed to npcdata->%s: %d\n", str, (ri->npcdataref*10000)); \
					ret = -10000; \
				} \
				else if ( (unsigned)indx > indexbound ) \
				{ \
					Z_scripterrlog("Invalid Array Index passed to npcdata->%s: %d\n", str, indx); \
					ret = -10000; \
				} \
				else \
				{ \
					ret = (guysbuf[ri->npcdataref].member[indx] * 100000); \
				} \
		}
		
		#define GET_NPCDATA_FLAG(member, str, indexbound) \
		{ \
			int32_t flag =  (value/10000);  \
			if( (unsigned) ri->npcdataref > (MAXNPCS-1) ) \
			{ \
				Z_scripterrlog("Invalid NPC ID passed to npcdata->%s: %d\n", str, (ri->npcdataref*10000)); \
			} \
			else \
			{ \
				ret = (guysbuf[ID].member&flag) ? 10000 : 0); \
			} \
		} \
		
		case NPCDATATILE: GET_NPCDATA_VAR_BYTE(tile, "Tile"); break;
		case NPCDATAWIDTH: GET_NPCDATA_VAR_BYTE(width, "Width"); break;
		case NPCDATAHEIGHT: GET_NPCDATA_VAR_BYTE(height, "Height"); break;
		case NPCDATAFLAGS: GET_NPCDATA_VAR_INT16(flags, "Flags"); break; //16 b its
		case NPCDATAFLAGS2: GET_NPCDATA_VAR_INT16(flags2, "Flags2"); break; //16 bits
		case NPCDATASTILE: GET_NPCDATA_VAR_BYTE(s_tile, "STile"); break;
		case NPCDATASWIDTH: GET_NPCDATA_VAR_BYTE(s_width, "SWidth"); break;
		case NPCDATASHEIGHT: GET_NPCDATA_VAR_BYTE(s_height, "SHeight"); break;
		case NPCDATAETILE: GET_NPCDATA_VAR_INT32(e_tile, "ExTile"); break;
		case NPCDATAEWIDTH: GET_NPCDATA_VAR_BYTE(e_width, "ExWidth"); break;
		case NPCDATAEHEIGHT: GET_NPCDATA_VAR_BYTE(e_height, "ExHeight"); break;
		case NPCDATAHP: GET_NPCDATA_VAR_INT16(hp, "HP"); break;
		case NPCDATAFAMILY: GET_NPCDATA_VAR_INT16(family, "Family"); break;
		case NPCDATACSET: GET_NPCDATA_VAR_INT16(cset, "CSet"); break;
		case NPCDATAANIM: GET_NPCDATA_VAR_INT16(anim, "Anim"); break;
		case NPCDATAEANIM: GET_NPCDATA_VAR_INT16(e_anim, "ExAnim"); break;
		case NPCDATAFRAMERATE: GET_NPCDATA_VAR_INT16(frate, "Framerate"); break;
		case NPCDATAEFRAMERATE: GET_NPCDATA_VAR_INT16(e_frate, "ExFramerate"); break;
		case NPCDATATOUCHDAMAGE: GET_NPCDATA_VAR_INT16(dp, "TouchDamage"); break;
		case NPCDATAWEAPONDAMAGE: GET_NPCDATA_VAR_INT16(wdp, "WeaponDamage"); break;
		case NPCDATAWEAPON: GET_NPCDATA_VAR_INT16(weapon, "Weapon"); break;
		case NPCDATARANDOM: GET_NPCDATA_VAR_INT16(rate, "Random"); break;
		case NPCDATAHALT: GET_NPCDATA_VAR_INT16(hrate, "Haltrate"); break;
		case NPCDATASTEP: GET_NPCDATA_VAR_INT16(step, "Step"); break;
		case NPCDATAHOMING: GET_NPCDATA_VAR_INT16(homing, "Homing"); break;
		case NPCDATAHUNGER: GET_NPCDATA_VAR_INT16(grumble, "Hunger"); break;
		case NPCDATADROPSET: GET_NPCDATA_VAR_INT16(item_set, "Dropset"); break;
		case NPCDATABGSFX: GET_NPCDATA_VAR_INT16(bgsfx, "BGSFX"); break;
		case NPCDATADEATHSFX: GET_NPCDATA_VAR_BYTE(deadsfx, "DeathSFX"); break;
		case NPCDATAHITSFX: GET_NPCDATA_VAR_BYTE(hitsfx, "HitSFX"); break;
		case NPCDATAXOFS: GET_NPCDATA_VAR_INT32(xofs, "DrawXOffset"); break;
		case NPCDATAYOFS: GET_NPCDATA_VAR_INT32(yofs, "DrawYOffset"); break;
		case NPCDATAZOFS: GET_NPCDATA_VAR_INT32(zofs, "DrawZOffset"); break;
		case NPCDATAHXOFS: GET_NPCDATA_VAR_INT32(hxofs, "HitXOffset"); break;
		case NPCDATAHYOFS: GET_NPCDATA_VAR_INT32(hyofs, "HitYOffset"); break;
		case NPCDATAHITWIDTH: GET_NPCDATA_VAR_INT32(hxsz, "HitWidth"); break;
		case NPCDATAHITHEIGHT: GET_NPCDATA_VAR_INT32(hysz, "HitHeight"); break;
		case NPCDATAHITZ: GET_NPCDATA_VAR_INT32(hzsz, "HitZHeight"); break;
		case NPCDATASCRIPT: GET_NPCDATA_VAR_INT32(script, "Script"); break;
		case NPCDATATILEWIDTH: GET_NPCDATA_VAR_INT32(txsz, "TileWidth"); break;
		case NPCDATATILEHEIGHT: GET_NPCDATA_VAR_INT32(tysz, "TileHeight"); break;
		case NPCDATAWPNSPRITE: GET_NPCDATA_VAR_INT32(wpnsprite, "WeaponSprite"); break;
		case NPCDATAWEAPONSCRIPT: GET_NPCDATA_VAR_INT32(weaponscript, "WeaponScript"); break;
		case NPCDATADEFENSE: GET_NPCDATA_VAR_INDEX(defense, "Defense", 42); break;
		case NPCDATAINITD: GET_NPCDATA_VAR_INDEX(initD, "InitD", 8); break;
		case NPCDATAWEAPONINITD: GET_NPCDATA_VAR_INDEX(weap_initiald, "WeaponInitD", 8); break;
		case NPCDATASIZEFLAG: GET_NPCDATA_VAR_INT32(SIZEflags, "SizeFlags"); break;

		case NPCDATAFROZENTILE: GET_NPCDATA_VAR_INT32(frozentile, "FrozenTile"); break;
		case NPCDATAFROZENCSET: GET_NPCDATA_VAR_INT32(frozencset, "FrozenCSet"); break;


		case NPCDATAATTRIBUTE: 
		{
			int32_t indx = ri->d[rINDEX] / 10000; 
			if(ri->npcdataref < 0 || ri->npcdataref > (MAXNPCS-1) ) 
			{
				Z_scripterrlog("Invalid Sprite ID passed to npcdata->Attributes[]: %d\n", (ri->npcdataref*10000)); 
				ret = -10000;
			}
			else if ( indx < 0 || indx > MAX_NPC_ATRIBUTES )
			{ 
				Z_scripterrlog("Invalid Array Index passed to npcdata->Attributes[]: %d\n", (ri->npcdataref*10000)); 
				ret = -10000; 
			} 
			else 
			{ 
				switch(indx)
				{
					case 0: ret = (guysbuf[ri->npcdataref].misc1 * 10000); break;
					case 1: ret = (guysbuf[ri->npcdataref].misc2 * 10000); break;
					case 2: ret = (guysbuf[ri->npcdataref].misc3 * 10000); break;
					case 3: ret = (guysbuf[ri->npcdataref].misc4 * 10000); break;
					case 4: ret = (guysbuf[ri->npcdataref].misc5 * 10000); break;
					case 5: ret = (guysbuf[ri->npcdataref].misc6 * 10000); break;
					case 6: ret = (guysbuf[ri->npcdataref].misc7 * 10000); break;
					case 7: ret = (guysbuf[ri->npcdataref].misc8 * 10000); break;
					case 8: ret = (guysbuf[ri->npcdataref].misc9 * 10000); break;
					case 9: ret = (guysbuf[ri->npcdataref].misc10 * 10000); break;
					case 10: ret = (guysbuf[ri->npcdataref].misc11 * 10000); break;
					case 11: ret = (guysbuf[ri->npcdataref].misc12 * 10000); break;
					case 12: ret = (guysbuf[ri->npcdataref].misc13 * 10000); break;
					case 13: ret = (guysbuf[ri->npcdataref].misc14 * 10000); break;
					case 14: ret = (guysbuf[ri->npcdataref].misc15 * 10000); break;
					case 15: ret = (guysbuf[ri->npcdataref].misc16 * 10000); break;
					case 16: ret = (guysbuf[ri->npcdataref].misc17 * 10000); break;
					case 17: ret = (guysbuf[ri->npcdataref].misc18* 10000); break;
					case 18: ret = (guysbuf[ri->npcdataref].misc19 * 10000); break;
					case 19: ret = (guysbuf[ri->npcdataref].misc20 * 10000); break;
					case 20: ret = (guysbuf[ri->npcdataref].misc21 * 10000); break;
					case 21: ret = (guysbuf[ri->npcdataref].misc22 * 10000); break;
					case 22: ret = (guysbuf[ri->npcdataref].misc23 * 10000); break;
					case 23: ret = (guysbuf[ri->npcdataref].misc24 * 10000); break;
					case 24: ret = (guysbuf[ri->npcdataref].misc25 * 10000); break;
					case 25: ret = (guysbuf[ri->npcdataref].misc26 * 10000); break;
					case 26: ret = (guysbuf[ri->npcdataref].misc27 * 10000); break;
					case 27: ret = (guysbuf[ri->npcdataref].misc28 * 10000); break;
					case 28: ret = (guysbuf[ri->npcdataref].misc29 * 10000); break;
					case 29: ret = (guysbuf[ri->npcdataref].misc30 * 10000); break;
					case 30: ret = (guysbuf[ri->npcdataref].misc31 * 10000); break;
					case 31: ret = (guysbuf[ri->npcdataref].misc32 * 10000); break;
					
					
					
					default: 
					{
						Z_scripterrlog("Invalid Array Index passed to npcdata->Attributes[]: %d\n", (ri->npcdataref*10000)); 
						ret = -10000;
						break;
					}
				}
					
			} 
			break;
		}

		case NPCDATABEHAVIOUR: 
		{
			if(ri->npcdataref < 0 || ri->npcdataref > (MAXNPCS-1) ) 
			{
				ret = -10000;
				break;
			}
			int32_t index = vbound(ri->d[rINDEX]/10000,0,4);
			switch(index)
			{
				case 0:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG1)?10000:0; break;
				case 1:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG2)?10000:0; break;
				case 2:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG3)?10000:0; break;
				case 3:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG4)?10000:0; break;
				case 4:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG5)?10000:0; break;
				case 5:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG6)?10000:0; break;
				case 6:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG7)?10000:0; break;
				case 7:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG8)?10000:0; break;
				case 8:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG9)?10000:0; break;
				case 9:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG10)?10000:0; break;
				case 10:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG11)?10000:0; break;
				case 11:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG12)?10000:0; break;
				case 12:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG13)?10000:0; break;
				case 13:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG14)?10000:0; break;
				case 14:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG15)?10000:0; break;
				case 15:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG16)?10000:0; break;
				
				
				default: 
					ret = 0; break;
			}
				
			break;
		}
		
		case NPCDATASHIELD:
		{
			int32_t indx = ri->d[rINDEX] / 10000; 
			if(ri->npcdataref < 0 || ri->npcdataref > (MAXNPCS-1) ) 
			{ 
				Z_scripterrlog("Invalid NPC ID passed to npcdata->Shield[]: %d\n", (ri->npcdataref*10000)); 
				ret = -10000; 
				break;
			} 
			else 
			{ 
				switch(indx)
				{
					case 0:
					{
						ret = ((guysbuf[ri->npcdataref].flags&inv_front) ? 10000 : 0);
						break;
					}
					case 1:
					{
						ret = ((guysbuf[ri->npcdataref].flags&inv_left) ? 10000 : 0);
						break;
					}
					case 2:
					{
						ret = ((guysbuf[ri->npcdataref].flags&inv_right) ? 10000 : 0);
						break;
					}
					case 3:
					{
						ret = ((guysbuf[ri->npcdataref].flags&inv_back) ? 10000 : 0);
						break;
					}
					case 4:
					{
						ret = ((guysbuf[ri->npcdataref].flags&guy_bkshield) ? 10000 : 0);
						break;
					}
					default:
					{
						Z_scripterrlog("Invalid Array Index passed to npcdata->Shield[]: %d\n", indx); 
						ret = -10000; 
						break;
					}
				}
			} 
		}
		break;

		case NPCDSHADOWSPR:
		{
			if(ri->npcdataref < 0 || ri->npcdataref > (MAXNPCS-1) ) 
			{ 
				Z_scripterrlog("Invalid NPC ID passed to npcdata->ShadowSprite: %d\n", (ri->npcdataref*10000));
				ret = -10000; 
			} 
			else 
			{
				ret = guysbuf[ri->npcdataref].spr_shadow * 10000;
			} 
			break;
		}
		case NPCDSPAWNSPR:
		{
			if(ri->npcdataref < 0 || ri->npcdataref > (MAXNPCS-1) ) 
			{ 
				Z_scripterrlog("Invalid NPC ID passed to npcdata->SpawnSprite: %d\n", (ri->npcdataref*10000));
				ret = -10000; 
			} 
			else 
			{
				ret = guysbuf[ri->npcdataref].spr_spawn * 10000;
			} 
			break;
		}
		case NPCDDEATHSPR:
		{
			if(ri->npcdataref < 0 || ri->npcdataref > (MAXNPCS-1) ) 
			{ 
				Z_scripterrlog("Invalid NPC ID passed to npcdata->DeathSprite: %d\n", (ri->npcdataref*10000));
				ret = -10000; 
			} 
			else 
			{
				ret = guysbuf[ri->npcdataref].spr_death * 10000;
			} 
			break;
		}
		
		case NPCMATCHINITDLABEL: 	 //Same form as SetScreenD()
			//bool npcdata->MatchInitDLabel("label", d)
		{
			
			if( (unsigned) ri->npcdataref > (MAXNPCS-1) ) \
			{ 
				Z_scripterrlog("Invalid NPC ID passed to npcdata->%s: %d\n", (ri->npcdataref*10000), "MatchInitDLabel()"); 
				ret = 0; 
				break;
			} 
			
			int32_t arrayptr = get_register(sarg1) / 10000;
			int32_t init_d_index = get_register(sarg2) / 10000;
			
			string name;
			ArrayH::getString(arrayptr, name, 256); // What's the limit on name length?
			
			bool match = (!( strcmp(name.c_str(), guysbuf[ri->npcdataref].initD_label[init_d_index] )));
			
			ret = ( match ? 10000 : 0 );
			break;
		}
		
		///----------------------------------------------------------------------------------------------------//
		//Dropset Variables

		case DROPSETITEMS:
		{
			if(ri->dropsetref < 0 || ri->dropsetref > MAXITEMDROPSETS)
			{
				Z_scripterrlog("Invalid dropset pointer %d\n", ri->dropsetref);
				ret = -10000;
				break;
			}
			int32_t indx = ri->d[rINDEX]/10000;
			if(indx < 0 || indx > 9)
			{
				Z_scripterrlog("Invalid index passed to dropdata->Items[]: %d\n", indx);
				ret = -10000;
			}
			else
			{
				ret = item_drop_sets[ri->dropsetref].item[indx] * 10000;
			}
			break;
		}
		case DROPSETCHANCES:
		{
			if(ri->dropsetref < 0 || ri->dropsetref > MAXITEMDROPSETS)
			{
				Z_scripterrlog("Invalid dropset pointer %d\n", ri->dropsetref);
				ret = -10000;
				break;
			}
			int32_t indx = ri->d[rINDEX]/10000;
			if(indx < 0 || indx > 9)
			{
				Z_scripterrlog("Invalid index passed to dropdata->Chances[]: %d\n", indx);
				ret = -10000;
			}
			else
			{
				ret = item_drop_sets[ri->dropsetref].chance[indx+1] * 10000; //+1 is because '0' is 'nothing''s chance
			}
			break;
		}
		case DROPSETNULLCHANCE:
		{
			if(ri->dropsetref < 0 || ri->dropsetref > MAXITEMDROPSETS)
			{
				Z_scripterrlog("Invalid dropset pointer %d\n", ri->dropsetref);
				ret = -10000;
				break;
			}
			ret = item_drop_sets[ri->dropsetref].chance[0] * 10000;
			break;
		}
		case DROPSETCHOOSE:
		{
			if(ri->dropsetref < 0 || ri->dropsetref > MAXITEMDROPSETS)
			{
				Z_scripterrlog("Invalid dropset pointer %d\n", ri->dropsetref);
				ret = -10000;
				break;
			}
			ret = select_dropitem(ri->dropsetref) * 10000;
			break;
		}
			
		///----------------------------------------------------------------------------------------------------//
		//Audio Variables

		case AUDIOVOLUME:
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			switch(indx)
			{
				
				case 0: //midi volume
				{
					ret = FFScript::do_getMIDI_volume() * 10000;
					break;
				}
				case 1: //digi volume
				{
					ret = FFScript::do_getDIGI_volume() * 10000;
					break;
				}
				case 2: //emh music volume
				{
					ret = FFScript::do_getMusic_volume() * 10000;
					break;
				}
				case 3: //sfx volume
				{
					ret = FFScript::do_getSFX_volume() * 10000;
					break;
				}
				default:
				{
					Z_scripterrlog("Attempted to access an invalid index of Audio->Volume[]", indx); 
					ret = -10000;
					break;
				}
			}
		}
		break;

		case AUDIOPAN:
		{
			ret = FFScript::do_getSFX_pan() * 10000;
			break;
		}

		///----------------------------------------------------------------------------------------------------//
		//Graphics->

		case NUMDRAWS:
			ret = script_drawing_commands.Count() * 10000;
			//ret = FFCore.numscriptdraws * 10000; // This isn't updated until end of frame, making it useless!
			break;

		case MAXDRAWS:
			ret = MAX_SCRIPT_DRAWING_COMMANDS * 10000;
			break;
		
		case ISBLANKTILE: ret = (FFCore.IsBlankTile(ri->d[rINDEX]/10000) * 10000); break;
		case IS8BITTILE: ret = (FFCore.Is8BitTile(ri->d[rINDEX] / 10000) * 10000); break;

		case BITMAPWIDTH:
		{
			if (auto bmp = user_bitmaps.check(ri->bitmapref, "->Width"); bmp && bmp->u_bmp)
			{
				ret = bmp->width * 10000;
			}
			else
			{
				ret = -10000;
			}
			break;
		}

		case BITMAPHEIGHT:
		{
			if (auto bmp = user_bitmaps.check(ri->bitmapref, "->Height"); bmp && bmp->u_bmp)
			{
				ret = bmp->height * 10000;
			}
			else
			{
				ret = -10000;
			}
			break;
		}
		///----------------------------------------------------------------------------------------------------//
		//File->
		case FILEPOS:
		{
			if(user_file* f = checkFile(ri->fileref, "Pos", true))
			{
				ret = ftell(f->file); //NOT *10000 -V
			}
			else ret = -10000L;
			break;
		}
		case FILEEOF:
		{
			if(user_file* f = checkFile(ri->fileref, "EOF", true))
			{
				ret = feof(f->file) ? 10000L : 0L; //Boolean
			}
			else ret = -10000L;
			break;
		}
		case FILEERR:
		{
			if(user_file* f = checkFile(ri->fileref, "Error", true))
			{
				ret = ferror(f->file) * 10000L;
			}
			else ret = -10000L;
			break;
		}
		
		///----------------------------------------------------------------------------------------------------//
		//Directory->
		case DIRECTORYSIZE:
		{
			if(user_dir* dr = checkDir(ri->directoryref, "Size()", true))
			{
				ret = dr->size() * 10000L;
			}
			else ret = -10000L;
			break;
		}
		
		///----------------------------------------------------------------------------------------------------//
		//Stack->
		case STACKSIZE:
		{
			if(user_stack* st = checkStack(ri->stackref, "Size", true))
			{
				ret = st->size(); //NOT *10000
			}
			else ret = -10000L;
			break;
		}
		case STACKFULL:
		{
			if(user_stack* st = checkStack(ri->stackref, "Full", true))
			{
				ret = st->full() ? 10000L : 0L;
			}
			else ret = -10000L;
			break;
		}
		
		///----------------------------------------------------------------------------------------------------//
		//Module->
		
		case MODULEGETINT:
		{
			int32_t section_pointer = ((ri->d[rINDEX])/10000);
			int32_t element_pointer = ((ri->d[rINDEX2])/10000);
			string sectionid;
			string elementid;
		
			ArrayH::getString(section_pointer, sectionid);
			ArrayH::getString(element_pointer, elementid);
			
			///set config file
			if(!fileexists((char*)moduledata.module_name))
			{
				Z_scripterrlog("I/O Error: No module definitions found when using Module->GetInt()\n");
				ret = -10000;
			}	
			else
			{
				zc_push_config();
				zc_config_file(moduledata.module_name);
				ret = zc_get_config_basic(sectionid.c_str(), elementid.c_str(), 0)*10000;
				//return config file to zc.cfg
				zc_pop_config();
			}
			break;
		}
		
		///----------------------------------------------------------------------------------------------------//
		//Misc./Internal
		case REFFFC:
			ret = ri->ffcref * 10000;
			break;
			
		case REFITEM:
			ret = ri->itemref;
			break;
			
		case REFITEMCLASS:
			ret = ri->idata;
			break;
			
		case REFLWPN:
			ret = ri->lwpn;
			break;
			
		case REFEWPN:
			ret = ri->ewpn;
			break;
			
		case REFNPC:
			ret = ri->guyref;
			break;
		
		case REFMAPDATA: ret = ri->mapsref; break;
		case REFSCREENDATA: ret = ri->screenref; break;
		case REFCOMBODATA: ret = ri->combosref; break;
		case REFSPRITEDATA: ret = ri->spritesref; break;
		case REFBITMAP: ret = ri->bitmapref; break;
		case REFNPCCLASS: ret = ri->npcdataref; break;
		
		
		case REFDMAPDATA: ret = ri->dmapsref; break;
		case REFSHOPDATA: ret = ri->shopsref; break;
		case REFMSGDATA: ret = ri->zmsgref; break;
		case REFUNTYPED: ret = ri->untypedref; break;
		
		case REFDROPS: ret = ri->dropsetref; break;
		case REFBOTTLETYPE: ret = ri->bottletyperef; break;
		case REFBOTTLESHOP: ret = ri->bottleshopref; break;
		case REFGENERICDATA: ret = ri->genericdataref; break;
		case REFPONDS: ret = ri->pondref; break;
		case REFWARPRINGS: ret = ri->warpringref; break;
		case REFDOORS: ret = ri->doorsref; break;
		case REFUICOLOURS: ret = ri->zcoloursref; break;
		case REFRGB: ret = ri->rgbref; break;
		case REFPALETTE: ret = ri->paletteref; break;
		case REFTUNES: ret = ri->tunesref; break;
		case REFPALCYCLE: ret = ri->palcycleref; break;
		case REFGAMEDATA: ret = ri->gamedataref; break;
		case REFCHEATS: ret = ri->cheatsref; break;
		case REFFILE: ret = ri->fileref; break;
		case REFDIRECTORY: ret = ri->directoryref; break;
		case REFSTACK: ret = ri->stackref; break;
		case REFSUBSCREEN: ret = ri->subdataref; break;
		case REFSUBSCREENPAGE: ret = ri->subpageref; break;
		case REFSUBSCREENWIDG: ret = ri->subwidgref; break;
		case REFRNG: ret = ri->rngref; break;
		case REFWEBSOCKET: ret = ri->websocketref; break;
		case CLASS_THISKEY: ret = ri->thiskey; break;
		case CLASS_THISKEY2: ret = ri->thiskey2; break;
		case REFPALDATA: ret = ri->paldataref; break;
		
			
		case SP:
			ret = ri->sp * 10000;
			break;
		case SP2:
			ret = ri->sp;
			break;
			
		case PC:
			ret = ri->pc;
			break;
		
		case SWITCHKEY:
			ret = ri->switchkey;
			break;
			
		case SCRIPTRAM:
		case GLOBALRAM:
			ret = ArrayH::getElement(ri->d[rINDEX] / 10000, ri->d[rINDEX2] / 10000);
			break;
			
		case SCRIPTRAMD:
		case GLOBALRAMD:
			ret = ArrayH::getElement(ri->d[rINDEX] / 10000, 0);
			break;
			
		case GDD://Doesn't work like this =(
			ret = game->global_d[ri->d[rINDEX] / 10000];
			break;
			
		///----------------------------------------------------------------------------------------------------//
		
		case PALDATACOLOR:
		{
			if (user_paldata* pd = checkPalData(ri->paldataref, "paldata->GetColor()"))
			{
				int32_t ind = ri->d[rINDEX] / 10000; // get_register(sarg1) / 10000;
				if (unsigned(ind) >= PALDATA_NUM_COLORS)
				{
					Z_scripterrlog("Invalid color index (%d) passed to paldata->GetColor(). Valid indices are 0-255.\n", ind);
					ret = -10000;
					break;
				}

				if (get_bit(pd->colors_used, ind))
				{
					RGB c = pd->colors[ind];
					
					ret = (c.r << 16) | (c.g << 8) | c.b;
				}
				else
				{
					//Z_scripterrlog("Color index (%d) returned an invalid color in paldata->GetColor().\n", ind);
					ret = -10000;
					break;
				}
			}
			break;
		}
		case PALDATAR:
			ret = FFCore.do_paldata_getrgb(0);
			break;
		case PALDATAG:
			ret = FFCore.do_paldata_getrgb(1);
			break;
		case PALDATAB:
			ret = FFCore.do_paldata_getrgb(2);
			break;

		///----------------------------------------------------------------------------------------------------//
		
		case GENDATARUNNING:
		{
			ret = 0;
			if(user_genscript* scr = checkGenericScr(ri->genericdataref, "Running"))
			{
				ret = scr->doscript() ? 10000L : 0L;
			}
			break;
		}
		case GENDATASIZE:
		{
			ret = 0;
			if(user_genscript* scr = checkGenericScr(ri->genericdataref, "DataSize"))
			{
				ret = scr->dataSize()*10000;
			}
			break;
		}
		case GENDATAEXITSTATE:
		{
			ret = 0;
			if(user_genscript* scr = checkGenericScr(ri->genericdataref, "ExitState"))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= GENSCR_NUMST)
				{
					Z_scripterrlog("Invalid index passed to genericdata->ExitState[]: %d\n", indx);
					break;
				}
				ret = (scr->exitState & (1<<indx)) ? 10000L : 0;
			}
			break;
		}
		case GENDATARELOADSTATE:
		{
			ret = 0;
			if(user_genscript* scr = checkGenericScr(ri->genericdataref, "ReloadState"))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= GENSCR_NUMST)
				{
					Z_scripterrlog("Invalid index passed to genericdata->ReloadState[]: %d\n", indx);
					break;
				}
				ret = (scr->reloadState & (1<<indx)) ? 10000L : 0;
			}
			break;
		}
		case GENDATAEVENTSTATE:
		{
			ret = 0;
			if(user_genscript* scr = checkGenericScr(ri->genericdataref, "EventListen"))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= GENSCR_NUMEVENT)
				{
					Z_scripterrlog("Invalid index passed to genericdata->EventListen[]: %d\n", indx);
					break;
				}
				ret = (scr->eventstate & (1<<indx)) ? 10000L : 0;
			}
			break;
		}
		case GENDATADATA:
		{
			ret = 0;
			if(user_genscript* scr = checkGenericScr(ri->genericdataref, "Data[]"))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= scr->dataSize())
				{
					Z_scripterrlog("Invalid index passed to genericdata->Data[]: %d\n", indx);
					break;
				}
				ret = scr->data[indx];
			}
			break;
		}
		case GENDATAINITD:
		{
			ret = 0;
			if(user_genscript* scr = checkGenericScr(ri->genericdataref, "InitD[]"))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= 8)
				{
					Z_scripterrlog("Invalid index passed to genericdata->InitD[]: %d\n", indx);
					break;
				}
				ret = scr->initd[indx];
			}
			break;
		}
		
		///----------------------------------------------------------------------------------------------------//
		
		case PORTALX:
		{
			ret = -10000;
			if(portal* p = checkPortal(ri->portalref, "X"))
				ret = p->x.getZLong();
			break;
		}
		case PORTALY:
		{
			ret = -10000;
			if(portal* p = checkPortal(ri->portalref, "Y"))
				ret = p->y.getZLong();
			break;
		}
		case PORTALDMAP:
		{
			ret = -10000;
			if(portal* p = checkPortal(ri->portalref, "DMap"))
				ret = p->destdmap*10000;
			break;
		}
		case PORTALSCREEN:
		{
			ret = -10000;
			if(portal* p = checkPortal(ri->portalref, "Screen"))
				ret = p->destscr*10000;
			break;
		}
		case PORTALACLK:
		{
			ret = -10000;
			if(portal* p = checkPortal(ri->portalref, "AClk"))
				ret = p->aclk*10000;
			break;
		}
		case PORTALAFRM:
		{
			ret = -10000;
			if(portal* p = checkPortal(ri->portalref, "AFrame"))
				ret = p->aframe*10000;
			break;
		}
		case PORTALOTILE:
		{
			ret = -10000;
			if(portal* p = checkPortal(ri->portalref, "OriginalTile"))
				ret = p->o_tile*10000;
			break;
		}
		case PORTALASPD:
		{
			ret = -10000;
			if(portal* p = checkPortal(ri->portalref, "ASpeed"))
				ret = p->aspd*10000;
			break;
		}
		case PORTALFRAMES:
		{
			ret = -10000;
			if(portal* p = checkPortal(ri->portalref, "Frames"))
				ret = p->frames*10000;
			break;
		}
		case PORTALSAVED:
		{
			ret = 0;
			if(portal* p = checkPortal(ri->portalref, "SavedPortal"))
				ret = p->saved_data;
			break;
		}
		case PORTALCLOSEDIS:
		{
			ret = 0;
			if(portal* p = checkPortal(ri->portalref, "CloseDisabled"))
				ret = p->prox_active ? 0 : 10000; //Inverted
			break;
		}
		case REFPORTAL:
		{
			ret = ri->portalref;
			break;
		}
		case REFSAVPORTAL:
		{
			ret = ri->saveportalref;
			break;
		}
		case PORTALWARPSFX:
		{
			ret = 0;
			if(portal* p = checkPortal(ri->portalref, "WarpSFX"))
				ret = p->wsfx ? 0 : 10000;
			break;
		}
		case PORTALWARPVFX:
		{
			ret = 0;
			if(portal* p = checkPortal(ri->portalref, "WarpEffect"))
				ret = p->weffect ? 0 : 10000;
			break;
		}
		case SAVEDPORTALX:
		{
			ret = -10000;
			if(savedportal* p = checkSavedPortal(ri->saveportalref, "X"))
				ret = p->x;
			break;
		}
		case SAVEDPORTALY:
		{
			ret = -10000;
			if(savedportal* p = checkSavedPortal(ri->saveportalref, "Y"))
				ret = p->y;
			break;
		}
		case SAVEDPORTALSRCDMAP:
		{
			ret = -10000;
			if(savedportal* p = checkSavedPortal(ri->saveportalref, "SrcDMap"))
				ret = p->srcdmap * 10000;
			break;
		}
		case SAVEDPORTALDESTDMAP:
		{
			ret = -10000;
			if(savedportal* p = checkSavedPortal(ri->saveportalref, "DestDMap"))
				ret = p->destdmap * 10000;
			break;
		}
		case SAVEDPORTALSRCSCREEN:
		{
			ret = -10000;
			if(savedportal* p = checkSavedPortal(ri->saveportalref, "SrcScreen"))
				ret = p->srcscr * 10000;
			break;
		}
		case SAVEDPORTALDSTSCREEN:
		{
			ret = -10000;
			if(savedportal* p = checkSavedPortal(ri->saveportalref, "DestScreen"))
				ret = p->destscr * 10000;
			break;
		}
		case SAVEDPORTALWARPSFX:
		{
			ret = -10000;
			if(savedportal* p = checkSavedPortal(ri->saveportalref, "WarpSFX"))
				ret = p->sfx * 10000;
			break;
		}
		case SAVEDPORTALWARPVFX:
		{
			ret = -10000;
			if(savedportal* p = checkSavedPortal(ri->saveportalref, "WarpEffect"))
				ret = p->warpfx * 10000;
			break;
		}
		case SAVEDPORTALSPRITE:
		{
			ret = -10000;
			if(savedportal* p = checkSavedPortal(ri->saveportalref, "Sprite"))
				ret = p->spr * 10000;
			break;
		}
		case SAVEDPORTALPORTAL:
		{
			ret = 0;
			if(savedportal* p = checkSavedPortal(ri->saveportalref, "Portal"))
				ret = getPortalFromSaved(p);
			break;
		}
		case PORTALCOUNT:
		{
			ret = portals.Count()*10000;
			break;
		}
		case SAVEDPORTALCOUNT:
		{
			ret = game->user_portals.size()*10000;
			break;
		}
		
		case GAMEASUBOPEN:
		{
			ret = subscreen_open ? 10000 : 0;
			break;
		}
		case GAMEASUBYOFF:
		{
			ret = active_sub_yoff*10000;
			break;
		}
		case GAMENUMASUB:
		{
			ret = subscreens_active.size()*10000;
			break;
		}
		case GAMENUMPSUB:
		{
			ret = subscreens_passive.size()*10000;
			break;
		}
		case GAMENUMOSUB:
		{
			ret = subscreens_overlay.size()*10000;
			break;
		}
		
		///----------------------------------------------------------------------------------------------------//
		
		case SUBDATACURPG:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "CurPage"))
				if(sub->sub_type == sstACTIVE)
					ret = 10000*sub->curpage;
			break;
		}
		case SUBDATANUMPG:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "NumPages"))
			{
				if(sub->sub_type == sstACTIVE)
					ret = 10000*sub->pages.size();
				else ret = 10000;
			}
			break;
		}
		case SUBDATAPAGES:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "Pages[]"))
			{
				size_t indx = ri->d[rINDEX]/10000;
				size_t sz = sub->sub_type == sstACTIVE ? sub->pages.size() : 1;
				if(indx >= sz)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreendata->Pages[]' of size '%d'\n", indx, sz);
				}
				else
				{
					auto [sb,ty,_pg,_ind] = from_subref(ri->subdataref);
					ret = get_subref(sb,ty,indx,0);
				}
			}
			break;
		}
		case SUBDATATYPE:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "Type"))
				ret = sub->sub_type*10000;
			break;
		}
		case SUBDATAFLAGS:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "Flags[]"))
			{
				size_t indx = ri->d[rINDEX]/10000;
				size_t sz = 0;
				switch(sub->sub_type)
				{
					case sstACTIVE:
						sz = 2;
						break;
					case sstPASSIVE:
						sz = 0;
						break;
					case sstOVERLAY:
						sz = 0;
						break;
				}
				if(indx >= sz)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreendata->Flags[]' of size '%d'\n", indx, sz);
				}
				else
					ret = (sub->flags & (1<<indx)) ? 10000 : 0;
			}
			break;
		}
		///---- ACTIVE SUBSCREENS ONLY
		case SUBDATACURSORPOS:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "CursorPos", sstACTIVE))
			{
				SubscrPage& pg = sub->cur_page();
				ret = pg.cursor_pos * 10000;
			}
			break;
		}
		case SUBDATASCRIPT:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "Script", sstACTIVE))
				ret = sub->script * 10000;
			break;
		}
		case SUBDATAINITD:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "InitD[]", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= 8)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreendata->InitD[8]'\n", indx);
				}
				else
					ret = sub->initd[indx];
			}
			break;
		}
		case SUBDATABTNLEFT:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "BtnPageLeft[]", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= 8)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreendata->BtnPageLeft[8]'\n", indx);
				}
				else
					ret = (sub->btn_left & (1<<indx)) ? 10000 : 0;
			}
			break;
		}
		case SUBDATABTNRIGHT:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "BtnPageRight[]", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= 8)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreendata->BtnPageRight[8]'\n", indx);
				}
				else
					ret = (sub->btn_right & (1<<indx)) ? 10000 : 0;
			}
			break;
		}
		case SUBDATATRANSLEFTTY:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "TransLeftType", sstACTIVE))
			{
				auto& trans = sub->trans_left;
				ret = trans.type * 10000;
			}
			break;
		}
		case SUBDATATRANSLEFTSFX:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "TransLeftSFX", sstACTIVE))
			{
				auto& trans = sub->trans_left;
				ret = trans.tr_sfx * 10000;
			}
			break;
		}
		case SUBDATATRANSLEFTFLAGS:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "TransLeftFlags[]", sstACTIVE))
			{
				auto& trans = sub->trans_left;
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_TRANS_NUMFLAGS)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreendata->TransLeftFlags[%d]'\n", indx, SUBSCR_TRANS_NUMFLAGS);
				}
				else
					ret = (trans.flags & (1<<indx)) ? 10000 : 0;
			}
			break;
		}
		case SUBDATATRANSLEFTARGS:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "TransLeftArgs[]", sstACTIVE))
			{
				auto& trans = sub->trans_left;
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_TRANSITION_MAXARG)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreendata->TransLeftArgs[%d]'\n", indx, SUBSCR_TRANSITION_MAXARG);
				}
				else
					ret = trans.arg[indx]*SubscrTransition::argScale(trans.type,indx);
			}
			break;
		}
		case SUBDATATRANSRIGHTTY:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "TransRightType", sstACTIVE))
			{
				auto& trans = sub->trans_right;
				ret = trans.type * 10000;
			}
			break;
		}
		case SUBDATATRANSRIGHTSFX:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "TransRightSFX", sstACTIVE))
			{
				auto& trans = sub->trans_right;
				ret = trans.tr_sfx * 10000;
			}
			break;
		}
		case SUBDATATRANSRIGHTFLAGS:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "TransRightFlags[]", sstACTIVE))
			{
				auto& trans = sub->trans_right;
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_TRANS_NUMFLAGS)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreendata->TransRightFlags[%d]'\n", indx, SUBSCR_TRANS_NUMFLAGS);
				}
				else
					ret = (trans.flags & (1<<indx)) ? 10000 : 0;
			}
			break;
		}
		case SUBDATATRANSRIGHTARGS:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "TransRightArgs[]", sstACTIVE))
			{
				auto& trans = sub->trans_right;
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_TRANSITION_MAXARG)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreendata->TransRightArgs[%d]'\n", indx, SUBSCR_TRANSITION_MAXARG);
				}
				else
					ret = trans.arg[indx]*SubscrTransition::argScale(trans.type,indx);
			}
			break;
		}
		case SUBDATASELECTORDSTX:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "SelectorDestX", sstACTIVE))
				ret = sub->selector_setting.x * 10000;
			break;
		}
		case SUBDATASELECTORDSTY:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "SelectorDestY", sstACTIVE))
				ret = sub->selector_setting.y * 10000;
			break;
		}
		case SUBDATASELECTORDSTW:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "SelectorDestW", sstACTIVE))
				ret = sub->selector_setting.w * 10000;
			break;
		}
		case SUBDATASELECTORDSTH:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "SelectorDestH", sstACTIVE))
				ret = sub->selector_setting.h * 10000;
			break;
		}
		case SUBDATASELECTORWID:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "SelectorDestWid", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreendata->"
						"SelectorDestWid[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else
					ret = sub->selector_setting.tileinfo[indx].sw * 10000;
			}
			break;
		}
		case SUBDATASELECTORHEI:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "SelectorDestHei", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreendata->"
						"SelectorDestHei[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else
					ret = sub->selector_setting.tileinfo[indx].sh * 10000;
			}
			break;
		}
		case SUBDATASELECTORTILE:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "SelectorTile", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreendata->"
						"SelectorTile[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else
					ret = sub->selector_setting.tileinfo[indx].tile * 10000;
			}
			break;
		}
		case SUBDATASELECTORCSET:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "SelectorCSet", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreendata->"
						"SelectorCSet[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else
				{
					byte& cs = sub->selector_setting.tileinfo[indx].cset;
					ret = (cs&0x0F) * 10000;
				}
			}
			break;
		}
		case SUBDATASELECTORFLASHCSET:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "SelectorFlashCSet", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreendata->"
						"SelectorFlashCSet[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else
				{
					byte& cs = sub->selector_setting.tileinfo[indx].cset;
					ret = ((cs&0xF0)>>4) * 10000;
				}
			}
			break;
		}
		case SUBDATASELECTORFRM:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "SelectorFrames", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreendata->"
						"SelectorFrames[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else
					ret = sub->selector_setting.tileinfo[indx].frames * 10000;
			}
			break;
		}
		case SUBDATASELECTORASPD:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "SelectorASpeed", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreendata->"
						"SelectorASpeed[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else
					ret = sub->selector_setting.tileinfo[indx].speed * 10000;
			}
			break;
		}
		case SUBDATASELECTORDELAY:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "SelectorDelay", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreendata->"
						"SelectorDelay[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else
					ret = sub->selector_setting.tileinfo[indx].delay * 10000;
			}
			break;
		}
		///---- CURRENTLY OPEN ACTIVE SUBSCREEN ONLY
		case SUBDATATRANSCLK:
		{
			ret = -10000;
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "TransClock", sstACTIVE))
			{
				if(sub != new_subscreen_active)
					Z_scripterrlog("'subscreendata->TransClock' is only"
						" valid for the current active subscreen!\n");
				else if(subscreen_open && subscr_pg_animating)
					ret = subscr_pg_clk*10000;
			}
			break;
		}
		case SUBDATATRANSTY:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "TransType", sstACTIVE))
			{
				auto& trans = subscr_pg_transition;
				if(sub != new_subscreen_active)
					Z_scripterrlog("'subscreendata->TransType' is only"
						" valid for the current active subscreen!\n");
				else if(subscreen_open)
					ret = trans.type*10000;
			}
			break;
		}
		case SUBDATATRANSFLAGS:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "TransFlags[]", sstACTIVE))
			{
				auto& trans = subscr_pg_transition;
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_TRANS_NUMFLAGS)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreendata->TransFlags[%d]'\n", indx, SUBSCR_TRANS_NUMFLAGS);
				}
				else if(sub != new_subscreen_active)
					Z_scripterrlog("'subscreendata->TransType' is only"
						" valid for the current active subscreen!\n");
				else if(subscreen_open)
					ret = (trans.flags & (1<<indx)) ? 10000 : 0;
			}
			break;
		}
		case SUBDATATRANSARGS:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "TransArgs[]", sstACTIVE))
			{
				auto& trans = subscr_pg_transition;
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_TRANSITION_MAXARG)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreendata->TransArgs[%d]'\n", indx, SUBSCR_TRANSITION_MAXARG);
				}
				else if(sub != new_subscreen_active)
					Z_scripterrlog("'subscreendata->TransType' is only"
						" valid for the current active subscreen!\n");
				else if(subscreen_open)
					ret = trans.arg[indx]*SubscrTransition::argScale(trans.type,indx);
			}
			break;
		}
		case SUBDATATRANSFROMPG:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "TransFromPage", sstACTIVE))
			{
				if(sub != new_subscreen_active)
					Z_scripterrlog("'subscreendata->TransFromPage' is only"
						" valid for the current active subscreen!\n");
				else if(subscreen_open)
					ret = subscr_pg_from*10000;
			}
			break;
		}
		case SUBDATATRANSTOPG:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "TransToPage", sstACTIVE))
			{
				if(sub != new_subscreen_active)
					Z_scripterrlog("'subscreendata->TransToPage' is only"
						" valid for the current active subscreen!\n");
				else if(subscreen_open)
					ret = subscr_pg_to*10000;
			}
			break;
		}
		
		///----------------------------------------------------------------------------------------------------//
		case SUBPGINDEX: 
		{
			if(SubscrPage* pg = checkSubPage(ri->subpageref, "Index"))
				ret = pg->getIndex() * 10000;
			break;
		}
		case SUBPGNUMWIDG: 
		{
			if(SubscrPage* pg = checkSubPage(ri->subpageref, "NumWidgets"))
				ret = pg->size() * 10000;
			break;
		}
		case SUBPGWIDGETS: 
		{
			if(SubscrPage* pg = checkSubPage(ri->subpageref, "Widgets[]"))
			{
				size_t indx = ri->d[rINDEX]/10000;
				size_t sz = pg->size();
				if(indx >= sz)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreenpage->Widgets[]' of size '%d'\n", indx, sz);
				}
				else
				{
					auto [sb,ty,pg,_ind] = from_subref(ri->subpageref);
					ret = get_subref(sb,ty,pg,indx);
				}
			}
			break;
		}
		case SUBPGSUBDATA: 
		{
			if(SubscrPage* pg = checkSubPage(ri->subpageref, "SubData"))
			{
				auto [sub,ty,_pgid,_ind] = from_subref(ri->subpageref);
				ret = get_subref(sub,ty,0,0);
			}
			break;
		}
		case SUBPGCURSORPOS: 
		{
			if(SubscrPage* pg = checkSubPage(ri->subpageref, "CursorPos"))
				ret = pg->cursor_pos * 10000;
			break;
		}
		///----------------------------------------------------------------------------------------------------//
		///---- ANY WIDGET TYPE
		case SUBWIDGTYPE:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Type"))
				ret = 10000*widg->getType();
			break;
		}
		case SUBWIDGINDEX:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Index"))
			{
				auto [_sub,_ty,_pgid,ind] = from_subref(ri->subwidgref);
				ret = 10000*ind;
			}
			break;
		}
		case SUBWIDGDISPITM:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "DisplayItem"))
			{
				ret = 10000*widg->getDisplayItem();
			}
			break;
		}
		case SUBWIDGEQPITM:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "EquipItem"))
			{
				ret = 10000*widg->getItemVal();
			}
			break;
		}
		case SUBWIDGPAGE:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Page"))
			{
				auto [sub,ty,pgid,_ind] = from_subref(ri->subwidgref);
				ret = get_subref(sub,ty,pgid,0);
			}
			break;
		}
		case SUBWIDGPOS:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Pos"))
				ret = 10000*widg->pos;
			break;
		}
		case SUBWIDGPOSES:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "PosDirs"))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= 4)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreenwidget->PosDirs[%d]'\n", indx, 4);
					ret = -10000;
				}
				else
				{
					switch(indx)
					{
						case up:
							ret = 10000*widg->pos_up;
							break;
						case down:
							ret = 10000*widg->pos_down;
							break;
						case left:
							ret = 10000*widg->pos_left;
							break;
						case right:
							ret = 10000*widg->pos_right;
							break;
					}
				}
			}
			break;
		}
		case SUBWIDGPOSFLAG:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "VisibleFlags"))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= sspNUM)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreenwidget->VisibleFlags[%d]'\n", indx, sspNUM);
				}
				else ret = (widg->posflags & (1<<indx)) ? 10000 : 0;
			}
			break;
		}
		case SUBWIDGX:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "X"))
				ret = 10000*widg->x;
			break;
		}
		case SUBWIDGY:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Y"))
				ret = 10000*widg->y;
			break;
		}
		case SUBWIDGW:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "W"))
				ret = 10000*widg->w;
			break;
		}
		case SUBWIDGH:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "H"))
				ret = 10000*widg->h;
			break;
		}
		case SUBWIDG_DISPX:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "X"))
				ret = 10000*widg->getX();
			break;
		}
		case SUBWIDG_DISPY:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Y"))
				ret = 10000*widg->getY();
			break;
		}
		case SUBWIDG_DISPW:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "W"))
				ret = 10000*widg->getW();
			break;
		}
		case SUBWIDG_DISPH:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "H"))
				ret = 10000*widg->getH();
			break;
		}
		case SUBWIDGGENFLAG:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "GenFlags"))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCRFLAG_GEN_COUNT)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreenwidget->GenFlags[%d]'\n", indx, SUBSCRFLAG_GEN_COUNT);
				}
				else ret = (widg->genflags & (1<<indx)) ? 10000 : 0;
			}
			break;
		}
		case SUBWIDGFLAG:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Flags"))
			{
				size_t indx = ri->d[rINDEX]/10000;
				byte sz = widg->numFlags();
				if(indx >= sz)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreenwidget->Flags[%d]'\n", indx, sz);
				}
				else ret = (widg->flags & (1<<indx)) ? 10000 : 0;
			}
			break;
		}
		///---- ACTIVE SUBSCREENS ONLY
		case SUBWIDGSELECTORDSTX:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "SelectorDestX", sstACTIVE))
				ret = 10000*widg->selector_override.x;
			break;
		}
		case SUBWIDGSELECTORDSTY:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "SelectorDestY", sstACTIVE))
				ret = 10000*widg->selector_override.y;
			break;
		}
		case SUBWIDGSELECTORDSTW:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "SelectorDestW", sstACTIVE))
				ret = 10000*widg->selector_override.w;
			break;
		}
		case SUBWIDGSELECTORDSTH:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "SelectorDestH", sstACTIVE))
				ret = 10000*widg->selector_override.h;
			break;
		}
		case SUBWIDGSELECTORWID:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "SelectorDestWid", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreenwidget->"
						"SelectorDestWid[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else ret = 10000*widg->selector_override.tileinfo[indx].sw;
			}
			break;
		}
		case SUBWIDGSELECTORHEI:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "SelectorDestHei", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreenwidget->"
						"SelectorDestHei[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else ret = 10000*widg->selector_override.tileinfo[indx].sh;
			}
			break;
		}
		case SUBWIDGSELECTORTILE:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "SelectorTile", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreenwidget->"
						"SelectorTile[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else ret = 10000*widg->selector_override.tileinfo[indx].tile;
			}
			break;
		}
		case SUBWIDGSELECTORCSET:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "SelectorCSet", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreenwidget->"
						"SelectorCSet[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else ret = 10000*(widg->selector_override.tileinfo[indx].cset&0xF);
			}
			break;
		}
		case SUBWIDGSELECTORFLASHCSET:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "SelectorFlashCSet", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreenwidget->"
						"SelectorFlashCSet[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else ret = 10000*((widg->selector_override.tileinfo[indx].cset&0xF0)>>4);
			}
			break;
		}
		case SUBWIDGSELECTORFRM:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "SelectorFrames", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreenwidget->"
						"SelectorFrames[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else ret = 10000*widg->selector_override.tileinfo[indx].frames;
			}
			break;
		}
		case SUBWIDGSELECTORASPD:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "SelectorASpeed", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreenwidget->"
						"SelectorASpeed[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else ret = 10000*widg->selector_override.tileinfo[indx].speed;
			}
			break;
		}
		case SUBWIDGSELECTORDELAY:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "SelectorDelay", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreenwidget->"
						"SelectorDelay[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else ret = 10000*widg->selector_override.tileinfo[indx].delay;
			}
			break;
		}
				
		case SUBWIDGPRESSSCRIPT:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "PressScript", sstACTIVE))
				ret = 10000*widg->generic_script;
			break;
		}
		case SUBWIDGPRESSINITD:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "PressInitD[]", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= 8)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreenwidget->PressInitD[8]'\n", indx);
				}
				else ret = widg->generic_initd[indx];
			}
			break;
		}
		case SUBWIDGBTNPRESS:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "BtnPressScript[]", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= 8)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreenwidget->BtnPressScript[8]'\n", indx);
				}
				else ret = (widg->gen_script_btns & (1<<indx)) ? 10000 : 0;
			}
			break;
		}
		case SUBWIDGBTNPG:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "BtnPageChange[]", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= 8)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreenwidget->BtnPageChange[8]'\n", indx);
				}
				else ret = (widg->pg_btns & (1<<indx)) ? 10000 : 0;
			}
			break;
		}
		case SUBWIDGPGMODE:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "PageMode", sstACTIVE))
				ret = 10000*widg->pg_mode;
			break;
		}
		case SUBWIDGPGTARG:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "TargetPage", sstACTIVE))
				ret = 10000*widg->pg_targ;
			break;
		}
		
		case SUBWIDGTRANSPGTY:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "PageTransType", sstACTIVE))
			{
				auto& trans = widg->pg_trans;
				ret = 10000*trans.type;
			}
			break;
		}
		case SUBWIDGTRANSPGSFX:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "PageTransSFX", sstACTIVE))
			{
				auto& trans = widg->pg_trans;
				ret = 10000*trans.tr_sfx;
			}
			break;
		}
		case SUBWIDGTRANSPGFLAGS:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "PageTransFlags[]", sstACTIVE))
			{
				auto& trans = widg->pg_trans;
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_TRANS_NUMFLAGS)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreenwidget->PageTransFlags[%d]'\n", indx, SUBSCR_TRANS_NUMFLAGS);
				}
				else ret = (trans.flags & (1<<indx)) ? 10000 : 0;
			}
			break;
		}
		case SUBWIDGTRANSPGARGS:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "PageTransArgs[]", sstACTIVE))
			{
				auto& trans = widg->pg_trans;
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_TRANSITION_MAXARG)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreenwidget->PageTransArgs[%d]'\n", indx, SUBSCR_TRANSITION_MAXARG);
				}
				else ret = trans.arg[indx]*SubscrTransition::argScale(trans.type,indx);
			}
			break;
		}
		///---- VARYING WIDGET TYPES
		case SUBWIDGTY_CSET:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "CSet[]"))
			{
				size_t indx = ri->d[rINDEX]/10000;
				size_t sz = 0;
				byte ty = widg->getType();
				switch(ty)
				{
					case widgFRAME:
					case widgMCGUFF:
					case widgTILEBLOCK:
					case widgMINITILE:
						sz = 1;
						break;
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						sz = 4;
						break;
					default:
						sz = 0;
						bad_subwidg_type("CSet[]", false, ty);
						ret = -10000;
						break;
				}
				if(!sz) break;
				if(indx >= sz)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreenwidget->CSet[%d]'\n", indx, sz);
					break;
				}
				switch(ty)
				{
					case widgFRAME:
						ret = ((SW_2x2Frame*)widg)->cs.get_cset()*10000;
						break;
					case widgMCGUFF:
						ret = ((SW_McGuffin*)widg)->cs.get_cset()*10000;
						break;
					case widgTILEBLOCK:
						ret = ((SW_TileBlock*)widg)->cs.get_cset()*10000;
						break;
					case widgMINITILE:
						ret = ((SW_MiniTile*)widg)->cs.get_cset()*10000;
						break;
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						ret = 10000*((SW_GaugePiece*)widg)->mts[indx].cset;
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_TILE:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Tile"))
			{
				size_t indx = ri->d[rINDEX]/10000;
				size_t sz = 0;
				byte ty = widg->getType();
				switch(ty)
				{
					case widgFRAME:
					case widgMCGUFF:
					case widgTILEBLOCK:
					case widgMINITILE:
						sz = 1;
						break;
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						sz = 4;
						break;
					default:
						sz = 0;
						bad_subwidg_type("Tile[]", false, ty);
						ret = -10000;
						break;
				}
				if(!sz) break;
				if(indx >= sz)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreenwidget->Tile[%d]'\n", indx, sz);
					break;
				}
				switch(ty)
				{
					case widgFRAME:
						ret = ret = 10000*((SW_2x2Frame*)widg)->tile;
						break;
					case widgMCGUFF:
						ret = 10000*((SW_McGuffin*)widg)->tile;
						break;
					case widgTILEBLOCK:
						ret = 10000*((SW_TileBlock*)widg)->tile;
						break;
					case widgMINITILE:
						ret = 10000*((SW_MiniTile*)widg)->get_int_tile();
						break;
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						ret = 10000*((SW_GaugePiece*)widg)->mts[indx].tile();
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_FONT:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Font"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgTEXT:
						ret = 10000*((SW_Text*)widg)->fontid;
						break;
					case widgTEXTBOX:
						ret = 10000*((SW_TextBox*)widg)->fontid;
						break;
					case widgSELECTEDTEXT:
						ret = 10000*((SW_SelectedText*)widg)->fontid;
						break;
					case widgTIME:
						ret = 10000*((SW_Time*)widg)->fontid;
						break;
					case widgCOUNTER:
						ret = 10000*((SW_Counter*)widg)->fontid;
						break;
					case widgBTNCOUNTER:
						ret = 10000*((SW_BtnCounter*)widg)->fontid;
						break;
					case widgOLDCTR:
						ret = 10000*((SW_Counters*)widg)->fontid;
						break;
					case widgMMAPTITLE:
						ret = 10000*((SW_MMapTitle*)widg)->fontid;
						break;
					default:
						bad_subwidg_type("Font", false, ty);
						ret = -10000;
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_ALIGN:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Align"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgTEXT:
						ret = 10000*((SW_Text*)widg)->align;
						break;
					case widgTEXTBOX:
						ret = 10000*((SW_TextBox*)widg)->align;
						break;
					case widgSELECTEDTEXT:
						ret = 10000*((SW_SelectedText*)widg)->align;
						break;
					case widgTIME:
						ret = 10000*((SW_Time*)widg)->align;
						break;
					case widgCOUNTER:
						ret = 10000*((SW_Counter*)widg)->align;
						break;
					case widgBTNCOUNTER:
						ret = 10000*((SW_BtnCounter*)widg)->align;
						break;
					case widgMMAPTITLE:
						ret = 10000*((SW_MMapTitle*)widg)->align;
						break;
					default:
						bad_subwidg_type("Align", false, ty);
						ret = -10000;
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_SHADOWTY:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "ShadowType"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgTEXT:
						ret = 10000*((SW_Text*)widg)->shadtype;
						break;
					case widgTEXTBOX:
						ret = 10000*((SW_TextBox*)widg)->shadtype;
						break;
					case widgSELECTEDTEXT:
						ret = 10000*((SW_SelectedText*)widg)->shadtype;
						break;
					case widgTIME:
						ret = 10000*((SW_Time*)widg)->shadtype;
						break;
					case widgCOUNTER:
						ret = 10000*((SW_Counter*)widg)->shadtype;
						break;
					case widgBTNCOUNTER:
						ret = 10000*((SW_BtnCounter*)widg)->shadtype;
						break;
					case widgOLDCTR:
						ret = 10000*((SW_Counters*)widg)->shadtype;
						break;
					case widgMMAPTITLE:
						ret = 10000*((SW_MMapTitle*)widg)->shadtype;
						break;
					default:
						bad_subwidg_type("ShadowType", false, ty);
						ret = -10000;
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_COLOR_TXT:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "ColorText"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgTEXT:
						ret = 10000*((SW_Text*)widg)->c_text.get_int_color();
						break;
					case widgTEXTBOX:
						ret = 10000*((SW_TextBox*)widg)->c_text.get_int_color();
						break;
					case widgSELECTEDTEXT:
						ret = 10000*((SW_SelectedText*)widg)->c_text.get_int_color();
						break;
					case widgTIME:
						ret = 10000*((SW_Time*)widg)->c_text.get_int_color();
						break;
					case widgCOUNTER:
						ret = 10000*((SW_Counter*)widg)->c_text.get_int_color();
						break;
					case widgBTNCOUNTER:
						ret = 10000*((SW_BtnCounter*)widg)->c_text.get_int_color();
						break;
					case widgOLDCTR:
						ret = 10000*((SW_Counters*)widg)->c_text.get_int_color();
						break;
					case widgMMAPTITLE:
						ret = 10000*((SW_MMapTitle*)widg)->c_text.get_int_color();
						break;
					case widgMCGUFF_FRAME:
						ret = 10000*((SW_TriFrame*)widg)->c_number.get_int_color();
						break;
					default:
						bad_subwidg_type("ColorText", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_COLOR_SHD:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "ColorShadow"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgTEXT:
						ret = 10000*((SW_Text*)widg)->c_shadow.get_int_color();
						break;
					case widgTEXTBOX:
						ret = 10000*((SW_TextBox*)widg)->c_shadow.get_int_color();
						break;
					case widgSELECTEDTEXT:
						ret = 10000*((SW_SelectedText*)widg)->c_shadow.get_int_color();
						break;
					case widgTIME:
						ret = 10000*((SW_Time*)widg)->c_shadow.get_int_color();
						break;
					case widgCOUNTER:
						ret = 10000*((SW_Counter*)widg)->c_shadow.get_int_color();
						break;
					case widgBTNCOUNTER:
						ret = 10000*((SW_BtnCounter*)widg)->c_shadow.get_int_color();
						break;
					case widgOLDCTR:
						ret = 10000*((SW_Counters*)widg)->c_shadow.get_int_color();
						break;
					case widgMMAPTITLE:
						ret = 10000*((SW_MMapTitle*)widg)->c_shadow.get_int_color();
						break;
					default:
						bad_subwidg_type("ColorShadow", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_COLOR_BG:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "ColorBG"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgTEXT:
						ret = 10000*((SW_Text*)widg)->c_bg.get_int_color();
						break;
					case widgTEXTBOX:
						ret = 10000*((SW_TextBox*)widg)->c_bg.get_int_color();
						break;
					case widgSELECTEDTEXT:
						ret = 10000*((SW_SelectedText*)widg)->c_bg.get_int_color();
						break;
					case widgTIME:
						ret = 10000*((SW_Time*)widg)->c_bg.get_int_color();
						break;
					case widgCOUNTER:
						ret = 10000*((SW_Counter*)widg)->c_bg.get_int_color();
						break;
					case widgBTNCOUNTER:
						ret = 10000*((SW_BtnCounter*)widg)->c_bg.get_int_color();
						break;
					case widgOLDCTR:
						ret = 10000*((SW_Counters*)widg)->c_bg.get_int_color();
						break;
					case widgMMAPTITLE:
						ret = 10000*((SW_MMapTitle*)widg)->c_bg.get_int_color();
						break;
					case widgBGCOLOR:
						ret = 10000*((SW_Clear*)widg)->c_bg.get_int_color();
						break;
					default:
						bad_subwidg_type("ColorBG", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_COLOR_OLINE:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "ColorOutline"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgLINE:
						ret = 10000*((SW_Line*)widg)->c_line.get_int_color();
						break;
					case widgRECT:
						ret = 10000*((SW_Rect*)widg)->c_outline.get_int_color();
						break;
					case widgMCGUFF_FRAME:
						ret = 10000*((SW_TriFrame*)widg)->c_outline.get_int_color();
						break;
					default:
						bad_subwidg_type("ColorOutline", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_COLOR_FILL:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "ColorFill"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgRECT:
						ret = 10000*((SW_Rect*)widg)->c_fill.get_int_color();
						break;
					default:
						bad_subwidg_type("ColorFill", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_BUTTON:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Button"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgBTNITM:
						ret = 10000*((SW_ButtonItem*)widg)->btn;
						break;
					case widgBTNCOUNTER:
						ret = 10000*((SW_BtnCounter*)widg)->btn;
						break;
					default:
						bad_subwidg_type("Button", false, ty);
						ret = -10000;
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_COUNTERS:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Counter[]"))
			{
				size_t indx = ri->d[rINDEX]/10000;
				size_t sz = 0;
				byte ty = widg->getType();
				switch(ty)
				{
					case widgCOUNTER:
						sz = 3;
						break;
					case widgMISCGAUGE:
						sz = 1;
						break;
					default:
						sz = 0;
						bad_subwidg_type("Counter[]", false, ty);
						ret = -10000;
						break;
				}
				if(!sz) break;
				if(indx >= sz)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreenwidget->Counter[%d]'\n", indx, sz);
					break;
				}
				switch(ty)
				{
					case widgCOUNTER:
						ret = ((SW_Counter*)widg)->ctrs[indx]*10000;
						break;
					case widgMISCGAUGE:
						ret = ((SW_MiscGaugePiece*)widg)->counter*10000;
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_MINDIG:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "MinDigits"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgCOUNTER:
						ret = 10000*((SW_Counter*)widg)->mindigits;
						break;
					case widgBTNCOUNTER:
						ret = 10000*((SW_BtnCounter*)widg)->mindigits;
						break;
					case widgOLDCTR:
						ret = 10000*((SW_Counters*)widg)->digits;
						break;
					default:
						bad_subwidg_type("MinDigits", false, ty);
						ret = -10000;
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_MAXDIG:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "MaxDigits"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgCOUNTER:
						ret = 10000*((SW_Counter*)widg)->maxdigits;
						break;
					case widgBTNCOUNTER:
						ret = 10000*((SW_BtnCounter*)widg)->maxdigits;
						break;
					default:
						bad_subwidg_type("MaxDigits", false, ty);
						ret = -10000;
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_INFITM:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "InfiniteItem"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgCOUNTER:
						ret = 10000*((SW_Counter*)widg)->infitm;
						break;
					case widgOLDCTR:
						ret = 10000*((SW_Counters*)widg)->infitm;
						break;
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						ret = 10000*((SW_GaugePiece*)widg)->inf_item;
						break;
					default:
						bad_subwidg_type("InfiniteItem", false, ty);
						ret = -10000;
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_INFCHAR:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "InfiniteChar"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgCOUNTER:
						ret = 10000*byte(((SW_Counter*)widg)->infchar);
						break;
					case widgOLDCTR:
						ret = 10000*byte(((SW_Counters*)widg)->infchar);
						break;
					case widgBTNCOUNTER:
						ret = 10000*byte(((SW_BtnCounter*)widg)->infchar);
						break;
					default:
						bad_subwidg_type("InfiniteChar", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_COSTIND:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "CostIndex"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgBTNCOUNTER:
						ret = 10000*((SW_BtnCounter*)widg)->costind;
						break;
					default:
						bad_subwidg_type("CostIndex", false, ty);
						ret = -1;
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_COLOR_PLAYER:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "ColorPlayer"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgMMAP:
						ret = 10000*((SW_MMap*)widg)->c_plr.get_int_color();
						break;
					case widgLMAP:
						ret = 10000*((SW_LMap*)widg)->c_plr.get_int_color();
						break;
					default:
						bad_subwidg_type("ColorPlayer", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_COLOR_CMPBLNK:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "ColorCompassBlink"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgMMAP:
						ret = 10000*((SW_MMap*)widg)->c_cmp_blink.get_int_color();
						break;
					default:
						bad_subwidg_type("ColorCompassBlink", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_COLOR_CMPOFF:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "ColorCompassOff"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgMMAP:
						ret = 10000*((SW_MMap*)widg)->c_cmp_off.get_int_color();
						break;
					default:
						bad_subwidg_type("ColorCompassOff", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_COLOR_ROOM:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "ColorRoom"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgLMAP:
						ret = 10000*((SW_LMap*)widg)->c_room.get_int_color();
						break;
					default:
						bad_subwidg_type("ColorRoom", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_ITEMCLASS:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "ItemClass"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgITEMSLOT:
						ret = 10000*((SW_ItemSlot*)widg)->iclass;
						break;
					default:
						bad_subwidg_type("ItemClass", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_ITEMID:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "ItemID"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgITEMSLOT:
						ret = 10000*((SW_ItemSlot*)widg)->iid;
						break;
					default:
						bad_subwidg_type("ItemID", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_FRAMETILE:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "FrameTile"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgMCGUFF_FRAME:
						ret = 10000*((SW_TriFrame*)widg)->frame_tile;
						break;
					default:
						bad_subwidg_type("FrameTile", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_FRAMECSET:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "FrameCSet"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgMCGUFF_FRAME:
						ret = 10000*((SW_TriFrame*)widg)->frame_cset;
						break;
					default:
						bad_subwidg_type("FrameCSet", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_PIECETILE:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "PieceTile"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgMCGUFF_FRAME:
						ret = 10000*((SW_TriFrame*)widg)->piece_tile;
						break;
					default:
						bad_subwidg_type("PieceTile", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_PIECECSET:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "PieceCSet"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgMCGUFF_FRAME:
						ret = 10000*((SW_TriFrame*)widg)->piece_cset;
						break;
					default:
						bad_subwidg_type("PieceCSet", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_FLIP:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Flip"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgMCGUFF:
						ret = 10000*((SW_McGuffin*)widg)->flip;
						break;
					case widgTILEBLOCK:
						ret = 10000*((SW_TileBlock*)widg)->flip;
						break;
					case widgMINITILE:
						ret = 10000*((SW_MiniTile*)widg)->flip;
						break;
					default:
						bad_subwidg_type("Flip", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_NUMBER:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Number"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgMCGUFF:
						ret = 10000*((SW_McGuffin*)widg)->number;
						break;
					default:
						bad_subwidg_type("Number", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_CORNER:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Corner"))
			{
				size_t indx = ri->d[rINDEX]/10000;
				size_t sz = 0;
				byte ty = widg->getType();
				switch(ty)
				{
					case widgMINITILE:
						sz = 1;
						break;
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						sz = 4;
						break;
					default:
						sz = 0;
						bad_subwidg_type("Corner[]", false, ty);
						ret = -10000;
						break;
				}
				if(!sz) break;
				if(indx >= sz)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreenwidget->Corner[%d]'\n", indx, sz);
					break;
				}
				switch(ty)
				{
					case widgMINITILE:
						ret = 10000*((SW_MiniTile*)widg)->crn;
						break;
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						ret = 10000*((SW_GaugePiece*)widg)->mts[indx].crn();
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_FRAMES:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Frames"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						ret = 10000*((SW_GaugePiece*)widg)->frames;
						break;
					default:
						bad_subwidg_type("Frames", false, ty);
						ret = -10000;
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_SPEED:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Speed"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						ret = 10000*((SW_GaugePiece*)widg)->speed;
						break;
					default:
						bad_subwidg_type("Speed", false, ty);
						ret = -10000;
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_DELAY:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Delay"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						ret = 10000*((SW_GaugePiece*)widg)->delay;
						break;
					default:
						bad_subwidg_type("Delay", false, ty);
						ret = -10000;
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_CONTAINER:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Container"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						ret = 10000*((SW_GaugePiece*)widg)->container;
						break;
					default:
						bad_subwidg_type("Container", false, ty);
						ret = -10000;
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_GAUGE_WID:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "GaugeWid"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						ret = 10000*(((SW_GaugePiece*)widg)->gauge_wid+1);
						break;
					default:
						bad_subwidg_type("GaugeWid", false, ty);
						ret = -10000;
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_GAUGE_HEI:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "GaugeHei"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						ret = 10000*(((SW_GaugePiece*)widg)->gauge_hei+1);
						break;
					default:
						bad_subwidg_type("GaugeHei", false, ty);
						ret = -10000;
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_UNITS:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Units"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						ret = 10000*(((SW_GaugePiece*)widg)->unit_per_frame+1);
						break;
					default:
						bad_subwidg_type("Units", false, ty);
						ret = -10000;
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_HSPACE:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "HSpace"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						ret = 10000*((SW_GaugePiece*)widg)->hspace;
						break;
					default:
						bad_subwidg_type("HSpace", false, ty);
						ret = -10000;
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_VSPACE:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "VSpace"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						ret = 10000*((SW_GaugePiece*)widg)->vspace;
						break;
					default:
						bad_subwidg_type("VSpace", false, ty);
						ret = -10000;
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_GRIDX:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "GridX"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						ret = 10000*((SW_GaugePiece*)widg)->grid_xoff;
						break;
					default:
						bad_subwidg_type("GridX", false, ty);
						ret = -10000;
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_GRIDY:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "GridY"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						ret = 10000*((SW_GaugePiece*)widg)->grid_yoff;
						break;
					default:
						bad_subwidg_type("GridY", false, ty);
						ret = -10000;
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_ANIMVAL:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "AnimVal"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						ret = 10000*((SW_GaugePiece*)widg)->anim_val;
						break;
					default:
						bad_subwidg_type("AnimVal", false, ty);
						ret = -10000;
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_SHOWDRAIN:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "ShowDrain"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgMGAUGE:
						ret = 10000*((SW_MagicGaugePiece*)widg)->showdrain;
						break;
					default:
						bad_subwidg_type("ShowDrain", false, ty);
						ret = -10000;
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_PERCONTAINER:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "PerContainer"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgMISCGAUGE:
						ret = 10000*((SW_MiscGaugePiece*)widg)->per_container;
						break;
					default:
						bad_subwidg_type("PerContainer", false, ty);
						ret = -10000;
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_TABSIZE:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "TabSize"))
			{
				auto ty = widg->getType();
				switch(ty)
				{
					case widgTEXTBOX:
						ret = 10000*((SW_TextBox*)widg)->tabsize;
						break;
					case widgSELECTEDTEXT:
						ret = 10000*((SW_SelectedText*)widg)->tabsize;
						break;
					default:
						bad_subwidg_type("TabSize", false, ty);
						ret = -10000;
						break;
				}
			}
			break;
		}
		///----------------------------------------------------------------------------------------------------//

		case WEBSOCKET_STATE:
		{
			ret = 0;
			auto ws = user_websockets.check(ri->websocketref, "->State");
			if (!ws) break;

			ret = (int)ws->get_state();
			break;
		}
		case WEBSOCKET_HAS_MESSAGE:
		{
			ret = 0;
			auto ws = user_websockets.check(ri->websocketref, "->HasMessage");
			if (!ws) break;

			ret = ws->has_message() * 10000;
			break;
		}
		case WEBSOCKET_MESSAGE_TYPE:
		{
			ret = 0;
			auto ws = user_websockets.check(ri->websocketref, "->MessageType");
			if (!ws) break;

			ret = (int)ws->last_message_type;
			break;
		}

		default:
		{
			if(arg >= D(0) && arg <= D(7))			ret = ri->d[arg - D(0)];
			else if(arg >= A(0) && arg <= A(1))		ret = ri->a[arg - A(0)];
			else if(arg >= GD(0) && arg <= GD(MAX_SCRIPT_REGISTERS))	ret = game->global_d[arg - GD(0)];
			
			break;
		}
	}
		
	return ret;
}

//Setter Instructions


void set_register(int32_t arg, int32_t value)
{
	//Macros
	
	#define	SET_SPRITEDATA_VAR_INT(member, str) \
	{ \
		if(unsigned(ri->spritesref) > (MAXWPNS-1) ) \
		{ \
			Z_scripterrlog("Invalid Sprite ID passed to spritedata->%s: %d\n", str, (ri->spritesref*10000)); \
		} \
		else \
		{ \
			wpnsbuf[ri->spritesref].member = vbound((value / 10000),0,214747); \
		} \
	} \

	#define	SET_SPRITEDATA_VAR_BYTE(member, str) \
	{ \
		if(unsigned(ri->spritesref) > (MAXWPNS-1) ) \
		{ \
			Z_scripterrlog("Invalid Sprite ID passed to spritedata->%s: %d\n", str, (ri->spritesref*10000)); \
		} \
		else \
		{ \
			wpnsbuf[ri->spritesref].member = vbound((value / 10000),0,255); \
		} \
	} \
	
	switch(arg)
	{
		//debug ri->d[]
		case DEBUGD:
		{
			int32_t a = vbound((ri->d[rINDEX] / 10000), 0, 255);
			ri->d[a] = value/10000;
			break;
		}    
		
	///----------------------------------------------------------------------------------------------------//
	//FFC Variables
		case DATA:
			if(BC::checkFFC(ri->ffcref, "ffc->Data") == SH::_NoError)
			{
				zc_ffc_set(tmpscr->ffcs[ri->ffcref], vbound(value/10000,0,MAXCOMBOS-1));
			}
			break;
		
		case FFSCRIPT:
			if(BC::checkFFC(ri->ffcref, "ffc->Script") == SH::_NoError)
			{
				tmpscr->ffcs[ri->ffcref].script = vbound(value/10000, 0, NUMSCRIPTFFC-1);
				for(int32_t i=0; i<16; i++)
					ffmisc[ri->ffcref][i] = 0;
				if (get_qr(qr_CLEARINITDONSCRIPTCHANGE))
				{
					for(int32_t i=0; i<2; i++)
						tmpscr->ffcs[ri->ffcref].inita[i] = 0;
					
					for(int32_t i=0; i<8; i++)
						tmpscr->ffcs[ri->ffcref].initd[i] = 0;
				}
				on_reassign_script_engine_data(ScriptType::FFC, ri->ffcref);
			}
			break;
			
			
		case FCSET:
			if(BC::checkFFC(ri->ffcref, "ffc->CSet") == SH::_NoError)
				tmpscr->ffcs[ri->ffcref].cset = (value/10000)&15;
			break;
			
		case DELAY:
			if(BC::checkFFC(ri->ffcref, "ffc->Delay") == SH::_NoError)
				tmpscr->ffcs[ri->ffcref].delay = value/10000;
			break;
			
		case FX:
			if(BC::checkFFC(ri->ffcref, "ffc->X") == SH::_NoError)
				tmpscr->ffcs[ri->ffcref].x = zslongToFix(value);
			break;
			
		case FY:
			if(BC::checkFFC(ri->ffcref, "ffc->Y") == SH::_NoError)
				tmpscr->ffcs[ri->ffcref].y=zslongToFix(value);
			break;
			
		case XD:
			if(BC::checkFFC(ri->ffcref, "ffc->Vx") == SH::_NoError)
				tmpscr->ffcs[ri->ffcref].vx=zslongToFix(value);
			break;
			
		case YD:
			if(BC::checkFFC(ri->ffcref, "ffc->Vy") == SH::_NoError)
				tmpscr->ffcs[ri->ffcref].vy=zslongToFix(value);
			break;
		
		case FFCID:
			break;
			
		case XD2:
			if(BC::checkFFC(ri->ffcref, "ffc->Ax") == SH::_NoError)
				tmpscr->ffcs[ri->ffcref].ax=zslongToFix(value);
			break;
			
		case YD2:
			if(BC::checkFFC(ri->ffcref, "ffc->Ay") == SH::_NoError)
				tmpscr->ffcs[ri->ffcref].ay=zslongToFix(value);
			break;
			
		case FFFLAGSD:
			if(BC::checkFFC(ri->ffcref, "ffc->Flags[]") == SH::_NoError)
			{
				auto flag = 1<<((ri->d[rINDEX])/10000);
				ffcdata& ff = tmpscr->ffcs[ri->ffcref];
				SETFLAG(ff.flags, flag, value);
				if (flag == ffSOLID || flag == ffCHANGER)
					ff.updateSolid();
			}
			break;
			
		case FFCWIDTH:
			if(BC::checkFFC(ri->ffcref, "ffc->EffectWidth") == SH::_NoError)
				tmpscr->ffcs[ri->ffcref].hit_width = (value/10000);
			break;
			
		case FFCHEIGHT:
			if(BC::checkFFC(ri->ffcref, "ffc->EffectHeight") == SH::_NoError)
				tmpscr->ffcs[ri->ffcref].hit_height = (value/10000);
			break;
			
		case FFTWIDTH:
			if(BC::checkFFC(ri->ffcref, "ffc->TileWidth") == SH::_NoError)
				tmpscr->ffcs[ri->ffcref].txsz = vbound(value/10000, 1, 4);
			break;
			
		case FFTHEIGHT:
			if(BC::checkFFC(ri->ffcref, "ffc->TileHeight") == SH::_NoError)
				tmpscr->ffcs[ri->ffcref].tysz = vbound(value/10000, 1, 4);
			break;
			
		case FFLINK:
			if(BC::checkFFC(ri->ffcref, "ffc->Link") == SH::_NoError)
				(tmpscr->ffcs[ri->ffcref].link)=vbound(value/10000, 0, MAXFFCS); // Allow "ffc->Link = 0" to unlink ffc.
			//0 is none, setting this before made it impssible to clear it. -Z
			break;
			
		case FFMISCD:
		{
			int32_t a = vbound(ri->d[rINDEX]/10000,0,15);
			if(BC::checkFFC(ri->ffcref, "ffc->Misc[]")== SH::_NoError)
				ffmisc[ri->ffcref][a]=value;
			break;
		}
		
		case FFINITDD:
			if(BC::checkFFC(ri->ffcref, "ffc->InitD[]") == SH::_NoError)
				(tmpscr->ffcs[ri->ffcref].initd[vbound(ri->d[rINDEX]/10000,0,7)])=value;
			break;
			
		case FFCLASTCHANGERX:
			if(BC::checkFFC(ri->ffcref, "ffc->LastChangerX") == SH::_NoError)
				ffposx[ri->ffcref]=vbound(zslongToFix(value).getInt(),-32768, 32767);
			break;
			
		case FFCLASTCHANGERY:
			if(BC::checkFFC(ri->ffcref, "ffc->LastChangerY") == SH::_NoError)
				ffposy[ri->ffcref]=vbound(zslongToFix(value).getInt(),-32768, 32767);
			break;
		
			
			
	///----------------------------------------------------------------------------------------------------//
	//Hero's Variables
		case LINKX:
		{
			if ( get_qr(qr_SPRITEXY_IS_FLOAT) )
			{
				Hero.setXfix(zslongToFix(value));
			}
			else
			{
				Hero.setX(value/10000);
			}
		}
		break;
		
		case LINKCSET:
		{
			Hero.cs = value/10000;
			break;
		}
		case LINKY:
		{
			if ( get_qr(qr_SPRITEXY_IS_FLOAT) )
			{
				Hero.setYfix(zslongToFix(value));
			}
			else
			{
				Hero.setY(value/10000);
			}
		}
		break;
			
		case LINKZ:
		{
			if ( get_qr(qr_SPRITEXY_IS_FLOAT) )
			{
				Hero.setZfix(zslongToFix(value));
			}
			else
			{
				Hero.setZ(value/10000);
			}
		}
		break;
			
		case LINKJUMP:
			Hero.setFall(zslongToFix(value) * -100);
			break;
		
		case HEROFAKEJUMP:
			Hero.setFakeFall(zslongToFix(value) * -100);
			break;
			
		case LINKDIR:
		{
			//Hero->setDir() calls reset_hookshot(), which removes the sword sprite.. O_o
			if(Hero.getAction() == attacking || Hero.getAction() == sideswimattacking) Hero.dir = (value/10000);
			else Hero.setDir(value/10000);
			
			break;
		}
		
		case LINKHITDIR:
			Hero.setHitDir(value / 10000);
			break;
		
		case LINKGRAVITY:
			if(value)
				Hero.moveflags |= FLAG_OBEYS_GRAV;
			else
				Hero.moveflags &= ~FLAG_OBEYS_GRAV;
			break;
		
		case HERONOSTEPFORWARD:
			FFCore.nostepforward = ( (value) ? 1 : 0 ); 
			break;
			
		case LINKHP:
			game->set_life(zc_max(0, zc_min(value/10000,game->get_maxlife())));
			break;
			
		case LINKMP:
			game->set_magic(zc_max(0, zc_min(value/10000,game->get_maxmagic())));
			break;
			
		case LINKMAXHP:
			game->set_maxlife(value/10000);
			break;
			
		case LINKMAXMP:
			game->set_maxmagic(value/10000);
			break;
			
		case LINKACTION:
		{
			int32_t act = value / 10000;
			switch(act)
			{
				case hookshotout:
				case stunned:
				case ispushing:
					FFCore.setHeroAction(act);
					break;
				default:
					Hero.setAction((actiontype)(act));
			}
			//Protect from writing illegal actions to Hero's raw variable. 
			//in the future, we can move all scripted actions that are not possible
			//to set in ZC into this mechanic. -Z
			break;
		}
			
		case HEROHEALTHBEEP:
		{
			int32_t beep = vbound((value/10000),-4, 255); 
			//-2 suspends system control of stopping the sound
			//-3 suspends system control of stopping the sound AND suspends
			// system control over starting or playing it.
			heart_beep_timer = beep;
			if ( heart_beep_timer > -1 )
			{
				cont_sfx(QMisc.miscsfx[sfxLOWHEART]);
			}
			else
			{
				stop_sfx(QMisc.miscsfx[sfxLOWHEART]);
			}
			break;
		}
		
		case LINKHELD:
			Hero.setHeldItem(vbound(value/10000,0,MAXITEMS-1));
			break;
		
		case HEROSTEPS:
		{
			lsteps[vbound(ri->d[rINDEX]/10000,0,7)] = value/10000;
			break;
		}
		
		case HEROSTEPRATE:
			if(!get_qr(qr_NEW_HERO_MOVEMENT))
			{
				Z_scripterrlog("To use '%s', you must %s the quest rule '%s'.", "Hero->Step", "enable", "New Player Movement");
			}
			Hero.setStepRate(zc_max(value/10000,0));
			if(!get_qr(qr_SCRIPT_WRITING_HEROSTEP_DOESNT_CARRY_OVER))
				zinit.heroStep = Hero.getStepRate();
			break;
		case HEROSHOVEOFFSET:
			if(!get_qr(qr_NEW_HERO_MOVEMENT2))
				Z_scripterrlog("To use 'Hero->ShoveOffset', you must enable the quest rule 'Newer Player Movement'.");
			Hero.shove_offset = vbound(zslongToFix(value),16_zf,0_zf);
			if(!get_qr(qr_SCRIPT_WRITING_HEROSTEP_DOESNT_CARRY_OVER))
				zinit.shove_offset = Hero.shove_offset;
			break;
		
		case LINKITEMD:
		{
			int32_t itemID=vbound(ri->d[rINDEX]/10000,0,MAXITEMS-1);
			
			// If the Cane of Byrna is being removed, cancel its effect.
			if(value==0 && itemID==current_item_id(itype_cbyrna))
				stopCaneOfByrna();
			
			auto& data = get_script_engine_data(ScriptType::Item, itemID);
		
			//Stop current script if set false.
			if ( !value && data.doscript )
			{
				data.doscript = 4; //Val of 4 means 'clear stack and quit'
				//itemScriptData[itemID].Clear(); //Don't clear here, causes crash if is current item!
			}
			else if ( value && !data.doscript )
			{
				//Clear the item refInfo and stack for use.
				data.ref.Clear();
				if ( (itemsbuf[itemID].flags&ITEM_PASSIVESCRIPT) ) data.doscript = 1;
			}
			else if ( value && data.doscript == 4 ) 
			{
				// Arbitrary event number 49326: Writing the item false, then true, in the same frame. -Z
				if ( (itemsbuf[itemID].flags&ITEM_PASSIVESCRIPT) ) data.doscript = 1;
			}
			
			bool settrue = ( value != 0 );
			
			//Sanity check to prevent setting the item if the value would be the same. -Z
			if ( game->item[itemID] != settrue ) 
			{
				game->set_item(itemID,(value != 0));
			}
					
			if((get_qr(qr_OVERWORLDTUNIC) != 0) || (currscr<128 || dlevel)) 
			{
				ringcolor(false);
				//refreshpal=true;
			}
			if ( !value ) //setting the item false clears the state of forced ->Equipment writes.
			{
				if ( game->forced_bwpn == itemID ) 
				{
					game->forced_bwpn = -1;
				} //not else if! -Z
				if ( game->forced_awpn == itemID ) 
				{
					game->forced_awpn = -1;
				}
				if ( game->forced_xwpn == itemID ) 
				{
					game->forced_xwpn = -1;
				}
				if ( game->forced_ywpn == itemID ) 
				{
					game->forced_ywpn = -1;
				}
			}
		}
		break;
			
		case LINKEQUIP:
		{
			if ( FFCore.getQuestHeaderInfo(vZelda) == 0x250 && FFCore.getQuestHeaderInfo(vBuild) < 33 )
			{
				break;
			}
			//int32_t seta = (value/10000) >> 8; int32_t setb = value/10000) & 0xFF;
			int32_t setb = ((value/10000)&0xFF00)>>8, seta = (value/10000)&0xFF;
			seta = vbound(seta,-1,255);
			setb = vbound(setb,-1,255);
			//zprint("A is: %d\n", seta);
			//zprint("A is: %d\n", setb);
				
			Awpn = seta;
			game->awpn = 255;
			game->forced_awpn = seta;
			game->items_off[seta] = 0;
			directItemA = seta;
			
			Bwpn = setb;
			game->bwpn = 255;
			game->forced_bwpn = setb;
			game->items_off[setb] = 0;
			directItemB = setb;
			break;
		}
		
		  
		case SETITEMSLOT:
		{
			//ri->d[rINDEX2] = 1st arg
			//ri->d[rINDEX] = 2nd arg
			//value = third arg
			//int32_t item, int32_t slot, int32_t force
			int32_t itm = ri->d[rINDEX]/10000;
			itm = vbound(itm, -1, 255);
			
			int32_t slot = ri->d[rINDEX2]/10000;
			int32_t force = ri->d[rEXP1]/10000;
			
			zprint("SetItemSlot rid->[0] is (%i), trying to use for '%s'\n", itm, "itm");
			zprint("SetItemSlot rid->[1] is (%i), trying to use for '%s'\n", slot, "slot");
			zprint("SetItemSlot rid->[2] is (%i), trying to use for '%s'\n", force, "force");
			
			//If we add more item buttons, slot should be an int32_t
			//and force shuld be an int32_t
			
			/*
				For zScript, 
					const int32_t ITM_REQUIRE_NONE = 0
					const int32_t ITM_REQUIRE_INVENTORY = 1
					const int32_t ITM_REQUIRE_A_SLOT_RULE = 2
					//Combine as flags
			*/
			if ( force == 0 )
			{
				switch(slot)
				{
					case 0: //b
						Bwpn = itm;
						game->items_off[itm] = 0;
						game->bwpn = 255;
						game->forced_bwpn = itm;
						directItemB = itm;
						break;
					
					case 1: //a
						Awpn = itm;
						game->items_off[itm] = 0;
						game->awpn = 255;
						game->forced_awpn = itm;
						directItemA = itm;
						break;
					
					case 2: //x
						Xwpn = itm;
						game->items_off[itm] = 0;
						game->xwpn = 255;
						game->forced_xwpn = itm;
						directItemX = itm;
						break;
					
					case 3: //y
						Ywpn = itm;
						game->items_off[itm] = 0;
						game->ywpn = 255;
						game->forced_ywpn = itm;
						directItemX = itm;
						break;
				}
			}
			else if ( force == 1 )
			{
				if (game->item[itm])
				{
					switch(slot)
					{
						case 0: //b
							Bwpn = itm;
							game->items_off[itm] = 0;
							game->bwpn = 255;
							game->forced_bwpn = itm;
							directItemB = itm;
							break;
						
						case 1: //a
							Awpn = itm;
							game->items_off[itm] = 0;
							game->awpn = 255;
							game->forced_awpn = itm;
							directItemA = itm;
							break;
						
						case 2: //x
							Xwpn = itm;
							game->items_off[itm] = 0;
							game->xwpn = 255;
							game->forced_xwpn = itm;
							directItemX = itm;
							break;
						
						case 3: //y
							Ywpn = itm;
							game->items_off[itm] = 0;
							game->ywpn = 255;
							game->forced_ywpn = itm;
							directItemY = itm;
							break;
					}
				}
			}
			else if ( force == 2 )
			{
				switch(slot)
				{
					case 0: //b
						Bwpn = itm;
						game->items_off[itm] = 0;
						game->bwpn = 255;
						game->forced_bwpn = itm;
						directItemB = itm;
						break;
					
					case 1: //a
						if (get_qr(qr_SELECTAWPN))
						{
							Awpn = itm;
							game->items_off[itm] = 0;
							game->awpn = 255;
							game->forced_awpn = itm;
							directItemA = itm;
						}
						break;
					
					case 2:  //x
						Xwpn = itm;
						game->items_off[itm] = 0;
						game->xwpn = 255;
						game->forced_xwpn = itm;
						directItemX = itm;
						break;
					
					case 3: //y
						Ywpn = itm;
						game->items_off[itm] = 0;
						game->ywpn = 255;
						game->forced_ywpn = itm;
						directItemY = itm;
						break;
				}
			}
			else if ( force == 3 ) //Flag ITM_REQUIRE_INVENTORY + ITM_REQUIRE_SLOT_A_RULE
			{
				if ( game->item[itm] )
				{
					switch(slot)
					{
						case 0: //b
							Bwpn = itm;
							game->items_off[itm] = 0;
							game->bwpn = 255;
							game->forced_bwpn = itm;
							directItemB = itm;
							break;
						
						case 1: //a
							if (get_qr(qr_SELECTAWPN))
							{
								Awpn = itm;
								game->items_off[itm] = 0;
								game->awpn = 255;
								game->forced_awpn = itm;
								directItemA = itm;
							}
							break;
						
						case 2: //x
							Xwpn = itm;
							game->items_off[itm] = 0;
							game->xwpn = 255;
							game->forced_xwpn = itm;
							directItemX = itm;
							break;
						
						case 3: //y
							Ywpn = itm;
							game->items_off[itm] = 0;
							game->ywpn = 255;
							game->forced_ywpn = itm;
							directItemY = itm;
							break;
					}
				}
			}
		}
		break;
		  
		case LINKINVIS:
			Hero.setDontDraw((value ? 2 : 0));
			break;
			
		case LINKINVINC:
			Hero.scriptcoldet=(value/10000);
			break;
		
		case LINKENGINEANIMATE:
			Hero.do_animation=value;
			break;
			
		case LINKSWORDJINX:
			Hero.setSwordClk(value/10000);
			break;
			
		case LINKITEMJINX:
			Hero.setItemClk(value/10000);
			break;
			
		case LINKDRUNK:
			Hero.setDrunkClock(value/10000);
			break;
			
		case LINKMISCD:
			Hero.miscellaneous[vbound(ri->d[rINDEX]/10000,0,31)] = value; 
			break;
		
		case LINKHITBY:
		{
			int32_t indx = ri->d[rINDEX]/10000;
			switch(indx)
			{
				//screen index objects
				case 0:
				case 1:
				case 2:
				case 3:
				case 8:
				case 9:
				case 10:
				case 11:
				case 12:
				case 16:
				{
					Hero.sethitHeroUID(indx, (value/10000)); //Why the Flidd did I vbound this? UIDs are LONGs, with a starting value of 0.0001. Why did I allow it, in fact? -Z
					break;
				}
				//UIDs
				case 4:
				case 5:
				case 6:
				case 7:
				case 13:
				case 14:
				case 15:
				{
					Hero.sethitHeroUID(indx, value); //Why the Flidd did I vbound this? UIDs are LONGs, with a starting value of 0.0001. Why did I allow it, in fact? -Z
					break;
				}
				default: { al_trace("Invalid index passed to Player->HitBy[%d] /n", indx); break; }
			}
			break;
		}
		
		case LINKDEFENCE:
			Hero.set_defence(vbound(ri->d[rINDEX]/10000,0,255), ((char)vbound((value/10000), 0, 255)));
			break;
			
		case LINKHXOFS:
			(Hero.hxofs)=(zfix)(value/10000);
			break;

		case LINKROTATION:
			if ( get_qr(qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"Player->Rotation");
				break;
			}
			(Hero.rotation)=(value/10000);
			break;
		
		case LINKSCALE:
		{
			if ( get_qr(qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"Player->Scale");
				break;
			}
			(Hero.scale)=(value/100.0);
			//al_trace("Player.scale is: %d\n", Hero.scale);
			//al_trace("Trying to set Player.scale to: %d\n", value/100.0);
			break;
		}

		case LINKHYOFS:
			(Hero.hyofs)=(zfix)(value/10000);
			break;
			
		case LINKXOFS:
			(Hero.xofs)=(zfix)(value/10000);
			break;
			
		case LINKYOFS:
			(Hero.yofs)=(zfix)(value/10000)+(get_qr(qr_OLD_DRAWOFFSET)?playing_field_offset:original_playing_field_offset);
			break;
		case HEROTOTALDYOFFS:
			break; //READ-ONLY
			
		case HEROSHADOWXOFS:
			(Hero.shadowxofs)=(zfix)(value/10000);
			break;
			
		case HEROSHADOWYOFS:
			(Hero.shadowyofs)=(zfix)(value/10000);
			break;
			
		case LINKZOFS:
			(Hero.zofs)=(zfix)(value/10000);
			break;
			
		case LINKHXSZ:
			(Hero.hit_width)=(zfix)(value/10000);
			break;
			
		case LINKHYSZ:
			(Hero.hit_height)=(zfix)(value/10000);
			break;
			
		case LINKHZSZ:
			(Hero.hzsz)=(zfix)(value/10000);
			break;
			
		case LINKTXSZ:
			(Hero.txsz)=(zfix)(value/10000);
			break;
			
		case LINKTYSZ:
			(Hero.tysz)=(zfix)(value/10000);
			break;
			
		case LINKTILE:
			(Hero.tile)=(zfix)(value/10000);
			break;
			
		case LINKFLIP:
			(Hero.flip)=(zfix)(value/10000);
			break;
		
		
		
		case LINKINVFRAME:
			Hero.setHClk( (int32_t)vbound((value/10000), 0, 214747) );
			break;
		
		case LINKCANFLICKER:
			Hero.setCanFlicker((value/10000)?1:0);
			break;
		
		case LINKHURTSFX:
			Hero.setHurtSFX( (int32_t)vbound((value/10000), 0, 255) );
			break;
			
		
		case LINKITEMB:
		{
			if ( value/10000 < -1 ) 
			{
				al_trace("Tried to write an invalid item ID to Player->ItemB: %d\n",value/10000);
				break;
			}		
			if ( value/10000 > MAXITEMS-1 ) 
			{
				al_trace("Tried to write an invalid item ID to Player->ItemB: %d\n",value/10000);
				break;
			}
			//Hero->setBButtonItem(vbound((value/10000),0,(MAXITEMS-1)));
			
			if (Bwpn != (value/10000))
			{
				Bwpn = value/10000;
				if(new_subscreen_active)
					new_subscreen_active->get_page_pos(Bwpn, game->bwpn);
				game->forced_bwpn = value/10000;
				game->items_off[value/10000] = 0;
			}
			directItemB = value/10000;
			break;
		}
		
		
		case LINKITEMA:
		{
			if ( value/10000 < -1 ) 
			{
				Z_scripterrlog("Tried to write an invalid item ID to Player->ItemA: %d\n",value/10000);
				break;
			}		
			if ( value/10000 > MAXITEMS-1 ) 
			{
				Z_scripterrlog("Tried to write an invalid item ID to Player->ItemA: %d\n",value/10000);
				break;
			}		
			//Hero->setBButtonItem(vbound((value/10000),0,(MAXITEMS-1)));
			if (Awpn != (value/10000))
			{
				Awpn = value/10000;
				if(new_subscreen_active)
					new_subscreen_active->get_page_pos(Awpn, game->awpn);
				game->items_off[value/10000] = 0;
				game->forced_awpn = value/10000;
			}
			directItemA = value/10000;
			break;
		}
		
		case LINKITEMX:
		{
			if ( value/10000 < -1 ) 
			{
				Z_scripterrlog("Tried to write an invalid item ID to Player->ItemX: %d\n",value/10000);
				break;
			}		
			if ( value/10000 > MAXITEMS-1 ) 
			{
				Z_scripterrlog("Tried to write an invalid item ID to Player->ItemX: %d\n",value/10000);
				break;
			}		
			//Hero->setBButtonItem(vbound((value/10000),0,(MAXITEMS-1)));
			if (Xwpn != (value/10000))
			{
				Xwpn = value/10000;
				if(new_subscreen_active)
					new_subscreen_active->get_page_pos(Xwpn, game->xwpn);
				game->items_off[value/10000] = 0;
				game->forced_xwpn = value/10000;
			}
			directItemX = value/10000;
			break;
		}
		case LINKITEMY:
		{
			if ( value/10000 < -1 ) 
			{
				Z_scripterrlog("Tried to write an invalid item ID to Player->ItemY: %d\n",value/10000);
				break;
			}		
			if ( value/10000 > MAXITEMS-1 ) 
			{
				Z_scripterrlog("Tried to write an invalid item ID to Player->ItemY: %d\n",value/10000);
				break;
			}		
			//Hero->setBButtonItem(vbound((value/10000),0,(MAXITEMS-1)));
			if (Ywpn != (value/10000))
			{
				Ywpn = value/10000;
				if(new_subscreen_active)
					new_subscreen_active->get_page_pos(Ywpn, game->ywpn);
				game->items_off[value/10000] = 0;
				game->forced_ywpn = value/10000;
			}
			directItemY = value/10000;
			break;
		}


		case LINKEATEN:
			Hero.setEaten(value/10000);
			break;
		case LINKGRABBED:
			Hero.inwallm = value != 0;
			break;
		case HEROBUNNY:
			Hero.setBunnyClock(value/10000);
			break;
		case LINKPUSH:
			Hero.pushing = zc_max((value/10000),0);
			break;
		case LINKSTUN:
			Hero.setStunClock(value/10000);
			break;
		case LINKSCRIPTTILE:
			script_hero_sprite=vbound((value/10000), -1, NEWMAXTILES-1);
			break;
		
		case HEROSCRIPTCSET:
			script_hero_cset=vbound((value/10000), -1, 0xF);
			break;
		case LINKSCRIPFLIP:
			script_hero_flip=vbound((value/10000),-1,256);
			break;
		
		case GAMESETA:
		{
			//int32_t state   = (ri->d[rINDEX2]/10000);
			//int32_t extend = (ri->d[rINDEX2]/10000);
			//int32_t dir = (ri->d[rINDEX]/10000);
			// Z_message("Trying to force-set the A-button item().\n");
			// Hero.setAButtonItem(vbound((value/10000),0,(MAXITEMS-1)));
		}
		break;
		
		case GAMESETB:
		{
			//int32_t state   = (ri->d[rINDEX2]/10000);
			//int32_t extend = (ri->d[rINDEX2]/10000);
			//int32_t dir = (ri->d[rINDEX]/10000);
			// Z_message("Trying to force-set the A-button item().\n");
			// Hero.setBButtonItem(vbound((value/10000),0,(MAXITEMS-1)));
		}
		break;
		
		//Set Hero Diagonal
		case LINKDIAG:
			Hero.setDiagMove(value?1:0);
			set_qr(qr_LTTPWALK, value?1:0);
			break;
		
		//Set Hero Big Hitbox
		case LINKBIGHITBOX:
			Hero.setBigHitbox((value/10000)?1:0);
			set_qr(qr_LTTPCOLLISION, (value/10000)?1:0);
			break;
		
		case LINKCLIMBING:
			Hero.setOnSideviewLadder(value!=0?true:false);
			break;
			
		case HEROJUMPCOUNT:
			Hero.extra_jump_count = value/10000;
			break;
		
		case HEROPULLCLK:
			Hero.pit_pullclk = value/10000;
			break;
		case HEROFALLCLK:
		{
			int32_t val = vbound(value/10000,0,70);
			if(val)
				Hero.setAction(falling);
			else if(Hero.action == falling)
			{
				Hero.setAction(none);
			}
			Hero.fallclk = val;
			break;
		}
		case HEROFALLCMB:
			Hero.fallCombo = vbound(value/10000,0,MAXCOMBOS-1);
			break;
		case HERODROWNCLK:
		{
			int32_t val = vbound(value/10000,0,70);
			if(val)
			{
				if (Hero.action != lavadrowning) Hero.setAction(drowning);
			}
			else if(Hero.action == drowning || Hero.action == lavadrowning)
			{
				Hero.setAction(none);
			}
			Hero.drownclk = val;
			break;
		}
		case HERODROWNCMB:
			Hero.drownCombo = vbound(value/10000,0,MAXCOMBOS-1);
			break;
		case HEROFAKEZ:
			{
				if ( get_qr(qr_SPRITEXY_IS_FLOAT) )
				{
					Hero.setFakeZfix(zslongToFix(value));
				}
				else
				{
					Hero.setFakeZ(value/10000);
				}
			}
			break;
		case HEROMOVEFLAGS:
		{
			int32_t indx = ri->d[rINDEX]/10000;
			if(BC::checkBounds(indx, 0, 10, "Hero->MoveFlags[]") == SH::_NoError)
			{
				//All bits, in order, of a single byte; just use bitwise
				int32_t bit = 1<<indx;
				if(value)
					Hero.moveflags |= bit;
				else
					Hero.moveflags &= ~bit;
			}
			break;
		}
		case HEROLIFTFLAGS:
		{
			int32_t indx = ri->d[rINDEX]/10000;
			if(BC::checkBounds(indx, 0, NUM_LIFTFL-1, "Hero->LiftFlags[]") == SH::_NoError)
			{
				int32_t bit = 1<<indx;
				if(value)
					Hero.liftflags |= bit;
				else
					Hero.liftflags &= ~bit;
			}
			break;
		}
		
		case HEROSHIELDJINX:
			Hero.shieldjinxclk = value/10000;
			break;
		
		case CLOCKACTIVE:
		{
			Hero.setClock(watch=(value?true:false));
			break;
		}
		
		case CLOCKCLK:
			clockclk = vbound((value/10000), 0, 214748);
			break;
		
		case HERORESPAWNX:
		{
			zfix zx = zslongToFix(value);
			Hero.respawn_x = vbound(zx, 0_zf, 240_zf);
			break;
		}
		
		case HERORESPAWNY:
		{
			zfix zy = zslongToFix(value);
			Hero.respawn_y = vbound(zy, 0_zf, 160_zf);
			break;
		}
		
		case HERORESPAWNDMAP:
		{
			Hero.respawn_dmap = vbound(value/10000, 0, MAXDMAPS-1);
			break;
		}
		
		case HERORESPAWNSCR:
		{
			Hero.respawn_scr = vbound(value/10000, 0, 0x7F);
			break;
		}
		
		
		case HEROSWITCHMAXTIMER:
		case HEROSWITCHTIMER:
			break; //read-only
		
		case HEROIMMORTAL:
		{
			Hero.setImmortal(value/10000);
			break;
		}
		
		case HEROCOYOTETIME:
		{
			auto v = value/10000;
			if(v < 0 || v > 65535) v = 65535;
			Hero.coyotetime = word(v);
			break;
		}
		case HEROLIFTEDWPN:
		{
			if(Hero.lift_wpn)
			{
				delete Hero.lift_wpn;
				Hero.lift_wpn = nullptr;
			}
			if(value)
			{
				if(weapon* wpn = checkLWpn(value,"Hero->LiftedWeapon"))
				{
					if(wpn == Hero.lift_wpn) break;
					Hero.lift_wpn = wpn;
					if(Lwpns.find(wpn) > -1)
						Lwpns.remove(wpn);
					if(curScriptType == ScriptType::Lwpn && value == curScriptIndex)
						earlyretval = RUNSCRIPT_SELFREMOVE;
				}
			} 
			break;
		}
		case HEROLIFTTIMER:
		{
			Hero.liftclk = value/10000;
			break;
		}
		case HEROLIFTMAXTIMER:
		{
			Hero.tliftclk = value/10000;
			break;
		}
		case HEROLIFTHEIGHT:
		{
			Hero.liftheight = zslongToFix(value);
			break;
		}
		case HEROHAMMERSTATE:
		{
			//readonly
			break;
		}
		case HEROFLICKERCOLOR:
		{
			Hero.flickercolor = value/10000;
			break;
		}
		case HEROFLICKERTRANSP:
		{
			Hero.flickertransp = value / 10000;
			break;
		}
		case HEROSCRICECMB:
			Hero.script_ice_combo = vbound(value/10000,-1,MAXCOMBOS); break;
		case HEROICEVX:
			Hero.ice_vx = zslongToFix(value); break;
		case HEROICEVY:
			Hero.ice_vy = zslongToFix(value); break;
		case HEROICEENTRYFRAMES:
			Hero.ice_entry_count = vbound(value/10000,0,255); break;
		case HEROICEENTRYMAXFRAMES:
			Hero.ice_entry_mcount = vbound(value/10000,0,255); break;
		
		
	///----------------------------------------------------------------------------------------------------//
	//Input States
		case INPUTSTART:
		{
			control_state[6]=(value?true:false);
			if ( get_qr(qr_FIXDRUNKINPUTS) ) drunk_toggle_state[6]=false;
			break;
		}
			
		case INPUTMAP:
		{
			control_state[9]=(value?true:false);
			if ( get_qr(qr_FIXDRUNKINPUTS) ) 
				drunk_toggle_state[9]=false;
			break;
		}
			
		case INPUTUP:
		{
			control_state[0]=(value?true:false);
			if ( get_qr(qr_FIXDRUNKINPUTS) ) drunk_toggle_state[0]=false;
			break;
		}
			
		case INPUTDOWN:
		{
			control_state[1]=(value?true:false);
			if ( get_qr(qr_FIXDRUNKINPUTS) ) 
				drunk_toggle_state[1]=false;
			break;
		}
			
		case INPUTLEFT:
		{
			control_state[2]=(value?true:false);
			if ( get_qr(qr_FIXDRUNKINPUTS) ) drunk_toggle_state[2]=false;
			break;
		}
			
		case INPUTRIGHT:
		{
			control_state[3]=(value?true:false);
			if ( get_qr(qr_FIXDRUNKINPUTS) ) drunk_toggle_state[3]=false;
			break;
		}
			
		case INPUTA:
		{
			control_state[4]=(value?true:false);
			if ( get_qr(qr_FIXDRUNKINPUTS) ) drunk_toggle_state[4]=false;
			break;
		}
			
		case INPUTB:
		{
			control_state[5]=(value?true:false);
			if ( get_qr(qr_FIXDRUNKINPUTS) ) drunk_toggle_state[5]=false;
			break;
		}
			
		case INPUTL:
		{
			control_state[7]=(value?true:false);
			if ( get_qr(qr_FIXDRUNKINPUTS) ) drunk_toggle_state[7]=false;
			break;
		}
			
		case INPUTR:
		{
			control_state[8]=(value?true:false);
			if ( get_qr(qr_FIXDRUNKINPUTS) ) drunk_toggle_state[8]=false;
			break;
		}
			
		case INPUTEX1:
		{
			control_state[10]=(value?true:false);
			break;
		}
			
		case INPUTEX2:
			control_state[11]=(value?true:false);
			break;
			
		case INPUTEX3:
			control_state[12]=(value?true:false);
			break;
			
		case INPUTEX4:
			control_state[13]=(value?true:false);
			break;
			
		case INPUTAXISUP:
			control_state[14]=(value?true:false);
			break;
			
		case INPUTAXISDOWN:
			control_state[15]=(value?true:false);
			break;
			
		case INPUTAXISLEFT:
			control_state[16]=(value?true:false);
			break;
			
		case INPUTAXISRIGHT:
			control_state[17]=(value?true:false);
			break;
			
		case INPUTPRESSSTART:
			button_press[6]=(value?true:false);
			break;
			
		case INPUTPRESSMAP:
			button_press[9]=(value?true:false);
			break;
			
		case INPUTPRESSUP:
			button_press[0]=(value?true:false);
			break;
			
		case INPUTPRESSDOWN:
			button_press[1]=(value?true:false);
			break;
			
		case INPUTPRESSLEFT:
			button_press[2]=(value?true:false);
			break;
			
		case INPUTPRESSRIGHT:
			button_press[3]=(value?true:false);
			break;
			
		case INPUTPRESSA:
			button_press[4]=(value?true:false);
			break;
			
		case INPUTPRESSB:
			button_press[5]=(value?true:false);
			break;
			
		case INPUTPRESSL:
			button_press[7]=(value?true:false);
			break;
			
		case INPUTPRESSR:
			button_press[8]=(value?true:false);
			break;
			
		case INPUTPRESSEX1:
			button_press[10]=(value?true:false);
			break;
			
		case INPUTPRESSEX2:
			button_press[11]=(value?true:false);
			break;
			
		case INPUTPRESSEX3:
			button_press[12]=(value?true:false);
			break;
			
		case INPUTPRESSEX4:
			button_press[13]=(value?true:false);
			break;
			
		case INPUTPRESSAXISUP:
			button_press[14]=(value?true:false);
			break;
			
		case INPUTPRESSAXISDOWN:
			button_press[15]=(value?true:false);
			break;
			
		case INPUTPRESSAXISLEFT:
			button_press[16]=(value?true:false);
			break;
			
		case INPUTPRESSAXISRIGHT:
			button_press[17]=(value?true:false);
			break;
			
		case INPUTMOUSEX:
		{
			auto [x, y] = rti_game.local_to_world(value/10000, mouse_y);
			position_mouse(x, y);
			break;
		}
		
		case INPUTMOUSEY:
		{
			int32_t mousequakeoffset = 56+((int32_t)(zc::math::Sin((double)(quakeclk*int64_t(2)-frame))*4));
			int32_t tempoffset = (quakeclk > 0) ? mousequakeoffset : (get_qr(qr_OLD_DRAWOFFSET)?playing_field_offset:original_playing_field_offset);
			auto [x, y] = rti_game.local_to_world(mouse_x, value/10000 + tempoffset);
			position_mouse(x, y);
			break;
		}
		
		case INPUTMOUSEZ:
			position_mouse_z(value/10000);
			break;
		
		case FFRULE:
		{
			int32_t ruleid = vbound((ri->d[rINDEX]/10000),0,qr_MAX);
			set_qr(ruleid, (value?true:false));
			switch(ruleid)
			{
				case qr_LTTPWALK:
					Hero.setDiagMove(value?1:0);
					break;
				case qr_LTTPCOLLISION:
					Hero.setBigHitbox(value?1:0);
					break;
				case qr_ZS_NO_NEG_ARRAY:
					can_neg_array = !value;
					break;
			}
		}
		break;
		
		case BUTTONPRESS:
			// DUkey, DDkey, DLkey, DRkey, Akey, Bkey, Skey, Lkey, Rkey, Pkey, Exkey1, Exkey2, Exkey3, Exkey4 };
		{
			//Read-only
			int32_t button = vbound((ri->d[rINDEX]/10000),0,17);
			button_press[button]=(value?true:false);
			if ( button < 11 && get_qr(qr_FIXDRUNKINPUTS) ) drunk_toggle_state[button]=false;
			
		}
		break;

		case BUTTONINPUT:
		{
			//Read-only
			int32_t button = vbound((ri->d[rINDEX]/10000),0,17);
			control_state[button]=(value?true:false);
			if ( button < 11 && get_qr(qr_FIXDRUNKINPUTS) ) drunk_toggle_state[button]=false;
		}
		break;

		case BUTTONHELD:
		{
			//Read-only
			int32_t button = vbound((ri->d[rINDEX]/10000),0,17);
			button_hold[button]=(value?true:false);
		}
		break;

		case RAWKEY:
		{	//Game->KeyPressed[], read-only
			//if ( !keypressed() ) break; //Don;t return values set by setting Hero->Input/Press
			//hmm...no, this won;t return properly for modifier keys. 
			int32_t keyid = ri->d[rINDEX]/10000;
			//key = vbound(key,0,n);
			_key[keyid]=key[keyid]=key_current_frame[keyid]=(value?true:false); //It isn't possible to set keys true, because polling occurs before they are set?
			//but they *can* be set false; ??? -Z
		}
		break;
		
		case KEYINPUT:
		{
			KeyInput[ri->d[rINDEX]/10000] = (value/10000)!=0;
			switch(ri->d[rINDEX]/10000)
			{
				case KEY_F6: onTryQuit(); break;
				case KEY_F3: Paused = !Paused; break;
				case KEY_F4: Paused = true; Advance = true; break;
			}
			break;
		}
		case KEYPRESS:
		{
			KeyPress[ri->d[rINDEX]/10000] = (value/10000)!=0;
			break;
		}
		
		case SIMULATEKEYPRESS:
		{	//Game->KeyPressed[], read-only
			//if ( !keypressed() ) break; //Don;t return values set by setting Hero->Input/Press
			//hmm...no, this won;t return properly for modifier keys. 
			int32_t keyid = ri->d[rINDEX]/10000;
			//key = vbound(key,0,n);
			if (value/10000) simulate_keypress(keyid << 8);
		}
		break;
		
		case KEYMODIFIERS:
		{
			key_shifts = ( value/10000 );
			break;
		}
		
		case KEYBINDINGS:
		{
			int32_t keyid = ri->d[rINDEX]/10000;
			switch(keyid)
			{
				case 0: DUkey = ( value/10000 ); break;
				case 1: DDkey = ( value/10000 ); break; 
				case 2: DLkey = ( value/10000 ); break;
				case 3: DRkey = ( value/10000 ); break;
				case 4: Akey = ( value/10000 ); break;
				case 5: Bkey = ( value/10000 ); break;
				case 6: Skey = ( value/10000 ); break;
				case 7: Lkey = ( value/10000 ); break;
				case 8: Rkey = ( value/10000 ); break;
				case 9: Pkey = ( value/10000 ); /*map*/ break; 
				case 10: Exkey1 = ( value/10000 ); break;
				case 11: Exkey2 = ( value/10000 ); break;
				case 12: Exkey3 = ( value/10000 ); break;
				case 13: Exkey4 = ( value/10000 ); break;
				
				default: { Z_scripterrlog("Invalid index [%d] passed to Input->KeyBindings[]\n", keyid); break; }
			}
			break;
		}
		
		case DISABLEKEY:
		{
			//Input->DisableKey(int32_t key, bool disable)
			int32_t keyid = ri->d[rINDEX]/10000;
			if(!zc_disablekey(keyid, value))
			{
				//Z_scripterrlog("The key %d passed to Input->DisableKey[] is system-reserved, and cannot be disabled\n",keyid);
			}
			break;
		}
		
		case DISABLEBUTTON:
		{
			//Input->DisableButton(int32_t cb, bool disable)
			int32_t cbid = ri->d[rINDEX]/10000;
			disable_control[cbid] = value?true:false;
			break;
		}
		
		case MOUSEARR:
		{	
			int32_t indx = (ri->d[rINDEX]/10000);
			switch (indx)
			{
				case 0: //MouseX
				{
					auto [x, y] = rti_game.local_to_world(value/10000, mouse_y);
					position_mouse(x, y);
					break;	
				}
				case 1: //MouseY
				{
					int32_t mousequakeoffset = 56+((int32_t)(zc::math::Sin((double)(quakeclk*int64_t(2)-frame))*4));
					int32_t tempoffset = (quakeclk > 0) ? mousequakeoffset :(get_qr(qr_OLD_DRAWOFFSET)?playing_field_offset:original_playing_field_offset);
					auto [x, y] = rti_game.local_to_world(mouse_x, value/10000 + tempoffset);
					position_mouse(x, y);
					break;
					
				}
				case 2: //MouseZ
				{
					position_mouse_z(value/10000);
					break;
				}
				case 3: //Left Click
				{
					if ( value ) mouse_b |= 1;
					else mouse_b &= ~1;
					break;
				}
				case 4: //Right Click
				{
					if ( value ) mouse_b |= 2;
					else mouse_b &= ~2;
					break;
				}
				case 5: //Middle Click
				{
					if ( value ) mouse_b |= 4;
					else mouse_b &= ~4;
					break;
				}
				default:
				{
					Z_scripterrlog("Invalid index passed to Input->Mouse[]: %d\n", indx);
				}
			}
				
		}
		break;
			
			
	///----------------------------------------------------------------------------------------------------//
	//Item Variables
		
		case ITEMFAMILY:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->family)=value/10000;
			}
			
			break;
		
		case ITEMLEVEL:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->lvl)=value/10000;
			}
			
			break;
			
		case SPRITEMAXITEM:
		{
			//No bounds check, as this is a universal function and works from NULL pointers!
			items.setMax(vbound((value/10000),1,MAX_ITEM_SPRITES));
			break;
		}
		
		case ITEMX:
			if(0!=(s=checkItem(ri->itemref)))
			{
				s->x = get_qr(qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000);
				
				// Move the Fairy enemy as well.
				if(itemsbuf[s->id].family==itype_fairy && itemsbuf[s->id].misc3)
				{
					enemy* fairy = (enemy*) guys.getByUID(((item*)(s))->fairyUID);
					if (fairy)
						fairy->x = s->x;
				}
			}
			break;

		case ITEMY:
			if(0!=(s=checkItem(ri->itemref)))
			{
				s->y = get_qr(qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000);
				
				// Move the Fairy enemy as well.
				if(itemsbuf[s->id].family==itype_fairy && itemsbuf[s->id].misc3)
				{
					enemy* fairy = (enemy*) guys.getByUID(((item*)(s))->fairyUID);
					if (fairy)
						fairy->y = s->y;
				}
			}
			break;
		
		case ITEMSPRITESCRIPT:
			FFScript::deallocateAllScriptOwned(ScriptType::ItemSprite, ri->itemref);
			if(0!=(s=checkItem(ri->itemref)))
			{
				(s->script)=(value/10000);
			}
			break;
		
		case ITEMSCALE:
			if ( get_qr(qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"item->Scale");
				break;
			}
			if(0!=(s=checkItem(ri->itemref)))
			{
				(s->scale)=(zfix)(value/100.0);
			}
			
			break;
			
		case ITEMZ:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(s->z)=(zfix)(value/10000);
				
				if(s->z < 0)
					s->z = 0;
			}
			
			break;
			
		case ITEMJUMP:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->fall)=zslongToFix(value)*-100;
			}
			
			break;
		
		case ITEMFAKEJUMP:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->fakefall)=zslongToFix(value)*-100;
			}
			
			break;
			
		case ITEMDRAWTYPE:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->drawstyle)=value/10000;
			}
			
			break;
			
		 case ITEMSPRITEINITD:
			if(0!=(s=checkItem(ri->itemref)))
			{
				int32_t a = vbound(ri->d[rINDEX]/10000,0,7);
				(((item *)s)->initD[a])=value;
			}
			
			break;
			
		case ITEMGRAVITY:
			if(0!=(s=checkItem(ri->itemref)))
			{
				if(value)
					((item *)s)->moveflags |= FLAG_OBEYS_GRAV;
				else
					((item *)s)->moveflags &= ~FLAG_OBEYS_GRAV;
			}
			
			break;
			
		case ITEMID:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->id)=value/10000;
				flushItemCache();
			}
			
			break;
			
		case ITEMTILE:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->tile)=vbound(value/10000,0,NEWMAXTILES-1);
			}
			
			break;
			
		case ITEMSCRIPTTILE:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->scripttile)=vbound(value/10000,-1,NEWMAXTILES-1);
			}
			break;
			
		case ITEMSCRIPTFLIP:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->scriptflip)=vbound((value/10000),-1,127);
			}
			break;
		
		case ITEMPSTRING:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->pstring)=vbound(value/10000,0,(msg_count-1));
			}
			
			break;
		
		case ITEMPSTRINGFLAGS:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->pickup_string_flags)=vbound(value/10000, 0, 214748);
			}
			
			break;
		
		case ITEMOVERRIDEFLAGS:
			break;
			
		case ITEMOTILE:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->o_tile)=vbound(value/10000,0,NEWMAXTILES-1);
			}
			
			break;
			
		case ITEMCSET:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->o_cset) = (((item *)s)->o_cset & ~15) | ((value/10000)&15);
				(((item *)s)->cs) = (((item *)s)->o_cset & 15);
			}
			
			break;
			
		case ITEMFLASHCSET:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->o_cset) = ((value/10000)<<4) | (((item *)s)->o_cset & 15);
			}
			
			break;
			
		case ITEMFRAMES:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->frames)=value/10000;
			}
			
			break;
			
		case ITEMFRAME:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->aframe)=value/10000;
			}
			
			break;
			
		case ITEMASPEED:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->o_speed)=value/10000;
			}
			
			break;
		
		 case ITEMACLK:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->aclk)=value/10000;
			}
			
			break;
		
		case ITEMDELAY:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->o_delay)=value/10000;
			}
			
			break;
			
		case ITEMFLIP:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->flip)=value/10000;
			}
			
			break;
			
		case ITEMFLASH:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->flash)= (value/10000)?1:0;
			}
			
			break;
			
		case ITEMEXTEND:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->extend)=value/10000;
			}
			
			break;
			
		case ITEMHXOFS:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->hxofs=value/10000;
			}
			
			break;
			
		case ITEMROTATION:
			if ( get_qr(qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"item->Rotation");
				break;
			}
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->rotation=value/10000;
			}
			
			break;
			
		case ITEMHYOFS:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->hyofs=value/10000;
			}
			
			break;
			
		case ITEMXOFS:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->xofs=(zfix)(value/10000);
			}
			
			break;
			
		case ITEMYOFS:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->yofs=(zfix)(value/10000)+(get_qr(qr_OLD_DRAWOFFSET)?playing_field_offset:original_playing_field_offset);
			}
			
			break;
			
		case ITEMSHADOWXOFS:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->shadowxofs=(zfix)(value/10000);
			}
			
			break;
		
		case ITEMSHADOWYOFS:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->shadowyofs=(zfix)(value/10000);
			}
			
			break;
		
		case ITEMZOFS:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->zofs=(zfix)(value/10000);
			}
			
			break;
			
		case ITEMHXSZ:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->hit_width=value/10000;
			}
			
			break;
			
		case ITEMHYSZ:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->hit_height=value/10000;
			}
			
			break;
			
		case ITEMHZSZ:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->hzsz=value/10000;
			}
			
			break;
			
		case ITEMTXSZ:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->txsz=vbound((value/10000),1,20);
			}
			
			break;
			
		case ITEMTYSZ:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->tysz=vbound((value/10000),1,20);
			}
			
			break;
			
		case ITEMPICKUP:
			if(0!=(s=checkItem(ri->itemref)))
			{
				int32_t newpickup = value/10000;
				// Values that the questmaker should not use, ever
				//Allowing it, for now, until something breaks. -Z 21-Jan-2020
				//newpickup &= ~(ipBIGRANGE | ipCHECK | ipMONEY | ipBIGTRI | ipNODRAW | ipFADE);
				//
				if (( FFCore.GetQuestVersion() == 0x250 && FFCore.GetQuestBuild() < 33 ) //this ishowit looks in 2.53.1, Beta 25
					|| ( FFCore.GetQuestVersion() < 0x250  ))
				{
					newpickup &= ~(ipBIGRANGE | ipCHECK | ipMONEY | ipBIGTRI | ipNODRAW | ipFADE);
				}
				
				// If making an item timeout, set its timer
				if(newpickup & ipFADE)
				{
					(((item*)(s))->clk2) = 512;
				}
				//else if(newpickup & ~ipFADE)
				//{
				//    (((item*)(s))->clk2) = 0;
				//}
				
				// If making it a carried item,
				// alter hasitem and set an itemguy.
				if((((item*)(s))->pickup & ipENEMY) < (newpickup & ipENEMY))
				{
					hasitem |= 2;
					bool hasitemguy = false;
					
					for(int32_t i=0; i<guys.Count(); i++)
					{
						if(((enemy*)guys.spr(i))->itemguy)
						{
							hasitemguy = true;
						}
					}
					
					if(!hasitemguy && guys.Count()>0)
					{
						((enemy*)guys.spr(guys.Count()-1))->itemguy = true;
					}
				}
				// If unmaking it a carried item,
				// alter hasitem if there are no more carried items.
				else if((((item*)(s))->pickup & ipENEMY) > (newpickup & ipENEMY))
				{
					// Move it back onscreen!
					if(get_qr(qr_HIDECARRIEDITEMS))
					{
						for(int32_t i=0; i<guys.Count(); i++)
						{
							if(((enemy*)guys.spr(i))->itemguy)
							{
								if (!get_qr(qr_BROKEN_ITEM_CARRYING))
								{
									if (get_qr(qr_ENEMY_DROPS_USE_HITOFFSETS))
									{
										((item*)(s))->x = ((enemy*)guys.spr(i))->x+((enemy*)guys.spr(i))->hxofs+(((enemy*)guys.spr(i))->hit_width/2)-8;
										((item*)(s))->y = ((enemy*)guys.spr(i))->y+((enemy*)guys.spr(i))->hyofs+(((enemy*)guys.spr(i))->hit_height/2)-10;
										((item*)(s))->z = ((enemy*)guys.spr(i))->z;
									}
									else
									{
										if(((enemy*)guys.spr(i))->extend >= 3) 
										{
											((item*)(s))->x = ((enemy*)guys.spr(i))->x+(((enemy*)guys.spr(i))->txsz-1)*8;
											((item*)(s))->y = ((enemy*)guys.spr(i))->y-2+(((enemy*)guys.spr(i))->tysz-1)*8;
											((item*)(s))->z = ((enemy*)guys.spr(i))->z;
										}
										else 
										{
											((item*)(s))->x = ((enemy*)guys.spr(i))->x;
											((item*)(s))->y = ((enemy*)guys.spr(i))->y - 2;
											((item*)(s))->z = ((enemy*)guys.spr(i))->z;
										}
									}
								}
								else
								{
									((item*)(s))->x = ((enemy*)guys.spr(i))->x;
									((item*)(s))->y = ((enemy*)guys.spr(i))->y - 2;
									((item*)(s))->z = ((enemy*)guys.spr(i))->z;
								}
								break;
							}
						}
					}
					
					if(more_carried_items()<=1)  // 1 includes this own item.
					{
						hasitem &= ~2;
					}
				}
				
				((item*)(s))->pickup=value/10000;
			}
			
			break;
			
		case ITEMMISCD:
			if(0!=(s=checkItem(ri->itemref)))
			{
				int32_t a = vbound(ri->d[rINDEX]/10000,0,31);
				(((item*)(s))->miscellaneous[a])=value;
			}
			
			break;
		case ITEMFALLCLK:
			if(0!=(s=checkItem(ri->itemref)))
			{
				if(((item*)(s))->fallclk != 0 && value == 0)
				{
					((item*)(s))->cs = ((item*)(s))->old_cset;
					((item*)(s))->tile = ((item*)(s))->o_tile;
				}
				else if(((item*)(s))->fallclk == 0 && value != 0) ((item*)(s))->old_cset = ((item*)(s))->cs;
				((item*)(s))->fallclk = vbound(value/10000,0,70);
			}
			break;
		case ITEMFALLCMB:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->fallCombo = vbound(value/10000,0,MAXCOMBOS-1);
			}
			break;
		case ITEMDROWNCLK:
			if(0!=(s=checkItem(ri->itemref)))
			{
				if(((item*)(s))->drownclk != 0 && value == 0)
				{
					((item*)(s))->cs = ((item*)(s))->old_cset;
					((item*)(s))->tile = ((item*)(s))->o_tile;
				}
				else if(((item*)(s))->drownclk == 0 && value != 0) ((item*)(s))->old_cset = ((item*)(s))->cs;
				((item*)(s))->drownclk = vbound(value/10000,0,70);
			}
			break;
		case ITEMDROWNCMB:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->drownCombo = vbound(value/10000,0,MAXCOMBOS-1);
			}
			break;
		case ITEMFAKEZ:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(s->fakez)=(zfix)(value/10000);
				
				if(s->fakez < 0)
					s->fakez = 0;
			}
			
			break;
		
		case ITEMMOVEFLAGS:
		{
			if(0!=(s=checkItem(ri->itemref)))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(BC::checkBounds(indx, 0, 10, "itemsprite->MoveFlags[]") == SH::_NoError)
				{
					//All bits, in order, of a single byte; just use bitwise
					int32_t bit = 1<<indx;
					if(value)
						((item*)(s))->moveflags |= bit;
					else
						((item*)(s))->moveflags &= ~bit;
				}
			}
			break;
		}
		
		case ITEMGLOWRAD:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->glowRad = vbound(value/10000,0,255);
			}
			break;
			
		case ITEMGLOWSHP:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->glowShape = vbound(value/10000,0,255);
			}
			break;
			
		case ITEMDIR:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->dir=(value/10000);
			}
			break;
			
		case ITEMENGINEANIMATE:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->do_animation=value;
			}
			break;
			
		case ITEMSHADOWSPR:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->spr_shadow=vbound(value/10000,0,255);
			}
			break;
		case ITEMDROPPEDBY:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->from_dropset=vbound(value/10000,-1,255);
			}
			break;
		case ITMSWHOOKED:
			break; //read-only
		case ITEMFORCEGRAB:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->set_forcegrab(value!=0);
			}
			break;
		case ITEMNOSOUND:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->noSound = (value!=0);
			}
			break;
		case ITEMNOHOLDSOUND:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->noHoldSound = (value!=0);
			}
			break;
			
	///----------------------------------------------------------------------------------------------------//
	//Itemdata Variables
		//not mine, but let;s guard some of them all the same -Z
		//item class
		case IDATAFAMILY:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].family)=vbound(value/10000,0, 254);
			flushItemCache();
			break;
		
		case IDATAUSEWPN:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].useweapon)=vbound(value/10000, 0, 255);
			break;
		case IDATAUSEDEF:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].usedefence)=vbound(value/10000, 0, 255);
			break;
		case IDATAWRANGE:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].weaprange)=vbound(value/10000, 0, 255);
			break;
		case IDATAMAGICTIMER:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].magiccosttimer[0])=vbound(value/10000, 0, 214747);
			break;
		case IDATAMAGICTIMER2:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].magiccosttimer[1])=vbound(value/10000, 0, 214747);
			break;
		case IDATADURATION:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].weapduration)=vbound(value/10000, 0, 255);
			break;
		 
		case IDATADUPLICATES:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].duplicates)=vbound(value/10000, 0, 255);
			break;
		case IDATADRAWLAYER:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].drawlayer)=vbound(value/10000, 0, 7);
			break;
		case IDATACOLLECTFLAGS:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			//int32_t a = ri->d[rINDEX] / 10000;
			(itemsbuf[ri->idata].collectflags)=vbound(value/10000, 0, 214747);
			break;
		case IDATAWEAPONSCRIPT:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].weaponscript)=vbound(value/10000, 0, 255);
			break;
		case IDATAMISCD:
		{
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			int32_t a = vbound((ri->d[rINDEX] / 10000),0,31);
			(itemsbuf[ri->idata].wpn_misc_d[a])=(value/10000);
		}
		break;
		case IDATAWPNINITD:
		{
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			int32_t a = vbound((ri->d[rINDEX] / 10000),0,7);
			(itemsbuf[ri->idata].weap_initiald[a])=(value);
		}
		break;
		case IDATAWEAPHXOFS:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].weap_hxofs)=(value/10000);
			break;
		case IDATAWEAPHYOFS:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].weap_hyofs)=(value/10000);
			break;
		case IDATAWEAPHXSZ:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].weap_hxsz)=(value/10000);
			break;
		case IDATAWEAPHYSZ:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].weap_hysz)=(value/10000);
			break;
		case IDATAWEAPHZSZ:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].weap_hzsz)=(value/10000);
			break;
		case IDATAWEAPXOFS:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].weap_xofs)=(value/10000);
			break;
		case IDATAWEAPYOFS:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].weap_yofs)=(value/10000);
			break;

		
		case IDATAHXOFS:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].hxofs)=(value/10000);
			break;
		case IDATAHYOFS:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].hyofs)=(value/10000);
			break;
		case IDATAHXSZ:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].hxsz)=(value/10000);
			break;
		case IDATAHYSZ:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].hysz)=(value/10000);
			break;
		case IDATAHZSZ:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].hzsz)=(value/10000);
			break;
		case IDATADXOFS:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].xofs)=(value/10000);
			break;
		case IDATADYOFS:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].yofs)=(value/10000);
			break;
		case IDATATILEW:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].tilew)=(value/10000);
			break;
		case IDATATILEH:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].tileh)=(value/10000);
			break;
		case IDATAPICKUP:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].pickup)=(value/10000);
			break;
		case IDATAOVERRIDEFL:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].overrideFLAGS)=(value/10000);
			break;

		case IDATATILEWWEAP:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].weap_tilew)=(value/10000);
			break;
		case IDATATILEHWEAP:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].weap_tileh)=(value/10000);
			break;
		case IDATAOVERRIDEFLWEAP:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].weapoverrideFLAGS)=(value/10000);
			break;
		
		case IDATAUSEMVT:
		{
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			int32_t a = vbound((ri->d[rINDEX] / 10000),0,(ITEM_MOVEMENT_PATTERNS-1));
			(itemsbuf[ri->idata].weap_pattern[a])=vbound(value/10000, 0, 255);
			break;
		}
		
		case IDATALEVEL:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].fam_type)=vbound(value/10000, 0, 512);
			flushItemCache();
			break;
		case IDATAKEEP:
			item_flag(ITEM_GAMEDATA, value);
			break;
		case IDATAAMOUNT:
		{
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			int32_t v = vbound(value/10000, -9999, 16383);
			itemsbuf[ri->idata].amount &= 0x8000;
			itemsbuf[ri->idata].amount |= (abs(v)&0x3FFF)|(v<0?0x4000:0);
			break;
		}
		case IDATAGRADUAL:
		{
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			SETFLAG(itemsbuf[ri->idata].amount, 0x8000, value!=0);
			break;
		}
		case IDATACONSTSCRIPT:
			item_flag(ITEM_PASSIVESCRIPT, value);
			break;
		case IDATASSWIMDISABLED:
			item_flag(ITEM_SIDESWIM_DISABLED, value);
			break;
		case IDATABUNNYABLE:
			item_flag(ITEM_BUNNY_ENABLED, value);
			break;
		case IDATAJINXIMMUNE:
			item_flag(ITEM_JINX_IMMUNE, value);
			break;
		case IDATAJINXSWAP:
			item_flag(ITEM_FLIP_JINX, value);
			break;
		case IDATAUSEBURNSPR:
			item_flag(ITEM_BURNING_SPRITES, value);
			break;
		case IDATASETMAX:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].setmax)=value/10000;
			break;
			
		case IDATAMAX:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].max)=value/10000;
			break;
			
		case IDATAPOWER:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].power)=value/10000;
			break;
			
		case IDATACOUNTER:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].count)=vbound(value/10000,0,31);
			break;
			
		case IDATAPSOUND:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].playsound)=vbound(value/10000, 0, 255);
			break;
			
		case IDATAUSESOUND:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].usesound)=vbound(value/10000, 0, 255);
			break;
			
		case IDATAUSESOUND2:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].usesound2)=vbound(value/10000, 0, 255);
			break;
		
		//2.54
		//My additions begin here. -Z
		//Stack item to gain next level
		case IDATACOMBINE:
			item_flag(ITEM_COMBINE, value);
			break;
		//using a level of an item downgrades to a lower one
		case IDATADOWNGRADE:
			item_flag(ITEM_DOWNGRADE, value);
			break;
		  //Only validate the cost, don't charge it
		case IDATAVALIDATE:
			item_flag(ITEM_VALIDATEONLY, value);
			break;
		case IDATAVALIDATE2:
			item_flag(ITEM_VALIDATEONLY2, value);
			break;
		
		//Flags[5]
		case IDATAFLAGS:
		{
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			int32_t index = ri->d[rINDEX]/10000;
			switch(index)
			{
				case 0:
					SETFLAG(itemsbuf[ri->idata].flags, ITEM_FLAG1, value);
					break;
				case 1:
					SETFLAG(itemsbuf[ri->idata].flags, ITEM_FLAG2, value);
					break;
				case 2:
					SETFLAG(itemsbuf[ri->idata].flags, ITEM_FLAG3, value);
					break;
				case 3:
					SETFLAG(itemsbuf[ri->idata].flags, ITEM_FLAG4, value);
					break;
				case 4:
					SETFLAG(itemsbuf[ri->idata].flags, ITEM_FLAG5, value);
					break;
				case 5:
					SETFLAG(itemsbuf[ri->idata].flags, ITEM_FLAG6, value);
					break;
				case 6:
					SETFLAG(itemsbuf[ri->idata].flags, ITEM_FLAG7, value);
					break;
				case 7:
					SETFLAG(itemsbuf[ri->idata].flags, ITEM_FLAG8, value);
					break;
				case 8:
					SETFLAG(itemsbuf[ri->idata].flags, ITEM_FLAG9, value);
					cache_tile_mod_clear();
					break;
				case 9:
					SETFLAG(itemsbuf[ri->idata].flags, ITEM_FLAG10, value);
					break;
				case 10:
					SETFLAG(itemsbuf[ri->idata].flags, ITEM_FLAG11, value);
					break;
				case 11:
					SETFLAG(itemsbuf[ri->idata].flags, ITEM_FLAG12, value);
					break;
				case 12:
					SETFLAG(itemsbuf[ri->idata].flags, ITEM_FLAG13, value);
					break;
				case 13:
					SETFLAG(itemsbuf[ri->idata].flags, ITEM_FLAG14, value);
					break;
				case 14:
					SETFLAG(itemsbuf[ri->idata].flags, ITEM_FLAG15, value);
					break;
				case 15:
					SETFLAG(itemsbuf[ri->idata].flags, ITEM_PASSIVESCRIPT, value);
					break;
			}
				
			break;
		}
		//Keep Old in editor
		case IDATAKEEPOLD:
			item_flag(ITEM_KEEPOLD, value);
			break;
		//Ruppes for magic
		case IDATARUPEECOST:
			item_flag(ITEM_RUPEE_MAGIC, value);
			break;
		//can be eaten
		case IDATAEDIBLE:
			item_flag(ITEM_EDIBLE, value);
			break;
		//Unused at this time
		case IDATAFLAGUNUSED:
			item_flag(ITEM_UNUSED, value);
			break;
		//gain lower level items
		case IDATAGAINLOWER:
			item_flag(ITEM_GAINOLD, value);
			break;
		//Set the action script
		case IDATASCRIPT:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			FFScript::deallocateAllScriptOwned(ScriptType::Item, ri->idata);
			itemsbuf[ri->idata].script=vbound(value/10000,0,255);
			break;
		case IDATASPRSCRIPT:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			itemsbuf[ri->idata].sprite_script=vbound(value/10000,0,255);
			break;
		
		/*
		case ITEMMISCD:
			if(0!=(s=checkItem(ri->itemref)))
			{
				int32_t a = vbound(ri->d[rINDEX]/10000,0,31);
				(((item*)(s))->miscellaneous[a])=value;
			}
			
			break;*/
		//Attributes[10]
		case IDATAATTRIB:
		case IDATAATTRIB_L:
		{
			int val = value/((arg==IDATAATTRIB_L)?1:10000);
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			int32_t index = vbound(ri->d[rINDEX]/10000,0,9);
			switch(index)
			{
				case 0:
					itemsbuf[ri->idata].misc1=val;
					break;
				case 1:
					itemsbuf[ri->idata].misc2=val; break;
				case 2:
					itemsbuf[ri->idata].misc3=val; break;
				case 3:
					itemsbuf[ri->idata].misc4=val; break;
				case 4:
					itemsbuf[ri->idata].misc5=val; break;
				case 5:
					itemsbuf[ri->idata].misc6=val; break;
				case 6:
					itemsbuf[ri->idata].misc7=val; break;
				case 7:
					itemsbuf[ri->idata].misc8=val; break;
				case 8:
					itemsbuf[ri->idata].misc9=val; break;
				case 9:
					itemsbuf[ri->idata].misc10=val; break;

				default: 
					break;
			}
				
			break;
		}
		//SpriteSprites[10]
		case IDATASPRITE:
		{
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			int32_t index = ri->d[rINDEX]/10000;
			byte val = vbound(value/10000, 0, 255);
			switch(index)
			{
				case 0:
					itemsbuf[ri->idata].wpn = val; break;
				case 1:
					itemsbuf[ri->idata].wpn2 = val; break;
				case 2:
					itemsbuf[ri->idata].wpn3 = val; break;
				case 3:
					itemsbuf[ri->idata].wpn4 = val; break;
				case 4:
					itemsbuf[ri->idata].wpn5 = val; break;
				case 5:
					itemsbuf[ri->idata].wpn6 = val; break;
				case 6:
					itemsbuf[ri->idata].wpn7 = val; break;
				case 7:
					itemsbuf[ri->idata].wpn8 = val; break;
				case 8:
					itemsbuf[ri->idata].wpn9 = val; break;
				case 9:
					itemsbuf[ri->idata].wpn10 = val; break;
				default:
					Z_scripterrlog("Invalid index to itemdata->Sprites[]: %d\n", index);
					break;
			}
			break;
		}
		case IDATABURNINGSPR:
		{
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			int32_t index = ri->d[rINDEX]/10000;
			if(index < 0 || index >= BURNSPR_MAX)
			{
				Z_scripterrlog("Invalid index to itemdata->BurnSprites[]: %d\n", index);
				break;
			}
			itemsbuf[ri->idata].burnsprs[index] = vbound(value/10000, 0, 255);
			break;
		}
		case IDATABURNINGLIGHTRAD:
		{
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			int32_t index = ri->d[rINDEX]/10000;
			if(index < 0 || index >= BURNSPR_MAX)
			{
				Z_scripterrlog("Invalid index to itemdata->BurnLightRadius[]: %d\n", index);
				break;
			}
			itemsbuf[ri->idata].light_rads[index] = vbound(value/10000, 0, 255);
			break;
		}
		//Hero tile modifier. 
		case IDATALTM:
		{
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			auto new_value = value/10000;
			if (new_value != itemsbuf[ri->idata].ltm)
				cache_tile_mod_clear();
			itemsbuf[ri->idata].ltm = new_value;
			break;
		}
		//Pickup script
		case IDATAPSCRIPT:
		{
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			//Need to get collect script ref, not standard idata ref!
			const int32_t new_ref = ri->idata!=0 ? -(ri->idata) : COLLECT_SCRIPT_ITEM_ZERO;
			FFScript::deallocateAllScriptOwned(ScriptType::Item,new_ref);
			itemsbuf[ri->idata].collect_script=vbound(value/10000, 0, 255);
			break;
		}
		//pickup string
		case IDATAPSTRING:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			itemsbuf[ri->idata].pstring=vbound(value/10000, 1, 255);
			break;
		case IDATAPFLAGS:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			itemsbuf[ri->idata].pickup_string_flags=vbound(value/10000, 0, 214748);
			break;
		//magic cost
		case IDATAMAGCOST:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			itemsbuf[ri->idata].cost_amount[0]=vbound(value/10000,32767,-32768);
			break;
		case IDATACOST2:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			itemsbuf[ri->idata].cost_amount[1]=vbound(value/10000,32767,-32768);
			break;
		//cost counter ref
		case IDATACOSTCOUNTER:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			itemsbuf[ri->idata].cost_counter[0]=(vbound(value/10000,-1,32));
			break;
		case IDATACOSTCOUNTER2:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			itemsbuf[ri->idata].cost_counter[1]=(vbound(value/10000,-1,32));
			break;
		//min hearts to pick up
		case IDATAMINHEARTS:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			itemsbuf[ri->idata].pickup_hearts=vbound(value/10000, 0, 214748);
			break;
		//item tile
		case IDATATILE:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			itemsbuf[ri->idata].tile=vbound(value/10000, 0, 65519);
			break;
		//flash
		case IDATAMISC:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			itemsbuf[ri->idata].misc_flags=value/10000;
			break;
		//cset
		case IDATACSET:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			itemsbuf[ri->idata].csets=vbound(value/10000,0,13);
			break;
		/*
		case IDATAFRAME:
			itemsbuf[ri->idata].frame=value/10000;
			break;
		*/
		//A.Frames
		case IDATAFRAMES:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			(itemsbuf[ri->idata].frames)=vbound(value/10000, 0, 214748);
			break;
		//A.speed
		case IDATAASPEED:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			itemsbuf[ri->idata].speed=vbound(value/10000, 0, 214748);
			break;
		//Anim delay
		case IDATADELAY:
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			itemsbuf[ri->idata].delay=vbound(value/10000, 0, 214748);
			break;
		 
			//not one of mine. 
		case IDATAINITDD:
		{
			int32_t a = ri->d[rINDEX] / 10000;
			if(unsigned(ri->idata) >= MAXITEMS)
			{
				Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
				break;
			}
			
			if(BC::checkBounds(a, 0, 7, "itemdata->InitD") == SH::_NoError)
				itemsbuf[ri->idata].initiald[a] = value;
		}
		break;
		
	///----------------------------------------------------------------------------------------------------//
	//LWeapon Variables
		
		case LWPNSCALE:
			if ( get_qr(qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"lweapon->Scale");
				break;
			}
			if(0!=(s=checkLWpn(ri->lwpn,"Scale")))
				((weapon*)s)->scale=(zfix)(value/100.0);
				
			break;
		
		case LWPNX:
			if(0!=(s=checkLWpn(ri->lwpn,"X")))
				((weapon*)s)->x=get_qr(qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000);
			break;
		
		case SPRITEMAXLWPN:
		{
			//No bounds check, as this is a universal function and works from NULL pointers!
			Lwpns.setMax(vbound((value/10000),1,MAX_LWPN_SPRITES));
			break;
		}
			
		case LWPNY:
			if(0!=(s=checkLWpn(ri->lwpn,"Y")))
				((weapon*)s)->y=get_qr(qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000);
				
			break;
			
		case LWPNZ:
			if(0!=(s=checkLWpn(ri->lwpn,"Z")))
			{
				((weapon*)s)->z=get_qr(qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000);
				if(((weapon*)s)->z < 0) ((weapon*)s)->z = 0_zf;
			}
				
			break;
			
		case LWPNJUMP:
			if(0!=(s=checkLWpn(ri->lwpn,"Jump")))
				((weapon*)s)->fall=zslongToFix(value)*-100;
				
			break;
			
		case LWPNFAKEJUMP:
			if(0!=(s=checkLWpn(ri->lwpn,"FakeJump")))
				((weapon*)s)->fakefall=zslongToFix(value)*-100;
				
			break;
			
		case LWPNDIR:
			if(0!=(s=checkLWpn(ri->lwpn,"Dir")))
			{
				((weapon*)s)->dir=(value/10000);
				((weapon*)s)->doAutoRotate(true);
			}
				
			break;
			
		case LWPNSPECIAL:
			if(0!=(s=checkLWpn(ri->lwpn,"Special")))
				((weapon*)s)->specialinfo=(value/10000);
				
			break;
		 
		case LWPNGRAVITY:
			if(0!=(s=checkLWpn(ri->lwpn,"Gravity")))
			{
				if(value)
					((weapon*)s)->moveflags |= FLAG_OBEYS_GRAV;
				else
					((weapon*)s)->moveflags &= ~FLAG_OBEYS_GRAV;
			}
			break;
			
		case LWPNSTEP:
			if(0!=(s=checkLWpn(ri->lwpn,"Step")))
			{
				// fp math is bad for replay, so always ignore this QR when replay is active.
				// TODO: can we just delete this QR? Would it actually break anything? For now,
				// just disable for replay and wait for more tests to be played with this QR
				// ignored.
				if ( get_qr(qr_STEP_IS_FLOAT) || replay_is_active() )
				{
					((weapon*)s)->step= zslongToFix(value / 100);
				}
				else
				{
					//old, buggy code replication, round two: Go! -Z
					//zfix val = zslongToFix(value);
					//val.doFloor();
					//((weapon*)s)->step = ((val / 100.0).getFloat());
					
					//old, buggy code replication, round THREE: Go! -Z
					((weapon*)s)->step = ((value/10000)/100.0);
				}
				
			}
				
			break;
			
		case LWPNANGLE:
			if(0!=(s=checkLWpn(ri->lwpn,"Angle")))
			{
				((weapon*)s)->angle=(double)(value/10000.0);
				((weapon*)(s))->doAutoRotate();
			}
				
			break;
			
		case LWPNDEGANGLE:
			if(0!=(s=checkLWpn(ri->lwpn,"DegAngle")))
			{
				double rangle = (value / 10000.0) * (PI / 180.0);
				((weapon*)s)->angle=(double)(rangle);
				((weapon*)(s))->doAutoRotate();
			}
				
			break;
			
		case LWPNVX:
			if(0!=(s=checkLWpn(ri->lwpn,"Vx")))
			{
				double vy;
				double vx = (value / 10000.0);
				if (((weapon*)(s))->angular)
					vy = zc::math::Sin(((weapon*)s)->angle)*((weapon*)s)->step;
				else
				{
					switch(NORMAL_DIR(((weapon*)(s))->dir))
					{
						case l_up:
						case r_up:
						case up:
							vy = -1.0*((weapon*)s)->step;
							break;
						case l_down:
						case r_down:
						case down:
							vy = ((weapon*)s)->step;
							break;
							
						default:
							vy = 0;
							break;
					}
				}
				((weapon*)s)->angular = true;
				((weapon*)s)->angle=atan2(vy, vx);
				((weapon*)s)->step=FFCore.Distance(0, 0, vx, vy)/10000.0;
				((weapon*)(s))->doAutoRotate();
			}
				
			break;
		
		case LWPNVY:
			if(0!=(s=checkLWpn(ri->lwpn,"Vy")))
			{
				double vx;
				double vy = (value / 10000.0);
				if (((weapon*)(s))->angular)
					vx = zc::math::Cos(((weapon*)s)->angle)*((weapon*)s)->step;
				else
				{
					switch(NORMAL_DIR(((weapon*)(s))->dir))
					{
						case l_up:
						case l_down:
						case left:
							vx = -1.0*((weapon*)s)->step;
							break;
						case r_down:
						case r_up:
						case right:
							vx = ((weapon*)s)->step;
							break;
							
						default:
							vx = 0;
							break;
					}
				}
				((weapon*)s)->angular = true;
				((weapon*)s)->angle=atan2(vy, vx);
				((weapon*)s)->step=FFCore.Distance(0, 0, vx, vy)/10000.0;
				((weapon*)(s))->doAutoRotate();
			}
				
			break;
			
		case LWPNANGULAR:
			if(0!=(s=checkLWpn(ri->lwpn,"Angular")))
			{
				((weapon*)s)->angular=(value!=0);
				((weapon*)(s))->doAutoRotate(false, true);
			}
				
			break;
			
		case LWPNAUTOROTATE:
			if(0!=(s=checkLWpn(ri->lwpn,"AutoRotate")))
			{
				((weapon*)s)->autorotate=(value!=0);
				((weapon*)(s))->doAutoRotate(false, true);
			}
				
			break;
			
		case LWPNBEHIND:
			if(0!=(s=checkLWpn(ri->lwpn,"Behind")))
				((weapon*)s)->behind=(value!=0);
				
			break;
			
		case LWPNDRAWTYPE:
			if(0!=(s=checkLWpn(ri->lwpn,"DrawStyle")))
				((weapon*)s)->drawstyle=(value/10000);
				
			break;
			
		case LWPNPOWER:
			if(0!=(s=checkLWpn(ri->lwpn,"Damage")))
				((weapon*)s)->power=(value/10000);
				
			break;
		/*
		case LWPNRANGE:
			if(0!=(s=checkLWpn(ri->lwpn,"Range")))
			((weapon*)s)->scriptrange=vbound((value/10000),0,512); //Allow it to move off-screen. -Z           
			break;
		*/        
		case LWPNDEAD:
			if(0!=(s=checkLWpn(ri->lwpn,"DeadState")))
			{
				auto dead = value/10000;
				((weapon*)s)->dead=dead;
				if(dead != 0) ((weapon*)s)->weapon_dying_frame = false;
			}
			break;
			
		case LWPNID:
			if(0!=(s=checkLWpn(ri->lwpn,"ID")))
				((weapon*)s)->id=(value/10000);
				
			break;
			
		case LWPNTILE:
			if(0!=(s=checkLWpn(ri->lwpn,"Tile")))
				((weapon*)s)->tile=(value/10000);
				
			break;
		
		case LWPNSCRIPTTILE:
			if(0!=(s=checkLWpn(ri->lwpn,"ScriptTile")))
				((weapon*)s)->scripttile=vbound((value/10000),-1,NEWMAXTILES-1);
				
			break;
		
		case LWPNSCRIPTFLIP:
			if(0!=(s=checkLWpn(ri->lwpn,"ScriptFlip")))
				((weapon*)s)->scriptflip=vbound((value/10000),-1,127);
				
			break;
			
		case LWPNCSET:
			if(0!=(s=checkLWpn(ri->lwpn,"CSet")))
				((weapon*)s)->cs=(value/10000)&15;
				
			break;
			
		case LWPNFLASHCSET:
			if(0!=(s=checkLWpn(ri->lwpn,"FlashCSet")))
				(((weapon*)s)->o_cset)|=(value/10000)<<4;
				
			break;
			
		case LWPNFRAMES:
			if(0!=(s=checkLWpn(ri->lwpn,"NumFrames")))
				((weapon*)s)->frames=(value/10000);
				
			break;
			
		case LWPNFRAME:
			if(0!=(s=checkLWpn(ri->lwpn,"Frame")))
				((weapon*)s)->aframe=(value/10000);
				
			break;
			
		case LWPNASPEED:
			if(0!=(s=checkLWpn(ri->lwpn,"ASpeed")))
				((weapon*)s)->o_speed=(value/10000);
				
			break;
			
		case LWPNFLASH:
			if(0!=(s=checkLWpn(ri->lwpn,"Flash")))
				((weapon*)s)->flash=(value/10000);
				
			break;
			
		case LWPNFLIP:
			if(0!=(s=checkLWpn(ri->lwpn,"Flip")))
				((weapon*)s)->flip=(value/10000);
				
			break;

		case LWPNROTATION:
			if ( get_qr(qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"lweapon->Rotation");
				break;
			}
			if(0!=(s=checkLWpn(ri->lwpn,"Rotation")))
				((weapon*)s)->rotation=(value/10000);
				
			break;
			
		case LWPNEXTEND:
			if(0!=(s=checkLWpn(ri->lwpn,"Extend")))
				((weapon*)s)->extend=(value/10000);
				
			break;
			
		case LWPNOTILE:
			if(0!=(s=checkLWpn(ri->lwpn,"OriginalTile")))
			{
				//zprint("LWPNOTILE before write: %d\n", ((weapon*)s)->o_tile);
					((weapon*)s)->o_tile=(value/10000);
					((weapon*)s)->ref_o_tile=(value/10000);
					//((weapon*)s)->script_wrote_otile=1; //Removing this as of 26th October, 2019 -Z
				//if at some future point we WANT writing ->Tile to also overwrite ->OriginalTile,
				//then either the user will need to manually write tile, or we can add a QR and 
				// write ->tile here. 'script_wrote_otile' is out.
				//zprint("LWPNOTILE after write: %d\n", ((weapon*)s)->o_tile);
			}
			break;
			
		case LWPNOCSET:
			if(0!=(s=checkLWpn(ri->lwpn,"OriginalCSet")))
				(((weapon*)s)->o_cset)|=(value/10000)&15;
				
			break;
			
		case LWPNHXOFS:
			if(0!=(s=checkLWpn(ri->lwpn,"HitXOffset")))
				(((weapon*)s)->hxofs)=(value/10000);
				
			break;
			
		case LWPNHYOFS:
			if(0!=(s=checkLWpn(ri->lwpn,"HitYOffset")))
				(((weapon*)s)->hyofs)=(value/10000);
				
			break;
			
		case LWPNXOFS:
			if(0!=(s=checkLWpn(ri->lwpn,"DrawXOffset")))
				(((weapon*)s)->xofs)=(zfix)(value/10000);
				
			break;
			
		case LWPNYOFS:
			if(0!=(s=checkLWpn(ri->lwpn,"DrawYOffset")))
				(((weapon*)s)->yofs)=(zfix)(value/10000)+(get_qr(qr_OLD_DRAWOFFSET)?playing_field_offset:original_playing_field_offset);
				
			break;
		
		case LWPNSHADOWXOFS:
			if(0!=(s=checkLWpn(ri->lwpn,"ShadowXOffset")))
				(((weapon*)s)->shadowxofs)=(zfix)(value/10000);
				
			break;
		
		case LWPNSHADOWYOFS:
			if(0!=(s=checkLWpn(ri->lwpn,"ShadowYOffset")))
				(((weapon*)s)->shadowyofs)=(zfix)(value/10000);
				
			break;
			
		case LWPNTOTALDYOFFS:
			break; //READ-ONLY
			
		case LWPNZOFS:
			if(0!=(s=checkLWpn(ri->lwpn,"DrawZOffset")))
				(((weapon*)s)->zofs)=(zfix)(value/10000);
				
			break;
			
		case LWPNHXSZ:
			if(0!=(s=checkLWpn(ri->lwpn,"HitWidth")))
				(((weapon*)s)->hit_width)=(value/10000);
				
			break;
			
		case LWPNHYSZ:
			if(0!=(s=checkLWpn(ri->lwpn,"HitHeight")))
				(((weapon*)s)->hit_height)=(value/10000);
				
			break;
			
		case LWPNHZSZ:
			if(0!=(s=checkLWpn(ri->lwpn,"HitZHeight")))
				(((weapon*)s)->hzsz)=(value/10000);
				
			break;
			
		case LWPNTXSZ:
			if(0!=(s=checkLWpn(ri->lwpn,"TileWidth")))
				(((weapon*)s)->txsz)=vbound((value/10000),1,20);
				
			break;
			
		case LWPNTYSZ:
			if(0!=(s=checkLWpn(ri->lwpn,"TileHeight")))
				(((weapon*)s)->tysz)=vbound((value/10000),1,20);
				
			break;
			
		case LWPNMISCD:
			if(0!=(s=checkLWpn(ri->lwpn,"Misc")))
			{
				int32_t a = vbound(ri->d[rINDEX]/10000,0,31);
				(((weapon*)(s))->miscellaneous[a])=value;
			}
			
			break;
			
		case LWPNCOLLDET:
			if(0!=(s=checkLWpn(ri->lwpn,"CollDetection")))
				(((weapon*)(s))->scriptcoldet) = value;

			break;
		
		case LWPNENGINEANIMATE:
			if(0!=(s=checkLWpn(ri->lwpn,"Animation")))
				(((weapon*)(s))->do_animation)=value;
				
			break;
		
		case LWPNPARENT:
		{
			//int32_t pitm = (vbound(value/10000,1,(MAXITEMS-1)));
			//zprint("Attempting to set ParentItem to: %d\n", pitm); 
					
			if(0!=(s=checkLWpn(ri->lwpn,"Parent")))
				(((weapon*)(s))->parentitem)=(vbound(value/10000,-1,(MAXITEMS-1)));
			break;
		}

		case LWPNLEVEL:
			if(0!=(s=checkLWpn(ri->lwpn,"Level")))
				(((weapon*)(s))->type)=value/10000;
				
			break;
		
		case LWPNSCRIPT:
			if(0!=(s=checkLWpn(ri->lwpn,"Script")))
			{
				(((weapon*)(s))->weaponscript)=vbound(value/10000,0,NUMSCRIPTWEAPONS-1);
				if ( get_qr(qr_CLEARINITDONSCRIPTCHANGE))
				{
					for(int32_t q=0; q<8; q++)
						(((weapon*)(s))->weap_initd[q]) = 0;
				}
				on_reassign_script_engine_data(ScriptType::Lwpn, ri->lwpn);
			}  
			break;
		
		case LWPNUSEWEAPON:
			if(0!=(s=checkLWpn(ri->lwpn,"Weapon")))
			(((weapon*)(s))->useweapon)=vbound(value/10000,0,255);
				
			break;
		
		case LWPNUSEDEFENCE:
			if(0!=(s=checkLWpn(ri->lwpn,"Defense")))
			(((weapon*)(s))->usedefence)=vbound(value/10000,0,255);
				
			break;
		
		case LWPNINITD:
		{
			int32_t a = vbound((ri->d[rINDEX] / 10000),0,7);
			if(0!=(s=checkLWpn(ri->lwpn,"InitD[]")))
			{
				(((weapon*)(s))->weap_initd[a])=value;
			}
			break;
		}
		case LWPNFALLCLK:
			if(0!=(s=checkLWpn(ri->lwpn,"Falling")))
			{
				if(((weapon*)(s))->fallclk != 0 && value == 0)
				{
					((weapon*)(s))->cs = ((weapon*)(s))->old_cset;
					((weapon*)(s))->tile = ((weapon*)(s))->o_tile;
				}
				else if(((weapon*)(s))->fallclk == 0 && value != 0) ((weapon*)(s))->old_cset = ((weapon*)(s))->cs;
				((weapon*)(s))->fallclk = vbound(value/10000,0,70);
			}
			break;
		case LWPNFALLCMB:
			if(0!=(s=checkLWpn(ri->lwpn,"FallCombo")))
			{
				((weapon*)(s))->fallCombo = vbound(value/10000,0,MAXCOMBOS-1);
			}
			break;
		case LWPNDROWNCLK:
			if(0!=(s=checkLWpn(ri->lwpn,"Drowning")))
			{
				if(((weapon*)(s))->drownclk != 0 && value == 0)
				{
					((weapon*)(s))->cs = ((weapon*)(s))->old_cset;
					((weapon*)(s))->tile = ((weapon*)(s))->o_tile;
				}
				else if(((weapon*)(s))->drownclk == 0 && value != 0) ((weapon*)(s))->old_cset = ((weapon*)(s))->cs;
				((weapon*)(s))->drownclk = vbound(value/10000,0,70);
			}
			break;
		case LWPNDROWNCMB:
			if(0!=(s=checkLWpn(ri->lwpn,"DrownCombo")))
			{
				((weapon*)(s))->drownCombo = vbound(value/10000,0,MAXCOMBOS-1);
			}
			break;
		case LWPNFAKEZ:
			if(0!=(s=checkLWpn(ri->lwpn,"FakeZ")))
			{
				((weapon*)s)->fakez=get_qr(qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000);
				if(((weapon*)s)->fakez < 0) ((weapon*)s)->fakez = 0_zf;
			}
				
			break;
			
		case LWPNMOVEFLAGS:
		{
			if(0!=(s=checkLWpn(ri->lwpn,"MoveFlags[]")))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(BC::checkBounds(indx, 0, 10, "lweapon->MoveFlags[]") == SH::_NoError)
				{
					//All bits, in order, of a single byte; just use bitwise
					int32_t bit = 1<<indx;
					if(value)
						((weapon*)(s))->moveflags |= bit;
					else
						((weapon*)(s))->moveflags &= ~bit;
				}
			}
			break;
		}
		case LWPNFLAGS:
		{
			if(0!=(s=checkLWpn(ri->lwpn,"Flags[]")))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(BC::checkBounds(indx, 0, WFLAG_MAX-1, "lweapon->Flags[]") == SH::_NoError)
				{
					//All bits, in order, of a single byte; just use bitwise
					int32_t bit = 1<<indx;
					if(value)
						((weapon*)(s))->misc_wflags |= bit;
					else
						((weapon*)(s))->misc_wflags &= ~bit;
				}
			}
			break;
		}
		case LWPNSPRITES:
		{
			if(0!=(s=checkLWpn(ri->lwpn,"Sprites[]")))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(BC::checkBounds(indx, 0, WPNSPR_MAX-1, "lweapon->Sprites[]") == SH::_NoError)
					((weapon*)(s))->misc_wsprites[indx] = vbound(value/10000,0,255);
			}
			break;
		}
		case LWPNBURNLIGHTRADIUS:
		{
			if(0!=(s=checkLWpn(ri->lwpn,"BurnLightRadius[]")))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(BC::checkBounds(indx, 0, WPNSPR_MAX-1, "lweapon->BurnLightRadius[]") == SH::_NoError)
					((weapon*)(s))->light_rads[indx] = vbound(value/10000,0,255);
			}
			break;
		}
		
		case LWPNGLOWRAD:
			if(0!=(s=checkLWpn(ri->lwpn,"LightRadius")))
			{
				((weapon*)(s))->glowRad = vbound(value/10000,0,255);
			}
			break;
			
		case LWPNGLOWSHP:
			if(0!=(s=checkLWpn(ri->lwpn,"LightShape")))
			{
				((weapon*)(s))->glowShape = vbound(value/10000,0,255);
			}
			break;
			
		case LWPNUNBL:
			if(0!=(s=checkLWpn(ri->lwpn,"Unblockable")))
			{
				((weapon*)(s))->unblockable = (value/10000)&WPNUNB_ALL;
			}
			break;
			
		case LWPNSHADOWSPR:
			if(0!=(s=checkLWpn(ri->lwpn,"ShadowSprite")))
			{
				((weapon*)(s))->spr_shadow = vbound(value/10000, 0, 255);
			}
			break;
		case LWSWHOOKED:
			break; //read-only
		case LWPNTIMEOUT:
			if(0!=(s=checkLWpn(ri->lwpn,"Timeout")))
			{
				((weapon*)(s))->weap_timeout = vbound(value/10000,0,214748);
			}
			break;
		case LWPNDEATHITEM:
			if(0!=(s=checkLWpn(ri->lwpn,"DeathItem")))
			{
				((weapon*)(s))->death_spawnitem = vbound(value/10000,-1,MAXITEMS-1);
			}
			break;
		case LWPNDEATHDROPSET:
			if(0!=(s=checkLWpn(ri->lwpn,"DeathDropset")))
			{
				((weapon*)(s))->death_spawndropset = vbound(value/10000,-1,MAXITEMDROPSETS-1);
			}
			break;
		case LWPNDEATHIPICKUP:
			if(0!=(s=checkLWpn(ri->lwpn,"DeathItemPFlags")))
			{
				((weapon*)(s))->death_item_pflags = value/10000;
			}
			break;
		case LWPNDEATHSPRITE:
			if(0!=(s=checkLWpn(ri->lwpn,"DeathSprite")))
			{
				((weapon*)(s))->death_sprite = vbound(value/10000,-255,MAXWPNS-1);
			}
			break;
		case LWPNDEATHSFX:
			if(0!=(s=checkLWpn(ri->lwpn,"DeathSFX")))
			{
				((weapon*)(s))->death_sfx = vbound(value/10000,0,WAV_COUNT);
			}
			break;
		case LWPNLIFTLEVEL:
			if(0!=(s=checkLWpn(ri->lwpn,"LiftLevel")))
			{
				((weapon*)(s))->lift_level = vbound(value/10000,0,255);
			}
			break;
		case LWPNLIFTTIME:
			if(0!=(s=checkLWpn(ri->lwpn,"LiftTime")))
			{
				((weapon*)(s))->lift_time = vbound(value/10000,0,255);
			}
			break;
		case LWPNLIFTHEIGHT:
			if(0!=(s=checkLWpn(ri->lwpn,"LiftHeight")))
			{
				((weapon*)(s))->lift_height = zslongToFix(value);
			}
			break;
			
	///----------------------------------------------------------------------------------------------------//
	//EWeapon Variables
		case EWPNSCALE:
			if ( get_qr(qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"eweapon->Scale");
				break;
			}
			if(0!=(s=checkEWpn(ri->ewpn,"Scale")))
				((weapon*)s)->scale=(zfix)(value/100.0);
				
			break;
		
		case EWPNX:
			if(0!=(s=checkEWpn(ri->ewpn,"X")))
				((weapon*)s)->x = (get_qr(qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000));
				
			break;
		
		case SPRITEMAXEWPN:
		{
			//No bounds check, as this is a universal function and works from NULL pointers!
			Ewpns.setMax(vbound((value/10000),1,MAX_EWPN_SPRITES));
			break;
		}
		
		case EWPNY:
			if(0!=(s=checkEWpn(ri->ewpn,"Y")))
				((weapon*)s)->y = (get_qr(qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000));
				
			break;
			
		case EWPNZ:
			if(0!=(s=checkEWpn(ri->ewpn,"Z")))
			{
				((weapon*)s)->z=get_qr(qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000);
				if(((weapon*)s)->z < 0) ((weapon*)s)->z = 0_zf;
			}
				
			break;
			
		case EWPNJUMP:
			if(0!=(s=checkEWpn(ri->ewpn,"Jump")))
				((weapon*)s)->fall=zslongToFix(value)*-100;
				
			break;
			
		case EWPNFAKEJUMP:
			if(0!=(s=checkEWpn(ri->ewpn,"FakeJump")))
				((weapon*)s)->fakefall=zslongToFix(value)*-100;
				
			break;
			
		case EWPNDIR:
			if(0!=(s=checkEWpn(ri->ewpn,"Dir")))
			{
				((weapon*)s)->dir=(value/10000);
				((weapon*)s)->doAutoRotate(true);
			}
				
			break;
			
		case EWPNLEVEL:
			if(0!=(s=checkEWpn(ri->ewpn,"Level")))
				((weapon*)s)->type=(value/10000);
				
			break;
		  
		case EWPNGRAVITY:
			if(0!=(s=checkEWpn(ri->ewpn,"Gravity")))
			{
				if(value)
					((weapon*)s)->moveflags |= FLAG_OBEYS_GRAV;
				else
					((weapon*)s)->moveflags &= ~FLAG_OBEYS_GRAV;
			}
			break;
			
		case EWPNSTEP:
			if(0!=(s=checkEWpn(ri->ewpn,"Step")))
			{
				if ( get_qr(qr_STEP_IS_FLOAT) || replay_is_active() )
				{
					((weapon*)s)->step= zslongToFix(value / 100);
				}
				else
				{
					//old, buggy code replication, round two: Go! -Z
					//zfix val = zslongToFix(value);
					//val.doFloor();
					//((weapon*)s)->step = ((val / 100.0).getFloat());
					
					//old, buggy code replication, round THREE: Go! -Z
					((weapon*)s)->step = ((value/10000)/100.0);
					//zprint2("ewpn step is %d\n", ((weapon*)s)->step);
				}
			}
				
			break;
			
		case EWPNANGLE:
			if(0!=(s=checkEWpn(ri->ewpn,"Angle")))
			{
				((weapon*)s)->angle=(double)(value/10000.0);
				((weapon*)(s))->doAutoRotate();
			}
				
			break;
			
		case EWPNDEGANGLE:
			if(0!=(s=checkEWpn(ri->ewpn,"DegAngle")))
			{
				double rangle = (value / 10000.0) * (PI / 180.0);
				((weapon*)s)->angle=(double)(rangle);
				((weapon*)(s))->doAutoRotate();
			}
				
			break;
			
		case EWPNVX:
			if(0!=(s=checkEWpn(ri->ewpn,"Vx")))
			{
				double vy;
				double vx = (value / 10000.0);
				if (((weapon*)(s))->angular)
					vy = zc::math::Sin(((weapon*)s)->angle)*((weapon*)s)->step;
				else
				{
					switch(NORMAL_DIR(((weapon*)(s))->dir))
					{
						case l_up:
						case r_up:
						case up:
							vy = -1.0*((weapon*)s)->step;
							break;
						case l_down:
						case r_down:
						case down:
							vy = ((weapon*)s)->step;
							break;
							
						default:
							vy = 0;
							break;
					}
				}
				((weapon*)s)->angular = true;
				((weapon*)s)->angle=atan2(vy, vx);
				((weapon*)s)->step=FFCore.Distance(0, 0, vx, vy)/10000;
				((weapon*)(s))->doAutoRotate();
			}
				
			break;
		
		case EWPNVY:
			if(0!=(s=checkEWpn(ri->ewpn,"Vy")))
			{
				double vx;
				double vy = (value / 10000.0);
				if (((weapon*)(s))->angular)
					vx = zc::math::Cos(((weapon*)s)->angle)*((weapon*)s)->step;
				else
				{
					switch(NORMAL_DIR(((weapon*)(s))->dir))
					{
						case l_up:
						case l_down:
						case left:
							vx = -1.0*((weapon*)s)->step;
							break;
						case r_down:
						case r_up:
						case right:
							vx = ((weapon*)s)->step;
							break;
							
						default:
							vx = 0;
							break;
					}
				}
				((weapon*)s)->angular = true;
				((weapon*)s)->angle=atan2(vy, vx);
				((weapon*)s)->step=FFCore.Distance(0, 0, vx, vy)/10000;
				((weapon*)(s))->doAutoRotate();
			}
				
			break;
			
		case EWPNANGULAR:
			if(0!=(s=checkEWpn(ri->ewpn,"Angular")))
			{
				((weapon*)s)->angular=(value!=0);
				((weapon*)(s))->doAutoRotate(false, true);
			}
				
			break;
			
		case EWPNAUTOROTATE:
			if(0!=(s=checkEWpn(ri->ewpn,"AutoRotate")))
			{
				((weapon*)s)->autorotate=(value!=0);
				((weapon*)(s))->doAutoRotate(false, true);
			}
				
			break;
			
		case EWPNBEHIND:
			if(0!=(s=checkEWpn(ri->ewpn,"Behind")))
				((weapon*)s)->behind=(value!=0);
				
			break;
			
		case EWPNDRAWTYPE:
			if(0!=(s=checkEWpn(ri->ewpn,"DrawStyle")))
				((weapon*)s)->drawstyle=(value/10000);
				
			break;
			
		case EWPNPOWER:
			if(0!=(s=checkEWpn(ri->ewpn,"Damage")))
				((weapon*)s)->power=(value/10000);
				
			break;
			
		case EWPNDEAD:
			if(0!=(s=checkEWpn(ri->ewpn,"DeadState")))
			{
				auto dead = value/10000;
				((weapon*)s)->dead=dead;
				if(dead != 0) ((weapon*)s)->weapon_dying_frame = false;
			}
				
			break;
			
		case EWPNID:
			if(0!=(s=checkEWpn(ri->ewpn,"ID")))
				((weapon*)s)->id=(value/10000);
				
			break;
			
		case EWPNTILE:
			if(0!=(s=checkEWpn(ri->ewpn,"Tile")))
				((weapon*)s)->tile=(value/10000);
				
			break;
			
		case EWPNSCRIPTTILE:
			if(0!=(s=checkEWpn(ri->ewpn,"ScriptTile")))
				((weapon*)s)->scripttile=vbound((value/10000),-1, NEWMAXTILES-1);
				
			break;
		
		case EWPNSCRIPTFLIP:
			if(0!=(s=checkEWpn(ri->ewpn,"ScriptFlip")))
				((weapon*)s)->scriptflip=vbound((value/10000),-1, 127);
				
			break;
			
		case EWPNCSET:
			if(0!=(s=checkEWpn(ri->ewpn,"CSet")))
				((weapon*)s)->cs=(value/10000)&15;
				
			break;
			
		case EWPNFLASHCSET:
			if(0!=(s=checkEWpn(ri->ewpn,"FlashCSet")))
				(((weapon*)s)->o_cset)|=(value/10000)<<4;
				
			break;
			
		case EWPNFRAMES:
			if(0!=(s=checkEWpn(ri->ewpn,"NumFrames")))
				((weapon*)s)->frames=(value/10000);
				
			break;
			
		case EWPNFRAME:
			if(0!=(s=checkEWpn(ri->ewpn,"Frame")))
				((weapon*)s)->aframe=(value/10000);
				
			break;
			
		case EWPNASPEED:
			if(0!=(s=checkEWpn(ri->ewpn,"ASpeed")))
				((weapon*)s)->o_speed=(value/10000);
				
			break;
			
		case EWPNFLASH:
			if(0!=(s=checkEWpn(ri->ewpn,"Flash")))
				((weapon*)s)->flash=(value/10000);
				
			break;
			
		case EWPNFLIP:
			if(0!=(s=checkEWpn(ri->ewpn,"Flip")))
				((weapon*)s)->flip=(value/10000);
				
			break;
			
		case EWPNROTATION:
			if ( get_qr(qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"eweapon->Rotation");
				break;
			}
			if(0!=(s=checkEWpn(ri->ewpn,"Rotation")))
				((weapon*)s)->rotation=(value/10000);
				
			break;
			
		case EWPNEXTEND:
			if(0!=(s=checkEWpn(ri->ewpn,"Extend")))
				((weapon*)s)->extend=(value/10000);
				
			break;
			
		case EWPNOTILE:
			if(0!=(s=checkEWpn(ri->ewpn,"OriginalTile")))
			{
				((weapon*)s)->o_tile=(value/10000);
				((weapon*)s)->ref_o_tile=(value/10000);
			}
				
			break;
			
		case EWPNOCSET:
			if(0!=(s=checkEWpn(ri->ewpn,"OriginalCSet")))
				(((weapon*)s)->o_cset)|=(value/10000)&15;
				
			break;
			
		case EWPNHXOFS:
			if(0!=(s=checkEWpn(ri->ewpn,"HitXOffset")))
				(((weapon*)s)->hxofs)=(value/10000);
				
			break;
			
		case EWPNHYOFS:
			if(0!=(s=checkEWpn(ri->ewpn,"HitYOffset")))
				(((weapon*)s)->hyofs)=(value/10000);
				
			break;
			
		case EWPNXOFS:
			if(0!=(s=checkEWpn(ri->ewpn,"DrawXOffset")))
				(((weapon*)s)->xofs)=(zfix)(value/10000);
				
			break;
			
		case EWPNYOFS:
			if(0!=(s=checkEWpn(ri->ewpn,"DrawYOffset")))
				(((weapon*)s)->yofs)=(zfix)(value/10000)+(get_qr(qr_OLD_DRAWOFFSET)?playing_field_offset:original_playing_field_offset);
				
			break;
		case EWPNTOTALDYOFFS:
			break; //READ-ONLY
			
		case EWPNSHADOWXOFS:
			if(0!=(s=checkEWpn(ri->ewpn,"ShadowXOffset")))
				(((weapon*)s)->shadowxofs)=(zfix)(value/10000);
				
			break;
			
		case EWPNSHADOWYOFS:
			if(0!=(s=checkEWpn(ri->ewpn,"ShadowYOffset")))
				(((weapon*)s)->shadowyofs)=(zfix)(value/10000);
				
			break;
			
		case EWPNZOFS:
			if(0!=(s=checkEWpn(ri->ewpn,"DrawZOffset")))
				(((weapon*)s)->zofs)=(zfix)(value/10000);
				
			break;
			
		case EWPNHXSZ:
			if(0!=(s=checkEWpn(ri->ewpn,"HitWidth")))
				(((weapon*)s)->hit_width)=(value/10000);
				
			break;
			
		case EWPNHYSZ:
			if(0!=(s=checkEWpn(ri->ewpn,"HitHeight")))
				(((weapon*)s)->hit_height)=(value/10000);
				
			break;
			
		case EWPNHZSZ:
			if(0!=(s=checkEWpn(ri->ewpn,"HitZHeight")))
				(((weapon*)s)->hzsz)=(value/10000);
				
			break;
			
		case EWPNTXSZ:
			if(0!=(s=checkEWpn(ri->ewpn,"TileWidth")))
				(((weapon*)s)->txsz)=vbound((value/10000),1,20);
				
			break;
			
		case EWPNTYSZ:
			if(0!=(s=checkEWpn(ri->ewpn,"TileHeight")))
				(((weapon*)s)->tysz)=vbound((value/10000),1,20);
				
			break;
			
		case EWPNMISCD:
			if(0!=(s=checkEWpn(ri->ewpn,"Misc")))
			{
				int32_t a = vbound(ri->d[rINDEX]/10000,0,31);
				(((weapon*)(s))->miscellaneous[a])=value;
			}
			
			break;
			
		case EWPNCOLLDET:
			if(0!=(s=checkEWpn(ri->ewpn,"CollDetection")))
				(((weapon*)(s))->scriptcoldet)=value;
				
			break;
		
		case EWPNENGINEANIMATE:
			if(0!=(s=checkEWpn(ri->ewpn,"Animation")))
				(((weapon*)(s))->do_animation)=value;
				
			break;
		
		
		case EWPNPARENTUID:
			if(0!=(s=checkEWpn(ri->ewpn, "ParentUID")))
			(((weapon*)(s))->parent_script_UID) = value; //literal, not *10000
			break;
		
		case EWPNPARENT:
			if(0!=(s=checkEWpn(ri->ewpn, "Parent")))
				(((weapon*)(s))->parentid)= ( (get_qr(qr_OLDEWPNPARENT)) ? value / 10000 : value );
				
			break;
		
		case EWPNSCRIPT:
			if(0!=(s=checkEWpn(ri->ewpn,"Script")))
			{
				(((weapon*)(s))->weaponscript)=vbound(value/10000,0,NUMSCRIPTWEAPONS-1);
				if ( get_qr(qr_CLEARINITDONSCRIPTCHANGE))
				{
					for(int32_t q=0; q<8; q++)
						(((weapon*)(s))->weap_initd[q]) = 0;
				}
				on_reassign_script_engine_data(ScriptType::Ewpn, ri->ewpn);
			}
			break;
		
		case EWPNINITD:
		{
			int32_t a = vbound((ri->d[rINDEX] / 10000),0,7);
			if(0!=(s=checkEWpn(ri->ewpn,"InitD[]")))
			{
				(((weapon*)(s))->weap_initd[a])=value;
			}
			break;
		}
		case EWPNFALLCLK:
			if(0!=(s=checkEWpn(ri->ewpn,"Falling")))
			{
				if(((weapon*)(s))->fallclk != 0 && value == 0)
				{
					((weapon*)(s))->cs = ((weapon*)(s))->old_cset;
					((weapon*)(s))->tile = ((weapon*)(s))->o_tile;
				}
				else if(((weapon*)(s))->fallclk == 0 && value != 0) ((weapon*)(s))->old_cset = ((weapon*)(s))->cs;
				((weapon*)(s))->fallclk = vbound(value/10000,0,70);
			}
			break;
		case EWPNFALLCMB:
			if(0!=(s=checkEWpn(ri->ewpn,"FallCombo")))
			{
				((weapon*)(s))->fallCombo = vbound(value/10000,0,MAXCOMBOS-1);
			}
			break;
		case EWPNDROWNCLK:
			if(0!=(s=checkEWpn(ri->ewpn,"Drowning")))
			{
				if(((weapon*)(s))->drownclk != 0 && value == 0)
				{
					((weapon*)(s))->cs = ((weapon*)(s))->old_cset;
					((weapon*)(s))->tile = ((weapon*)(s))->o_tile;
				}
				else if(((weapon*)(s))->drownclk == 0 && value != 0) ((weapon*)(s))->old_cset = ((weapon*)(s))->cs;
				((weapon*)(s))->drownclk = vbound(value/10000,0,70);
			}
			break;
		case EWPNDROWNCMB:
			if(0!=(s=checkEWpn(ri->ewpn,"DrownCombo")))
			{
				((weapon*)(s))->drownCombo = vbound(value/10000,0,MAXCOMBOS-1);
			}
			break;
		case EWPNFAKEZ:
			if(0!=(s=checkEWpn(ri->ewpn,"FakeZ")))
			{
				((weapon*)s)->fakez=get_qr(qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000);
				if(((weapon*)s)->fakez < 0) ((weapon*)s)->fakez = 0_zf;
			}
				
			break;
			
		case EWPNMOVEFLAGS:
		{
			if(0!=(s=checkEWpn(ri->ewpn,"MoveFlags[]")))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(BC::checkBounds(indx, 0, 10, "eweapon->MoveFlags[]") == SH::_NoError)
				{
					//All bits, in order, of a single byte; just use bitwise
					int32_t bit = 1<<indx;
					if(value)
						((weapon*)(s))->moveflags |= bit;
					else
						((weapon*)(s))->moveflags &= ~bit;
				}
			}
			break;
		}
		case EWPNFLAGS:
		{
			if(0!=(s=checkEWpn(ri->ewpn,"Flags[]")))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(BC::checkBounds(indx, 0, WFLAG_MAX-1, "eweapon->Flags[]") == SH::_NoError)
				{
					//All bits, in order, of a single byte; just use bitwise
					int32_t bit = 1<<indx;
					if(value)
						((weapon*)(s))->misc_wflags |= bit;
					else
						((weapon*)(s))->misc_wflags &= ~bit;
				}
			}
			break;
		}
		case EWPNSPRITES:
		{
			if(0!=(s=checkEWpn(ri->ewpn,"Sprites[]")))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(BC::checkBounds(indx, 0, WPNSPR_MAX-1, "eweapon->Sprites[]") == SH::_NoError)
					((weapon*)(s))->misc_wsprites[indx] = vbound(value/10000,0,255);
			}
			break;
		}
		case EWPNBURNLIGHTRADIUS:
		{
			if(0!=(s=checkEWpn(ri->ewpn,"BurnLightRadius[]")))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(BC::checkBounds(indx, 0, WPNSPR_MAX-1, "eweapon->BurnLightRadius[]") == SH::_NoError)
					((weapon*)(s))->light_rads[indx] = vbound(value/10000,0,255);
			}
			break;
		}
		
		case EWPNGLOWRAD:
			if(0!=(s=checkEWpn(ri->ewpn,"LightRadius")))
			{
				((weapon*)(s))->glowRad = vbound(value/10000,0,255);
			}
			break;
		case EWPNGLOWSHP:
			if(0!=(s=checkEWpn(ri->ewpn,"LightShape")))
			{
				((weapon*)(s))->glowShape = vbound(value/10000,0,255);
			}
			break;
			
		case EWPNUNBL:
			if(0!=(s=checkEWpn(ri->ewpn,"Unblockable")))
			{
				((weapon*)(s))->unblockable = (value/10000)&WPNUNB_ALL;
			}
			break;
			
		case EWPNSHADOWSPR:
			if(0!=(s=checkEWpn(ri->ewpn,"ShadowSprite")))
			{
				((weapon*)(s))->spr_shadow = vbound(value/10000, 0, 255);
			}
			break;
		case EWSWHOOKED:
			break; //read-only
		case EWPNTIMEOUT:
			if(0!=(s=checkEWpn(ri->ewpn,"Timeout")))
			{
				((weapon*)(s))->weap_timeout = vbound(value/10000,0,214748);
			}
			break;case EWPNDEATHITEM:
			if(0!=(s=checkEWpn(ri->ewpn,"DeathItem")))
			{
				((weapon*)(s))->death_spawnitem = vbound(value/10000,-1,MAXITEMS-1);
			}
			break;
		case EWPNDEATHDROPSET:
			if(0!=(s=checkEWpn(ri->ewpn,"DeathDropset")))
			{
				((weapon*)(s))->death_spawndropset = vbound(value/10000,-1,MAXITEMDROPSETS-1);
			}
			break;
		case EWPNDEATHIPICKUP:
			if(0!=(s=checkEWpn(ri->ewpn,"DeathItemPFlags")))
			{
				((weapon*)(s))->death_item_pflags = value/10000;
			}
			break;
		case EWPNDEATHSPRITE:
			if(0!=(s=checkEWpn(ri->ewpn,"DeathSprite")))
			{
				((weapon*)(s))->death_sprite = vbound(value/10000,-255,MAXWPNS-1);
			}
			break;
		case EWPNDEATHSFX:
			if(0!=(s=checkEWpn(ri->ewpn,"DeathSFX")))
			{
				((weapon*)(s))->death_sfx = vbound(value/10000,0,WAV_COUNT);
			}
			break;
		case EWPNLIFTLEVEL:
			if(0!=(s=checkEWpn(ri->ewpn,"LiftLevel")))
			{
				((weapon*)(s))->lift_level = vbound(value/10000,0,255);
			}
			break;
		case EWPNLIFTTIME:
			if(0!=(s=checkEWpn(ri->ewpn,"LiftTime")))
			{
				((weapon*)(s))->lift_time = vbound(value/10000,0,255);
			}
			break;
		case EWPNLIFTHEIGHT:
			if(0!=(s=checkEWpn(ri->ewpn,"LiftHeight")))
			{
				((weapon*)(s))->lift_height = zslongToFix(value);
			}
			break;
			
	///----------------------------------------------------------------------------------------------------//
	//NPC Variables

		//Fixs are all a bit different
		case NPCX:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->X") == SH::_NoError)
			{
				GuyH::getNPC()->x = get_qr(qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000);
				
				if(GuyH::hasHero())
					Hero.setXfix(get_qr(qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000));
			}
		}
		break;
		
		case NPCSCALE:
		{
			if ( get_qr(qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"npc->Scale");
				break;
			}
			if(GuyH::loadNPC(ri->guyref, "npc->Scale") == SH::_NoError)
			{
				GuyH::getNPC()->scale = (value / 100.0);
			}
		}
		break;
		
		case NPCIMMORTAL:
			if(GuyH::loadNPC(ri->guyref, "npc->Immortal") == SH::_NoError)
			{
				GuyH::getNPC()->immortal = (value ? true : false);
			}
			break;
		
		case NPCNOSLIDE:
			if(GuyH::loadNPC(ri->guyref, "npc->NoSlide") == SH::_NoError)
			{
				if(value)
				{
					GuyH::getNPC()->knockbackflags |= FLAG_NOSLIDE;
				}
				else
				{
					GuyH::getNPC()->knockbackflags &= ~FLAG_NOSLIDE;
				}
			}
			break;
		
		case NPCNOSCRIPTKB:
			if(GuyH::loadNPC(ri->guyref, "npc->NoScriptKnockback") == SH::_NoError)
			{
				if(value)
				{
					GuyH::getNPC()->knockbackflags |= FLAG_NOSCRIPTKNOCKBACK;
				}
				else
				{
					GuyH::getNPC()->knockbackflags &= ~FLAG_NOSCRIPTKNOCKBACK;
				}
			}
			break;
		
		case NPCKNOCKBACKSPEED:
			if(GuyH::loadNPC(ri->guyref, "npc->NoKnockback") == SH::_NoError)
			{
				GuyH::getNPC()->knockbackSpeed = vbound(value/10000, 0, 255);
			}
			break;
		
		case SPRITEMAXNPC:
		{
			//No bounds check, as this is a universal function and works from NULL pointers!
			guys.setMax(vbound((value/10000),1,MAX_NPC_SPRITES));
			break;
		}
			
		case NPCY:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->Y") == SH::_NoError)
			{
				zfix oldy = GuyH::getNPC()->y;
				GuyH::getNPC()->y = get_qr(qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000);
				GuyH::getNPC()->floor_y += ((get_qr(qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000)) - oldy);
				
				if(GuyH::hasHero())
					Hero.setYfix(get_qr(qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000));
			}
		}
		break;
		
		case NPCZ:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->Z") == SH::_NoError)
			{
				if(!never_in_air(GuyH::getNPC()->id))
				{
					if(value < 0)
						GuyH::getNPC()->z = 0_zf;
					else
						GuyH::getNPC()->z = get_qr(qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000);
						
					if(GuyH::hasHero())
						Hero.setZfix(get_qr(qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000));
				}
			}
		}
		break;
		
		case NPCJUMP:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->Jump") == SH::_NoError)
			{
				if(canfall(GuyH::getNPC()->id))
					GuyH::getNPC()->fall =zslongToFix(value)*-100;
					
				if(GuyH::hasHero())
					Hero.setFall(zslongToFix(value)*-100);
			}
		}
		break;
		
		case NPCFAKEJUMP:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->FakeJump") == SH::_NoError)
			{
				if(canfall(GuyH::getNPC()->id))
					GuyH::getNPC()->fakefall =zslongToFix(value)*-100;
					
				if(GuyH::hasHero())
					Hero.setFakeFall(zslongToFix(value)*-100);
			}
		}
		break;
		
		case NPCSTEP:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->Step") == SH::_NoError)
			{
				if ( get_qr(qr_STEP_IS_FLOAT) || replay_is_active() )
				{	
					GuyH::getNPC()->step = zslongToFix(value / 100);
				}
				else
				{
					//old, buggy code replication, round two: Go! -Z
					//zfix val = zslongToFix(value);
					//val.doFloor();
					//GuyH::getNPC()->step = ((val / 100.0).getFloat());
					
					//old, buggy code replication, round THREE: Go! -Z
					GuyH::getNPC()->step = ((value/10000)/100.0);
				}
			}
		}
		break;
		
		case NPCGRAVITY:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->Gravity") == SH::_NoError)
			{
				if(value)
					GuyH::getNPC()->moveflags |= FLAG_OBEYS_GRAV;
				else
					GuyH::getNPC()->moveflags &= ~FLAG_OBEYS_GRAV;
			}
		}
		break;
		
		case NPCXOFS:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->DrawXOffset") == SH::_NoError)
				GuyH::getNPC()->xofs = zfix(value / 10000);
		}
		break;
		
		case NPCYOFS:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->DrawYOffset") == SH::_NoError)
				GuyH::getNPC()->yofs = zfix(value / 10000) + (get_qr(qr_OLD_DRAWOFFSET)?playing_field_offset:original_playing_field_offset);
		}
		break;
		
		case NPCSHADOWXOFS:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->ShadowXOffset") == SH::_NoError)
				GuyH::getNPC()->shadowxofs = zfix(value / 10000);
		}
		break;
		
		case NPCSHADOWYOFS:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->ShadowYOffset") == SH::_NoError)
				GuyH::getNPC()->shadowyofs = zfix(value / 10000);
		}
		break;
		
		case NPCTOTALDYOFFS:
			break; //READ-ONLY
		
		case NPCROTATION:
		{
			if ( get_qr(qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"npc->Rotation");
				break;
			}
			if(GuyH::loadNPC(ri->guyref, "npc->Rotation") == SH::_NoError)
				GuyH::getNPC()->rotation = (value / 10000);
		}
		break;
		
		case NPCZOFS:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->DrawZOffset") == SH::_NoError)
				GuyH::getNPC()->zofs = zfix(value / 10000);
		}
		break;
		
		#define SET_NPC_VAR_INT(member, str) \
		{ \
			if(GuyH::loadNPC(ri->guyref, str) == SH::_NoError) \
				GuyH::getNPC()->member = value / 10000; \
		}
		
		
		case NPCISCORE:
			if(GuyH::loadNPC(ri->guyref, "npc->isCore") == SH::_NoError)
			GuyH::getNPC()->isCore = ( (value / 10000) ? true : false );
			break;
		
		
		case NPCDIR:
			SET_NPC_VAR_INT(dir, "npc->Dir") break;
			
		case NPCHITDIR:
			if(GuyH::loadNPC(ri->guyref, "npc->HitDir") != SH::_NoError)
				(GuyH::getNPC()->hitdir) = vbound(value/10000, 0, 3);
				
			break;
			
		case NPCSLIDECLK:
			if(GuyH::loadNPC(ri->guyref, "npc->SlideClock") != SH::_NoError)
				GuyH::getNPC()->sclk = value/10000;//vbound(value/10000,0,255);
				
			break;
			
		case NPCFADING:
			if(GuyH::loadNPC(ri->guyref, "npc->Fading") != SH::_NoError)
				(GuyH::getNPC()->fading) = vbound(value/10000,0,4);
				
			break;
			
		case NPCHALTCLK:
			if(GuyH::loadNPC(ri->guyref, "npc->Halt") != SH::_NoError)
				(GuyH::getNPC()->clk2) = vbound(value/10000,0,214748);
				
			break;
			
		case NPCFRAME:
			if(GuyH::loadNPC(ri->guyref, "npc->Frame") != SH::_NoError)
				(GuyH::getNPC()->clk2) = vbound(value/10000,0,214748);
				
			break;
		
		case NPCMOVESTATUS:
			if(GuyH::loadNPC(ri->guyref, "npc->MoveStatus") != SH::_NoError)
				(GuyH::getNPC()->movestatus) = vbound(value/10000,0,3);
				
			break;
			
		case NPCRATE:
			SET_NPC_VAR_INT(rate, "npc->Rate") break;
			
		case NPCHOMING:
			SET_NPC_VAR_INT(homing, "npc->Homing") break;
			
		case NPCFRAMERATE:
			SET_NPC_VAR_INT(frate, "npc->ASpeed") break;
			
		case NPCHALTRATE:
			SET_NPC_VAR_INT(hrate, "npc->HaltRate") break;
		
		case NPCRANDOM:
			SET_NPC_VAR_INT(rate, "npc->Random") break;
			
		case NPCDRAWTYPE:
			SET_NPC_VAR_INT(drawstyle, "npc->DrawStyle") break;
			
		case NPCHP:
			SET_NPC_VAR_INT(hp, "npc->HP") break;
		
		case NPCORIGINALHP:
			SET_NPC_VAR_INT(starting_hp, "npc->OriginalHP") break;
			
			//case NPCID:        SET_NPC_VAR_INT(id, "npc->ID") break; ~Disallowed
		case NPCDP:
			SET_NPC_VAR_INT(dp, "npc->Damage") break;
			
		case NPCTYPE:
		{
			SET_NPC_VAR_INT(family, "npc->Type") break;
		}
		
		case NPCWDP:
			SET_NPC_VAR_INT(wdp, "npc->WeaponDamage") break;
			
		case NPCITEMSET:
			SET_NPC_VAR_INT(item_set, "npc->ItemSet") break;
			
		case NPCBOSSPAL:
			SET_NPC_VAR_INT(bosspal, "npc->BossPal") break;
			
		case NPCBGSFX:
			if(GuyH::loadNPC(ri->guyref, "npc->SFX") == SH::_NoError)
			{
				enemy *en=GuyH::getNPC();
				int32_t newSFX = value / 10000;
				
				// Stop the old sound and start the new one
				if(en->bgsfx != newSFX)
				{
					en->stop_bgsfx(GuyH::getNPCIndex(ri->guyref));
					cont_sfx(newSFX);
					en->bgsfx = newSFX;
				}
			}
			break;
			
			
		case NPCEXTEND:
			SET_NPC_VAR_INT(extend, "npc->Extend") break;
			
		case NPCHXOFS:
			SET_NPC_VAR_INT(hxofs, "npc->HitXOffset") break;
			
		case NPCHYOFS:
			SET_NPC_VAR_INT(hyofs, "npc->HitYOffset") break;
			
		case NPCHXSZ:
			SET_NPC_VAR_INT(hit_width, "npc->HitWidth") break;
			
		case NPCHYSZ:
			SET_NPC_VAR_INT(hit_height, "npc->HitHeight") break;
			
		case NPCHZSZ:
			SET_NPC_VAR_INT(hzsz, "npc->HitZHeight") break;
			
		case NPCCOLLDET:
			SET_NPC_VAR_INT(scriptcoldet, "npc->CollDetection") break;
			
		case NPCENGINEANIMATE:
			SET_NPC_VAR_INT(do_animation, "npc->Animation") break;
			
		case NPCSTUN:
			SET_NPC_VAR_INT(stunclk, "npc->Stun") break;
			
		case NPCHUNGER:
			SET_NPC_VAR_INT(grumble, "npc->Hunger") break;
		
		case NPCWEAPSPRITE:
			SET_NPC_VAR_INT(wpnsprite, "npc->WeaponSprite") break;
			
		case NPCCSET:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->CSet") == SH::_NoError)
			{
				GuyH::getNPC()->cs = (value / 10000) & 0xF;
				if(GuyH::getNPC()->family == eeLEV) GuyH::getNPC()->dcset = (value / 10000) & 0xF;
			}
		}
		break;
		
		//Bounds on value
		case NPCTXSZ:
		{
			int32_t height = value / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->TileWidth") == SH::_NoError &&
					BC::checkBounds(height, 0, 20, "npc->TileWidth") == SH::_NoError)
				GuyH::getNPC()->txsz = height;
		}
		break;
		
		case NPCTYSZ:
		{
			int32_t width = value / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->TileHeight") == SH::_NoError &&
					BC::checkBounds(width, 0, 20, "npc->TileHeight") == SH::_NoError)
				GuyH::getNPC()->tysz = width;
		}
		break;
		
		case NPCOTILE:
		{
			int32_t tile = value / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->OriginalTile") == SH::_NoError &&
					BC::checkTile(tile, "npc->OriginalTile") == SH::_NoError)
				GuyH::getNPC()->o_tile = tile;
		}
		break;
		
		case NPCTILE:
		{
			int32_t tile = value / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->Tile") == SH::_NoError &&
					BC::checkTile(tile, "npc->Tile") == SH::_NoError)
				GuyH::getNPC()->tile = tile;
		}
		break;
		
		case NPCSCRIPTTILE:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->ScriptTile") == SH::_NoError)
				GuyH::getNPC()->scripttile = vbound((value/10000),-1, NEWMAXTILES-1);
		}
		break;
		
		case NPCSCRIPTFLIP:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->ScriptFlip") == SH::_NoError )
				GuyH::getNPC()->scriptflip = vbound(value/10000, -1, 127);
		}
		break;
		
		case NPCWEAPON:
		{
			int32_t weapon = value / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->Weapon") == SH::_NoError &&
					BC::checkBounds(weapon, 0, MAXWPNS-1, "npc->Weapon") == SH::_NoError)
			{
				GuyH::getNPC()->wpn = weapon;
			
				//al_trace("Correct weapon sprite is: %d /n", FFCore.GetDefaultWeaponSprite(weapon));
				if ( get_qr(qr_SETENEMYWEAPONSPRITESONWPNCHANGE) ) //this should probably just be an extra_rule
				{
					GuyH::getNPC()->wpnsprite = FFCore.GetDefaultWeaponSprite(weapon);
				}
				//else GuyH::getNPC()->wpnsprite = FFCore.GetDefaultWeaponSprite(weapon); //just to test that this works. 
			}
		}
		break;
		
		//Indexed
		case NPCDEFENSED:
		{
			int32_t a = ri->d[rINDEX] / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->Defense") == SH::_NoError &&
					BC::checkBounds(a, 0, (edefLAST255), "npc->Defense") == SH::_NoError)
			{
				if ( ( get_qr(qr_250WRITEEDEFSCRIPT) ) && a == edefSCRIPT ) 
				{
					for ( int32_t sd = edefSCRIPT01; sd <= edefSCRIPT10; sd++ )
					{
						GuyH::getNPC()->defense[sd] = vbound((value / 10000),0,255);
					}
				}
				//no else here, is intentional as a fallthrough. -Z
				GuyH::getNPC()->defense[a] = vbound((value / 10000),0,255);
			}
		}
		break;
		
		case NPCPARENTUID:
			if(GuyH::loadNPC(ri->guyref, "npc->ParentUID") == SH::_NoError)
			{
				GuyH::getNPC()->parent_script_UID = value; //literal, not *10000
			}
			break;
		
		case NPCHITBY:
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->HitBy[]") == SH::_NoError)
			{
				switch(indx)
				{
					//screen index objects
					case 0:
					case 1:
					case 2:
					case 3:
					case 8:
					case 9:
					case 10:
					case 11:
					case 12:
					case 16:
					{
						GuyH::getNPC()->hitby[indx] = vbound((value / 10000),0,255); //Once again, why did I vbound this, and why did I allow it to be written? UIDs are LONGs, with a starting value of 0.0001. -Z
							break;
					}
					//UIDs
					case 4:
					case 5:
					case 6:
					case 7:
					case 13:
					case 14:
					case 15:
					{
						GuyH::getNPC()->hitby[indx] = value; //Once again, why did I vbound this, and why did I allow it to be written? UIDs are LONGs, with a starting value of 0.0001. -Z
							break;
					}
					default: al_trace("Invalid index used with npc->hitBy[%d]. /n", indx); break;
				}
			}
			break;
		}
		
		//2.future compat. -Z
		
		
		case NPCSCRDEFENSED:
		{
			int32_t a = ri->d[rINDEX] / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->ScriptDefense") == SH::_NoError &&
					BC::checkBounds(a, 0, edefSCRIPTDEFS_MAX, "npc->ScriptDefense") == SH::_NoError)
				GuyH::getNPC()->defense[a+edefSCRIPT01] = value / 10000;
		}
		break;
		
		case NPCMISCD:
		{
			int32_t a = ri->d[rINDEX] / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->Misc") == SH::_NoError &&
					BC::checkMisc32(a, "npc->Misc") == SH::_NoError)
				GuyH::getNPC()->miscellaneous[a] = value;
				
		}
		
		break;
		
		case NPCINITD:
		{
			int32_t a = ri->d[rINDEX] / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->InitD[]") == SH::_NoError)
			{
				//enemy *e = (enemy*)guys.spr(ri->guyref);
				//e->initD[a] = value; 
				GuyH::getNPC()->initD[a] = value;
			}
		}
		break;
		
		case NPCSCRIPT:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->Script") == SH::_NoError)
			{
				if ( get_qr(qr_CLEARINITDONSCRIPTCHANGE))
				{
					for(int32_t q=0; q<8; q++)
						GuyH::getNPC()->initD[q] = 0;
				}
				GuyH::getNPC()->script = vbound((value/10000), 0, NUMSCRIPTGUYS-1);
				on_reassign_script_engine_data(ScriptType::NPC, ri->guyref);
			}
		}
		break;
		
		//npc->Attributes[] setter -Z
		case NPCDD:
		{
			int32_t a = ri->d[rINDEX] / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->Attributes") == SH::_NoError &&
					BC::checkBounds(a, 0, 31, "npc->Attributes") == SH::_NoError)
		
			switch(a)
			{
				case 0: GuyH::getNPC()->dmisc1 = value / 10000; break;
				case 1: GuyH::getNPC()->dmisc2 = value / 10000; break;
				case 2: GuyH::getNPC()->dmisc3 = value / 10000; break;
				case 3: GuyH::getNPC()->dmisc4 = value / 10000; break;
				case 4: GuyH::getNPC()->dmisc5 = value / 10000; break;
				case 5: GuyH::getNPC()->dmisc6 = value / 10000; break;
				case 6: GuyH::getNPC()->dmisc7 = value / 10000; break;
				case 7: GuyH::getNPC()->dmisc8 = value / 10000; break;
				case 8: GuyH::getNPC()->dmisc9 = value / 10000; break;
				case 9: GuyH::getNPC()->dmisc10 = value / 10000; break;
				case 10: GuyH::getNPC()->dmisc11 = value / 10000; break;
				case 11: GuyH::getNPC()->dmisc12 = value / 10000; break;
				case 12: GuyH::getNPC()->dmisc13 = value / 10000; break;
				case 13: GuyH::getNPC()->dmisc14 = value / 10000; break;
				case 14: GuyH::getNPC()->dmisc15 = value / 10000; break;
				case 15: GuyH::getNPC()->dmisc16 = value / 10000; break;
				case 16: GuyH::getNPC()->dmisc17 = value / 10000; break;
				case 17: GuyH::getNPC()->dmisc18 = value / 10000; break;
				case 18: GuyH::getNPC()->dmisc19 = value / 10000; break;
				case 19: GuyH::getNPC()->dmisc20 = value / 10000; break;
				case 20: GuyH::getNPC()->dmisc21 = value / 10000; break;
				case 21: GuyH::getNPC()->dmisc22 = value / 10000; break;
				case 22: GuyH::getNPC()->dmisc23 = value / 10000; break;
				case 23: GuyH::getNPC()->dmisc24 = value / 10000; break;
				case 24: GuyH::getNPC()->dmisc25 = value / 10000; break;
				case 25: GuyH::getNPC()->dmisc26 = value / 10000; break;
				case 26: GuyH::getNPC()->dmisc27 = value / 10000; break;
				case 27: GuyH::getNPC()->dmisc28 = value / 10000; break;
				case 28: GuyH::getNPC()->dmisc28 = value / 10000; break;
				case 29: GuyH::getNPC()->dmisc30 = value / 10000; break;
				case 30: GuyH::getNPC()->dmisc31 = value / 10000; break;
				case 31: GuyH::getNPC()->dmisc32 = value / 10000; break;
				default: break;
			}
			break;
		}
		
			
		case NPCINVINC:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->InvFrames") == SH::_NoError)
				GuyH::getNPC()->hclk = (int32_t)value/10000;
		}
		break;
		
		case NPCSUPERMAN:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->Invincible") == SH::_NoError)
				GuyH::getNPC()->superman = (int32_t)value/10000;
		}
		break;
		
		case NPCHASITEM:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->HasItem") == SH::_NoError)
				GuyH::getNPC()->itemguy = (value/10000)?1:0;
		}
		break;
		
		case NPCRINGLEAD:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->Ringleader") == SH::_NoError)
				GuyH::getNPC()->leader = (value/10000)?1:0;
		}
		break;
		
		case NPCSHIELD:
		{
			int32_t indx = ri->d[rINDEX];
			if(GuyH::loadNPC(ri->guyref, "npc->Shield[]") == SH::_NoError)
			{
				switch(indx)
				{
					case 0:
					{
						(ri->d[rINDEX2])? (GuyH::getNPC()->flags |= inv_front) : (GuyH::getNPC()->flags &= ~inv_front);
						break;
					}
					case 1:
					{
						(ri->d[rINDEX2])? (GuyH::getNPC()->flags |= inv_left) : (GuyH::getNPC()->flags &= ~inv_left);
						break;
					}
					case 2:
					{
						(ri->d[rINDEX2])? (GuyH::getNPC()->flags |= inv_right) : (GuyH::getNPC()->flags &= ~inv_right);
						break;
					}
					case 3:
					{
						(ri->d[rINDEX2])? (GuyH::getNPC()->flags |= inv_back) : (GuyH::getNPC()->flags &= ~inv_back);
						break;
					}
					case 4: //shield can be broken
					{
						(ri->d[rINDEX2])? (GuyH::getNPC()->flags |= guy_bkshield) : (GuyH::getNPC()->flags &= ~guy_bkshield);
						break;
					}
					default:
					{
						Z_scripterrlog("Invalid Array Index passed to npc->Shield[]: %d\n", indx); 
						break;
					}
				}
			}
		}
		break;
		
		case NPCFROZENTILE:
			SET_NPC_VAR_INT(frozentile, "npc->FrozenTile"); break;
		case NPCFROZENCSET:
			SET_NPC_VAR_INT(frozencset, "npc->FrozenCSet"); break;
		case NPCFROZEN:
			SET_NPC_VAR_INT(frozenclock, "npc->Frozen"); break;
		
		case NPCBEHAVIOUR: 
		{
			if(GuyH::loadNPC(ri->guyref, "npc->Behaviour[]") != SH::_NoError) 
			{
				break;
			}
			int32_t index = vbound(ri->d[rINDEX]/10000,0,4);
			switch(index)
			{
				case 0:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG1 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG1;
					break;
				case 1:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG2 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG2;
					break;
				case 2:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG3 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG3;
					break;
				case 3:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG4 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG4; 
					break;
				case 4:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG5 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG5;
					break;
				case 5:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG6 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG6; 
					break;
				case 6:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG7 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG7;
					break;
				case 7:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG8 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG8;
					break;
				case 8:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG9 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG9;
					break;		    
				case 9:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG10 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG10;
					break;
				case 10:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG11 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG11; 
					break;
				case 11:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG12 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG12;
					break;
				case 12:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG13 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG13;
					break;
				case 13:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG14 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG14;
					break;
				case 14:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG15 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG15; 
					break;
				case 15:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG16 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG16; 
					break;
				
				
				default: 
					break;
			}
				
			break;
		}
		case NPCFALLCLK:
			if(GuyH::loadNPC(ri->guyref, "npc->Falling") == SH::_NoError)
			{
				if(GuyH::getNPC()->fallclk != 0 && value == 0)
				{
					GuyH::getNPC()->cs = GuyH::getNPC()->old_cset;
					GuyH::getNPC()->tile = GuyH::getNPC()->o_tile;
				}
				else if(GuyH::getNPC()->fallclk == 0 && value != 0) GuyH::getNPC()->old_cset = GuyH::getNPC()->cs;
				GuyH::getNPC()->fallclk = vbound(value/10000,0,70);
			}
			break;
		case NPCFALLCMB:
			if(GuyH::loadNPC(ri->guyref, "npc->FallCombo") == SH::_NoError)
			{
				GuyH::getNPC()->fallCombo = vbound(value/10000,0,MAXCOMBOS-1);
			}
			break;
		case NPCDROWNCLK:
			if(GuyH::loadNPC(ri->guyref, "npc->Drowning") == SH::_NoError)
			{
				if(GuyH::getNPC()->drownclk != 0 && value == 0)
				{
					GuyH::getNPC()->cs = GuyH::getNPC()->old_cset;
					GuyH::getNPC()->tile = GuyH::getNPC()->o_tile;
				}
				else if(GuyH::getNPC()->drownclk == 0 && value != 0) GuyH::getNPC()->old_cset = GuyH::getNPC()->cs;
				GuyH::getNPC()->drownclk = vbound(value/10000,0,70);
			}
			break;
		case NPCDROWNCMB:
			if(GuyH::loadNPC(ri->guyref, "npc->DrowningCombo") == SH::_NoError)
			{
				GuyH::getNPC()->drownCombo = vbound(value/10000,0,MAXCOMBOS-1);
			}
		case NPCFAKEZ:
			{
				if(GuyH::loadNPC(ri->guyref, "npc->FakeZ") == SH::_NoError)
				{
					if(!never_in_air(GuyH::getNPC()->id))
					{
						if(value < 0)
							GuyH::getNPC()->fakez = 0_zf;
						else
							GuyH::getNPC()->fakez = get_qr(qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000);
							
						if(GuyH::hasHero())
							Hero.setFakeZfix(get_qr(qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000));
					}
				}
			}
			break;
		case NPCMOVEFLAGS:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->MoveFlags[]") == SH::_NoError)
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(BC::checkBounds(indx, 0, 15, "npc->MoveFlags[]") == SH::_NoError)
				{
					//All bits, in order, of a single byte; just use bitwise
					int32_t bit = 1<<indx;
					if(value)
						GuyH::getNPC()->moveflags |= bit;
					else
						GuyH::getNPC()->moveflags &= ~bit;
				}
			}
			break;
		}
		
		case NPCGLOWRAD:
			if(GuyH::loadNPC(ri->guyref, "npc->LightRadius") == SH::_NoError)
			{
				GuyH::getNPC()->glowRad = vbound(value/10000,0,255);
			}
			break;
		case NPCGLOWSHP:
			if(GuyH::loadNPC(ri->guyref, "npc->LightShape") == SH::_NoError)
			{
				GuyH::getNPC()->glowShape = vbound(value/10000,0,255);
			}
			break;
			
		case NPCSHADOWSPR:
			if(GuyH::loadNPC(ri->guyref, "npc->ShadowSprite") == SH::_NoError)
			{
				GuyH::getNPC()->spr_shadow = vbound(value/10000,0,255);
			}
			break;
		case NPCSPAWNSPR:
			if(GuyH::loadNPC(ri->guyref, "npc->SpawnSprite") == SH::_NoError)
			{
				GuyH::getNPC()->spr_spawn = vbound(value/10000,0,255);
			}
			break;
		case NPCDEATHSPR:
			if(GuyH::loadNPC(ri->guyref, "npc->DeathSprite") == SH::_NoError)
			{
				GuyH::getNPC()->spr_death = vbound(value/10000,0,255);
			}
			break;
		case NPCSWHOOKED:
			break; //read-only
		case NPCCANFLICKER:
			if(GuyH::loadNPC(ri->guyref, "npc->InvFlicker") == SH::_NoError)
			{
				GuyH::getNPC()->setCanFlicker(value != 0);
			}
			break;
		case NPCFLICKERCOLOR:
			if (GuyH::loadNPC(ri->guyref, "npc->FlickerColor") == SH::_NoError)
			{
				GuyH::getNPC()->flickercolor = vbound(value/10000,-1,255);
			}
			break;
		case NPCFLICKERTRANSP:
			if (GuyH::loadNPC(ri->guyref, "npc->FlickerTransparencyPasses") == SH::_NoError)
			{
				GuyH::getNPC()->flickertransp = vbound(value / 10000, -1, 255);
			}
			break;
		
		
	///----------------------------------------------------------------------------------------------------//
	//Game Information
		
		case GAMEDEATHS:
			game->set_deaths(value/10000);
			break;
			
		case GAMECHEAT:
			cheat=vbound(value/10000,0,4);
			if(maxcheat < cheat) maxcheat = cheat;
			if(cheat) game->did_cheat(true);
			break;
		
		case GAMEMAXCHEAT:
			maxcheat=vbound(value/10000,0,4);
			game->set_cheat(maxcheat);
			if(cheat > maxcheat) cheat = maxcheat;
			break;
			
		case GAMETIME:
			game->set_time(value);
			break; // Can't multiply by 10000 or the maximum result is too big
		
		case ACTIVESSSPEED:
			Hero.subscr_speed = vbound((value/10000),1,85);
			break; // Can't multiply by 10000 or the maximum result is too big
			
		case GAMETIMEVALID:
			game->set_timevalid((value/10000)?1:0);
			break;
			
		case GAMEHASPLAYED:
			game->set_hasplayed((value/10000)?1:0);
			break;
		
		case TYPINGMODE:
			FFCore.kb_typing_mode = ((value/10000)?true:false);
			break;
		
		case SKIPCREDITS:
			FFCore.skip_ending_credits = ((value/10000)?true:false);
			break;
		
		case SKIPF6:
			set_qr(qr_NOCONTINUE,((value/10000)?1:0));
			break;
		
		
			
		case GAMEGUYCOUNT:
		{
			int32_t mi2 = (currmap*MAPSCRSNORMAL)+(ri->d[rINDEX]/10000);
			game->guys[mi2]=value/10000;
		}
		break;
		
		case GAMECONTSCR:
			game->set_continue_scrn(value/10000);
			break;
			
		case GAMECONTDMAP:
			game->set_continue_dmap(value/10000);
			break;
			
		case GAMEENTRSCR:
			lastentrance=value/10000;
			break;
			
		case GAMEENTRDMAP:
			lastentrance_dmap=value/10000;
			break;
			
		case GAMECOUNTERD:
			game->set_counter(value/10000, (ri->d[rINDEX])/10000);
			break;
			
		case GAMEMCOUNTERD:
			game->set_maxcounter(value/10000, (ri->d[rINDEX])/10000);
			break;
			
		case GAMEDCOUNTERD:
			game->set_dcounter(value/10000, (ri->d[rINDEX])/10000);
			break;
			
		case GAMEGENERICD:
		{
			auto indx = ri->d[rINDEX] / 10000;
			auto val = value/10000;
			switch(indx)
			{
				case genCONTHP:
				{
					if(!get_qr(qr_SCRIPT_CONTHP_IS_HEARTS) || game->get_cont_percent())
						game->set_generic(val, indx);
					else
						game->set_generic(val*game->get_hp_per_heart(), indx);
					break;
				}
				default:
					game->set_generic(val, indx);
					break;
			}
			break;
		}
		case GAMEMISC:
		{
			int32_t indx = ri->d[rINDEX]/10000;
			if ( indx < 0 || indx > 31 )
			{
				Z_scripterrlog("Invalid index used to access Game->Misc: %d\n", indx);
			}
			else 
			{
				QMisc.questmisc[indx] = (value/((get_qr(qr_OLDQUESTMISC)) ? 10000 : 1));
			}
			break;
		}
		case GAMEITEMSD:
			game->set_item((ri->d[rINDEX])/10000,(value!=0));
			break;
		
		case DISABLEDITEM:
		{
			int id = (ri->d[rINDEX])/10000;
			if(unsigned(id) >= MAXITEMS)
				break;
			game->items_off[id]=value/10000;
			removeFromItemCache(itemsbuf[id].family);
			break;
		}
		
		case GAMESUSPEND:
		{
			int32_t inx = (ri->d[rINDEX])/10000;
			if ( (unsigned) inx > (susptLAST-1) )
			{
				Z_scripterrlog("Invalid array index [%d] passed to Game->Suspend[]\n");
				break;
			}
			FFCore.system_suspend[inx]= ( (value) ? 1 : 0 );
			break;
		}
			
		case GAMELITEMSD:
		{
			int32_t ind = (ri->d[rINDEX])/10000;
			if(unsigned(ind) < MAXLEVELS)
				game->lvlitems[ind]=value/10000;
			break;
		}
		case GAMELSWITCH:
		{
			int32_t ind = (ri->d[rINDEX])/10000;
			if(unsigned(ind) < MAXLEVELS)
				game->lvlswitches[ind]=value;
			break;
		}
		case GAMEGSWITCH:
		{
			int32_t ind = (ri->d[rINDEX])/10000;
			if(unsigned(ind) < NUM_GSWITCHES)
				game->gswitch_timers[ind]=value/10000;
			break;
		}
		case GAMEBOTTLEST:
			game->set_bottle_slot((ri->d[rINDEX])/10000,value/10000);
			break;
		
		case TANGOARR:
		{
			int32_t inx = (ri->d[rINDEX])/10000;
			if ( ((unsigned)inx) > 255 )
			{
				Z_scripterrlog("Invalid index %d supplied to Game->Tango[].\n", inx);
				break;
			}
			else
			{
				FFCore.TangoArray[inx]=value/10000;
				break;
			}
		}
		
		case GHOSTARR:
		{
			int32_t inx = (ri->d[rINDEX])/10000;
			if ( ((unsigned)inx) > 255 )
			{
				Z_scripterrlog("Invalid index %d supplied to Game->Ghost[].\n", inx);
				break;
			}
			else
			{
			
				FFCore.GhostArray[inx]=value/10000;;
				break;
			}
		}
		case STDARR:
		{
			int32_t inx = (ri->d[rINDEX])/10000;
			if ( ((unsigned)inx) > 255 )
			{
				Z_scripterrlog("Invalid index %d supplied to Game->STD[].\n", inx);
				break;
			}
			else
			{
				FFCore.StdArray[inx]=value/10000;
				break;
			}
		}
		
		case GAMEMISCSPR:
		{
			int32_t inx = (ri->d[rINDEX])/10000;
			if ( ((unsigned)inx) > sprMAX )
			{
				Z_scripterrlog("Invalid index %d supplied to Game->MiscSprites[].\n", inx);
			}
			else
			{
				QMisc.sprites[inx] = vbound(value/10000, 0, 255);
			}
			break;
		}
		case GAMEMISCSFX:
		{
			int32_t inx = (ri->d[rINDEX])/10000;
			if ( ((unsigned)inx) > sfxMAX )
			{
				Z_scripterrlog("Invalid index %d supplied to Game->MiscSFX[].\n", inx);
			}
			else
			{
				QMisc.miscsfx[inx] = vbound(value/10000, 0, 255);
			}
			break;
		}
		case GAMEOVERRIDEITEMS:
		{
			int32_t ind = (ri->d[rINDEX])/10000;
			if(unsigned(ind) >= itype_max)
			{
				Z_scripterrlog("Invalid index %d supplied to Game->OverrideItems[].\n", ind);
			}
			else
			{
				auto val = value/10000;
				game->OverrideItems[ind] = (val < -1 || val >= MAXITEMS) ? -2 : val;
			}
			break;
		}
		case GAMEEVENTDATA:
		{
			int32_t inx = (ri->d[rINDEX])/10000;
			if ( ((unsigned)inx) < FFCore.eventData.size() )
			{
				FFCore.eventData[inx] = value;
			}
			break;
		}
		case GAMEMOUSECURSOR:
		{
			int v = value/10000;
			if(v < 0 || v >= ZCM_MAX)
				break;
			game_mouse_index = v;
			game_mouse();
			break;
		}
		case GAMETRIGGROUPS:
			break; //read-only
		
		case GAMELKEYSD:
			game->lvlkeys[(ri->d[rINDEX])/10000]=value/10000;
			break;
			
		case GAMEGRAVITY:
		{
			int32_t indx = ri->d[rINDEX]/10000;
			if(indx < 0 || indx > 3)
			{
				Z_scripterrlog("Invalid index used to access Game->Gravity[]: %d\n", indx);
			}
			else
			{
				switch(indx)
				{
					case 0: //Gravity Strength
						zinit.gravity = value;
						break;
					case 1: //Terminal Velocity
						zinit.terminalv = value / 100;
						break;
					case 2: //Sprite Layer Threshold
						zinit.jump_hero_layer_threshold = value / 10000;
						break;
					case 3: //Air Drag
						zinit.air_drag = zslongToFix(value);
						break;
				}
			}
			break;
		}
			
		case SCREENSTATED:
		{
			int32_t mi2 = (currmap*MAPSCRSNORMAL)+currscr;
			(value)?setmapflag(mi2, 1<<((ri->d[rINDEX])/10000)) : unsetmapflag(mi2, 1 << ((ri->d[rINDEX]) / 10000));
		}
		break;
		case SCREENEXSTATED:
		{
			int32_t mi2 = (currmap*MAPSCRSNORMAL)+currscr;
			(value)?setxmapflag(mi2, 1<<((ri->d[rINDEX])/10000)) : unsetxmapflag(mi2, 1 << ((ri->d[rINDEX]) / 10000));
		}
		break;
		case SCREENLENSSHOWS:
		{
			int ind = ri->d[rINDEX]/10000;
			if(ind < 0 || ind > 6)
				Z_scripterrlog("Bad index Screen->LensShows[%d]\n",ind);
			else
			{
				SETFLAG(tmpscr->lens_show, 1<<ind, value);
				if(value) tmpscr->lens_hide &= ~(1<<ind);
			}
			break;
		}
		case SCREENLENSHIDES:
		{
			int ind = ri->d[rINDEX]/10000;
			if(ind < 0 || ind > 6)
				Z_scripterrlog("Bad index Screen->LensHides[%d]\n",ind);
			else
			{
				SETFLAG(tmpscr->lens_hide, 1<<ind, value);
				if(value) tmpscr->lens_show &= ~(1<<ind);
			}
			break;
		}
		case SCREENSCRDATASIZE:
		{
			auto mi = get_total_mi();
			if(mi < 0) break;
			game->scriptDataResize(mi, value/10000);
			break;
		}
		case SCREENSCRDATA:
		{
			auto mi = get_total_mi();
			if(mi < 0) break;
			size_t indx = ri->d[rINDEX]/10000;
			if(indx >= game->scriptDataSize(mi))
			{
				Z_scripterrlog("Invalid index passed to Screen->Data[]: %d\n", indx);
				break;
			}
			game->screen_data[mi][indx] = value;
			break;
		}
		
		case SCREENSTATEDD:
		{
			int32_t mi2 = ri->d[rINDEX]/10000;
			mi2 -= 8*(mi2/MAPSCRS);
			
			if(BC::checkMapID(mi2>>7, "Game->SetScreenState") == SH::_NoError)
				(value)?setmapflag(mi2, 1<<(ri->d[rINDEX2]/10000)) : unsetmapflag(mi2, 1 << (ri->d[rINDEX2] / 10000), true);
		}
		break;
		
		case GAMEGUYCOUNTD:
			game->guys[(currmap*MAPSCRSNORMAL)+(ri->d[rINDEX]/10000)] = value / 10000;
			break;
			
		case GAMECLICKFREEZE:
			disableClickToFreeze=value==0;
			break;
		
		
		case NOACTIVESUBSC:
			Hero.stopSubscreenFalling((value/10000)?1:0);
			break;
			
	///----------------------------------------------------------------------------------------------------//
	//BottleTypes
		case BOTTLECOUNTER:
		{
			if(bottletype* ptr = checkBottleData(ri->bottletyperef, "Counter[]"))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				int32_t ctr = vbound(value/10000, -1, MAX_COUNTERS-1);
				if(unsigned(indx) > 2)
				{
					Z_scripterrlog("Invalid index %d supplied to bottledata->Counter[].\n", indx);
					break;
				}
				ptr->counter[indx] = ctr;
			}
		}
		break;
		
		case BOTTLEAMOUNT:
		{
			if(bottletype* ptr = checkBottleData(ri->bottletyperef, "Amount[]"))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				int32_t amnt = vbound(value/10000, 0, 65535);
				if(unsigned(indx) > 2)
				{
					Z_scripterrlog("Invalid index %d supplied to bottledata->Amount[].\n", indx);
					break;
				}
				ptr->amount[indx] = amnt;
			}
		}
		break;
		
		case BOTTLEPERCENT:
		{
			if(bottletype* ptr = checkBottleData(ri->bottletyperef, "IsPercent[]"))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(unsigned(indx) > 2)
				{
					Z_scripterrlog("Invalid index %d supplied to bottledata->IsPercent[].\n", indx);
					break;
				}
				SETFLAG(ptr->flags, 1<<indx, value);
			}
		}
		break;
		
		case BOTTLEFLAGS:
		{
			if(bottletype* ptr = checkBottleData(ri->bottletyperef, "Flags[]"))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(unsigned(indx) > 3)
				{
					Z_scripterrlog("Invalid index %d supplied to bottledata->Flags[].\n", indx);
					break;
				}
				int32_t flag = 0;
				switch(indx)
				{
					case 0: flag = BTFLAG_AUTOONDEATH; break;
					case 1: flag = BTFLAG_ALLOWIFFULL; break;
					case 2: flag = BTFLAG_CURESWJINX; break;
					case 3: flag = BTFLAG_CUREITJINX; break;
				}
				SETFLAG(ptr->flags, flag, value);
			}
		}
		break;
		
		case BOTTLENEXT:
		{
			if(bottletype* ptr = checkBottleData(ri->bottletyperef, "NextType"))
			{
				ptr->next_type = vbound(value/10000, 0, 64);
			}
		}
		break;
	///----------------------------------------------------------------------------------------------------//
	//BottleShops
		case BSHOPFILL:
		{
			if(bottleshoptype* ptr = checkBottleShopData(ri->bottleshopref, "Fill[]"))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(unsigned(indx) > 2)
				{
					Z_scripterrlog("Invalid index %d supplied to bottleshopdata->Fill[].\n", indx);
					break;
				}
				ptr->fill[indx] = vbound(value/10000, 0, 64);
			}
		}
		break;
		
		case BSHOPCOMBO:
		{
			if(bottleshoptype* ptr = checkBottleShopData(ri->bottleshopref, "Combo[]"))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(unsigned(indx) > 2)
				{
					Z_scripterrlog("Invalid index %d supplied to bottleshopdata->Combo[].\n", indx);
					break;
				}
				ptr->comb[indx] = vbound(value/10000, 0, MAXCOMBOS-1);
			}
		}
		break;
		
		case BSHOPCSET:
		{
			if(bottleshoptype* ptr = checkBottleShopData(ri->bottleshopref, "CSet[]"))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(unsigned(indx) > 2)
				{
					Z_scripterrlog("Invalid index %d supplied to bottleshopdata->CSet[].\n", indx);
					break;
				}
				ptr->cset[indx] = vbound(value/10000, 0, 11);
			}
		}
		break;
		
		case BSHOPPRICE:
		{
			if(bottleshoptype* ptr = checkBottleShopData(ri->bottleshopref, "Price[]"))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(unsigned(indx) > 2)
				{
					Z_scripterrlog("Invalid index %d supplied to bottleshopdata->Price[].\n", indx);
					break;
				}
				ptr->price[indx] = vbound(value/10000, 0, 65535);
			}
		}
		break;
		
		case BSHOPSTR:
		{
			if(bottleshoptype* ptr = checkBottleShopData(ri->bottleshopref, "InfoString[]"))
			{
				int32_t indx = ri->d[rINDEX]/10000;
				if(unsigned(indx) > 2)
				{
					Z_scripterrlog("Invalid index %d supplied to bottleshopdata->InfoString[].\n", indx);
					break;
				}
				ptr->str[indx] = vbound(value/10000, 0, 65535);
			}
		}
		break;
	///----------------------------------------------------------------------------------------------------//
	//DMap Information

		#define SET_DMAP_VAR(member, str) \
		{ \
			int32_t ID = ri->d[rINDEX] / 10000; \
			if(BC::checkDMapID(ID, str) == SH::_NoError) \
				DMaps[ID].member = value / 10000; \
		}

		case DMAPFLAGSD:
			SET_DMAP_VAR(flags, "Game->DMapFlags") break;
			
		case DMAPLEVELD:
			SET_DMAP_VAR(level, "Game->DMapLevel") break;
			
		case DMAPCOMPASSD:
			SET_DMAP_VAR(compass, "Game->DMapCompass") break;
			
		case DMAPCONTINUED:
			SET_DMAP_VAR(cont, "Game->DMapContinue") break;
			
		case DMAPLEVELPAL:
		{
			int32_t ID = ri->d[rINDEX] / 10000; 
			int32_t pal = value/10000;
			pal = vbound(pal, 0, 0x1FF);
				
			if(BC::checkDMapID(ID, "Game->DMapPalette") == SH::_NoError) 
				DMaps[ID].color = pal;

			if(ID == currdmap)
			{
				loadlvlpal(DMaps[ID].color);
				currcset = DMaps[ID].color;
			}
			break;
		}
		
		case DMAPMIDID:
		{
			int32_t ID = ri->d[rINDEX] / 10000;
			
			if(BC::checkDMapID(ID, "Game->DMapMIDI") == SH::_NoError)
			{
				// Based on play_DmapMusic
				switch(value / 10000)
				{
				case -6:
					DMaps[ID].midi = 2;
					break; // Dungeon
					
				case -3:
					DMaps[ID].midi = 3;
					break; // Level 9
					
				case -2:
					DMaps[ID].midi = 1;
					break; // Overworld
					
				case 0:
					DMaps[ID].midi = 0;
					break; // None
					
				default:
					DMaps[ID].midi = value / 10000 + 3;
				}
			}
			
			break;
		}
		
	///----------------------------------------------------------------------------------------------------//
	//Screen->ComboX
	case COMBODD:
	{
		int32_t pos = (ri->d[rINDEX])/10000;
		int32_t val = (value/10000);
		if ( ((unsigned) pos) > 175 )
		{
			Z_scripterrlog("Invalid [pos] %d used to write to Screen->ComboD[]\n", pos);
		}
		else if ( ((unsigned) val) >= MAXCOMBOS )
		{
			Z_scripterrlog("Invalid combo ID %d used to write to Screen->ComboD[]\n", val);
		}
		else
		{
			screen_combo_modify_preroutine(tmpscr,pos);
			tmpscr->data[pos]=(val);
			screen_combo_modify_postroutine(tmpscr,pos);
		}
	}
	break;
    
	case COMBOCD:
	{
		int32_t pos = (ri->d[rINDEX])/10000;
		int32_t val = (value/10000); //cset
		if ( ((unsigned) pos) > 175 )
		{
			Z_scripterrlog("Invalid [pos] %d used to write to Screen->ComboC[]\n", pos);
		}
		else if ( ((unsigned) val) >= 15 )
		{
			Z_scripterrlog("Invalid CSet ID %d used to write to Screen->ComboC[]\n", val);
		}
		else
		{
			screen_combo_modify_preroutine(tmpscr,pos);
			tmpscr->cset[pos]=(val)&15;
			screen_combo_modify_postroutine(tmpscr,pos);
		}
	}
	break;
    
	case COMBOFD:
	{
		int32_t pos = (ri->d[rINDEX])/10000;
		int32_t val = (value/10000); //flag
		if ( ((unsigned) pos) > 175 )
		{
			Z_scripterrlog("Invalid [pos] %d used to write to Screen->ComboF[]\n", pos);
		}
		else if ( ((unsigned) val) >= 256 )
		{
			Z_scripterrlog("Invalid Flag ID %d used to write to Screen->ComboF[]\n", val);
		}
		
		else
			tmpscr->sflag[pos]=(val);
	}
	break;
    
    case COMBOTD:
    {
        int32_t pos = (ri->d[rINDEX])/10000;
        int32_t val = (value/10000); //type
		if ( ((unsigned) pos) > 175 )
		{
			Z_scripterrlog("Invalid [pos] %d used to write to Screen->ComboT[]\n", pos);
		}
		else if ( ((unsigned) val) >= 256 )
		{
			Z_scripterrlog("Invalid Flag ID %d used to write to Screen->ComboT[]\n", val);
		}
        else
        {
			auto cid = tmpscr->data[pos];
            screen_combo_modify_pre(cid);
            combobuf[cid].type=val;
            screen_combo_modify_post(cid);
        }
    }
    break;
    
    case COMBOID:
    {
        int32_t pos = (ri->d[rINDEX])/10000;
        int32_t val = (value/10000); //iflag
	if ( ((unsigned) pos) > 175 )
	{
		Z_scripterrlog("Invalid [pos] %d used to write to Screen->ComboI[]\n", pos);
	}
	else if ( ((unsigned) val) >= 256 )
	{
		Z_scripterrlog("Invalid Flag ID %d used to write to Screen->ComboI[]\n", val);
	}
        
        else
            combobuf[tmpscr->data[pos]].flag=val;
    }
    break;
    
    case COMBOSD:
    {
        int32_t pos = (ri->d[rINDEX])/10000;
        int32_t val = (value/10000); //iflag
		if ( ((unsigned) pos) > 175 )
		{
			Z_scripterrlog("Invalid [pos] %d used to write to Screen->ComboS[]\n", pos);
		}
		else if ( ((unsigned) val) >= 16 )//solidity 1, 2, 4, 8 max 15
		{
			Z_scripterrlog("Invalid Flag ID %d used to write to Screen->ComboS[]\n", val);
		}
        else
		{
			combobuf[tmpscr->data[pos]].walk &= ~0x0F;
            combobuf[tmpscr->data[pos]].walk |= (val)&0x0F;
		}
    }
    break;
    
    case COMBOED:
    {
        int32_t pos = (ri->d[rINDEX])/10000;
        int32_t val = (value/10000); //iflag
		if ( ((unsigned) pos) > 175 )
		{
			Z_scripterrlog("Invalid [pos] %d used to write to Screen->ComboE[]\n", pos);
		}
		else if ( ((unsigned) val) >= 16 )//solidity 1, 2, 4, 8 max 15
		{
			Z_scripterrlog("Invalid Flag ID %d used to write to Screen->ComboE[]\n", val);
		}
        else
		{
			combobuf[tmpscr->data[pos]].walk &= ~0xF0;
            combobuf[tmpscr->data[pos]].walk |= ((val)&0x0F)<<4;
		}
    }
    break;
		
	///----------------------------------------------------------------------------------------------------//
	//Game->SetComboX
		case COMBODDM:
		{
			int32_t pos = (ri->d[rINDEX])/10000;
			int32_t sc = (ri->d[rEXP1]/10000);
			int32_t m = (ri->d[rINDEX2]/10000)-1;
			int32_t scr = zc_max(m*MAPSCRS+sc,0);
			int32_t layr = whichlayer(scr);
			
			//if(!(pos >= 0 && pos < 176 && scr >= 0 && sc < MAPSCRS && m < map_count)) break;
	    
			if(pos < 0 || pos >= 176) 
			{
				Z_scripterrlog("Invalid combo position (%d) passed to SetComboData", pos);
				break;
			}
			if(scr < 0) 
			{
				Z_scripterrlog("Invalid Screen ID (%d) passed to SetComboData", scr);
				break;
			}
			if(sc >= MAPSCRS) 
			{
				Z_scripterrlog("Invalid Screen ID (%d) passed to SetComboData", sc);
				break;
			}
			if(unsigned(m) >= map_count) 
			{
				Z_scripterrlog("Invalid Map ID (%d) passed to SetComboData", m);
				break;
			}
			int32_t combo = vbound(value/10000,0,MAXCOMBOS);
			if(scr==(currmap*MAPSCRS+currscr))
			{
				screen_combo_modify_preroutine(tmpscr,pos);
				
			}
				
			TheMaps[scr].data[pos]=combo;
			
			if(scr==(currmap*MAPSCRS+currscr))
			{
				tmpscr->data[pos] = combo;
				screen_combo_modify_postroutine(tmpscr,pos);
				//Start the script for the new combo
				int index = get_combopos_ref(pos, 0);
				FFCore.reset_script_engine_data(ScriptType::Combo, index);
				//Not ure if combodata arrays clean themselves up, or leak. -Z
				//Not sure if this could result in stack corruption. 
			}
			
			if(layr>-1)
			{
				tmpscr2[layr].data[pos]=combo;
				int index = get_combopos_ref(pos, layr + 1);
				FFCore.reset_script_engine_data(ScriptType::Combo, index);
			}
		}
		break;
		
		case COMBOCDM:
		{
			int32_t pos = (ri->d[rINDEX])/10000;
			int32_t sc = (ri->d[rEXP1]/10000);
			int32_t m = (ri->d[rINDEX2]/10000)-1;
			int32_t scr = zc_max(m*MAPSCRS+sc,0);
			
			//if(!(pos >= 0 && pos < 176 && scr >= 0 && sc < MAPSCRS && m < map_count)) break;
        
			if(pos < 0 || pos >= 176) 
			{
				Z_scripterrlog("Invalid combo position (%d) passed to SetComboCSet", pos);
				break;
			}
			if(scr < 0) 
			{
				Z_scripterrlog("Invalid Screen ID (%d) passed to SetComboCSet", scr);
				break;
			}
			if(sc >= MAPSCRS) 
			{
				Z_scripterrlog("Invalid Screen ID (%d) passed to SetComboCSet", sc);
				break;
			}
			if(unsigned(m) >= map_count) 
			{
				Z_scripterrlog("Invalid Map ID (%d) passed to SetComboCSet", m);
				break;
			}
			
			TheMaps[scr].cset[pos]=(value/10000)&15;
			
			if(scr==(currmap*MAPSCRS+currscr))
				tmpscr->cset[pos] = value/10000;
				
			int32_t layr = whichlayer(scr);
			
			if(layr>-1)
				tmpscr2[layr].cset[pos]=(value/10000)&15;
		}
		break;
		
		case COMBOFDM:
		{
			int32_t pos = (ri->d[rINDEX])/10000;
			int32_t sc = (ri->d[rEXP1]/10000);
			int32_t m = (ri->d[rINDEX2]/10000)-1;
			int32_t scr = zc_max(m*MAPSCRS+sc,0);
			
			//if(!(pos >= 0 && pos < 176 && scr >= 0 && sc < MAPSCRS && m < map_count)) break;
        
			if(pos < 0 || pos >= 176) 
			{
				Z_scripterrlog("Invalid combo position (%d) passed to SetComboFlag", pos);
				break;
			}
			if(scr < 0) 
			{
				Z_scripterrlog("Invalid Screen ID (%d) passed to SetComboFlag", scr);
				break;
			}
			if(sc >= MAPSCRS) 
			{
				Z_scripterrlog("Invalid Screen ID (%d) passed to SetComboFlag", sc);
				break;
			}
			if(unsigned(m) >= map_count) 
			{
				Z_scripterrlog("Invalid Map ID (%d) passed to SetComboFlag", m);
				break;
			}
			
			TheMaps[scr].sflag[pos]=value/10000;
			
			if(scr==(currmap*MAPSCRS+currscr))
				tmpscr->sflag[pos] = value/10000;
				
			int32_t layr = whichlayer(scr);
			
			if(layr>-1)
				tmpscr2[layr].sflag[pos]=value/10000;
		}
		break;
		
		case COMBOTDM:
		{
			int32_t pos = (ri->d[rINDEX])/10000;
			int32_t sc = (ri->d[rEXP1]/10000);
			int32_t m = (ri->d[rINDEX2]/10000)-1;
			int32_t scr = zc_max(m*MAPSCRS+sc,0);
			
			//if(!(pos >= 0 && pos < 176 && scr >= 0 && sc < MAPSCRS && m < map_count))
			//    break;
			    
			if(pos < 0 || pos >= 176) 
			{
				Z_scripterrlog("Invalid combo position (%d) passed to SetComboType", pos);
				break;
			}
			if(scr < 0) 
			{
				Z_scripterrlog("Invalid Screen ID (%d) passed to SetComboType", scr);
				break;
			}
			if(sc >= MAPSCRS) 
			{
				Z_scripterrlog("Invalid Screen ID (%d) passed to SetComboType", sc);
				break;
			}
			if(unsigned(m) >= map_count) 
			{
				Z_scripterrlog("Invalid Map ID (%d) passed to SetComboType", m);
				break;
			}
				
			int32_t cdata = TheMaps[scr].data[pos];
			screen_combo_modify_pre(cdata);
			combobuf[cdata].type=value/10000;
			screen_combo_modify_post(cdata);
		}
		break;
		
		case COMBOIDM:
		{
			int32_t pos = (ri->d[rINDEX])/10000;
			int32_t sc = (ri->d[rEXP1]/10000);
			int32_t m = (ri->d[rINDEX2]/10000)-1;
			int32_t scr = zc_max(m*MAPSCRS+sc,0);
			
			//if(!(pos >= 0 && pos < 176 && scr >= 0 && sc < MAPSCRS && m < map_count))
			//    break;
			    
			if(pos < 0 || pos >= 176) 
			{
				Z_scripterrlog("Invalid combo position (%d) passed to GetComboInherentFlag", pos);
				break;
			}
			if(scr < 0) 
			{
				Z_scripterrlog("Invalid Screen ID (%d) passed to GetComboInherentFlag", scr);
				break;
			}
			if(sc >= MAPSCRS) 
			{
				Z_scripterrlog("Invalid Screen ID (%d) passed to GetComboInherentFlag", sc);
				break;
			}
			if(unsigned(m) >= map_count) 
			{
				Z_scripterrlog("Invalid Map ID (%d) passed to GetComboInherentFlag", m);
				break;
			}
				
			combobuf[TheMaps[scr].data[pos]].flag=value/10000;
		}
		break;
		
		case COMBOSDM:
		{
			//This is how it was in 2.50.1-2
			int32_t pos = (ri->d[rINDEX])/10000;
			int32_t scr = (ri->d[rINDEX2]/10000)*MAPSCRS+(ri->d[rEXP1]/10000);
			//This (below) us the precise code from 2.50.1 (?)
			//int32_t scr = zc_max((ri->d[rINDEX2]/10000)*MAPSCRS+(ri->d[rEXP1]/10000),0); //Not below 0. 

			//if(pos < 0 || pos >= 176 || scr < 0) break;
			if(pos < 0 || pos >= 176) 
			{
				Z_scripterrlog("Invalid combo position (%d) passed to GetSolid", pos);
				break;
			}
			if(scr < 0) 
			{
				Z_scripterrlog("Invalid MapScreen ID (%d) passed to GetSolid", scr);
				break;
			}
			combobuf[TheMaps[scr].data[pos]].walk &= ~0x0F;
			combobuf[TheMaps[scr].data[pos]].walk |= (value/10000)&15;	    
		}
		break;
		
	///----------------------------------------------------------------------------------------------------//
	//Screen Variables
		
			#define	SET_SCREENDATA_VAR_INT32(member, str) \
		{ \
			tmpscr->member = vbound((value / 10000),-214747,214747); \
		} \
		
		#define	SET_SCREENDATA_VAR_INT16(member, str) \
		{ \
			tmpscr->member = vbound((value / 10000),0,32767); \
		} \

		#define	SET_SCREENDATA_VAR_BYTE(member, str) \
		{ \
			tmpscr->member = vbound((value / 10000),0,255); \
		} \
		
		#define SET_SCREENDATA_VAR_INDEX32(member, str, indexbound) \
		{ \
			int32_t indx = ri->d[rINDEX] / 10000; \
			tmpscr->member[indx] = vbound((value / 10000),-214747,214747); \
		} \
		
		#define SET_SCREENDATA_VAR_INDEX16(member, str, indexbound) \
		{ \
			int32_t indx = ri->d[rINDEX] / 10000; \
			tmpscr->member[indx] = vbound((value / 10000),-32767,32767); \
		} \

		#define SET_SCREENDATA_BYTE_INDEX(member, str, indexbound) \
		{ \
			int32_t indx = ri->d[rINDEX] / 10000; \
			tmpscr->member[indx] = vbound((value / 10000),0,255); \
		}
		#define SET_SCREENDATA_LAYER_INDEX(member, str, indexbound) \
		{ \
			int32_t indx = ri->d[rINDEX] / 10000; \
			if ( FFCore.quest_format[vFFScript] < 11 ) ++indx; \
			if(indx < 1 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, indx); \
			} \
			else tmpscr->member[indx-1] = vbound((value / 10000),0,255); \
		}
		///max screen id is higher! vbound properly... -Z
		#define SET_SCREENDATA_LAYERSCREEN_INDEX(member, str, indexbound) \
		{ \
			int32_t indx = ri->d[rINDEX] / 10000; \
			int32_t scrn_id = value/10000; \
			if ( FFCore.quest_format[vFFScript] < 11 ) ++indx; \
			if(indx < 1 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, indx); \
			} \
			else if ( scrn_id > MAPSCRS ) \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->LayerScreen[%d].\n",scrn_id); \
				Z_scripterrlog("Valid Screen values are (0) through (%d).\n",MAPSCRS); \
			} \
			else tmpscr->member[indx-1] = vbound((scrn_id),0,MAPSCRS); \
		}
		
		#define SET_SCREENDATA_FLAG(member, str) \
		{ \
			int32_t flag =  (value/10000);  \
			if ( flag != 0 ) \
			{ \
				tmpscr->member|=flag; \
			} \
			else tmpscr->.member|= ~flag; \
		} \
		
		#define SET_SCREENDATA_BOOL_INDEX(member, str, indexbound) \
		{ \
			int32_t indx = ri->d[rINDEX] / 10000; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to Screen->%s[]: %d\n", (indx), str); \
				break; \
			} \
			tmpscr->member[indx] =( (value/10000) ? 1 : 0 ); \
		}

		#define SET_FFC_BOOL_INDEX(member, str, indexbound) \
		{ \
			int32_t indx = ri->d[rINDEX] / 10000; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to Screen->%s[]: %d\n", (indx), str); \
				break; \
			} \
			tmpscr->ffcs[indx].member =( (value/10000) ? 1 : 0 ); \
		}
		

		case SCREENDATAVALID:		SET_SCREENDATA_VAR_BYTE(valid, "Valid"); break;		//b
		case SCREENDATAGUY: 		SET_SCREENDATA_VAR_BYTE(guy, "Guy"); break;		//b
		case SCREENDATASTRING:		SET_SCREENDATA_VAR_INT32(str, "String"); break;		//w
		case SCREENDATAROOM: 		SET_SCREENDATA_VAR_BYTE(room, "RoomType");	break;		//b
		case SCREENDATAITEM:
		{
			auto v = vbound((value / 10000),-1,255);
			if(v > -1)
				tmpscr->item = v;
			tmpscr->hasitem = v > -1;
			break;
		}
		case SCREENDATAHASITEM: 		SET_SCREENDATA_VAR_BYTE(hasitem, "HasItem"); break;	//b
		case SCREENDATATILEWARPTYPE: 	SET_SCREENDATA_BYTE_INDEX(tilewarptype, "TileWarpType", 3); break;	//b, 4 of these
		//case SCREENDATATILEWARPOVFLAGS: 	SET_SCREENDATA_VAR_BYTE(tilewarpoverlayflags, "TileWarpOverlayFlags"); break;	//b, tilewarpoverlayflags
		case SCREENDATADOORCOMBOSET: 	SET_SCREENDATA_VAR_INT32(door_combo_set, "DoorComboSet"); break;	//w
		case SCREENDATAWARPRETX:	 	SET_SCREENDATA_BYTE_INDEX(warpreturnx, "WarpReturnX", 3); break;	//b, 4 of these
		case SCREENDATAWARPRETY:	 	SET_SCREENDATA_BYTE_INDEX(warpreturny, "WarpReturnY", 3); break;	//b, 4 of these
		case SCREENDATAWARPRETURNC: 	SET_SCREENDATA_VAR_INT32(warpreturnc, "WarpReturnC"); break;	//w
		case SCREENDATASTAIRX: 		SET_SCREENDATA_VAR_BYTE(stairx, "StairsX"); break;	//b
		case SCREENDATASTAIRY: 		SET_SCREENDATA_VAR_BYTE(stairy, "StairsY"); break;	//b
		case SCREENDATAITEMX:		SET_SCREENDATA_VAR_BYTE(itemx, "ItemX"); break; //itemx
		case SCREENDATAITEMY:		SET_SCREENDATA_VAR_BYTE(itemy, "ItemY"); break;	//itemy
		case SCREENDATACOLOUR: 		SET_SCREENDATA_VAR_INT32(color, "CSet"); break;	//w
		case SCREENDATAENEMYFLAGS: 	SET_SCREENDATA_VAR_BYTE(enemyflags, "EnemyFlags");	break;	//b
		case SCREENDATADOOR: 		SET_SCREENDATA_BYTE_INDEX(door, "Door", 3); break;	//b, 4 of these
		case SCREENDATATILEWARPDMAP: 	SET_SCREENDATA_VAR_INDEX32(tilewarpdmap, "TileWarpDMap", 3); break;	//w, 4 of these
		case SCREENDATATILEWARPSCREEN: 	SET_SCREENDATA_BYTE_INDEX(tilewarpscr, "TileWarpScreen", 3); break;	//b, 4 of these
		case SCREENDATAEXITDIR: 		SET_SCREENDATA_VAR_BYTE(exitdir, "ExitDir"); break;	//b
		case SCREENDATAENEMY: 	
		{ 
			int32_t indx = ri->d[rINDEX] / 10000; 
			int32_t enemyid = value/10000;
			if ( ((unsigned)enemyid) > MAXGUYS ) 
			{ 
				Z_scripterrlog("Invaid enemy ID (%d) passed to Screen->%s.", enemyid,"Enemy[]"); \
				break; 
			}
			if(unsigned(indx) > 9)
			{
				Z_scripterrlog("Invalid index (%d) used for Screen->Enemy[]", indx);
				break;
			}
			tmpscr->enemy[indx] = enemyid; 
			break;
		} 
		//case SCREENDATAENEMY: 		SET_SCREENDATA_VAR_INDEX32(enemy, "Enemy", 9); break;	//w, 10 of these
		case SCREENDATAPATTERN: 		SET_SCREENDATA_VAR_BYTE(pattern, "Pattern"); break;	//b
		case SCREENDATASIDEWARPTYPE: 	SET_SCREENDATA_BYTE_INDEX(sidewarptype, "SideWarpType", 3); break;	//b, 4 of these
		//case SCREENDATASIDEWARPOVFLAGS: 	SET_SCREENDATA_VAR_BYTE(sidewarpoverlayflags, "SideWarpOverlayFlags"); break;	//b
		case SCREENDATAWARPARRIVALX: 	SET_SCREENDATA_VAR_BYTE(warparrivalx, "WarpArrivalX"); break;	//b
		case SCREENDATAWARPARRIVALY: 	SET_SCREENDATA_VAR_BYTE(warparrivaly, "WarpArrivalY"); break;	//b
		case SCREENDATAPATH: 		SET_SCREENDATA_BYTE_INDEX(path, "MazePath", 3); break;	//b, 4 of these
		case SCREENDATASIDEWARPSC: 	SET_SCREENDATA_BYTE_INDEX(sidewarpscr, "SideWarpScreen", 3); break;	//b, 4 of these
		case SCREENDATASIDEWARPDMAP: 	SET_SCREENDATA_VAR_INDEX32(sidewarpdmap, "SideWarpDMap", 3); break;	//w, 4 of these
		case SCREENDATASIDEWARPINDEX: 	SET_SCREENDATA_VAR_BYTE(sidewarpindex, "SideWarpIndex"); break;	//b
		case SCREENDATAUNDERCOMBO: 	SET_SCREENDATA_VAR_INT32(undercombo, "Undercombo"); break;	//w
		case SCREENDATAUNDERCSET:	 	SET_SCREENDATA_VAR_BYTE(undercset,	"UnderCSet"); break; //b
		case SCREENDATACATCHALL:	 	SET_SCREENDATA_VAR_INT32(catchall,	"Catchall"); break; //W

		case SCREENDATACSENSITIVE: 	SET_SCREENDATA_VAR_BYTE(csensitive, "CSensitive"); break;	//B
		case SCREENDATANORESET: 		SET_SCREENDATA_VAR_INT32(noreset, "NoReset"); break;	//W
		case SCREENDATANOCARRY: 		SET_SCREENDATA_VAR_INT32(nocarry, "NoCarry"); break;	//W
		case SCREENDATALAYERMAP:	 	SET_SCREENDATA_LAYER_INDEX(layermap, "LayerMap", 5); break;	//B, 6 OF THESE
		case SCREENDATALAYERSCREEN: 	SET_SCREENDATA_LAYERSCREEN_INDEX(layerscreen, "LayerScreen", 5); break;	//B, 6 OF THESE
		case SCREENDATALAYEROPACITY: 	SET_SCREENDATA_LAYER_INDEX(layeropacity, "LayerOpacity", 5); break;	//B, 6 OF THESE
		case SCREENDATALAYERINVIS: 	
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if(indx < 0 || indx > 6 )
			{
				Z_scripterrlog("Invalid Index passed to Screen->LayerInvisible[]: %d\n", indx);
			}
			else
			{
				if(value)
					tmpscr->hidelayers |= (1<<indx);
				else
					tmpscr->hidelayers &= ~(1<<indx);
			}
			break;
		}
		case SCREENDATASCRIPTDRAWS: 	
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if(indx < 0 || indx > 7 )
			{
				Z_scripterrlog("Invalid Index passed to Screen->HideScriptLayer[]: %d\n", indx);
			}
			else
			{
				if(value)
					tmpscr->hidescriptlayers &= ~(1<<indx);
				else
					tmpscr->hidescriptlayers |= (1<<indx);
			}
			break;
		}

		case SCREENDATATILEWARPOVFLAGS: 
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if ( ((unsigned)indx) > 3 ) 
			{
				Z_scripterrlog("Invalid index passed to TileWarpOverlayFlags[%d].\n. Valid indices are [0] through [3].\n", indx);
			}
			else
			{
				if ( value ) tmpscr->tilewarpoverlayflags |= (1<<indx);
				else tmpscr->tilewarpoverlayflags &= ~(1<<indx);
			}
			break;
		}

		case SCREENDATASIDEWARPOVFLAGS: 
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if ( ((unsigned)indx) > 3 ) 
			{
				Z_scripterrlog("Invalid index passed to SideWarpOverlayFlags[%d].\n. Valid indices are [0] through [3].\n", indx);
			}
			else
			{
				if ( value ) tmpscr->sidewarpoverlayflags |= (1<<indx);
				else tmpscr->sidewarpoverlayflags &= ~(1<<indx);
			}
			break;
		}

		case SCREENDATATIMEDWARPTICS: 	SET_SCREENDATA_VAR_INT32(timedwarptics, "TimedWarpTimer"); break;	//W
		case SCREENDATANEXTMAP: 		SET_SCREENDATA_VAR_BYTE(nextmap, "NextMap"); break;	//B
		case SCREENDATANEXTSCREEN: 	SET_SCREENDATA_VAR_BYTE(nextscr, "NextScreen"); break;	//B
		case SCREENDATASECRETCOMBO: 	SET_SCREENDATA_VAR_INDEX32(secretcombo, "SecretCombo", 127); break;	//W, 128 OF THESE
		case SCREENDATASECRETCSET: 	SET_SCREENDATA_BYTE_INDEX(secretcset, "SecretCSet", 127); break;	//B, 128 OF THESE
		case SCREENDATASECRETFLAG: 	SET_SCREENDATA_BYTE_INDEX(secretflag, "SecretFlags", 127); break;	//B, 128 OF THESE
		case SCREENDATAVIEWX: 		break;//SET_SCREENDATA_VAR_INT32(viewX, "ViewX"); break;	//W
		case SCREENDATAVIEWY: 		break;//SET_SCREENDATA_VAR_INT32(viewY, "ViewY"); break; //W
		case SCREENDATASCREENWIDTH: 	break;//SET_SCREENDATA_VAR_BYTE(scrWidth, "Width"); break;	//B
		case SCREENDATASCREENHEIGHT: 	break;//SET_SCREENDATA_VAR_BYTE(scrHeight,	"Height"); break;	//B
		case SCREENDATAENTRYX: 		
		{
			int32_t newx = vbound((value/10000),0,255);
			tmpscr->entry_x = newx;
			if ( get_qr(qr_WRITE_ENTRYPOINTS_AFFECTS_HEROCLASS) )
			{
				Hero.respawn_x = (zfix)(newx);
			}
			break;
		}
		case SCREENDATAENTRYY: 		
		{
			
			int32_t newy = vbound((value/10000),0,175);
			tmpscr->entry_y = newy;
			if ( get_qr(qr_WRITE_ENTRYPOINTS_AFFECTS_HEROCLASS) )
			{
				Hero.respawn_y = (zfix)(newy);
			}
			break;	//B
		}

		case SCREENDATANUMFF: 	
		{
			break;
		}

		case SCREENDATAFFINITIALISED:
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if (indx < 0 || indx > MAXFFCS-1)
			{
				Z_scripterrlog("Invalid Index passed to Screen->%s[]: %d\n", (indx), "FFCRunning");
				break;
			}
			get_script_engine_data(ScriptType::FFC, indx).initialized = (value/10000) ? true : false;
		}
		break;

		case SCREENDATASCRIPTENTRY: 	SET_SCREENDATA_VAR_INT32(script_entry, "ScriptEntry"); break;	//W
		case SCREENDATASCRIPTOCCUPANCY: 	SET_SCREENDATA_VAR_INT32(script_occupancy,	"ScriptOccupancy");  break;//W
		case SCREENDATASCRIPTEXIT: 	SET_SCREENDATA_VAR_INT32(script_exit, "ExitScript"); break;	//W
		case SCREENDATAOCEANSFX:
		{
			int32_t v = vbound(value/10000, 0, 255);
			if(tmpscr->oceansfx != v)
			{
				stop_sfx(tmpscr->oceansfx);
				tmpscr->oceansfx = v;
				cont_sfx(tmpscr->oceansfx);
			}
			break;
		}
		case SCREENDATABOSSSFX: 		SET_SCREENDATA_VAR_BYTE(bosssfx, "BossSFX"); break;	//B
		case SCREENDATASECRETSFX:	 	SET_SCREENDATA_VAR_BYTE(secretsfx, "SecretSFX"); break;	//B
		case SCREENDATAHOLDUPSFX:	 	SET_SCREENDATA_VAR_BYTE(holdupsfx,	"ItemSFX"); break; //B
		case SCREENDATASCREENMIDI:
		{
			tmpscr->screen_midi = vbound((value / 10000)-(MIDIOFFSET_MAPSCR-MIDIOFFSET_ZSCRIPT),-1,32767);
			break;
		}
		case SCREENDATALENSLAYER:	 	SET_SCREENDATA_VAR_BYTE(lens_layer, "LensLayer"); break;	//B, OLD QUESTS ONLY?
			
		case SCREENSIDEWARPID:
		{
			int32_t indx = ri->d[rINDEX] / 10000; //dir
			
			int32_t new_warp_return = vbound((value / 10000),-1,3); //none, A, B, C, D
			if(new_warp_return == -1)
			{
				tmpscr->flags2 &= ~(1<<indx); //Unset the "Enabled" flag for this dir
				tmpscr->sidewarpindex &= ~(3<<(2*indx)); //Clear the dir as well.
			}
			else
			{
				tmpscr->flags2 |= 1<<indx; //Set the "Enabled" flag for this dir
				tmpscr->sidewarpindex &= ~(3<<(2*indx)); //Clear the dir bits
				tmpscr->sidewarpindex |= (new_warp_return<<(2*indx)); //Set the new dir
			}
			
			break;
		} 

		case SCREENDATATWARPRETSQR:
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if ( ((unsigned)indx) > 3)
			{
				 Z_scripterrlog("Invalid Array Index passed to Screen->TileWarpReturnSquare[]: %d\n", indx);
			}
			else
			{
				int32_t wrindex = vbound(value/10000, 0, 3);
				tmpscr->warpreturnc = (tmpscr->warpreturnc&~(3<<(indx*2))) | (wrindex<<(indx*2));
			}
			break;
		}

		//
		case SCREENDATASWARPRETSQR:
		{
			
			int32_t indx = ri->d[rINDEX] / 10000;
			if ( ((unsigned)indx) > 3)
			{
				 Z_scripterrlog("Invalid Array Index passed to Screen->SideWarpReturnSquare[]: %d\n", indx);
			}
			else
			{
				int32_t wrindex = vbound(value/10000, 0, 3);
				tmpscr->warpreturnc = (tmpscr->warpreturnc&~(3<<(8+(indx*2)))) | (wrindex<<(8+(indx*2)));
			}
			break;
		}


		case SCREENDATAFLAGS: 
		{
			int32_t flagid = (ri->d[rINDEX])/10000;
			//bool valtrue = ( value ? 10000 : 0);
			switch(flagid)
			{
				case 0: tmpscr->flags = (value / 10000); break;
				case 1: tmpscr->flags2 = (value / 10000); break;
				case 2: tmpscr->flags3 = (value / 10000); break;
				case 3: tmpscr->flags4 = (value / 10000); break;
				case 4: tmpscr->flags5 = (value / 10000); break;
				case 5: tmpscr->flags6 = (value / 10000); break;
				case 6: tmpscr->flags7 = (value / 10000); break;
				case 7: tmpscr->flags8 = (value / 10000); break;
				case 8: tmpscr->flags9 = (value / 10000); break;
				case 9: tmpscr->flags10 = (value / 10000); break;
				default:
				{
					Z_scripterrlog("Invalid index passed to mapdata->flags[]: %d\n", flagid); 
					break;
					
				}
			}
			break;
			//GET_SCREENDATA_BYTE_INDEX	//B, 11 OF THESE, flags, flags2-flags10
		}
		
		case SCREENDATAGUYCOUNT:
		{
			int mi = get_mi();
			if(mi > -1)
				game->guys[mi] = vbound(value/10000,10,0);
			break;
		}
		case SCREENDATAEXDOOR:
		{
			int mi = get_mi();
			if(mi < 0) break;
			int dir = SH::read_stack(ri->sp+1) / 10000;
			int ind = SH::read_stack(ri->sp+0) / 10000;
			if(unsigned(dir) > 3)
				Z_scripterrlog("Invalid dir '%d' passed to 'Screen->SetExDoor()'; must be 0-3\n", dir);
			else if(unsigned(ind) > 7)
				Z_scripterrlog("Invalid index '%d' passed to 'Screen->SetExDoor()'; must be 0-7\n", ind);
			else
				set_xdoorstate(mi, dir, ind);
			break;
		}

		//These use the same method as SetScreenD
		case SCREENWIDTH:
			// FFScript::set_screenWidth(&TheMaps[(ri->d[rINDEX2] / 10000) * MAPSCRS + (ri->d[rINDEX]/10000)], value/10000);
			break;

		case SCREENHEIGHT:
			// FFScript::set_screenHeight(&TheMaps[(ri->d[rINDEX2] / 10000) * MAPSCRS + (ri->d[rINDEX]/10000)], value/10000);
			break;

		case SCREENVIEWX:
			// FFScript::set_screenViewX(&TheMaps[(ri->d[rINDEX2] / 10000) * MAPSCRS + (ri->d[rINDEX]/10000)], value/10000);
			break;

		case SCREENVIEWY:
			// FFScript::set_screenViewY(&TheMaps[(ri->d[rINDEX2] / 10000) * MAPSCRS + (ri->d[rINDEX]/10000)], value/10000);
			break;

		case SCREENGUY:
			FFScript::set_screenGuy(&TheMaps[(ri->d[rINDEX2] / 10000) * MAPSCRS + (ri->d[rINDEX]/10000)], value/10000);
			break;

		case SCREENSTRING:
		{
			FFScript::set_screenString(&TheMaps[(ri->d[rINDEX2] / 10000) * MAPSCRS + (ri->d[rINDEX]/10000)], value/10000);
			//should this be either
			//set_screenString(&TheMaps[((ri->d[rINDEX2] / 10000) * MAPSCRS + (ri->d[rINDEX]/10000)])-1), value/10000);
			//or
			//set_screenString(&TheMaps[((ri->d[rINDEX2] / 10000) * MAPSCRS + (ri->d[rINDEX]/10000)])-+1), value/10000);
			Z_message("Map ref is: %d\n",((ri->d[rINDEX2] / 10000) * MAPSCRS + (ri->d[rINDEX]/10000)));
		}
		break;

		case SCREENROOM:
			FFScript::set_screenRoomtype(&TheMaps[(ri->d[rINDEX2] / 10000) * MAPSCRS + (ri->d[rINDEX]/10000)], value/10000);
			break;

		case SCREENENTX:
			FFScript::set_screenEntryX(&TheMaps[(ri->d[rINDEX2] / 10000) * MAPSCRS + (ri->d[rINDEX]/10000)], value/10000);
			break;

		case SCREENENTY:
			FFScript::set_screenEntryY(&TheMaps[(ri->d[rINDEX2] / 10000) * MAPSCRS + (ri->d[rINDEX]/10000)], value/10000);
			break;

		case SCREENITEM:
			FFScript::set_screenitem(&TheMaps[(ri->d[rINDEX2] / 10000) * MAPSCRS + (ri->d[rINDEX]/10000)], value/10000);
			break;

		case SCREENUNDCMB:
			FFScript::set_screenundercombo(&TheMaps[(ri->d[rINDEX2] / 10000) * MAPSCRS + (ri->d[rINDEX]/10000)], value/10000);
			break;

		case SCREENUNDCST:
			FFScript::set_screenundercset(&TheMaps[(ri->d[rINDEX2] / 10000) * MAPSCRS + (ri->d[rINDEX]/10000)], value/10000);
			break;

		case SCREENCATCH:
			FFScript::set_screenatchall(&TheMaps[(ri->d[rINDEX2] / 10000) * MAPSCRS + (ri->d[rINDEX]/10000)], value/10000);
			break;

		//These use the method of SetScreenEnemy


		//SetScreenLayerOpacity(int32_t map, int32_t scr, int32_t layer, int32_t v)
		case SETSCREENLAYOP:
		{ 
			int32_t map     = (ri->d[rINDEX2] / 10000) - 1; //Should this be +1? -Z
			int32_t scrn  = ri->d[rEXP1] / 10000; 
			int32_t index = ri->d[rINDEX] / 10000; 
			int32_t nn = ri->d[rEXP2]/10000; 

			if(BC::checkMapID(map, "Game->SetScreenLayerOpacity(...map...)") != SH::_NoError ||
				BC::checkBounds(scrn, 0, 0x87, "Game->SetScreenLayerOpacity(...screen...)") != SH::_NoError ||
				BC::checkBounds(index, 0, 9, "Game->SetScreenLayerOpacity(...index...)") != SH::_NoError)
				return;
				
			FFScript::set_screenlayeropacity(&TheMaps[map * MAPSCRS + scrn], index, nn); 
		}
		break;

		case SETSCREENSECCMB:
		{ 
			int32_t map     = (ri->d[rINDEX2] / 10000) - 1; //Should this be +1? -Z
			int32_t scrn  = ri->d[rEXP1] / 10000; 
			int32_t index = ri->d[rINDEX] / 10000; 
			int32_t nn = ri->d[rEXP2]/10000; 

			if(BC::checkMapID(map, "Game->SetScreenSecretCombo(...map...)") != SH::_NoError ||
				BC::checkBounds(scrn, 0, 0x87, "Game->SetScreenSecretCombo(...screen...)") != SH::_NoError ||
				BC::checkBounds(index, 0, 9, "Game->SetScreenSecretCombo(...index...)") != SH::_NoError)
				return;
				
			FFScript::set_screensecretcombo(&TheMaps[map * MAPSCRS + scrn], index, nn); 
		}
		break;

		case SETSCREENSECCST:
		{ 
			int32_t map     = (ri->d[rINDEX2] / 10000) - 1; //Should this be +1? -Z
			int32_t scrn  = ri->d[rEXP1] / 10000; 
			int32_t index = ri->d[rINDEX] / 10000; 
			int32_t nn = ri->d[rEXP2]/10000; 

			if(BC::checkMapID(map, "Game->SetScreenSecretCSet(...map...)") != SH::_NoError ||
				BC::checkBounds(scrn, 0, 0x87, "Game->SetScreenSecretCSet(...screen...)") != SH::_NoError ||
				BC::checkBounds(index, 0, 9, "Game->SetScreenSecretCSet(...index...)") != SH::_NoError)
				return;
				
			FFScript::set_screensecretcset(&TheMaps[map * MAPSCRS + scrn], index, nn); 
		}
		break;

		case SETSCREENSECFLG:
		{ 
			int32_t map     = (ri->d[rINDEX2] / 10000) - 1; //Should this be +1? -Z
			int32_t scrn  = ri->d[rEXP1] / 10000; 
			int32_t index = ri->d[rINDEX] / 10000; 
			int32_t nn = ri->d[rEXP2]/10000; 

			if(BC::checkMapID(map, "Game->SetScreenSecretFlag(...map...)") != SH::_NoError ||
				BC::checkBounds(scrn, 0, 0x87, "Game->SetScreenSecretFlag(...screen...)") != SH::_NoError ||
				BC::checkBounds(index, 0, 9, "Game->SetScreenSecretFlag(...index...)") != SH::_NoError)
				return;
				
			FFScript::set_screensecretflag(&TheMaps[map * MAPSCRS + scrn], index, nn); 
		}
		break;

		case SETSCREENLAYMAP:
		{ 
			int32_t map     = (ri->d[rINDEX2] / 10000) - 1; //Should this be +1? -Z
			int32_t scrn  = ri->d[rEXP1] / 10000; 
			int32_t index = ri->d[rINDEX] / 10000; 
			int32_t nn = ri->d[rEXP2]/10000; 

			if(BC::checkMapID(map, "Game->SetScreenLayerMap(...map...)") != SH::_NoError ||
				BC::checkBounds(scrn, 0, 0x87, "Game->SetScreenLayerMap(...screen...)") != SH::_NoError ||
				BC::checkBounds(index, 0, 9, "Game->SetScreenLayerMap(...index...)") != SH::_NoError)
				return;
				
			FFScript::set_screenlayermap(&TheMaps[map * MAPSCRS + scrn], index, nn); 
		}
		break;

		case SETSCREENLAYSCR:
		{ 
			int32_t map     = (ri->d[rINDEX2] / 10000) - 1; //Should this be +1? -Z
			int32_t scrn  = ri->d[rEXP1] / 10000; 
			int32_t index = ri->d[rINDEX] / 10000; 
			int32_t nn = ri->d[rEXP2]/10000; 

			if(BC::checkMapID(map, "Game->SetScreenLayerScreen(...map...)") != SH::_NoError ||
				BC::checkBounds(scrn, 0, 0x87, "Game->SetScreenLayerScreen(...screen...)") != SH::_NoError ||
				BC::checkBounds(index, 0, 9, "Game->SetScreenLayerScreen(...index...)") != SH::_NoError)
				return;
				
			FFScript::set_screenlayerscreen(&TheMaps[map * MAPSCRS + scrn], index, nn); 
		}
		break;

		case SETSCREENPATH:
		{ 
			int32_t map     = (ri->d[rINDEX2] / 10000) - 1; //Should this be +1? -Z
			int32_t scrn  = ri->d[rEXP1] / 10000; 
			int32_t index = ri->d[rINDEX] / 10000; 
			int32_t nn = ri->d[rEXP2]/10000; 

			if(BC::checkMapID(map, "Game->SetScreenPath(...map...)") != SH::_NoError ||
				BC::checkBounds(scrn, 0, 0x87, "Game->SetScreenPath(...screen...)") != SH::_NoError ||
				BC::checkBounds(index, 0, 9, "Game->SetScreenPath(...index...)") != SH::_NoError)
				return;
				
			FFScript::set_screenpath(&TheMaps[map * MAPSCRS + scrn], index, nn); 
		}
		break;

		case SETSCREENWARPRX:
		{ 
			int32_t map     = (ri->d[rINDEX2] / 10000) - 1; //Should this be +1? -Z
			int32_t scrn  = ri->d[rEXP1] / 10000; 
			int32_t index = ri->d[rINDEX] / 10000; 
			int32_t nn = ri->d[rEXP2]/10000; 

			if(BC::checkMapID(map, "Game->SetScreenWarpReturnX(...map...)") != SH::_NoError ||
				BC::checkBounds(scrn, 0, 0x87, "Game->SetScreenWarpReturnX(...screen...)") != SH::_NoError ||
				BC::checkBounds(index, 0, 9, "Game->SetScreenWarpReturnX(...index...)") != SH::_NoError)
				return;
				
			FFScript::set_screenwarpReturnX(&TheMaps[map * MAPSCRS + scrn], index, nn); 
		}
		break;

		case SETSCREENWARPRY:
		{ 
			int32_t map     = (ri->d[rINDEX2] / 10000) - 1; //Should this be +1? -Z
			int32_t scrn  = ri->d[rEXP1] / 10000; 
			int32_t index = ri->d[rINDEX] / 10000; 
			int32_t nn = ri->d[rEXP2]/10000; 

			if(BC::checkMapID(map, "Game->SetScreenWarpReturnY(...map...)") != SH::_NoError ||
				BC::checkBounds(scrn, 0, 0x87, "Game->SetScreenWarpReturnY(...screen...)") != SH::_NoError ||
				BC::checkBounds(index, 0, 9, "Game->SetScreenWarpReturnY(...index...)") != SH::_NoError)
				return;
				
			FFScript::set_screenwarpReturnY(&TheMaps[map * MAPSCRS + scrn], index, nn); 
		}
		break;

		case SDD:
		{
			{
				int32_t di2 = ((get_currdmap())<<7) + get_currscr()-(DMaps[get_currdmap()].type==dmOVERW ? 0 : DMaps[get_currdmap()].xoff);
				FFScript::set_screen_d(di2, ri->d[rINDEX]/10000, value);
				break;
			}
		}
		
		case GDD:
			al_trace("GDD");
			game->global_d[ri->d[rINDEX]/10000]=value;
			break;
			
		case SDDD:
			FFScript::set_screen_d((ri->d[rINDEX])/10000 + ((get_currdmap())<<7), ri->d[rINDEX2]/10000, value);
			break;
			
		case SDDDD:
			FFScript::set_screen_d(ri->d[rINDEX2]/10000 + ((ri->d[rINDEX]/10000)<<7), ri->d[rEXP1]/10000, value);
			break;
			
		case SCREENINITD:
			tmpscr->screeninitd[ri->d[rINDEX]/10000] = value;
			break;
		
		case SCREENSCRIPT:
		{
			FFScript::deallocateAllScriptOwned(ScriptType::Screen, 0);
			
			if ( get_qr(qr_CLEARINITDONSCRIPTCHANGE))
			{
				for(int32_t q=0; q<8; q++)
					tmpscr->screeninitd[q] = 0;
			}
			tmpscr->script=vbound(value/10000, 0, NUMSCRIPTSCREEN-1);
			on_reassign_script_engine_data(ScriptType::Screen, 0);
			break;
		}
		
		case MAPDATAINITD:
			tmpscr->screeninitd[ri->d[rINDEX]/10000]=value;
			break;
		
		case SCRDOORD:
			tmpscr->door[ri->d[rINDEX]/10000]=value/10000;
			putdoor(scrollbuf,0,ri->d[rINDEX]/10000,value/10000,true,true);
			break;
			
		case LIT:
			set_lights(value);
			break;
			
		case WAVY:
			wavy=value/10000;
			break;
			
		case QUAKE:
			quakeclk=value/10000;
			break;
			
		case ROOMTYPE:
			tmpscr->room=value/10000; break; //this probably doesn't work too well...
		
		case ROOMDATA:
			tmpscr->catchall=value/10000;
			break;
			
		case PUSHBLOCKLAYER:
			mblock2.blockLayer=vbound(value/10000, 0, 6);
			break;
			
		case PUSHBLOCKCOMBO:
			mblock2.bcombo=value/10000;
			break;
			
		case PUSHBLOCKCSET:
			mblock2.cs=value/10000;
			mblock2.oldcset=value/10000;
			break;
			
		case UNDERCOMBO:
			tmpscr->undercombo=value/10000;
			break;
			
		case UNDERCSET:
			tmpscr->undercset=value/10000;
			break;
		
		
		case DEBUGGDR:
		{
			int32_t a = vbound(ri->d[rINDEX]/10000,0,15);
			game->global_d[a] = value / 10000;;
			break;
		}
		
		case DEBUGSP:
			SH::write_stack(ri->sp,vbound((value / 10000),0,MAX_SCRIPT_REGISTERS-1));
			break;
			
		case DEBUGREFFFC:
			ri->ffcref = vbound((value / 10000),1,MAXFFCS-1);
			break;
			
		case DEBUGREFITEM:
			ri->itemref = vbound((value / 10000),0,255);
			break;
			
		case DEBUGREFITEMDATA:
			ri->idata = vbound((value / 10000),0,255);
			break;
			
		case DEBUGREFLWEAPON:
			ri->lwpn = vbound((value / 10000),0,255);
			break;
			
		case DEBUGREFEWEAPON:
			ri->ewpn = vbound((value / 10000),0,255);
			break;
			
		case DEBUGREFNPC:
			ri->guyref = vbound((value / 10000),0,255);
			break;
			
		
		//Game Over Screen
		case SETGAMEOVERELEMENT:
		{
			int32_t colour = value/10000;
			int32_t index = ri->d[rINDEX]/10000;
			index = vbound(index,0,SAVESC_LAST-1);
			// zprint("GameOverScreen Index,Value: %d,%ld/n",index,colour);
			SetSaveScreenSetting(index,colour);
			break;
		}

		case SETGAMEOVERSTRING:
		{
			int32_t arrayptr = value/10000;
			int32_t index = ri->d[rINDEX]/10000;
			index = vbound(index,0,SAVESC_END-1);
			string filename_str;
			ArrayH::getString(arrayptr, filename_str, 73);
			ChangeSubscreenText(index,filename_str.c_str());
			break;
		}

	///----------------------------------------------------------------------------------------------------//
	//New Datatype Variables
		
	///----------------------------------------------------------------------------------------------------//
	//spritedata sp-> Variables
		case SPRITEDATATILE: SET_SPRITEDATA_VAR_INT(tile, "Tile"); break;
		case SPRITEDATAMISC: SET_SPRITEDATA_VAR_BYTE(misc, "Misc"); break;
		case SPRITEDATACSETS:
		{
			if(unsigned(ri->spritesref) > (MAXWPNS-1) )
			{
				Z_scripterrlog("Invalid Sprite ID passed to spritedata->CSet: %d\n", (ri->spritesref*10000));
			}
			else
			{
				wpnsbuf[ri->spritesref].csets &= 0xF0;
				wpnsbuf[ri->spritesref].csets |= vbound((value / 10000),0,15);
			}
			break;
		}
		case SPRITEDATAFLCSET:
		{
			if(unsigned(ri->spritesref) > (MAXWPNS-1) )
			{
				Z_scripterrlog("Invalid Sprite ID passed to spritedata->FlashCSet: %d\n", (ri->spritesref*10000));
			}
			else
			{
				wpnsbuf[ri->spritesref].csets &= 0x0F;
				wpnsbuf[ri->spritesref].csets |= vbound((value / 10000),0,15)<<4;
			}
			break;
		}
		case SPRITEDATAFRAMES: SET_SPRITEDATA_VAR_BYTE(frames, "Frames"); break;
		case SPRITEDATASPEED: SET_SPRITEDATA_VAR_BYTE(speed, "Speed"); break;
		case SPRITEDATATYPE: SET_SPRITEDATA_VAR_BYTE(type, "Type"); break;
		case SPRITEDATAFLAGS:
		{
			if(unsigned(ri->spritesref) > (MAXWPNS-1) )
			{
				Z_scripterrlog("Invalid Sprite ID passed to spritedata->Flags[]: %d\n", (ri->spritesref*10000));
				break;
			}
			int32_t index = ri->d[rINDEX]/10000;
			if(unsigned(index) >= 5)
			{
				Z_scripterrlog("Invalid index passed to spritedata->Flags[]: %d\n", index);
				break;
			}
			SETFLAG(wpnsbuf[ri->spritesref].misc, 1<<index, value);
			break;
		}
		
	///----------------------------------------------------------------------------------------------------//
	//mapdata m-> Variables
		//mapdata m-> Variables
		
		#define	SET_MAPDATA_VAR_INT32(member, str) \
		{ \
			if (mapscr *m = GetMapscr(ri->mapsref)) \
			{ \
				m->member = vbound((value / 10000),-214747,214747); \
			} \
			else \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n",str); \
			} \
			break; \
		} \
		
		#define	SET_MAPDATA_VAR_INT16(member, str) \
		{ \
			if (mapscr *m = GetMapscr(ri->mapsref)) \
			{ \
				m->member = vbound((value / 10000),0,32767); \
			} \
			else \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n",str); \
			} \
			break; \
		} \

		#define	SET_MAPDATA_VAR_BYTE(member, str) \
		{ \
			if (mapscr *m = GetMapscr(ri->mapsref)) \
			{ \
				m->member = vbound((value / 10000),0,255); \
			} \
			else \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n",str); \
			} \
			break; \
		} \
		
		#define SET_MAPDATA_VAR_INDEX32(member, str, indexbound) \
		{ \
			int32_t indx = ri->d[rINDEX] / 10000; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, indx); \
			} \
			else if (mapscr *m = GetMapscr(ri->mapsref)) \
			{ \
				m->member[indx] = vbound((value / 10000),-214747,214747); \
			} \
			else \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n",str); \
			} \
			break; \
		} \
		
		#define SET_MAPDATA_VAR_INDEX16(member, str, indexbound) \
		{ \
			int32_t indx = ri->d[rINDEX] / 10000; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, indx); \
			} \
			else if (mapscr *m = GetMapscr(ri->mapsref)) \
			{ \
				m->member[indx] = vbound((value / 10000),-32767,32767); \
			} \
			else \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n",str); \
			} \
			break; \
		} \

		#define SET_MAPDATA_BYTE_INDEX(member, str, indexbound) \
		{ \
			int32_t indx = ri->d[rINDEX] / 10000; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, indx); \
			} \
			else if (mapscr *m = GetMapscr(ri->mapsref)) \
			{ \
				m->member[indx] = vbound((value / 10000),0,255); \
			} \
			else \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n",str); \
			} \
			break; \
		}\
		
		#define SET_MAPDATA_LAYER_INDEX(member, str, indexbound) \
		{ \
			int32_t indx = ri->d[rINDEX] / 10000; \
			if ( FFCore.quest_format[vFFScript] < 11 ) ++indx; \
			if(indx < 1 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, indx); \
			} \
			else if (mapscr *m = GetMapscr(ri->mapsref)) \
			{ \
				m->member[indx-1] = vbound((value / 10000),0,255); \
			} \
			else \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n",str); \
			} \
			break; \
		} \
		
		#define SET_MAPDATA_LAYERSCREEN_INDEX(member, str, indexbound) \
		{ \
			int32_t indx = ri->d[rINDEX] / 10000; \
			if ( FFCore.quest_format[vFFScript] < 11 ) ++indx; \
			int32_t scrn_id = value/10000; \
			if(indx < 1 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, indx); \
			} \
			else if ( scrn_id > MAPSCRS ) \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->LayerScreen[%d].\n",scrn_id); \
				Z_scripterrlog("Valid Screen values are (0) through (%d).\n",MAPSCRS); \
			} \
			else if (mapscr *m = GetMapscr(ri->mapsref)) \
			{ \
				m->member[indx-1] = vbound((scrn_id),0,MAPSCRS); \
			} \
			else \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n",str); \
			} \
			break; \
		}\
		
		#define SET_MAPDATA_BOOL_INDEX(member, str, indexbound) \
		{ \
			int32_t indx = ri->d[rINDEX] / 10000; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, indx); \
			} \
			else if (mapscr *m = GetMapscr(ri->mapsref)) \
			{ \
				m->member[indx] =( (value/10000) ? 1 : 0 ); \
			} \
			else \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n",str); \
			} \
			break; \
		} \

		#define SET_FFC_MAPDATA_BOOL_INDEX(member, str, indexbound) \
		{ \
			int32_t indx = ri->d[rINDEX] / 10000; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, indx); \
			} \
			else if (mapscr *m = GetMapscr(ri->mapsref)) \
			{ \
				m->ffcs[indx].member =( (value/10000) ? 1 : 0 ); \
			} \
			else \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n",str); \
			} \
			break; \
		} \
		
		#define SET_MAPDATA_FLAG(member, str) \
		{ \
			int32_t flag =  (value/10000);  \
			if (mapscr *m = GetMapscr(ri->mapsref)) \
			{ \
				if ( flag != 0 ) \
				{ \
					m->member|=flag; \
				} \
				else m->.member|= ~flag; \
			} \
			else \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n",str); \
			} \
			break; \
		} \
		
		#define SET_MAPDATA_FFCPOS_INDEX32(member, str, indexbound) \
		{ \
			int32_t indx = (ri->d[rINDEX] / 10000)-1; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, (indx+1)); \
			} \
			else if (mapscr *m = GetMapscr(ri->mapsref)) \
			{ \
				m->ffcs[indx].member = zslongToFix(value); \
			} \
			else \
			{ \
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised",	str); \
			} \
			break; \
		} \
		
		#define SET_MAPDATA_FFC_INDEX32(member, str, indexbound) \
		{ \
			int32_t indx = (ri->d[rINDEX] / 10000)-1; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, (indx+1)); \
			} \
			else if (mapscr *m = GetMapscr(ri->mapsref)) \
			{ \
				m->ffcs[indx].member = value/10000; \
			} \
			else \
			{ \
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised",str); \
			} \
			break; \
		} \
		
		#define SET_MAPDATA_FFC_INDEX_VBOUND(member, str, indexbound, min, max) \
		{ \
			int32_t v = value/10000; \
			int32_t indx = (ri->d[rINDEX] / 10000)-1; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, (indx+1)); \
			} \
			else if(v < min || v > max ) \
			{ \
				Z_scripterrlog("Invalid value assigned to mapdata->%s[]: %d\n", str, (indx+1)); \
			} \
			else if (mapscr *m = GetMapscr(ri->mapsref)) \
			{ \
				m->ffcs[indx].member = v; \
			} \
			else \
			{ \
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised",str); \
			} \
			break; \
		} \
		
		case MAPDATAVALID:		SET_MAPDATA_VAR_BYTE(valid, "Valid"); break;		//b
		case MAPDATAGUY: 		SET_MAPDATA_VAR_BYTE(guy, "Guy"); break;		//b
		case MAPDATASTRING:		SET_MAPDATA_VAR_INT32(str, "String"); break;		//w
		case MAPDATAROOM: 		SET_MAPDATA_VAR_BYTE(room, "RoomType");	break;		//b
		case MAPDATAITEM:
		{
			if (mapscr *m = GetMapscr(ri->mapsref))
			{
				auto v = vbound((value / 10000),-1,255);
				if(v > -1)
					m->item = v;
				m->hasitem = v > -1;
			}
			else
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","Item");
			}
			break;
		}
		case MAPDATAHASITEM: 		SET_MAPDATA_VAR_BYTE(hasitem, "HasItem"); break;	//b
		case MAPDATATILEWARPTYPE: 	SET_MAPDATA_BYTE_INDEX(tilewarptype, "TileWarpType", 3); break;	//b, 4 of these
		//case MAPDATATILEWARPOVFLAGS: 	SET_MAPDATA_VAR_BYTE(tilewarpoverlayflags, "TileWarpOverlayFlags"); break;	//b, tilewarpoverlayflags
		case MAPDATADOORCOMBOSET: 	SET_MAPDATA_VAR_INT32(door_combo_set, "DoorComboSet"); break;	//w
		case MAPDATAWARPRETX:	 	SET_MAPDATA_BYTE_INDEX(warpreturnx, "WarpReturnX", 3); break;	//b, 4 of these
		case MAPDATAWARPRETY:	 	SET_MAPDATA_BYTE_INDEX(warpreturny, "WarpReturnY", 3); break;	//b, 4 of these
		case MAPDATAWARPRETURNC: 	SET_MAPDATA_VAR_INT32(warpreturnc, "WarpReturnC"); break;	//w
		case MAPDATASTAIRX: 		SET_MAPDATA_VAR_BYTE(stairx, "StairsX"); break;	//b
		case MAPDATASTAIRY: 		SET_MAPDATA_VAR_BYTE(stairy, "StairsY"); break;	//b
		case MAPDATAITEMX:		SET_MAPDATA_VAR_BYTE(itemx, "ItemX"); break; //itemx
		case MAPDATAITEMY:		SET_MAPDATA_VAR_BYTE(itemy, "ItemY"); break;	//itemy
		case MAPDATACOLOUR: 		SET_MAPDATA_VAR_INT32(color, "CSet"); break;	//w
		case MAPDATAENEMYFLAGS: 	SET_MAPDATA_VAR_BYTE(enemyflags, "EnemyFlags");	break;	//b
		case MAPDATADOOR: 		SET_MAPDATA_BYTE_INDEX(door, "Door", 3); break;	//b, 4 of these
		case MAPDATATILEWARPDMAP: 	SET_MAPDATA_VAR_INDEX32(tilewarpdmap, "TileWarpDMap", 3); break;	//w, 4 of these
		case MAPDATATILEWARPSCREEN: 	SET_MAPDATA_BYTE_INDEX(tilewarpscr, "TileWarpScreen", 3); break;	//b, 4 of these
		case MAPDATAEXITDIR: 		SET_MAPDATA_VAR_BYTE(exitdir, "ExitDir"); break;	//b
		case MAPDATAENEMY: 
		{ 
			int32_t indx = (ri->d[rINDEX] / 10000);
			int32_t enemyid = value/10000;
			if( ((unsigned)indx) > 9 ) 
			{ 
				Z_scripterrlog("Invalid Index passed to mapdata->%s: %d\n", "Enemy[]", (indx));
			} 
			else if ( ((unsigned)enemyid) > MAXGUYS ) 
			{ 
				Z_scripterrlog("Invaid enemy ID (%d) passed to Mapdata->%s.", enemyid,"Enemy[]");
			} 
			else if (mapscr *m = GetMapscr(ri->mapsref)) 
			{ 
				m->enemy[indx] = enemyid; 
			} 
			else 
			{ 
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","Enemy[]");
			} 
			break;
		} 
		//case MAPDATAENEMY: 		SET_MAPDATA_VAR_INDEX32(enemy, "Enemy", 9); break;	//w, 10 of these
		case MAPDATAPATTERN: 		SET_MAPDATA_VAR_BYTE(pattern, "Pattern"); break;	//b
		case MAPDATASIDEWARPTYPE: 	SET_MAPDATA_BYTE_INDEX(sidewarptype, "SideWarpType", 3); break;	//b, 4 of these
		//case MAPDATASIDEWARPOVFLAGS: 	SET_MAPDATA_VAR_BYTE(sidewarpoverlayflags, "SideWarpOverlayFlags"); break;	//b
		case MAPDATAWARPARRIVALX: 	SET_MAPDATA_VAR_BYTE(warparrivalx, "WarpArrivalX"); break;	//b
		case MAPDATAWARPARRIVALY: 	SET_MAPDATA_VAR_BYTE(warparrivaly, "WarpArrivalY"); break;	//b
		case MAPDATAPATH: 		SET_MAPDATA_BYTE_INDEX(path, "MazePath", 3); break;	//b, 4 of these
		case MAPDATASIDEWARPSC: 	SET_MAPDATA_BYTE_INDEX(sidewarpscr, "SideWarpScreen", 3); break;	//b, 4 of these
		case MAPDATAINITDARRAY:	 	
		{
			
			if (mapscr *m = GetMapscr(ri->mapsref)) 
			{ 
				m->screeninitd[ri->d[rINDEX]/10000] = value;
			} 
			else 
			{ 
				Z_scripterrlog("Script attempted to use a mapdata->InitD[%d] on a pointer that is uninitialised\n",ri->d[rINDEX]/10000); 
			} 
			break;
		}


		case MAPDATALAYERINVIS: 	
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if(indx < 0 || indx > 6 )
			{
				Z_scripterrlog("Invalid Index passed to mapdata->LayerInvisible[]: %d\n", indx);
			}
			else
			{
				
				if (mapscr *m = GetMapscr(ri->mapsref))
				{
					if(value)
					{
						tmpscr->hidelayers |= (1<<indx);
					}
					else
					{
						tmpscr->hidelayers &= ~(1<<indx);
					}
				}
				else
				{
					Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","LayerInvisible");
				}
			}
			break;
		}
		case MAPDATASCRIPTDRAWS: 	
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if(indx < 0 || indx > 7 )
			{
				Z_scripterrlog("Invalid Index passed to mapdata->DisableScriptDraw[]: %d\n", indx);
			}
			else
			{
				if (mapscr *m = GetMapscr(ri->mapsref))
				{
					if(value)
					{
						tmpscr->hidescriptlayers &= ~(1<<indx);
					}
					else
					{
						tmpscr->hidescriptlayers |= (1<<indx);
					}
				}
				else
				{	
					Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","DisableScriptDraw");
				}
			}
			break;
		}

		case MAPDATATILEWARPOVFLAGS: 
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if ( ((unsigned)indx) > 3 ) 
			{
				Z_scripterrlog("Invalid index passed to TileWarpOverlayFlags[%d].\n. Valid indices are [0] through [3].\n", indx);
			}
			else if (mapscr *m = GetMapscr(ri->mapsref))
			{
				if ( value ) m->tilewarpoverlayflags |= (1<<indx);
				else m->tilewarpoverlayflags &= ~(1<<indx);
			}
			else
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","NumFFCs[]");
			}
			break;
		}

		case MAPDATASIDEWARPOVFLAGS: 
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if ( ((unsigned)indx) > 3 ) 
			{
				Z_scripterrlog("Invalid index passed to SideWarpOverlayFlags[%d].\n. Valid indices are [0] through [3].\n", indx);
			}
			else if (mapscr *m = GetMapscr(ri->mapsref))
			{
				if ( value ) m->sidewarpoverlayflags |= (1<<indx);
				else m->sidewarpoverlayflags &= ~(1<<indx);
			}
			else
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","NumFFCs[]");
			}
			break;
		}

		case MAPDATASIDEWARPDMAP: 	SET_MAPDATA_VAR_INDEX32(sidewarpdmap, "SideWarpDMap", 3); break;	//w, 4 of these
		case MAPDATASIDEWARPINDEX: 	SET_MAPDATA_VAR_BYTE(sidewarpindex, "SideWarpIndex"); break;	//b
		case MAPDATAUNDERCOMBO: 	SET_MAPDATA_VAR_INT32(undercombo, "UnderCombo"); break;	//w
		case MAPDATAUNDERCSET:	 	SET_MAPDATA_VAR_BYTE(undercset,	"UnderCSet"); break; //b
		case MAPDATACATCHALL:	 	SET_MAPDATA_VAR_INT32(catchall,	"Catchall"); break; //W

		case MAPDATACSENSITIVE: 	SET_MAPDATA_VAR_BYTE(csensitive, "CSensitive"); break;	//B
		case MAPDATANORESET: 		SET_MAPDATA_VAR_INT32(noreset, "NoReset"); break;	//W
		case MAPDATANOCARRY: 		SET_MAPDATA_VAR_INT32(nocarry, "NoCarry"); break;	//W
		//! Layer arrays should be a size of 7, and return the current screen / map / and OP_OPAQUE 
		//! if you try to read 0, so that they correspond to actual layer IDs. 
		//! 
		case MAPDATALAYERMAP:	 	SET_MAPDATA_LAYER_INDEX(layermap, "LayerMap", 6); break;	//B, 6 OF THESE
		case MAPDATALAYERSCREEN: 	SET_MAPDATA_LAYERSCREEN_INDEX(layerscreen, "LayerScreen", 6); break;	//B, 6 OF THESE
		case MAPDATALAYEROPACITY: 	SET_MAPDATA_LAYER_INDEX(layeropacity, "LayerOpacity", 6); break;	//B, 6 OF THESE
		case MAPDATATIMEDWARPTICS: 	SET_MAPDATA_VAR_INT32(timedwarptics, "TimedWarpTimer"); break;	//W
		case MAPDATANEXTMAP: 		SET_MAPDATA_VAR_BYTE(nextmap, "NextMap"); break;	//B
		case MAPDATANEXTSCREEN: 	SET_MAPDATA_VAR_BYTE(nextscr, "NextScreen"); break;	//B
		case MAPDATASECRETCOMBO: 	SET_MAPDATA_VAR_INDEX32(secretcombo, "SecretCombo", 127); break;	//W, 128 OF THESE
		case MAPDATASECRETCSET: 	SET_MAPDATA_BYTE_INDEX(secretcset, "SecretCSet", 127); break;	//B, 128 OF THESE
		case MAPDATASECRETFLAG: 	SET_MAPDATA_BYTE_INDEX(secretflag, "SecretFlags", 127); break;	//B, 128 OF THESE
		case MAPDATAVIEWX: 		break;//SET_MAPDATA_VAR_INT32(viewX, "ViewX"); break;	//W
		case MAPDATASCRIPT:
		{
			if (mapscr *m = GetMapscr(ri->mapsref)) 
			{
				if(ri->mapsref == MAPSCR_TEMP0) //This mapsref references tmpscr, so can reference a running script!
				{
					if ( get_qr(qr_CLEARINITDONSCRIPTCHANGE))
					{
						for(int32_t q=0; q<8; q++)
							tmpscr->screeninitd[q] = 0;
					}
					
					on_reassign_script_engine_data(ScriptType::Screen, 0);
				}
				m->script=vbound(value/10000, 0, NUMSCRIPTSCREEN-1);
			} 
			else 
			{ 
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","Script");
			} 
			break;
			
		}
		case MAPDATAVIEWY: 		break;//SET_MAPDATA_VAR_INT32(viewY, "ViewY"); break; //W
		case MAPDATASCREENWIDTH: 	break;//SET_MAPDATA_VAR_BYTE(scrWidth, "Width"); break;	//B
		case MAPDATASCREENHEIGHT: 	break;//SET_MAPDATA_VAR_BYTE(scrHeight,	"Height"); break;	//B
		case MAPDATAENTRYX: 		SET_MAPDATA_VAR_BYTE(entry_x, "EntryX"); break;	//B
		case MAPDATAENTRYY: 		SET_MAPDATA_VAR_BYTE(entry_y, "EntryY"); break;	//B
		case MAPDATAFFDATA:         
		{
			int32_t indx = (ri->d[rINDEX] / 10000)-1;
			if(indx < 0 || indx > MAXFFCS-1 )
			{
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", "FFCData", (indx+1));
			}
			else if (mapscr *m = GetMapscr(ri->mapsref))
			{
				zc_ffc_set(m->ffcs[indx], value/10000);
			}
			else
			{
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised", "FFCData");
			}
			break;  //W, MAXFFCS OF THESE
		}
		case MAPDATAFFCSET:         SET_MAPDATA_FFC_INDEX32(cset, "FFCCSet", MAXFFCS-1); break;  //B, MAXFFCS
		case MAPDATAFFDELAY:        SET_MAPDATA_FFC_INDEX32(delay, "FFCDelay", MAXFFCS-1); break;    //W, MAXFFCS
		case MAPDATAFFX:        SET_MAPDATA_FFCPOS_INDEX32(x, "FFCX", MAXFFCS-1); break; //INT32, MAXFFCS OF THESE
		case MAPDATAFFY:        SET_MAPDATA_FFCPOS_INDEX32(y, "FFCY", MAXFFCS-1); break; //..
		case MAPDATAFFXDELTA:       SET_MAPDATA_FFCPOS_INDEX32(vx, "FFCVx", MAXFFCS-1); break;   //..
		case MAPDATAFFYDELTA:       SET_MAPDATA_FFCPOS_INDEX32(vy, "FFCVy", MAXFFCS-1); break;   //..
		case MAPDATAFFXDELTA2:      SET_MAPDATA_FFCPOS_INDEX32(ax, "FFCAx", MAXFFCS-1); break;  //..
		case MAPDATAFFYDELTA2:      SET_MAPDATA_FFCPOS_INDEX32(ay, "FFCAy", MAXFFCS-1); break;  //..
		
		case MAPDATAFFFLAGS:
		{
			int32_t indx = (ri->d[rINDEX] / 10000)-1;
			if(indx < 0 || indx > MAXFFCS-1)
			{
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", (indx+1), "FFCFlags");
			}
			else if (mapscr *m = GetMapscr(ri->mapsref))
			{
				m->ffcs[indx].flags = value/10000;
				m->ffcs[indx].updateSolid();
			}
			else
			{
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","FFCFlags");
			}
			break;
		}

		//Number of ffcs that are in use (have valid data
		case MAPDATANUMFF: 	
		{
			break;
		}

		case MAPDATASIDEWARPID:
		{
			
			int32_t indx = ri->d[rINDEX] / 10000; //dir
			if (mapscr *m = GetMapscr(ri->mapsref))
			{
				int32_t new_warp_return = vbound((value / 10000),-1,3); //none, A, B, C, D
				if(new_warp_return == -1)
				{
					m->flags2 &= ~(1<<indx); //Unset the "Enabled" flag for this dir
					m->sidewarpindex &= ~(3<<(2*indx)); //Clear the dir as well.
				}
				else
				{
					m->flags2 |= 1<<indx; //Set the "Enabled" flag for this dir
					m->sidewarpindex &= ~(3<<(2*indx)); //Clear the dir bits
					m->sidewarpindex |= (new_warp_return<<(2*indx)); //Set the new dir
				}
			}
			else
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","SideWarpID"); 
			} 
			break;
		} 

		case MAPDATATWARPRETSQR:
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if ( ((unsigned)indx) > 3)
			{
				 Z_scripterrlog("Invalid Array Index passed to mapdata->TileWarpReturnSquare[]: %d\n", indx);
			}
			else if (mapscr *m = GetMapscr(ri->mapsref))
			{
				int32_t wrindex = vbound(value/10000, 0, 3);
				m->warpreturnc = (m->warpreturnc&~(3<<(indx*2))) | (wrindex<<(indx*2));
			} 
			else
			{
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","str"); 
			}
			break;
		}

		//
		case MAPDATASWARPRETSQR:
		{
			
			int32_t indx = ri->d[rINDEX] / 10000;
			if ( ((unsigned)indx) > 3)
			{
				 Z_scripterrlog("Invalid Array Index passed to MAPDATA->SideWarpReturnSquare[]: %d\n", indx);
			}
			else if (mapscr *m = GetMapscr(ri->mapsref))
			{
				int32_t wrindex = vbound(value/10000, 0, 3);
				m->warpreturnc = (m->warpreturnc&~(3<<(8+(indx*2)))) | (wrindex<<(8+(indx*2)));
			} 
			else
			{
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","str"); 
			}
			break;
		}

		case MAPDATAFFWIDTH:       
		{
			int32_t indx = (ri->d[rINDEX] / 10000)-1;
			if ( indx < 0 || indx > MAXFFCS-1 )
			{
				Z_scripterrlog("Invalid FFC Index passed to MapData->FFCTileWidth[]: %d\n", indx+1);
			}
			else if ( (value/10000) < 0 || (value/10000) > 4 )
			{
				Z_scripterrlog("Invalid WIDTH value passed to MapData->FFCTileWidth[]: %d\n", value/10000);
			}
			else if (mapscr *m = GetMapscr(ri->mapsref))
			{
				m->ffTileWidth(indx, (value/10000));
			}
			else
			{
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","FFCTileWidth[]");
			}
			break;
		}  
		 
		case MAPDATAFFHEIGHT:      
		{
			int32_t indx = (ri->d[rINDEX] / 10000)-1;
			if ( indx < 0 || indx > MAXFFCS-1 )
			{
				Z_scripterrlog("Invalid FFC Index passed to MapData->FFCTileHeight[]: %d\n", indx+1);
			}
			else if ( (value/10000) < 0 || (value/10000) > 4 )
			{
				Z_scripterrlog("Invalid WIDTH value passed to MapData->FFCTileHeight[]: %d\n", value/10000);
			}
			else if (mapscr *m = GetMapscr(ri->mapsref))
			{
				m->ffTileHeight(indx, (value/10000));
			}
			else
			{
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","FFCTileHeight[]");
			}
			break;
			
		}
		 
		case MAPDATAFFEFFECTWIDTH:     
		{
			int32_t indx = (ri->d[rINDEX] / 10000)-1;
			if ( indx < 0 || indx > MAXFFCS-1 )
			{
				Z_scripterrlog("Invalid FFC Index passed to MapData->FFCEffectWidth[]: %d\n", indx+1);
			}
			else if ( (value/10000) < 0 )
			{
				Z_scripterrlog("Invalid WIDTH value passed to MapData->FFCEffectWidth[]: %d\n", value/10000);
			}
			else if (mapscr *m = GetMapscr(ri->mapsref))
			{
				m->ffEffectWidth(indx, (value/10000));
			}
			else
			{
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","FFCEffectWidth[]");
			}
			break;
		}
		 
		case MAPDATAFFEFFECTHEIGHT:
		{
			int32_t indx = (ri->d[rINDEX] / 10000)-1;
			if ( indx < 0 || indx > MAXFFCS-1 )
			{
				Z_scripterrlog("Invalid FFC Index passed to MapData->FFCEffectHeight[]: %d\n", indx+1);
			}
			else if ( (value/10000) < 0 )
			{
				Z_scripterrlog("Invalid HEIGHT value passed to MapData->FFCEffectHeight[]: %d\n", value/10000);
			}
			else if (mapscr *m = GetMapscr(ri->mapsref))
			{
				m->ffEffectHeight(indx, (value/10000));
			}
			else
			{
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","FFCEffectHeight[]");
			}
			break;
		}
		 
		case MAPDATAFFLINK:         SET_MAPDATA_FFC_INDEX_VBOUND(link, "FFCLink", MAXFFCS-1, 0, MAXFFCS); break;  //B, MAXFFCS OF THESE
		case MAPDATAFFSCRIPT:       SET_MAPDATA_FFC_INDEX_VBOUND(script, "FFCScript", MAXFFCS-1, 0, 255); break; //W, 32 OF THESE

		case MAPDATAINTID: 	 //Same form as SetScreenD()
			//SetFFCInitD(ffindex, d, value)
		{
			if (mapscr *m = GetMapscr(ri->mapsref))
			{
				//int32_t ffindex = ri->d[rINDEX]/10000;
				//int32_t d = ri->d[rINDEX2]/10000;
				//int32_t v = (value/10000);
				int32_t ffid = (ri->d[rINDEX]/10000) -1;
				int32_t indx = ri->d[rINDEX2]/10000;
					
				if ( (unsigned)ffid > MAXFFCS-1 ) 
				{
					Z_scripterrlog("Invalid FFC id passed to mapdata->FFCInitD[]: %d",ffid); 
				}
				else if ( (unsigned)indx > 7 )
				{
					Z_scripterrlog("Invalid InitD[] index passed to mapdata->FFCInitD[]: %d",indx);
				}
				else
				{ 
					 m->ffcs[ffid].initd[indx] = value;
				}
			}
			else
			{
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","SetFFCInitD()");
			}
			break;
		}	
			

		//initd	//INT32 , 32 OF THESE, EACH WITH 10 INDICES. 


		case MAPDATAINITA: 		
			//same form as SetScreenD
		{
			if (mapscr *m = GetMapscr(ri->mapsref))
			{//int32_t ffindex = ri->d[rINDEX]/10000;
				//int32_t d = ri->d[rINDEX2]/10000;
				//int32_t v = (value/10000);
				int32_t ffid = (ri->d[rINDEX]/10000) -1;
				int32_t indx = ri->d[rINDEX2]/10000;
					
				if ( (unsigned)ffid > MAXFFCS-1 ) 
				{
					Z_scripterrlog("Invalid FFC id passed to mapdata->FFCInitD[]: %d",ffid); 
				}
				else if ( (unsigned)indx > 7 )
				{
					Z_scripterrlog("Invalid InitD[] index passed to mapdata->FFCInitD[]: %d",indx);
				}
				else
				{ 
					 m->ffcs[ffid].inita[indx] = value;
				}
			}
			else
			{
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","SetFFCInitA()");
			}
			break;
		}

		case MAPDATAFFINITIALISED:
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if(indx < 0 || indx > MAXFFCS-1)
			{
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", "FFCRunning", indx);
			}
			else if (mapscr *m = GetMapscr(ri->mapsref))
			{
				get_script_engine_data(ScriptType::FFC, indx).initialized = (value/10000) ? true : false;
			}
			else
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n", "FFCRunning");
			}
		}
		break;

		case MAPDATASCRIPTENTRY: 	SET_MAPDATA_VAR_INT32(script_entry, "ScriptEntry"); break;	//W
		case MAPDATASCRIPTOCCUPANCY: 	SET_MAPDATA_VAR_INT32(script_occupancy,	"ScriptOccupancy");  break;//W
		case MAPDATASCRIPTEXIT: 	SET_MAPDATA_VAR_INT32(script_exit, "ExitScript"); break;	//W
		case MAPDATAOCEANSFX:
		{
			if (mapscr *m = GetMapscr(ri->mapsref))
			{
				int32_t v = vbound(value/10000, 0, 255);
				if(m == tmpscr && m->oceansfx != v)
				{
					stop_sfx(m->oceansfx);
					m->oceansfx = v;
					cont_sfx(m->oceansfx);
				}
				else m->oceansfx = v;
			}
			else
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","OceanSFX");
			}
			break;
		}
		case MAPDATABOSSSFX: 		SET_MAPDATA_VAR_BYTE(bosssfx, "BossSFX"); break;	//B
		case MAPDATASECRETSFX:	 	SET_MAPDATA_VAR_BYTE(secretsfx, "SecretSFX"); break;	//B
		case MAPDATAHOLDUPSFX:	 	SET_MAPDATA_VAR_BYTE(holdupsfx,	"ItemSFX"); break; //B
		case MAPDATASCREENMIDI:
		{
			if (mapscr *m = GetMapscr(ri->mapsref))
			{
				m->screen_midi = vbound((value / 10000)-(MIDIOFFSET_MAPSCR-MIDIOFFSET_ZSCRIPT),-1,32767);
			}
			else
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","MIDI");
			}
			break;
		}
		case MAPDATALENSLAYER:	 	SET_MAPDATA_VAR_BYTE(lens_layer, "LensLayer"); break;	//B, OLD QUESTS ONLY?
			

		case MAPDATAFLAGS: 
		{
			int32_t flagid = (ri->d[rINDEX])/10000;
			//bool valtrue = ( value ? 10000 : 0);
			if(mapscr *m = GetMapscr(ri->mapsref))
			{
				switch(flagid)
				{
					case 0: m->flags = (value / 10000); break;
					case 1: m->flags2 = (value / 10000); break;
					case 2: m->flags3 = (value / 10000); break;
					case 3: m->flags4 = (value / 10000); break;
					case 4: m->flags5 = (value / 10000); break;
					case 5: m->flags6 = (value / 10000); break;
					case 6: m->flags7 = (value / 10000); break;
					case 7: m->flags8 = (value / 10000); break;
					case 8: m->flags9 = (value / 10000); break;
					case 9: m->flags10 = (value / 10000); break;
					default:
					{
						Z_scripterrlog("Invalid index passed to mapdata->flags[]: %d\n", flagid); 
						break;
					}
				}
			}
			else
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","Flags[]");
			}
			break;
			//SET_MAPDATA_BYTE_INDEX	//B, 11 OF THESE, flags, flags2-flags10
		}

		case MAPDATAMISCD:
		{
			if(mapscr* m = GetMapscr(ri->mapsref))
			{
				int32_t indx = (ri->d[rINDEX])/10000;
				int32_t mi = get_mi(ri->mapsref);
				if(mi<0) break;
				if( ((unsigned)indx) > 7 )
				{
					Z_scripterrlog("You were trying to reference an out-of-bounds array index for a screen's D[] array (%ld); valid indices are from 0 to 7.\n", indx);
					break;
				}
				else 
				{
					game->screen_d[mi][indx] = value/10000;
					break;
				}
			}
			else
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","D[]");
			}
			break;
		}


		case MAPDATACOMBODD:
		{
			int32_t pos = (ri->d[rINDEX])/10000;
			int32_t val = (value/10000);
      
			if(mapscr *m = GetMapscr(ri->mapsref))
			{
				if ( ((unsigned) pos) > 175 )
				{
					Z_scripterrlog("Invalid [pos] %d used to write to mapdata->ComboD[]\n", pos);
				}
				else if ( ((unsigned) val) >= MAXCOMBOS )
				{
					Z_scripterrlog("Invalid combo ID %d used to write to mapdata->ComboD[]\n", val);
				}
				else
				{
					screen_combo_modify_preroutine(m,pos);
					m->data[pos]=val;
					screen_combo_modify_postroutine(m,pos);
				}
			}
			else
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","ComboD[]");
			}
		}
		break;
		
		case MAPDATACOMBOCD:
		{
			int32_t pos = (ri->d[rINDEX])/10000;
			int32_t val = (value/10000); //cset
			if(mapscr *m = GetMapscr(ri->mapsref))
			{
				if ( ((unsigned) pos) > 175 )
				{
					Z_scripterrlog("Invalid [pos] %d used to write to mapdata->ComboC[]\n", pos);
				}
				else if ( ((unsigned) val) >= 15 )
				{
					Z_scripterrlog("Invalid CSet ID %d used to write to mapdata->ComboC[]\n", val);
				}
				else
				{
					screen_combo_modify_preroutine(m,pos);
					m->cset[pos]=(val)&15;
					screen_combo_modify_postroutine(m,pos);
				}
			}
			else
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","ComboC[]");
			}
		}
		break;
		
		case MAPDATACOMBOFD:
		{
			int32_t pos = (ri->d[rINDEX])/10000;
			int32_t val = (value/10000); //flag
			if(mapscr *m = GetMapscr(ri->mapsref))
			{
				if ( ((unsigned) pos) > 175 )
				{
					Z_scripterrlog("Invalid [pos] %d used to write to mapdata->ComboF[]\n", pos);
				}
				else if ( ((unsigned) val) >= 256 )
				{
					Z_scripterrlog("Invalid Flag ID %d used to write to mapdata->ComboF[]\n", val);
				}
				
				else
					m->sflag[pos]=(val);
			}
			else
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","ComboF[]");
			}
		}
		break;
		
		case MAPDATACOMBOTD:
		{
			int32_t pos = (ri->d[rINDEX])/10000;
			int32_t val = (value/10000); //type
			if(mapscr *m = GetMapscr(ri->mapsref))
			{
				if ( ((unsigned) pos) > 175 )
				{
					Z_scripterrlog("Invalid [pos] %d used to write to mapdata->ComboT[]\n", pos);
				}
				else if ( ((unsigned) val) >= cMAX )
				{
					Z_scripterrlog("Invalid Type ID %d used to write to mapdata->ComboT[]\n", val);
				}
				else
				{
					auto cid = m->data[pos];
					screen_combo_modify_pre(cid);
					combobuf[cid].type=val;
					screen_combo_modify_post(cid);
				}
			}
			else
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","ComboT[]");
			}
		}
		break;
		
		case MAPDATACOMBOID:
		{
			int32_t pos = (ri->d[rINDEX])/10000;
			int32_t val = (value/10000); //iflag
			if(mapscr *m = GetMapscr(ri->mapsref))
			{
				if ( ((unsigned) pos) > 175 )
				{
					Z_scripterrlog("Invalid [pos] %d used to write to mapdata->ComboI[]\n", pos);
				}
				else if ( ((unsigned) val) >= 256 )
				{
					Z_scripterrlog("Invalid Flag ID %d used to write to mapdata->ComboI[]\n", val);
				}
				
				else
					combobuf[m->data[pos]].flag=value/10000;
			}
			else
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","ComboI[]");
			}
		}
		break;
		
		case MAPDATACOMBOSD:
		{
			int32_t pos = (ri->d[rINDEX])/10000;
			int32_t val = (value/10000); //solidity
			if(mapscr *m = GetMapscr(ri->mapsref))
			{
				if ( ((unsigned) pos) > 175 )
				{
					Z_scripterrlog("Invalid [pos] %d used to write to mapdata->ComboS[]\n", pos);
				}
				else if ( ((unsigned) val) >= 16 )
				{
					Z_scripterrlog("Invalid Solidity %d used to write to mapdata->ComboS[]\n", val);
				}
				
				else
				{
					combobuf[m->data[pos]].walk &= ~0x0F;
					combobuf[m->data[pos]].walk |= (val)&0x0F;
				}
			}
			else
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","ComboS[]");
			}
		}
		break;
		
		case MAPDATACOMBOED:
		{
			int32_t pos = (ri->d[rINDEX])/10000;
			int32_t val = (value/10000); //solidity
			if(mapscr *m = GetMapscr(ri->mapsref))
			{
				if ( ((unsigned) pos) > 175 )
				{
					Z_scripterrlog("Invalid [pos] %d used to write to mapdata->ComboE[]\n", pos);
				}
				else if ( ((unsigned) val) >= 16 )
				{
					Z_scripterrlog("Invalid Solidity %d used to write to mapdata->ComboE[]\n", val);
				}
				
				else
				{
					combobuf[m->data[pos]].walk &= ~0xF0;
					combobuf[m->data[pos]].walk |= ((val)&0x0F)<<4;
				}
			}
			else
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","ComboE[]");
			}
		}
		break;

		case MAPDATASCREENSTATED:
		{
			if(mapscr* m = GetMapscr(ri->mapsref))
			{
				int32_t mi = get_mi(ri->mapsref);
				if(mi<0) break;
				(value)?setmapflag(mi, 1<<((ri->d[rINDEX])/10000)) : unsetmapflag(mi, 1 << ((ri->d[rINDEX]) / 10000));
			}
			else
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","State[]");
			}
		}
		break;
		case MAPDATAEXSTATED:
		{
			if(mapscr* m = GetMapscr(ri->mapsref))
			{
				int32_t mi = get_mi(ri->mapsref);
				if(mi<0) break;
				(value)?setxmapflag(mi, 1<<((ri->d[rINDEX])/10000)) : unsetxmapflag(mi, 1 << ((ri->d[rINDEX]) / 10000));
			}
			else
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on an invalid pointer\n","State[]");
			}
			break;
		}
		case MAPDATALENSSHOWS:
		{
			int ind = ri->d[rINDEX]/10000;
			if(ind < 0 || ind > 6)
				Z_scripterrlog("Bad index mapdata->LensShows[%d]\n",ind);
			else if(mapscr *m = GetMapscr(ri->mapsref))
			{
				SETFLAG(m->lens_show, 1<<ind, value);
				if(value) m->lens_hide &= ~(1<<ind);
			}
			else Z_scripterrlog("mapdata->LensShows[] pointer (%d) is either invalid or uninitialised.\n", ri->mapsref);
			break;
		}
		case MAPDATALENSHIDES:
		{
			int ind = ri->d[rINDEX]/10000;
			if(ind < 0 || ind > 6)
				Z_scripterrlog("Bad index mapdata->LensHides[%d]\n",ind);
			else if(mapscr *m = GetMapscr(ri->mapsref))
			{
				SETFLAG(m->lens_hide, 1<<ind, value);
				if(value) m->lens_show &= ~(1<<ind);
			}
			else Z_scripterrlog("mapdata->LensHides[] pointer (%d) is either invalid or uninitialised.\n", ri->mapsref);
			break;
		}
		case MAPDATASCRDATASIZE:
		{
			if(mapscr *m = GetMapscr(ri->mapsref))
			{
				auto mi = get_total_mi(ri->mapsref);
				if(mi < 0) break;
				game->scriptDataResize(mi, value/10000);
			}
			else Z_scripterrlog("mapdata->DataSize pointer (%d) is either invalid or uninitialised.\n", ri->mapsref);
			break;
		}
		case MAPDATASCRDATA:
		{
			if(mapscr *m = GetMapscr(ri->mapsref))
			{
				auto mi = get_total_mi(ri->mapsref);
				if(mi < 0) break;
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= game->scriptDataSize(mi))
					Z_scripterrlog("Invalid index passed to mapdata->Data[]: %d\n", indx);
				else game->screen_data[mi][indx] = value;
			}
			else Z_scripterrlog("mapdata->Data[] pointer (%d) is either invalid or uninitialised.\n", ri->mapsref);
			break;
		}
		case MAPDATAGUYCOUNT:
		{
			if(mapscr *m = GetMapscr(ri->mapsref))
			{
				int mi = get_mi(ri->mapsref);
				if(mi > -1)
				{
					game->guys[mi] = vbound(value/10000,10,0);
					break;
				}
			}
			else Z_scripterrlog("Mapdata->%s pointer (%d) is either invalid or uninitialised.\n","GuyCount", ri->mapsref);
			break;
		}
		case MAPDATAEXDOOR:
		{
			if(mapscr *m = GetMapscr(ri->mapsref))
			{
				int mi = get_mi(ri->mapsref);
				if(mi < 0) break;
				int dir = SH::read_stack(ri->sp+1) / 10000;
				int ind = SH::read_stack(ri->sp+0) / 10000;
				if(unsigned(dir) > 3)
					Z_scripterrlog("Invalid dir '%d' passed to 'mapdata->SetExDoor()'; must be 0-3\n", dir);
				else if(unsigned(ind) > 7)
					Z_scripterrlog("Invalid index '%d' passed to 'mapdata->SetExDoor()'; must be 0-7\n", ind);
				else
					set_xdoorstate(mi, dir, ind);
			}
			else Z_scripterrlog("mapdata->SetExDoor pointer (%d) is either invalid or uninitialised.\n", ri->mapsref);
			break;
		}

		
	///----------------------------------------------------------------------------------------------------//
	//shopdata sd-> Variables
		
		case SHOPDATAITEM: 
		{ 
			
			int32_t ref = ri->shopsref; 
			bool isInfo = ( ref > NUMSHOPS && ref <= NUMINFOSHOPS ); 
			int32_t indx = ri->d[rINDEX] / 10000; 
			if ( indx < 0 || indx > 2 ) 
			{ 
				Z_scripterrlog("Invalid Array Index passed to shopdata->%s: %d\n", indx, "Item"); 
				break;
			} 
			else 
			{ 
				if ( isInfo ) 
				{ 
					Z_scripterrlog("Attempted to write an 'item' to an infoshop, using shop ID: %d\n", ri->shopsref); 
					break;
				} 
				else 
				{ 
					QMisc.shop[ref].item[indx] = (byte)(vbound((value/10000), 0, 255)); 
					break;
				} 
			} 
		} 
		break;
		//SET_SHOPDATA_VAR_INDEX(item, "Item", 2); break;
		case SHOPDATAHASITEM: 
		{ 
			
			int32_t ref = ri->shopsref; 
			bool isInfo = ( ref > NUMSHOPS && ref <= NUMINFOSHOPS ); 
			int32_t indx = ri->d[rINDEX] / 10000; 
			if ( indx < 0 || indx > 2 ) 
			{ 
				Z_scripterrlog("Invalid Array Index passed to shopdata->%s: %d\n", indx, "HasItem"); 
				break;
			} 
			else 
			{ 
				if ( isInfo ) 
				{ 
					Z_scripterrlog("Attempted to write 'hasitem' to an infoshop, using shop ID: %d\n", ri->shopsref); 
					break;
				} 
				else 
				{ 
					QMisc.shop[ref].hasitem[indx] = (byte)(vbound((value/10000), 0, 255)); break;
				} 
			} 
		} 
		break;
		//SET_SHOPDATA_VAR_INDEX(hasitem, "HasItem", 2); break;
		case SHOPDATAPRICE: 
		{ 
			
			int32_t ref = ri->shopsref; 
			bool isInfo = ( ref > NUMSHOPS && ref <= NUMINFOSHOPS ); 
			int32_t indx = ri->d[rINDEX] / 10000; 
			if ( indx < 0 || indx > 2 ) 
			{ 
				Z_scripterrlog("Invalid Array Index passed to shopdata->%s: %d\n", indx, "Price"); 
				break;
			} 
			else
			{ 
				if ( isInfo ) 
				{ 
					QMisc.info[ref - NUMSHOPS].price[indx] = (word)(vbound((value/10000), 0, 65535));
					break;
				} 
				else 
				{ 
					QMisc.shop[ref].price[indx] = (word)(vbound((value/10000), 0, 65535));
					break;
				} 
			} 
		} 
		//SET_SHOPDATA_VAR_INDEX(price, "Price", 2); break;
		//Pay for info
		case SHOPDATASTRING:
		{
			{
				int32_t ref = ri->shopsref;
				if ( ref < NUMSHOPS || ref > NUMINFOSHOPS )
				{
					Z_scripterrlog("Invalid Info Shop ID passed to shopdata->String[]: %d\n", ref); 
					break;
				}
				else 
				{
					bool isInfo = ( ref > NUMSHOPS && ref <= NUMINFOSHOPS ); 
					int32_t indx = ri->d[rINDEX] / 10000; 
					if ( indx < 0 || indx > 2 ) 
					{ 
						Z_scripterrlog("Invalid Array Index passed to shopdata->%s: %d\n", indx, "HasItem"); 
						break;
					} 
					else 
					{ 
						if ( isInfo ) 
						{ 
							QMisc.info[ref - NUMSHOPS].str[indx] = (word)(vbound((value/10000), 0, 32767));
							break;
						} 
						else 
						{ 
							QMisc.shop[ref].str[indx] = (word)(vbound((value/10000), 0, 32767));
							break;
						} 
					} 
			
			
				}
					
				//GET_SHOPDATA_VAR_INDEX(str, String, 2); break;
			} break;
		}

		///----------------------------------------------------------------------------------------------------//
		//dmapdata dmd-> Variables
		case DMAPDATAMAP: 	//byte
		{
			DMaps[ri->dmapsref].map = ((byte)(value / 10000)) - 1; break;
		}
		case DMAPDATALEVEL:	//word
		{
			DMaps[ri->dmapsref].level = ((word)(value / 10000)); break;
		}
		case DMAPDATAOFFSET:	//char
		{
			DMaps[ri->dmapsref].xoff = ((char)(value / 10000)); break;
		}
		case DMAPDATACOMPASS:	//byte
		{
			DMaps[ri->dmapsref].compass = ((byte)(value / 10000)); break;
		}
		case DMAPDATAPALETTE:	//word
		{
			DMaps[ri->dmapsref].color= ((word)(value / 10000));
			if(ri->dmapsref == currdmap)
			{
				loadlvlpal(DMaps[ri->dmapsref].color);
				currcset = DMaps[ri->dmapsref].color;
			}
			break;
		}
		case DMAPDATAMIDI:	//byte
		{
			DMaps[ri->dmapsref].midi = ((byte)((value / 10000)+MIDIOFFSET_DMAP)); break;
		}
		case DMAPDATACONTINUE:	//byte
		{
			DMaps[ri->dmapsref].cont = ((byte)(value / 10000)); break;
		}
		case DMAPDATATYPE:	//byte
		{
			DMaps[ri->dmapsref].type = (((byte)(value / 10000))&dmfTYPE) | (DMaps[ri->dmapsref].type&~dmfTYPE); break;
		}
		case DMAPSCRIPT:	//byte
		{
			DMaps[ri->dmapsref].script = vbound((value / 10000),0,NUMSCRIPTSDMAP-1);
			on_reassign_script_engine_data(ScriptType::DMap, ri->dmapsref);
			break;
		}
		case DMAPDATASIDEVIEW:	//byte, treat as bool
		{
			DMaps[ri->dmapsref].sideview = ((value) ? 1 : 0); break;
		}
		case DMAPDATAGRID:	//byte[8] --array
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if ( indx < 0 || indx > 7 ) 
			{
				Z_scripterrlog("Invalid index supplied to dmapdata->Grid[]: %d\n", indx); break;
			}
			else
			{
				DMaps[ri->dmapsref].grid[indx] = ((byte)(value / 10000)); break;
			}
		}
		case DMAPINITD:
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if ( indx < 0 || indx > 7 ) 
			{
				Z_scripterrlog("Invalid index supplied to dmapdata->InitD[]: %d\n", indx); break;
			}
			else
			{
				DMaps[ri->dmapsref].initD[indx] = value; break;
			}
		}
		case DMAPDATAMINIMAPTILE:	//word - two of these, so let's do MinimapTile[2]
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			switch(indx)
			{
				case 0: { DMaps[ri->dmapsref].minimap_1_tile = ((word)(value / 10000)); break; }
				case 1: { DMaps[ri->dmapsref].minimap_2_tile = ((word)(value / 10000)); break; }
				default: 
				{
					Z_scripterrlog("Invalid index supplied to dmapdata->MiniMapTile[]: %d\n", indx);
					break;
				}
			}
			break;
		}
		case DMAPDATAMINIMAPCSET:	//byte - two of these, so let's do MinimapCSet[2]
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			switch(indx)
			{
				case 0: { DMaps[ri->dmapsref].minimap_1_cset= ((byte)(value / 10000)); break; }
				case 1: { DMaps[ri->dmapsref].minimap_2_cset= ((byte)(value / 10000)); break; }
				default: 
				{
					Z_scripterrlog("Invalid index supplied to dmapdata->MiniMapCSet[]: %d\n", indx);
					break;
				}
			}
			break;
		}
		case DMAPDATALARGEMAPTILE:	//word -- two of these, so let's to LargemapTile[2]
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			switch(indx)
			{
				case 0: { DMaps[ri->dmapsref].largemap_1_tile = ((word)(value / 10000)); break; }
				case 1: { DMaps[ri->dmapsref].largemap_2_tile = ((word)(value / 10000)); break; }
				default: 
				{
					Z_scripterrlog("Invalid index supplied to dmapdata->LargeMapTile[]: %d\n", indx);
					break;
				}
			}
			break;
		}
		case DMAPDATALARGEMAPCSET:	//word -- two of these, so let's to LargemaCSet[2]
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			switch(indx)
			{
				case 0: { DMaps[ri->dmapsref].largemap_1_cset= ((byte)(value / 10000)); break; }
				case 1: { DMaps[ri->dmapsref].largemap_2_cset= ((byte)(value / 10000)); break; }
				default: 
				{
					Z_scripterrlog("Invalid index supplied to dmapdata->LargeMapCSet[]: %d\n", indx);
					break;
				}
			}
			break;
		}
		case DMAPDATAMUISCTRACK:	//byte
		{
			DMaps[ri->dmapsref].tmusictrack= ((byte)(value / 10000)); break;
		}
		case DMAPDATASUBSCRA:
		{
			bool changed = DMaps[ri->dmapsref].active_subscreen != ((byte)(value / 10000));
			DMaps[ri->dmapsref].active_subscreen= ((byte)(value / 10000));
			if(changed&&ri->dmapsref==currdmap)
				update_subscreens();
			break;
		}
		case DMAPDATASUBSCRP:
		{
			bool changed = DMaps[ri->dmapsref].passive_subscreen != ((byte)(value / 10000));
			DMaps[ri->dmapsref].passive_subscreen= ((byte)(value / 10000));
			if(changed&&ri->dmapsref==currdmap)
				update_subscreens();
			break;
		}
		case DMAPDATASUBSCRO:
		{
			bool changed = DMaps[ri->dmapsref].overlay_subscreen != ((byte)(value / 10000));
			DMaps[ri->dmapsref].overlay_subscreen = ((byte)(value / 10000));
			if(changed&&ri->dmapsref==currdmap)
				update_subscreens();
			break;
		}
		case DMAPDATADISABLEDITEMS:	 //byte[MAXITEMS]
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if ( indx < 0 || indx > (MAXITEMS-1) ) 
			{
				Z_scripterrlog("Invalid index supplied to dmapdata->Grid[]: %d\n", indx); break;
			}
			else
			{
				DMaps[ri->dmapsref].disableditems[indx] = ((byte)(value / 10000)); break;
			}
		}
		
		case DMAPDATAFLAGARR:	 //int32_t
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if ( ((unsigned)indx) > 31 )
			{
				Z_scripterrlog("Invalid index supplied to dmapdata->Flags[]: %d\n", indx);
				break;
			}
			if ( value ) DMaps[ri->dmapsref].flags |= (1<<indx);
			else DMaps[ri->dmapsref].flags &= ~(1<<indx);
			break;
		}
		case DMAPDATAFLAGS:	 //int32_t
		{
			DMaps[ri->dmapsref].flags = (value / 10000); break;
		}
		case DMAPDATAMIRRDMAP:
		{
			DMaps[ri->dmapsref].mirrorDMap = vbound(value / 10000, -1, MAXDMAPS); break;
		}
		case DMAPDATALOOPSTART:
		{
			DMaps[ri->dmapsref].tmusic_loop_start = value; 
			if (ri->dmapsref == currdmap)
			{
				if (FFCore.doing_dmap_enh_music(currdmap))
				{
					zcmusic_set_loop(zcmusic, double(DMaps[currdmap].tmusic_loop_start / 10000.0), double(DMaps[currdmap].tmusic_loop_end / 10000.0));
				}
			}
			break;
		}
		case DMAPDATALOOPEND:
		{
			DMaps[ri->dmapsref].tmusic_loop_end = value;
			if (ri->dmapsref == currdmap)
			{
				if (FFCore.doing_dmap_enh_music(currdmap))
				{
					zcmusic_set_loop(zcmusic, double(DMaps[currdmap].tmusic_loop_start / 10000.0), double(DMaps[currdmap].tmusic_loop_end / 10000.0));
				}
			}
			break;
		}
		case DMAPDATAXFADEIN:
		{
			DMaps[ri->dmapsref].tmusic_xfade_in = (value / 10000);
			break;
		}
		case DMAPDATAXFADEOUT:
		{
			DMaps[ri->dmapsref].tmusic_xfade_out = (value / 10000);
			if (DMaps[currdmap].tmusic[0]!=0 && strcmp(DMaps[ri->dmapsref].tmusic, zcmusic->filename) == 0)
			{
				zcmusic->fadeoutframes = (value / 10000);
			}
			break;
		}
		case DMAPDATAINTROSTRINGID:
		{
			DMaps[ri->dmapsref].intro_string_id = (value / 10000);
			break;
		}
		case MUSICUPDATECOND:
		{
			FFCore.music_update_cond = vbound(value / 10000, 0, 255);
			break;
		}
		case MUSICUPDATEFLAGS:
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if (indx < 0 || indx > 1)
			{
				Z_scripterrlog("Invalid Index passed to Audio->MusicRefreshFlags[]: %d\n", indx);
				break;
			}
			SETFLAG(FFCore.music_update_flags, 1 << indx, value);
			break;
		}
		case DMAPDATAASUBSCRIPT:	//byte
		{
			DMaps[ri->dmapsref].active_sub_script = vbound((value / 10000),0,NUMSCRIPTSDMAP-1);
			on_reassign_script_engine_data(ScriptType::ScriptedActiveSubscreen, ri->dmapsref);
			break;
		}
		case DMAPDATAMAPSCRIPT:	//byte
		{
			DMaps[ri->dmapsref].onmap_script = vbound((value / 10000),0,NUMSCRIPTSDMAP-1);
			on_reassign_script_engine_data(ScriptType::OnMap, ri->dmapsref);
			break;
		}
		case DMAPDATAPSUBSCRIPT:	//byte
		{
			FFScript::deallocateAllScriptOwned(ScriptType::ScriptedPassiveSubscreen, ri->dmapsref);
			word val = vbound((value / 10000),0,NUMSCRIPTSDMAP-1);
			if (FFCore.doscript(ScriptType::ScriptedPassiveSubscreen) && ri->dmapsref == currdmap && val == DMaps[ri->dmapsref].passive_sub_script)
				break;
			DMaps[ri->dmapsref].passive_sub_script = val;
			if(ri->dmapsref == currdmap)
			{
				FFCore.doscript(ScriptType::ScriptedPassiveSubscreen) = val != 0;
			};
			break;
		}
		case DMAPDATASUBINITD:
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if ( indx < 0 || indx > 7 ) 
			{
				Z_scripterrlog("Invalid index supplied to dmapdata->SubInitD[]: %d\n", indx); break;
			}
			else
			{
				DMaps[ri->dmapsref].sub_initD[indx] = value; break;
			}
		}
		
		case DMAPDATAMAPINITD:
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if ( indx < 0 || indx > 7 ) 
			{
				Z_scripterrlog("Invalid index supplied to dmapdata->MapInitD[]: %d\n", indx); break;
			}
			else
			{
				DMaps[ri->dmapsref].onmap_initD[indx] = value; break;
			}
		}
		
		case DMAPDATACHARTED:
		{
			int32_t scr = ri->d[rINDEX] / 10000;
			if(ri->dmapsref >= MAXDMAPS)
			{
				Z_scripterrlog("Invalid DMap reference used for dmapdata->Charted[]: %d\n", ri->dmapsref);
			}
			// else if((DMaps[get_currdmap()].type&dmfTYPE) == dmOVERW)
			// {
				// Z_scripterrlog("dmapdata->Charted[] cannot presently be used on Overworld-type dmaps\n");
			// }
			else if(((unsigned)(scr)) > 127)
			{
				Z_scripterrlog("Invalid index supplied to dmapdata->Charted[]: %d\n", scr);
			}
			else 
			{
				int32_t col = (scr&15)-(DMaps[ri->dmapsref].type==dmOVERW ? 0 : DMaps[ri->dmapsref].xoff);
				if((DMaps[ri->dmapsref].type&dmfTYPE)!=dmOVERW ? (((unsigned)col) > 7) : (((unsigned)col) > 15))
					break; //Out-of-bounds; don't attempt write!
				int32_t di = (ri->dmapsref << 7) + (scr & 0x7F);
				game->bmaps[di] = (value/10000)&0x8F;
			}
			break;
		}
		//case DMAPDATAGRAVITY:	 //unimplemented
		//case DMAPDATAJUMPLAYER:	 //unimplemented

		///----------------------------------------------------------------------------------------------------//
		//messagedata msgd-> Variables
		 

		case MESSAGEDATANEXT: //W
		{
			int32_t ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Next") != SH::_NoError)
				break;
			else 
				MsgStrings[ID].nextstring = vbound((value/10000), 0, (msg_count-1));
			break;
		}	

		case MESSAGEDATATILE: //W
		{
			int32_t ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Tile") != SH::_NoError)
				break;
			else 
				MsgStrings[ID].tile = vbound((value/10000), 0, (NEWMAXTILES));
			break;
		}	

		case MESSAGEDATACSET: //b
		{
			int32_t ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->CSet") != SH::_NoError)
				break;
			else 
				MsgStrings[ID].cset = ((byte)vbound((value/10000), 0, 15));
			break;
		}	
		case MESSAGEDATATRANS: //BOOL
		{
			int32_t ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Transparent") != SH::_NoError)
				break;
			else 
				(MsgStrings[ID].trans) = ((value)?true:false);
			break;
		}	
		case MESSAGEDATAFONT: //B
		{
			int32_t ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Font") != SH::_NoError)
				break;
			else 
				MsgStrings[ID].font = ((byte)vbound((value/10000), 0, 255));
			break;
		}	
		case MESSAGEDATAX: //SHORT
		{
			int32_t ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->X") != SH::_NoError)
				break;
			else 
				MsgStrings[ID].x = ((int16_t)vbound((value/10000), SHRT_MIN, SHRT_MAX));
			break;
		}	
		case MESSAGEDATAY: //SHORT
		{
			int32_t ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Y") != SH::_NoError)
				break;
			else 
				MsgStrings[ID].y = ((int16_t)vbound((value/10000), SHRT_MIN, SHRT_MAX));
			break;
		}	
		case MESSAGEDATAW: //UNSIGNED SHORT
		{
			int32_t ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Width") != SH::_NoError)
				break;
			else 
				MsgStrings[ID].w = ((uint16_t)vbound((value/10000), 0, USHRT_MAX));
			break;
		}	
		case MESSAGEDATAH: //UNSIGNED SHORT
		{
			int32_t ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Height") != SH::_NoError)
				break;
			else 
				MsgStrings[ID].h = ((uint16_t)vbound((value/10000), 0, USHRT_MAX));
			break;
		}	
		case MESSAGEDATASFX: //BYTE
		{
			int32_t ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Sound") != SH::_NoError)
				break;
			else 
				MsgStrings[ID].sfx = ((byte)vbound((value/10000), 0, 255));
			break;
		}	
		case MESSAGEDATALISTPOS: //WORD
		{
			int32_t ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->ListPosition") != SH::_NoError)
				break;
			else 
				MsgStrings[ID].listpos = vbound((value/10000), 1, (msg_count-1));
			break;
		}	
		case MESSAGEDATAVSPACE: //BYTE
		{
			int32_t ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->VSpace") != SH::_NoError)
				break;
			else 
				MsgStrings[ID].vspace = ((byte)vbound((value/10000), 0, 255));
			break;
		}	
		case MESSAGEDATAHSPACE: //BYTE
		{
			int32_t ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->HSpace") != SH::_NoError)
				break;
			else 
				MsgStrings[ID].hspace = ((byte)vbound((value/10000), 0, 255));
			break;
		}	
		case MESSAGEDATAFLAGS: //BYTE
		{
			int32_t ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Flags") != SH::_NoError)
				break;
			else 
				MsgStrings[ID].stringflags = ((byte)vbound((value/10000), 0, 255));
			break;
		}
		case MESSAGEDATAMARGINS: //BYTE, 4
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if ( indx < 0 || indx > 3 ) 
			{
				Z_scripterrlog("Invalid index supplied to messagedata->Margins[]: %d\n", indx);
				break;
			}
			int32_t ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->Margins[]") != SH::_NoError)
				break;
			else
				MsgStrings[ID].margins[indx] = ((byte)vbound((value/10000), 0, 255));
			break;
		}
		case MESSAGEDATAPORTTILE: //INT
		{
			int32_t ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->PortraitTile") != SH::_NoError)
				break;
			else
				MsgStrings[ID].portrait_tile = vbound((value/10000), 0, (NEWMAXTILES));
			break;
		}
		case MESSAGEDATAPORTCSET: //BYTE
		{
			int32_t ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->PortraitCSet") != SH::_NoError)
				break;
			else
				MsgStrings[ID].portrait_cset = ((byte)vbound((value/10000), 0, 15));
			break;
		}
		case MESSAGEDATAPORTX: //BYTE
		{
			int32_t ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->PortraitX") != SH::_NoError)
				break;
			else
				MsgStrings[ID].portrait_x = ((byte)vbound((value/10000), 0, 255));
			break;
		}
		case MESSAGEDATAPORTY: //BYTE
		{
			int32_t ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->PortraitY") != SH::_NoError)
				break;
			else
				MsgStrings[ID].portrait_y = ((byte)vbound((value/10000), 0, 255));
			break;
		}
		case MESSAGEDATAPORTWID: //BYTE
		{
			int32_t ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->PortraitTileWidth") != SH::_NoError)
				break;
			else
				MsgStrings[ID].portrait_tw = ((byte)vbound((value/10000), 0, 16));
			break;
		}
		case MESSAGEDATAPORTHEI: //BYTE
		{
			int32_t ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->PortraitTileHeight") != SH::_NoError)
				break;
			else
				MsgStrings[ID].portrait_th = ((byte)vbound((value/10000), 0, 14));
			break;
		}
		case MESSAGEDATAFLAGSARR: //BOOL, 7
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			int32_t ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->Flags[]") != SH::_NoError)
				break;
			else
			{
				switch(indx)
				{
					case 0:
						(value) ? (MsgStrings[ID].stringflags)|=STRINGFLAG_WRAP : (MsgStrings[ID].stringflags)&= ~STRINGFLAG_WRAP;
						break;
					case 1:
						(value) ? (MsgStrings[ID].stringflags)|=STRINGFLAG_CONT : (MsgStrings[ID].stringflags)&= ~STRINGFLAG_CONT;
						break;
					case 2: //Not implemented
						//(value) ? (MsgStrings[ID].stringflags)|=STRINGFLAG_CENTER : (MsgStrings[ID].stringflags)&= ~STRINGFLAG_CENTER;
						break;
					case 3: //Not implemented
						//(value) ? (MsgStrings[ID].stringflags)|=STRINGFLAG_RIGHT : (MsgStrings[ID].stringflags)&= ~STRINGFLAG_RIGHT;
						break;
					case 4:
						(value) ? (MsgStrings[ID].stringflags)|=STRINGFLAG_FULLTILE : (MsgStrings[ID].stringflags)&= ~STRINGFLAG_FULLTILE;
						break;
					case 5:
						(value) ? (MsgStrings[ID].stringflags)|=STRINGFLAG_TRANS_BG : (MsgStrings[ID].stringflags)&= ~STRINGFLAG_TRANS_BG;
						break;
					case 6:
						(value) ? (MsgStrings[ID].stringflags)|=STRINGFLAG_TRANS_FG : (MsgStrings[ID].stringflags)&= ~STRINGFLAG_TRANS_FG;
						break;
					default:
						Z_scripterrlog("Invalid index supplied to messagedata->Flags[]: %d\n", indx);
						break;
				}
			}
			break;
		}




	///----------------------------------------------------------------------------------------------------//
	//combodata cd-> Setter Variables
	//newcombo	
		#define	SET_COMBO_VAR_INT(member, str) \
		{ \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
			} \
			else \
			{ \
				combobuf[ri->combosref].member = vbound((value / 10000),0,214747); \
			} \
		} \
		
		#define	SET_COMBO_VAR_DWORD(member, str) \
		{ \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
			} \
			else \
			{ \
				combobuf[ri->combosref].member = vbound((value / 10000),0,32767); \
			} \
		} \

		#define	SET_COMBO_VAR_BYTE(member, str) \
		{ \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
			} \
			else \
			{ \
				combobuf[ri->combosref].member = vbound((value / 10000),0,255); \
			} \
		} \
		
		#define SET_COMBO_VAR_INDEX(member, str, indexbound) \
		{ \
				int32_t indx = ri->d[rINDEX] / 10000; \
				if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
				{ \
					Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
				} \
				else if ( indx < 0 || indx >= indexbound ) \
				{ \
					Z_scripterrlog("Invalid Array Index passed to combodata->%s: %d\n", indx, str); \
				} \
				else \
				{ \
					combobuf[ri->combosref].member[indx] = vbound((value / 10000),0,214747); \
				} \
		}
		
		#define SET_COMBO_VAR_INDEX2(member, str, indexbound, low, high) \
		{ \
				int32_t indx = ri->d[rINDEX] / 10000; \
				if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
				{ \
					Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
				} \
				else if ( indx < 0 || indx >= indexbound ) \
				{ \
					Z_scripterrlog("Invalid Array Index passed to combodata->%s: %d\n", indx, str); \
				} \
				else \
				{ \
					combobuf[ri->combosref].member[indx] = vbound((value / 10000),low,high); \
				} \
		}

		#define SET_COMBO_BYTE_INDEX(member, str, indexbound) \
		{ \
				int32_t indx = ri->d[rINDEX] / 10000; \
				if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
				{ \
					Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
				} \
				else if ( indx < 0 || indx >= indexbound ) \
				{ \
					Z_scripterrlog("Invalid Array Index passed to combodata->%s: %d\n", indx, str); \
				} \
				else \
				{ \
					combobuf[ri->combosref].member[indx] = vbound((value / 10000),0,255); \
				} \
		}
		
		#define SET_COMBO_FLAG(member, str) \
		{ \
			int32_t flag =  (value/10000);  \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
			} \
			else \
			{ \
				if ( flag != 0 ) \
				{ \
					combobuf[ri->combosref].member|=flag; \
				} \
				else combobuf[ri->combosref].member|= ~flag; \
			} \
		} \
		
		//comboclass
		#define	SET_COMBOCLASS_VAR_INT(member, str) \
		{ \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
			} \
			else \
			{ \
				combo_class_buf[combobuf[ri->combosref].type].member = vbound((value / 10000),0,214747); \
			} \
		} \
		
		#define	SET_COMBOCLASS_VAR_DWORD(member, str) \
		{ \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
			} \
			else \
			{ \
				combo_class_buf[combobuf[ri->combosref].type].member = vbound((value / 10000),0,32767); \
			} \
		} \

		#define	SET_COMBOCLASS_VAR_BYTE(member, str) \
		{ \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
			} \
			else \
			{ \
				combo_class_buf[combobuf[ri->combosref].type].member = vbound((value / 10000),0,255); \
			} \
		} \
		
		#define SET_COMBOCLASS_VAR_INDEX(member, str, indexbound) \
		{ \
				int32_t indx = ri->d[rINDEX] / 10000; \
				if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
				{ \
					Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
				} \
				else if ( indx < 0 || indx > indexbound ) \
				{ \
					Z_scripterrlog("Invalid Array Index passed to combodata->%s: %d\n", indx, str); \
				} \
				else \
				{ \
					combo_class_buf[combobuf[ri->combosref].type].member[indx] = vbound((value / 10000),0,214747); \
				} \
		}

		#define SET_COMBOCLASS_BYTE_INDEX(member, str, indexbound) \
		{ \
				int32_t indx = ri->d[rINDEX] / 10000; \
				if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
				{ \
					Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
				} \
				else if ( indx < 0 || indx > indexbound ) \
				{ \
					Z_scripterrlog("Invalid Array Index passed to combodata->%s: %d\n", indx, str); \
				} \
				else \
				{ \
					combo_class_buf[combobuf[ri->combosref].type].member[indx] = vbound((value / 10000),0,255); \
				} \
		}
		
		#define SET_COMBOCLASS_FLAG(member, str) \
		{ \
			int32_t flag =  (value/10000);  \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
			} \
			else \
			{ \
				if ( flag != 0 ) \
				{ \
					combo_class_buf[combobuf[ri->combosref].type].member|=flag; \
				} \
				else combo_class_buf[combobuf[ri->combosref].type].member|= ~flag; \
			} \
		} \
		
		//NEWCOMBO STRUCT
		case COMBODTILE:	SET_COMBO_VAR_INT(tile, "Tile"); break;						//word
		case COMBODOTILE:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "OriginalTile");
			}
			else
			{
				newcombo& cdata = combobuf[ri->combosref];
				cdata.o_tile = vbound((value / 10000),0,NEWMAXTILES);
				if(get_qr(qr_NEW_COMBO_ANIMATION))
				{
					cdata.tile = cdata.o_tile + ((1+cdata.skipanim)*cdata.cur_frame);
					if(int32_t rowoffset = TILEROW(cdata.tile)-TILEROW(cdata.o_tile))
					{
						cdata.tile += cdata.skipanimy * rowoffset * TILES_PER_ROW;
					}
				}
			}
			break;
		}
		case COMBODFRAME:		SET_COMBO_VAR_BYTE(cur_frame, "Frame"); break;				//char
		case COMBODACLK:		SET_COMBO_VAR_BYTE(aclk, "AClk"); break;				//char
		case COMBODATASCRIPT:	SET_COMBO_VAR_DWORD(script, "Script"); break;						//word
		case COMBODASPEED:	SET_COMBO_VAR_BYTE(speed, "ASpeed"); break;						//char
		case COMBODFLIP:	SET_COMBO_VAR_BYTE(flip, "Flip"); break;						//char
		case COMBODWALK:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "Walk");
			}
			else
			{
				combobuf[ri->combosref].walk &= ~0x0F;
				combobuf[ri->combosref].walk |= (value / 10000)&0x0F;
			}
			break;
		}
		case COMBODEFFECT:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "Effect");
			}
			else
			{
				combobuf[ri->combosref].walk &= ~0xF0;
				combobuf[ri->combosref].walk |= ((value / 10000)&0x0F)<<4;
			}
			break;
		}
		case COMBODTYPE:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->Type: %d\n", (ri->combosref*10000));
			}
			else
			{
				screen_combo_modify_pre(ri->combosref);
				combobuf[ri->combosref].type = vbound((value / 10000),0,255);
				screen_combo_modify_post(ri->combosref);
			}
			break;
		}
		case COMBODCSET:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "CSet2");
			}
			else
			{
				int8_t v = vbound(value, -8, 7);
				combobuf[ri->combosref].csets &= ~0xF;
				combobuf[ri->combosref].csets |= v;
			}
			break;
		}
		case COMBODCSET2FLAGS:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "CSet2Flags");
			}
			else
			{
				combobuf[ri->combosref].csets &= 0xF;
				combobuf[ri->combosref].csets |= (value&0xF)<<4;
			}
			break;
		}
		case COMBODFOO:		break;							//W
		case COMBODFRAMES:	SET_COMBO_VAR_BYTE(frames, "Frames"); break;						//C
		case COMBODNEXTD:	SET_COMBO_VAR_DWORD(speed, "NextData"); break;						//W
		case COMBODNEXTC:	SET_COMBO_VAR_BYTE(nextcombo, "NextCSet"); break;					//C
		case COMBODFLAG:	SET_COMBO_VAR_BYTE(nextcset, "Flag"); break;						//C
		case COMBODSKIPANIM:	SET_COMBO_VAR_BYTE(skipanim, "SkipAnim"); break;					//C
		case COMBODNEXTTIMER:	SET_COMBO_VAR_DWORD(nexttimer, "NextTimer"); break;					//W
		case COMBODAKIMANIMY:	SET_COMBO_VAR_BYTE(skipanimy, "SkipAnimY"); break;					//C
		case COMBODANIMFLAGS:	SET_COMBO_VAR_BYTE(animflags, "AnimFlags"); break;					//C
		case COMBODEXPANSION:	SET_COMBO_BYTE_INDEX(expansion, "Expansion[]", 6); break;					//C , 6 INDICES
		case COMBODATTRIBUTES:
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "Attributes[]");
			}
			else if ( indx < 0 || indx > 4 )
			{
				Z_scripterrlog("Invalid Array Index passed to combodata->%s: %d\n", indx, "Attributes[]");
			}
			else
			{
				combobuf[ri->combosref].attributes[indx] = value;
			}
		}break;
		//case COMBODATAINITD: 	SET_COMBO_VAR_INDEX(initd,	"InitD[]", 2); break;				//LONG, 4 INDICES, INDIVIDUAL VALUES
		case COMBODATAINITD:
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "InitD[]");
			}
			else if ( ((unsigned)indx) > 8 )
			{ 
				Z_scripterrlog("Invalid Array Index passed to combodata->%s: %d\n", indx, "InitD[]"); 
			} 
			else 
			{ 
				combobuf[ri->combosref].initd[indx] = (value * ( get_qr(qr_COMBODATA_INITD_MULT_TENK) ? 10000 : 1)); 
			} 
			break;
		}
		
		
		case COMBODATTRIBYTES: 	SET_COMBO_VAR_INDEX(attribytes,	"Attribytes[]", 8); break;				//LONG, 4 INDICES, INDIVIDUAL VALUES
		case COMBODATTRISHORTS: 	SET_COMBO_VAR_INDEX2(attrishorts,	"Attrishorts[]", 8, -32768, 32767); break;				//LONG, 4 INDICES, INDIVIDUAL VALUES
		case COMBODUSRFLAGARR:
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if (ri->combosref < 0 || ri->combosref >(MAXCOMBOS - 1))
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", "Flags[]", (ri->combosref * 10000));
			}
			else if (((unsigned)indx) > 15)
			{
				Z_scripterrlog("Invalid Array Index passed to combodata->%s: %d\n", "Flags[]", indx);
			}
			else
			{
				SETFLAG(combobuf[ri->combosref].usrflags, 1 << indx, value);
			}
			break;
		}
		case COMBODGENFLAGARR:
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if (ri->combosref < 0 || ri->combosref >(MAXCOMBOS - 1))
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", "GenFlags[]", (ri->combosref * 10000));
			}
			else if (((unsigned)indx) > 0)
			{
				Z_scripterrlog("Invalid Array Index passed to combodata->%s: %d\n", "GenFlags[]", indx);
			}
			else
			{
				SETFLAG(combobuf[ri->combosref].genflags, 1 << indx, value);
			}
			break;
		}
		case COMBODUSRFLAGS:	SET_COMBO_VAR_INT(usrflags, "UserFlags"); break;					//LONG
		case COMBODTRIGGERFLAGS:	SET_COMBO_VAR_INDEX(triggerflags, "TriggerFlags[]", 6);	break;			//LONG 3 INDICES AS FLAGSETS
		case COMBODTRIGGERFLAGS2:
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "TrigFlags[]");
			}
			else if ( unsigned(indx) >= 32*6 )
			{
				Z_scripterrlog("Invalid Array Index passed to combodata->%s: %d\n", indx, "TrigFlags[]");
			}
			else
			{
				SETFLAG(combobuf[ri->combosref].triggerflags[indx/32],1<<(indx%32),value);
			}
			break;
		}
		case COMBODTRIGGERBUTTON:
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "TriggerButton[]");
			}
			else if ( unsigned(indx) >= 8 )
			{
				Z_scripterrlog("Invalid Array Index passed to combodata->%s: %d\n", indx, "TriggerButton[]");
			}
			else
			{
				SETFLAG(combobuf[ri->combosref].triggerbtn,1<<indx,value);
			}
			break;
		}
		case COMBODTRIGGERITEM:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalueid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "TriggerItem");
			}
			else combobuf[ri->combosref].triggeritem = vbound(value/10000,0,255);
			break;
		}
		case COMBODTRIGGERTIMER:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalueid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "TriggerTimer");
			}
			else combobuf[ri->combosref].trigtimer = vbound(value/10000,0,255);
			break;
		}
		case COMBODTRIGGERSFX:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalueid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "TriggerSFX");
			}
			else combobuf[ri->combosref].trigsfx = vbound(value/10000,0,255);
			break;
		}
		case COMBODTRIGGERCHANGECMB:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalueid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "TriggerChange");
			}
			else combobuf[ri->combosref].trigchange = vbound(value/10000,-65535,65535);
			break;
		}
		case COMBODTRIGGERPROX:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "TriggerProximity");
			}
			else combobuf[ri->combosref].trigprox = vbound(value/10000,0,65535);
			break;
		}
		case COMBODTRIGGERLIGHTBEAM:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "TriggerLightBeam");
			}
			else combobuf[ri->combosref].triglbeam = vbound(value/10000,0,32);
			break;
		}
		case COMBODTRIGGERCTR:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "TriggerCounter");
			}
			else combobuf[ri->combosref].trigctr = vbound(value/10000, 0, MAX_COUNTERS-1);
			break;
		}
		case COMBODTRIGGERCTRAMNT:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), "TriggerCtrAmount");
			}
			else combobuf[ri->combosref].trigctramnt = vbound(value/10000, -65535, 65535);
			break;
		}
		
		case COMBODTRIGGERCOOLDOWN:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TriggerCooldown: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].trigcooldown = vbound(value/10000, 0, 255);
			break;
		}
		case COMBODTRIGGERCOPYCAT:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TriggerCopycat: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].trigcopycat = vbound(value/10000, 0, 255);
			break;
		}
		case COMBODTRIGITEMPICKUP:
		{
			const int32_t allowed_pflags = ipHOLDUP | ipTIMER | ipSECRETS | ipCANGRAB;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TriggerSpawnItemPickup: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].spawnip = (value/10000)&allowed_pflags;
			break;
		}
		case COMBODTRIGEXSTATE:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigExState: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].exstate = vbound(value/10000, -1, 31);
			break;
		}
		case COMBODTRIGEXDOORDIR:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigExDoorDir: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].exdoor_dir = vbound(value/10000, -1, 3);
			break;
		}
		case COMBODTRIGEXDOORIND:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigExDoorIndex: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].exdoor_ind = vbound(value/10000, 0, 7);
			break;
		}
		case COMBODTRIGSPAWNENEMY:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigSpawnEnemy: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].spawnenemy = vbound(value/10000, 0, 511);
			break;
		}
		case COMBODTRIGSPAWNITEM:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigSpawnItem: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].spawnitem = vbound(value/10000, -255, 255);
			break;
		}
		case COMBODTRIGCSETCHANGE:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigCSetChange: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].trigcschange = vbound(value/10000, -15, 15);
			break;
		}
		case COMBODTRIGLITEMS:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigLItems: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].trig_levelitems = (value/10000)&liALL;
			break;
		}
		case COMBODTRIGDMAPLVL:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigDMapLvl: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].trigdmlevel = vbound(value/10000, -1, MAXDMAPS-1);
			break;
		}
		case COMBODTRIGTINTR:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigTintR: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].trigtint[0] = vbound(value/10000, -63, 63);
			break;
		}
		case COMBODTRIGTINTG:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigTintG: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].trigtint[1] = vbound(value/10000, -63, 63);
			break;
		}
		case COMBODTRIGTINTB:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigTintB: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].trigtint[2] = vbound(value/10000, -63, 63);
			break;
		}
		case COMBODTRIGLVLPAL:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigLvlPal: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].triglvlpalette = vbound(value/10000, -1, 512);
			break;
		}
		case COMBODTRIGBOSSPAL:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigBossPal: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].trigbosspalette = vbound(value/10000, -1, 29);
			break;
		}
		case COMBODTRIGQUAKETIME:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigQuakeTimer: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].trigquaketime = zc_max(value/10000, -1);
			break;
		}
		case COMBODTRIGWAVYTIME:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigWavyTimer: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].trigwavytime = zc_max(value/10000, -1);
			break;
		}
		case COMBODTRIGSWORDJINX:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigSwordJinx: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].trig_swjinxtime = zc_max(value/10000, -2);
			break;
		}
		case COMBODTRIGITEMJINX:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigItemJinx: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].trig_itmjinxtime = zc_max(value/10000, -2);
			break;
		}
		case COMBODTRIGSTUN:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigStun: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].trig_bunnytime = zc_max(value/10000, -2);
			break;
		}
		case COMBODTRIGBUNNY:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigBunny: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].trig_bunnytime = zc_max(value/10000, -2);
			break;
		}
		case COMBODTRIGPUSHTIME:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigPushTime: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].trig_pushtime = vbound(value/10000, 0, 255);
			break;
		}
		case COMBODLIFTGFXCOMBO:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftGFXCombo: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].liftcmb = vbound(value/10000, 0, MAXCOMBOS);
			break;
		}
		case COMBODLIFTGFXCCSET:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftGFXCSet: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].liftcs = vbound(value/10000, 0, 13);
			break;
		}
		case COMBODLIFTUNDERCMB:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftUnderCombo: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].liftundercmb = vbound(value/10000, 0, MAXCOMBOS);
			break;
		}
		case COMBODLIFTUNDERCS:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftUnderCSet: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].liftundercs = vbound(value/10000, 0, 13);
			break;
		}
		case COMBODLIFTDAMAGE:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftDamage: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].liftdmg = vbound(value/10000, 0, 255);
			break;
		}
		case COMBODLIFTLEVEL:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftLevel: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].liftlvl = vbound(value/10000, 0, 255);
			break;
		}
		case COMBODLIFTITEM:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftItem: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].liftitm = vbound(value/10000, 0, 255);
			break;
		}
		case COMBODLIFTFLAGS:
		{
			int32_t indx = ri->d[rINDEX] / 10000;
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftFlags[]: %d\n", (ri->combosref*10000));
				break;
			}
			if ( unsigned(indx) > 7 ) 
			{
				Z_scripterrlog("Invalid index supplied to combodata->LiftFlags[]: %d\n", indx);
				break;
			}
			SETFLAG(combobuf[ri->combosref].liftflags, (1<<indx), value);
			break;
		}
		case COMBODLIFTGFXTYPE:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftGFXType: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].liftgfx = vbound(value/10000, 0, 2);
			break;
		}
		case COMBODLIFTGFXSPRITE:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftGFXSprite: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].liftsprite = vbound(value/10000, 0, 255);
			break;
		}
		case COMBODLIFTSFX:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftSFX: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].liftsfx = vbound(value/10000, 0, 255);
			break;
		}
		case COMBODLIFTBREAKSPRITE:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftBreakSprite: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].liftbreaksprite = vbound(value/10000, -4, 255);
			break;
		}
		case COMBODLIFTBREAKSFX:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftBreakSFX: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].liftbreaksfx = vbound(value/10000, 0, 255);
			break;
		}
		case COMBODLIFTHEIGHT:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftHeight: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].lifthei = vbound(value/10000, 0, 255);
			break;
		}
		case COMBODLIFTTIME:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftTime: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].lifttime = vbound(value/10000, 0, 255);
			break;
		}
		case COMBODLIFTWEAPONITEM:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->LiftWeaponItem: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].lift_parent_item = vbound(value/10000, 0, 255);
			break;
		}
		case COMBODTRIGGERLSTATE:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigLevelState: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].trig_lstate = vbound(value/10000, 0, 31);
			break;
		}
		case COMBODTRIGGERGSTATE:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigGlobalState: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].trig_gstate = vbound(value/10000, 0, 255);
			break;
		}
		case COMBODTRIGGERGROUP:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigGroup: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].trig_group = vbound(value/10000, 0, 255);
			break;
		}
		case COMBODTRIGGERGROUPVAL:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigGroupVal: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].trig_group_val = vbound(value/10000, 0, 65535);
			break;
		}
		case COMBODTRIGGERGTIMER:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigGStateTimer: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].trig_statetime = vbound(value/10000, 0, 214748);
			break;
		}
		case COMBODTRIGGERGENSCRIPT:
		{
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) )
			{
				Z_scripterrlog("Invalid Combo ID passed to combodata->TrigGenScript: %d\n", (ri->combosref*10000));
			}
			else combobuf[ri->combosref].trig_genscr = vbound(value/10000, 0, 65535);
			break;
		}
		case COMBODTRIGGERLEVEL:	SET_COMBO_VAR_INT(triggerlevel, "TriggerLevel"); break;				//LONG
	
	
		


		//COMBOCLASS STRUCT
		//case COMBODNAME:		//CHAR[64], STRING
		case COMBODBLOCKNPC:		SET_COMBOCLASS_VAR_BYTE(block_enemies, "BlockNPC"); break;			//C
		case COMBODBLOCKHOLE:		SET_COMBOCLASS_VAR_BYTE(block_hole, "BlockHole"); break;			//C
		case COMBODBLOCKTRIG:		SET_COMBOCLASS_VAR_BYTE(block_trigger,	"BlockTrigger"); break; 		//C
		case COMBODBLOCKWEAPON:		SET_COMBOCLASS_BYTE_INDEX(block_weapon, "BlockWeapon[]", 32); break;			//C, 32 INDICES
		case COMBODCONVXSPEED:		SET_COMBOCLASS_VAR_DWORD(conveyor_x_speed, "ConveyorSpeedX"); break;		//SHORT
		case COMBODCONVYSPEED:		SET_COMBOCLASS_VAR_DWORD(conveyor_y_speed, "ConveyorSpeedY"); break;		//SHORT
		case COMBODSPAWNNPC:		SET_COMBOCLASS_VAR_DWORD(create_enemy, "SpawnNPC"); break;			//W
		case COMBODSPAWNNPCWHEN:	SET_COMBOCLASS_VAR_BYTE(create_enemy_when, "SpawnNPCWhen"); break;		//C
		case COMBODSPAWNNPCCHANGE:	SET_COMBOCLASS_VAR_INT(create_enemy_change, "SpawnNPCChange"); break;		//LONG
		case COMBODDIRCHANGETYPE:	SET_COMBOCLASS_VAR_BYTE(directional_change_type, "DirChange"); break;		//C
		case COMBODDISTANCECHANGETILES:	SET_COMBOCLASS_VAR_INT(distance_change_tiles, "DistanceChangeTiles"); break; 	//LONG
		case COMBODDIVEITEM:		SET_COMBOCLASS_VAR_DWORD(dive_item, "DiveItem"); break;				//SHORT
		case COMBODDOCK:		SET_COMBOCLASS_VAR_BYTE(dock, "Dock"); break;					//C
		case COMBODFAIRY:		SET_COMBOCLASS_VAR_BYTE(fairy, "Fairy"); break;					//C
		case COMBODFFATTRCHANGE:	SET_COMBOCLASS_VAR_BYTE(ff_combo_attr_change, "FFCAttributeChange"); break;	//C
		case COMBODFOORDECOTILE:	SET_COMBOCLASS_VAR_INT(foot_decorations_tile, "DecorationTile"); break;		//LONG
		case COMBODFOORDECOTYPE:	SET_COMBOCLASS_VAR_BYTE(foot_decorations_type, "DecorationType"); break;	//C
		case COMBODHOOKSHOTPOINT:	SET_COMBOCLASS_VAR_BYTE(hookshot_grab_point, "Hookshot"); break;		//C
		case COMBODLADDERPASS:		SET_COMBOCLASS_VAR_BYTE(ladder_pass, "Ladder"); break;				//C
		case COMBODLOCKBLOCK:		SET_COMBOCLASS_VAR_BYTE(lock_block_type, "LockBlock"); break;			//C
		case COMBODLOCKBLOCKCHANGE:	SET_COMBOCLASS_VAR_INT(lock_block_change, "LockBlockChange"); break;		//LONG
		case COMBODMAGICMIRROR:		SET_COMBOCLASS_VAR_BYTE(magic_mirror_type, "Mirror"); break;			//C
		case COMBODMODHPAMOUNT:		SET_COMBOCLASS_VAR_DWORD(modify_hp_amount, "DamageAmount"); break;		//SHORT
		case COMBODMODHPDELAY:		SET_COMBOCLASS_VAR_BYTE(modify_hp_delay, "DamageDelay"); break;			//C
		case COMBODMODHPTYPE:		SET_COMBOCLASS_VAR_BYTE(modify_hp_type,	"DamageType"); break; 			//C
		case COMBODNMODMPAMOUNT:	SET_COMBOCLASS_VAR_DWORD(modify_mp_amount, "MagicAmount"); break;		//SHORT
		case COMBODMODMPDELAY:		SET_COMBOCLASS_VAR_BYTE(modify_mp_delay, "MagicDelay"); break;			//C
		case COMBODMODMPTYPE:		SET_COMBOCLASS_VAR_BYTE(modify_mp_type,	"MagicType"); break;				//C
		case COMBODNOPUSHBLOCK:		SET_COMBOCLASS_VAR_BYTE(no_push_blocks, "NoPushBlocks"); break;			//C
		case COMBODOVERHEAD:		SET_COMBOCLASS_VAR_BYTE(overhead, "Overhead"); break;				//C
		case COMBODPLACENPC:		SET_COMBOCLASS_VAR_BYTE(place_enemy, "PlaceNPC"); break;			//C
		case COMBODPUSHDIR:		SET_COMBOCLASS_VAR_BYTE(push_direction,	"PushDir"); break; 			//C
		case COMBODPUSHWAIT:		SET_COMBOCLASS_VAR_BYTE(push_wait, "PushDelay"); break;				//C
		case COMBODPUSHHEAVY:		SET_COMBOCLASS_VAR_BYTE(push_weight, "PushHeavy"); break;				//C
		case COMBODPUSHED:		SET_COMBOCLASS_VAR_BYTE(pushed, "Pushed"); break;				//C
		case COMBODRAFT:		SET_COMBOCLASS_VAR_BYTE(raft, "Raft"); break;					//C
		case COMBODRESETROOM:		SET_COMBOCLASS_VAR_BYTE(reset_room, "ResetRoom"); break;			//C
		case COMBODSAVEPOINTTYPE:	SET_COMBOCLASS_VAR_BYTE(save_point_type, "SavePoint"); break;			//C
		case COMBODSCREENFREEZETYPE:	SET_COMBOCLASS_VAR_BYTE(screen_freeze_type, "FreezeScreen"); break;		//C
		case COMBODSECRETCOMBO:		SET_COMBOCLASS_VAR_BYTE(secret_combo, "SecretCombo"); break;			//C
		case COMBODSINGULAR:		SET_COMBOCLASS_VAR_BYTE(singular, "Singular"); break;				//C
		case COMBODSLOWWALK:		SET_COMBOCLASS_VAR_BYTE(slow_movement, "SlowWalk"); break;			//C
		case COMBODSTATUETYPE:		SET_COMBOCLASS_VAR_BYTE(statue_type, "Statue"); break;				//C
		case COMBODSTEPTYPE:		SET_COMBOCLASS_VAR_BYTE(step_type, "Step"); break;				//C
		case COMBODSTEPCHANGEINTO:	SET_COMBOCLASS_VAR_INT(step_change_to, "StepChange"); break;			//LONG
		case COMBODSTRIKEWEAPONS:	SET_COMBOCLASS_BYTE_INDEX(strike_weapons, "Strike[]", 32); break;			//BYTE, 32 INDICES. 
		case COMBODSTRIKEREMNANTS:	SET_COMBOCLASS_VAR_INT(strike_remnants,	"StrikeRemnants"); break;		//LONG
		case COMBODSTRIKEREMNANTSTYPE:	SET_COMBOCLASS_VAR_BYTE(strike_remnants_type, "StrikeRemnantsType"); break;	//C
		case COMBODSTRIKECHANGE:	SET_COMBOCLASS_VAR_INT(strike_change, "StrikeChange"); break;			//LONG
		case COMBODSTRIKEITEM:		SET_COMBOCLASS_VAR_DWORD(strike_item, "StrikeItem"); break;			//SHORT
		case COMBODTOUCHITEM:		SET_COMBOCLASS_VAR_DWORD(touch_item, "TouchItem"); break;			//SHORT
		case COMBODTOUCHSTAIRS:		SET_COMBOCLASS_VAR_BYTE(touch_stairs, "TouchStairs"); break;			//C
		case COMBODTRIGGERTYPE:		SET_COMBOCLASS_VAR_BYTE(trigger_type, "TriggerType"); break;			//C
		case COMBODTRIGGERSENS:		SET_COMBOCLASS_VAR_BYTE(trigger_sensitive, "TriggerSensitivity"); break;	//C
		case COMBODWARPTYPE:		SET_COMBOCLASS_VAR_BYTE(warp_type, "Warp"); break;				//C
		case COMBODWARPSENS:		SET_COMBOCLASS_VAR_BYTE(warp_sensitive,	"WarpSensitivity"); break; 		//C
		case COMBODWARPDIRECT:		SET_COMBOCLASS_VAR_BYTE(warp_direct, "WarpDirect"); break;			//C
		case COMBODWARPLOCATION:	SET_COMBOCLASS_VAR_BYTE(warp_location, "WarpLocation"); break;			//C
		case COMBODWATER:		SET_COMBOCLASS_VAR_BYTE(water, "Liquid"); break;					//C
		case COMBODWHISTLE:		SET_COMBOCLASS_VAR_BYTE(whistle, "Whistle"); break;				//C
		case COMBODWINGAME:		SET_COMBOCLASS_VAR_BYTE(win_game, "WinGame"); break; 				//C
		case COMBODBLOCKWPNLEVEL:	SET_COMBOCLASS_VAR_BYTE(block_weapon_lvl, "BlockWeaponLevel"); break;		//C



	///----------------------------------------------------------------------------------------------------//
	//npcdata nd-> Variables
		
		#define	SET_NPCDATA_VAR_INT(member, str) \
		{ \
			if( (unsigned) ri->npcdataref > (MAXNPCS-1) ) \
			{ \
				Z_scripterrlog("Invalid NPC ID passed to npcdata->%s: %d\n", (ri->npcdataref*10000), str); \
			} \
			else \
			{ \
				guysbuf[ri->npcdataref].member = vbound((value / 10000),0,214747); \
			} \
		} \
		
		#define	SET_NPCDATA_VAR_DWORD(member, str) \
		{ \
			if( (unsigned) ri->npcdataref > (MAXNPCS-1) ) \
			{ \
				Z_scripterrlog("Invalid NPC ID passed to npcdata->%s: %d\n", (ri->npcdataref*10000), str); \
			} \
			else \
			{ \
				guysbuf[ri->npcdataref].member = vbound((value / 10000),0,32767); \
			} \
		} \

		#define	SET_NPCDATA_VAR_BYTE(member, str) \
		{ \
			if( (unsigned) ri->npcdataref > (MAXNPCS-1) ) \
			{ \
				Z_scripterrlog("Invalid NPC ID passed to npcdata->%s: %d\n", (ri->npcdataref*10000), str); \
			} \
			else \
			{ \
				guysbuf[ri->npcdataref].member = vbound((value / 10000),0,255); \
			} \
		} \
		
		#define SET_NPCDATA_VAR_INDEX(member, str, indexbound) \
		{ \
				int32_t indx = ri->d[rINDEX] / 10000; \
				if( (unsigned) ri->npcdataref > (MAXNPCS-1) ) \
				{ \
					Z_scripterrlog("Invalid NPC ID passed to npcdata->%s: %d\n", (ri->npcdataref*10000), str); \
				} \
				else if ( (unsigned)indx > indexbound ) \
				{ \
					Z_scripterrlog("Invalid Array Index passed to npcdata->%s: %d\n", indx, str); \
				} \
				else \
				{ \
					guysbuf[ri->npcdataref].member[indx] = vbound((value / 10000),0,214747); \
				} \
		}

		#define SET_NPCDATA_BYTE_INDEX(member, str, indexbound) \
		{ \
				int32_t indx = ri->d[rINDEX] / 10000; \
				if( (unsigned) ri->npcdataref > (MAXNPCS-1) ) \
				{ \
					Z_scripterrlog("Invalid NPC ID passed to npcdata->%s: %d\n", (ri->npcdataref*10000), str); \
				} \
				else if ( (unsigned)indx > indexbound ) \
				{ \
					Z_scripterrlog("Invalid Array Index passed to npcdata->%s: %d\n", indx, str); \
				} \
				else \
				{ \
					guysbuf[ri->npcdataref].member[indx] = vbound((value / 10000),0,255); \
				} \
		}
		
		#define SET_NPCDATA_FLAG(member, str) \
		{ \
			int32_t flag =  (value/10000);  \
			if( (unsigned) ri->npcdataref > (MAXNPCS-1) ) \
			{ \
				Z_scripterrlog("Invalid NPC ID passed to npcdata->%s: %d\n", (ri->npcdataref*10000), str); \
			} \
			else \
			{ \
				if ( flag ) \
				{ \
					guysbuf[ri->npcdataref].member|=flag; \
				} \
				else guysbuf[ri->npcdataref].member|= ~flag; \
			} \
		} \
		
		case NPCDATATILE: SET_NPCDATA_VAR_BYTE(tile, "Tile"); break;
		case NPCDATAWIDTH: SET_NPCDATA_VAR_BYTE(width, "Width"); break;
		case NPCDATAHEIGHT: SET_NPCDATA_VAR_BYTE(height, "Height"); break;
		case NPCDATAFLAGS: SET_NPCDATA_VAR_DWORD(flags, "Flags"); break; //16 b its
		case NPCDATAFLAGS2: SET_NPCDATA_VAR_DWORD(flags2, "Flags2"); break; //16 bits
		case NPCDATASTILE: SET_NPCDATA_VAR_BYTE(s_tile, "STile"); break;
		case NPCDATASWIDTH: SET_NPCDATA_VAR_BYTE(s_width, "SWidth"); break;
		case NPCDATASHEIGHT: SET_NPCDATA_VAR_BYTE(s_height, "SHeight"); break;
		case NPCDATAETILE: SET_NPCDATA_VAR_INT(e_tile, "ExTile"); break;
		case NPCDATAEWIDTH: SET_NPCDATA_VAR_BYTE(e_width, "ExWidth"); break;
		case NPCDATASCRIPT: SET_NPCDATA_VAR_BYTE(script, "Script"); break;
		case NPCDATAEHEIGHT: SET_NPCDATA_VAR_BYTE(e_height, "ExHeight"); break;
		case NPCDATAHP: SET_NPCDATA_VAR_DWORD(hp, "HP"); break;
		case NPCDATAFAMILY: SET_NPCDATA_VAR_DWORD(family, "Family"); break;
		case NPCDATACSET: SET_NPCDATA_VAR_DWORD(cset, "CSet"); break;
		case NPCDATAANIM: SET_NPCDATA_VAR_DWORD(anim, "Anim"); break;
		case NPCDATAEANIM: SET_NPCDATA_VAR_DWORD(e_anim, "ExAnim"); break;
		case NPCDATAFRAMERATE: SET_NPCDATA_VAR_DWORD(frate, "Framerate"); break;
		case NPCDATAEFRAMERATE: SET_NPCDATA_VAR_DWORD(e_frate, "ExFramerate"); break;
		case NPCDATATOUCHDAMAGE: SET_NPCDATA_VAR_DWORD(dp, "TouchDamage"); break;
		case NPCDATAWEAPONDAMAGE: SET_NPCDATA_VAR_DWORD(wdp, "WeaponDamage"); break;
		case NPCDATAWEAPON: SET_NPCDATA_VAR_DWORD(weapon, "Weapon"); break;
		case NPCDATARANDOM: SET_NPCDATA_VAR_DWORD(rate, "Random"); break;
		case NPCDATAHALT: SET_NPCDATA_VAR_DWORD(hrate, "Haltrate"); break;
		case NPCDATASTEP: SET_NPCDATA_VAR_DWORD(step, "Step"); break;
		case NPCDATAHOMING: SET_NPCDATA_VAR_DWORD(homing, "Homing"); break;
		case NPCDATAHUNGER: SET_NPCDATA_VAR_DWORD(grumble, "Hunger"); break;
		case NPCDATADROPSET: SET_NPCDATA_VAR_DWORD(item_set, "Dropset"); break;
		case NPCDATABGSFX: SET_NPCDATA_VAR_DWORD(bgsfx, "BGSFX"); break;
		case NPCDATADEATHSFX: SET_NPCDATA_VAR_BYTE(deadsfx, "DeathSFX"); break;
		case NPCDATAHITSFX: SET_NPCDATA_VAR_BYTE(hitsfx, "HitSFX"); break;
		case NPCDATAXOFS: SET_NPCDATA_VAR_INT(xofs, "DrawXOffset"); break;
		case NPCDATAYOFS: SET_NPCDATA_VAR_INT(yofs, "DrawYOffset"); break;
		case NPCDATAZOFS: SET_NPCDATA_VAR_INT(zofs, "DrawZOffset"); break;
		case NPCDATAHXOFS: SET_NPCDATA_VAR_INT(hxofs, "HitXOffset"); break;
		case NPCDATAHYOFS: SET_NPCDATA_VAR_INT(hyofs, "HitYOffset"); break;
		case NPCDATAHITWIDTH: SET_NPCDATA_VAR_INT(hxsz, "HitWidth"); break;
		case NPCDATAHITHEIGHT: SET_NPCDATA_VAR_INT(hysz, "HitHeight"); break;
		case NPCDATAHITZ: SET_NPCDATA_VAR_INT(hzsz, "HitZHeight"); break;
		case NPCDATATILEWIDTH: SET_NPCDATA_VAR_INT(txsz, "TileWidth"); break;
		case NPCDATATILEHEIGHT: SET_NPCDATA_VAR_INT(tysz, "TileHeight"); break;
		case NPCDATAWPNSPRITE: SET_NPCDATA_VAR_INT(wpnsprite, "WeaponSprite"); break;
		case NPCDATAWEAPONSCRIPT: SET_NPCDATA_VAR_INT(weaponscript, "WeaponScript"); break;
		case NPCDATADEFENSE: SET_NPCDATA_VAR_INDEX(defense, "Defense", 42); break;
		case NPCDATAWEAPONINITD: SET_NPCDATA_VAR_INDEX(weap_initiald, "WeaponInitD", 8); break;
		case NPCDATAINITD: SET_NPCDATA_VAR_INDEX(initD, "InitD", 8); break;
		case NPCDATASIZEFLAG: SET_NPCDATA_VAR_INT(SIZEflags, "SizeFlags"); break;

		case NPCDATAFROZENTILE: SET_NPCDATA_VAR_INT(frozentile, "FrozenTile"); break;
		case NPCDATAFROZENCSET: SET_NPCDATA_VAR_INT(frozencset, "FrozenCSet"); break;

		case NPCDATAATTRIBUTE: 
		{
			int32_t indx = ri->d[rINDEX] / 10000; 
			if(ri->npcdataref < 0 || ri->npcdataref > (MAXNPCS-1) ) 
			{
				Z_scripterrlog("Invalid Sprite ID passed to npcdata->Attributes[]: %d\n", (ri->npcdataref*10000)); 
			}
			else if ( indx < 0 || indx > MAX_NPC_ATRIBUTES )
			{ 
				Z_scripterrlog("Invalid Array Index passed to npcdata->Attributes[]: %d\n", (ri->npcdataref*10000)); 
			} 
			else 
			{ 
				switch(indx)
				{
					case 0: guysbuf[ri->npcdataref].misc1 = (value / 10000); break;
					case 1: guysbuf[ri->npcdataref].misc2 = (value / 10000); break;
					case 2: guysbuf[ri->npcdataref].misc3 = (value / 10000); break;
					case 3: guysbuf[ri->npcdataref].misc4 = (value / 10000); break;
					case 4: guysbuf[ri->npcdataref].misc5 = (value / 10000); break;
					case 5: guysbuf[ri->npcdataref].misc6 = (value / 10000); break;
					case 6: guysbuf[ri->npcdataref].misc7 = (value / 10000); break;
					case 7: guysbuf[ri->npcdataref].misc8 = (value / 10000); break;
					case 8: guysbuf[ri->npcdataref].misc9 = (value / 10000); break;
					case 9: guysbuf[ri->npcdataref].misc10 = (value / 10000); break;
					case 10: guysbuf[ri->npcdataref].misc11 = (value / 10000); break;
					case 11: guysbuf[ri->npcdataref].misc12 = (value / 10000); break;
					case 12: guysbuf[ri->npcdataref].misc13 = (value / 10000); break;
					case 13: guysbuf[ri->npcdataref].misc14 = (value / 10000); break;
					case 14: guysbuf[ri->npcdataref].misc15 = (value / 10000); break;
					
					case 15: guysbuf[ri->npcdataref].misc16 = value / 10000; break;
					case 16: guysbuf[ri->npcdataref].misc17 = value / 10000; break;
					case 17: guysbuf[ri->npcdataref].misc18 = value / 10000; break;
					case 18: guysbuf[ri->npcdataref].misc19 = value / 10000; break;
					case 19: guysbuf[ri->npcdataref].misc20 = value / 10000; break;
					case 20: guysbuf[ri->npcdataref].misc21 = value / 10000; break;
					case 21: guysbuf[ri->npcdataref].misc22 = value / 10000; break;
					case 22: guysbuf[ri->npcdataref].misc23 = value / 10000; break;
					case 23: guysbuf[ri->npcdataref].misc24 = value / 10000; break;
					case 24: guysbuf[ri->npcdataref].misc25 = value / 10000; break;
					case 25: guysbuf[ri->npcdataref].misc26 = value / 10000; break;
					case 26: guysbuf[ri->npcdataref].misc27 = value / 10000; break;
					case 27: guysbuf[ri->npcdataref].misc28 = value / 10000; break;
					case 28: guysbuf[ri->npcdataref].misc29 = value / 10000; break;
					case 29: guysbuf[ri->npcdataref].misc30 = value / 10000; break;
					case 30: guysbuf[ri->npcdataref].misc31 = value / 10000; break;
					case 31: guysbuf[ri->npcdataref].misc32 = value / 10000; break;
					
						default: 
					{
						Z_scripterrlog("Invalid Array Index passed to npcdata->Attributes[]: %d\n", (ri->npcdataref*10000)); 
						break;
					}
				}
					
			} 
			break;
		}

		case NPCDATABEHAVIOUR: 
		{
			if(ri->npcdataref < 0 || ri->npcdataref > (MAXNPCS-1) ) 
			{
				break;
			}
			
			
			int32_t index = vbound(ri->d[rINDEX]/10000,0,4);
			switch(index){
				case 0:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG1 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG1;
				break;
				case 1:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG2 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG2;
				break;
				case 2:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG3 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG3;
				break;
				case 3:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG4 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG4; 
				break;
				case 4:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG5 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG5;
				break;
				case 5:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG6 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG6; 
				break;
				case 6:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG7 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG7;
				break;
				case 7:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG8 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG8;
				break;
				case 8:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG9 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG9;
				break;		    
				case 9:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG10 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG10;
				break;
				case 10:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG11 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG11; 
				break;
				case 11:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG12 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG12;
				break;
				case 12:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG13 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG13;
				break;
				case 13:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG14 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG14;
				break;
				case 14:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG15 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG15; 
				break;
				case 15:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG16 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG16; 
				break;
				
				
				default: 
					break;
			}
				
			break;
		}

		case NPCDATASHIELD:
		{
			int32_t indx = ri->d[rINDEX] / 10000; 
			if(ri->npcdataref < 0 || ri->npcdataref > (MAXNPCS-1) ) 
			{ 
				Z_scripterrlog("Invalid NPC ID passed to npcdata->Shield[]: %d\n", (ri->npcdataref*10000));
				break;
			} 
			else 
			{ 
				switch(indx)
				{
					case 0:
					{
						(ri->d[rINDEX2])? (guysbuf[ri->npcdataref].flags |= inv_front) : (guysbuf[ri->npcdataref].flags &= ~inv_front);
						break;
					}
					case 1:
					{
						(ri->d[rINDEX2])? (guysbuf[ri->npcdataref].flags |= inv_left) : (guysbuf[ri->npcdataref].flags &= ~inv_left);
						break;
					}
					case 2:
					{
						(ri->d[rINDEX2])? (guysbuf[ri->npcdataref].flags |= inv_right) : (guysbuf[ri->npcdataref].flags &= ~inv_right);
						break;
					}
					case 3:
					{
						(ri->d[rINDEX2])? (guysbuf[ri->npcdataref].flags |= inv_back) : (guysbuf[ri->npcdataref].flags &= ~inv_back);
						break;
					}
					case 4:
					{
						(ri->d[rINDEX2])? (guysbuf[ri->npcdataref].flags |= guy_bkshield) : (guysbuf[ri->npcdataref].flags &= ~guy_bkshield);
						break;
					}
					default:
					{
						Z_scripterrlog("Invalid Array Index passed to npcdata->Shield[]: %d\n", indx); 
						break;
					}
				}
				break;
			} 
		}

		case NPCDSHADOWSPR:
		{
			if(ri->npcdataref < 0 || ri->npcdataref > (MAXNPCS-1) ) 
			{ 
				Z_scripterrlog("Invalid NPC ID passed to npcdata->ShadowSprite: %d\n", (ri->npcdataref*10000));
			} 
			else 
			{
				guysbuf[ri->npcdataref].spr_shadow = vbound(value/10000, 0, 255);
			} 
			break;
		}
		case NPCDSPAWNSPR:
		{
			if(ri->npcdataref < 0 || ri->npcdataref > (MAXNPCS-1) ) 
			{ 
				Z_scripterrlog("Invalid NPC ID passed to npcdata->SpawnSprite: %d\n", (ri->npcdataref*10000));
			} 
			else 
			{
				guysbuf[ri->npcdataref].spr_spawn = vbound(value/10000, 0, 255);
			} 
			break;
		}
		case NPCDDEATHSPR:
		{
			if(ri->npcdataref < 0 || ri->npcdataref > (MAXNPCS-1) ) 
			{ 
				Z_scripterrlog("Invalid NPC ID passed to npcdata->DeathSprite: %d\n", (ri->npcdataref*10000));
			} 
			else 
			{
				guysbuf[ri->npcdataref].spr_death = vbound(value/10000, 0, 255);
			} 
			break;
		}


	///----------------------------------------------------------------------------------------------------//
	//Dropset Variables

		case DROPSETITEMS:
		{
			if(ri->dropsetref < 0 || ri->dropsetref > MAXITEMDROPSETS)
			{
				Z_scripterrlog("Invalid dropset pointer %d\n", ri->dropsetref);
				break;
			}
			int32_t indx = ri->d[rINDEX]/10000;
			if(indx < 0 || indx > 9)
			{
				Z_scripterrlog("Invalid index passed to dropdata->Items[]: %d\n", indx);
			}
			else
			{
				item_drop_sets[ri->dropsetref].item[indx] = vbound(value / 10000, 0, MAXITEMS-1);
			}
			break;
		}
		case DROPSETCHANCES:
		{
			if(ri->dropsetref < 0 || ri->dropsetref > MAXITEMDROPSETS)
			{
				Z_scripterrlog("Invalid dropset pointer %d\n", ri->dropsetref);
				break;
			}
			int32_t indx = ri->d[rINDEX]/10000;
			if(indx < 0 || indx > 9)
			{
				Z_scripterrlog("Invalid index passed to dropdata->Chances[]: %d\n", indx);
			}
			else
			{
				item_drop_sets[ri->dropsetref].chance[indx+1] = vbound((value / 10000),0,32767); //+1 is because '0' is 'nothing''s chance
			}
			break;
		}
		case DROPSETNULLCHANCE:
		{
			if(ri->dropsetref < 0 || ri->dropsetref > MAXITEMDROPSETS)
			{
				Z_scripterrlog("Invalid dropset pointer %d\n", ri->dropsetref);
				break;
			}
			item_drop_sets[ri->dropsetref].chance[0] = vbound((value / 10000),0,32767);
			break;
		}

	///----------------------------------------------------------------------------------------------------//
	//Audio Variables

		case AUDIOVOLUME:
		{
			if (!get_qr(qr_OLD_SCRIPT_VOLUME))
				break;

			int32_t indx = ri->d[rINDEX] / 10000;
			//zprint("Volume[index] is: %d", indx);
			//int32_t vol = value / 10000;
			//zprint("Attempted to change volume to: %d", vol);
			switch(indx)
			{
				
				case 0: //midi volume
				{
					if ( !(FFCore.coreflags&FFCORE_SCRIPTED_MIDI_VOLUME) ) 
					{
						FFCore.usr_midi_volume = FFScript::do_getMIDI_volume();
						FFCore.SetFFEngineFlag(FFCORE_SCRIPTED_MIDI_VOLUME,true);
					}
					FFScript::do_setMIDI_volume(value / 10000);
					break;
				}
				case 1: //digi volume
				{
					if ( !(FFCore.coreflags&FFCORE_SCRIPTED_DIGI_VOLUME) ) 
					{
						FFCore.usr_digi_volume = FFScript::do_getDIGI_volume();
						FFCore.SetFFEngineFlag(FFCORE_SCRIPTED_DIGI_VOLUME,true);
					}
					FFScript::do_setDIGI_volume(value / 10000);
					break;
				}
				case 2: //emh music volume
				{
					if ( !(FFCore.coreflags&FFCORE_SCRIPTED_MUSIC_VOLUME) ) 
					{
						FFCore.usr_music_volume = FFScript::do_getMusic_volume();
						FFCore.SetFFEngineFlag(FFCORE_SCRIPTED_MUSIC_VOLUME,true);
					}
					FFScript::do_setMusic_volume(value / 10000);
					break;
				}
				case 3: //sfx volume
				{
					if ( !(FFCore.coreflags&FFCORE_SCRIPTED_SFX_VOLUME) ) 
					{
						FFCore.usr_sfx_volume = FFScript::do_getSFX_volume();
						FFCore.SetFFEngineFlag(FFCORE_SCRIPTED_SFX_VOLUME,true);
					}
					FFScript::do_setSFX_volume(value / 10000);
					break;
				}
				default:
				{
					Z_scripterrlog("Attempted to access an invalid index of Audio->Volume[]", indx); 
					break;
				}
			}
			break;
		}

		case AUDIOPAN:
		{
			if ( !(FFCore.coreflags&FFCORE_SCRIPTED_PANSTYLE) ) 
			{
				FFCore.usr_panstyle = FFScript::do_getSFX_pan();
				FFCore.SetFFEngineFlag(FFCORE_SCRIPTED_PANSTYLE,true);
			}
			FFScript::do_setSFX_pan(value/10000);
			break;
		}

	///----------------------------------------------------------------------------------------------------//
	//Graphics->

		case NUMDRAWS:
			break;
		
		case MAXDRAWS: break;
	
	///----------------------------------------------------------------------------------------------------//
	//Module->
	case MODULEGETSTR:
	{
		int32_t buf_pointer = ((ri->d[rINDEX])/10000);
		int32_t section_pointer = ((ri->d[rINDEX2])/10000);
		int32_t element_pointer = (value/10000);
		
		string sectionid;
		string elementid;
		
		ArrayH::getString(section_pointer, sectionid);
		ArrayH::getString(element_pointer, elementid);
		
		char buffer[256] = {0};
		
		
		if(!fileexists((char*)moduledata.module_name))
		{
			Z_scripterrlog("I/O Error: No module definitions found when using Module->GetString()\n");
		}	
		else
		{
			zc_push_config();
			//set config file
			zc_config_file(moduledata.module_name);
			strcpy(buffer,zc_get_config_basic(sectionid.c_str(), elementid.c_str(), ""));
			buffer[255] = '\0';
			if(ArrayH::setArray(buf_pointer, buffer) == SH::_Overflow)
				Z_scripterrlog("Dest string supplied to 'Module->GetString()' is not large enough\n");
			//return config file to zc.cfg
			zc_pop_config();
		}
	
		break;
	}

	///----------------------------------------------------------------------------------------------------//
	//Misc./Internal
		case SP:
			ri->sp = value / 10000;
			ri->sp &= MASK_SP;
			break;
		
		case SP2:
			ri->sp = value;
			ri->sp &= MASK_SP;
			break;
			
		case PC:
			ri->pc = value;
			break;
			
		case SWITCHKEY:
			ri->switchkey = value;
			break;
			
		case SCRIPTRAM:
		case GLOBALRAM:
			ArrayH::setElement(ri->d[rINDEX] / 10000, ri->d[rINDEX2] / 10000, value);
			break;
			
		case SCRIPTRAMD:
		case GLOBALRAMD:
			ArrayH::setElement(ri->d[rINDEX] / 10000, 0, value);
			break;
			
		case REFFFC:
			ri->ffcref = value / 10000;
			break;
			
		case REFITEM:
			ri->itemref = value;
			break;
			
		case REFITEMCLASS:
			ri->idata = value;
			break;
			
		case REFLWPN:
			ri->lwpn = value;
			break;
			
		case REFEWPN:
			ri->ewpn = value;
			break;
			
		case REFNPC:
			ri->guyref = value;
			break;
		
		case REFMAPDATA: ri->mapsref = value; break;
		case REFSCREENDATA: ri->screenref = value; break;
		case REFCOMBODATA: ri->combosref = value; break;
		case REFSPRITEDATA: ri->spritesref = value; break;
		case REFBITMAP: ri->bitmapref = value; break;
		case REFNPCCLASS: ri->npcdataref = value; break;
		
		case REFDMAPDATA: ri->dmapsref = value; break;
		case REFSHOPDATA: ri->shopsref = value; break;
		case REFMSGDATA: ri->zmsgref = value; break;
		case REFUNTYPED: ri->untypedref = value; break;
		
		
		case REFDROPS:  ri->dropsetref = value; break;
		case REFBOTTLETYPE:  ri->bottletyperef = value; break;
		case REFBOTTLESHOP:  ri->bottleshopref = value; break;
		case REFGENERICDATA:  ri->genericdataref = value; break;
		case REFPONDS:  ri->pondref = value; break;
		case REFWARPRINGS:  ri->warpringref = value; break;
		case REFDOORS:  ri->doorsref = value; break;
		case REFUICOLOURS:  ri->zcoloursref = value; break;
		case REFRGB:  ri->rgbref = value; break;
		case REFPALETTE:  ri->paletteref = value; break;
		case REFTUNES:  ri->tunesref = value; break;
		case REFPALCYCLE:  ri->palcycleref = value; break;
		case REFGAMEDATA:  ri->gamedataref = value; break;
		case REFCHEATS:  ri->cheatsref = value; break;
		case REFFILE: ri->fileref = value; break;
		case REFDIRECTORY: ri->directoryref = value; break;
		case REFSTACK: ri->stackref = value; break;
		case REFSUBSCREEN: ri->subdataref = value; break;
		case REFSUBSCREENPAGE: ri->subpageref = value; break;
		case REFSUBSCREENWIDG: ri->subwidgref = value; break;
		case REFRNG: ri->rngref = value; break;
		case REFWEBSOCKET: ri->websocketref = value; break;
		case CLASS_THISKEY: ri->thiskey = value; break;
		case CLASS_THISKEY2: ri->thiskey2 = value; break;
		case REFPALDATA: ri->paldataref = value; break;
		
		//-------------------------------------------------------------------------------------------------
		
		case PALDATACOLOR:
		{
			if (user_paldata* pd = checkPalData(ri->paldataref, "paldata->SetColor()"))
			{
				int32_t ind = ri->d[rINDEX] / 10000;
				if (unsigned(ind) >= PALDATA_NUM_COLORS)
				{
					Z_scripterrlog("Invalid color index (%d) passed to paldata->SetColor(). Valid indices are 0-255. Aborting.\n", ind);
					break;
				}
				int32_t clri = value;

				RGB c = _RGB((clri >> 16) & 0xFF, (clri >> 8) & 0xFF, clri & 0xFF);

				if (c.r < 0 || c.g < 0 || c.b < 0)
				{
					Z_scripterrlog("Invalid rgb (%d) passed to paldata->SetColor().\n", clri);
				}
				c.r = vbound(c.r, 0, 63);
				c.g = vbound(c.g, 0, 63);
				c.b = vbound(c.b, 0, 63);

				pd->set_color(ind, c);
			}
			break;
		}
		case PALDATAR:
			FFCore.do_paldata_setrgb(0, value / 10000);
			break;
		case PALDATAG:
			FFCore.do_paldata_setrgb(1, value / 10000);
			break;
		case PALDATAB:
			FFCore.do_paldata_setrgb(2, value / 10000);
			break;

		//-------------------------------------------------------------------------------------------------

		case GENDATARUNNING:
		{
			if(user_genscript* scr = checkGenericScr(ri->genericdataref, "Running"))
			{
				if(value)
					scr->launch();
				else scr->quit();
			}
			break;
		}
		case GENDATASIZE:
		{
			if(user_genscript* scr = checkGenericScr(ri->genericdataref, "DataSize"))
			{
				scr->dataResize(value/10000);
			}
			break;
		}
		case GENDATAEXITSTATE:
		{
			if(user_genscript* scr = checkGenericScr(ri->genericdataref, "ExitState"))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= GENSCR_NUMST)
				{
					Z_scripterrlog("Invalid index passed to genericdata->ReloadState[]: %d\n", indx);
					break;
				}
				SETFLAG(scr->exitState, (1<<indx), value);
			}
			break;
		}
		case GENDATARELOADSTATE:
		{
			if(user_genscript* scr = checkGenericScr(ri->genericdataref, "ReloadState"))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= GENSCR_NUMST)
				{
					Z_scripterrlog("Invalid index passed to genericdata->ReloadState[]: %d\n", indx);
					break;
				}
				SETFLAG(scr->reloadState, (1<<indx), value);
			}
			break;
		}
		case GENDATAEVENTSTATE:
		{
			if(user_genscript* scr = checkGenericScr(ri->genericdataref, "EventListen"))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= GENSCR_NUMEVENT)
				{
					Z_scripterrlog("Invalid index passed to genericdata->EventListen[]: %d\n", indx);
					break;
				}
				SETFLAG(scr->eventstate, (1<<indx), value);
			}
			break;
		}
		case GENDATADATA:
		{
			if(user_genscript* scr = checkGenericScr(ri->genericdataref, "Data[]"))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= scr->dataSize())
				{
					Z_scripterrlog("Invalid index passed to genericdata->Data[]: %d\n", indx);
					break;
				}
				scr->data[indx] = value;
			}
			break;
		}
		case GENDATAINITD:
		{
			if(user_genscript* scr = checkGenericScr(ri->genericdataref, "InitD[]"))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= 8)
				{
					Z_scripterrlog("Invalid index passed to genericdata->InitD[]: %d\n", indx);
					break;
				}
				scr->initd[indx] = value;
			}
			break;
		}
		
		//----------------------------------------------------------------------------------------------------//
		
		case PORTALX:
		{
			if(portal* p = checkPortal(ri->portalref, "X"))
				p->x = zslongToFix(value);
			break;
		}
		case PORTALY:
		{
			if(portal* p = checkPortal(ri->portalref, "Y"))
				p->y = zslongToFix(value);
			break;
		}
		case PORTALDMAP:
		{
			if(portal* p = checkPortal(ri->portalref, "DMap"))
				p->destdmap = vbound(value/10000,-1,MAXDMAPS-1);
			break;
		}
		case PORTALSCREEN:
		{
			if(portal* p = checkPortal(ri->portalref, "Screen"))
				p->destscr = vbound(value/10000,0,255);
			break;
		}
		case PORTALACLK:
		{
			if(portal* p = checkPortal(ri->portalref, "AClk"))
				p->aclk = vbound(value/10000, 0, 9999);
			break;
		}
		case PORTALAFRM:
		{
			if(portal* p = checkPortal(ri->portalref, "AFrame"))
				p->aframe = vbound(value/10000, 0, 9999);
			break;
		}
		case PORTALOTILE:
		{
			if(portal* p = checkPortal(ri->portalref, "OriginalTile"))
				p->o_tile = vbound(value/10000, 0, NEWMAXTILES-1);
			break;
		}
		case PORTALASPD:
		{
			if(portal* p = checkPortal(ri->portalref, "ASpeed"))
				p->aspd = vbound(value/10000, 0, 9999);
			break;
		}
		case PORTALFRAMES:
		{
			if(portal* p = checkPortal(ri->portalref, "Frames"))
				p->frames = vbound(value/10000, 0, 9999);
			break;
		}
		case PORTALSAVED:
		{
			if(ri->portalref < 0 || value < 0) break;
			if(portal* p = checkPortal(ri->portalref, "SavedPortal"))
			{
				if(!value)
					p->saved_data = 0;
				else if(savedportal* sp = checkSavedPortal(value, "portal->SavedPortal"))
					p->saved_data = sp->getUID();
			}
			break;
		}
		case PORTALCLOSEDIS:
		{
			if(portal* p = checkPortal(ri->portalref, "CloseDisabled"))
				p->prox_active = value==0; //Inverted
			break;
		}
		case REFPORTAL:
		{
			ri->portalref = value;
			break;
		}
		case REFSAVPORTAL:
		{
			ri->saveportalref = value;
			break;
		}
		case PORTALWARPSFX:
		{
			if(portal* p = checkPortal(ri->portalref, "WarpSFX"))
				p->wsfx = vbound(value/10000,0,255);
			break;
		}
		case PORTALWARPVFX:
		{
			if(portal* p = checkPortal(ri->portalref, "WarpEffect"))
				p->weffect = vbound(value/10000,0,255);
			break;
		}
		case SAVEDPORTALX:
		{
			if(savedportal* p = checkSavedPortal(ri->saveportalref, "X"))
				p->x = value;
			break;
		}
		case SAVEDPORTALY:
		{
			if(savedportal* p = checkSavedPortal(ri->saveportalref, "Y"))
				p->y = value;
			break;
		}
		case SAVEDPORTALSRCDMAP:
		{
			if(savedportal* p = checkSavedPortal(ri->saveportalref, "SrcDMap"))
				p->srcdmap = vbound(value/10000, -1, MAXDMAPS-1);
			break;
		}
		case SAVEDPORTALDESTDMAP:
		{
			if(savedportal* p = checkSavedPortal(ri->saveportalref, "DestDMap"))
				p->destdmap = vbound(value/10000, -1, MAXDMAPS-1);
			break;
		}
		case SAVEDPORTALSRCSCREEN:
		{
			if(savedportal* p = checkSavedPortal(ri->saveportalref, "SrcScreen"))
				p->srcscr = vbound(value/10000,0,255);
			break;
		}
		case SAVEDPORTALDSTSCREEN:
		{
			if(savedportal* p = checkSavedPortal(ri->saveportalref, "DestScreen"))
				p->destscr = vbound(value/10000,0,255);
			break;
		}
		case SAVEDPORTALWARPSFX:
		{
			if(savedportal* p = checkSavedPortal(ri->saveportalref, "WarpSFX"))
				p->sfx = vbound(value/10000,0,255);
			break;
		}
		case SAVEDPORTALWARPVFX:
		{
			if(savedportal* p = checkSavedPortal(ri->saveportalref, "WarpEffect"))
				p->warpfx = vbound(value/10000,0,255);
			break;
		}
		case SAVEDPORTALSPRITE:
		{
			if(savedportal* p = checkSavedPortal(ri->saveportalref, "Sprite"))
				p->spr = vbound(value/10000,0,255);
			break;
		}
		case SAVEDPORTALPORTAL:
		{
			if(ri->saveportalref < 0 || value < 0) break;
			if(savedportal* sp = checkSavedPortal(ri->saveportalref, "Portal"))
			{
				int32_t id = getPortalFromSaved(sp);
				if(id == value) break; //no change
				portal* p = checkPortal(value,"savedportal->Portal");
				if(p)
				{
					p->saved_data = sp->getUID();
					if(id > 0)
					{
						portal* p = checkPortal(id,"THIS SHOULD NOT APPEAR");
						p->saved_data = 0;
					}
				}
			}
			break;
		}
		
		case GAMENUMASUB:
		{
			if(value >= 0)
			{
				size_t sz = vbound(value/10000, 0, 256);
				while(subscreens_active.size() < sz)
				{
					auto& sub = subscreens_active.emplace_back();
					sub.sub_type = sstACTIVE;
				}
				while(subscreens_active.size() > sz)
					subscreens_active.pop_back();
			}
			break;
		}
		case GAMENUMPSUB:
		{
			if(value >= 0)
			{
				size_t sz = vbound(value/10000, 0, 256);
				while(subscreens_passive.size() < sz)
				{
					auto& sub = subscreens_passive.emplace_back();
					sub.sub_type = sstPASSIVE;
				}
				while(subscreens_passive.size() > sz)
					subscreens_passive.pop_back();
			}
			break;
		}
		case GAMENUMOSUB:
		{
			if(value >= 0)
			{
				size_t sz = vbound(value/10000, 0, 256);
				while(subscreens_overlay.size() < sz)
				{
					auto& sub = subscreens_overlay.emplace_back();
					sub.sub_type = sstOVERLAY;
				}
				while(subscreens_overlay.size() > sz)
					subscreens_overlay.pop_back();
			}
			break;
		}
		///----------------------------------------------------------------------------------------------------//
		
		case SUBDATACURPG:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "CurPage"))
				if(sub->sub_type == sstACTIVE)
					sub->curpage = vbound(value/10000,0,sub->pages.size()-1);
			break;
		}
		case SUBDATANUMPG:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "NumPages"))
				if(sub->sub_type == sstACTIVE && value >= 10000)
				{
					size_t sz = value/10000;
					while(sub->pages.size() < sz)
						if(!sub->add_page(MAX_SUBSCR_PAGES))
							break;
					while(sub->pages.size() > sz)
						sub->delete_page(sub->pages.size()-1);
				}
			break;
		}
		case SUBDATAPAGES: break; //READONLY
		case SUBDATATYPE: break; //READONLY
		case SUBDATAFLAGS:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "Flags[]"))
			{
				size_t indx = ri->d[rINDEX]/10000;
				size_t sz = 0;
				switch(sub->sub_type)
				{
					case sstACTIVE:
						sz = 2;
						break;
					case sstPASSIVE:
						sz = 0;
						break;
					case sstOVERLAY:
						sz = 0;
						break;
				}
				if(indx >= sz)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreendata->Flags[]' of size '%d'\n", indx, sz);
				}
				else
					SETFLAG(sub->flags,(1<<indx),value);
			}
			break;
		}
		///---- ACTIVE SUBSCREENS ONLY
		case SUBDATACURSORPOS:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "CursorPos", sstACTIVE))
			{
				SubscrPage& pg = sub->cur_page();
				//Should this be sanity checked? Or should nulling out
				// the cursor by setting it invalid be allowed? -Em
				pg.cursor_pos = vbound(value/10000,0,255);
			}
			break;
		}
		case SUBDATASCRIPT:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "Script", sstACTIVE))
				sub->script = vbound(value/10000,0,NUMSCRIPTSSUBSCREEN-1);
			break;
		}
		case SUBDATAINITD:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "InitD[]", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= 8)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreendata->InitD[8]'\n", indx);
				}
				else
					sub->initd[indx] = value;
			}
			break;
		}
		case SUBDATABTNLEFT:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "BtnPageLeft[]", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= 8)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreendata->BtnPageLeft[8]'\n", indx);
				}
				else
					SETFLAG(sub->btn_left,(1<<indx),value);
			}
			break;
		}
		case SUBDATABTNRIGHT:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "BtnPageRight[]", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= 8)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreendata->BtnPageRight[8]'\n", indx);
				}
				else
					SETFLAG(sub->btn_right,(1<<indx),value);
			}
			break;
		}
		case SUBDATATRANSLEFTTY:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "TransLeftType", sstACTIVE))
			{
				auto& trans = sub->trans_left;
				trans.type = vbound(value/10000,0,sstrMAX-1);
			}
			break;
		}
		case SUBDATATRANSLEFTSFX:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "TransLeftSFX", sstACTIVE))
			{
				auto& trans = sub->trans_left;
				trans.tr_sfx = vbound(value/10000,0,255);
			}
			break;
		}
		case SUBDATATRANSLEFTFLAGS:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "TransLeftFlags[]", sstACTIVE))
			{
				auto& trans = sub->trans_left;
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_TRANS_NUMFLAGS)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreendata->TransLeftFlags[%d]'\n", indx, SUBSCR_TRANS_NUMFLAGS);
				}
				else
					SETFLAG(trans.flags,(1<<indx),value);
			}
			break;
		}
		case SUBDATATRANSLEFTARGS:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "TransLeftArgs[]", sstACTIVE))
			{
				auto& trans = sub->trans_left;
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_TRANSITION_MAXARG)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreendata->TransLeftArgs[%d]'\n", indx, SUBSCR_TRANSITION_MAXARG);
				}
				else
					trans.arg[indx] = value/SubscrTransition::argScale(trans.type,indx);
			}
			break;
		}
		case SUBDATATRANSRIGHTTY:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "TransRightType", sstACTIVE))
			{
				auto& trans = sub->trans_right;
				trans.type = vbound(value/10000,0,sstrMAX-1);
			}
			break;
		}
		case SUBDATATRANSRIGHTSFX:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "TransRightSFX", sstACTIVE))
			{
				auto& trans = sub->trans_right;
				trans.tr_sfx = vbound(value/10000,0,255);
			}
			break;
		}
		case SUBDATATRANSRIGHTFLAGS:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "TransRightFlags[]", sstACTIVE))
			{
				auto& trans = sub->trans_right;
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_TRANS_NUMFLAGS)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreendata->TransRightFlags[%d]'\n", indx, SUBSCR_TRANS_NUMFLAGS);
				}
				else
					SETFLAG(trans.flags,(1<<indx),value);
			}
			break;
		}
		case SUBDATATRANSRIGHTARGS:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "TransRightArgs[]", sstACTIVE))
			{
				auto& trans = sub->trans_right;
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_TRANSITION_MAXARG)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreendata->TransRightArgs[%d]'\n", indx, SUBSCR_TRANSITION_MAXARG);
				}
				else
					trans.arg[indx] = value/SubscrTransition::argScale(trans.type,indx);
			}
			break;
		}
		case SUBDATASELECTORDSTX:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "SelectorDestX", sstACTIVE))
				sub->selector_setting.x = vbound(value/10000,-32768,32767);
			break;
		}
		case SUBDATASELECTORDSTY:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "SelectorDestY", sstACTIVE))
				sub->selector_setting.y = vbound(value/10000,-32768,32767);
			break;
		}
		case SUBDATASELECTORDSTW:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "SelectorDestW", sstACTIVE))
				sub->selector_setting.w = vbound(value/10000,-32768,32767);
			break;
		}
		case SUBDATASELECTORDSTH:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "SelectorDestH", sstACTIVE))
				sub->selector_setting.h = vbound(value/10000,-32768,32767);
			break;
		}
		case SUBDATASELECTORWID:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "SelectorDestWid", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreendata->"
						"SelectorDestWid[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else
					sub->selector_setting.tileinfo[indx].sw = vbound(value/10000,0,65535);
			}
			break;
		}
		case SUBDATASELECTORHEI:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "SelectorDestHei", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreendata->"
						"SelectorDestHei[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else
					sub->selector_setting.tileinfo[indx].sh = vbound(value/10000,0,65535);
			}
			break;
		}
		case SUBDATASELECTORTILE:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "SelectorTile", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreendata->"
						"SelectorTile[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else
					sub->selector_setting.tileinfo[indx].tile = vbound(value/10000,0,NEWMAXTILES-1);
			}
			break;
		}
		case SUBDATASELECTORCSET:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "SelectorCSet", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreendata->"
						"SelectorCSet[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else
				{
					byte& cs = sub->selector_setting.tileinfo[indx].cset;
					cs = (cs&0xF0)|vbound(value/10000,0,0x0F);
				}
			}
			break;
		}
		case SUBDATASELECTORFLASHCSET:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "SelectorFlashCSet", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreendata->"
						"SelectorFlashCSet[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else
				{
					byte& cs = sub->selector_setting.tileinfo[indx].cset;
					cs = (cs&0x0F)|(vbound(value/10000,0,0x0F)<<4);
				}
			}
			break;
		}
		case SUBDATASELECTORFRM:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "SelectorFrames", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreendata->"
						"SelectorFrames[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else
					sub->selector_setting.tileinfo[indx].frames = vbound(value/10000,1,255);
			}
			break;
		}
		case SUBDATASELECTORASPD:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "SelectorASpeed", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreendata->"
						"SelectorASpeed[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else
					sub->selector_setting.tileinfo[indx].speed = vbound(value/10000,1,255);
			}
			break;
		}
		case SUBDATASELECTORDELAY:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "SelectorDelay", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreendata->"
						"SelectorDelay[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else
					sub->selector_setting.tileinfo[indx].delay = vbound(value/10000,0,255);
			}
			break;
		}
		///---- CURRENTLY OPEN ACTIVE SUBSCREEN ONLY
		case SUBDATATRANSCLK:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "TransClock", sstACTIVE))
			{
				if(sub != new_subscreen_active)
					Z_scripterrlog("'subscreendata->TransClock' is only"
						" valid for the current active subscreen!\n");
				else if(subscreen_open)
				{
					int val = value/10000;
					if(val < 0)
						subscrpg_clear_animation();
					else if(!subscr_pg_animating)
					{
						SubscrTransition tr = subscr_pg_transition;
						tr.tr_sfx = 0;
						subscrpg_animate(subscr_pg_from,subscr_pg_to,tr,*new_subscreen_active);
						subscr_pg_clk = val;
					}
					else subscr_pg_clk = val;
				}
			}
			break;
		}
		case SUBDATATRANSTY:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "TransType", sstACTIVE))
			{
				auto& trans = subscr_pg_transition;
				if(sub != new_subscreen_active)
					Z_scripterrlog("'subscreendata->TransType' is only"
						" valid for the current active subscreen!\n");
				else if(subscreen_open)
					trans.type = vbound(value/10000,0,sstrMAX-1);
			}
			break;
		}
		case SUBDATATRANSFLAGS:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "TransFlags[]", sstACTIVE))
			{
				auto& trans = subscr_pg_transition;
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_TRANS_NUMFLAGS)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreendata->TransFlags[%d]'\n", indx, SUBSCR_TRANS_NUMFLAGS);
				}
				else if(sub != new_subscreen_active)
					Z_scripterrlog("'subscreendata->TransType' is only"
						" valid for the current active subscreen!\n");
				else if(subscreen_open)
					SETFLAG(trans.flags,(1<<indx),value);
			}
			break;
		}
		case SUBDATATRANSARGS:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "TransArgs[]", sstACTIVE))
			{
				auto& trans = subscr_pg_transition;
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_TRANSITION_MAXARG)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreendata->TransArgs[%d]'\n", indx, SUBSCR_TRANSITION_MAXARG);
				}
				else if(sub != new_subscreen_active)
					Z_scripterrlog("'subscreendata->TransType' is only"
						" valid for the current active subscreen!\n");
				else if(subscreen_open)
					trans.arg[indx] = value/SubscrTransition::argScale(trans.type,indx);
			}
			break;
		}
		case SUBDATATRANSFROMPG:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "TransFromPage", sstACTIVE))
			{
				if(sub != new_subscreen_active)
					Z_scripterrlog("'subscreendata->TransFromPage' is only"
						" valid for the current active subscreen!\n");
				else if(subscreen_open)
					subscr_pg_from = vbound(value/10000,0,sub->pages.size()-1);
			}
			break;
		}
		case SUBDATATRANSTOPG:
		{
			if(ZCSubscreen* sub = checkSubData(ri->subdataref, "TransToPage", sstACTIVE))
			{
				if(sub != new_subscreen_active)
					Z_scripterrlog("'subscreendata->TransToPage' is only"
						" valid for the current active subscreen!\n");
				else if(subscreen_open)
					subscr_pg_to = vbound(value/10000,0,sub->pages.size()-1);
			}
			break;
		}
		
		///----------------------------------------------------------------------------------------------------//
		case SUBPGINDEX: break; //READ-ONLY
		case SUBPGNUMWIDG: break; //READ-ONLY
		case SUBPGWIDGETS: break; //READ-ONLY
		case SUBPGSUBDATA: break; //READ-ONLY
		case SUBPGCURSORPOS:
		{
			if(SubscrPage* pg = checkSubPage(ri->subpageref, "CursorPos"))
				pg->cursor_pos = vbound(value/10000,0,255);
			break;
		}
		///----------------------------------------------------------------------------------------------------//
		///---- ANY WIDGET TYPE
		case SUBWIDGTYPE: break; //READ-ONLY
		case SUBWIDGINDEX: break; //READ-ONLY
		case SUBWIDGPAGE: break; //READ-ONLY
		case SUBWIDGDISPITM: break; //READ-ONLY
		case SUBWIDGEQPITM: break; //READ-ONLY
		case SUBWIDGPOS:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Pos"))
				widg->pos = vbound(value/10000,0,255);
			break;
		}
		case SUBWIDGPOSES:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "PosDirs"))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= 4)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreenwidget->PosDirs[%d]'\n", indx, 4);
				}
				else
				{
					byte val = vbound(value/10000,0,255);
					switch(indx)
					{
						case up:
							widg->pos_up = val;
							break;
						case down:
							widg->pos_down = val;
							break;
						case left:
							widg->pos_left = val;
							break;
						case right:
							widg->pos_right = val;
							break;
					}
				}
			}
			break;
		}
		case SUBWIDGPOSFLAG:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "VisibleFlags"))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= sspNUM)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreenwidget->VisibleFlags[%d]'\n", indx, sspNUM);
				}
				else
				{
					SETFLAG(widg->posflags, 1<<indx, value);
				}
			}
			break;
		}
		case SUBWIDGX:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "X"))
				widg->x = vbound(value/10000,-32768,32767);
			break;
		}
		case SUBWIDGY:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Y"))
				widg->y = vbound(value/10000,-32768,32767);
			break;
		}
		case SUBWIDGW:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "W"))
				widg->w = vbound(value/10000,0,65535);
			break;
		}
		case SUBWIDGH:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "H"))
				widg->h = vbound(value/10000,0,65535);
			break;
		}
		case SUBWIDGGENFLAG:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "GenFlags"))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCRFLAG_GEN_COUNT)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreenwidget->GenFlags[%d]'\n", indx, SUBSCRFLAG_GEN_COUNT);
				}
				else
				{
					SETFLAG(widg->genflags, 1<<indx, value);
				}
			}
			break;
		}
		case SUBWIDGFLAG:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Flags"))
			{
				size_t indx = ri->d[rINDEX]/10000;
				byte sz = widg->numFlags();
				if(indx >= sz)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreenwidget->Flags[%d]'\n", indx, sz);
				}
				else
				{
					SETFLAG(widg->flags, 1<<indx, value);
				}
			}
			break;
		}
		///---- ACTIVE SUBSCREENS ONLY
		case SUBWIDGSELECTORDSTX:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "SelectorDestX", sstACTIVE))
				widg->selector_override.x = vbound(value/10000,-32768,32767);
			break;
		}
		case SUBWIDGSELECTORDSTY:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "SelectorDestY", sstACTIVE))
				widg->selector_override.y = vbound(value/10000,-32768,32767);
			break;
		}
		case SUBWIDGSELECTORDSTW:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "SelectorDestW", sstACTIVE))
				widg->selector_override.w = vbound(value/10000,-32768,32767);
			break;
		}
		case SUBWIDGSELECTORDSTH:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "SelectorDestH", sstACTIVE))
				widg->selector_override.h = vbound(value/10000,-32768,32767);
			break;
		}
		case SUBWIDGSELECTORWID:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "SelectorDestWid", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreenwidget->"
						"SelectorDestWid[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else
					widg->selector_override.tileinfo[indx].sw = vbound(value/10000,0,65535);
			}
			break;
		}
		case SUBWIDGSELECTORHEI:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "SelectorDestHei", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreenwidget->"
						"SelectorDestHei[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else
					widg->selector_override.tileinfo[indx].sh = vbound(value/10000,0,65535);
			}
			break;
		}
		case SUBWIDGSELECTORTILE:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "SelectorTile", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreenwidget->"
						"SelectorTile[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else
					widg->selector_override.tileinfo[indx].tile = vbound(value/10000,0,NEWMAXTILES-1);
			}
			break;
		}
		case SUBWIDGSELECTORCSET:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "SelectorCSet", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreenwidget->"
						"SelectorCSet[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else
				{
					byte& cs = widg->selector_override.tileinfo[indx].cset;
					cs = (cs&0xF0)|vbound(value/10000,0,0x0F);
				}
			}
			break;
		}
		case SUBWIDGSELECTORFLASHCSET:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "SelectorFlashCSet", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreenwidget->"
						"SelectorFlashCSet[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else
				{
					byte& cs = widg->selector_override.tileinfo[indx].cset;
					cs = (cs&0x0F)|(vbound(value/10000,0,0x0F)<<4);
				}
			}
			break;
		}
		case SUBWIDGSELECTORFRM:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "SelectorFrames", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreenwidget->"
						"SelectorFrames[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else
					widg->selector_override.tileinfo[indx].frames = vbound(value/10000,1,255);
			}
			break;
		}
		case SUBWIDGSELECTORASPD:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "SelectorASpeed", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreenwidget->"
						"SelectorASpeed[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else
					widg->selector_override.tileinfo[indx].speed = vbound(value/10000,1,255);
			}
			break;
		}
		case SUBWIDGSELECTORDELAY:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "SelectorDelay", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_SELECTOR_NUMTILEINFO)
				{
					Z_scripterrlog("Bad index '%d' to array 'subscreenwidget->"
						"SelectorDelay[%d]'\n", indx, SUBSCR_SELECTOR_NUMTILEINFO);
				}
				else
					widg->selector_override.tileinfo[indx].delay = vbound(value/10000,0,255);
			}
			break;
		}
				
		case SUBWIDGPRESSSCRIPT:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "PressScript", sstACTIVE))
				widg->generic_script = vbound(value/10000,0,NUMSCRIPTSGENERIC-1);
			break;
		}
		case SUBWIDGPRESSINITD:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "PressInitD[]", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= 8)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreenwidget->PressInitD[8]'\n", indx);
				}
				else
					widg->generic_initd[indx] = value;
			}
			break;
		}
		case SUBWIDGBTNPRESS:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "BtnPressScript[]", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= 8)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreenwidget->BtnPressScript[8]'\n", indx);
				}
				else
					SETFLAG(widg->gen_script_btns,(1<<indx),value);
			}
			break;
		}
		case SUBWIDGBTNPG:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "BtnPageChange[]", sstACTIVE))
			{
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= 8)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreenwidget->BtnPageChange[8]'\n", indx);
				}
				else
					SETFLAG(widg->pg_btns,(1<<indx),value);
			}
			break;
		}
		case SUBWIDGPGMODE:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "PageMode", sstACTIVE))
				widg->pg_mode = vbound(value/10000,0,PGGOTO_MAX-1);
			break;
		}
		case SUBWIDGPGTARG:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "TargetPage", sstACTIVE))
				widg->pg_targ = vbound(value/10000,0,MAX_SUBSCR_PAGES-1);
			break;
		}
		
		case SUBWIDGTRANSPGTY:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "PageTransType", sstACTIVE))
			{
				auto& trans = widg->pg_trans;
				trans.type = vbound(value/10000,0,sstrMAX-1);
			}
			break;
		}
		case SUBWIDGTRANSPGSFX:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "PageTransSFX", sstACTIVE))
			{
				auto& trans = widg->pg_trans;
				trans.tr_sfx = vbound(value/10000,0,255);
			}
			break;
		}
		case SUBWIDGTRANSPGFLAGS:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "PageTransFlags[]", sstACTIVE))
			{
				auto& trans = widg->pg_trans;
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_TRANS_NUMFLAGS)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreenwidget->PageTransFlags[%d]'\n", indx, SUBSCR_TRANS_NUMFLAGS);
				}
				else
					SETFLAG(trans.flags,(1<<indx),value);
			}
			break;
		}
		case SUBWIDGTRANSPGARGS:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "PageTransArgs[]", sstACTIVE))
			{
				auto& trans = widg->pg_trans;
				size_t indx = ri->d[rINDEX]/10000;
				if(indx >= SUBSCR_TRANSITION_MAXARG)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreenwidget->PageTransArgs[%d]'\n", indx, SUBSCR_TRANSITION_MAXARG);
				}
				else
					trans.arg[indx] = value/SubscrTransition::argScale(trans.type,indx);
			}
			break;
		}
		///---- VARYING WIDGET TYPES
		case SUBWIDGTY_CSET:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "CSet"))
			{
				auto val = vbound(value/10000,-sscsMAX,15);
				size_t indx = ri->d[rINDEX]/10000;
				size_t sz = 0;
				byte ty = widg->getType();
				switch(ty)
				{
					case widgFRAME:
					case widgMCGUFF:
					case widgTILEBLOCK:
					case widgMINITILE:
						sz = 1;
						break;
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						sz = 4;
						break;
					default:
						sz = 0;
						bad_subwidg_type("CSet[]", false, ty);
						break;
				}
				if(!sz) break;
				if(indx >= sz)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreenwidget->CSet[%d]'\n", indx, sz);
					break;
				}
				switch(ty)
				{
					case widgFRAME:
						((SW_2x2Frame*)widg)->cs.set_int_cset(val);
						break;
					case widgMCGUFF:
						((SW_McGuffin*)widg)->cs.set_int_cset(val);
						break;
					case widgTILEBLOCK:
						((SW_TileBlock*)widg)->cs.set_int_cset(val);
						break;
					case widgMINITILE:
						((SW_MiniTile*)widg)->cs.set_int_cset(val);
						break;
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						val = vbound(value/10000,0,15);
						((SW_GaugePiece*)widg)->mts[indx].cset = val;
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_TILE:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Tile[]"))
			{
				auto val = vbound(value/10000,0,NEWMAXTILES-1);
				size_t indx = ri->d[rINDEX]/10000;
				size_t sz = 0;
				byte ty = widg->getType();
				switch(ty)
				{
					case widgFRAME:
					case widgMCGUFF:
					case widgTILEBLOCK:
					case widgMINITILE:
						sz = 1;
						break;
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						sz = 4;
						break;
					default:
						sz = 0;
						bad_subwidg_type("Tile[]", false, ty);
						break;
				}
				if(!sz) break;
				if(indx >= sz)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreenwidget->Tile[%d]'\n", indx, sz);
					break;
				}
				switch(ty)
				{
					case widgFRAME:
						((SW_2x2Frame*)widg)->tile = val;
						break;
					case widgMCGUFF:
						((SW_McGuffin*)widg)->tile = val;
						break;
					case widgTILEBLOCK:
						((SW_TileBlock*)widg)->tile = val;
						break;
					case widgMINITILE:
						val = vbound(value/10000,-ssmstMAX,NEWMAXTILES-1);
						((SW_MiniTile*)widg)->set_int_tile(val);
						break;
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						((SW_GaugePiece*)widg)->mts[indx].setTile(val);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_FONT:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Font"))
			{
				auto val = vbound(value/10000,0,font_max-1);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgTEXT:
						((SW_Text*)widg)->fontid = val;
						break;
					case widgTEXTBOX:
						((SW_TextBox*)widg)->fontid = val;
						break;
					case widgSELECTEDTEXT:
						((SW_SelectedText*)widg)->fontid = val;
						break;
					case widgTIME:
						((SW_Time*)widg)->fontid = val;
						break;
					case widgCOUNTER:
						((SW_Counter*)widg)->fontid = val;
						break;
					case widgBTNCOUNTER:
						((SW_BtnCounter*)widg)->fontid = val;
						break;
					case widgOLDCTR:
						((SW_Counters*)widg)->fontid = val;
						break;
					case widgMMAPTITLE:
						((SW_MMapTitle*)widg)->fontid = val;
						break;
					default:
						bad_subwidg_type("Font", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_ALIGN:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Align"))
			{
				auto val = vbound(value/10000,0,sstaMAX-1);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgTEXT:
						((SW_Text*)widg)->align = val;
						break;
					case widgTEXTBOX:
						((SW_TextBox*)widg)->align = val;
						break;
					case widgSELECTEDTEXT:
						((SW_SelectedText*)widg)->align = val;
						break;
					case widgTIME:
						((SW_Time*)widg)->align = val;
						break;
					case widgCOUNTER:
						((SW_Counter*)widg)->align = val;
						break;
					case widgBTNCOUNTER:
						((SW_BtnCounter*)widg)->align = val;
						break;
					case widgMMAPTITLE:
						((SW_MMapTitle*)widg)->align = val;
						break;
					default:
						bad_subwidg_type("Align", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_SHADOWTY:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "ShadowType"))
			{
				auto val = vbound(value/10000,0,sstsMAX-1);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgTEXT:
						((SW_Text*)widg)->shadtype = val;
						break;
					case widgTEXTBOX:
						((SW_TextBox*)widg)->shadtype = val;
						break;
					case widgSELECTEDTEXT:
						((SW_SelectedText*)widg)->shadtype = val;
						break;
					case widgTIME:
						((SW_Time*)widg)->shadtype = val;
						break;
					case widgCOUNTER:
						((SW_Counter*)widg)->shadtype = val;
						break;
					case widgBTNCOUNTER:
						((SW_BtnCounter*)widg)->shadtype = val;
						break;
					case widgOLDCTR:
						((SW_Counters*)widg)->shadtype = val;
						break;
					case widgMMAPTITLE:
						((SW_MMapTitle*)widg)->shadtype = val;
						break;
					default:
						bad_subwidg_type("ShadowType", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_COLOR_TXT:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "ColorText"))
			{
				auto val = vbound(value/10000,MIN_SUBSCR_COLOR,MAX_SUBSCR_COLOR);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgTEXT:
						((SW_Text*)widg)->c_text.set_int_color(val);
						break;
					case widgTEXTBOX:
						((SW_TextBox*)widg)->c_text.set_int_color(val);
						break;
					case widgSELECTEDTEXT:
						((SW_SelectedText*)widg)->c_text.set_int_color(val);
						break;
					case widgTIME:
						((SW_Time*)widg)->c_text.set_int_color(val);
						break;
					case widgCOUNTER:
						((SW_Counter*)widg)->c_text.set_int_color(val);
						break;
					case widgBTNCOUNTER:
						((SW_BtnCounter*)widg)->c_text.set_int_color(val);
						break;
					case widgOLDCTR:
						((SW_Counters*)widg)->c_text.set_int_color(val);
						break;
					case widgMMAPTITLE:
						((SW_MMapTitle*)widg)->c_text.set_int_color(val);
						break;
					case widgMCGUFF_FRAME:
						((SW_TriFrame*)widg)->c_number.set_int_color(val);
						break;
					default:
						bad_subwidg_type("ColorText", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_COLOR_SHD:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "ColorShadow"))
			{
				auto val = vbound(value/10000,MIN_SUBSCR_COLOR,MAX_SUBSCR_COLOR);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgTEXT:
						((SW_Text*)widg)->c_shadow.set_int_color(val);
						break;
					case widgTEXTBOX:
						((SW_TextBox*)widg)->c_shadow.set_int_color(val);
						break;
					case widgSELECTEDTEXT:
						((SW_SelectedText*)widg)->c_shadow.set_int_color(val);
						break;
					case widgTIME:
						((SW_Time*)widg)->c_shadow.set_int_color(val);
						break;
					case widgCOUNTER:
						((SW_Counter*)widg)->c_shadow.set_int_color(val);
						break;
					case widgBTNCOUNTER:
						((SW_BtnCounter*)widg)->c_shadow.set_int_color(val);
						break;
					case widgOLDCTR:
						((SW_Counters*)widg)->c_shadow.set_int_color(val);
						break;
					case widgMMAPTITLE:
						((SW_MMapTitle*)widg)->c_shadow.set_int_color(val);
						break;
					default:
						bad_subwidg_type("ColorShadow", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_COLOR_BG:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "ColorBG"))
			{
				auto val = vbound(value/10000,MIN_SUBSCR_COLOR,MAX_SUBSCR_COLOR);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgTEXT:
						((SW_Text*)widg)->c_bg.set_int_color(val);
						break;
					case widgTEXTBOX:
						((SW_TextBox*)widg)->c_bg.set_int_color(val);;
						break;
					case widgSELECTEDTEXT:
						((SW_SelectedText*)widg)->c_bg.set_int_color(val);;
						break;
					case widgTIME:
						((SW_Time*)widg)->c_bg.set_int_color(val);
						break;
					case widgCOUNTER:
						((SW_Counter*)widg)->c_bg.set_int_color(val);
						break;
					case widgBTNCOUNTER:
						((SW_BtnCounter*)widg)->c_bg.set_int_color(val);
						break;
					case widgOLDCTR:
						((SW_Counters*)widg)->c_bg.set_int_color(val);
						break;
					case widgMMAPTITLE:
						((SW_MMapTitle*)widg)->c_bg.set_int_color(val);
						break;
					case widgBGCOLOR:
						((SW_Clear*)widg)->c_bg.set_int_color(val);
						break;
					default:
						bad_subwidg_type("ColorBG", false, ty);
						break;
				}
			}
			break;
		}
		
		case SUBWIDGTY_COLOR_OLINE:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "ColorOutline"))
			{
				auto val = vbound(value/10000,MIN_SUBSCR_COLOR,MAX_SUBSCR_COLOR);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgLINE:
						((SW_Line*)widg)->c_line.set_int_color(val);
						break;
					case widgRECT:
						((SW_Rect*)widg)->c_outline.set_int_color(val);
						break;
					case widgMCGUFF_FRAME:
						((SW_TriFrame*)widg)->c_outline.set_int_color(val);
						break;
					default:
						bad_subwidg_type("ColorOutline", false, ty);
						break;
				}
			}
			break;
		}
		
		case SUBWIDGTY_COLOR_FILL:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "ColorFill"))
			{
				auto val = vbound(value/10000,MIN_SUBSCR_COLOR,MAX_SUBSCR_COLOR);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgRECT:
						((SW_Rect*)widg)->c_fill.set_int_color(val);
						break;
					default:
						bad_subwidg_type("ColorFill", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_BUTTON:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Button"))
			{
				auto val = vbound(value/10000,0,3);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgBTNITM:
						((SW_ButtonItem*)widg)->btn = val;
						break;
					case widgBTNCOUNTER:
						((SW_BtnCounter*)widg)->btn = val;
						break;
					default:
						bad_subwidg_type("Button", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_COUNTERS:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Counter[]"))
			{
				auto val = vbound(value/10000,sscMIN+1,MAX_COUNTERS-1);
				size_t indx = ri->d[rINDEX]/10000;
				size_t sz = 0;
				byte ty = widg->getType();
				switch(ty)
				{
					case widgCOUNTER:
						sz = 3;
						break;
					case widgMISCGAUGE:
						sz = 1;
						break;
					default:
						sz = 0;
						bad_subwidg_type("Counter[]", false, ty);
						break;
				}
				if(!sz) break;
				if(indx >= sz)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreenwidget->Counter[%d]'\n", indx, sz);
					break;
				}
				switch(ty)
				{
					case widgCOUNTER:
						((SW_Counter*)widg)->ctrs[indx] = val;
						break;
					case widgMISCGAUGE:
						((SW_MiscGaugePiece*)widg)->counter = val;
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_MINDIG:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "MinDigits"))
			{
				auto val = vbound(value/10000,0,5);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgCOUNTER:
						((SW_Counter*)widg)->mindigits = val;
						break;
					case widgBTNCOUNTER:
						((SW_BtnCounter*)widg)->mindigits = val;
						break;
					case widgOLDCTR:
						((SW_Counters*)widg)->digits = val;
						break;
					default:
						bad_subwidg_type("MinDigits", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_MAXDIG:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "MaxDigits"))
			{
				auto val = vbound(value/10000,0,5);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgCOUNTER:
						((SW_Counter*)widg)->maxdigits = val;
						break;
					case widgBTNCOUNTER:
						((SW_BtnCounter*)widg)->maxdigits = val;
						break;
					default:
						bad_subwidg_type("MaxDigits", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_INFITM:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "InfiniteItem"))
			{
				auto val = vbound(value/10000,-1,MAXITEMS-1);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgCOUNTER:
						((SW_Counter*)widg)->infitm = val;
						break;
					case widgOLDCTR:
						((SW_Counters*)widg)->infitm = val;
						break;
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						((SW_GaugePiece*)widg)->inf_item = val;
						break;
					default:
						bad_subwidg_type("InfiniteItem", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_INFCHAR:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "InfiniteChar"))
			{
				char val = vbound(value/10000,0,255);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgCOUNTER:
						((SW_Counter*)widg)->infchar = val;
						break;
					case widgBTNCOUNTER:
						((SW_BtnCounter*)widg)->infchar = val;
						break;
					case widgOLDCTR:
						((SW_Counters*)widg)->infchar = val;
						break;
					default:
						bad_subwidg_type("InfiniteChar", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_COSTIND:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "CostIndex"))
			{
				auto val = vbound(value/10000,0,1);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgBTNCOUNTER:
						((SW_BtnCounter*)widg)->costind = val;
						break;
					default:
						bad_subwidg_type("CostIndex", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_COLOR_PLAYER:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "ColorPlayer"))
			{
				auto val = vbound(value/10000,MIN_SUBSCR_COLOR,MAX_SUBSCR_COLOR);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgMMAP:
						((SW_MMap*)widg)->c_plr.set_int_color(val);
						break;
					case widgLMAP:
						((SW_LMap*)widg)->c_plr.set_int_color(val);
						break;
					default:
						bad_subwidg_type("ColorPlayer", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_COLOR_CMPBLNK:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "ColorCompassBlink"))
			{
				auto val = vbound(value/10000,MIN_SUBSCR_COLOR,MAX_SUBSCR_COLOR);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgMMAP:
						((SW_MMap*)widg)->c_cmp_blink.set_int_color(val);
						break;
					default:
						bad_subwidg_type("ColorCompassBlink", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_COLOR_CMPOFF:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "ColorCompassOff"))
			{
				auto val = vbound(value/10000,MIN_SUBSCR_COLOR,MAX_SUBSCR_COLOR);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgMMAP:
						((SW_MMap*)widg)->c_cmp_off.set_int_color(val);
						break;
					default:
						bad_subwidg_type("ColorCompassOff", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_COLOR_ROOM:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "ColorRoom"))
			{
				auto val = vbound(value/10000,MIN_SUBSCR_COLOR,MAX_SUBSCR_COLOR);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgLMAP:
						((SW_LMap*)widg)->c_room.set_int_color(val);
						break;
					default:
						bad_subwidg_type("ColorRoom", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_ITEMCLASS:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "ItemClass"))
			{
				auto val = vbound(value/10000,0,itype_maxusable-1);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgITEMSLOT:
						((SW_ItemSlot*)widg)->iclass = val;
						break;
					default:
						bad_subwidg_type("ItemClass", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_ITEMID:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "ItemID"))
			{
				auto val = vbound(value/10000,-1,MAXITEMS-1);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgITEMSLOT:
						((SW_ItemSlot*)widg)->iid = val;
						break;
					default:
						bad_subwidg_type("ItemID", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_FRAMETILE:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "FrameTile"))
			{
				auto val = vbound(value/10000,0,NEWMAXTILES-1);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgMCGUFF_FRAME:
						((SW_TriFrame*)widg)->frame_tile = val;
						break;
					default:
						bad_subwidg_type("FrameTile", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_FRAMECSET:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "FrameCSet"))
			{
				auto val = vbound(value/10000,0,15);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgMCGUFF_FRAME:
						((SW_TriFrame*)widg)->frame_cset = val;
						break;
					default:
						bad_subwidg_type("FrameCSet", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_PIECETILE:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "PieceTile"))
			{
				auto val = vbound(value/10000,0,NEWMAXTILES-1);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgMCGUFF_FRAME:
						((SW_TriFrame*)widg)->piece_tile = val;
						break;
					default:
						bad_subwidg_type("PieceTile", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_PIECECSET:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "PieceCSet"))
			{
				auto val = vbound(value/10000,0,15);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgMCGUFF_FRAME:
						((SW_TriFrame*)widg)->piece_cset = val;
						break;
					default:
						bad_subwidg_type("PieceCSet", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_FLIP:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Flip"))
			{
				auto val = vbound(value/10000,0,15);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgMCGUFF:
						((SW_McGuffin*)widg)->flip = val;
						break;
					case widgTILEBLOCK:
						((SW_TileBlock*)widg)->flip = val;
						break;
					case widgMINITILE:
						((SW_MiniTile*)widg)->flip = val;
						break;
					default:
						bad_subwidg_type("Flip", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_NUMBER:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Number"))
			{
				auto val = vbound(value/10000,0,255);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgMCGUFF:
						((SW_McGuffin*)widg)->number = val;
						break;
					default:
						bad_subwidg_type("Number", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_CORNER:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Corner[]"))
			{
				auto val = vbound(value/10000,0,3);
				size_t indx = ri->d[rINDEX]/10000;
				size_t sz = 0;
				byte ty = widg->getType();
				switch(ty)
				{
					case widgMINITILE:
						sz = 1;
						break;
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						sz = 4;
						break;
					default:
						sz = 0;
						bad_subwidg_type("Corner[]", false, ty);
						break;
				}
				if(!sz) break;
				if(indx >= sz)
				{
					Z_scripterrlog("Bad index '%d' to array "
						"'subscreenwidget->Corner[%d]'\n", indx, sz);
					break;
				}
				switch(ty)
				{
					case widgMINITILE:
						((SW_MiniTile*)widg)->crn = val;
						break;
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						((SW_GaugePiece*)widg)->mts[indx].setCrn(val);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_FRAMES:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Frames"))
			{
				auto val = vbound(value/10000,1,65535);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						((SW_GaugePiece*)widg)->frames = val;
						break;
					default:
						bad_subwidg_type("Frames", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_SPEED:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Speed"))
			{
				auto val = vbound(value/10000,1,65535);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						((SW_GaugePiece*)widg)->speed = val;
						break;
					default:
						bad_subwidg_type("Speed", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_DELAY:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Delay"))
			{
				auto val = vbound(value/10000,0,65535);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						((SW_GaugePiece*)widg)->delay = val;
						break;
					default:
						bad_subwidg_type("Delay", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_CONTAINER:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Container"))
			{
				auto val = vbound(value/10000,0,65535);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						((SW_GaugePiece*)widg)->container = val;
						break;
					default:
						bad_subwidg_type("Container", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_GAUGE_WID:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "GaugeWid"))
			{
				auto val = vbound(value/10000,1,32)-1;
				auto ty = widg->getType();
				switch(ty)
				{
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						((SW_GaugePiece*)widg)->gauge_wid = val;
						break;
					default:
						bad_subwidg_type("GaugeWid", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_GAUGE_HEI:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "GaugeHei"))
			{
				auto val = vbound(value/10000,1,32)-1;
				auto ty = widg->getType();
				switch(ty)
				{
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						((SW_GaugePiece*)widg)->gauge_hei = val;
						break;
					default:
						bad_subwidg_type("GaugeHei", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_UNITS:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "Units"))
			{
				auto val = vbound(value/10000,1,256);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						((SW_GaugePiece*)widg)->unit_per_frame = val-1;
						break;
					default:
						bad_subwidg_type("Units", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_HSPACE:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "HSpace"))
			{
				auto val = vbound(value/10000,-128,127);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						((SW_GaugePiece*)widg)->hspace = val;
						break;
					default:
						bad_subwidg_type("HSpace", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_VSPACE:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "VSpace"))
			{
				auto val = vbound(value/10000,-128,127);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						((SW_GaugePiece*)widg)->vspace = val;
						break;
					default:
						bad_subwidg_type("VSpace", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_GRIDX:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "GridX"))
			{
				auto val = vbound(value/10000,-32768,32767);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						((SW_GaugePiece*)widg)->grid_xoff = val;
						break;
					default:
						bad_subwidg_type("GridX", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_GRIDY:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "GridY"))
			{
				auto val = vbound(value/10000,-32768,32767);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						((SW_GaugePiece*)widg)->grid_yoff = val;
						break;
					default:
						bad_subwidg_type("GridY", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_ANIMVAL:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "AnimVal"))
			{
				auto val = vbound(value/10000,0,65535);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgLGAUGE:
					case widgMGAUGE:
					case widgMISCGAUGE:
						((SW_GaugePiece*)widg)->anim_val = val;
						break;
					default:
						bad_subwidg_type("AnimVal", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_SHOWDRAIN:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "ShowDrain"))
			{
				auto val = vbound(value/10000,-1,32767);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgMGAUGE:
						((SW_MagicGaugePiece*)widg)->showdrain = val;
						break;
					default:
						bad_subwidg_type("ShowDrain", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_PERCONTAINER:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "PerContainer"))
			{
				auto val = vbound(value/10000,1,65535);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgMISCGAUGE:
						((SW_MiscGaugePiece*)widg)->per_container = val;
						break;
					default:
						bad_subwidg_type("PerContainer", false, ty);
						break;
				}
			}
			break;
		}
		case SUBWIDGTY_TABSIZE:
		{
			if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "TabSize"))
			{
				auto val = vbound(value/10000,0,255);
				auto ty = widg->getType();
				switch(ty)
				{
					case widgTEXTBOX:
						((SW_TextBox*)widg)->tabsize = val;
						break;
					case widgSELECTEDTEXT:
						((SW_SelectedText*)widg)->tabsize = val;
						break;
					default:
						bad_subwidg_type("TabSize", false, ty);
						break;
				}
			}
			break;
		}
		///----------------------------------------------------------------------------------------------------//
		
		default:
		{
			if(arg >= D(0) && arg <= D(7))			ri->d[arg - D(0)] = value;
			else if(arg >= A(0) && arg <= A(1))		ri->a[arg - A(0)] = value;
			else if(arg >= GD(0) && arg <= GD(MAX_SCRIPT_REGISTERS))	game->global_d[arg-GD(0)] = value;
			
			break;
		}
	}
} //end set_register

static std::map<std::string, int> name_to_slot_index_ffcmap;
static std::map<std::string, int> name_to_slot_index_globalmap;
static std::map<std::string, int> name_to_slot_index_genericmap;
static std::map<std::string, int> name_to_slot_index_itemmap;
static std::map<std::string, int> name_to_slot_index_npcmap;
static std::map<std::string, int> name_to_slot_index_ewpnmap;
static std::map<std::string, int> name_to_slot_index_lwpnmap;
static std::map<std::string, int> name_to_slot_index_playermap;
static std::map<std::string, int> name_to_slot_index_dmapmap;
static std::map<std::string, int> name_to_slot_index_screenmap;
static std::map<std::string, int> name_to_slot_index_itemspritemap;
static std::map<std::string, int> name_to_slot_index_comboscriptmap;
static std::map<std::string, int> name_to_slot_index_subscreenmap;

void script_init_name_to_slot_index_maps()
{
	int i;
	#define DECL_INIT_MAP(name) \
	{\
		name_to_slot_index_##name.clear();\
		i = 0;\
		for (auto& it : name)\
		{\
			if (!name_to_slot_index_##name.contains(it.second.scriptname))\
				name_to_slot_index_##name[it.second.scriptname] = i;\
			i++;\
		}\
	}

	DECL_INIT_MAP(ffcmap);
	DECL_INIT_MAP(globalmap);
	DECL_INIT_MAP(genericmap);
	DECL_INIT_MAP(itemmap);
	DECL_INIT_MAP(npcmap);
	DECL_INIT_MAP(ewpnmap);
	DECL_INIT_MAP(lwpnmap);
	DECL_INIT_MAP(playermap);
	DECL_INIT_MAP(dmapmap);
	DECL_INIT_MAP(screenmap);
	DECL_INIT_MAP(itemspritemap);
	DECL_INIT_MAP(comboscriptmap);
	DECL_INIT_MAP(subscreenmap);
}

static void do_get_script_index_by_name(const std::map<std::string, int>& name_to_slot_index)
{
	int32_t arrayptr = get_register(sarg1) / 10000;
	string name;
	int32_t num=-1;
	ArrayH::getString(arrayptr, name, 256); // What's the limit on name length?
	
	auto it = name_to_slot_index.find(name);
	if (it != name_to_slot_index.end())
		num = it->second + 1;
	
	set_register(sarg1, num * 10000);
}

int32_t get_int_arr(const int32_t ptr, int32_t indx)
{
	switch(ptr)
	{
		case INTARR_SCREEN_NPC:
		{
			if(BC::checkGuyIndex(indx, "Screen->NPCs[]") != SH::_NoError)
				return 0;
			return guys.spr(indx)->getUID();
		}
		case INTARR_SCREEN_ITEMSPR:
		{
			if(BC::checkItemIndex(indx, "Screen->Items[]") != SH::_NoError)
				return 0;
			return items.spr(indx)->getUID();
		}
		case INTARR_SCREEN_LWPN:
		{
			if(BC::checkLWeaponIndex(indx, "Screen->LWeapons[]") != SH::_NoError)
				return 0;
			return Lwpns.spr(indx)->getUID();
		}
		case INTARR_SCREEN_EWPN:
		{
			if(BC::checkEWeaponIndex(indx, "Screen->EWeapons[]") != SH::_NoError)
				return 0;
			return Ewpns.spr(indx)->getUID();
		}
		case INTARR_SCREEN_FFC:
		{
			if(BC::checkFFC(indx, "Screen->FFCs[]") != SH::_NoError)
				return 0;
			return indx*10000;
		}
		case INTARR_SCREEN_PORTALS:
		{
			if(BC::checkBoundsOneIndexed(indx, 0, portals.Count()-1, "Screen->Portals[]") != SH::_NoError)
				return 0;
			return portals.spr(indx)->getUID();
		}
		case INTARR_SAVPRTL:
		{
			if(BC::checkBoundsOneIndexed(indx, 0, game->user_portals.size()-1, "Game->SavedPortals[]") != SH::_NoError)
				return 0;
			return (indx+1)*10000;
		}
		default:
		{
			Z_scripterrlog("Unknown internal array '%d' read from!\n", ptr);
			return 0;
		}
	}
}
void set_int_arr(const int32_t ptr, int32_t indx, int32_t val)
{
	switch(ptr)
	{
		case INTARR_SCREEN_NPC:
			Z_scripterrlog("Read-only array 'Screen->NPCs' cannot be written to!\n");
			return;
		case INTARR_SCREEN_ITEMSPR:
			Z_scripterrlog("Read-only array 'Screen->Items' cannot be written to!\n");
			return;
		case INTARR_SCREEN_LWPN:
			Z_scripterrlog("Read-only array 'Screen->LWeapons' cannot be written to!\n");
			return;
		case INTARR_SCREEN_EWPN:
			Z_scripterrlog("Read-only array 'Screen->EWeapons' cannot be written to!\n");
			return;
		case INTARR_SCREEN_FFC:
			Z_scripterrlog("Read-only array 'Screen->FFCs' cannot be written to!\n");
			return;
		case INTARR_SCREEN_PORTALS:
			Z_scripterrlog("Read-only array 'Screen->Portals' cannot be written to!\n");
			return;
		case INTARR_SAVPRTL:
			Z_scripterrlog("Read-only array 'Game->SavedPortals' cannot be written to!\n");
			return;
		
		default:
		{
			Z_scripterrlog("Unknown internal array '%d' written to!\n", ptr);
			return;
		}
	}
}
int32_t sz_int_arr(const int32_t ptr)
{
	switch(ptr)
	{
		case INTARR_SCREEN_NPC:
		{
			return guys.Count();
		}
		case INTARR_SCREEN_ITEMSPR:
		{
			return items.Count();
		}
		case INTARR_SCREEN_LWPN:
		{
			return Lwpns.Count();
		}
		case INTARR_SCREEN_EWPN:
		{
			return Ewpns.Count();
		}
		case INTARR_SCREEN_FFC:
		{
			return MAXFFCS;
		}
		case INTARR_SCREEN_PORTALS:
		{
			return portals.Count();
		}
		case INTARR_SAVPRTL:
		{
			return game->user_portals.size();
		}
		default:
		{
			Z_scripterrlog("Unknown internal array '%d' size read!\n", ptr);
			return -1;
		}
	}
}

///----------------------------------------------------------------------------------------------------//
//                                       ASM Functions                                                 //
///----------------------------------------------------------------------------------------------------//

void retstack_push(int32_t val)
{
	if(ri->retsp >= ret_stack->size())
	{
		Z_scripterrlog("RetStack over or underflow, retstack pointer = %ld\n", ri->retsp);
		return;
	}
	ret_stack->at(ri->retsp++) = val;
}
optional<int32_t> retstack_pop()
{
	if(!ri->retsp)
		return nullopt; //return from root, so, QUIT
	return ret_stack->at(--ri->retsp);
}

void stack_push(int32_t val)
{
	--ri->sp;
	ri->sp &= MASK_SP;
	SH::write_stack(ri->sp, val);
}
void stack_push(int32_t val, size_t count)
{
	for(int q = 0; q < count; ++q)
	{
		--ri->sp;
		ri->sp &= MASK_SP;
		SH::write_stack(ri->sp, val);
	}
}

int32_t stack_pop()
{
	const int32_t val = SH::read_stack(ri->sp);
	++ri->sp;
	ri->sp &= MASK_SP;
	return val;
}
int32_t stack_pop(size_t count)
{
	ri->sp += count;
	ri->sp &= MASK_SP;
	const int32_t val = SH::read_stack((ri->sp-1) & MASK_SP);
	return val;
}

///----------------------------------------------------------------------------------------------------//
//Internal (to ZScript)

void do_set(const bool v, ScriptType whichType, const int32_t whichUID)
{
	bool allowed = true;
	switch(whichType) //Check for objects attempting to change own script
	{
		//case ScriptType::Global:
		
		case ScriptType::FFC:
			if(sarg1==FFSCRIPT && ri->ffcref==whichUID)
				allowed = false;
			break;
		
		case ScriptType::Screen:
			if(sarg1==SCREENSCRIPT) //Only 1 screen script running at a time, no UID check needed
				allowed = false;
			break;
		
		//case ScriptType::Player:
		
		case ScriptType::Item:
		{
			bool collect = ( ( whichUID < 1 ) || (whichUID == COLLECT_SCRIPT_ITEM_ZERO) );
			int32_t new_UID = ( collect ) ? (( whichUID != COLLECT_SCRIPT_ITEM_ZERO ) ? (whichUID * -1) : 0) : whichUID;
			
			if(collect)
			{
				if(sarg1==IDATAPSCRIPT && ri->idata==new_UID)
					allowed = false;
			}
			else if(sarg1==IDATASCRIPT && ri->idata==new_UID)
				allowed = false;
			break;
		}
		
		case ScriptType::Lwpn:
			if(sarg1==LWPNSCRIPT && ri->lwpn==whichUID)
				allowed = false;
			break;
			
		case ScriptType::NPC:
			if(sarg1==NPCSCRIPT && ri->guyref==whichUID)
				allowed = false;
			break;
		
		case ScriptType::Ewpn:
			if(sarg1==EWPNSCRIPT && ri->ewpn==whichUID)
				allowed = false;
			break;
		
		case ScriptType::DMap:
			if(sarg1==DMAPSCRIPT && ri->dmapsref==whichUID)
				allowed = false;
			break;
		
		case ScriptType::ItemSprite:
			if(sarg1==ITEMSPRITESCRIPT && ri->itemref==whichUID)
				allowed = false;
			break;
	}   
	if(!allowed)
	{
		Z_scripterrlog("Script attempted to change own object's script! This has been ignored.\n");
		return;
	}
	int32_t temp = SH::get_arg(sarg2, v);
	set_register(sarg1, temp);
}

void do_push(const bool v)
{
	const int32_t value = SH::get_arg(sarg1, v);
	stack_push(value);
}
void do_push_varg(const bool v)
{
	const int32_t value = SH::get_arg(sarg1, v);
	zs_vargs.push_back(value);
}

void do_push_vargs(const bool v)
{
	if(sarg2 < 1) return;
	const int value = SH::get_arg(sarg1, v);
	zs_vargs.insert(zs_vargs.end(), sarg2, value);
	zs_vargs.push_back(value);
}

void do_pop()
{
	set_register(sarg1, stack_pop());
}

void do_peek()
{
	set_register(sarg1, SH::read_stack(ri->sp));
}

void do_peekat(const bool v)
{
	auto offs = SH::get_arg(sarg2,v);
	set_register(sarg1, SH::read_stack(ri->sp+offs));
}

void do_writeat(const bool v1, const bool v2)
{
	auto val = SH::get_arg(sarg1,v1);
	auto offs = SH::get_arg(sarg2,v2);
	SH::write_stack(ri->sp+offs, val);
}

void do_pops() // Pop past a bunch of stuff at once. Useful for clearing the stack.
{
	set_register(sarg1, stack_pop(sarg2));
}

void do_pushs(const bool v) // Push a bunch of the same thing. Useful for filling the stack.
{
	const int value = SH::get_arg(sarg1, v);
	stack_push(value, sarg2);
}

void do_loadi()
{
	const int32_t stackoffset = get_register(sarg2) / 10000;
	const int32_t value = SH::read_stack(stackoffset);
	set_register(sarg1, value);
}

void do_storei()
{
	const int32_t stackoffset = get_register(sarg2) / 10000;
	const int32_t value = get_register(sarg1);
	SH::write_stack(stackoffset, value);
}

void do_loadd()
{
	const int32_t stackoffset = (sarg2+ri->d[rSFRAME]) / 10000;
	const int32_t value = SH::read_stack(stackoffset);
	set_register(sarg1, value);
}

void do_load()
{
	const int32_t stackoffset = ri->d[rSFRAME] + sarg2;
	const int32_t value = SH::read_stack(stackoffset);
	set_register(sarg1, value);
}

void do_stored(const bool v)
{
	const int32_t stackoffset = (sarg2+ri->d[rSFRAME]) / 10000;
	const int32_t value = SH::get_arg(sarg1, v);
	SH::write_stack(stackoffset, value);
}

void do_store(const bool v)
{
	const int32_t stackoffset = ri->d[rSFRAME] + sarg2;
	const int32_t value = SH::get_arg(sarg1, v);
	SH::write_stack(stackoffset, value);
}

void script_store_object(uint32_t offset, uint32_t new_id)
{
	// Increase, then decrease, to handle the case where a variable (holding the only reference to an object) is assigned to itself.
	// This is unlikely so lets not bother with a conditional that skips both ref modifications when the ids are equal.
	uint32_t id = SH::read_stack(offset);
	script_object_ref_inc(new_id);
	if (ri->stack_pos_is_object.contains(offset))
		script_object_ref_dec(id);
	else
		ri->stack_pos_is_object.insert(offset);

	SH::write_stack(offset, new_id);
}

void do_store_object(const bool v)
{
	const int32_t stackoffset = ri->d[rSFRAME] + sarg2;
	const int32_t new_id = SH::get_arg(sarg1, v);
	script_store_object(stackoffset, new_id);
}

void script_remove_object_ref(int32_t offset)
{
	if (offset < 0 || offset >= MAX_SCRIPT_REGISTERS)
	{
		assert(false);
		return;
	}

	if (!ri->stack_pos_is_object.contains(offset))
		return;

	uint32_t id = SH::read_stack(offset);
	script_object_ref_dec(id);
	ri->stack_pos_is_object.erase(offset);
}

void do_enqueue(const bool)
{
}
void do_dequeue(const bool)
{
}

void do_comp(bool v, const bool inv = false)
{
	bool v2 = false;
	if(inv) zc_swap(v,v2);
	ri->cmp_op2 = SH::get_arg(sarg2, v);
	ri->cmp_op1 = SH::get_arg(sarg1, v2);
	ri->cmp_strcache = nullopt;
}

void do_internal_strcmp()
{
	int32_t arrayptr_a = get_register(sarg1)/10000;
	int32_t arrayptr_b = get_register(sarg2)/10000;
	string strA;
	string strB;
	ArrayH::getString(arrayptr_a, strA);
	ArrayH::getString(arrayptr_b, strB);
	ri->cmp_strcache = strcmp(strA.c_str(), strB.c_str());
}

void do_internal_stricmp()
{
	int32_t arrayptr_a = get_register(sarg1)/10000;
	int32_t arrayptr_b = get_register(sarg2)/10000;
	string strA;
	string strB;
	ArrayH::getString(arrayptr_a, strA);
	ArrayH::getString(arrayptr_b, strB);
	ri->cmp_strcache = stricmp(strA.c_str(), strB.c_str());
}

void do_resize_array()
{
	int32_t size = vbound(get_register(sarg2) / 10000, 0, 214748);
	dword ptrval = get_register(sarg1) / 10000;
	ArrayManager am(ptrval);
	am.resize(size);
}

void do_own_array(dword arrindx, ScriptType scriptType, const int32_t UID)
{
	ArrayManager am(arrindx);
	
	if(am.internal())
	{
		Z_scripterrlog("Cannot 'OwnArray()' an internal array '%d'\n", arrindx);
		return;
	}
	if(arrindx >= NUM_ZSCRIPT_ARRAYS && arrindx < NUM_ZSCRIPT_ARRAYS*2)
	{
		//ignore global arrays
	}
	else if(!am.invalid())
	{
		if(arrindx > 0 && arrindx < NUM_ZSCRIPT_ARRAYS)
		{
			arrayOwner[arrindx].reown(scriptType, UID);
		}
		else if(arrindx < 0) //object array
			Z_scripterrlog("Cannot 'OwnArray()' an object-based array '%d'\n", arrindx);
	}
	else Z_scripterrlog("Tried to 'OwnArray()' an invalid array '%d'\n", arrindx);
}
void do_destroy_array()
{
	dword arrindx = get_register(sarg1) / 10000;
	
	ArrayManager am(arrindx);
	
	if(am.internal())
	{
		Z_scripterrlog("Cannot 'DestroyArray()' an internal array '%d'\n", arrindx);
		return;
	}
	
	if(arrindx >= NUM_ZSCRIPT_ARRAYS && arrindx < NUM_ZSCRIPT_ARRAYS*2)
	{
		//ignore global arrays
	}
	else if(!am.invalid())
	{
		if(arrindx > 0 && arrindx < NUM_ZSCRIPT_ARRAYS)
		{
			arrayOwner[arrindx].clear();
			
			if(localRAM[arrindx].Valid())
				localRAM[arrindx].Clear();
			
			arrayOwner[arrindx].specCleared = true;
		}
		else if(arrindx < 0) //object array
			Z_scripterrlog("Cannot 'DestroyArray()' an object-based array '%d'\n", arrindx);
	}
	else Z_scripterrlog("Tried to 'DestroyArray()' an invalid array '%d'\n", arrindx);
}

static dword allocatemem(int32_t size, bool local, ScriptType type, const uint32_t UID, script_object_type object_type = script_object_type::none)
{
	dword ptrval;
	
	if(size < 0)
	{
		Z_scripterrlog("Array initialized to invalid size of %d\n", size);
		return 0;
	}
	
	if(local)
	{
		//localRAM[0] is used as an invalid container, so 0 can be the NULL pointer in ZScript
		for(ptrval = 1; localRAM[ptrval].Valid(); ptrval++) ;
		
		if(ptrval >= NUM_ZSCRIPT_ARRAYS)
		{
			Z_scripterrlog("%d local arrays already in use, no more can be allocated\n", NUM_ZSCRIPT_ARRAYS-1);
			ptrval = 0;
		}
		else
		{
			ZScriptArray &a = localRAM[ptrval]; //marginally faster for large arrays if we use a reference
			
			a.Resize(size);
			a.setValid(true);
			a.setObjectType(object_type);
			
			for(dword j = 0; j < (dword)size; j++)
				a[j] = 0; //initialize array
				
			// Keep track of which object created the array so we know which to deallocate
			arrayOwner[ptrval].reown(type, UID);
		}
	}
	else
	{
		//Globals are only allocated here at first play, otherwise in init_game
		for(ptrval = 0; game->globalRAM[ptrval].Valid(); ptrval++) ;
		
		if(ptrval >= game->globalRAM.size())
		{
			al_trace("Invalid pointer value of %u passed to global allocate\n", ptrval);
			//this shouldn't happen, unless people are putting ALLOCATEGMEM in their ZASM scripts where they shouldn't be
		}
		
		ZScriptArray &a = game->globalRAM[ptrval];
		
		a.Resize(size);
		a.setValid(true);
		a.setObjectType(object_type);
		
		for(dword j = 0; j < (dword)size; j++)
			a[j] = 0;
			
		ptrval += NUM_ZSCRIPT_ARRAYS; //so each pointer has a unique value
	}

	return ptrval;
}

void do_allocatemem(bool v, const bool local, ScriptType type, const uint32_t UID)
{
	int32_t size = SH::get_arg(sarg2, v) / 10000;
	assert(sarg3 >= 0 && sarg3 <= (int)script_object_type::last);
	dword ptrval = allocatemem(size, local, type, UID, (script_object_type)sarg3);
	set_register(sarg1, ptrval * 10000);
}

void do_deallocatemem()
{
	const int32_t ptrval = get_register(sarg1) / 10000;
	
	FFScript::deallocateZScriptArray(ptrval);
}

void do_loada(const byte a)
{
	if(ri->a[a] == 0)
	{
		Z_eventlog("Global scripts currently have no A registers\n");
		return;
	}
	
	int32_t ffcref = (ri->a[a] / 10000) - 1; //FFC 2
	
	if(BC::checkFFC(ffcref, "LOAD%i") != SH::_NoError)
		return;
		
	int32_t reg = get_register(sarg2); //Register in FFC 2
	
	if(reg >= D(0) && reg <= D(7))
		set_register(sarg1, FFCore.ref(ScriptType::FFC, ffcref).d[reg - D(0)]); //get back the info into *sarg1
	else if(reg == A(0) || reg == A(1))
		set_register(sarg1, FFCore.ref(ScriptType::FFC, ffcref).a[reg - A(0)]);
	else if(reg == SP)
		set_register(sarg1, FFCore.ref(ScriptType::FFC, ffcref).sp * 10000);
		
	//Can get everything else using REFFFC
}

void do_seta(const byte a)
{
	if(ri->a[a] == 0)
	{
		Z_eventlog("Global scripts currently have no A registers\n");
		return;
	}
	
	int32_t ffcref = (ri->a[a] / 10000) - 1; //FFC 2
	
	if(BC::checkFFC(ffcref, "SETA%i") != SH::_NoError)
		return;
		
	int32_t reg = get_register(sarg2); //Register in FFC 2
	
	if(reg >= D(0) && reg <= D(7))
		FFCore.ref(ScriptType::FFC, ffcref).d[reg - D(0)] = get_register(sarg1); //Set it to *sarg1
	else if(reg == A(0) || reg == A(1))
		FFCore.ref(ScriptType::FFC, ffcref).a[reg - A(0)] = get_register(sarg1);
	else if(reg == SP)
		FFCore.ref(ScriptType::FFC, ffcref).sp = get_register(sarg1) / 10000;
}

///----------------------------------------------------------------------------------------------------//
//Mathematical

void do_add(const bool v)
{
	int32_t temp = SH::get_arg(sarg2, v);
	int32_t temp2 = get_register(sarg1);
	
	set_register(sarg1, temp2 + temp);
}

void do_sub(bool v, const bool inv = false)
{
	bool v2 = false;
	if(inv) zc_swap(v,v2);
	auto destreg = (inv ? sarg2 : sarg1);
	int32_t temp = SH::get_arg(sarg2, v);
	int32_t temp2 = SH::get_arg(sarg1, v2);
	//zprint2("Subtraction found: '%d - %d' where '%s - %s'\n", temp2, temp, v2 ? "const" : "reg", v ? "const" : "reg");
	set_register(destreg, temp2 - temp);
}

void do_mult(const bool v)
{
	int64_t temp = SH::get_arg(sarg2, v);
	int32_t temp2 = get_register(sarg1);
	
	set_register(sarg1, int32_t((temp * temp2) / 10000));
}

void do_div(bool v, const bool inv = false)
{
	bool v2 = false;
	if(inv) zc_swap(v,v2);
	auto destreg = (inv ? sarg2 : sarg1);
	int64_t temp = SH::get_arg(sarg2, v);
	int64_t temp2 = SH::get_arg(sarg1, v2);
	
	if(temp == 0)
	{
		Z_scripterrlog("Script attempted to divide %ld by zero!\n", temp2);
		set_register(destreg, int32_t(sign(temp2) * MAX_SIGNED_32));
	}
	else
	{
		set_register(destreg, int32_t((temp2 * 10000) / temp));
	}
}

void do_mod(bool v, const bool inv = false)
{
	bool v2 = false;
	if(inv) zc_swap(v,v2);
	auto destreg = (inv ? sarg2 : sarg1);
	int32_t temp = SH::get_arg(sarg2, v);
	int32_t temp2 = SH::get_arg(sarg1, v2);
	
	if(temp == 0)
	{
		Z_scripterrlog("Script attempted to modulo %ld by zero!\n",temp2);
		temp = 1;
	}
	
	set_register(destreg, temp2 % temp);
}

void do_trig(const bool v, const byte type)
{
	double rangle = (SH::get_arg(sarg2, v) / 10000.0) * PI / 180.0;
	
	switch(type)
	{
		case 0:
			set_register(sarg1, int32_t(zc::math::Sin(rangle) * 10000.0));
			break;
			
		case 1:
			set_register(sarg1, int32_t(zc::math::Cos(rangle) * 10000.0));
			break;
			
		case 2:
			set_register(sarg1, int32_t(zc::math::Tan(rangle) * 10000.0));
			break;
	}
}

void do_degtorad()
{
	double rangle = (SH::get_arg(sarg2, false) / 10000.0) * (PI / 180.0);
	rangle += rangle < 0?-0.00005:0.00005;
	
	set_register(sarg1, int32_t(rangle * 10000.0));
}

void do_radtodeg()
{
	double rangle = (SH::get_arg(sarg2, false) / 10000.0) * (180.0 / PI);
	
	set_register(sarg1, int32_t(rangle * 10000.0));
}

void do_asin(const bool v)
{
	double temp = double(SH::get_arg(sarg2, v)) / 10000.0;
	
	if(temp >= -1 && temp <= 1)
		set_register(sarg1, int32_t(asin(temp) * 10000.0));
	else
	{
		Z_scripterrlog("Script attempted to pass %ld into ArcSin!\n",temp);
		set_register(sarg1, -10000);
	}
}

void do_acos(const bool v)
{
	double temp = double(SH::get_arg(sarg2, v)) / 10000.0;
	
	if(temp >= -1 && temp <= 1)
		set_register(sarg1, int32_t(acos(temp) * 10000.0));
	else
	{
		Z_scripterrlog("Script attempted to pass %ld into ArcCos!\n",temp);
		set_register(sarg1, -10000);
	}
}

void do_arctan()
{
	double xpos = ri->d[rINDEX] / 10000.0;
	double ypos = ri->d[rINDEX2] / 10000.0;
	
	set_register(sarg1, int32_t(atan2(ypos, xpos) * 10000.0));
}

void do_abs(const bool v)
{
	int32_t temp = SH::get_arg(sarg1, v);
	set_register(sarg1, abs(temp));
}

void do_log10(const bool v)
{
	double temp = double(SH::get_arg(sarg1, v)) / 10000.0;
	
	if(temp > 0)
		set_register(sarg1, int32_t(log10(temp) * 10000.0));
	else
	{
		Z_eventlog("Script tried to calculate log of %f\n", temp / 10000.0);
		set_register(sarg1, 0);
	}
}

void do_naturallog(const bool v)
{
	double temp = double(SH::get_arg(sarg1, v)) / 10000.0;
	
	if(temp > 0)
		set_register(sarg1, int32_t(log(temp) * 10000.0));
	// else if(temp == 0)
	// {
		// Z_eventlog("Script tried to calculate ln of 0\n");
		// set_register(sarg1, MIN_SIGNED_32);
	// }
	else
	{
		Z_eventlog("Script tried to calculate ln of %f\n", temp / 10000.0);
		set_register(sarg1, 0);
	}
}

void do_min(const bool v)
{
	int32_t temp = SH::get_arg(sarg2, v);
	int32_t temp2 = get_register(sarg1);
	set_register(sarg1, zc_min(temp2, temp));
}

void do_max(const bool v)
{
	int32_t temp = SH::get_arg(sarg2, v);
	int32_t temp2 = get_register(sarg1);
	
	set_register(sarg1, zc_max(temp2, temp));
}
void do_wrap_rad(const bool v)
{
	ri->d[rEXP1] = wrap_zslong_rad(SH::get_arg(sarg1, v));
}
void do_wrap_deg(const bool v)
{
	ri->d[rEXP1] = wrap_zslong_deg(SH::get_arg(sarg1, v));
}


void do_rnd(const bool v)
{
	int32_t temp = SH::get_arg(sarg2, v) / 10000;

	if(temp > 0)
		set_register(sarg1, (zc_oldrand() % temp) * 10000);
	else if(temp < 0)
		set_register(sarg1, (zc_oldrand() % (-temp)) * -10000);
	else
		set_register(sarg1, 0); // Just return 0. (Do not log an error)
}

void do_srnd(const bool v)
{
	uint32_t seed = SH::get_arg(sarg1, v); //Do not `/10000`- allow the decimal portion to be used! -V
	zc_game_srand(seed);
}

void do_srndrnd()
{
	//Randomize the seed to the current system time, + or - the product of 2 random numbers.
	int32_t seed = time(0) + ((zc_rand() * int64_t(zc_rand())) * (zc_rand(1) ? 1 : -1));
	set_register(sarg1, seed);
	zc_game_srand(seed);
}

//Returns the system Real-Time-Clock value for a specific type. 
void FFScript::getRTC(const bool v)
{
	//int32_t type = get_register(sarg1) / 10000;
	//zprint("FFCore.getRTC() type == %d\n",type);
	//int32_t time = getTime(type);
	//zprint("FFCore.getRTC() time == %d\n",time);
	//zprint("FFCore.getRTC() time * 10000 == %d\n",time);
	//set_register(sarg1, getTime((byte)(SH::get_arg(sarg2, v) / 10000)) * 10000);
	set_register(sarg1, getTime((get_register(sarg1) / 10000)) * 10000);
}


void do_factorial(const bool v)
{
	int32_t temp;
	
	if(v)
		return;  //must factorial a register, not a value (why is this exactly? ~Joe123)
	else
	{
		temp = get_register(sarg1) / 10000;
		
		if(temp < 2)
		{
			set_register(sarg1, temp >= 0 ? 10000 : 00000);
			return;
		}
	}
	
	int32_t temp2 = 1;
	
	for(int32_t temp3 = temp; temp > 1; temp--)
		temp2 *= temp3;
		
	set_register(sarg1, temp2 * 10000);
}

void do_power(bool v, const bool inv = false)
{
	bool v2 = false;
	if(inv) zc_swap(v,v2);
	auto destreg = (inv ? sarg2 : sarg1);
	double temp = double(SH::get_arg(sarg2, v)) / 10000.0;
	double temp2 = double(SH::get_arg(sarg1, v2)) / 10000.0;
	
	if(temp == 0 && temp2 == 0)
	{
		set_register(destreg, 10000);
		return;
	}
	
	set_register(destreg, int32_t(pow(temp2, temp) * 10000.0));
}

void do_lpower(bool v, const bool inv = false)
{
	bool v2 = false;
	if(inv) zc_swap(v,v2);
	auto destreg = (inv ? sarg2 : sarg1);
	int32_t temp = SH::get_arg(sarg2, v);
	int32_t temp2 = SH::get_arg(sarg1, v2);
	
	if(temp == 0 && temp2 == 0)
	{
		set_register(destreg, 1);
		return;
	}
	
	set_register(destreg, int32_t(pow(temp2, temp)));
}

//could use recursion or something to avoid truncation.
void do_ipower(const bool v)
{
	double sarg2val = double(SH::get_arg(sarg2, v));
	if ( sarg2val == 0 )
	{
		Z_scripterrlog("Division by 0 Err: InvPower() exponent divisor cannot be 0!!\n");
		set_register(sarg1, 1);
		return;
	}
	double temp = 10000.0 / sarg2val;
	double temp2 = double(get_register(sarg1)) / 10000.0;
	
	if(temp == 0 && temp2 == 0)
	{
		set_register(sarg1, 1);
		return;
	}
	
	set_register(sarg1, int32_t(pow(temp2, temp) * 10000.0));
}

void do_sqroot(const bool v)
{
	double temp = double(SH::get_arg(sarg2, v)) / 10000.0;
	
	if(temp < 0)
	{
		Z_scripterrlog("Script attempted to calculate square root of %ld!\n", temp);
		set_register(sarg1, -10000);
		return;
	}
	
	set_register(sarg1, int32_t(sqrt(temp) * 10000.0));
}

///----------------------------------------------------------------------------------------------------//
//Bitwise

void do_and(const bool v)
{
	int32_t temp = SH::get_arg(sarg2, v) / 10000;
	int32_t temp2 = get_register(sarg1) / 10000;
	set_register(sarg1, (temp2 & temp) * 10000);
}

void do_and32(const bool v)
{
	int32_t temp = SH::get_arg(sarg2, v);
	int32_t temp2 = get_register(sarg1);
	set_register(sarg1, (temp2 & temp));
}

void do_or(const bool v)
{
	int32_t temp = SH::get_arg(sarg2, v) / 10000;
	int32_t temp2 = get_register(sarg1) / 10000;
	set_register(sarg1, (temp2 | temp) * 10000);
}

void do_or32(const bool v)
{
	int32_t temp = SH::get_arg(sarg2, v);
	int32_t temp2 = get_register(sarg1);
	set_register(sarg1, (temp2 | temp));
}

void do_xor(const bool v)
{
	int32_t temp = SH::get_arg(sarg2, v) / 10000;
	int32_t temp2 = get_register(sarg1) / 10000;
	set_register(sarg1, (temp2 ^ temp) * 10000);
}

void do_xor32(const bool v)
{
	int32_t temp = SH::get_arg(sarg2, v);
	int32_t temp2 = get_register(sarg1);
	set_register(sarg1, (temp2 ^ temp));
}

void do_nand(const bool v)
{
	int32_t temp = SH::get_arg(sarg2, v) / 10000;
	int32_t temp2 = get_register(sarg1) / 10000;
	set_register(sarg1, (~(temp2 & temp)) * 10000);
}

void do_nor(const bool v)
{
	int32_t temp = SH::get_arg(sarg2, v) / 10000;
	int32_t temp2 = get_register(sarg1) / 10000;
	set_register(sarg1, (~(temp2 | temp)) * 10000);
}

void do_xnor(const bool v)
{
	int32_t temp = SH::get_arg(sarg2, v) / 10000;
	int32_t temp2 = get_register(sarg1) / 10000;
	set_register(sarg1, (~(temp2 ^ temp)) * 10000);
}

void do_not(const bool v)
{
	int32_t temp = SH::get_arg(sarg2, v);
	set_register(sarg1, !temp);
}

void do_bitwisenot(const bool v)
{
	int32_t temp = SH::get_arg(sarg1, v) / 10000;
	set_register(sarg1, (~temp) * 10000);
}

void do_bitwisenot32(const bool v)
{
	int32_t temp = SH::get_arg(sarg1, v);
	set_register(sarg1, (~temp));
}

void do_lshift(const bool v)
{
	int32_t temp = SH::get_arg(sarg2, v) / 10000;
	int32_t temp2 = get_register(sarg1) / 10000;
	set_register(sarg1, (temp2 << temp) * 10000);
}

void do_lshift32(const bool v)
{
	int32_t temp = SH::get_arg(sarg2, v) / 10000;
	int32_t temp2 = get_register(sarg1);
	set_register(sarg1, (temp2 << temp));
}

void do_rshift(const bool v)
{
	int32_t temp = SH::get_arg(sarg2, v) / 10000;
	int32_t temp2 = get_register(sarg1) / 10000;
	set_register(sarg1, (temp2 >> temp) * 10000);
}

void do_rshift32(const bool v)
{
	int32_t temp = SH::get_arg(sarg2, v) / 10000;
	int32_t temp2 = get_register(sarg1);
	set_register(sarg1, (temp2 >> temp));
}

///----------------------------------------------------------------------------------------------------//
//Casting

void do_boolcast(const bool isFloat)
{
	set_register(sarg1, (get_register(sarg1) ? (isFloat ? 1 : 10000) : 0));
}

///----------------------------------------------------------------------------------------------------//
//Text ptr functions
void do_fontheight()
{
	int32_t font = get_register(sarg1)/10000;
	ri->d[rEXP1] = text_height(get_zc_font(font))*10000;
}

void do_strwidth()
{
	int32_t strptr = get_register(sarg1)/10000;
	int32_t font = get_register(sarg2)/10000;
	string the_string;
	ArrayH::getString(strptr, the_string, 512);
	ri->d[rEXP1] = text_length(get_zc_font(font), the_string.c_str())*10000;
}

void do_charwidth()
{
	char chr = get_register(sarg1)/10000;
	int32_t font = get_register(sarg2)/10000;
	char *cstr = new char[2];
	cstr[0] = chr;
	cstr[1] = '\0';
	ri->d[rEXP1] = text_length(get_zc_font(font), cstr)*10000;
	delete[] cstr;
}

int32_t do_msgwidth(int32_t msg, char const* str)
{
	if(BC::checkMessage(msg, str) != SH::_NoError)
	{
		return -1;
	}
	
	int32_t v = text_length(get_zc_font(MsgStrings[msg].font),
		MsgStrings[msg].s.substr(0,MsgStrings[msg].s.find_last_not_of(' ')+1).c_str());
	return v;
}

int32_t do_msgheight(int32_t msg, char const* str)
{
	if(BC::checkMessage(msg, str) != SH::_NoError)
	{
		return -1;
	}
	return text_height(get_zc_font(MsgStrings[msg].font));
}

///----------------------------------------------------------------------------------------------------//
//Gameplay functions

void do_warp(bool v)
{
	int32_t dmapid = SH::get_arg(sarg1, v) / 10000;
	int32_t screenid = SH::get_arg(sarg2, v) / 10000;
	if ( ((unsigned)dmapid) >= MAXDMAPS ) 
	{
		Z_scripterrlog("Invalid DMap ID (%d) passed to Warp(). Aborting.\n", dmapid);
		return;
	}
	if ( ((unsigned)screenid) >= MAPSCRS ) 
	{
		Z_scripterrlog("Invalid Screen ID (%d) passed to Warp(). Aborting.\n", screenid);
		return;
	}
	if ( DMaps[dmapid].map*MAPSCRS+DMaps[dmapid].xoff+screenid >= (int32_t)TheMaps.size() )
	{
		Z_scripterrlog("Invalid destination passed to Warp(). Aborting.\n");
		return;
	}
	tmpscr->sidewarpdmap[0] = dmapid;
	tmpscr->sidewarpscr[0]  = screenid;
	tmpscr->sidewarptype[0] = wtIWARP;
	if(!get_qr(qr_OLD_HERO_WARP_RETSQUARE))
	{
		tmpscr->warpreturnc &= ~(3 << 8);
		set_bit(&tmpscr->sidewarpoverlayflags,0,0);
	}
	Hero.ffwarp = true;
}

void do_pitwarp(bool v)
{
	int32_t dmapid = SH::get_arg(sarg1, v) / 10000;
	int32_t screenid = SH::get_arg(sarg2, v) / 10000;
	if ( ((unsigned)dmapid) >= MAXDMAPS ) 
	{
		Z_scripterrlog("Invalid DMap ID (%d) passed to PitWarp(). Aborting.\n", dmapid);
		return;
	}
	if ( ((unsigned)screenid) >= MAPSCRS ) 
	{
		Z_scripterrlog("Invalid Screen ID (%d) passed to PitWarp(). Aborting.\n", screenid);
		return;
	}
	//Extra sanity guard. 
	if ( DMaps[dmapid].map*MAPSCRS+DMaps[dmapid].xoff+screenid >= (int32_t)TheMaps.size() )
	{
		Z_scripterrlog("Invalid destination passed to Warp(). Aborting.\n");
		return;
	}
	tmpscr->sidewarpdmap[0] = dmapid;
	tmpscr->sidewarpscr[0]  = screenid;
	tmpscr->sidewarptype[0] = wtIWARP;
	if(!get_qr(qr_OLD_HERO_WARP_RETSQUARE))
	{
		tmpscr->warpreturnc &= ~(3 << 8);
		set_bit(&tmpscr->sidewarpoverlayflags,0,0);
	}
	Hero.ffwarp = true;
	Hero.ffpit = true;
}

void do_breakshield()
{
	int32_t UID = get_register(sarg1);
	
	for(int32_t j = 0; j < guys.Count(); j++)
		if(guys.spr(j)->getUID() == UID)
		{
			((enemy*)guys.spr(j))->break_shield();
			return;
		}
}

void do_showsavescreen()
{
	bool didsaved = save_game(false, 0);
	set_register(sarg1, didsaved ? 10000 : 0);
}

void do_selectweapon(bool v, int32_t btn)
{
	switch(btn)
	{
		case 1:
			if(!get_qr(qr_SELECTAWPN))
				return;
			break;
		case 2:
			if(!get_qr(qr_SET_XBUTTON_ITEMS))
				return;
			break;
		case 3:
			if(!get_qr(qr_SET_YBUTTON_ITEMS))
				return;
			break;
	}
		
	byte dir=(byte)(SH::get_arg(sarg1, v)/10000);
	
	// Selection directions don't match the normal ones...
	switch(dir)
	{
	case 0:
		dir=SEL_UP;
		break;
		
	case 1:
		dir=SEL_DOWN;
		break;
		
	case 2:
		dir=SEL_LEFT;
		break;
		
	case 3:
		dir=SEL_RIGHT;
		break;
		
	default:
		return;
	}
	
	switch(btn)
	{
		case 0:
			selectNextBWpn(dir);
			break;
		case 1:
			selectNextAWpn(dir);
			break;
		case 2:
			selectNextXWpn(dir);
			break;
		case 3:
			selectNextYWpn(dir);
			break;
	}
}

///----------------------------------------------------------------------------------------------------//
//Screen Information

void do_issolid()
{
	int32_t x = int32_t(ri->d[rINDEX] / 10000);
	int32_t y = int32_t(ri->d[rINDEX2] / 10000);
	
	set_register(sarg1, (_walkflag(x, y, 1) ? 10000 : 0));
}

void do_mapdataissolid()
{
	if ( ri->mapsref == MAX_SIGNED_32  )
	{
		Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","isSolid()");
		set_register(sarg1,10000);
	}
	else
	{
		//mapscr *m = GetMapscr(ri->mapsref); 
		int32_t x = int32_t(ri->d[rINDEX] / 10000);
		int32_t y = int32_t(ri->d[rINDEX2] / 10000);
		switch(ri->mapsref)
		{
			case MAPSCR_TEMP0:
				set_register(sarg1, (_walkflag(x, y, 1)) ? 10000 : 0);
				break;
			case MAPSCR_SCROLL0:
				set_register(sarg1, (_walkflag(x, y, 1, FFCore.ScrollingScreens[0], FFCore.ScrollingScreens[1], FFCore.ScrollingScreens[2])) ? 10000 : 0);
				break;
			default:
				set_register(sarg1, (_walkflag(x, y, 1, GetMapscr(ri->mapsref)) ? 10000 : 0));
		}
	}
}

void do_mapdataissolid_layer()
{
	if ( ri->mapsref == MAX_SIGNED_32  )
	{
		Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","isSolidLayer()");
		set_register(sarg1,10000);
	}
	else
	{
		//mapscr *m = GetMapscr(ri->mapsref); 
		int32_t x = int32_t(ri->d[rINDEX] / 10000);
		int32_t y = int32_t(ri->d[rINDEX2] / 10000);
		int32_t layer = int32_t(ri->d[rEXP1] / 10000);
		if(BC::checkBounds(layer, 0, 6, "mapdata->isSolidLayer()") != SH::_NoError)
		{
			set_register(sarg1,10000);
		}
		else
		{
			switch(ri->mapsref)
			{
				case MAPSCR_TEMP0:
					set_register(sarg1, (_walkflag_layer(x, y, 1, FFCore.tempScreens[layer])) ? 10000 : 0);
					break;
				case MAPSCR_SCROLL0:
					set_register(sarg1, (_walkflag_layer(x, y, 1, FFCore.ScrollingScreens[layer])) ? 10000 : 0);
					break;
				default:
					mapscr* m = GetMapscr(ri->mapsref);
					if(layer > 0)
					{
						if(m->layermap[layer] == 0)
						{
							set_register(sarg1,10000);
							break;
						}
						m = &TheMaps[(m->layermap[layer]*MAPSCRS + m->layerscreen[layer])];
					}
					set_register(sarg1, (_walkflag_layer(x, y, 1, m) ? 10000 : 0));
					break;
			}
		}
	}
}

void do_issolid_layer()
{
	int32_t x = int32_t(ri->d[rINDEX] / 10000);
	int32_t y = int32_t(ri->d[rINDEX2] / 10000);
	int32_t layer = int32_t(ri->d[rEXP1] / 10000);
	if(BC::checkBounds(layer, 0, 6, "Screen->isSolidLayer()") != SH::_NoError)
	{
		set_register(sarg1,10000);
	}
	else
	{
		set_register(sarg1, (_walkflag_layer(x, y, 1, FFCore.tempScreens[layer])) ? 10000 : 0);
	}
}

void do_setsidewarp()
{
	int32_t warp   = SH::read_stack(ri->sp + 3) / 10000;
	int32_t scrn = SH::read_stack(ri->sp + 2) / 10000;
	int32_t dmap   = SH::read_stack(ri->sp + 1) / 10000;
	int32_t type   = SH::read_stack(ri->sp + 0) / 10000;
	
	if(BC::checkBounds(warp, -1, 3, "Screen->SetSideWarp") != SH::_NoError ||
			BC::checkBounds(scrn, -1, 0x87, "Screen->SetSideWarp") != SH::_NoError ||
			BC::checkBounds(dmap, -1, MAXDMAPS - 1, "Screen->SetSideWarp") != SH::_NoError ||
			BC::checkBounds(type, -1, wtMAX - 1, "Screen->SetSideWarp") != SH::_NoError)
		return;
		
	if(scrn > -1)
		tmpscr->sidewarpscr[warp] = scrn;
		
	if(dmap > -1)
		tmpscr->sidewarpdmap[warp] = dmap;
		
	if(type > -1)
		tmpscr->sidewarptype[warp] = type;
}

void do_settilewarp()
{
	int32_t warp   = SH::read_stack(ri->sp + 3) / 10000;
	int32_t scrn = SH::read_stack(ri->sp + 2) / 10000;
	int32_t dmap   = SH::read_stack(ri->sp + 1) / 10000;
	int32_t type   = SH::read_stack(ri->sp + 0) / 10000;
	
	if(BC::checkBounds(warp, -1, 3, "Screen->SetTileWarp") != SH::_NoError ||
			BC::checkBounds(scrn, -1, 0x87, "Screen->SetTileWarp") != SH::_NoError ||
			BC::checkBounds(dmap, -1, MAXDMAPS - 1, "Screen->SetTileWarp") != SH::_NoError ||
			BC::checkBounds(type, -1, wtMAX - 1, "Screen->SetTileWarp") != SH::_NoError)
		return;
		
	if(scrn > -1)
		tmpscr->tilewarpscr[warp] = scrn;
		
	if(dmap > -1)
		tmpscr->tilewarpdmap[warp] = dmap;
		
	if(type > -1)
		tmpscr->tilewarptype[warp] = type;
}

void do_getsidewarpdmap(const bool v)
{
	int32_t warp = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkBounds(warp, -1, 3, "Screen->GetSideWarpDMap") != SH::_NoError)
	{
		set_register(sarg1, -10000);
		return;
	}
	
	set_register(sarg1, tmpscr->sidewarpdmap[warp]*10000);
}

void do_getsidewarpscr(const bool v)
{
	int32_t warp = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkBounds(warp, -1, 3, "Screen->GetSideWarpScreen") != SH::_NoError)
	{
		set_register(sarg1, -10000);
		return;
	}
	
	set_register(sarg1, tmpscr->sidewarpscr[warp]*10000);
}

void do_getsidewarptype(const bool v)
{
	int32_t warp = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkBounds(warp, -1, 3, "Screen->GetSideWarpType") != SH::_NoError)
	{
		set_register(sarg1, -10000);
		return;
	}
	
	set_register(sarg1, tmpscr->sidewarptype[warp]*10000);
}

void do_gettilewarpdmap(const bool v)
{
	int32_t warp = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkBounds(warp, -1, 3, "Screen->GetTileWarpDMap") != SH::_NoError)
	{
		set_register(sarg1, -10000);
		return;
	}
	
	set_register(sarg1, tmpscr->tilewarpdmap[warp]*10000);
}

void do_gettilewarpscr(const bool v)
{
	int32_t warp = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkBounds(warp, -1, 3, "Screen->GetTileWarpScreen") != SH::_NoError)
	{
		set_register(sarg1, -10000);
		return;
	}
	
	set_register(sarg1, tmpscr->tilewarpscr[warp]*10000);
}

void do_gettilewarptype(const bool v)
{
	int32_t warp = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkBounds(warp, -1, 3, "Screen->GetTileWarpType") != SH::_NoError)
	{
		set_register(sarg1, -10000);
		return;
	}
	
	set_register(sarg1, tmpscr->tilewarptype[warp]*10000);
}

void do_layerscreen()
{
	int32_t layer = (get_register(sarg2) / 10000) - 1;
	
	if(BC::checkBounds(layer, 0, 5, "Screen->LayerScreen") != SH::_NoError ||
			tmpscr->layermap[layer] == 0)
		set_register(sarg1, -10000);
	else
		set_register(sarg1, tmpscr->layerscreen[layer] * 10000);
}

void do_layermap()
{
	int32_t layer = (get_register(sarg2) / 10000) - 1;
	
	if(BC::checkBounds(layer, 0, 5, "Screen->LayerMap") != SH::_NoError ||
			tmpscr->layermap[layer] == 0)
		set_register(sarg1, -10000);
	else
		set_register(sarg1, tmpscr->layermap[layer] * 10000);
}


	

void do_triggersecrets()
{
	hidden_entrance(0, true, false, -4);
	//hidden_entrance(0,true,single16,scombo); 
	//bool findentrance(int32_t x, int32_t y, int32_t flag, bool setflag)
	//We need a variation on these that triggers any combos with a given flag. -Z
}



void do_getscreenforcombopos(const bool v)
{
	int rpos = (SH::get_arg(sarg1, v) / 10000);
	
	if (BC::checkBoundsPos(rpos, 0, 175, "Region->GetScreenForComoboPos") != SH::_NoError)
	{
		set_register(sarg1, -10000);
		return;
	}

	set_register(sarg1, currscr * 10000);
}



void do_getscreenflags()
{
	int32_t map     = (ri->d[rEXP1] / 10000) - 1;
	int32_t scrn  = ri->d[rINDEX2] / 10000;
	int32_t flagset = ri->d[rINDEX] / 10000;
	
	if(BC::checkMapID(map, "Game->GetScreenFlags") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetScreenFlags") != SH::_NoError ||
			BC::checkBounds(flagset, 0, 9, "Game->GetScreenFlags") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenflags(&TheMaps[map * MAPSCRS + scrn], flagset));
}

void do_getscreeneflags()
{
	int32_t map     = (ri->d[rEXP1] / 10000) - 1;
	int32_t scrn  = ri->d[rINDEX2] / 10000;
	int32_t flagset = ri->d[rINDEX] / 10000;
	
	if(BC::checkMapID(map, "Game->GetScreenEFlags") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetScreenEFlags") != SH::_NoError ||
			BC::checkBounds(flagset, 0, 9, "Game->GetScreenEFlags") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screeneflags(&TheMaps[map * MAPSCRS + scrn], flagset));
}

void FFScript::do_graphics_getpixel()
{
	int32_t yoffset = 0;
	const bool brokenOffset= ( (get_er(er_BITMAPOFFSET)!=0) || (get_qr(qr_BITMAPOFFSETFIX)!=0) );
	int32_t ref = (ri->d[rEXP1]);
	
	BITMAP *bitty = FFCore.GetScriptBitmap(ref);
	int32_t xpos  = ri->d[rINDEX2] / 10000;
	
	if(!brokenOffset && (ref-10) == -1 )
	{
		yoffset = 56; //should this be -56?
	}
	else
	{
		yoffset = 0;
	}
	
	int32_t ypos = (ri->d[rINDEX] / 10000)+yoffset;
	if(!bitty)
	{
		bitty = scrollbuf;
	}
	
	int32_t ret =  getpixel(bitty, xpos, ypos); //This is a palette index value. 
	
	if(!get_qr(qr_BROKEN_GETPIXEL_VALUE))
		ret *= 10000;
	set_register(sarg1, ret);
}

//Some of these need to be reduced to two inputs. -Z

int32_t get_screendoor(mapscr *m, int32_t d)
{
	int32_t f = m->door[d];
	return f*10000;
}



int32_t get_screenlayeropacity(mapscr *m, int32_t d)
{
	int32_t f = m->layeropacity[d]; //6 of these
	return f*10000;
}

int32_t get_screensecretcombo(mapscr *m, int32_t d)
{
	int32_t f = m->secretcombo[d]; //128 of these
	return f*10000;
}

int32_t get_screensecretcset(mapscr *m, int32_t d)
{
	int32_t f = m->secretcset[d]; //128 of these
	return f*10000;
}

int32_t get_screensecretflag(mapscr *m, int32_t d)
{
	int32_t f = m->secretflag[d]; //128 of these
	return f*10000;
}

int32_t get_screenlayermap(mapscr *m, int32_t d)
{
	int32_t f = m->layermap[d]; //6 of these
	return f*10000;
}

int32_t get_screenlayerscreen(mapscr *m, int32_t d)
{
	int32_t f = m->layerscreen[d]; //6 of these
	return f*10000;
}

int32_t get_screenpath(mapscr *m, int32_t d)
{
	int32_t f = m->path[d]; //4 of these
	return f*10000;
}

int32_t get_screenwarpReturnX(mapscr *m, int32_t d)
{
	int32_t f = m->warpreturnx[d]; //4 of these
	return f*10000;
}

int32_t get_screenwarpReturnY(mapscr *m, int32_t d)
{
	int32_t f = m->warpreturny[d]; //4 of these
	return f*10000;
}
//One too many inputs here. -Z
int32_t get_screenGuy(mapscr *m)
{
	int32_t f = m->guy;
	return f*10000;
}
//One too many inputs here. -Z
int32_t get_screenString(mapscr *m)
{
	int32_t f = m->str;
	return f*10000;
}
//One too many inputs here. -Z
int32_t get_screenRoomtype(mapscr *m)
{
	int32_t f = m->room;
	return f*10000;
}
//One too many inputs here. -Z
int32_t get_screenEntryX(mapscr *m)
{
	int32_t f = m->entry_x;
	return f*10000;
}
//One too many inputs here. -Z
int32_t get_screenEntryY(mapscr *m)
{
	int32_t f = m->entry_y;
	return f*10000;
}
//One too many inputs here. -Z
int32_t get_screenitem(mapscr *m)
{
	int32_t f = m->item;
	return f*10000;
}
//One too many inputs here. -Z
int32_t get_screenundercombo(mapscr *m)
{
	int32_t f = m->undercombo;
	return f*10000;
}
//One too many inputs here. -Z
int32_t get_screenundercset(mapscr *m)
{
	int32_t f = m->undercset;
	return f*10000;
}
//One too many inputs here. -Z
int32_t get_screenatchall(mapscr *m)
{
	int32_t f = m->catchall;
	return f*10000;
}
void do_getscreenLayerOpacity()
{
	int32_t map     = (ri->d[rEXP1] / 10000) - 1;
	int32_t scrn  = ri->d[rINDEX2] / 10000;
	int32_t d = ri->d[rINDEX] / 10000;
	
	if(BC::checkMapID(map, "Game->GetLayerOpacity(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetLayerOpacity(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 6, "Game->GetLayerOpacity(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenlayeropacity(&TheMaps[map * MAPSCRS + scrn], d));
}
void do_getscreenSecretCombo()
{
	int32_t map     = (ri->d[rEXP1] / 10000) - 1;
	int32_t scrn  = ri->d[rINDEX2] / 10000;
	int32_t d = ri->d[rINDEX] / 10000;
	
	if(BC::checkMapID(map, "Game->GetSecretCombo(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetSecretCombo(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 127, "Game->GetSecretCombo(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screensecretcombo(&TheMaps[map * MAPSCRS + scrn], d));
}

void do_getscreenSecretCSet()
{
	int32_t map     = (ri->d[rEXP1] / 10000) - 1;
	int32_t scrn  = ri->d[rINDEX2] / 10000;
	int32_t d = ri->d[rINDEX] / 10000;
	
	if(BC::checkMapID(map, "Game->GetSecretCSet(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetSecretCSet(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 127, "Game->GetSecretCSet(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screensecretcset(&TheMaps[map * MAPSCRS + scrn], d));
}

void do_getscreenSecretFlag()
{
	int32_t map     = (ri->d[rEXP1] / 10000) - 1;
	int32_t scrn  = ri->d[rINDEX2] / 10000;
	int32_t d = ri->d[rINDEX] / 10000;
	
	if(BC::checkMapID(map, "Game->GetSecretFlag(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetSecretFlag(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0,127, "Game->GetSecretFlag(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screensecretflag(&TheMaps[map * MAPSCRS + scrn], d));
}
void do_getscreenLayerMap()
{
	int32_t map     = (ri->d[rEXP1] / 10000) - 1;
	int32_t scrn  = ri->d[rINDEX2] / 10000;
	int32_t d = ri->d[rINDEX] / 10000;
	
	if(BC::checkMapID(map, "Game->GetSreenLayerMap(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetSreenLayerMap(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 6, "Game->GetSreenLayerMap(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenlayermap(&TheMaps[map * MAPSCRS + scrn], d));
}
void do_getscreenLayerscreen()
{
	int32_t map     = (ri->d[rEXP1] / 10000) - 1;
	int32_t scrn  = ri->d[rINDEX2] / 10000;
	int32_t d = ri->d[rINDEX] / 10000;
	
	if(BC::checkMapID(map, "Game->GetSreenLayerScreen(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetSreenLayerScreen(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 6, "Game->GetSreenLayerScreen(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenlayerscreen(&TheMaps[map * MAPSCRS + scrn], d));
}
void do_getscreenPath()
{
	int32_t map     = (ri->d[rEXP1] / 10000) - 1;
	int32_t scrn  = ri->d[rINDEX2] / 10000;
	int32_t d = ri->d[rINDEX] / 10000;
	
	if(BC::checkMapID(map, "Game->GetSreenPath(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetSreenPath(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 3, "Game->GetSreenPath(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenpath(&TheMaps[map * MAPSCRS + scrn], d));
}
void do_getscreenWarpReturnX()
{
	int32_t map     = (ri->d[rEXP1] / 10000) - 1;
	int32_t scrn  = ri->d[rINDEX2] / 10000;
	int32_t d = ri->d[rINDEX] / 10000;
	
	if(BC::checkMapID(map, "Game->GetScreenWarpReturnX(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetScreenWarpReturnX(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 3, "Game->GetScreenWarpReturnX(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenwarpReturnX(&TheMaps[map * MAPSCRS + scrn], d));
}
void do_getscreenWarpReturnY()
{
	int32_t map     = (ri->d[rEXP1] / 10000) - 1;
	int32_t scrn  = ri->d[rINDEX2] / 10000;
	int32_t d = ri->d[rINDEX] / 10000;
	
	if(BC::checkMapID(map, "Game->GetScreenWarpReturnY(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetScreenWarpReturnY(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 3, "Game->GetScreenWarpReturnY(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenwarpReturnY(&TheMaps[map * MAPSCRS + scrn], d));
}

/*
//One too many inputs here. -Z
void do_getscreenatchall()
{
	int32_t map     = (ri->d[rEXP1] / 10000) - 1;
	int32_t scrn  = ri->d[rINDEX2] / 10000;
	int32_t d = ri->d[rINDEX] / 10000;
	
	if(BC::checkMapID(map, "Game->GetScreenCatchall(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetScreenCatchall(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 6, "Game->GetScreenCatchall(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenatchall(&TheMaps[map * MAPSCRS + scrn], d));
}


//One too many inputs here. -Z
void do_getscreenUndercombo()
{
	int32_t map     = (ri->d[rEXP1] / 10000) - 1;
	int32_t scrn  = ri->d[rINDEX2] / 10000;
	int32_t d = ri->d[rINDEX] / 10000;
	
	if(BC::checkMapID(map, "Game->GetcreenUndercombo(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetcreenUndercombo(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 6, "Game->GetcreenUndercombo(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenundercombo(&TheMaps[map * MAPSCRS + scrn], d));
}
//One too many inputs here. -Z
void do_getscreenUnderCSet()
{
	int32_t map     = (ri->d[rEXP1] / 10000) - 1;
	int32_t scrn  = ri->d[rINDEX2] / 10000;
	int32_t d = ri->d[rINDEX] / 10000;
	
	if(BC::checkMapID(map, "Game->GeScreenUnderCSet(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GeScreenUnderCSet(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 6, "Game->GeScreenUnderCSet(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenundercset(&TheMaps[map * MAPSCRS + scrn], d));
}

//One too many inputs here. -Z
void do_getscreenGuy()
{
	int32_t map     = (ri->d[rEXP1] / 10000) - 1;
	int32_t scrn  = ri->d[rINDEX2] / 10000;
	int32_t d = ri->d[rINDEX] / 10000;
	
	if(BC::checkMapID(map, "Game->GetScreenGuy(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetScreenGuy(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 214747, "Game->GetScreenGuy(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenGuy(&TheMaps[map * MAPSCRS + scrn], d));
}
//One too many inputs here. -Z
void do_getscreenString()
{
	int32_t map     = (ri->d[rEXP1] / 10000) - 1;
	int32_t scrn  = ri->d[rINDEX2] / 10000;
	int32_t d = ri->d[rINDEX] / 10000;
	
	if(BC::checkMapID(map, "Game->GetScreenString(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetScreenString(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 214747, "Game->GetScreenString(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenString(&TheMaps[map * MAPSCRS + scrn], d));
}
//One too many inputs here. -Z
void do_getscreenRoomType()
{
	int32_t map     = (ri->d[rEXP1] / 10000) - 1;
	int32_t scrn  = ri->d[rINDEX2] / 10000;
	int32_t d = ri->d[rINDEX] / 10000;
	
	if(BC::checkMapID(map, "Game->GetScreenRoomType(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetScreenRoomType(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 214747, "Game->GetScreenRoomType(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenRoomtype(&TheMaps[map * MAPSCRS + scrn], d));
}
//One too many inputs here. -Z
void do_getscreenEntryX()
{
	int32_t map     = (ri->d[rEXP1] / 10000) - 1;
	int32_t scrn  = ri->d[rINDEX2] / 10000;
	int32_t d = ri->d[rINDEX] / 10000;
	
	if(BC::checkMapID(map, "Game->GetScreenEntryX(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetScreenEntryX(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 214747, "Game->GetScreenEntryX(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenEntryX(&TheMaps[map * MAPSCRS + scrn], d));
}
//One too many inputs here. -Z
void do_getscreenEntryY()
{
	int32_t map     = (ri->d[rEXP1] / 10000) - 1;
	int32_t scrn  = ri->d[rINDEX2] / 10000;
	int32_t d = ri->d[rINDEX] / 10000;
	
	if(BC::checkMapID(map, "Game->GetScreenEntryY(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetScreenEntryY(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 214747, "Game->GetScreenEntryY(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenEntryY(&TheMaps[map * MAPSCRS + scrn], d));
}
//One too many inputs here. -Z
void do_getscreenItem()
{
	int32_t map     = (ri->d[rEXP1] / 10000) - 1;
	int32_t scrn  = ri->d[rINDEX2] / 10000;
	int32_t d = ri->d[rINDEX] / 10000;
	
	if(BC::checkMapID(map, "Game->GetScreenItem(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetScreenItem(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 255, "Game->GetScreenItem(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenitem(&TheMaps[map * MAPSCRS + scrn], d));
}
*/
void do_getscreendoor()
{
	int32_t map     = (ri->d[rEXP1] / 10000) - 1;
	int32_t scrn  = ri->d[rINDEX2] / 10000;
	int32_t door = ri->d[rINDEX] / 10000;
	
	if(BC::checkMapID(map, "Game->GetScreenDoor(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetScreenDoor(...screen...)") != SH::_NoError ||
			BC::checkBounds(door, 0, 3, "Game->GetScreenDoor(...doorindex...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screendoor(&TheMaps[map * MAPSCRS + scrn], door));
}

int32_t get_screennpc(mapscr *m, int32_t index)
{
	int32_t f = m->enemy[index];
	return f*10000;
}


void do_getscreennpc()
{
	int32_t map     = (ri->d[rEXP1] / 10000) - 1;
	int32_t scrn  = ri->d[rINDEX2] / 10000;
	int32_t enemy = ri->d[rINDEX] / 10000;
	
	if(BC::checkMapID(map, "Game->GetScreenEnemy(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetScreenEnemy(...screen...)") != SH::_NoError ||
			BC::checkBounds(enemy, 0, 9, "Game->GetScreenEnemy(...enemy...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screennpc(&TheMaps[map * MAPSCRS + scrn], enemy));
}


///----------------------------------------------------------------------------------------------------//
//Pointer handling

bool is_valid_array(int32_t ptr)
{
	if(!ptr) return false;
	
	if(ptr < 0) //An object array?
	{
		int32_t objptr = -ptr;
		auto it = objectRAM.find(objptr);
		if(it == objectRAM.end())
			return false;
		return true;
	}
	else if(ptr >= NUM_ZSCRIPT_ARRAYS) //check global
	{
		dword gptr = ptr - NUM_ZSCRIPT_ARRAYS;
		
		if(gptr > game->globalRAM.size())
			return false;
		else return game->globalRAM[gptr].Valid();
	}
	else
	{
		return localRAM[ptr].Valid();
	}
}

void do_isvalidarray()
{
	int32_t ptr = get_register(sarg1)/10000;
	
	set_register(sarg1,is_valid_array(ptr) ? 10000 : 0);
}

void do_isvaliditem()
{
	int32_t IID = get_register(sarg1);
	//int32_t ct = items.Count();
  
	//for ( int32_t j = items.Count()-1; j >= 0; --j )
	for(int32_t j = 0; j < items.Count(); j++)
	//for(int32_t j = 0; j < ct; j++)
		if(items.spr(j)->getUID() == IID)
		{
			set_register(sarg1, 10000);
			return;
		}
		
	set_register(sarg1, 0);
}

void do_isvalidnpc()
{
	int32_t UID = get_register(sarg1);
	//for ( int32_t j = guys.Count()-1; j >= 0; --j )
	//int32_t ct = guys.Count(); 
	
	for(int32_t j = 0; j < guys.Count(); j++)
	//for(int32_t j = 0; j < ct; j++)
		if(guys.spr(j)->getUID() == UID)
		{
			set_register(sarg1, 10000);
			return;
		}
		
	set_register(sarg1, 0);
}

void do_isvalidlwpn()
{
	int32_t WID = get_register(sarg1);
	//int32_t ct = Lwpns.Count();
	
	//for ( int32_t j = Lwpns.Count()-1; j >= 0; --j )
	for(int32_t j = 0; j < Lwpns.Count(); j++)
	//for(int32_t j = 0; j < ct; j++)
		if(Lwpns.spr(j)->getUID() == WID)
		{
			set_register(sarg1, 10000);
			return;
		}
		
	set_register(sarg1, 0);
}

void do_isvalidewpn()
{
	int32_t WID = get_register(sarg1);
	// int32_t ct = Ewpns.Count();
	
	// for ( int32_t j = Ewpns.Count()-1; j >= 0; --j )
	for(int32_t j = 0; j < Ewpns.Count(); j++)
	//for(int32_t j = 0; j < ct; j++)
		if(Ewpns.spr(j)->getUID() == WID)
		{
			set_register(sarg1, 10000);
			return;
		}
		
	set_register(sarg1, 0);
}

void do_lwpnmakeangular()
{
	if(LwpnH::loadWeapon(ri->lwpn, "lweapon->MakeAngular") == SH::_NoError)
	{
		if (!LwpnH::getWeapon()->angular)
		{
			double vx;
			double vy;
			switch(NORMAL_DIR(LwpnH::getWeapon()->dir))
			{
				case l_up:
				case l_down:
				case left:
					vx = -1.0*((weapon*)s)->step;
					break;
				case r_down:
				case r_up:
				case right:
					vx = ((weapon*)s)->step;
					break;
					
				default:
					vx = 0;
					break;
			}
			switch(NORMAL_DIR(LwpnH::getWeapon()->dir))
			{
				case l_up:
				case r_up:
				case up:
					vy = -1.0*((weapon*)s)->step;
					break;
				case l_down:
				case r_down:
				case down:
					vy = ((weapon*)s)->step;
					break;
					
				default:
					vy = 0;
					break;
			}
			LwpnH::getWeapon()->angular = true;
			LwpnH::getWeapon()->angle=atan2(vy, vx);
			LwpnH::getWeapon()->step=FFCore.Distance(0, 0, vx, vy)/10000.0;
			LwpnH::getWeapon()->doAutoRotate();
		}
	}
}

void do_lwpnmakedirectional()
{
	if(LwpnH::loadWeapon(ri->lwpn, "lweapon->MakeDirectional") == SH::_NoError)
	{
		if (LwpnH::getWeapon()->angular)
		{
			LwpnH::getWeapon()->dir = NORMAL_DIR(AngleToDir(WrapAngle(LwpnH::getWeapon()->angle)));
			LwpnH::getWeapon()->angular = false;
			LwpnH::getWeapon()->doAutoRotate(true);
		}
	}
}

void do_ewpnmakeangular()
{
	if(EwpnH::loadWeapon(ri->ewpn, "eweapon->MakeAngular") == SH::_NoError)
	{
		if (!EwpnH::getWeapon()->angular)
		{
			double vx;
			double vy;
			switch(NORMAL_DIR(EwpnH::getWeapon()->dir))
			{
				case l_up:
				case l_down:
				case left:
					vx = -1.0*((weapon*)s)->step;
					break;
				case r_down:
				case r_up:
				case right:
					vx = ((weapon*)s)->step;
					break;
					
				default:
					vx = 0;
					break;
			}
			switch(NORMAL_DIR(EwpnH::getWeapon()->dir))
			{
				case l_up:
				case r_up:
				case up:
					vy = -1.0*((weapon*)s)->step;
					break;
				case l_down:
				case r_down:
				case down:
					vy = ((weapon*)s)->step;
					break;
					
				default:
					vy = 0;
					break;
			}
			EwpnH::getWeapon()->angular = true;
			EwpnH::getWeapon()->angle=atan2(vy, vx);
			EwpnH::getWeapon()->step=FFCore.Distance(0, 0, vx, vy)/10000.0;
			EwpnH::getWeapon()->doAutoRotate();
		}
	}
}

void do_ewpnmakedirectional()
{
	if(EwpnH::loadWeapon(ri->lwpn, "eweapon->MakeDirectional") == SH::_NoError)
	{
		if (EwpnH::getWeapon()->angular)
		{
			EwpnH::getWeapon()->dir = NORMAL_DIR(AngleToDir(WrapAngle(EwpnH::getWeapon()->angle)));
			EwpnH::getWeapon()->angular = false;
			EwpnH::getWeapon()->doAutoRotate(true);
		}
	}
}

void do_lwpnusesprite(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkWeaponMiscSprite(ID, "lweapon->UseSprite") != SH::_NoError)
		return;
		
	if(LwpnH::loadWeapon(ri->lwpn, "lweapon->UseSprite") == SH::_NoError)
		LwpnH::getWeapon()->LOADGFX(ID);
}

void do_ewpnusesprite(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkWeaponMiscSprite(ID, "eweapon->UseSprite") != SH::_NoError)
		return;
		
	if(EwpnH::loadWeapon(ri->ewpn, "eweapon->UseSprite") == SH::_NoError)
		EwpnH::getWeapon()->LOADGFX(ID);
}

void do_portalusesprite()
{
	int32_t ID = get_register(sarg1) / 10000;
	
	if(BC::checkWeaponMiscSprite(ID, "portal->UseSprite") != SH::_NoError)
		return;
	
	if(portal* p = checkPortal(ri->portalref, "UseSprite()"))
		p->LOADGFX(ID);
}

void do_clearsprites(const bool v)
{
	int32_t spritelist = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkBounds(spritelist, 0, 5, "Screen->ClearSprites") != SH::_NoError)
		return;
		
	switch(spritelist)
	{
		case 0:
			guys.clear();
			break;
			
		case 1:
			items.clear();
			break;
			
		case 2:
			Ewpns.clear();
			break;
			
		case 3:
			Lwpns.clear();
			Hero.reset_hookshot();
			break;
			
		case 4:
			decorations.clear();
			break;
			
		case 5:
			particles.clear();
			break;
	}
}

void do_loadlweapon(const bool v)
{
	int32_t index = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkLWeaponIndex(index, "Screen->LoadLWeapon") != SH::_NoError)
		ri->lwpn = 0; //MAX_DWORD; //Now NULL
	else
	{
		ri->lwpn = Lwpns.spr(index)->getUID();
		// This is too trivial to log. -L
		//Z_eventlog("Script loaded lweapon with UID = %ld\n", ri->lwpn);
	}
}

void do_loadeweapon(const bool v)
{
	int32_t index = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkEWeaponIndex(index, "Screen->LoadEWeapon") != SH::_NoError)
		ri->ewpn = 0; //MAX_DWORD; //Now NULL
	else
	{
		ri->ewpn = Ewpns.spr(index)->getUID();
		//Z_eventlog("Script loaded eweapon with UID = %ld\n", ri->ewpn);
	}
}

void do_loaditem(const bool v)
{
	int32_t index = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkItemIndex(index, "Screen->LoadItem") != SH::_NoError)
		ri->itemref = 0; //MAX_DWORD; //Now NULL
	else
	{
		ri->itemref = items.spr(index)->getUID();
		//Z_eventlog("Script loaded item with UID = %ld\n", ri->itemref);
	}
}


void do_loaditemdata(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	
	//I *think* this is the right check ~Joe
	if(BC::checkItemID(ID, "Game->LoadItemData") != SH::_NoError)
	{
		ri->idata = -1; //new null value
		return;
	}
	ri->idata = ID;
	//Z_eventlog("Script loaded itemdata with ID = %ld\n", ri->idata);
}

void do_loadnpc(const bool v)
{
	int32_t index = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkGuyIndex(index, "Screen->LoadNPC") != SH::_NoError)
		ri->guyref = 0; // MAX_DWORD;
	else
	{
		ri->guyref = guys.spr(index)->getUID();
		//Z_eventlog("Script loaded NPC with UID = %ld\n", ri->guyref);
	}
}

void FFScript::do_loaddmapdata(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	
	if ( ID < 0 || ID > 511 )
	{
		Z_scripterrlog("Invalid DMap ID passed to Game->LoadDMapData(): %d\n", ID);
		ri->dmapsref = MAX_DWORD;
	}
	else ri->dmapsref = ID;
}

void FFScript::do_load_active_subscreendata(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	
	if(ID == -1 || (unsigned(ID) < subscreens_active.size() && unsigned(ID) < 256))
	{
		ri->subdataref = get_subref(ID, sstACTIVE);
	}
	else
	{
		Z_scripterrlog("Invalid Subscreen ID passed to Game->LoadASubData(): %d\n", ID);
		ri->subdataref = 0;
	}
	ri->d[rEXP1] = ri->subdataref;
}
void FFScript::do_load_passive_subscreendata(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	
	if(ID == -1 || (unsigned(ID) < subscreens_passive.size() && unsigned(ID) < 256))
	{
		ri->subdataref = get_subref(ID, sstPASSIVE);
	}
	else
	{
		Z_scripterrlog("Invalid Subscreen ID passed to Game->LoadPSubData(): %d\n", ID);
		ri->subdataref = 0;
	}
	ri->d[rEXP1] = ri->subdataref;
}
void FFScript::do_load_overlay_subscreendata(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	
	if(ID == -1 || (unsigned(ID) < subscreens_overlay.size() && unsigned(ID) < 256))
	{
		ri->subdataref = get_subref(ID, sstOVERLAY);
	}
	else
	{
		Z_scripterrlog("Invalid Subscreen ID passed to Game->LoadOSubData(): %d\n", ID);
		ri->subdataref = 0;
	}
	ri->d[rEXP1] = ri->subdataref;
}
void FFScript::do_load_subscreendata(const bool v, const bool v2)
{
	int32_t ty = SH::get_arg(sarg2, v2) / 10000;
	switch(ty)
	{
		case sstACTIVE:
			do_load_active_subscreendata(v);
			break;
		case sstPASSIVE:
			do_load_passive_subscreendata(v);
			break;
		case sstOVERLAY:
			do_load_overlay_subscreendata(v);
			break;
		default:
		{
			Z_scripterrlog("Invalid Subscreen Type passed to ???: %d\n", ty);
			ri->subdataref = 0;
			break;
		}
	}
	ri->d[rEXP1] = ri->subdataref;
}

void FFScript::do_loadrng()
{
	auto rng = user_rngs.create();
	if (!rng)
	{
		ri->d[rEXP1] = 0;
		return;
	}

	int q = script_object_ids_by_type[script_object_type::rng].size() - 1;
	rng->gen = &script_rnggens[q];
	ri->rngref = rng->id;
	ri->d[rEXP1] = rng->id;
}

void FFScript::do_loaddirectory()
{
	int32_t arrayptr = get_register(sarg1) / 10000;
	string path;
	ArrayH::getString(arrayptr, path, 2048);
	
	if(path.find("../") != string::npos
		|| path.find("..\\") != string::npos)
	{
		Z_scripterrlog("Error: Script attempted to go up a directory in directory load '%s'\n", path.c_str());
		return;
	}
	
	size_t pos = path.find_last_not_of("/\\");
	if(pos != string::npos && !(path.find_last_of("/\\") < pos))
		path = path.substr(0, pos+1);
	char buf[2048+1] = {0};
	get_scriptfile_path(buf, path.c_str());
	regulate_path(buf);
	if(valid_dir(buf) && checkPath(buf, true))
	{
		ri->directoryref = user_dirs.get_free();
		if(!ri->directoryref) return;
		user_dir* d = checkDir(ri->directoryref, "LoadDirectory", true);
		set_register(sarg1, ri->directoryref);
		d->setPath(buf);
		return;
	}
	Z_scripterrlog("Path '%s' empty or points to a file; must point to a directory!\n",path.c_str());
	ri->directoryref = 0;
	set_register(sarg1, 0);
}

void FFScript::do_loadstack()
{
	ri->stackref = user_stacks.get_free();
	ri->d[rEXP1] = ri->stackref;
}

void FFScript::do_loaddropset(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	
	if ( ID < 0 || ID > MAXITEMDROPSETS )
	{
		Z_scripterrlog("Invalid Dropset ID passed to Game->LoadDropset(): %d\n", ID);
		ri->dropsetref = MAX_DWORD;
	}
		
	else ri->dropsetref = ID;
}

void FFScript::do_loadbottle(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	
	if ( ID < 1 || ID > 64 )
	{
		Z_scripterrlog("Invalid BottleType ID passed to Game->LoadBottleData(): %d\n", ID);
		ri->bottletyperef = 0;
	}
	else ri->bottletyperef = ID;
}

void FFScript::do_loadbottleshop(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	
	if ( ID < 0 || ID > 255 )
	{
		Z_scripterrlog("Invalid BottleShopType ID passed to Game->LoadBottleShopData(): %d\n", ID);
		ri->bottleshopref = 0;
	}
	else ri->bottleshopref = ID+1;
}
void FFScript::do_loadgenericdata(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	
	if ( ID < 1 || ID > NUMSCRIPTSGENERIC )
	{
		Z_scripterrlog("Invalid GenericData ID passed to Game->LoadGenericData(): %d\n", ID);
		ri->genericdataref = 0;
	}
	else ri->genericdataref = ID;
}

void FFScript::do_create_paldata()
{
	ri->paldataref = user_paldatas.get_free();
	ri->d[rEXP1] = ri->paldataref;
}

void FFScript::do_create_paldata_clr()
{
	ri->paldataref = user_paldatas.get_free();
	if (ri->paldataref > 0)
	{
		user_paldata& pd = user_paldatas[ri->paldataref];
		int32_t clri = get_register(sarg1);

		RGB c = _RGB((clri >> 16) & 0xFF, (clri >> 8) & 0xFF, clri & 0xFF);

		if (c.r < 0 || c.g < 0 || c.b < 0)
		{
			Z_scripterrlog("Invalid rgb (%d) passed to Graphics->CreatePalData().\n", clri);
		}
		c.r = vbound(c.r, 0, 63);
		c.g = vbound(c.g, 0, 63);
		c.b = vbound(c.b, 0, 63);

		for (int32_t q = 0; q < 240; ++q)
			pd.set_color(q, c);
	}
	ri->d[rEXP1] = ri->paldataref;
}

void FFScript::do_mix_clr()
{
	int32_t clr_start = SH::read_stack(ri->sp + 3);
	int32_t clr_end = SH::read_stack(ri->sp + 2);
	float percent = SH::read_stack(ri->sp + 1) / 10000.0;
	int32_t color_space = SH::read_stack(ri->sp + 0) / 10000;

	RGB ref1c = _RGB((clr_start >> 16) & 0xFF, (clr_start >> 8) & 0xFF, clr_start & 0xFF);
	RGB ref2c = _RGB((clr_end >> 16) & 0xFF, (clr_end >> 8) & 0xFF, clr_end & 0xFF);
	RGB outputc = user_paldata::mix_color(ref1c, ref2c, percent, color_space);

	int32_t r = vbound(outputc.r, 0, 63);
	int32_t g = vbound(outputc.g, 0, 63);
	int32_t b = vbound(outputc.b, 0, 63);

	ri->d[rEXP1] = (r << 16) | (g << 8) | b;
}

void FFScript::do_create_rgb_hex()
{
	int32_t hexrgb = get_register(sarg1);

	int32_t r = (hexrgb >> 16) & 0xFF;
	int32_t g = (hexrgb >> 8) & 0xFF;
	int32_t b = hexrgb & 0xFF;

	//Convert rgb from 8-bit to 6-bit
	r = vbound(r / 4, 0, 63);
	g = vbound(g / 4, 0, 63);
	b = vbound(b / 4, 0, 63);

	ri->d[rEXP1] = (r << 16) | (g << 8) | b;
}

void FFScript::do_create_rgb()
{
	int32_t r = SH::read_stack(ri->sp + 2) / 10000;
	int32_t g = SH::read_stack(ri->sp + 1) / 10000;
	int32_t b = SH::read_stack(ri->sp + 0) / 10000;

	if (unsigned(r) > 63 || unsigned(g) > 63 || unsigned(b) > 63)
	{
		Z_scripterrlog("R/G/B values passed to Graphics->CreateRGB() should range from 0-63.\n");
	}
	r = vbound(r, 0, 63);
	g = vbound(g, 0, 63);
	b = vbound(b, 0, 63);

	ri->d[rEXP1] = (r << 16) | (g << 8) | b;
}

void FFScript::do_convert_from_rgb()
{
	int32_t buf = SH::read_stack(ri->sp + 2) / 10000;
	int32_t clri = SH::read_stack(ri->sp + 1);
	int32_t color_space = SH::read_stack(ri->sp + 0) / 10000;

	ArrayManager am(buf);
	if (am.invalid()) return;
	int32_t zscript_array_size = am.size();
	int32_t target_size;
	
	switch (color_space)
	{
	case user_paldata::CSPACE_CMYK:
			target_size = 4;
			break;
		default:
			target_size = 3;
	}

	if (zscript_array_size < target_size)
	{
		Z_scripterrlog("Array supplied to 'Graphics->ConvertFromRGB' not large enough. Should be at least size %d\n", target_size);
		return;
	}
	
	RGB c = _RGB((clri >> 16) & 0xFF, (clri >> 8) & 0xFF, clri & 0xFF);
	double convert[4];
	user_paldata::RGBTo(c, convert, color_space);

	for (int32_t q = 0; q < target_size; ++q)
	{
		am.set(q, int32_t(convert[q]*10000));
	}

	return;
}

void FFScript::do_convert_to_rgb()
{
	int32_t buf = SH::read_stack(ri->sp + 1) / 10000;
	int32_t color_space = SH::read_stack(ri->sp + 0) / 10000;
	
	ArrayManager am(buf);
	if (am.invalid()) return;
	int32_t zscript_array_size = am.size();
	int32_t target_size;

	switch (color_space)
	{
	case user_paldata::CSPACE_CMYK:
		target_size = 4;
		break;
	default:
		target_size = 3;
	}

	if (zscript_array_size < target_size)
	{
		Z_scripterrlog("Array supplied to 'Graphics->ConvertToRGB' not large enough. Should be at least size %d\n", target_size);
		return;
	}

	double convert[4];
	for (int32_t q = 0; q < target_size; ++q)
	{
		convert[q] = am.get(q) / 10000.0;
	}
	RGB c = user_paldata::RGBFrom(convert, color_space);

	ri->d[rEXP1] = (c.r << 16) | (c.g << 8) | c.b;
}

void FFScript::do_paldata_load_level()
{
	if (user_paldata* pd = checkPalData(ri->paldataref, "paldata->LoadLevelPalette()"))
	{
		int32_t lvl = get_register(sarg1) / 10000;
		//Load CSets 2-4
		pd->load_cset(2, lvl * pdLEVEL + poLEVEL + 0);
		pd->load_cset(3, lvl * pdLEVEL + poLEVEL + 1);
		pd->load_cset(4, lvl * pdLEVEL + poLEVEL + 2);
		//Load CSet 9
		pd->load_cset(9, lvl * pdLEVEL + poLEVEL + 3);
		//Load 1, 5, 7, 8
		pd->load_cset(1, lvl * pdLEVEL + poNEWCSETS);
		pd->load_cset(5, lvl * pdLEVEL + poNEWCSETS + 1);
		pd->load_cset(7, lvl * pdLEVEL + poNEWCSETS + 2);
		pd->load_cset(8, lvl * pdLEVEL + poNEWCSETS + 3);
	}
	return;
}

void FFScript::do_paldata_load_sprite()
{
	if (user_paldata* pd = checkPalData(ri->paldataref, "paldata->LoadSpritePalette()"))
	{
		int32_t page = get_register(sarg1) / 10000;

		int32_t pageoffset = 0;
		switch (page)
		{
		case 0: pageoffset += 0;  break;
		case 1: pageoffset += 15; break;
		default:
			Z_scripterrlog("Invalid page (%d) passed to paldata->LoadSpritePalette(). Valid pages are 0 or 1. Aborting.\n", page);
			return;
		}
		for (int32_t q = 0; q < 15; ++q)
		{
			pd->load_cset(q, poSPRITE255 + pageoffset + q);
		}
	}
	return;
}

void FFScript::do_paldata_load_main()
{
	if (user_paldata* pd = checkPalData(ri->paldataref, "paldata->LoadMainPalette()"))
	{
		for (int32_t q = 0; q <= 15; ++q)
		{
			pd->load_cset_main(q);
		}
	}
	return;
}

void FFScript::do_paldata_load_cycle()
{
	if (user_paldata* pd = checkPalData(ri->paldataref, "paldata->LoadCyclePalette()"))
	{
		int32_t lvl = get_register(sarg1) / 10000;
		for (int32_t q = 4; q <= 12; ++q)
		{
			pd->load_cset(q, lvl * pdLEVEL + poLEVEL + q);
		}
	}
	return;
}

void FFScript::do_paldata_load_bitmap()
{
	if (user_paldata* pd = checkPalData(ri->paldataref, "paldata->LoadBitmapPalette()"))
	{
		int32_t pathptr = get_register(sarg1) / 10000;
		string str;
		ArrayH::getString(pathptr, str, 256);

		if (get_qr(qr_BITMAP_AND_FILESYSTEM_PATHS_ALWAYS_RELATIVE))
		{
			char buf[2048+1] = { 0 };
			if (FFCore.get_scriptfile_path(buf, str.c_str()))
				str = buf;
		}
		regulate_path(str);

		if (str.empty())
		{
			al_trace("String pointer is null! Internal error. \n");
			return;
		}

		PALETTE tempPal;
		get_palette(tempPal);
		if (checkPath(str.c_str(), false))
		{
			BITMAP* bmp = load_bitmap(str.c_str(), tempPal);
			if (!bmp)
			{
				Z_scripterrlog("LoadBitmapPalette() failed to load image file %s.\n", str.c_str());
			}
			else
			{
				for (int32_t q = 0; q < PALDATA_NUM_COLORS; ++q)
				{
					pd->colors[q] = tempPal[q];
					set_bit(pd->colors_used, q, true);
				}
			}
			destroy_bitmap(bmp);
		}
		else
		{
			Z_scripterrlog("Failed to load image file: %s. File not found.\n", str.c_str());
		}
	}
	return;
}

void FFScript::do_paldata_write_level()
{
	if (user_paldata* pd = checkPalData(ri->paldataref, "paldata->WriteLevelPalette()"))
	{
		int32_t lvl = get_register(sarg1) / 10000;
		bool changed = false;
		//Write CSets 2-4
		if (pd->check_cset(2, lvl * pdLEVEL + poLEVEL + 0))
		{
			pd->write_cset(2, lvl * pdLEVEL + poLEVEL + 0);
			changed = true;
		}
		if (pd->check_cset(3, lvl * pdLEVEL + poLEVEL + 1))
		{
			pd->write_cset(3, lvl * pdLEVEL + poLEVEL + 1);
			changed = true;
		}
		if (pd->check_cset(4, lvl * pdLEVEL + poLEVEL + 2))
		{
			pd->write_cset(4, lvl * pdLEVEL + poLEVEL + 2);
			changed = true;
		}
		//Write CSet 9
		if (pd->check_cset(9, lvl * pdLEVEL + poLEVEL + 3))
		{
			pd->write_cset(9, lvl * pdLEVEL + poLEVEL + 3);
			changed = true;
		}
		//Write 1, 5, 7, 8
		if (pd->check_cset(1, lvl * pdLEVEL + poNEWCSETS + 0))
		{
			pd->write_cset(1, lvl * pdLEVEL + poNEWCSETS + 0);
			changed = true;
		}
		if (pd->check_cset(5, lvl * pdLEVEL + poNEWCSETS + 1))
		{
			pd->write_cset(5, lvl * pdLEVEL + poNEWCSETS + 1);
			changed = true;
		}
		if (pd->check_cset(7, lvl * pdLEVEL + poNEWCSETS + 2))
		{
			pd->write_cset(7, lvl * pdLEVEL + poNEWCSETS + 2);
			changed = true;
		}
		if (pd->check_cset(8, lvl * pdLEVEL + poNEWCSETS + 3))
		{
			pd->write_cset(8, lvl * pdLEVEL + poNEWCSETS + 3);
			changed = true;
		}

		if (changed && DMaps[currdmap].color == lvl)
		{
			loadlvlpal(lvl);
			currcset = lvl;
			if (darkroom && !get_qr(qr_NEW_DARKROOM))
			{
				if (get_qr(qr_FADE))
				{
					interpolatedfade();
				}
				else
				{
					loadfadepal((DMaps[currdmap].color) * pdLEVEL + poFADE3);
				}
			}
		}
	}
	return;
}

void FFScript::do_paldata_write_levelcset()
{
	if (user_paldata* pd = checkPalData(ri->paldataref, "paldata->WriteLevelCSet()"))
	{
		int32_t lvl = get_register(sarg1) / 10000;
		int32_t cs = get_register(sarg2) / 10000;

		bool changed = false;

		switch (cs)
		{
		case 1:
			if (pd->check_cset(1, lvl * pdLEVEL + poNEWCSETS + 0))
			{
				pd->write_cset(1, lvl * pdLEVEL + poNEWCSETS + 0);
				changed = true;
			}
			break;
		case 2:
			if (pd->check_cset(2, lvl * pdLEVEL + poLEVEL + 0))
			{
				pd->write_cset(2, lvl * pdLEVEL + poLEVEL + 0);
				changed = true;
			}
			break;
		case 3:
			if (pd->check_cset(3, lvl * pdLEVEL + poLEVEL + 1))
			{
				pd->write_cset(3, lvl * pdLEVEL + poLEVEL + 1);
				changed = true;
			}
			break;
		case 4:
			if (pd->check_cset(4, lvl * pdLEVEL + poLEVEL + 2))
			{
				pd->write_cset(4, lvl * pdLEVEL + poLEVEL + 2);
				changed = true;
			}
			break;
		case 5:
			if (pd->check_cset(5, lvl * pdLEVEL + poNEWCSETS + 1))
			{
				pd->write_cset(5, lvl * pdLEVEL + poNEWCSETS + 1);
				changed = true;
			}
			break;
		case 7:
			if (pd->check_cset(7, lvl * pdLEVEL + poNEWCSETS + 2))
			{
				pd->write_cset(7, lvl * pdLEVEL + poNEWCSETS + 2);
				changed = true;
			}
			break;
		case 8:
			if (pd->check_cset(8, lvl * pdLEVEL + poNEWCSETS + 3))
			{
				pd->write_cset(8, lvl * pdLEVEL + poNEWCSETS + 3);
				changed = true;
			}
			break;
		case 9:
			if (pd->check_cset(9, lvl * pdLEVEL + poLEVEL + 3))
			{
				pd->write_cset(9, lvl * pdLEVEL + poLEVEL + 3);
				changed = true;
			}
			break;
		default:
			Z_scripterrlog("Invalid CSet (%d) passed to 'paldata->WriteLevelCSet()'. Level palettes can use CSets 1, 2, 3, 4, 5, 7, 8, 9.\n");
			return;
		}
	
		if (changed && DMaps[currdmap].color == lvl)
		{
			loadlvlpal(lvl);
			if (darkroom && !get_qr(qr_NEW_DARKROOM))
			{
				if (get_qr(qr_FADE))
				{
					interpolatedfade();
				}
				else
				{
					loadfadepal((DMaps[currdmap].color) * pdLEVEL + poFADE3);
				}
			}
			currcset = lvl;
		}
	}
}

void FFScript::do_paldata_write_sprite()
{
	if (user_paldata* pd = checkPalData(ri->paldataref, "paldata->WriteSpritePalette()"))
	{
		int32_t page = get_register(sarg1) / 10000;

		int32_t pageoffset = 0;
		switch (page)
		{
		case 0: pageoffset += 0;  break;
		case 1: pageoffset += 15; break;
		default:
			Z_scripterrlog("Invalid page (%d) passed to paldata->WriteSpritePalette(). Valid pages are 0 or 1. Aborting.\n", page);
			return;
		}
		bool changed6 = false;
		bool changed14 = false;
		for (int32_t q = 0; q < 15; ++q)
		{
			if (pd->check_cset(q, poSPRITE255 + pageoffset + q))
			{
				pd->write_cset(q, poSPRITE255 + pageoffset + q);
				if (pageoffset + q == currspal6)
				{
					changed6 = true;
				}
				if (pageoffset + q == currspal14)
				{
					changed14 = true;
				}
			}
		}

		//If either sprite palette has been changed, update the main palette
		if (changed6 || changed14)
		{
			if (changed6) 
			{
				loadpalset(6, poSPRITE255 + currspal6, false);
			}
			if (changed14)
			{
				loadpalset(14, poSPRITE255 + currspal14, false);
			}

			if (isMonochrome()) {
				if (lastMonoPreset) {
					restoreMonoPreset();
				}
				else {
					setMonochrome(false);
					setMonochrome(true);
				}
			}

			if (isUserTinted()) {
				restoreTint();
			}
		}
	}
	return;
}

void FFScript::do_paldata_write_spritecset()
{
	if (user_paldata* pd = checkPalData(ri->paldataref, "paldata->WriteSpritePalette()"))
	{
		int32_t page = get_register(sarg1) / 10000;
		int32_t cs = get_register(sarg2) / 10000;

		int32_t pageoffset = 0;
		switch (page)
		{
		case 0: pageoffset += 0;  break;
		case 1: pageoffset += 15; break;
		default:
			Z_scripterrlog("Invalid page (%d) passed to paldata->WriteSpriteCSet(). Valid pages are 0 or 1. Aborting.\n", page);
			return;
		}
		bool changed6 = false;
		bool changed14 = false;
		if (unsigned(cs) > 15)
		{
			Z_scripterrlog("Invalid CSet (%d) passed to paldata->WriteSpriteCSet(). Valid CSets are 0-15. Aborting.\n", cs);
			return;
		}
		if (pd->check_cset(cs, poSPRITE255 + pageoffset + cs))
		{
			pd->write_cset(cs, poSPRITE255 + pageoffset + cs);
			if (pageoffset + cs == currspal6)
			{
				changed6 = true;
			}
			if (pageoffset + cs == currspal14)
			{
				changed14 = true;
			}
		}

		//If either sprite palette has been changed, update the main palette
		if (changed6 || changed14)
		{
			if (changed6)
			{
				loadpalset(6, poSPRITE255 + currspal6, false);
			}
			if (changed14)
			{
				loadpalset(14, poSPRITE255 + currspal14, false);
			}

			if (isMonochrome()) {
				if (lastMonoPreset) {
					restoreMonoPreset();
				}
				else {
					setMonochrome(false);
					setMonochrome(true);
				}
			}

			if (isUserTinted()) {
				restoreTint();
			}
		}
	}
	return;
}

void FFScript::do_paldata_write_main()
{
	if (user_paldata* pd = checkPalData(ri->paldataref, "paldata->WriteMainPalette()"))
	{
		bool changed = false;
		for (int32_t q = 0; q <= 15; ++q)
		{
			if (pd->check_cset_main(q))
			{
				pd->write_cset_main(q);
				changed = true;
			}
		}

		if (changed)
		{
			refreshpal = true;
		}
	}
	return;
}

void FFScript::do_paldata_write_maincset()
{
	if (user_paldata* pd = checkPalData(ri->paldataref, "paldata->WriteMainCSet()"))
	{
		int32_t cs = get_register(sarg1) / 10000;

		bool changed = false;

		if (unsigned(cs) < 16)
		{
			if (pd->check_cset_main(cs))
			{
				pd->write_cset_main(cs);
				changed = true;
			}
		}
		else
		{
			Z_scripterrlog("Invalid CSet (%d) passed to 'paldata->WriteMainCSet()'. Valid csets are 0-15. Aborting.\n");
			return;
		}

		if (changed) 
		{
			refreshpal = true;
		}
	}
}

void FFScript::do_paldata_write_cycle()
{
	if (user_paldata* pd = checkPalData(ri->paldataref, "paldata->WriteCyclePalette()"))
	{
		int32_t lvl = get_register(sarg1) / 10000;
		for (int32_t q = 4; q <= 12; ++q)
		{
			if (pd->check_cset(q, lvl * pdLEVEL + poLEVEL + q))
			{
				pd->write_cset(q, lvl * pdLEVEL + poLEVEL + q);
			}
		}
	}
	return;
}

void FFScript::do_paldata_write_cyclecset()
{
	if (user_paldata* pd = checkPalData(ri->paldataref, "paldata->WriteCycleCSet()"))
	{
		int32_t lvl = get_register(sarg1) / 10000;
		int32_t cs = get_register(sarg2) / 10000;

		bool changed = false;

		switch (cs)
		{
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
		case 11:
		case 12:
			if (pd->check_cset(cs, lvl * pdLEVEL + poLEVEL + cs))
			{
				pd->write_cset(cs, lvl * pdLEVEL + poLEVEL + cs);
				changed = true;
			}
			break;
		default:
			Z_scripterrlog("Invalid CSet (%d) passed to 'paldata->WriteCycleCSet()'. Cycle palettes use CSets 4-12.\n");
			return;
		}

		if (changed && DMaps[currdmap].color == lvl)
		{
			loadlvlpal(lvl);
			currcset = lvl;
		}
	}
}

void FFScript::do_paldata_colorvalid()
{
	if (user_paldata* pd = checkPalData(ri->paldataref, "paldata->ColorValid()"))
	{
		int32_t ind = get_register(sarg1) / 10000;
		if (unsigned(ind) >= PALDATA_NUM_COLORS)
		{
			Z_scripterrlog("Invalid color index (%d) passed to paldata->ColorValid(). Valid indices are 0-255.\n", ind);
			set_register(sarg1, 0);
			return;
		}

		if (get_bit(pd->colors_used, ind))
		{
			set_register(sarg1, 10000);
		}
		else
		{
			set_register(sarg1, 0);
		}
	}
}

void FFScript::do_paldata_clearcolor()
{
	if (user_paldata* pd = checkPalData(ri->paldataref, "paldata->SetColor()"))
	{
		int32_t ind = get_register(sarg1) / 10000;
		if (unsigned(ind) >= PALDATA_NUM_COLORS)
		{
			Z_scripterrlog("Invalid color index (%d) passed to paldata->ClearColor(). Valid indices are 0-255. Aborting.\n", ind);
			return;
		}
		set_bit(pd->colors_used, ind, false);
	}
}

void FFScript::do_paldata_clearcset()
{
	if (user_paldata* pd = checkPalData(ri->paldataref, "paldata->ClearCSet()"))
	{
		int32_t cs = get_register(sarg1) / 10000;
		if (unsigned(cs) > 15)
		{
			Z_scripterrlog("Invalid cset (%d) passed to paldata->ClearCSet(). Valid csets are 0-15. Aborting.\n", cs);
			return;
		}
		for (int32_t q = 0; q < 16; ++q)
		{
			set_bit(pd->colors_used, CSET(cs) + q, false);
		}
	}
}

int32_t FFScript::do_paldata_getrgb(int32_t v)
{
	const char* fname = "";
	switch (v)
	{
		case 0: fname = "paldata->R[]"; break;
		case 1: fname = "paldata->G[]"; break;
		case 2: fname = "paldata->B[]"; break;
	}
	if (user_paldata* pd = checkPalData(ri->paldataref, fname))
	{
		int32_t ind = ri->d[rINDEX] / 10000;
		if (unsigned(ind) >= PALDATA_NUM_COLORS)
		{
			Z_scripterrlog("Invalid color index (%d) passed to %s. Valid indices are 0-255.\n", ind, fname);
			return -10000;
		}
		if (!get_bit(pd->colors_used, ind))
		{
			Z_scripterrlog("%s tried to access unused color %d.\n", fname, ind);
			return -10000;
		}
		switch (v)
		{
			case 0:
				return pd->colors[ind].r * 10000;
			case 1:
				return pd->colors[ind].g * 10000;
			case 2:
				return pd->colors[ind].b * 10000;
		}
	}
	return -10000;
}

void FFScript::do_paldata_setrgb(int32_t v, int32_t val)
{
	const char* fname = "";
	switch (v)
	{
		case 0: fname = "paldata->R[]"; break;
		case 1: fname = "paldata->G[]"; break;
		case 2: fname = "paldata->B[]"; break;
	}
	if (user_paldata* pd = checkPalData(ri->paldataref, fname))
	{
		int32_t ind = ri->d[rINDEX] / 10000;
		if (unsigned(ind) >= PALDATA_NUM_COLORS)
		{
			Z_scripterrlog("Invalid color index (%d) passed to %s. Valid indices are 0-255. Aborting.\n", ind, fname);
			return;
		}
		if (unsigned(val) > 63)
		{
			Z_scripterrlog("RGB value(%d) passed to %s is out of range. RGB values range from 0 - 63.\n", val, fname);
			val = vbound(val, 0, 63);
		}
		if (!get_bit(pd->colors_used, ind))
		{
			Z_scripterrlog("%s tried to access unused color %d.\n", fname, ind);
			return;
		}
		switch (v)
		{
			case 0:
				pd->colors[ind].r = val;
				break;
			case 1:
				pd->colors[ind].g = val;
				break;
			case 2:
				pd->colors[ind].b = val;
				break;
		}
	}
}

void FFScript::do_paldata_mix()
{
	int32_t ref = SH::read_stack(ri->sp + 4);
	if (user_paldata* pd = checkPalData(ref, "paldata->Mix()"))
	{
		int32_t ref1 = SH::read_stack(ri->sp + 3);
		int32_t ref2 = SH::read_stack(ri->sp + 2);
		double percent = SH::read_stack(ri->sp + 1)/10000.0;
		int32_t color_space = SH::read_stack(ri->sp + 0)/10000;
		if (user_paldata* pd_start = checkPalData(ref1, "paldata->Mix()"))
		{
			if (user_paldata* pd_end = checkPalData(ref2, "paldata->Mix()"))
			{
				pd->mix(pd_start, pd_end, percent, color_space);
			}
		}
	}
}

void FFScript::do_paldata_mixcset()
{
	int32_t ref = SH::read_stack(ri->sp + 5);
	if (user_paldata* pd = checkPalData(ref, "paldata->MixCSet()"))
	{
		int32_t ref1 = SH::read_stack(ri->sp + 4);
		int32_t ref2 = SH::read_stack(ri->sp + 3);
		int32_t cset = SH::read_stack(ri->sp + 2) / 10000;
		double percent = SH::read_stack(ri->sp + 1) / 10000.0;
		int32_t color_space = SH::read_stack(ri->sp + 0) / 10000;
		if (user_paldata* pd_start = checkPalData(ref1, "paldata->MixCSet()"))
		{
			if (user_paldata* pd_end = checkPalData(ref2, "paldata->MixCSet()"))
			{
				if (unsigned(cset) > 15)
				{
					Z_scripterrlog("CSet passed to 'paldata->MixCSet()' out of range. Valid CSets are 0-15\n");
					return;
				}
				pd->mix(pd_start, pd_end, percent, color_space, CSET(cset), CSET(cset) + 16);
			}
		}
	}
}

void FFScript::do_paldata_copy()
{
	if (user_paldata* pd = checkPalData(ri->paldataref, "paldata->Copy()"))
	{
		int32_t ref_dest = get_register(sarg1);
		if (user_paldata* pd_dest = checkPalData(ref_dest, "paldata->Copy()"))
		{
			for (int32_t q = 0; q < PALDATA_NUM_COLORS; ++q)
			{
				pd_dest->colors[q] = pd->colors[q];
			}
			for (int32_t q = 0; q < PALDATA_BITSTREAM_SIZE; ++q)
			{
				pd_dest->colors_used[q] = pd->colors_used[q];
			}
		}
	}
}

void FFScript::do_paldata_copycset()
{
	ri->paldataref = SH::read_stack(ri->sp + 3);
	if (user_paldata* pd = checkPalData(ri->paldataref, "paldata->CopyCSet()"))
	{
		int32_t ref_dest = SH::read_stack(ri->sp + 2);
		int32_t cs = SH::read_stack(ri->sp + 1) / 10000;
		int32_t cs_dest = SH::read_stack(ri->sp + 0) / 10000;
		if (user_paldata* pd_dest = checkPalData(ref_dest, "paldata->CopyCSet()"))
		{
			if (unsigned(cs) > 15)
			{
				Z_scripterrlog("Invalid CSet (%d) passed to paldata->CopyCSet(). Valid CSets are 0-15. Aborting.\n", cs);
				return;
			}
			for (int32_t q = 0; q < 16; ++q)
			{
				pd_dest->colors[CSET(cs_dest) + q] = pd->colors[CSET(cs) + q];
				set_bit(pd_dest->colors_used, CSET(cs_dest) + q, bool(get_bit(pd->colors_used, CSET(cs) + q)));
			}
		}
	}
}

//Loads a cset to paldata from memory
void user_paldata::load_cset(int32_t cset, int32_t dataset)
{
	byte* si = colordata + CSET(dataset) * 3;
	for (int32_t q = 0; q < 16; ++q)
	{
		int32_t ind = CSET(cset) + q;
		colors[ind].r = si[0];
		colors[ind].g = si[1];
		colors[ind].b = si[2];
		set_bit(colors_used, ind, true);
		si += 3;
	}
}

//Loads a cset to paldata from the main palette
void user_paldata::load_cset_main(int32_t cset)
{
	for (int32_t q = 0; q < 16; ++q)
	{
		int32_t ind = CSET(cset) + q;
		colors[ind].r = RAMpal[ind].r;
		colors[ind].g = RAMpal[ind].g;
		colors[ind].b = RAMpal[ind].b;
		set_bit(colors_used, ind, true);
	}
}

//Writes to a memory cset from paldata
void user_paldata::write_cset(int32_t cset, int32_t dataset)
{
	byte* si = colordata + CSET(dataset) * 3;
	for (int32_t q = 0; q < 16; ++q)
	{
		int32_t ind = CSET(cset) + q;
		if (get_bit(colors_used, ind))
		{
			si[0] = colors[ind].r;
			si[1] = colors[ind].g;
			si[2] = colors[ind].b;
		}
		si += 3;
	}
}

//Writes to a main palette cset from paldata
void user_paldata::write_cset_main(int32_t cset)
{
	for (int32_t q = 0; q < 16; ++q)
	{
		int32_t ind = CSET(cset) + q;
		if (get_bit(colors_used, ind))
		{
			RAMpal[ind] = colors[ind];
		}
	}
}


//Checks a memory cset from 




bool user_paldata::check_cset(int32_t cset, int32_t dataset)
{
	byte* si = colordata + CSET(dataset) * 3;
	for (int32_t q = 0; q < 16; ++q)
	{
		int32_t ind = CSET(cset) + q;
		if (get_bit(colors_used, ind))
		{
			if (si[0] != colors[ind].r)
				return true;
			if (si[1] != colors[ind].g)
				return true;
			if (si[2] != colors[ind].b)
				return true;
		}
		si += 3;
	}
	return false;
}

//Checks a memory cset from the main palette
bool user_paldata::check_cset_main(int32_t cset)
{
	for (int32_t q = 0; q < 16; ++q)
	{
		int32_t ind = CSET(cset) + q;
		if (get_bit(colors_used, ind))
		{
			if (RAMpal[ind].r != colors[ind].r)
				return true;
			if (RAMpal[ind].g != colors[ind].g)
				return true;
			if (RAMpal[ind].b != colors[ind].b)
				return true;
		}
	}
	return false;
}

//Mixes a color between two paldatas
RGB user_paldata::mix_color(RGB start, RGB end, double percent, int32_t color_space)
{
	int32_t direction = 0;
	switch (color_space)
	{
	case CSPACE_RGB:
		return _RGB(byte(vbound(double(zc::math::Lerp(start.r, end.r, percent)), 0.0, 63.0)),
			byte(vbound(double(zc::math::Lerp(start.g, end.g, percent)), 0.0, 63.0)),
			byte(vbound(double(zc::math::Lerp(start.b, end.b, percent)), 0.0, 63.0)));
	case CSPACE_CMYK:
	{
		double convert_start[4];
		double convert_end[4];
		double convert_result[4];
		RGBTo(start, convert_start, color_space);
		RGBTo(end, convert_end, color_space);
		convert_result[0] = zc::math::Lerp(convert_start[0], convert_end[0], percent);
		convert_result[1] = zc::math::Lerp(convert_start[1], convert_end[1], percent);
		convert_result[2] = zc::math::Lerp(convert_start[2], convert_end[2], percent);
		convert_result[3] = zc::math::Lerp(convert_start[3], convert_end[3], percent);
		return RGBFrom(convert_result, color_space);
	}
	case CSPACE_HSV_CW:
		if (color_space == CSPACE_HSV_CW)
			direction = 1;
		[[fallthrough]];
	case CSPACE_HSV_CCW:
		if (color_space == CSPACE_HSV_CCW)
			direction = -1;
		[[fallthrough]];
	case CSPACE_HSV:
	{
		double convert_start[3];
		double convert_end[3];
		double convert_result[3];
		RGBTo(start, convert_start, color_space);
		RGBTo(end, convert_end, color_space);
		convert_result[0] = WrapLerp(convert_start[0], convert_end[0], percent, 0.0, 1.0, direction);
		convert_result[1] = zc::math::Lerp(convert_start[1], convert_end[1], percent);
		convert_result[2] = zc::math::Lerp(convert_start[2], convert_end[2], percent);
		return RGBFrom(convert_result, color_space);
	}
	case CSPACE_HSL_CW:
		if (color_space == CSPACE_HSL_CW)
			direction = 1;
		[[fallthrough]];
	case CSPACE_HSL_CCW:
		if (color_space == CSPACE_HSL_CCW)
			direction = -1;
		[[fallthrough]];
	case CSPACE_HSL:
	{
		double convert_start[3];
		double convert_end[3];
		double convert_result[3];
		RGBTo(start, convert_start, color_space);
		RGBTo(end, convert_end, color_space);
		convert_result[0] = WrapLerp(convert_start[0], convert_end[0], percent, 0.0, 1.0, direction);
		convert_result[1] = zc::math::Lerp(convert_start[1], convert_end[1], percent);
		convert_result[2] = zc::math::Lerp(convert_start[2], convert_end[2], percent);
		return RGBFrom(convert_result, color_space);
	}
	case CSPACE_LAB:
	{
		double convert_start[3];
		double convert_end[3];
		double convert_result[3];
		RGBTo(start, convert_start, color_space);
		RGBTo(end, convert_end, color_space);
		convert_result[0] = zc::math::Lerp(convert_start[0], convert_end[0], percent);
		convert_result[1] = zc::math::Lerp(convert_start[1], convert_end[1], percent);
		convert_result[2] = zc::math::Lerp(convert_start[2], convert_end[2], percent);
		return RGBFrom(convert_result, color_space);
	}
	case CSPACE_LCH_CW:
		if (color_space == CSPACE_LCH_CW)
			direction = 1;
		[[fallthrough]];
	case CSPACE_LCH_CCW:
		if (color_space == CSPACE_LCH_CCW)
			direction = -1;
		[[fallthrough]];
	case CSPACE_LCH:
	{
		double convert_start[3];
		double convert_end[3];
		double convert_result[3];
		RGBTo(start, convert_start, color_space);
		RGBTo(end, convert_end, color_space);
		convert_result[0] = zc::math::Lerp(convert_start[0], convert_end[0], percent);
		convert_result[1] = zc::math::Lerp(convert_start[1], convert_end[1], percent);
		convert_result[2] = WrapLerp(convert_start[2], convert_end[2], percent, 0.0, 360.0, direction);
		return RGBFrom(convert_result, color_space);
	}
	}
	return start;
}

void user_paldata::RGBTo(RGB c, double arr[], int32_t color_space)
{
	//From easyrgb.com/en/math.php
	double r = vbound(c.r / 63.0, 0.0, 1.0);
	double g = vbound(c.g / 63.0, 0.0, 1.0);
	double b = vbound(c.b / 63.0, 0.0, 1.0);
	switch (color_space)
	{
	case CSPACE_CMYK:
	{
		double c = 1.0 - r;
		double m = 1.0 - g;
		double y = 1.0 - b;

		double k = 1.0;

		if (c < k) k = c;
		if (m < k) k = m;
		if (y < k) k = y;
		if (k == 1)
		{
			c = 0.0;
			m = 0.0;
			y = 0.0;
		}
		else
		{
			c = (c - k) / (1.0 - k);
			m = (m - k) / (1.0 - k);
			y = (y - k) / (1.0 - k);
		}
		arr[0] = c;
		arr[1] = m;
		arr[2] = y;
		arr[3] = k;
		break;
	}
	case CSPACE_HSV_CW:
	case CSPACE_HSV_CCW:
	case CSPACE_HSV:
	{
		double min_val = std::min(std::min(r, g), b);
		double max_val = std::max(std::max(r, g), b);
		double del_max = max_val - min_val;

		double h = 0;
		double s = 0;
		double v = max_val;

		if (del_max != 0) //Set chroma if not gray
		{
			s = del_max / max_val;

			double del_r = (((max_val - r) / 6.0) + (del_max / 2.0)) / del_max;
			double del_g = (((max_val - g) / 6.0) + (del_max / 2.0)) / del_max;
			double del_b = (((max_val - b) / 6.0) + (del_max / 2.0)) / del_max;

			if (r == max_val) h = del_b - del_g;
			else if (g == max_val) h = (1.0 / 3.0) + del_r - del_b;
			else if (b == max_val) h = (2.0 / 3.0) + del_g - del_r;

			if (h < 0) ++h;
			if (h > 1) --h;
		}

		arr[0] = h;
		arr[1] = s;
		arr[2] = v;
		break;
	}
	case CSPACE_HSL_CW:
	case CSPACE_HSL_CCW:
	case CSPACE_HSL:
	{
		double min_val = std::min(std::min(r, g), b);
		double max_val = std::max(std::max(r, g), b);
		double del_max = max_val - min_val;

		double h = 0;
		double s = 0;
		double l = (max_val + min_val) / 2.0;

		if (del_max != 0) //Set chroma if not gray
		{
			if (l < 0.5) s = del_max / (max_val + min_val);
			else s = del_max / (2 - max_val - min_val);

			double del_r = (((max_val - r) / 6.0) + (del_max / 2.0)) / del_max;
			double del_g = (((max_val - g) / 6.0) + (del_max / 2.0)) / del_max;
			double del_b = (((max_val - b) / 6.0) + (del_max / 2.0)) / del_max;

			if (r == max_val) h = del_b - del_g;
			else if (g == max_val) h = (1.0 / 3.0) + del_r - del_b;
			else if (b == max_val) h = (2.0 / 3.0) + del_g - del_r;

			if (h < 0) ++h;
			if (h > 1) --h;
		}

		arr[0] = h;
		arr[1] = s;
		arr[2] = l;
		break;
	}
	case CSPACE_LAB:
	{
		if (r > 0.04045) r = pow(((r + 0.055) / 1.055), 2.4);
		else r /= 12.92;
		if (g > 0.04045) g = pow(((g + 0.055) / 1.055), 2.4);
		else g /= 12.92;
		if (b > 0.04045) b = pow(((b + 0.055) / 1.055), 2.4);
		else b /= 12.92;

		double x = r * 0.4124 + g * 0.3576 + b * 0.1805;
		double y = r * 0.2126 + g * 0.7152 + b * 0.0722;
		double z = r * 0.0193 + g * 0.1192 + b * 0.9505;

		if (x > 0.008856) x = pow(x, 1.0 / 3.0);
		else x = (7.787 * x) + (16.0 / 116.0);
		if (y > 0.008856) y = pow(y, 1.0 / 3.0);
		else y = (7.787 * y) + (16.0 / 116.0);
		if (z > 0.008856) z = pow(z, 1.0 / 3.0);
		else z = (7.787 * z) + (16.0 / 116.0);

		double CIEL = (116 * y) - 16;
		double CIEa = 500 * (x - y);
		double CIEb = 200 * (y - z);

		arr[0] = CIEL;
		arr[1] = CIEa;
		arr[2] = CIEb;
		break;
	}
	case CSPACE_LCH_CW:
	case CSPACE_LCH_CCW:
	case CSPACE_LCH:
	{
		if (r > 0.04045) r = pow(((r + 0.055) / 1.055), 2.4);
		else r /= 12.92;
		if (g > 0.04045) g = pow(((g + 0.055) / 1.055), 2.4);
		else g /= 12.92;
		if (b > 0.04045) b = pow(((b + 0.055) / 1.055), 2.4);
		else b /= 12.92;

		double x = r * 0.4124 + g * 0.3576 + b * 0.1805;
		double y = r * 0.2126 + g * 0.7152 + b * 0.0722;
		double z = r * 0.0193 + g * 0.1192 + b * 0.9505;

		if (x > 0.008856) x = pow(x, 1.0 / 3.0);
		else x = (7.787 * x) + (16.0 / 116.0);
		if (y > 0.008856) y = pow(y, 1.0 / 3.0);
		else y = (7.787 * y) + (16.0 / 116.0);
		if (z > 0.008856) z = pow(z, 1.0 / 3.0);
		else z = (7.787 * z) + (16.0 / 116.0);

		double CIEL = (116 * y) - 16;
		double CIEa = 500 * (x - y);
		double CIEb = 200 * (y - z);

		double h = atan2(CIEb, CIEa);
		if (h > 0) h = (h / PI) * 180;
		else h = 360 - (abs(h) / PI) * 180;

		double CIEC = sqrt(pow(CIEa, 2) + pow(CIEb, 2));

		arr[0] = CIEL;
		arr[1] = CIEC;
		arr[2] = h;
		break;
	}
	}

}

RGB user_paldata::RGBFrom(double arr[], int32_t color_space)
{
	double r = 0.0;
	double g = 0.0;
	double b = 0.0;
	switch (color_space)
	{
	case CSPACE_CMYK:
	{
		double c = (arr[0] * (1 - arr[3]) + arr[3]);
		double m = (arr[1] * (1 - arr[3]) + arr[3]);
		double y = (arr[2] * (1 - arr[3]) + arr[3]);

		r = vbound((1 - c) * 63.0, 0.0, 63.0);
		g = vbound((1 - m) * 63.0, 0.0, 63.0);
		b = vbound((1 - y) * 63.0, 0.0, 63.0);
		return _RGB(r, g, b);
		break;
	}
	case CSPACE_HSV_CW:
	case CSPACE_HSV_CCW:
	case CSPACE_HSV:
	{
		double h = arr[0];
		double s = arr[1];
		double v = arr[2];

		if (s == 0)
		{
			r = v;
			g = v;
			b = v;
		}
		else
		{
			double var_h = h * 6;
			if (var_h >= 6) var_h = 0;
			int32_t var_i = floor(var_h);
			double var_1 = v * (1 - s);
			double var_2 = v * (1 - s * (var_h - var_i));
			double var_3 = v * (1 - s * (1 - (var_h - var_i)));

			switch (var_i)
			{
			case 0:
				r = v;
				g = var_3;
				b = var_1;
				break;
			case 1:
				r = var_2;
				g = v;
				b = var_1;
				break;
			case 2:
				r = var_1;
				g = v;
				b = var_3;
				break;
			case 3:
				r = var_1;
				g = var_2;
				b = v;
				break;
			case 4:
				r = var_3;
				g = var_1;
				b = v;
				break;
			default:
				r = v;
				g = var_1;
				b = var_2;
			}
		}

		r = vbound(r * 63.0, 0.0, 63.0);
		g = vbound(g * 63.0, 0.0, 63.0);
		b = vbound(b * 63.0, 0.0, 63.0);

		return _RGB(r, g, b);
	}
	case CSPACE_HSL_CW:
	case CSPACE_HSL_CCW:
	case CSPACE_HSL:
	{
		double h = arr[0];
		double s = arr[1];
		double l = arr[2];

		if (s == 0)
		{
			r = l;
			g = l;
			b = l;
		}
		else
		{
			double var_1;
			double var_2;
			if (l < 0.5)var_2 = l * (1 + s);
			else var_2 = (l + s) - (s * l);

			var_1 = 2 * l - var_2;

			r = HueToRGB(var_1, var_2, h + (1.0 / 3.0));
			g = HueToRGB(var_1, var_2, h);
			b = HueToRGB(var_1, var_2, h - (1.0 / 3.0));
		}

		r = vbound(r * 63.0, 0.0, 63.0);
		g = vbound(g * 63.0, 0.0, 63.0);
		b = vbound(b * 63.0, 0.0, 63.0);

		return _RGB(r, g, b);
	}
	case CSPACE_LAB:
	{
		double CIEL = arr[0];
		double CIEa = arr[1];
		double CIEb = arr[2];

		double var_y = (CIEL + 16) / 116.0;
		double var_x = CIEa / 500.0 + var_y;
		double var_z = var_y - CIEb / 200.0;

		if (pow(var_x, 3) > 0.008856) var_x = pow(var_x, 3);
		else var_x = (var_x - 16.0 / 116.0) / 7.787;
		if (pow(var_y, 3) > 0.008856) var_y = pow(var_y, 3);
		else var_y = (var_y - 16.0 / 116.0) / 7.787;
		if (pow(var_z, 3) > 0.008856) var_z = pow(var_z, 3);
		else var_z = (var_z - 16.0 / 116.0) / 7.787;

		r = var_x * 3.2406 + var_y * -1.5372 + var_z * -0.4986;
		g = var_x * -0.9689 + var_y * 1.8758 + var_z * 0.0415;
		b = var_x * 0.0557 + var_y * -0.2040 + var_z * 1.0570;

		if (r > 0.0031308) r = 1.055 * pow(r, (1 / 2.4)) - 0.055;
		else r = 12.92 * r;
		if (g > 0.0031308) g = 1.055 * pow(g, (1 / 2.4)) - 0.055;
		else g = 12.92 * g;
		if (b > 0.0031308) b = 1.055 * pow(b, (1 / 2.4)) - 0.055;
		else b = 12.92 * b;

		r = vbound(r * 63.0, 0.0, 63.0);
		g = vbound(g * 63.0, 0.0, 63.0);
		b = vbound(b * 63.0, 0.0, 63.0);

		return _RGB(r, g, b);
	}
	case CSPACE_LCH_CW:
	case CSPACE_LCH_CCW:
	case CSPACE_LCH:
	{
		double CIEL = arr[0];
		double CIEa = cos((arr[2] * PI) / 180.0) * arr[1];
		double CIEb = sin((arr[2] * PI) / 180.0) * arr[1];

		double var_y = (CIEL + 16) / 116.0;
		double var_x = CIEa / 500.0 + var_y;
		double var_z = var_y - CIEb / 200.0;

		if (pow(var_y, 3) > 0.008856) var_y = pow(var_y, 3);
		else var_y = (var_y - 16.0 / 116.0) / 7.787;
		if (pow(var_x, 3) > 0.008856) var_x = pow(var_x, 3);
		else var_x = (var_x - 16.0 / 116.0) / 7.787;
		if (pow(var_z, 3) > 0.008856) var_z = pow(var_z, 3);
		else var_z = (var_z - 16.0 / 116.0) / 7.787;

		r = var_x * 3.2406 + var_y * -1.5372 + var_z * -0.4986;
		g = var_x * -0.9689 + var_y * 1.8758 + var_z * 0.0415;
		b = var_x * 0.0557 + var_y * -0.2040 + var_z * 1.0570;

		if (r > 0.0031308) r = 1.055 * pow(r, (1 / 2.4)) - 0.055;
		else r = 12.92 * r;
		if (g > 0.0031308) g = 1.055 * pow(g, (1 / 2.4)) - 0.055;
		else g = 12.92 * g;
		if (b > 0.0031308) b = 1.055 * pow(b, (1 / 2.4)) - 0.055;
		else b = 12.92 * b;

		r = vbound(r * 63.0, 0.0, 63.0);
		g = vbound(g * 63.0, 0.0, 63.0);
		b = vbound(b * 63.0, 0.0, 63.0);

		return _RGB(r, g, b);
	}
	}
	return _RGB(0, 0, 0);
}
double user_paldata::HueToRGB(double v1, double v2, double vH)
{
	if (vH < 0) vH += 1;
	if (vH > 1) vH -= 1;
	if ((6 * vH) < 1) return (v1 + (v2 - v1) * 6 * vH);
	if ((2 * vH) < 1) return (v2);
	if ((3 * vH) < 2) return (v1 + (v2 - v1) * ((2.0 / 3.0) - vH) * 6);
	return (v1);
}

double user_paldata::WrapLerp(double a, double b, double t, double min, double max, int32_t direction)
{
	double dif = abs(a - b);
	double range = abs(max - min);

	switch (direction)
	{
	case 0:
		if (dif > range * 0.5)
			dif = range - dif;
		if (a + dif == b)
			direction = 1;
		else
			direction = -1;
		break;
	case 1:
		if (b < a)
			dif = range - dif;
		break;
	case -1:
		if (b > a)
			dif = range - dif;
		break;
	}

	double ret = zc::math::Lerp(a, a + dif * direction, t);

	if (ret <= min)
		ret += range;
	else if (ret >= max)
		ret -= range;
	return ret;
}

//Mixes an entire palette given two paldatas
void user_paldata::mix(user_paldata *pal_start, user_paldata *pal_end, double percent, int32_t color_space, int32_t start_color, int32_t end_color)
{
	for (int32_t q = start_color; q < end_color; ++q)
	{
		if (get_bit(pal_start->colors_used, q) && get_bit(pal_end->colors_used, q)) {
			RGB start = pal_start->colors[q];
			RGB end = pal_end->colors[q];
			colors[q] = mix_color(start, end, percent, color_space);
			set_bit(colors_used, q, true);
		}
	}
}

void item_display_name(const bool setter)
{
	int32_t ID = ri->idata;
	if(unsigned(ID) >= MAXITEMS)
		return;
	int32_t arrayptr = get_register(sarg1) / 10000;
	if(setter)
	{
		std::string str;
		ArrayH::getString(arrayptr, str, 255);
		strcpy(itemsbuf[ID].display_name, str.c_str());
	}
	else
	{
		if(ArrayH::setArray(arrayptr, string(itemsbuf[ID].display_name)) == SH::_Overflow)
			Z_scripterrlog("Array supplied to 'itemdata->GetDisplayName()' not large enough\n");
	}
}
void item_shown_name()
{
	int32_t ID = ri->idata;
	if(unsigned(ID) >= MAXITEMS)
		return;
	int32_t arrayptr = get_register(sarg1) / 10000;
	if(ArrayH::setArray(arrayptr, itemsbuf[ID].get_name()) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'itemdata->GetShownName()' not large enough\n");
}

void FFScript::do_getDMapData_dmapname(const bool v)
{
	//int32_t ID = ri->zmsgref;
	int32_t ID = ri->dmapsref;
	int32_t arrayptr = get_register(sarg1) / 10000;
	
	if(BC::checkDMapID(ID, "dmapdata->GetName()") != SH::_NoError)
		return;
		
	if(ArrayH::setArray(arrayptr, string(DMaps[ID].name)) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'dmapdata->GetName()' not large enough\n");
}

void FFScript::do_setDMapData_dmapname(const bool v)
{
	//int32_t ID = ri->zmsgref;
	int32_t ID = ri->dmapsref;
	int32_t arrayptr = get_register(sarg1) / 10000;

	string filename_str;
	
	if(BC::checkDMapID(ID, "dmapdata->SetName()") != SH::_NoError)
		return;
		
		
	ArrayH::getString(arrayptr, filename_str, 22);
	strncpy(DMaps[ID].name, filename_str.c_str(), 21);
	DMaps[ID].name[20]='\0';
}

void FFScript::do_getDMapData_dmaptitle(const bool v)
{
	//int32_t ID = ri->zmsgref;
	int32_t ID = ri->dmapsref;
	int32_t arrayptr = get_register(sarg1) / 10000;
	
	if(BC::checkDMapID(ID, "dmapdata->GetTitle()") != SH::_NoError)
		return;
		
	if (!get_qr(qr_OLD_DMAP_INTRO_STRINGS))
	{
		ArrayManager am(arrayptr);
		am.resize(DMaps[ID].title.size() + 1);
	}
	if(ArrayH::setArray(arrayptr, string(DMaps[ID].title)) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'dmapdata->GetTitle()' not large enough\n");
}

void FFScript::do_setDMapData_dmaptitle(const bool v)
{
	//int32_t ID = ri->zmsgref;
	int32_t ID = ri->dmapsref;
	int32_t arrayptr = get_register(sarg1) / 10000;
	string filename_str;

	if(BC::checkDMapID(ID, "dmapdata->SetTitle()") != SH::_NoError)
		return;

	if (get_qr(qr_OLD_DMAP_INTRO_STRINGS))
	{
		char namestr[21];
		ArrayH::getString(arrayptr, filename_str, 21);
		strncpy(namestr, filename_str.c_str(), 20);
		namestr[20] = '\0';
		DMaps[ID].title.assign(namestr);
	}
	else
	{
		ArrayH::getString(arrayptr, filename_str, ArrayH::getSize(arrayptr));
		DMaps[ID].title = filename_str;
	}
}

void FFScript::do_getDMapData_dmapintro(const bool v)
{
	//int32_t ID = ri->zmsgref;
	int32_t ID = ri->dmapsref;
	int32_t arrayptr = get_register(sarg1) / 10000;
	
	if(BC::checkDMapID(ID, "dmapdata->GetIntro()") != SH::_NoError)
		return;
		
	if(ArrayH::setArray(arrayptr, string(DMaps[ID].intro)) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'dmapdata->GetIntro()' not large enough\n");
}

void FFScript::do_setDMapData_dmapintro(const bool v)
{
	//int32_t ID = ri->zmsgref;
	int32_t ID = ri->dmapsref;
	int32_t arrayptr = get_register(sarg1) / 10000;
	string filename_str;
	
	if(BC::checkDMapID(ID, "dmapdata->SetIntro()") != SH::_NoError)
		return;
		
		
	ArrayH::getString(arrayptr, filename_str, 73);
	strncpy(DMaps[ID].intro, filename_str.c_str(), 72);
	DMaps[ID].intro[72]='\0';
}

void FFScript::do_getDMapData_music(const bool v)
{
	//int32_t ID = ri->zmsgref;
	int32_t ID = ri->dmapsref;
	int32_t arrayptr = get_register(sarg1) / 10000;
	
	if(BC::checkDMapID(ID, "dmapdata->GetMusic()") != SH::_NoError)
		return;
		
	if(ArrayH::setArray(arrayptr, string(DMaps[ID].tmusic)) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'dmapdata->GetMusic()' not large enough\n");
}

void FFScript::do_setDMapData_music(const bool v)
{
	//int32_t ID = ri->zmsgref;
	int32_t ID = ri->dmapsref;
	int32_t arrayptr = get_register(sarg1) / 10000;
	string filename_str;
	
	if(BC::checkDMapID(ID, "dmapdata->SetMusic()") != SH::_NoError)
		return;
		
		
	ArrayH::getString(arrayptr, filename_str, 56);
	strncpy(DMaps[ID].tmusic, filename_str.c_str(), 55);
	DMaps[ID].tmusic[55]='\0';
}

void FFScript::do_loadnpcdata(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	
	if ( ID < 1 || ID > (MAXGUYS-1) )
	{
		Z_scripterrlog("Invalid NPC ID passed to Game->LoadNPCData: %d\n", ID);
		ri->npcdataref = MAX_DWORD;
	}
		
	else ri->npcdataref = ID;
	//Z_eventlog("Script loaded npcdata with ID = %ld\n", ri->idata);
}
void FFScript::do_loadmessagedata(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	
	if ( ID < 1 || ID > (msg_count-1) )
	{
		Z_scripterrlog("Invalid Message ID passed to Game->LoadMessageData: %d\n", ID);
		ri->zmsgref = MAX_DWORD;
	}
		
	else ri->zmsgref = ID;
	//Z_eventlog("Script loaded npcdata with ID = %ld\n", ri->idata);
}
//same syntax as loadmessage data
//the input is an array
void FFScript::do_messagedata_setstring(const bool v)
{
	int32_t arrayptr = get_register(sarg1) / 10000;
	int32_t ID = ri->zmsgref;
	if(BC::checkMessage(ID, "messagesata->Set()") != SH::_NoError)
		return;
	
	ArrayH::getString(arrayptr, MsgStrings[ID].s, MSG_NEW_SIZE);
}
void FFScript::do_messagedata_getstring(const bool v)
{
	int32_t ID = ri->zmsgref;
	int32_t arrayptr = get_register(sarg1) / 10000;
	
	if(BC::checkMessage(ID, "messagedata->Get()") != SH::_NoError)
		return;
		
	if(ArrayH::setArray(arrayptr, MsgStrings[ID].s) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'messagedata->Get()' not large enough\n");
}

void FFScript::do_loadcombodata(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	
	if ( (unsigned)ID > (MAXCOMBOS-1) )
	{
		Z_scripterrlog("Invalid Combo ID passed to Game->LoadComboData: %d\n", ID);
		ri->combosref = 0;
	}

	else ri->combosref = ID;
	//Z_eventlog("Script loaded mapdata with ID = %ld\n", ri->idata);
}

void FFScript::do_loadmapdata(const bool v)
{
	int32_t _map = SH::get_arg(sarg1, v) / 10000;
	
	int32_t _scr = SH::get_arg(sarg2, v) / 10000;
	// zprint("LoadMapData Map Value: %d\n", _map);
	// zprint("LoadMapData Screen Value: %d\n", _scr);
	int32_t indx = (_map * MAPSCRS + _scr);
	// zprint("LoadMapData Indx Value: %d\n", indx);
	if ( _map < 1 || _map > (map_count-1) )
	{
		Z_scripterrlog("Invalid Map ID passed to Game->LoadMapData: %d\n", _map);
		ri->mapsref = 0;
	}
	else if ( (unsigned)_scr > 129 ) //0x00 to 0x81 -Z
	{
		Z_scripterrlog("Invalid Screen ID passed to Game->LoadMapData: %d\n", _scr);
		ri->mapsref = 0;
	}
	else ri->mapsref = indx;
	// zprint("LoadMapData Screen set ri->mapsref to: %d\n", ri->mapsref);
	//zprint("Script loaded mapdata with ID = %ld\n", ri->idata);
}

void FFScript::do_loadmapdata_tempscr(const bool v)
{
	int32_t layer = SH::get_arg(sarg1, v) / 10000;
	if(BC::checkBounds(layer, 0, 6, "Game->LoadTempScreen()") != SH::_NoError)
	{
		ri->mapsref = 0;
		return;
	}
	switch(layer)
	{
		case 0: ri->mapsref = MAPSCR_TEMP0; break;
		case 1: ri->mapsref = MAPSCR_TEMP1; break;
		case 2: ri->mapsref = MAPSCR_TEMP2; break;
		case 3: ri->mapsref = MAPSCR_TEMP3; break;
		case 4: ri->mapsref = MAPSCR_TEMP4; break;
		case 5: ri->mapsref = MAPSCR_TEMP5; break;
		case 6: ri->mapsref = MAPSCR_TEMP6; break;
	}
	set_register(sarg1, ri->mapsref);
}

void FFScript::do_loadmapdata_scrollscr(const bool v)
{
	int32_t layer = SH::get_arg(sarg1, v) / 10000;
	if(BC::checkBounds(layer, 0, 6, "Game->LoadScrollingScreen()") != SH::_NoError)
	{
		ri->mapsref = 0;
		return;
	}
	switch(layer)
	{
		case 0: ri->mapsref = MAPSCR_SCROLL0; break;
		case 1: ri->mapsref = MAPSCR_SCROLL1; break;
		case 2: ri->mapsref = MAPSCR_SCROLL2; break;
		case 3: ri->mapsref = MAPSCR_SCROLL3; break;
		case 4: ri->mapsref = MAPSCR_SCROLL4; break;
		case 5: ri->mapsref = MAPSCR_SCROLL5; break;
		case 6: ri->mapsref = MAPSCR_SCROLL6; break;
	}
	set_register(sarg1, ri->mapsref);
}
	
void FFScript::do_loadshopdata(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	
	if ( (unsigned)ID > 255 )
	{
		Z_scripterrlog("Invalid Shop ID passed to Game->LoadShopData: %d\n", ID);
		ri->shopsref = 0;
	}	
	else ri->shopsref = ID;
	//Z_eventlog("Script loaded npcdata with ID = %ld\n", ri->idata);
}


void FFScript::do_loadinfoshopdata(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	
	if ( (unsigned)ID > 255 )
	{
		Z_scripterrlog("Invalid Shop ID passed to Game->LoadShopData: %d\n", ID);
		ri->shopsref = 0;
	}	
	else ri->shopsref = ID+NUMSHOPS;
	//Z_eventlog("Script loaded npcdata with ID = %ld\n", ri->idata);
}

/*
void FFScript::do_loadmapdata(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	
	if ( ID < 0 || ID > (map_count-1) )
	{
		Z_scripterrlog("Invalid Map ID passed to Game->LoadMapData: %d\n", ID);
		ri->mapsref = MAX_SIGNED_32;
	}

	else ri->mapsref = ID;
	//Z_eventlog("Script loaded mapdata with ID = %ld\n", ri->idata);
}
*/

/*

void FFScript::do_loadmapdata(const bool v)
{
	int32_t ID = get_register(sarg2) / 10000; 
	
	if ( ID < 0 || ID > (map_count-1) )
	{
		Z_scripterrlog("Invalid Map ID passed to Game->LoadMapData: %d\n", ID);
		return;
	}

	ri->mapsref = ID;
	set_register(sarg1, ri->mapsref); 
	//Z_eventlog("Script loaded mapdata with ID = %ld\n", ri->idata);
}

*/

void FFScript::do_loadspritedata(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	
	if ( (unsigned)ID > (MAXWPNS-1) )
	{
		Z_scripterrlog("Invalid Sprite ID passed to Game->LoadSpriteData: %d\n", ID);
		ri->spritesref = 0; 
	}

	else ri->spritesref = ID;
	//Z_eventlog("Script loaded mapdata with ID = %ld\n", ri->idata);
}


void FFScript::do_loadscreendata(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	
	if ( (unsigned)ID > (MAXSCREENS-1) )
	{
		Z_scripterrlog("Invalid Map ID passed to Game->LoadScreenData: %d\n", ID);
		ri->screenref = 0; 
	}

	else ri->screenref = ID;
	//Z_eventlog("Script loaded mapdata with ID = %ld\n", ri->idata);
}

void FFScript::do_loadbitmapid(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	switch(ID)
	{
		case rtSCREEN:
		case rtBMP0:
		case rtBMP1:
		case rtBMP2:
		case rtBMP3:
		case rtBMP4:
		case rtBMP5:
		case rtBMP6:
			ri->bitmapref = ID+10; break;
		default:
		{
			Z_scripterrlog("Invalid Bitmap ID passed to Game->Load BitmapID: %d\n", ID);
			ri->bitmapref = 0; break;
		}
	}
	
	//Z_eventlog("Script loaded mapdata with ID = %ld\n", ri->idata);
}

void do_createlweapon(const bool v)
{
	const int32_t ID = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkWeaponID(ID, "Screen->CreateLWeapon") != SH::_NoError)
		return;
	
	if ( Lwpns.has_space() )
	{
		Lwpns.add
		(
			new weapon
			(
				(zfix)0, /*X*/
				(zfix)0, /*Y*/
				(zfix)0, /*Z*/
				ID,	 /*id*/
				0,	 /*type*/
				0,	 /*power*/
				0,	 /*dir*/
				-1,	 /*Parentid*/
				Hero.getUID(), /*prntid*/
				false,	 /*isdummy*/
				1,	 /*script_gen*/
				1,  /*islwpn*/
				(ID==wWind?1:0)  /*special*/
			)
		);
		ri->lwpn = Lwpns.spr(Lwpns.Count() - 1)->getUID();
		//Lwpns.spr(Lwpns.Count() - 1)->LOADGFX(0);
		//Lwpns.spr(Lwpns.Count() - 1)->ScriptGenerated = 1;
		//Lwpns.spr(Lwpns.Count() - 1)->isLWeapon = 1;
		weapon *w = (weapon*)Lwpns.spr(Lwpns.Count()-1); //last created
		//w->LOADGFX(FFCore.getDefWeaponSprite(ID)); //No.
		w->ScriptGenerated = 1;
		w->isLWeapon = 1;
		if(ID == wWind) w->specialinfo = 1;
		Z_eventlog("Script created lweapon %ld with UID = %ld\n", ID, ri->lwpn);
	}
	else
	{
		//ri->lwpn = MAX_DWORD;
		ri->lwpn = 0; // Now NULL
		Z_scripterrlog("Couldn't create lweapon %ld, screen lweapon limit reached\n", ID);
	}
}

void do_createeweapon(const bool v)
{
	const int32_t ID = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkWeaponID(ID, "Screen->CreateEWeapon") != SH::_NoError)
		return;
		
	if ( Ewpns.has_space() )
	{
		addEwpn(0, 0, 0, ID, 0, 0, 0, -1,1); //Param 9 marks it as script-generated.
		//Ewpns.spr(Ewpns.Count() - 1)->LOADGFX(0);
		//Ewpns.spr(Ewpns.Count() - 1)->ScriptGenerated = 1;
		//Ewpns.spr(Ewpns.Count() - 1)->isLWeapon = 0;
		if( ID > wEnemyWeapons || ( ID >= wScript1 && ID <= wScript10) )
		{
			weapon *w = (weapon*)Ewpns.spr(Ewpns.Count()-1); //last created
			//w->LOADGFX(FFCore.getDefWeaponSprite(ID));
			w->ScriptGenerated = 1;
			w->isLWeapon = 0;
			ri->ewpn = Ewpns.spr(Ewpns.Count() - 1)->getUID();
			Z_eventlog("Script created eweapon %ld with UID = %ld\n", ID, ri->ewpn);
		}
		else
		{
			Z_scripterrlog("Couldn't create eweapon %ld: Invalid ID/Type (%d) specified.\n", ID);
			return;
		}
	}
	else
	{
		ri->ewpn = 0;
		Z_scripterrlog("Couldn't create eweapon %ld, screen eweapon limit reached\n", ID);
	}
}

void do_createitem(const bool v)
{
	const int32_t ID = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkItemID(ID, "Screen->CreateItem") != SH::_NoError)
		return;

	if ( items.has_space() )
	{
		additem(0, (get_qr(qr_NOITEMOFFSET) ? 1: 0), ID, ipBIGRANGE);
		ri->itemref = items.spr(items.Count() - 1)->getUID();
		Z_eventlog("Script created item \"%s\" with UID = %ld\n", item_string[ID], ri->itemref);
	}
	else
	{
		ri->itemref = 0;
		Z_scripterrlog("Couldn't create item \"%s\", screen item limit reached\n", item_string[ID]);
	}
	/*
	if(items.Count() < 1)
	{
		ri->itemref = MAX_DWORD;
		Z_scripterrlog("Couldn't create item \"%s\", screen item limit reached\n", item_string[ID]);
	}
	else
	{
		ri->itemref = items.spr(items.Count() - 1)->getUID();
		Z_eventlog("Script created item \"%s\" with UID = %ld\n", item_string[ID], ri->itemref);
	}
	*/
}

void do_createnpc(const bool v)
{
	const int32_t ID = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkGuyID(ID, "Screen->CreateNPC") != SH::_NoError)
		return;
		
	//If we make a segmented enemy there'll be more than one sprite created
	word numcreated = addenemy(0, 0, ID, -10);
	
	if(numcreated == 0)
	{
		//ri->guyref = MAX_DWORD;
		ri->guyref = 0;
		Z_scripterrlog("Couldn't create NPC \"%s\", screen NPC limit reached\n", guy_string[ID]);
	}
	else
	{
		word index = guys.Count() - numcreated; //Get the main enemy, not a segment
		ri->guyref = guys.spr(index)->getUID();
		
		for(; index<guys.Count(); index++)
			((enemy*)guys.spr(index))->script_spawned=true;
			
		Z_eventlog("Script created NPC \"%s\" with UID = %ld\n", guy_string[ID], ri->guyref);
	}
}

///----------------------------------------------------------------------------------------------------//
//Drawing & Sound

void do_message(const bool v)
{
	const int32_t ID = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkMessage(ID, "Screen->Message") != SH::_NoError)
		return;
		
	if(ID == 0)
	{
		dismissmsg();
		msgfont = get_zc_font(font_zfont);
		blockpath = false;
		Hero.finishedmsg();
	}
	else
		donewmsg(ID);
}

INLINE void set_drawing_command_args(const int32_t j, const word numargs)
{
	for(int32_t k = 1; k <= numargs; k++)
		script_drawing_commands[j][k] = SH::read_stack(ri->sp + (numargs - k));
}

INLINE void set_user_bitmap_command_args(const int32_t j, const word numargs)
{
	//ri->bitmapref = SH::read_stack(ri->sp+numargs);
	//zprint("Current drawing bitmap ref is: %d\n", ri->bitmapref );
	for(int32_t k = 1; k <= numargs; k++)
		script_drawing_commands[j][k] = SH::read_stack(ri->sp + (numargs - k));
}

void do_drawing_command(const int32_t script_command)
{
	if (FFCore.skipscriptdraws)
		return;
	int32_t j = script_drawing_commands.GetNext();
	
	if(j == -1)  //out of drawing command space
	{
		Z_scripterrlog("Max draw primitive limit reached\n");
		return;
	}
	
	script_drawing_commands[j][0] = script_command;
	script_drawing_commands[j][18] = zscriptDrawingRenderTarget->GetCurrentRenderTarget(); // no fixed bs.
	
	switch(script_command)
	{
		case RECTR:
			set_drawing_command_args(j, 12);
			break;
			
		case FRAMER:
			set_drawing_command_args(j, 9);
			break;
			
		case CIRCLER:
			set_drawing_command_args(j, 11);
			break;
			
		case ARCR:
			set_drawing_command_args(j, 14);
			break;
			
		case ELLIPSER:
			set_drawing_command_args(j, 12);
			break;
			
		case LINER:
			set_drawing_command_args(j, 11);
			break;
			
		case PUTPIXELR:
			set_drawing_command_args(j, 8);
			break;
		
		case PIXELARRAYR:
		{
			set_drawing_command_args(j, 5);
			std::vector<int32_t> *v = script_drawing_commands.GetVector();
			//for ( int32_t q = 0; q < 6; q++ ) 
			//{ 
			//	zprint("PIXELARRAY script_drawing_commands[j][%d] is %d\n", q, script_drawing_commands[j][q]);
			//}
			int32_t arrayptr = script_drawing_commands[j][2]/10000;
			if ( !arrayptr ) //Don't crash because of vector size.
			{
				Z_scripterrlog("Invalid array pointer %d passed to Screen->PutPixels(). Aborting.", arrayptr);
				break;
			}
			//zprint("Pixelarray array pointer is: %d\n", arrayptr);
			int32_t sz = ArrayH::getSize(arrayptr);
			if(!sz)
			{
				script_drawing_commands.PopLast();
				return;
			}
			//ArrayH::getSize(script_drawing_commands[j][2]/10000);
			//zprint("Pixelarray size is: %d\n", sz);
			v->resize(sz, 0);
			int32_t* pos = &v->at(0);
			
			ArrayH::getValues(script_drawing_commands[j][2] / 10000, pos, sz);
			script_drawing_commands[j].SetVector(v);
			break;
		}
		
		case TILEARRAYR:
		{
			set_drawing_command_args(j, 2);
			std::vector<int32_t> *v = script_drawing_commands.GetVector();
			//for ( int32_t q = 0; q < 6; q++ ) 
			//{ 
			//	zprint("PIXELARRAY script_drawing_commands[j][%d] is %d\n", q, script_drawing_commands[j][q]);
			//}
			int32_t arrayptr = script_drawing_commands[j][2]/10000;
			if ( !arrayptr ) //Don't crash because of vector size.
			{
				Z_scripterrlog("Invalid array pointer %d passed to Screen->DrawTiles(). Aborting.", arrayptr);
				break;
			}
			//zprint("Pixelarray array pointer is: %d\n", arrayptr);
			int32_t sz = ArrayH::getSize(arrayptr);
			if(!sz)
			{
				script_drawing_commands.PopLast();
				return;
			}
			//ArrayH::getSize(script_drawing_commands[j][2]/10000);
			//zprint("Pixelarray size is: %d\n", sz);
			v->resize(sz, 0);
			int32_t* pos = &v->at(0);
			
			ArrayH::getValues(script_drawing_commands[j][2] / 10000, pos, sz);
			script_drawing_commands[j].SetVector(v);
			break;
			}
			
		case LINESARRAY:
		{
			set_drawing_command_args(j, 2);
			std::vector<int32_t> *v = script_drawing_commands.GetVector();
			//for ( int32_t q = 0; q < 6; q++ ) 
			//{ 
			//	zprint("PIXELARRAY script_drawing_commands[j][%d] is %d\n", q, script_drawing_commands[j][q]);
			//}
			int32_t arrayptr = script_drawing_commands[j][2]/10000;
			if ( !arrayptr ) //Don't crash because of vector size.
			{
				Z_scripterrlog("Invalid array pointer %d passed to Screen->Lines(). Aborting.", arrayptr);
				break;
			}
			//zprint("Pixelarray array pointer is: %d\n", arrayptr);
			int32_t sz = ArrayH::getSize(arrayptr);
			if(!sz)
			{
				script_drawing_commands.PopLast();
				return;
			}
			//ArrayH::getSize(script_drawing_commands[j][2]/10000);
			//zprint("Pixelarray size is: %d\n", sz);
			v->resize(sz, 0);
			int32_t* pos = &v->at(0);
			
			ArrayH::getValues(script_drawing_commands[j][2] / 10000, pos, sz);
			script_drawing_commands[j].SetVector(v);
			break;
			}
		
			/*
			historical-old-master
			set_drawing_command_args(j, 6);
			int32_t count = script_drawing_commands[j][2] / 10000; //todo: errcheck

			int32_t* ptr = (int32_t*)script_drawing_commands.AllocateDrawBuffer(3 * count * sizeof(int32_t));
			int32_t* p = ptr;

			ArrayH::getValues(script_drawing_commands[j][3] / 10000, p, count); p += count;
			ArrayH::getValues(script_drawing_commands[j][4] / 10000, p, count); p += count;
			ArrayH::getValues(script_drawing_commands[j][5] / 10000, p, count);

			script_drawing_commands[j].SetPtr(ptr);
			*/
			// Unused
			//const int32_t index = script_drawing_commands[j][19] = j;
			
			//std::array    *aptr = script_drawing_commands.GetString();
			//ArrayH::getString(script_drawing_commands[j][2] / 10000, *aptr);
			//script_drawing_commands[j].SetArray(aptr);
			//set_drawing_command_args(j, 2);
			//break;
			
		case COMBOARRAYR:
		{
			set_drawing_command_args(j, 2);
			std::vector<int32_t> *v = script_drawing_commands.GetVector();
			//for ( int32_t q = 0; q < 6; q++ ) 
			//{ 
			//	zprint("PIXELARRAY script_drawing_commands[j][%d] is %d\n", q, script_drawing_commands[j][q]);
			//}
			int32_t arrayptr = script_drawing_commands[j][2]/10000;
			if ( !arrayptr ) //Don't crash because of vector size.
			{
				Z_scripterrlog("Invalid array pointer %d passed to Screen->DrawCombos(). Aborting.", arrayptr);
				break;
			}
			//zprint("Pixelarray array pointer is: %d\n", arrayptr);
			int32_t sz = ArrayH::getSize(arrayptr);
			if(!sz)
			{
				script_drawing_commands.PopLast();
				return;
			}
			//ArrayH::getSize(script_drawing_commands[j][2]/10000);
			//zprint("Pixelarray size is: %d\n", sz);
			v->resize(sz, 0);
			int32_t* pos = &v->at(0);
			
			ArrayH::getValues(script_drawing_commands[j][2] / 10000, pos, sz);
			script_drawing_commands[j].SetVector(v);
			break;
		}
		case POLYGONR:
		{
			set_drawing_command_args(j, 5);
				
			int32_t arrayptr = script_drawing_commands[j][3]/10000;
			if ( !arrayptr ) //Don't crash because of vector size.
			{
				Z_scripterrlog("Invalid array pointer %d passed to Screen->Polygon(). Aborting.", arrayptr);
				break;
			}
			int32_t sz = ArrayH::getSize(arrayptr);
			if(!sz)
			{
				script_drawing_commands.PopLast();
				return;
			}
				
			std::vector<int32_t> *v = script_drawing_commands.GetVector();
			v->resize(sz, 0);
			
			int32_t* pos = &v->at(0);
			
			
			ArrayH::getValues(script_drawing_commands[j][3] / 10000, pos, sz);
			script_drawing_commands[j].SetVector(v);
		}
		break;
			
		case DRAWTILER:
			set_drawing_command_args(j, 15);
			break;
			
		case DRAWTILECLOAKEDR:
			set_drawing_command_args(j, 7);
			break;
			
		case DRAWCOMBOR:
			set_drawing_command_args(j, 16);
			break;
			
		case DRAWCOMBOCLOAKEDR:
			set_drawing_command_args(j, 7);
			break;
			
		case FASTTILER:
			set_drawing_command_args(j, 6);
			break;
			
		case FASTCOMBOR:
			set_drawing_command_args(j, 6);
			break;
			
		case DRAWCHARR:
			set_drawing_command_args(j, 10);
			break;
			
		case DRAWINTR:
			set_drawing_command_args(j, 11);
			break;
			
		case SPLINER:
			set_drawing_command_args(j, 11);
			break;
			
		case QUADR:
			set_drawing_command_args(j, 15);
			break;
			
		case TRIANGLER:
			set_drawing_command_args(j, 13);
			break;
			
		case BITMAPR:
			set_drawing_command_args(j, 12);
			break;
		
		case BITMAPEXR:
			set_drawing_command_args(j, 16);
			break;
			
		case DRAWLAYERR:
			set_drawing_command_args(j, 8);
			break;
			
		case DRAWSCREENR:
			set_drawing_command_args(j, 6);
			break;
			
		case QUAD3DR:
		{
			set_drawing_command_args(j, 8);
			int32_t arrayptr = script_drawing_commands[j][2]/10000;
			int32_t sz = ArrayH::getSize(arrayptr);
			arrayptr = script_drawing_commands[j][3]/10000;
			sz += ArrayH::getSize(arrayptr);
			arrayptr = script_drawing_commands[j][4]/10000;
			sz += ArrayH::getSize(arrayptr);
			arrayptr = script_drawing_commands[j][5]/10000;
			sz += ArrayH::getSize(arrayptr);
			if(sz < 25)
			{
				script_drawing_commands.PopLast();
				return;
			}
			std::vector<int32_t> *v = script_drawing_commands.GetVector();
			v->resize(sz, 0);
			
			int32_t* pos = &v->at(0);
			int32_t* uv = &v->at(12);
			int32_t* col = &v->at(20);
			int32_t* size = &v->at(24);
			
			ArrayH::getValues((script_drawing_commands[j][2] / 10000), pos, 12);
			ArrayH::getValues((script_drawing_commands[j][3] / 10000), uv, 8);
			ArrayH::getValues((script_drawing_commands[j][4] / 10000), col, 4);
			//FFCore.getValues2(script_drawing_commands[j][5] / 10000, size, 2);
			ArrayH::getValues((script_drawing_commands[j][5] / 10000), size, 2);
			
			script_drawing_commands[j].SetVector(v);
		}
		break;
		
		case TRIANGLE3DR:
		{
			set_drawing_command_args(j, 8);
				
			int32_t arrayptr = script_drawing_commands[j][2]/10000;
			int32_t sz = ArrayH::getSize(arrayptr);
			arrayptr = script_drawing_commands[j][3]/10000;
			sz += ArrayH::getSize(arrayptr);
			arrayptr = script_drawing_commands[j][4]/10000;
			sz += ArrayH::getSize(arrayptr);
			arrayptr = script_drawing_commands[j][5]/10000;
			sz += ArrayH::getSize(arrayptr);
			if(sz < 19)
			{
				script_drawing_commands.PopLast();
				return;
			}
			
			std::vector<int32_t> *v = script_drawing_commands.GetVector();
			v->resize(sz, 0);
			
			int32_t* pos = &v->at(0);
			int32_t* uv = &v->at(9);
			int32_t* col = &v->at(15);
			int32_t* size = &v->at(18);
			
			ArrayH::getValues(script_drawing_commands[j][2] / 10000, pos, 8);
			ArrayH::getValues(script_drawing_commands[j][3] / 10000, uv, 6);
			ArrayH::getValues(script_drawing_commands[j][4] / 10000, col, 3);
			ArrayH::getValues(script_drawing_commands[j][5] / 10000, size, 2);
			
			script_drawing_commands[j].SetVector(v);
		}
		break;
		
		case DRAWSTRINGR:
		{
			set_drawing_command_args(j, 9);
			// Unused
			//const int32_t index = script_drawing_commands[j][19] = j;
			
			string *str = script_drawing_commands.GetString();
			ArrayH::getString(script_drawing_commands[j][8] / 10000, *str, 256);
			script_drawing_commands[j].SetString(str);
		}
		break;
		
		case DRAWSTRINGR2:
		{
			set_drawing_command_args(j, 11);
			// Unused
			//const int32_t index = script_drawing_commands[j][19] = j;
			
			string *str = script_drawing_commands.GetString();
			ArrayH::getString(script_drawing_commands[j][8] / 10000, *str, 256);
			script_drawing_commands[j].SetString(str);
		}
		break;
		
		case BMPRECTR:	
			set_user_bitmap_command_args(j, 12); script_drawing_commands[j][17] = SH::read_stack(ri->sp+12);
			//Pop the args off the stack first. Then pop the pointer and push it to sdci[17]. 
			//The pointer for the bitmap variable (its literal value) is always ri->sp+numargs, so, with 12 args, it is sp+12.
			break;
		
		case BMPFRAMER:	
			set_user_bitmap_command_args(j, 9);
			script_drawing_commands[j][17] = SH::read_stack(ri->sp+9);
			break;
			
		case CLEARBITMAP:	
		{
			set_user_bitmap_command_args(j, 1);
			script_drawing_commands[j][17] = SH::read_stack(ri->sp+1); 
			break;
		}
		case BITMAPCLEARTOCOLOR:	
		{
			set_user_bitmap_command_args(j, 2);
			script_drawing_commands[j][17] = SH::read_stack(ri->sp+2); 
			break;
		}
		case REGENERATEBITMAP:	
		{
			set_user_bitmap_command_args(j, 3);
			script_drawing_commands[j][17] = SH::read_stack(ri->sp+3);
			break;
		}
		case BMPPOLYGONR:
		{
			set_user_bitmap_command_args(j, 5);
			script_drawing_commands[j][17] = SH::read_stack(ri->sp+5); 
			int32_t arrayptr = script_drawing_commands[j][3]/10000;
			if ( !arrayptr ) //Don't crash because of vector size.
			{
				Z_scripterrlog("Invalid array pointer %d passed to Screen->Polygon(). Aborting.", arrayptr);
				break;
			}
			int32_t sz = ArrayH::getSize(arrayptr);
			if(!sz)
			{
				script_drawing_commands.PopLast();
				return;
			}
			std::vector<int32_t> *v = script_drawing_commands.GetVector();
			v->resize(sz, 0);
			
			int32_t* pos = &v->at(0);
			
			
			ArrayH::getValues(script_drawing_commands[j][3] / 10000, pos, sz);
			script_drawing_commands[j].SetVector(v);
		}
		break;
		case READBITMAP:	
		{
			//zprint("Calling %s\n","READBITMAP");
			set_user_bitmap_command_args(j, 2);
			script_drawing_commands[j][17] = SH::read_stack(ri->sp+2);
			string *str = script_drawing_commands.GetString();
			ArrayH::getString(script_drawing_commands[j][2] / 10000, *str, 256);
			
			//char cptr = new char[str->size()+1]; // +1 to account for \0 byte
			//strncpy(cptr, str->c_str(), str->size());
			
			if(get_qr(qr_BITMAP_AND_FILESYSTEM_PATHS_ALWAYS_RELATIVE))
			{
				char buf[2048+1] = {0};
				if(FFCore.get_scriptfile_path(buf, str->c_str()))
					(*str) = buf;
			}
			regulate_path(*str);
			
			//zprint("READBITMAP string is %s\n", cptr);
			
			script_drawing_commands[j].SetString(str);
			break;
		}
		case WRITEBITMAP:	
		{
			//zprint("Calling %s\n","WRITEBITMAP");
			set_user_bitmap_command_args(j, 3);
			script_drawing_commands[j][17] = SH::read_stack(ri->sp+3); 
			std::string *str = script_drawing_commands.GetString();
			ArrayH::getString(script_drawing_commands[j][2] / 10000, *str, 256);
			
			
			//char *cptr = new char[str->size()+1]; // +1 to account for \0 byte
			//strncpy(cptr, str->c_str(), str->size());
			
			if(get_qr(qr_BITMAP_AND_FILESYSTEM_PATHS_ALWAYS_RELATIVE))
			{
				char buf[2048+1] = {0};
				if(FFCore.get_scriptfile_path(buf, str->c_str()))
					(*str) = buf;
			}
			regulate_path(*str);
			
			//zprint("WRITEBITMAP string is %s\n", cptr);
			script_drawing_commands[j].SetString(str);
			break;
		}
		
		case BMPCIRCLER:	set_user_bitmap_command_args(j, 11); script_drawing_commands[j][17] = SH::read_stack(ri->sp+11);  break;
		case BMPARCR:	set_user_bitmap_command_args(j, 14); script_drawing_commands[j][17] = SH::read_stack(ri->sp+14);  break;
		case BMPELLIPSER:	set_user_bitmap_command_args(j, 12); script_drawing_commands[j][17] = SH::read_stack(ri->sp+12);  break;
		case BMPLINER:	set_user_bitmap_command_args(j, 11); script_drawing_commands[j][17] = SH::read_stack(ri->sp+11); break;
		case BMPSPLINER:	set_user_bitmap_command_args(j, 11); script_drawing_commands[j][17] = SH::read_stack(ri->sp+11); break;
		case BMPPUTPIXELR:	set_user_bitmap_command_args(j, 8); script_drawing_commands[j][17] = SH::read_stack(ri->sp+8); break;
		case BMPDRAWTILER:	set_user_bitmap_command_args(j, 15); script_drawing_commands[j][17] = SH::read_stack(ri->sp+15); break;
		case BMPDRAWTILECLOAKEDR:	set_user_bitmap_command_args(j, 7); script_drawing_commands[j][17] = SH::read_stack(ri->sp+7); break;
		case BMPDRAWCOMBOR:	set_user_bitmap_command_args(j, 16); script_drawing_commands[j][17] = SH::read_stack(ri->sp+16); break;
		case BMPDRAWCOMBOCLOAKEDR:	set_user_bitmap_command_args(j, 7); script_drawing_commands[j][17] = SH::read_stack(ri->sp+7); break;
		case BMPFASTTILER:	set_user_bitmap_command_args(j, 6); script_drawing_commands[j][17] = SH::read_stack(ri->sp+6); break;
		case BMPFASTCOMBOR:  set_user_bitmap_command_args(j, 6); script_drawing_commands[j][17] = SH::read_stack(ri->sp+6); break;
		case BMPDRAWCHARR:	set_user_bitmap_command_args(j, 10); script_drawing_commands[j][17] = SH::read_stack(ri->sp+10); break;
		case BMPDRAWINTR:	set_user_bitmap_command_args(j, 11); script_drawing_commands[j][17] = SH::read_stack(ri->sp+11); break;
		case BMPDRAWSTRINGR:	
		{
			set_user_bitmap_command_args(j, 9);
			script_drawing_commands[j][17] = SH::read_stack(ri->sp+9);
			// Unused
			//const int32_t index = script_drawing_commands[j][19] = j;
			
			string *str = script_drawing_commands.GetString();
			ArrayH::getString(script_drawing_commands[j][8] / 10000, *str, 256);
			script_drawing_commands[j].SetString(str);
			
		}
		break;
		case BMPDRAWSTRINGR2:	
		{
			set_user_bitmap_command_args(j, 11);
			script_drawing_commands[j][17] = SH::read_stack(ri->sp+11);
			// Unused
			//const int32_t index = script_drawing_commands[j][19] = j;
			
			string *str = script_drawing_commands.GetString();
			ArrayH::getString(script_drawing_commands[j][8] / 10000, *str, 256);
			script_drawing_commands[j].SetString(str);
			
		}
		break;
		case BMPQUADR:	set_user_bitmap_command_args(j, 16);  script_drawing_commands[j][17] = SH::read_stack(ri->sp+16); break;
		case BMPQUAD3DR:
		{
			set_drawing_command_args(j, 9);
			std::vector<int32_t> *v = script_drawing_commands.GetVector();
			v->resize(26, 0);
			
			int32_t* pos = &v->at(0);
			int32_t* uv = &v->at(12);
			int32_t* col = &v->at(20);
			int32_t* size = &v->at(24);
			
			
			ArrayH::getValues(script_drawing_commands[j][2] / 10000, pos, 12);
			ArrayH::getValues(script_drawing_commands[j][3] / 10000, uv, 8);
			ArrayH::getValues(script_drawing_commands[j][4] / 10000, col, 4);
			ArrayH::getValues(script_drawing_commands[j][5] / 10000, size, 2);
			
			script_drawing_commands[j].SetVector(v);
			script_drawing_commands[j][17] = SH::read_stack(ri->sp+9);
			
		}
		break;
		case BMPTRIANGLER:	set_user_bitmap_command_args(j, 14); script_drawing_commands[j][17] = SH::read_stack(ri->sp+14); break;
		case BMPTRIANGLE3DR:
		{
			set_drawing_command_args(j, 9);
			
			std::vector<int32_t> *v = script_drawing_commands.GetVector();
			v->resize(20, 0);
			
			int32_t* pos = &v->at(0);
			int32_t* uv = &v->at(9);
			int32_t* col = &v->at(15);
			int32_t* size = &v->at(18);
			
			
			ArrayH::getValues(script_drawing_commands[j][2] / 10000, pos, 8);
			ArrayH::getValues(script_drawing_commands[j][3] / 10000, uv, 6);
			ArrayH::getValues(script_drawing_commands[j][4] / 10000, col, 3);
			ArrayH::getValues(script_drawing_commands[j][5] / 10000, size, 2);
			
			script_drawing_commands[j].SetVector(v);
			script_drawing_commands[j][17] = SH::read_stack(ri->sp+9);
			break;
		}
		
		case BMPDRAWLAYERR:
			set_user_bitmap_command_args(j, 8);
			script_drawing_commands[j][17] = SH::read_stack(ri->sp+8);
			break;
		case BMPDRAWLAYERSOLIDR: 
		case BMPDRAWLAYERCFLAGR: 
		case BMPDRAWLAYERCTYPER: 
		case BMPDRAWLAYERCIFLAGR: 
		case BMPDRAWLAYERSOLIDITYR: set_user_bitmap_command_args(j, 9); script_drawing_commands[j][17] = SH::read_stack(ri->sp+9); break;
		case BMPDRAWSCREENR:
		case BMPDRAWSCREENSOLIDR:
		case BMPDRAWSCREENSOLID2R:
		case BMPDRAWSCREENCOMBOFR:
		case BMPDRAWSCREENCOMBOIR:
		case BMPDRAWSCREENCOMBOTR:
			set_user_bitmap_command_args(j, 6); script_drawing_commands[j][17] = SH::read_stack(ri->sp+6); break;
		case BITMAPGETPIXEL:
		{
			//UNUSED
			// for(int32_t q = 0; q < 20; q++)
			// {
				// Z_scripterrlog("getpixel SH::read_stack(ri->sp+%d) is: %d\n", q, SH::read_stack(ri->sp+q));
			// }
			set_user_bitmap_command_args(j, 3); script_drawing_commands[j][17] = SH::read_stack(ri->sp+3);
			break;
		}
		case BMPBLIT:	
		{
			set_user_bitmap_command_args(j, 16); 
			//for(int32_t q = 0; q < 8; ++q )
			//Z_scripterrlog("FFscript blit() ri->d[%d] is: %d\n", q, ri->d[q]);
			script_drawing_commands[j][17] = SH::read_stack(ri->sp+16);
			break;
		}
		case BMPBLITTO:	
		{
			set_user_bitmap_command_args(j, 16); 
			//for(int32_t q = 0; q < 8; ++q )
			//Z_scripterrlog("FFscript blit() ri->d[%d] is: %d\n", q, ri->d[q]);
			script_drawing_commands[j][17] = SH::read_stack(ri->sp+16);
			break;
		}
		case BMPMODE7:	
		{
			set_user_bitmap_command_args(j, 13); 
			//for(int32_t q = 0; q < 8; ++q )
			//Z_scripterrlog("FFscript blit() ri->d[%d] is: %d\n", q, ri->d[q]);
			script_drawing_commands[j][17] = SH::read_stack(ri->sp+13);
			break;
		}
		
		case BMPWRITETILE:
		{
			set_user_bitmap_command_args(j, 6);
			script_drawing_commands[j][17] = SH::read_stack(ri->sp+6);
			break;
		}
		case BMPDITHER:
		{
			set_user_bitmap_command_args(j, 5);
			script_drawing_commands[j][17] = SH::read_stack(ri->sp+5);
			break;
		}
		case BMPMASKDRAW:
		{
			set_user_bitmap_command_args(j, 3);
			script_drawing_commands[j][4] = 0x01 * 10000L;
			script_drawing_commands[j][5] = 0xFF * 10000L;
			script_drawing_commands[j][17] = SH::read_stack(ri->sp+3);
			break;
		}
		case BMPMASKDRAW2:
		{
			set_user_bitmap_command_args(j, 4);
			script_drawing_commands[j][5] = script_drawing_commands[j][4];
			script_drawing_commands[j][0] = BMPMASKDRAW;
			script_drawing_commands[j][17] = SH::read_stack(ri->sp+4);
			break;
		}
		case BMPMASKDRAW3:
		{
			set_user_bitmap_command_args(j, 5);
			script_drawing_commands[j][0] = BMPMASKDRAW;
			script_drawing_commands[j][17] = SH::read_stack(ri->sp+5);
			break;
		}
		case BMPMASKBLIT:
		{
			set_user_bitmap_command_args(j, 4);
			script_drawing_commands[j][5] = 0x01 * 10000L;
			script_drawing_commands[j][6] = 0xFF * 10000L;
			script_drawing_commands[j][17] = SH::read_stack(ri->sp+4);
			break;
		}
		case BMPMASKBLIT2:
		{
			set_user_bitmap_command_args(j, 5);
			script_drawing_commands[j][6] = script_drawing_commands[j][5];
			script_drawing_commands[j][0] = BMPMASKBLIT;
			script_drawing_commands[j][17] = SH::read_stack(ri->sp+5);
			break;
		}
		case BMPMASKBLIT3:
		{
			set_user_bitmap_command_args(j, 6);
			script_drawing_commands[j][0] = BMPMASKBLIT;
			script_drawing_commands[j][17] = SH::read_stack(ri->sp+6);
			break;
		}
		case BMPREPLCOLOR:
		case BMPSHIFTCOLOR:
		{
			set_user_bitmap_command_args(j, 4);
			script_drawing_commands[j][17] = SH::read_stack(ri->sp+4);
			break;			
		}
	}
	script_drawing_commands.mark_dirty(script_drawing_commands[j][1]/10000);
}

void do_set_rendertarget(bool)
{
	int32_t target = int32_t(SH::read_stack(ri->sp) / 10000);
	zscriptDrawingRenderTarget->SetCurrentRenderTarget(target);
}

void do_sfx(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkSFXID(ID, "Audio->PlaySound") != SH::_NoError)
		return;
		
	sfx(ID);
}

void do_sfx_ex(const bool restart)
{
	int32_t ID = SH::read_stack(ri->sp + 4) / 10000;
	int32_t vol = vbound(SH::read_stack(ri->sp + 3), 0, 10000 * 100);
	int32_t pan = vbound(SH::read_stack(ri->sp + 2)/10000 + 128, 0, 255);
	int32_t freq = SH::read_stack(ri->sp + 1);
	bool loop = SH::read_stack(ri->sp) / 10000;

	if (BC::checkSFXID(ID, restart?"Audio->PlaySound":"Audio->AdjustSound") != SH::_NoError)
		return;

	if (!restart && !sfx_allocated(ID))
		return;

	sfx(ID, pan, loop, restart, vol, freq);
}

static int get_sfx_completion()
{
	int32_t ID = get_register(sarg1) / 10000;

	if (!sfx_allocated(ID))
	{
		return -10000;
	}

	uint64_t sample_pos = voice_get_position(sfx_voice[ID]);

	if (sample_pos < 0)
	{
		return -10000;
	}

	uint32_t sample_length = sfx_get_length(ID);
	uint64_t res = (sample_pos * 10000 * 100) / sample_length;
	return int32_t(res);
}

void do_get_sfx_completion()
{
	int32_t ID = get_register(sarg1) / 10000;
	if (replay_is_active())
		replay_step_comment(fmt::format("ID {}", ID));
	int32_t value = replay_get_state(ReplayStateType::SfxPosition, get_sfx_completion);
	set_register(sarg1, value);
}

int32_t FFScript::do_get_internal_uid_npc(int32_t index)
{
	return ((int32_t)guys.spr(index)->getUID());
}
int32_t FFScript::do_get_internal_uid_item(int32_t index)
{
	return ((int32_t)items.spr(index)->getUID());
}
int32_t FFScript::do_get_internal_uid_lweapon(int32_t index)
{
	return ((int32_t)Lwpns.spr(index)->getUID());
}
int32_t FFScript::do_get_internal_uid_eweapon(int32_t index)
{
	return ((int32_t)Ewpns.spr(index)->getUID());
}

void FFScript::AlloffLimited(int32_t flagset)
{
	clear_bitmap(msg_txt_display_buf);
	clear_bitmap(msg_bg_display_buf);
	clear_bitmap(msg_portrait_display_buf);
	set_clip_state(msg_txt_display_buf, 1);
	set_clip_state(msg_bg_display_buf, 1);
	set_clip_state(msg_portrait_display_buf, 1);
	
	
	clear_bitmap(pricesdisplaybuf);
	set_clip_state(pricesdisplaybuf, 1);
	
	if(items.idCount(iPile))
	{
		loadlvlpal(DMaps[currdmap].color);
	}
	
	/*
	
	#define warpFlagCLEARITEMS 0x200
	#define warpFlagCLEARGUYS 0x400
	#define warpFlagCLEARLWEAPONS 0x800
	#define warpFlagCLEAREWEAPONS 0x1000
	#define warpFlagCLEARHOOKSHOT 0x2000
	#define warpFlagCLEARDECORATIONS 0x4000
	#define warpFlagCLEARPARTICLES 0x8000
	*/
	
	if ( (flagset&warpFlagCLEARITEMS) ) items.clear();
	if ( (flagset&warpFlagCLEARGUYS) ) guys.clear();
	if ( (flagset&warpFlagCLEARLWEAPONS) ) Lwpns.clear();
	if ( (flagset&warpFlagCLEAREWEAPONS) ) Ewpns.clear();
	if ( (flagset&warpFlagCLEARHOOKSHOT) ) 
	{
		chainlinks.clear();
		Hero.reset_hookshot();
	}
	if ( (flagset&warpFlagCLEARDECORATIONS) ) decorations.clear();
	if ( (flagset&warpFlagCLEARPARTICLES) ) particles.clear();
	clearScriptHelperData();
	
	
	
	clearScriptHelperData();
	
	lensclk = 0;
	lensid=-1;
	drawguys=true;
	down_control_states[btnUp] =
		down_control_states[btnDown] =
			down_control_states[btnLeft] =
				down_control_states[btnRight] =
					down_control_states[btnA] =
						down_control_states[btnB] =
							down_control_states[btnS] = true;

	if(watch && !cheat_superman)
	{
		Hero.setClock(false);
	}
	
	//  if(watch)
	//    Hero.setClock(false);
	watch=freeze_guys=loaded_guys=loaded_enemies=blockpath=false;
	
	for(int32_t i=0; i<176; i++)
		guygrid[i]=0;
	
	for(int32_t i=0; i<MAXFFCS; i++)
		guygridffc[i]=0;
		
	
	sle_clk=0;
	
	if(usebombpal)
	{
		memcpy(RAMpal, tempbombpal, PAL_SIZE*sizeof(RGB));
		refreshpal=true;
		usebombpal=false;
	}
	
	
}

void doWarpEffect(int32_t warpEffect, bool out)
{
	switch(warpEffect)
	{
		case warpEffectZap:
			if(out) zapout();
			else zapin();
			break;
		case warpEffectWave:
			if(out) wavyout(false);
			else wavyin();
			break;
		case warpEffectInstant:
			if(out) blackscr(30,true);
			break;
		case warpEffectMozaic:
			//!TODO Unimplemented
			break;
		case warpEffectOpen:
			if(out) closescreen();
			else openscreen();
			break;
	}
}

void FFScript::queueWarp(int32_t wtype, int32_t tdm, int32_t tscr, int32_t wx, int32_t wy,
	int32_t weff, int32_t wsfx, int32_t wflag, int32_t wdir)
{
	warpex[wexActive] = 1;
	warpex[wexType] = wtype;
	warpex[wexDMap] = tdm;
	warpex[wexScreen] = tscr;
	warpex[wexX] = wx;
	warpex[wexY] = wy;
	warpex[wexEffect] = weff;
	warpex[wexSound] = wsfx;
	warpex[wexFlags] = wflag;
	warpex[wexDir] = wdir;
}

bool FFScript::warp_player(int32_t warpType, int32_t dmapID, int32_t scrID, int32_t warpDestX, int32_t warpDestY, int32_t warpEffect, int32_t warpSound, int32_t warpFlags, int32_t heroFacesDir)
{
	if(DEVLOGGING)
	{
		zprint("FFScript::warp_player() arg %s is: %d \n", "warpType", warpType);
		zprint("FFScript::warp_player() arg %s is: %d \n", "dmapID", dmapID);
		zprint("FFScript::warp_player() arg %s is: %d \n", "scrID", scrID);
		zprint("FFScript::warp_player() arg %s is: %d \n", "warpDestX", warpDestX);
		zprint("FFScript::warp_player() arg %s is: %d \n", "warpDestY", warpDestY);
		zprint("FFScript::warp_player() arg %s is: %d \n", "warpEffect", warpEffect);
		zprint("FFScript::warp_player() arg %s is: %d \n", "warpSound", warpSound);
		zprint("FFScript::warp_player() arg %s is: %d \n", "warpFlags", warpFlags);
		zprint("FFScript::warp_player() arg %s is: %d \n", "heroFacesDir", heroFacesDir);
	}
	if ( ((unsigned)dmapID) >= MAXDMAPS ) 
	{
		Z_scripterrlog("Invalid DMap ID (%d) passed to WarpEx(). Aborting.\n", dmapID);
		return false;
	}
	if ( ((unsigned)scrID) >= MAPSCRS ) 
	{
		Z_scripterrlog("Invalid Screen ID (%d) passed to WarpEx(). Aborting.\n", scrID);
		return false;
	}
	//Extra sanity guard. 
	if ( DMaps[dmapID].map*MAPSCRS+DMaps[dmapID].xoff+scrID >= (int32_t)TheMaps.size() )
	{
		Z_scripterrlog("Invalid destination passed to WarpEx(). Aborting.\n");
		return false;
	}
	byte t = 0;
	t=(currscr<128)?0:1;
	bool overlay=false;
	bool intradmap = (dmapID == currdmap);
	int32_t olddmap = currdmap;
	//if ( intradmap ) 
	//{
	//	initZScriptDMapScripts();    //Not needed.
	//}

	if ( warpType == wtNOWARP ) { Z_eventlog("Used a Cancel Warped to DMap %d: %s, screen %d", currdmap, DMaps[currdmap].name,currscr); return false; }
	int32_t mapID = (DMaps[dmapID].map+1);
	int32_t dest_dmap_xoff = DMaps[dmapID].xoff;	
	//mapscr *m = &TheMaps[mapID * MAPSCRS + scrID]; 
	mapscr *m = &TheMaps[(zc_max((mapID)-1,0) * MAPSCRS + dest_dmap_xoff + scrID)];
	if ( warpFlags&warpFlagNOSTEPFORWARD ) FFCore.temp_no_stepforward = 1;
	int32_t wx = 0, wy = 0;
	if ( warpDestX < 0 )
	{
		if(DEVLOGGING) zprint("WarpEx() was set to warp return point:%d\n", warpDestY); 
		if ( (unsigned)warpDestY < 4 )
		{
			wx = m->warpreturnx[warpDestY];
			wy = m->warpreturny[warpDestY];
			if(DEVLOGGING)
			{
				zprint("WarpEx Return Point X is: %d\n",wx);
				zprint("WarpEx Return Point Y is: %d\n",wy);
			}
		}
		else
		{
			if ( warpDestY == 5 || warpDestY < 0)
			{
				//Pit warp
				wx = Hero.getX();
				wy = Hero.getY();
			}
			else
			{
				Z_scripterrlog("Invalid Warp Return Square Type (%d) provided as an arg to Player->WarpEx().\n",warpDestY);
				return false;
			}
		}
	}
	else 
	{
		if ( (unsigned)warpDestX < 256 && (unsigned)warpDestY < 176 )
		{
			wx = warpDestX;
			wy = warpDestY;
		}
		else
		{
			Z_scripterrlog("Invalid pixel coordinates of x = %d, y = %d, supplied to Player->WarpEx()\n",warpDestX,warpDestY);
			return false;
		}
		
	} 
	//warp coordinates are wx, wy, not x, y! -Z
	if ( !(warpFlags&warpFlagDONTKILLSCRIPTDRAWS) ) script_drawing_commands.Clear();
	//we also need to check if dmaps are sideview here! -Z
	//Likewise, we need to add that check to the normal Hero:;dowarp(0
	bool wasSideview = isSideViewGravity(t); //((tmpscr[t].flags7 & fSIDEVIEW)!=0 || DMaps[currdmap].sideview) && !ignoreSideview;
	
	//int32_t last_entr_scr = -1;
	//int32_t last_entr_dmap = -1;
	
	if ( warpType < wtEXIT ) warpType = wtIWARP; //Sanity check. We can't use wtCave, or wtPassage, with scritped warps at present.
	Hero.is_warping = true;
	switch(warpType)
	{
		
		//wtCAVE, wtPASS, wtEXIT, wtSCROLL, wtIWARP, wtIWARPBLK, wtIWARPOPEN,
		//wtIWARPZAP, wtIWARPWAVE, wtNOWARP, wtWHISTLE, wtMAX
			
		
		case wtIWARP:
		case wtIWARPBLK:
		case wtIWARPOPEN:
		case wtIWARPZAP:
		case wtIWARPWAVE: 
		{
			bool wasswimming = (Hero.getAction()==swimming);
			bool wassideswim = (Hero.getAction()==sideswimming);
			int32_t olddiveclk = Hero.diveclk;
			if ( !(warpFlags&warpFlagDONTCLEARSPRITES) )
			{
				ALLOFF();
			}
			else FFCore.AlloffLimited(warpFlags);
			if (warpFlags&warpFlagFORCERESETMUSIC) music_stop();
			if ( !(warpFlags&warpFlagDONTKILLSOUNDS) ) kill_sfx();
			sfx(warpSound);
			if(wasswimming)
			{
				Hero.setAction(swimming); FFCore.setHeroAction(swimming);
				Hero.diveclk = olddiveclk;
			}
			if(wassideswim)
			{
				Hero.setAction(sideswimming); FFCore.setHeroAction(sideswimming);
				Hero.diveclk = 0;
			}
			doWarpEffect(warpEffect, true);
			int32_t c = DMaps[currdmap].color;
			bool changedlevel = false;
			bool changeddmap = false;
			if(currdmap != dmapID)
			{
				timeExitAllGenscript(GENSCR_ST_CHANGE_DMAP);
				changeddmap = true;
			}
			if(dlevel != DMaps[dmapID].level)
			{
				timeExitAllGenscript(GENSCR_ST_CHANGE_LEVEL);
				changedlevel = true;
			}
			dlevel = DMaps[dmapID].level;
			currdmap = dmapID;
			if(changeddmap)
			{
				throwGenScriptEvent(GENSCR_EVENT_CHANGE_DMAP);
			}
			if(changedlevel)
			{
				throwGenScriptEvent(GENSCR_EVENT_CHANGE_LEVEL);
			}
			currmap = DMaps[currdmap].map;
			init_dmap();
			update_subscreens(dmapID);
			
			ringcolor(false);
			
			if(DMaps[currdmap].color != c)
				loadlvlpal(DMaps[currdmap].color);
				
			homescr = currscr = scrID + DMaps[currdmap].xoff;
			
			lightingInstant(); // Also sets naturaldark
			
			loadscr(0,currdmap,currscr,-1,overlay);
			
			Hero.x = (zfix)wx;
			Hero.y = (zfix)wy;
			
			switch(heroFacesDir)
			{
				case up:
				case down:
				case left:
				case right:
					Hero.dir = heroFacesDir;
					break;
				default:
					if((int32_t)Hero.x==(zfix)0)  
					{
						Hero.dir=right;
					}
					if((int32_t)Hero.x==(zfix)240) 
					{
						Hero.dir=left;
					}
					
					if((int32_t)Hero.y==(zfix)0)   
					{
						Hero.dir=down;
					}
					
					if((int32_t)Hero.y==(zfix)160) 
					{
						Hero.dir=up;
					}
			}
			
			markBmap(Hero.dir^1);
			
			if(iswaterex(MAPCOMBO((int32_t)Hero.x,(int32_t)Hero.y+8), currmap, currscr, -1, Hero.x, Hero.y+8, true) && _walkflag((int32_t)Hero.x,(int32_t)Hero.y+8,0) && current_item(itype_flippers))
			{
				Hero.hopclk=0xFF;
				Hero.attackclk = Hero.charging = Hero.spins = 0;
				if (isSideViewHero() && get_qr(qr_SIDESWIM)) {Hero.setAction(sideswimming); FFCore.setHeroAction(sideswimming);}
				else {Hero.setAction(swimming); FFCore.setHeroAction(swimming);}
			}
			else
			{
				Hero.setAction(none); FFCore.setHeroAction(none);
			}
				
			//preloaded freeform combos
			ffscript_engine(true);
			
			putscr(scrollbuf,0,0,tmpscr);
			putscrdoors(scrollbuf,0,0,tmpscr);
			
			doWarpEffect(warpEffect, false);
			show_subscreen_life=true;
			show_subscreen_numbers=true;
			if (!(warpFlags&warpFlagFORCECONTINUEMUSIC)) Play_Level_Music();
			currcset=DMaps[currdmap].color;
			dointro();
			Hero.set_respawn_point();
			Hero.trySideviewLadder();
			
			break;
		}
		
		
		case wtEXIT:
		{
			//zprint("%s was called with a warp type of Entrance/Exit\n", "Player->WarpEx()");
			lighting(false,false,pal_litRESETONLY);//Reset permLit, and do nothing else; lighting was not otherwise called on a wtEXIT warp.
			ALLOFF();
			if (warpFlags&warpFlagFORCERESETMUSIC) music_stop();
			if ( !(warpFlags&warpFlagDONTKILLSOUNDS) ) kill_sfx();
			sfx(warpSound);
			blackscr(30,false);
			bool changedlevel = false;
			bool changeddmap = false;
			if(currdmap != dmapID)
			{
				timeExitAllGenscript(GENSCR_ST_CHANGE_DMAP);
				changeddmap = true;
			}
			if(dlevel != DMaps[dmapID].level)
			{
				timeExitAllGenscript(GENSCR_ST_CHANGE_LEVEL);
				changedlevel = true;
			}
			dlevel = DMaps[dmapID].level;
			currdmap = dmapID;
			if(changeddmap)
			{
				throwGenScriptEvent(GENSCR_EVENT_CHANGE_DMAP);
			}
			if(changedlevel)
			{
				throwGenScriptEvent(GENSCR_EVENT_CHANGE_LEVEL);
			}
			currmap=DMaps[currdmap].map;
			init_dmap();
			update_subscreens(dmapID);
			loadfullpal();
			ringcolor(false);
			loadlvlpal(DMaps[currdmap].color);
			//lastentrance_dmap = currdmap;
			homescr = currscr = scrID + DMaps[currdmap].xoff;
			loadscr(0,currdmap,currscr,-1,overlay);
			
			if((tmpscr->flags&fDARK) && !get_qr(qr_NEW_DARKROOM))
			{
				if(get_qr(qr_FADE))
				{
				interpolatedfade();
				}
				else
				{
				loadfadepal((DMaps[currdmap].color)*pdLEVEL+poFADE3);
				}
				
				darkroom=naturaldark=true;
			}
			else
			{
				darkroom=naturaldark=false;
			}
				
			
			//Move Player's coordinates
			Hero.x = (zfix)wx;
			Hero.y = (zfix)wy;
			//set his dir
			switch(heroFacesDir)
			{
				case up:
				case down:
				case left:
				case right:
					Hero.dir = heroFacesDir;
					break;
				default:
					Hero.dir=down;
					if((int32_t)Hero.x==(zfix)0)  
					{
						Hero.dir=right;
					}
					if((int32_t)Hero.x==(zfix)240) 
					{
						Hero.dir=left;
					}
					
					if((int32_t)Hero.y==(zfix)0)   
					{
						Hero.dir=down;
					}
					
					if((int32_t)Hero.y==(zfix)160) 
					{
						Hero.dir=up;
					}
			}
			
			if(dlevel)
			{
				// reset enemy kill counts
				for(int32_t i=0; i<128; i++)
				{
					game->guys[(currmap*MAPSCRSNORMAL)+i] = 0;
					game->maps[(currmap*MAPSCRSNORMAL)+i] &= ~mTMPNORET;
				}
			}
			
			markBmap(Hero.dir^1);
			//preloaded freeform combos
			ffscript_engine(true);
			Hero.reset_hookshot();
			
			if(isdungeon())
			{
				openscreen();
				if(get_er(er_SHORTDGNWALK)==0 && get_qr(qr_SHORTDGNWALK)==0)
				Hero.stepforward(Hero.diagonalMovement?11:12, false);
				else
				// Didn't walk as far pre-1.93, and some quests depend on that
				Hero.stepforward(8, false);
			}
			else
			{
				openscreen();
			}
			
			show_subscreen_life=true;
			show_subscreen_numbers=true;
			if (!(warpFlags&warpFlagFORCECONTINUEMUSIC))Play_Level_Music();
			currcset=DMaps[currdmap].color;
			dointro();
			Hero.set_respawn_point();
			Hero.trySideviewLadder();
			
			for(int32_t i=0; i<6; i++)
				visited[i]=-1;
				
			//last_entr_scr = scrID;
			//last_entr_dmap = dmapID;
			
			break;
			
		}
		case wtSCROLL:                                          // scrolling warp
		{
			int32_t c = DMaps[currdmap].color;
			scrolling_map = currmap;
			currmap = DMaps[dmapID].map;
			update_subscreens(dmapID);
			
			dlevel = DMaps[dmapID].level;
				//check if Hero has the map for the new location before updating the subscreen. ? -Z
				//This works only in one direction, if Hero had a map, to not having one.
				//If Hero does not have a map, and warps somewhere where he does, then the map still briefly shows. 
			update_subscreens(dmapID);
				
			// if ( has_item(itype_map, dlevel) ) 
			// {
				// //Blank the map during an intra-dmap scrolling warp. 
				// dlevel = -1; //a hack for the minimap. This works!! -Z
			// }
				
			// fix the scrolling direction, if it was a tile or instant warp
			Hero.sdir = vbound(Hero.dir,0,3);
			
			
			Hero.scrollscr(Hero.sdir, scrID+DMaps[dmapID].xoff, dmapID);
			bool changedlevel = false;
			bool changeddmap = false;
			if(currdmap != dmapID)
			{
				timeExitAllGenscript(GENSCR_ST_CHANGE_DMAP);
				changeddmap = true;
			}
			if(dlevel != DMaps[dmapID].level)
			{
				timeExitAllGenscript(GENSCR_ST_CHANGE_LEVEL);
				changedlevel = true;
			}
			dlevel = DMaps[dmapID].level;
			currdmap = dmapID;
			if(changeddmap)
			{
				throwGenScriptEvent(GENSCR_EVENT_CHANGE_DMAP);
			}
			if(changedlevel)
			{
				throwGenScriptEvent(GENSCR_EVENT_CHANGE_LEVEL);
			}
			
			Hero.reset_hookshot();
			
			if(!intradmap)
			{
				currdmap = dmapID;
				dlevel = DMaps[currdmap].level;
				homescr = currscr = scrID + DMaps[dmapID].xoff;
				init_dmap();
				
				
				if(((wx>0||wy>0)||(get_qr(qr_WARPSIGNOREARRIVALPOINT)))&&(!get_qr(qr_NOSCROLLCONTINUE))&&(!(tmpscr->flags6&fNOCONTINUEHERE)))
				{
					if(dlevel)
					{
						lastentrance = currscr;
					}
					else
					{
						lastentrance = DMaps[currdmap].cont + DMaps[currdmap].xoff;
					}
					
					lastentrance_dmap = dmapID;
				}
			}
			
			if(DMaps[currdmap].color != c)
			{
				lighting(false, true);
			}
			
			if (!(warpFlags&warpFlagFORCECONTINUEMUSIC)) Play_Level_Music();
			currcset=DMaps[currdmap].color;
			dointro();
			break;
		}
		//Cannot use these types with scripts, or with strings. 
		case wtCAVE:
		case wtPASS:
		case wtWHISTLE:
		default: 
		{
			Z_scripterrlog("Invalid warp type (%d) supplied to Hero->WarpEx()!. Cannot warp!!\n", warpType);
			Hero.is_warping = false;
			return false;
		}
	}
	// Stop Hero from drowning!
	if(Hero.getAction()==drowning)
	{
		Hero.drownclk=0;
		Hero.setAction(none); FFCore.setHeroAction(none);
	}
		
	// But keep him swimming if he ought to be!
	if(Hero.getAction()!=rafting && iswaterex(MAPCOMBO((int32_t)Hero.x,(int32_t)Hero.y+8), currmap, currscr, -1, Hero.x, Hero.y+8, true) && (_walkflag((int32_t)Hero.x,(int32_t)Hero.y+8,0) || get_qr(qr_DROWN))
			&& (current_item(itype_flippers)) && (Hero.getAction()!=inwind))
	{
		Hero.hopclk=0xFF;
		if (isSideViewHero() && get_qr(qr_SIDESWIM)) {Hero.setAction(sideswimming); FFCore.setHeroAction(sideswimming);}
		else {Hero.setAction(swimming); FFCore.setHeroAction(swimming);}
	}
		
	newscr_clk=frame;
	activated_timed_warp=false;
	eat_buttons();
		
	if(warpType!=wtIWARP) { Hero.attackclk=0; }
		
	Hero.didstuff=0;
	Hero.usecounts.clear();
	map_bkgsfx(true);
	loadside=Hero.dir^1;
	whistleclk=-1;
		
	if(((int32_t)Hero.z>0 || (int32_t)Hero.fakez>0) && isSideViewHero())
	{
		Hero.y-=Hero.z;
		Hero.y-=Hero.fakez;
		Hero.z=0;
		Hero.fakez=0;
	}
	else if(!isSideViewHero())
	{
		Hero.fall=0;
		Hero.fakefall=0;
	}
		
	// If warping between top-down and sideview screens,
	// fix enemies that are carried over by Full Screen Warp
	const bool tmpscr_is_sideview = isSideViewGravity();
		
	if(!wasSideview && tmpscr_is_sideview)
	{
		for(int32_t i=0; i<guys.Count(); i++)
		{
			if(guys.spr(i)->z > 0)
			{
				guys.spr(i)->y -= guys.spr(i)->z;
				guys.spr(i)->z = 0;
			}
			
			if(((enemy*)guys.spr(i))->family!=eeTRAP && ((enemy*)guys.spr(i))->family!=eeSPINTILE)
			guys.spr(i)->yofs += 2;
		}
	}
	else if(wasSideview && !tmpscr_is_sideview)
	{
		for(int32_t i=0; i<guys.Count(); i++)
		{
			if(((enemy*)guys.spr(i))->family!=eeTRAP && ((enemy*)guys.spr(i))->family!=eeSPINTILE)
			guys.spr(i)->yofs -= 2;
		}
	}
	if ( warpType == wtEXIT )
	{
		game->set_continue_scrn(currscr);
		game->set_continue_dmap(dmapID);
		lastentrance = currscr;
		lastentrance_dmap = dmapID;
	}
	else
	{
		if ( (warpFlags&warpFlagSETENTRANCESCREEN) ) lastentrance = currscr;
		if ( (warpFlags&warpFlagSETENTRANCEDMAP) ) lastentrance_dmap = dmapID;
		if ( (warpFlags&warpFlagSETCONTINUESCREEN) ) game->set_continue_scrn(currscr);
		if ( (warpFlags&warpFlagSETCONTINUEDMAP) ) game->set_continue_dmap(dmapID);
	}
	if(tmpscr->flags4&fAUTOSAVE)
	{
		save_game(true,0);
	}
		
	if(tmpscr->flags6&fCONTINUEHERE)
	{
		lastentrance_dmap = currdmap;
		lastentrance = homescr;
	}
		
	update_subscreens();
	verifyBothWeapons();
	Z_eventlog("Warped to DMap %d: %s, screen %d, via %s.\n", currdmap, DMaps[currdmap].name,currscr,
						warpType==wtEXIT ? "Entrance/Exit" :
						warpType==wtSCROLL ? "Scrolling Warp" :
						warpType==wtNOWARP ? "Cancel Warp" :
						"Insta-Warp");
						
	eventlog_mapflags();
	if (((warpFlags&warpFlagDONTRESTARTDMAPSCRIPT) != 0) == (get_qr(qr_SCRIPT_WARPS_DMAP_SCRIPT_TOGGLE) != 0)|| olddmap != currdmap) //Changed DMaps, or needs to reset the script
	{
		FFScript::deallocateAllScriptOwned(ScriptType::DMap, olddmap);
		initZScriptDMapScripts();
	}
	Hero.is_warping = false;
	if(!get_qr(qr_SCROLLWARP_NO_RESET_FRAME))
		GameFlags |= GAMEFLAG_RESET_GAME_LOOP;
	return true;
}

void FFScript::do_adjustvolume(const bool v)
{
	if (get_qr(qr_OLD_SCRIPT_VOLUME))
	{
		int32_t perc = (SH::get_arg(sarg1, v) / 10000);
		float pct = perc / 100.0;
		// zprint("pct is: %f\n",pct);
		float temp_midi = 0;
		float temp_digi = 0;
		float temp_mus = 0;
		if (!(coreflags & FFCORE_SCRIPTED_MIDI_VOLUME))
		{
			// zprint("FFCORE_SCRIPTED_MIDI_VOLUME: wasn't set\n");
			temp_midi = do_getMIDI_volume();
			// zprint("temp_midi is %f\n", temp_midi);
			usr_midi_volume = do_getMIDI_volume();
			// zprint("usr_midi_volume stored as %d\n", usr_midi_volume);
			SetFFEngineFlag(FFCORE_SCRIPTED_MIDI_VOLUME, true);
		}
		else
		{
			temp_midi = (float)usr_midi_volume;
		}
		if (!(coreflags & FFCORE_SCRIPTED_DIGI_VOLUME))
		{
			temp_digi = do_getDIGI_volume();
			usr_digi_volume = do_getDIGI_volume();
			// zprint("usr_music_volume stored as %d\n", usr_digi_volume);
			SetFFEngineFlag(FFCORE_SCRIPTED_DIGI_VOLUME, true);
		}
		else
		{
			temp_digi = (float)usr_digi_volume;
		}
		if (!(coreflags & FFCORE_SCRIPTED_MUSIC_VOLUME))
		{
			temp_mus = do_getMusic_volume();
			usr_music_volume = do_getMusic_volume();
			// zprint("usr_music_volume stored as %d\n", usr_music_volume);
			SetFFEngineFlag(FFCORE_SCRIPTED_MUSIC_VOLUME, true);
		}
		else
		{
			temp_mus = (float)usr_music_volume;
		}

		temp_midi *= pct;
		temp_digi *= pct;
		temp_mus *= pct;
		// zprint("temp_midi is: %f\n",temp_midi);
		// zprint("temp_digi is: %f\n",temp_digi);
		// zprint("temp_mus is: %f\n",temp_mus);
		do_setMIDI_volume((int32_t)temp_midi);
		do_setDIGI_volume((int32_t)temp_digi);
		do_setMusic_volume((int32_t)temp_mus);
	}
	else
	{
		int32_t perc = SH::get_arg(sarg1, v);
		FFCore.usr_music_volume = vbound(perc, 0, 10000 * 100);

		if (zcmusic != NULL)
		{
			if (zcmusic->playing != ZCM_STOPPED)
			{
				int32_t temp_volume = emusic_volume;
				if (!get_qr(qr_OLD_SCRIPT_VOLUME))
					temp_volume = (emusic_volume * FFCore.usr_music_volume) / 10000 / 100;
				temp_volume = (temp_volume * zcmusic->fadevolume) / 10000;
				zcmusic_play(zcmusic, temp_volume);
				return;
			}
		}
		else if (currmidi > -1)
		{
			jukebox(currmidi);
			master_volume(digi_volume, midi_volume);
		}
	}
}

void FFScript::do_adjustsfxvolume(const bool v)
{
	if (get_qr(qr_OLD_SCRIPT_VOLUME))
	{
		int32_t perc = (SH::get_arg(sarg1, v) / 10000);
		float pct = perc / 100.0;
		float temp_sfx = 0;
		if (!(coreflags & FFCORE_SCRIPTED_SFX_VOLUME))
		{
			temp_sfx = do_getSFX_volume();
			usr_sfx_volume = (int32_t)temp_sfx;
			// zprint("usr_sfx_volume stored as %d\n", usr_sfx_volume);
			SetFFEngineFlag(FFCORE_SCRIPTED_SFX_VOLUME, true);
		}
		else
		{
			temp_sfx = (float)usr_sfx_volume;
		}
		temp_sfx *= pct;
		do_setSFX_volume((int32_t)temp_sfx);
	}
	else
	{
		int32_t perc = SH::get_arg(sarg1, v);
		FFCore.usr_sfx_volume = vbound(perc, 0, 10000 * 100);
	}
}
	

void do_midi(bool v)
{
	int32_t MIDI = SH::get_arg(sarg1, v) / 10000;
	
	if(MIDI == 0)
		music_stop();
	else
		jukebox(MIDI + (ZC_MIDI_COUNT - 1));
}


void stop_sfx(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	int32_t sfx = (int32_t)ID;
	if(BC::checkSFXID(ID, "Game->EndSound") != SH::_NoError)
		return;
	stop_sfx(sfx);
}

void pause_sfx(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	int32_t sfx = (int32_t)ID;
	if(BC::checkSFXID(ID, "Game->PauseSound") != SH::_NoError)
		return;
	pause_sfx(sfx);
}

void resume_sfx(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	int32_t sfx = (int32_t)ID;
	if(BC::checkSFXID(ID, "Game->ResumeSound") != SH::_NoError)
		return;
	resume_sfx(sfx);
}



void do_enh_music(bool v)
{
	int32_t arrayptr = SH::get_arg(sarg1, v) / 10000;
	int32_t track = (SH::get_arg(sarg2, v) / 10000)-1;
	
	if(arrayptr == 0)
		music_stop();
	else // Pointer to a string..
	{
		string filename_str;
		char filename_char[256];
		bool ret;
		ArrayH::getString(arrayptr, filename_str, 256);
		strncpy(filename_char, filename_str.c_str(), 255);
		filename_char[255]='\0';
		ret=try_zcmusic(filename_char, qstpath, track, -1000, get_emusic_volume());
		set_register(sarg2, ret ? 10000 : 0);
	}
}

void do_enh_music_crossfade()
{
	int32_t arrayptr = SH::read_stack(ri->sp + 5) / 10000;
	int32_t track = SH::read_stack(ri->sp + 4) / 10000;
	int32_t fadeoutframes = zc_max(SH::read_stack(ri->sp + 3) / 10000, 0);
	int32_t fadeinframes = zc_max(SH::read_stack(ri->sp + 2) / 10000, 0);
	int32_t fademiddleframes = SH::read_stack(ri->sp + 1) / 10000;
	int32_t startpos = SH::read_stack(ri->sp);

	if (arrayptr == 0)
	{
		bool ret = play_enh_music_crossfade(NULL, qstpath, track, get_emusic_volume(), fadeoutframes, fadeinframes, fademiddleframes, startpos);
		ri->d[rEXP1] = ret ? 10000 : 0;
	}
	else
	{
		string filename_str;
		char filename_char[256];
		ArrayH::getString(arrayptr, filename_str, 256);
		strncpy(filename_char, filename_str.c_str(), 255);
		filename_char[255] = '\0';
		bool ret = play_enh_music_crossfade(filename_char, qstpath, track, get_emusic_volume(), fadeoutframes, fadeinframes, fademiddleframes, startpos, true);
		ri->d[rEXP1] = ret ? 10000 : 0;
	}
}

bool FFScript::doing_dmap_enh_music(int32_t dm)
{
	if (DMaps[dm].tmusic[0] != 0)
	{
		if (zcmusic != NULL)
		{
			if (strcmp(zcmusic->filename, DMaps[dm].tmusic) == 0)
			{
				switch (zcmusic_get_type(zcmusic))
				{
				case ZCMF_OGG:
				case ZCMF_MP3:
					return true;
				case ZCMF_DUH:
				case ZCMF_GME:
					if (zcmusic->track == DMaps[dm].tmusictrack)
					{
						return true;
					}
				}
			}
		}
	}
	return false;
}

bool FFScript::can_dmap_change_music(int32_t dm)
{
	switch (music_update_cond)
	{
	case MUSIC_UPDATE_SCREEN:
		return true;
	case MUSIC_UPDATE_DMAP:
		return dm != -1 && dm != currdmap;
	case MUSIC_UPDATE_LEVEL:
		return dm != -1 && DMaps[dm].level != DMaps[currdmap].level;
	}
	return false;
}

void FFScript::do_set_music_position(const bool v)
{
	int32_t newposition = SH::get_arg(sarg1, v);
	
	set_zcmusicpos(newposition);
}

void FFScript::do_get_music_position()
{
	int32_t pos = replay_get_state(ReplayStateType::MusicPosition, [](){
		return zcmusic_get_curpos(zcmusic);
	});
	set_register(sarg1, pos);
}

void FFScript::do_set_music_speed(const bool v)
{
	int32_t newspeed = SH::get_arg(sarg1, v);
	set_zcmusicspeed(newspeed);
}

void FFScript::do_get_music_length()
{
	int32_t len = get_zcmusiclen();
	set_register(sarg1, len);
}

void FFScript::do_set_music_loop()
{
	double start = (get_register(sarg1) / 10000.0);
	double end = (get_register(sarg2) / 10000.0);

	set_zcmusicloop(start, end);
}

void do_get_enh_music_filename(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	int32_t arrayptr = get_register(sarg2) / 10000;
	
	if(BC::checkDMapID(ID, "Game->GetDMapMusicFilename") != SH::_NoError)
		return;
		
	if(ArrayH::setArray(arrayptr, string(DMaps[ID].tmusic)) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'Game->GetDMapMusicFilename' not large enough\n");
}

void do_get_enh_music_track(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkDMapID(ID, "Game->GetDMapMusicTrack") != SH::_NoError)
		return;
		
	set_register(sarg1, (DMaps[ID].tmusictrack+1)*10000);
}

void do_set_dmap_enh_music(const bool v)
{
	int32_t ID   = SH::read_stack(ri->sp + 2) / 10000;
	int32_t arrayptr = SH::read_stack(ri->sp + 1) / 10000;
	int32_t track = (SH::read_stack(ri->sp + 0) / 10000)-1;
	string filename_str;
	
	if(BC::checkDMapID(ID, "Game->SetDMapEnhancedMusic") != SH::_NoError)
		return;
		
	ArrayH::getString(arrayptr, filename_str, 56);
	strncpy(DMaps[ID].tmusic, filename_str.c_str(), 55);
	DMaps[ID].tmusic[55]='\0';
	DMaps[ID].tmusictrack=track;
}






///----------------------------------------------------------------------------------------------------//
//Array & string related

void do_arraysize()
{
	int32_t arrayptr = get_register(sarg1) / 10000;
	ri->d[rEXP1] = ArrayH::getSize(arrayptr) * 10000;
}

void do_tobyte()
{
	int32_t b1 = get_register(sarg1) / 10000;
	byte b2 = b1;
	set_register(sarg1, b2 * 10000);
}

void do_tosignedbyte()
{
	int32_t b1 = get_register(sarg1) / 10000;
	signed char b2 = b1;
	set_register(sarg1, b2 * 10000);
}

void do_tointeger()
{
	int32_t b1 = get_register(sarg1) / 10000;
	set_register(sarg1, b1 * 10000);
}

void do_floor()
{
	set_register(sarg1, zslongToFix(get_register(sarg1)).doFloor().getZLong());
}

void do_trunc()
{
	set_register(sarg1, zslongToFix(get_register(sarg1)).doTrunc().getZLong());
}

void do_ceiling()
{
	set_register(sarg1, zslongToFix(get_register(sarg1)).doCeil().getZLong());
}

void do_round()
{
	set_register(sarg1, zslongToFix(get_register(sarg1)).doRound().getZLong());
}

void do_roundaway()
{
	set_register(sarg1, zslongToFix(get_register(sarg1)).doRoundAway().getZLong());
}

void do_toword()
{
	int32_t b1 = get_register(sarg1) / 10000;
	word b2 = b1;
	set_register(sarg1, b2 * 10000);
}

void do_toshort()
{
	int32_t b1 = get_register(sarg1) / 10000;
	int16_t b2 = b1;
	set_register(sarg1, b2 * 10000);
}

void do_getsavename()
{
	int32_t arrayptr = get_register(sarg1) / 10000;
	
	if(ArrayH::setArray(arrayptr, string(game->get_name())) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'Game->GetSaveName' not large enough\n");
}

void do_setsavename()
{
	int32_t arrayptr = get_register(sarg1) / 10000;
	
	string str;
	ArrayH::getString(arrayptr, str);
	byte j;

	for(j = 0; str[j] != '\0'; j++)
	{
		if(j >= 8)
		{
			Z_scripterrlog("String supplied to 'Game->GetSaveName' too large\n");
			return;
		}
	}

	game->set_name(str);
}

void do_getmessage(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	int32_t arrayptr = get_register(sarg2) / 10000;
	
	if(BC::checkMessage(ID, "Game->GetMessage") != SH::_NoError)
		return;
		
	if(ArrayH::setArray(arrayptr, MsgStrings[ID].s) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'Game->GetMessage' not large enough\n");
}



void do_setmessage(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	int32_t arrayptr = get_register(sarg2) / 10000;
	
	if(BC::checkMessage(ID, "Game->SetMessage") != SH::_NoError)
		return;
	
	ArrayH::getString(arrayptr, MsgStrings[ID].s, MSG_NEW_SIZE);
}


void do_getdmapname(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	int32_t arrayptr = get_register(sarg2) / 10000;
	
	if(BC::checkDMapID(ID, "Game->GetDMapName") != SH::_NoError)
		return;
		
	if(ArrayH::setArray(arrayptr, string(DMaps[ID].name)) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'Game->GetDMapName' not large enough\n");
}

void do_setdmapname(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	int32_t arrayptr = get_register(sarg2) / 10000;

	string filename_str;
	
	if(BC::checkDMapID(ID, "Game->Game->SetDMapName") != SH::_NoError)
		return;
		
	ArrayH::getString(arrayptr, filename_str, 22);
	strncpy(DMaps[ID].name, filename_str.c_str(), 21);
	DMaps[ID].name[20]='\0';
}

void do_getdmaptitle(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	int32_t arrayptr = get_register(sarg2) / 10000;
	
	if(BC::checkDMapID(ID, "Game->GetDMapTitle") != SH::_NoError)
		return;
		
	if (!get_qr(qr_OLD_DMAP_INTRO_STRINGS))
	{
		ArrayManager am(arrayptr);
		am.resize(DMaps[ID].title.size() + 1);
	}
	if(ArrayH::setArray(arrayptr, string(DMaps[ID].title)) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'Game->GetDMapTitle' not large enough\n");
}


void do_setdmaptitle(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	int32_t arrayptr = get_register(sarg2) / 10000;
	string filename_str;
	
	if(BC::checkDMapID(ID, "Game->Game->SetDMapTitle") != SH::_NoError)
		return;
		
	if (get_qr(qr_OLD_DMAP_INTRO_STRINGS))
	{
		char namestr[21];
		ArrayH::getString(arrayptr, filename_str, 21);
		strncpy(namestr, filename_str.c_str(), 20);
		namestr[20] = '\0';
		DMaps[ID].title.assign(namestr);
	}
	else
	{
		ArrayH::getString(arrayptr, filename_str, ArrayH::getSize(arrayptr));
		DMaps[ID].title = filename_str;
	}
}

void do_getdmapintro(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	int32_t arrayptr = get_register(sarg2) / 10000;
	
	if(BC::checkDMapID(ID, "Game->GetDMapIntro") != SH::_NoError)
		return;
		
	if(ArrayH::setArray(arrayptr, string(DMaps[ID].intro)) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'Game->GetDMapIntro' not large enough\n");
}


void do_setdmapintro(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	int32_t arrayptr = get_register(sarg2) / 10000;
	string filename_str;
	
	if(BC::checkDMapID(ID, "Game->Game->SetDMapIntro") != SH::_NoError)
		return;
		
	ArrayH::getString(arrayptr, filename_str, 73);
	strncpy(DMaps[ID].intro, filename_str.c_str(), 72);
	DMaps[ID].intro[72]='\0';
}

//Set npc and item names t.b.a. -Z

void do_getitemname()
{
	int32_t arrayptr = get_register(sarg1) / 10000;
	if(unsigned(ri->idata) >= MAXITEMS)
	{
		Z_scripterrlog("Invalid itemdata access: %d\n", ri->idata);
		return;
	}
	
	if(ArrayH::setArray(arrayptr, item_string[ri->idata]) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'itemdata->GetName' not large enough\n");
}

void do_getnpcname()
{
	int32_t arrayptr = get_register(sarg1) / 10000;
	
	if(GuyH::loadNPC(ri->guyref, "npc->GetName") != SH::_NoError)
		return;
		
	word ID = (GuyH::getNPC()->id & 0xFFF);
	
	if(ArrayH::setArray(arrayptr, guy_string[ID]) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'npc->GetName' not large enough\n");
}

//npcdata->GetName
void FFScript::do_getnpcdata_getname()
{
	int32_t arrayptr = get_register(sarg1) / 10000;
	int32_t npc_id = ri->npcdataref;
	if((unsigned)npc_id > 511)
	{
		Z_scripterrlog("Invalid npc ID (%d) passed to npcdata->GetName().\n", npc_id);
		return;
	}
		
	if(ArrayH::setArray(arrayptr, guy_string[npc_id]) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'npcdata->GetName()' not large enough\n");
}

void do_getffcscript()
{
	do_get_script_index_by_name(name_to_slot_index_ffcmap);
}

void do_npc_hero_in_range()
{
	int32_t dist = get_register(sarg1) / 10000;
	if(GuyH::loadNPC(ri->guyref, "npc->LinedUp()") == SH::_NoError)
	{
		bool in_range = GuyH::getNPC()->HeroInRange(dist);
		set_register(sarg1, 0);
	}
	else set_register(sarg1, 0);
}

void do_getitemscript()
{
	do_get_script_index_by_name(name_to_slot_index_itemmap);
}

///----------------------------------------------------------------------------------------------------//
//Tile Manipulation

void do_copytile(const bool v, const bool v2)
{
	int32_t tile = SH::get_arg(sarg1, v) / 10000;
	int32_t tile2 = SH::get_arg(sarg2, v2) / 10000;
	
	copy_tile(newtilebuf, tile, tile2, false);
}

int32_t FFScript::IsBlankTile(int32_t i)
{
	if( ((unsigned)i) > NEWMAXTILES )
	{
		Z_scripterrlog("Invalid tile ID (%d) passed to Graphics->IsBlankTile[]\n");
		return -1;
	}
	    
	byte *tilestart=newtilebuf[i].data;
	qword *di=(qword*)tilestart;
	int32_t parts=tilesize(newtilebuf[i].format)>>3;
    
	for(int32_t j=0; j<parts; ++j, ++di)
	{
		if(*di!=0)
		{
			return 0;
		}
	}
    
	return 1;
}

int32_t FFScript::Is8BitTile(int32_t i)
{
	if (((unsigned)i) > NEWMAXTILES)
	{
		Z_scripterrlog("Invalid tile ID (%d) passed to Graphics->Is8BitTile[]\n");
		return -1;
	}

	return newtilebuf[i].format == tf8Bit ? 1 : 0;
}

void do_swaptile(const bool v, const bool v2)
{
	int32_t tile = SH::get_arg(sarg1, v) / 10000;
	int32_t tile2 = SH::get_arg(sarg2, v2) / 10000;
	
	copy_tile(newtilebuf, tile, tile2, true);
}

void do_overlaytile(const bool v, const bool v2)
{
	int32_t tile = SH::get_arg(sarg1, v) / 10000;
	int32_t tile2 = SH::get_arg(sarg2, v2) / 10000;
	
	if(BC::checkTile(tile, "OverlayTile") != SH::_NoError ||
			BC::checkTile(tile2, "OverlayTile") != SH::_NoError)
		return;
		
	//Could add an arg for the CSet or something instead of just passing 0, currently only 8-bit is supported
	overlay_tile(newtilebuf, tile, tile2, 0, false);
}

void do_fliprotatetile(const bool v, const bool v2)
{
	int32_t tile = SH::get_arg(sarg1, v) / 10000;
	int32_t tile2 = SH::get_arg(sarg2, v2) / 10000;
	
	if(BC::checkTile(tile, "FlipRotateTile") != SH::_NoError ||
			BC::checkTile(tile2, "FlipRotateTile") != SH::_NoError)
		return;
		
	//fliprotatetile
}

void do_settilepixel()
{
	int32_t tile = SH::read_stack(ri->sp + 3) / 10000;
	int32_t x = SH::read_stack(ri->sp + 2) / 10000;
	int32_t y = SH::read_stack(ri->sp + 1) / 10000;
	int32_t val = SH::read_stack(ri->sp + 0) / 10000;
	
	if(BC::checkTile(tile, "SetTilePixel") != SH::_NoError)
		return;
		
	x = vbound(x, 0, 15);
	y = vbound(y, 0, 15);
	unpack_tile(newtilebuf, tile, 0, false);
	if (newtilebuf[tile].format == tf4Bit)
		val &= 0xF;
	unpackbuf[y * 16 + x] = val;
	pack_tile(newtilebuf, unpackbuf, tile);
}

void do_gettilepixel()
{
	int32_t tile = SH::read_stack(ri->sp + 3) / 10000;
	int32_t x = SH::read_stack(ri->sp + 2) / 10000;
	int32_t y = SH::read_stack(ri->sp + 1) / 10000;
	int32_t cs = SH::read_stack(ri->sp + 0) / 10000;

	if(BC::checkTile(tile, "GetTilePixel") != SH::_NoError)
		return;
		
	x = vbound(x, 0, 15);
	y = vbound(y, 0, 15);
	unpack_tile(newtilebuf, tile, 0, false);
	int32_t csoffs = newtilebuf[tile].format == tf8Bit ? 0 : cs * 16;
	ri->d[rEXP1] = 10000 * (unpackbuf[y * 16 + x] + csoffs);
}

void do_shifttile(const bool v, const bool v2)
{
	int32_t tile = SH::get_arg(sarg1, v) / 10000;
	int32_t tile2 = SH::get_arg(sarg2, v2) / 10000;
	
	if(BC::checkTile(tile, "ShiftTile") != SH::_NoError ||
			BC::checkTile(tile2, "ShiftTile") != SH::_NoError)
		return;
		
	//shifttile
}

void do_cleartile(const bool v)
{
	int32_t tile = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkTile(tile, "ClearTile") != SH::_NoError)
		return;
		
	reset_tile(newtilebuf, tile, newtilebuf[tile].format);
}

void do_combotile(const bool v)
{
	int32_t combo = SH::get_arg(sarg2, v) / 10000;
	
	if(BC::checkCombo(combo, "Game->ComboTile") != SH::_NoError)
		return;
		
	set_register(sarg1, combobuf[combo].tile * 10000);
}

void do_readpod(const bool v)
{
	int32_t indx = SH::get_arg(sarg2, v) / 10000;
	int32_t val = ArrayH::getElement(ri->d[rINDEX] / 10000, indx, can_neg_array);
	set_register(sarg1, val);
}
void do_writepod(const bool v1, const bool v2)
{
	int32_t indx = SH::get_arg(sarg1, v1) / 10000;
	int32_t val = SH::get_arg(sarg2, v2);
	ArrayH::setElement(ri->d[rINDEX] / 10000, indx, val, can_neg_array);
}
void do_writepodstr()
{
	if(!sargstr) return;
	auto ptr = get_register(sarg1) / 10000;
	ArrayH::setArray(ptr, *sargstr);
}
void do_writepodarr()
{
	if(!sargvec) return;
	auto ptr = get_register(sarg1) / 10000;
	ArrayH::setArray(ptr, sargvec->size(), sargvec->data(), false);
}
int32_t get_object_arr(size_t sz)
{
	if(sz > 214748) return 0;
	int32_t free_ptr = 1;
	auto it = objectRAM.begin();
	if(it != objectRAM.end())
	{
		if(it->first == 1)
		{
			for(free_ptr = 2; ; ++free_ptr)
			{
				if(objectRAM.find(free_ptr) == objectRAM.end())
					break;
			}
		}
	}
	ZScriptArray arr;
	arr.Resize(sz);
	arr.setValid(true);
	objectRAM[free_ptr] = arr;
	// auto res = objectRAM.emplace(free_ptr);
	// ZScriptArray& arr = res.first->second;
	// arr.Resize(sz);
	
	return -free_ptr;
}
void destroy_object_arr(int32_t ptr, bool dec_refs)
{
	if(ptr < 0)
	{
		auto it = objectRAM.find(-ptr);
		if(it != objectRAM.end())
		{
			auto& aptr = it->second;
			if (dec_refs && aptr.HoldsObjects())
			{
				for (int i = 0; i < aptr.Size(); i++)
					script_object_ref_dec(aptr[i]);
			}
			objectRAM.erase(it);
		}
	}
}
void do_constructclass(ScriptType type, word script, int32_t i)
{
	if(!sargvec) return;
	
	size_t num_vars = sargvec->at(0);
	size_t total_vars = num_vars + sargvec->size()-1;
	auto destr_pc = pc_calc(ri->d[rEXP1]);

	if (auto obj = user_objects.create())
	{
		// Before gc/reference counting, allocating a custom object automatically assigns
		// ownership to the current script. Not needed anymore, but important to keep
		// doing for compat.
		if (!ZScriptVersion::gc())
			own_script_object(obj, type, i);
		obj->owned_vars = num_vars;
		for(size_t q = 0; q < total_vars; ++q)
		{
			if(q < num_vars)
			{
				obj->data.push_back(0);
			}
			else
			{
				size_t sz = sargvec->at(q-num_vars+1);
				if(auto id = get_object_arr(sz))
					obj->data.push_back(10000*id);
				else obj->data.push_back(0); //nullptr
			}
		}
		set_register(sarg1, obj->id);
		ri->thiskey = obj->id;
		obj->prep(destr_pc,type,script,i);
	}
	else set_register(sarg1, 0);
}

void do_readclass()
{
	dword objref = get_register(sarg1);
	ri->d[rEXP1] = 0;
	int32_t ind = sarg2;
	if(user_object* obj = checkObject(objref))
	{
		if(unsigned(ind) >= obj->data.size())
		{
			Z_scripterrlog("Script tried to read position '%d' out of bounds on a '%d' size object (%d).", ind, obj->data.size(), objref);
		}
		else
		{
			ri->d[rEXP1] = obj->data.at(ind);
		}
	}
}
void do_writeclass()
{
	dword objref = get_register(sarg1);
	int32_t ind = sarg2;
	if(user_object* obj = checkObject(objref))
	{
		if(unsigned(ind) >= obj->data.size())
		{
			Z_scripterrlog("Script tried to write position '%d' out of bounds on a '%d' size object (%d).", ind, obj->data.size(), objref);
		}
		else
		{
			bool is_object = obj->isMemberObjectType(ind);
			if (is_object)
				script_object_ref_dec(obj->data[ind]);
			obj->data[ind] = ri->d[rEXP1];
			if (is_object)
				script_object_ref_inc(obj->data[ind]);
		}
	}
}
void do_freeclass()
{
	// Deleting is no longer needed. To keep reference counting simpler, simply do nothing on delete.
	ri->d[rEXP1] = 0;
}

int32_t get_own_i(ScriptType type)
{
	switch(type)
	{
		case ScriptType::Lwpn:
			return ri->lwpn;
		case ScriptType::Ewpn:
			return ri->ewpn;
		case ScriptType::ItemSprite:
			return ri->itemref;
		case ScriptType::NPC:
			return ri->guyref;
		case ScriptType::FFC:
			return ri->ffcref;
	}
	return 0;
}

portal* loadportal(savedportal& p);
///----------------------------------------------------------------------------------------------------//
//                                       Run the script                                                //
///----------------------------------------------------------------------------------------------------//

static bool check_cmp(uint cmp)
{
	if(cmp & CMP_BOOL)
	{
		if(ri->cmp_strcache) return false; //Cast string to bool? nonsense...
		switch(cmp & CMP_FLAGS)
		{
			case CMP_EQ:
				return !ri->cmp_op1 == !ri->cmp_op2;
			case CMP_NE:
				return !ri->cmp_op1 != !ri->cmp_op2;
		}
		return false;
	}
	else if(ri->cmp_strcache)
	{
		if(*ri->cmp_strcache < 0)
			return (cmp & CMP_LT);
		if(*ri->cmp_strcache > 0)
			return (cmp & CMP_GT);
		return (cmp & CMP_EQ);
	}
	else
	{
		if(cmp & CMP_GT)
			if(ri->cmp_op1 > ri->cmp_op2)
				return true;
		if(cmp & CMP_LT)
			if(ri->cmp_op1 < ri->cmp_op2)
				return true;
		if(cmp & CMP_EQ)
			if(ri->cmp_op1 == ri->cmp_op2)
				return true;
		return false;
	}
}

void goto_err(char const* opname)
{
	auto i = curScriptIndex;
	const char* type_str = ScriptTypeToString(curScriptType);
	switch(curScriptType)
	{
		case ScriptType::FFC:
			Z_scripterrlog("%s Script %s attempted to %s an invalid jump to (%d).\n", type_str, ffcmap[i].scriptname.c_str(), opname, sarg1); break;
		case ScriptType::NPC:
			Z_scripterrlog("%s Script %s attempted to %s an invalid jump to (%d).\n", type_str, npcmap[i].scriptname.c_str(), opname, sarg1); break;
		case ScriptType::Lwpn:
			Z_scripterrlog("%s Script %s attempted to %s an invalid jump to (%d).\n", type_str, lwpnmap[i].scriptname.c_str(), opname, sarg1); break;
		case ScriptType::Ewpn:
			Z_scripterrlog("%s Script %s attempted to %s an invalid jump to (%d).\n", type_str, ewpnmap[i].scriptname.c_str(), opname, sarg1); break;
		case ScriptType::ItemSprite:
			Z_scripterrlog("%s Script %s attempted to %s an invalid jump to (%d).\n", type_str, itemspritemap[i].scriptname.c_str(), opname, sarg1); break;
		case ScriptType::Item:
			Z_scripterrlog("%s Script %s attempted to %s an invalid jump to (%d).\n", type_str, itemmap[i].scriptname.c_str(), opname, sarg1); break;
		case ScriptType::Global:
			Z_scripterrlog("%s Script %s attempted to %s an invalid jump to (%d).\n", type_str, globalmap[i].scriptname.c_str(), opname, sarg1); break;
		case ScriptType::Player:
			Z_scripterrlog("%s Script %s attempted to %s an invalid jump to (%d).\n", type_str, playermap[i].scriptname.c_str(), opname, sarg1); break;
		case ScriptType::Screen:
			Z_scripterrlog("%s Script %s attempted to %s an invalid jump to (%d).\n", type_str, screenmap[i].scriptname.c_str(), opname, sarg1); break;
		case ScriptType::OnMap:
		case ScriptType::DMap:
		case ScriptType::ScriptedActiveSubscreen:
		case ScriptType::ScriptedPassiveSubscreen:
			Z_scripterrlog("%s Script %s attempted to %s an invalid jump to (%d).\n", type_str, dmapmap[i].scriptname.c_str(), opname, sarg1); break;
		case ScriptType::Combo:
			Z_scripterrlog("%s Script %s attempted to %s an invalid jump to (%d).\n", type_str, comboscriptmap[i].scriptname.c_str(), opname, sarg1); break;
		
		default: break;
	}
}

static void script_exit_cleanup(bool no_dealloc)
{
	ScriptType type = curScriptType;
	word script = curScriptNum;
	int32_t i = curScriptIndex;
	switch(type)
	{
		case ScriptType::FFC:
		{
			tmpscr->ffcs[i].script = 0;
			auto& data = get_script_engine_data(type, i);
			data.doscript = false;
		}
		break;

		case ScriptType::Screen:
			tmpscr->script = 0;
		case ScriptType::Global:
		case ScriptType::Player:
		case ScriptType::DMap:
		case ScriptType::OnMap:
		case ScriptType::ScriptedActiveSubscreen:
		case ScriptType::ScriptedPassiveSubscreen:
		case ScriptType::EngineSubscreen:
		case ScriptType::Combo:
		{
			auto& data = get_script_engine_data(type, i);
			data.doscript = false;
		}
		break;
		case ScriptType::NPC:
		{
			auto& data = get_script_engine_data(type, i);
			data.doscript = false;
			data.initialized = false;
			auto index = GuyH::getNPCIndex(i);
			if (index != -1)
				guys.spr(index)->weaponscript = 0;
		}
		break;
		case ScriptType::Lwpn:
		{
			auto& data = get_script_engine_data(type, i);
			data.doscript = false;
			data.initialized = false;
			auto index = LwpnH::getLWeaponIndex(i);
			if (index != -1)
				Lwpns.spr(index)->weaponscript = 0;
		}
		break;
		case ScriptType::Ewpn:
		{
			auto& data = get_script_engine_data(type, i);
			data.doscript = false;
			data.initialized = false;
			auto index = EwpnH::getEWeaponIndex(i);
			if (index != -1)
				Ewpns.spr(index)->weaponscript = 0;
		}
		break;
		case ScriptType::ItemSprite:
		{
			auto& data = get_script_engine_data(type, i);
			data.doscript = false;
			data.initialized = false;
			auto index = ItemH::getItemIndex(i);
			if (index != -1)
				items.spr(index)->script = 0;
		}
		break;
		
		case ScriptType::Generic:
			user_genscript::get(script).quit();
			break;
		
		case ScriptType::GenericFrozen:
			FFCore.doscript(ScriptType::GenericFrozen, gen_frozen_index-1) = false;
			break;

		case ScriptType::Item:
		{
			bool collect = ( ( i < 1 ) || (i == COLLECT_SCRIPT_ITEM_ZERO) );
			int new_i = ( collect ) ? (( i != COLLECT_SCRIPT_ITEM_ZERO ) ? (i * -1) : 0) : i;
			auto& data = get_script_engine_data(ScriptType::Item, i);
			if ( !collect )
			{
				if ( (itemsbuf[i].flags&ITEM_PASSIVESCRIPT) && game->item[i] ) itemsbuf[i].script = 0; //Quit perpetual scripts, too.
				data.doscript = 0;
				data.ref.Clear();
			}
			else
			{
				data.doscript = 0;
				data.ref.Clear();
			}
			data.initialized = false;
			break;
		}
	}
	if(!no_dealloc)
		switch(type)
		{
			case ScriptType::Item:
			{
				bool collect = ( ( i < 1 ) || (i == COLLECT_SCRIPT_ITEM_ZERO) );
				int new_i = ( collect ) ? (( i != COLLECT_SCRIPT_ITEM_ZERO ) ? (i * -1) : 0) : i;
				FFScript::deallocateAllScriptOwned(ScriptType::Item, new_i);
				break;
			}
			
			case ScriptType::Screen:
			{
				FFScript::deallocateAllScriptOwned(ScriptType::Screen, 0);
				break;
			} 
			
			default:
				FFScript::deallocateAllScriptOwned(type, i);
				break;
		}
}

int32_t run_script(ScriptType type, const word script, const int32_t i)
{
	if(Quit==qRESET || Quit==qEXIT) // In case an earlier script hung
		return RUNSCRIPT_ERROR;
		
	if(type != ScriptType::Global && !script) return RUNSCRIPT_OK; //Safeguard against running null scripts
	
	combopos_modified = -1;
	curScriptType=type;
	curScriptNum=script;
	curScriptIndex=i;
	//numInstructions=0; //DON'T CLEAR THIS OR IT CAN HARDLOCK! -Em

	if (!(type >= ScriptType::First && type <= ScriptType::Last))
	{
		al_trace("Invalid script type: %d\n", (int)type);
		return RUNSCRIPT_ERROR;
	}

	bool got_initialized = false;
	switch(type)
	{
		case ScriptType::FFC:
		case ScriptType::Global:
		case ScriptType::Player:
		case ScriptType::DMap:
		case ScriptType::OnMap:
		case ScriptType::ScriptedActiveSubscreen:
		case ScriptType::ScriptedPassiveSubscreen:
		case ScriptType::EngineSubscreen:
		case ScriptType::Screen:
		case ScriptType::Combo:
		case ScriptType::Item:
		case ScriptType::NPC:
		case ScriptType::Lwpn:
		case ScriptType::Ewpn:
		case ScriptType::ItemSprite:
		case ScriptType::Generic:
		case ScriptType::GenericFrozen:
		{
			got_initialized = set_current_script_engine_data(type, script, i);
		}
		break;

		default:
		{
			al_trace("No other scripts are currently supported\n");
			return RUNSCRIPT_ERROR;
		}
	}

	// Because qst.cpp likes to write script_data without setting this.
	curscript->meta.script_type = type;

	// If script isn't valid, we don't have a `pc` to start from... just exit.
	if(!curscript->valid())
	{
		script_exit_cleanup(false);
		return RUNSCRIPT_OK;
	}

	script_funcrun = false;

	JittedScriptHandle* jitted_script = nullptr;
	if (jit_is_enabled())
	{
		auto key = std::make_pair(curscript->zasm_script.get(), ri);
		auto it = jitted_scripts.find(key);
		if (it == jitted_scripts.end())
		{
			jitted_scripts[key] = jitted_script = jit_create_script_handle(curscript->zasm_script.get(), ri);
		}
		else
		{
			jitted_script = it->second;
		}
	}
	else if (zasm_optimize_enabled() && curscript->valid() && !curscript->zasm_script->optimized)
	{
		zasm_optimize_and_log(curscript->zasm_script.get());
	}

	runtime_script_debug_handle = nullptr;
	if (script_debug_is_runtime_debugging())
	{
		if (!script_debug_handles.contains(curscript->id))
		{
			script_debug_handles.emplace(curscript->id, ScriptDebugHandle(
				curscript->zasm_script.get(), ScriptDebugHandle::OutputSplit::ByFrame, curscript->name()));
		}
		runtime_script_debug_handle = &script_debug_handles.at(curscript->id);
		runtime_script_debug_handle->update_file();
		std::string line = fmt::format("=== running script type: {} index: {} name: {} i: {} script: {}", ScriptTypeToString(curscript->id.type), curscript->id.index, curscript->meta.script_name, i, script);
		runtime_script_debug_handle->print("\n");
		runtime_script_debug_handle->print(line.c_str());
		runtime_script_debug_handle->print("\n");

		replay_step_comment(line);
	}
	if (script_debug_is_runtime_debugging() == 1)
	{
		std::string line = script_debug_registers_and_stack_to_string();
		runtime_script_debug_handle->print(line.c_str());
		runtime_script_debug_handle->print("\n");

		util::replchar(line, '\n', ' ');
		replay_step_comment(line);
	}

	int32_t result;
	if (jitted_script)
	{
		if (got_initialized)
			jit_reinit(jitted_script);
		if (ri->waitframes)
		{
			--ri->waitframes;
			result = RUNSCRIPT_OK;
		}
		else
		{
			result = jit_run_script(jitted_script);
		}
	}
	else
	{
		result = run_script_int(false);
	}

	if (ZScriptVersion::gc())
	{
		// Drain the autorelease pool.
		// Move the vector, since destructors can possibly
		// create objects and modify `script_object_autorelease_pool`.
		auto ids = std::move(script_object_autorelease_pool);
		for (auto id : ids)
			script_object_ref_dec(id);

		// This throttles the actual full GC run.
		maybe_run_gc();
	}

	if (replay_is_active() && replay_get_meta_bool("debug_script_state"))
	{
		std::string str = script_debug_registers_and_stack_to_string();
		util::replstr(str, "\n", " ");
		replay_step_comment(str);
	}

	if (runtime_script_debug_handle)
	{
		runtime_script_debug_handle->print(fmt::format("result: {}\n", result).c_str());
		replay_step_comment(fmt::format("result: {}", result));
	}
	return result;
}

bool pc_overflow(dword pc, bool print_err)
{
	if(pc >= curscript->zasm_script->size)
	{
		if(print_err)
			Z_scripterrlog("Script PC out of bounds (over or underflow). Terminating.\n");
		return true;
	}
	return false;
}

int32_t run_script_int(bool is_jitted)
{
	if(pc_overflow(ri->pc))
	{
		script_exit_cleanup(false);
		return RUNSCRIPT_ERROR;
	}
	ScriptType type = curScriptType;
	word script = curScriptNum;
	int32_t i = curScriptIndex;

	int commands_run = 0;
	int jit_waiting_nop = false;
	bool old_script_funcrun = script_funcrun && curscript->meta.ffscript_v < 23;
	if(!is_jitted)
	{
		if(ri->waitframes)
		{
			--ri->waitframes;
			return RUNSCRIPT_OK;
		}
		zs_vargs.clear();
		
	#ifdef _FFDISSASSEMBLY
		
		if(curscript->zasm[ri->pc].command != 0xFFFF)
		{
	#ifdef _FFONESCRIPTDISSASSEMBLY
			zc_trace_clear();
	#endif
			
			switch(type)
			{
			case ScriptType::FFC:
				al_trace("\nStart of FFC script %i processing on FFC %i:\n", script, i);
				break;
				
			case ScriptType::Item:
				al_trace("\nStart of item script %i processing:\n", script);
				break;
				
			case ScriptType::Global:
				al_trace("\nStart of global script %I processing:\n", script);
				break;
			}
		}
		
	#endif
	}
	//j_command
	bool is_debugging = script_debug_is_runtime_debugging() == 2;
	bool increment = true;
	static std::vector<ffscript> empty_zasm = {{0xFFFF}};
	const auto& zasm = curscript->valid() ? curscript->zasm_script->zasm : empty_zasm;
	word scommand = zasm[ri->pc].command;
	bool hit_invalid_zasm = false;
	bool no_dealloc = false;
	while(scommand != 0xFFFF)
	{
		if(pc_overflow(ri->pc))
		{
			script_exit_cleanup(false);
			return RUNSCRIPT_ERROR;
		}
		const auto& op = zasm[ri->pc];
		scommand = op.command;
		sarg1 = op.arg1;
		sarg2 = op.arg2;
		sarg3 = op.arg3;
		sargstr = op.strptr;
		sargvec = op.vecptr;
		//zprint2("Executing zasm: %d,%d,%d,%d,%d\n",scommand,sarg1,sarg2,get_register(sarg1),get_register(sarg2));

		if (is_debugging && (!is_jitted || commands_run > 0))
		{
			runtime_script_debug_handle->pre_command();
		}

		bool waiting = true;
		switch(scommand) //Handle waitframe-type commands first
		{
			case WAITDRAW:
			{
				if(script_funcrun)
					scommand = NOP;
				else switch(type)
				{
					case ScriptType::EngineSubscreen: //ignore waitdraws
						Z_scripterrlog("'Waitdraw()' is invalid in subscreen scripts, will be ignored\n");
						scommand = NOP;
						break;
					case ScriptType::Generic:
					case ScriptType::GenericFrozen: //ignore waitdraws
						Z_scripterrlog("'Waitdraw()' is invalid in generic scripts, will be ignored\n");
						scommand = NOP;
						break;
				}
				break;
			}
			case WAITTO:
			{
				if(script_funcrun)
					scommand = NOP;
				else switch(type)
				{
					case ScriptType::GenericFrozen:
						//ignore, no warn/error
						scommand = NOP;
						break;
					case ScriptType::Generic:
					{
						user_genscript& scr = user_genscript::get(script);
						int32_t target = get_register(sarg1)/10000L;
						bool atleast = get_register(sarg2)!=0;
						if(unsigned(target) > SCR_TIMING_END_FRAME)
						{
							Z_scripterrlog("Invalid value '%d' provided to 'WaitTo()'\n", target);
							scommand = NOP;
							break;
						}
						if(genscript_timing == target ||
							(atleast && genscript_timing < target))
						{
							//Already that time, skip the command
							scommand = NOP;
							break;
						}
						scr.waituntil = scr_timing(target);
						scr.wait_atleast = atleast;
						break;
					}
					default:
						Z_scripterrlog("'WaitTo()' is only valid in 'generic' scripts!\n");
						scommand = NOP;
						break;
				}
				break;
			}
			case WAITEVENT:
			{
				if(script_funcrun)
					scommand = NOP;
				else switch(type)
				{
					case ScriptType::GenericFrozen:
						scommand = WAITFRAME;
						ri->d[0] = GENSCR_EVENT_NIL*10000; //no event
						break;
					case ScriptType::Generic:
					{
						user_genscript& scr = user_genscript::get(script);
						scr.waitevent = true;
						break;
					}
					default:
						Z_scripterrlog("'WaitEvent()' is only valid in 'generic' scripts!\n");
						scommand = NOP;
						break;
				}
				break;
			}
			case WAITFRAME:
			{
				if(script_funcrun)
					scommand = NOP;
				else switch(type)
				{
					case ScriptType::Generic:
					{
						user_genscript& scr = user_genscript::get(script);
						scr.waituntil = SCR_TIMING_START_FRAME;
						scr.wait_atleast = false;
						break;
					}
				}
				break;
			}
			case WAITFRAMESR:
			{
				auto count = get_register(sarg1);
				if(script_funcrun || count <= 0)
				{
					scommand = NOP;
					break;
				}
				auto frames = count/10000;
				if(count%10000) ++frames; //round up decimals
				ri->waitframes = frames-1; //this frame doesn't count
				switch(type)
				{
					case ScriptType::Generic:
					{
						user_genscript& scr = user_genscript::get(script);
						scr.waituntil = SCR_TIMING_START_FRAME;
						scr.wait_atleast = false;
						break;
					}
				}
				break;
			}
			default: waiting = false;
		}
		if(waiting && scommand != NOP)
		{
			if (is_jitted)
				jit_waiting_nop = true;
			break;
		}
		
		numInstructions++;
		if(numInstructions==hangcount) // No need to check frequently
		{
			numInstructions=0;
			poll_keyboard();
			checkQuitKeys();
			if(Quit)
				scommand=0xFFFF;
		}
		
		switch(scommand)
		{
			//always first
			case 0xFFFF:  //invalid command
			{
				const char* type_str = ScriptTypeToString(type);
				switch(type)
				{
					case ScriptType::FFC:
						zprint("%s Script %s has exited.\n", type_str, ffcmap[i].scriptname.c_str()); break;
					case ScriptType::NPC:
						zprint("%s Script %s has exited.\n", type_str, npcmap[i].scriptname.c_str()); break;
					case ScriptType::Lwpn:
						zprint("%s Script %s has exited.\n", type_str, lwpnmap[i].scriptname.c_str()); break;
					case ScriptType::Ewpn:
						zprint("%s Script %s has exited.\n", type_str, ewpnmap[i].scriptname.c_str()); break;
					case ScriptType::ItemSprite:
						zprint("%s Script %s has exited.\n", type_str, itemspritemap[i].scriptname.c_str()); break;
					case ScriptType::Item:
						zprint("%s Script %s has exited.\n", type_str, itemmap[i].scriptname.c_str()); break;
					case ScriptType::Global:
						zprint("%s Script %s has exited.\n", type_str, globalmap[i].scriptname.c_str()); break;
					case ScriptType::Player:
						zprint("%s Script %s has exited.\n", type_str, playermap[i].scriptname.c_str()); break;
					case ScriptType::Screen:
						zprint("%s Script %s has exited.\n", type_str, screenmap[i].scriptname.c_str()); break;
					case ScriptType::OnMap:
					case ScriptType::DMap:
					case ScriptType::ScriptedActiveSubscreen:
					case ScriptType::ScriptedPassiveSubscreen:
						zprint("%s Script %s has exited.\n", type_str, dmapmap[i].scriptname.c_str()); break;
					case ScriptType::Combo: zprint("%s Script %s has exited.\n", type_str, comboscriptmap[i].scriptname.c_str()); break;
					
					default: break;					
				}
				break;
			}
			case QUIT:
				scommand = 0xFFFF;
				break;
			case QUIT_NO_DEALLOC:
				scommand = 0xFFFF;
				no_dealloc = true;
				break;
				
			case NOP: //No Operation. Do nothing. -Em
			{
				// While we are here, skip many NOPs in a row to avoid the overhead
				// of the interpreter loop. This is especially good for how `zasm_optimize`
				// works, since it replaces many commands with a sequence of NOPs.
				// No need to do a bounds check - the last command should always be 0xFFFF.
				if (is_debugging)
					break;
				while (!pc_overflow(ri->pc+1, false) && zasm[ri->pc + 1].command == NOP)
					ri->pc++;
				break;
			}
			case GOTO:
			{
				if(sarg1 < 0 )
				{
					goto_err("GOTO");
					scommand = 0xFFFF;
					break;
				}
				ri->pc = pc_calc(sarg1);
				increment = false;
				break;
			}
			case GOTOR:
			{
				if(sarg1 < 0 )
				{
					goto_err("GOTOR");
					scommand = 0xFFFF;
					break;
				}
				ri->pc = pc_calc((get_register(sarg1) / 10000) - 1);
				increment = false;
			}
			break;
			
			case GOTOTRUE:
				if(check_cmp(CMP_EQ))
				{
					if(sarg1 < 0 )
					{
						goto_err("GOTOTRUE");
						scommand = 0xFFFF;
						break;
					}
					ri->pc = pc_calc(sarg1);
					increment = false;
				}
				break;
				
			case GOTOFALSE:
				if(check_cmp(CMP_NE))
				{
					if(sarg1 < 0 )
					{
						goto_err("GOTOFALSE");
						scommand = 0xFFFF;
						break;
					}
					ri->pc = pc_calc(sarg1);
					increment = false;
				}
				break;
				
			case GOTOMORE:
				if(check_cmp(CMP_GE))
				{
					if(sarg1 < 0 )
					{
						goto_err("GOTOMORE");
						scommand = 0xFFFF;
						break;
					}
					ri->pc = pc_calc(sarg1);
					increment = false;
				}
				break;
				
			case GOTOLESS:
				if(check_cmp(get_qr(qr_GOTOLESSNOTEQUAL) ? CMP_LT : CMP_LE))
				{
					if(sarg1 < 0 )
					{
						goto_err("GOTOLESS");
						scommand = 0xFFFF;
						break;
					}
					ri->pc = pc_calc(sarg1);
					increment = false;
				}
				break;
			
			case GOTOCMP:
			{
				bool run = check_cmp(sarg2);
				if(run)
				{
					if(sarg1 < 0 )
					{
						goto_err("GOTOCMP");
						scommand = 0xFFFF;
						break;
					}
					ri->pc = pc_calc(sarg1);
					increment = false;
				}
				break;
			}
			
			case SETCMP:
			{
				bool run = check_cmp(sarg2);
				set_register(sarg1, run ? ((sarg2 & CMP_SETI) ? 10000 : 1) : 0);
				break;
			}
			
			case CALLFUNC:
			{
				retstack_push(ri->pc+1);
				if(sarg1 < 0 )
				{
					goto_err("CALLFUNC");
					scommand = 0xFFFF;
					break;
				}
				ri->pc = pc_calc(sarg1);
				increment = false;
				break;
			}
			case RETURNFUNC:
			{
				if(auto retpc = retstack_pop())
				{
					if(*retpc < 0)
					{
						goto_err("RETURNFUNC");
						scommand = 0xFFFF;
						break;
					}
					ri->pc = *retpc;
					increment = false;
				}
				else //Returned from 'void run()', QUIT
				{
					scommand = 0xFFFF;
				}
				break;
			}
				
			case LOOP:
			{
				if(get_register(sarg2) > 0)
				{
					ri->pc = pc_calc(sarg1);
					increment = false;
				}
				else
				{
					set_register(sarg1, sarg1 - 1);
				}
			}
			break;

			case RETURN:
			{
				if (script_funcrun)
					break; //handled below, poorly. 'RETURNFUNC' does this better now.
				ri->pc = pc_calc(SH::read_stack(ri->sp) - 1);
				++ri->sp;
				ri->sp &= MASK_SP;
				increment = false;
				break;
			}
			
			case SETTRUE:
				set_register(sarg1, check_cmp(CMP_EQ) ? 1 : 0);
				break;
				
			case SETFALSE:
				set_register(sarg1, check_cmp(CMP_NE) ? 1 : 0);
				break;
				
			case SETMORE:
				set_register(sarg1, check_cmp(CMP_GE) ? 1 : 0);
				break;
				
			case SETLESS:
				set_register(sarg1, check_cmp(CMP_LE) ? 1 : 0);
				break;
			
			case SETTRUEI:
				set_register(sarg1, check_cmp(CMP_EQ) ? 10000 : 0);
				break;
				
			case SETFALSEI:
				set_register(sarg1, check_cmp(CMP_NE) ? 10000 : 0);
				break;
				
			case SETMOREI:
				set_register(sarg1, check_cmp(CMP_GE) ? 10000 : 0);
				break;
				
			case SETLESSI:
				set_register(sarg1, check_cmp(CMP_LE) ? 10000 : 0);
				break;
	
			case READPODARRAYR:
			{
				do_readpod(false);
				break;
			}
			case READPODARRAYV:
			{
				do_readpod(true);
				break;
			}
			case WRITEPODARRAYRR:
			{
				do_writepod(false,false);
				break;
			}
			case WRITEPODARRAYRV:
			{
				do_writepod(false,true);
				break;
			}
			case WRITEPODARRAYVR:
			{
				do_writepod(true,false);
				break;
			}
			case WRITEPODARRAYVV:
			{
				do_writepod(true,true);
				break;
			}
			case WRITEPODSTRING:
			{
				do_writepodstr();
				break;
			}
			case WRITEPODARRAY:
			{
				do_writepodarr();
				break;
			}
			case ZCLASS_CONSTRUCT:
			{
				do_constructclass(type,script,i);
				break;
			}
			case ZCLASS_READ:
			{
				do_readclass();
				break;
			}
			case ZCLASS_WRITE:
			{
				do_writeclass();
				break;
			}
			case ZCLASS_FREE:
			{
				do_freeclass();
				break;
			}
			case ZCLASS_OWN:
			{
				if(user_object* obj = checkObject(get_register(sarg1), true))
				{
					obj->setGlobal(false);
					own_script_object(obj, type, i);
				}
				break;
			}
			case STARTDESTRUCTOR:
			{
				zprint2("STARTDESTRUCTOR: %s\n", sargstr->c_str());
				//This opcode's EXISTENCE indicates the first opcode
				//of a user_object destructor function.
				break;
			}
			case ZCLASS_GLOBALIZE:
			{
				if(user_object* obj = checkObject(get_register(sarg1), true))
				{
					obj->setGlobal(true);
					own_script_object(obj, ScriptType::None, 0);
				}
				break;
			}
			
			case NOT:
				do_not(false);
				break;
				
			case COMPAREV:
				do_comp(true);
				break;
			case COMPAREV2:
				do_comp(true,true);
				break;
				
			case COMPARER:
				do_comp(false);
				break;
			
			case STRCMPR:
				do_internal_strcmp();
				break;
			
			case STRICMPR:
				do_internal_stricmp();
				break;
				
			case SETV:
				do_set(true, type, i);
				break;
				
			case SETR:
				do_set(false, type, i);
				break;
				
			case PUSHR:
				do_push(false);
				break;
				
			case PUSHV:
				do_push(true);
				break;
				
			case PEEK:
				do_peek();
				break;
			case PEEKATV:
				do_peekat(true);
				break;
			case STACKWRITEATRV:
				do_writeat(false, true);
				break;
			case STACKWRITEATVV_IF:
				if(!check_cmp(sarg3))
					break;
			[[fallthrough]];
			case STACKWRITEATVV:
				do_writeat(true, true);
				break;
			case POP:
				do_pop();
				break;
			
			case POPARGS:
				do_pops();
				break;
			
			case PUSHARGSR:
				do_pushs(false);
				break;
			
			case PUSHARGSV:
				do_pushs(true);
				break;
				
			case LOADI:
				do_loadi();
				break;
				
			case STOREI:
				do_storei();
				break;
				
			case LOADD:
				do_loadd();
				break;

			case LOAD:
				do_load();
				break;
				
			case STORED:
				do_stored(false);
				break;
			case STOREDV:
				do_stored(true);
				break;
			case STORE:
				do_store(false);
				break;
			case STOREV:
				do_store(true);
				break;
			case STORE_OBJECT:
				do_store_object(false);
				break;
				
			case LOAD1:
				do_loada(0);
				break;
				
			case LOAD2:
				do_loada(1);
				break;
				
			case SETA1:
				do_seta(0);
				break;
				
			case SETA2:
				do_seta(1);
				break;
				
			case ALLOCATEGMEMR:
				if(type == ScriptType::Global) do_allocatemem(false, false, type, i);
				
				break;
				
			case ALLOCATEGMEMV:
				if(type == ScriptType::Global) do_allocatemem(true, false, type, i);
				
				break;
				
			case ALLOCATEMEMR:
				do_allocatemem(false, true, type, i);
				break;
				
			case ALLOCATEMEMV:
				do_allocatemem(true, true, type, i);
				break;
			
			case RESIZEARRAYR:
				do_resize_array();
				break;
			case OWNARRAYR:
				do_own_array(get_register(sarg1)/10000, type, i);
				break;
			case DESTROYARRAYR:
				do_destroy_array();
				break;
				
			case DEALLOCATEMEMR:
				do_deallocatemem();
				break;
				
			case SAVEGAMESTRUCTS:
				using_SRAM = 1;
				FFCore.do_savegamestructs(false,false);
				using_SRAM = 0;
				break;
			case READGAMESTRUCTS:
				using_SRAM = 1;
				FFCore.do_loadgamestructs(false,false);
				using_SRAM = 0;
				break;
			case ARRAYSIZE:
				do_arraysize();
				break;
			 case ARRAYSIZEB:
				do_arraysize();
				break;
			case ARRAYSIZEF:
				do_arraysize();
				break;
			case ARRAYSIZEN:
				do_arraysize();
				break;
			case ARRAYSIZEI:
				do_arraysize();
				break;
			case ARRAYSIZEID:
				do_arraysize();
				break;
			case ARRAYSIZEL:
				do_arraysize();
				break;
			case ARRAYSIZEE:
				do_arraysize();
				break;
			
			case GETFFCSCRIPT:
				do_getffcscript();
				break;
			case GETITEMSCRIPT:
				do_getitemscript();
				break;
				
			case CASTBOOLI:
				do_boolcast(false);
				break;
				
			case CASTBOOLF:
				do_boolcast(true);
				break;
				
			case ADDV:
				do_add(true);
				break;
				
			case ADDR:
				do_add(false);
				break;
				
			case SUBV:
				do_sub(true);
				break;
			case SUBV2:
				do_sub(true,true);
				break;
				
			case SUBR:
				do_sub(false);
				break;
				
			case MULTV:
				do_mult(true);
				break;
				
			case MULTR:
				do_mult(false);
				break;
				
			case DIVV:
				do_div(true);
				break;
			case DIVV2:
				do_div(true,true);
				break;
				
			case DIVR:
				do_div(false);
				break;
				
			case MODV:
				do_mod(true);
				break;
			case MODV2:
				do_mod(true,true);
				break;
				
			case MODR:
				do_mod(false);
				break;
				
			case SINV:
				do_trig(true, 0);
				break;
				
			case SINR:
				do_trig(false, 0);
				break;
				
			case COSV:
				do_trig(true, 1);
				break;
				
			case COSR:
				do_trig(false, 1);
				break;
				
			case TANV:
				do_trig(true, 2);
				break;
				
			case TANR:
				do_trig(false, 2);
				break;
				
			case DEGTORAD:
				do_degtorad();
				break;
				
			case RADTODEG:
				do_radtodeg();
				break;
			
			case STRINGLENGTH:
				FFCore.do_strlen(false);
				break;
				
			case ARCSINR:
				do_asin(false);
				break;
				
			case ARCCOSR:
				do_acos(false);
				break;
				
			case ARCTANR:
				do_arctan();
				break;
			
			//Text ptr functions
			case FONTHEIGHTR:
				do_fontheight();
				break;
			case STRINGWIDTHR:
				do_strwidth();
				break;
			case CHARWIDTHR:
				do_charwidth();
				break;
			case MESSAGEWIDTHR:
				ri->d[rEXP1] = 10000* do_msgwidth(get_register(sarg1)/10000, "Text->MessageWidth()");
				break;
			case MESSAGEHEIGHTR:
				ri->d[rEXP1] = 10000* do_msgheight(get_register(sarg1)/10000, "Text->MessageHeight()");
				break;
			//
			
			//String.h functions 2.55 Alpha 23
			case STRINGCOMPARE: FFCore.do_strcmp(); break;
			case STRINGICOMPARE: FFCore.do_stricmp(); break;
			case STRINGCOPY: FFCore.do_strcpy(false,false); break;
			case ARRAYCOPY: FFCore.do_arraycpy(false,false); break;
			case STRINGNCOMPARE: FFCore.do_strncmp(); break;
			case STRINGNICOMPARE: FFCore.do_strnicmp(); break;
			
			//More string.h functions, 19th May, 2019 
			case XLEN: FFCore.do_xlen(false); break;
			case XTOI: FFCore.do_xtoi(false); break;
			case ILEN: FFCore.do_ilen(false); break;
			case ATOI: FFCore.do_atoi(false); break;
			case ATOL: FFCore.do_atol(false); break;
			case STRCSPN: FFCore.do_strcspn(); break;
			case STRSTR: FFCore.do_strstr(); break;
			case XTOA: FFCore.do_xtoa(); break;
			case ITOA: FFCore.do_itoa(); break;
			case ITOACAT: FFCore.do_itoacat(); break;
			case STRCAT: FFCore.do_strcat(); break;
			case STRSPN: FFCore.do_strspn(); break;
			case STRCHR: FFCore.do_strchr(); break;
			case STRRCHR: FFCore.do_strrchr(); break;
			case XLEN2: FFCore.do_xlen2(); break;
			case XTOI2: FFCore.do_xtoi2(); break;
			case ILEN2: FFCore.do_ilen2(); break;
			case ATOI2: FFCore.do_atoi2(); break;
			case REMCHR2: FFCore.do_remchr2(); break;
			case UPPERTOLOWER: FFCore.do_UpperToLower(false); break;
			case LOWERTOUPPER: FFCore.do_LowerToUpper(false); break;
			case CONVERTCASE: FFCore.do_ConvertCase(false); break;
				
			case GETNPCSCRIPT:	FFCore.do_getnpcscript(); break;
			case GETCOMBOSCRIPT:	FFCore.do_getcomboscript(); break;
			case GETLWEAPONSCRIPT:	FFCore.do_getlweaponscript(); break;
			case GETEWEAPONSCRIPT:	FFCore.do_geteweaponscript(); break;
			case GETHEROSCRIPT:	FFCore.do_getheroscript(); break;
			case GETGENERICSCRIPT:	FFCore.do_getgenericscript(); break;
			case GETGLOBALSCRIPT:	FFCore.do_getglobalscript(); break;
			case GETDMAPSCRIPT:	FFCore.do_getdmapscript(); break;
			case GETSCREENSCRIPT:	FFCore.do_getscreenscript(); break;
			case GETSPRITESCRIPT:	FFCore.do_getitemspritescript(); break;
			case GETUNTYPEDSCRIPT:	FFCore.do_getuntypedscript(); break;
			case GETSUBSCREENSCRIPT:FFCore.do_getsubscreenscript(); break;
			case GETNPCBYNAME:	FFCore.do_getnpcbyname(); break;
			case GETITEMBYNAME:	FFCore.do_getitembyname(); break;
			case GETCOMBOBYNAME:	FFCore.do_getcombobyname(); break;
			case GETDMAPBYNAME:	FFCore.do_getdmapbyname(); break;
				
			case ABS:
				do_abs(false);
				break;
				
			case MINR:
				do_min(false);
				break;
				
			case MINV:
				do_min(true);
				break;
				
			case MAXR:
				do_max(false);
				break;
			case MAXV:
				do_max(true);
				break;
			case WRAPRADIANS:
				do_wrap_rad(false);
				break;
			case WRAPDEGREES:
				do_wrap_deg(false);
				break;
			
			case MAXVARG:
				FFCore.do_varg_max();
				break;
			case MINVARG:
				FFCore.do_varg_min();
				break;
			case CHOOSEVARG:
				FFCore.do_varg_choose();
				break;
			case MAKEVARGARRAY:
				FFCore.do_varg_makearray(type,i);
				break;
			
			case PUSHVARGV:
				do_push_varg(true);
				break;
			case PUSHVARGR:
				do_push_varg(false);
				break;
			case PUSHVARGSV:
				do_push_vargs(true);
				break;
			case PUSHVARGSR:
				do_push_vargs(false);
				break;
				
			case RNDR:
				do_rnd(false);
				break;
				
			case RNDV:
				do_rnd(true);
				break;
				
			case SRNDR:
				do_srnd(false);
				break;
				
			case SRNDV:
				do_srnd(true);
				break;
				
			case SRNDRND:
				do_srndrnd();
				break;
			
			case GETRTCTIMER:
				FFCore.getRTC(false);
				break;
			case GETRTCTIMEV:
				FFCore.getRTC(true);
				break;
				
			case FACTORIAL:
				do_factorial(false);
				break;
				
			case SQROOTV:
				do_sqroot(true);
				break;
				
			case SQROOTR:
				do_sqroot(false);
				break;
				
			case POWERR:
				do_power(false);
				break;
			case POWERV:
				do_power(true);
				break;
			case POWERV2:
				do_power(true,true);
				break;
				
			case LPOWERR:
				do_lpower(false);
				break;
			case LPOWERV:
				do_lpower(true);
				break;
			case LPOWERV2:
				do_lpower(true,true);
				break;
				
			case IPOWERR:
				do_ipower(false);
				break;
				
			case IPOWERV:
				do_ipower(true);
				break;
				
			case LOG10:
				do_log10(false);
				break;
				
			case LOGE:
				do_naturallog(false);
				break;
				
			case ANDR:
				do_and(false);
				break;
				
			case ANDV:
				do_and(true);
				break;
				
			case ORR:
				do_or(false);
				break;
				
			case ORV:
				do_or(true);
				break;
				
			case XORR:
				do_xor(false);
				break;
				
			case XORV:
				do_xor(true);
				break;
				
			case NANDR:
				do_nand(false);
				break;
				
			case NANDV:
				do_nand(true);
				break;
				
			case NORR:
				do_nor(false);
				break;
				
			case NORV:
				do_nor(true);
				break;
				
			case XNORR:
				do_xnor(false);
				break;
				
			case XNORV:
				do_xnor(true);
				break;
				
			case BITNOT:
				do_bitwisenot(false);
				break;
				
			case LSHIFTR:
				do_lshift(false);
				break;
				
			case LSHIFTV:
				do_lshift(true);
				break;
				
			case RSHIFTR:
				do_rshift(false);
				break;
				
			case RSHIFTV:
				do_rshift(true);
				break;
				
			case ANDR32:
				do_and32(false);
				break;
				
			case ANDV32:
				do_and32(true);
				break;
				
			case ORR32:
				do_or32(false);
				break;
				
			case ORV32:
				do_or32(true);
				break;
				
			case XORR32:
				do_xor32(false);
				break;
				
			case XORV32:
				do_xor32(true);
				break;
				
			case BITNOT32:
				do_bitwisenot32(false);
				break;
				
			case LSHIFTR32:
				do_lshift32(false);
				break;
				
			case LSHIFTV32:
				do_lshift32(true);
				break;
				
			case RSHIFTR32:
				do_rshift32(false);
				break;
				
			case RSHIFTV32:
				do_rshift32(true);
				break;
				
			case TRACER:
				FFCore.do_trace(false);
				break;
				
			case TRACELR:
				FFCore.do_tracel(false);
				break;
				
			case TRACEV:
				FFCore.do_trace(true);
				break;
				
			case TRACE2R:
				FFCore.do_tracebool(false);
				break;
			
			//Zap and Wavy Effects
			case FXWAVYR:
				FFCore.do_fx_wavy(false);
				break;
			case FXZAPR:
				FFCore.do_fx_zap(false);
				break;
			//Zap and Wavy Effects
			case FXWAVYV:
				FFCore.do_fx_wavy(true);
				break;
			case FXZAPV:
				FFCore.do_fx_zap(true);
				break;
			case GREYSCALER:
				FFCore.do_greyscale(false);
				break;
			case GREYSCALEV:
				FFCore.do_greyscale(true);
				break;
			case MONOCHROMER:
				FFCore.do_monochromatic(false);
				break;
			case MONOCHROMEV:
				FFCore.do_monochromatic(true);
				break;
				
			case TRACE2V:
				FFCore.do_tracebool(true);
				break;
				
			case TRACE3:
				FFCore.do_tracenl();
				break;
				
			case TRACE4:
				FFCore.do_cleartrace();
				break;
				
			case TRACE5:
				FFCore.do_tracetobase();
				break;
				
			case TRACE6:
				FFCore.do_tracestring();
				break;
			
			case PRINTFV:
				FFCore.do_printf(true, false);
				break;
			case SPRINTFV:
				FFCore.do_sprintf(true, false);
				break;
				
			case PRINTFVARG:
				FFCore.do_printf(true, true);
				break;
			case SPRINTFVARG:
				FFCore.do_sprintf(true, true);
				break;
			case PRINTFA:
				FFCore.do_printfarr();
				break;
			case SPRINTFA:
				FFCore.do_sprintfarr();
				break;
			case ARRAYPUSH:
			{
				auto ptr = SH::read_stack(ri->sp + 2) / 10000;
				auto val = SH::read_stack(ri->sp + 1);
				auto indx = SH::read_stack(ri->sp + 0) / 10000;
				ArrayManager am(ptr);
				ri->d[rEXP1] = am.push(val,indx) ? 10000 : 0;
				break;
			}
			case ARRAYPOP:
			{
				auto ptr = SH::read_stack(ri->sp + 1) / 10000;
				auto indx = SH::read_stack(ri->sp + 0) / 10000;
				ArrayManager am(ptr);
				ri->d[rEXP1] = am.pop(indx);
				break;
			}
			
			case BREAKPOINT:
				FFCore.do_breakpoint();
				break;
				
			case WARP:
				do_warp(true);
				break;
				
			case WARPR:
				do_warp(false);
				break;
				
			case PITWARP:
				do_pitwarp(true);
				break;
				
			case PITWARPR:
				do_pitwarp(false);
				break;
				
			case BREAKSHIELD:
				do_breakshield();
				break;
				
			case SELECTAWPNV:
				do_selectweapon(true, 1);
				break;
				
			case SELECTAWPNR:
				do_selectweapon(false, 1);
				break;
				
			case SELECTBWPNV:
				do_selectweapon(true, 0);
				break;
				
			case SELECTBWPNR:
				do_selectweapon(false, 0);
				break;
				
			case SELECTXWPNR:
				do_selectweapon(false, 2);
				break;
				
			case SELECTYWPNR:
				do_selectweapon(false, 3);
				break;
				
			case PLAYSOUNDR:
				do_sfx(false);
				break;
				
			case PLAYSOUNDV:
				do_sfx(true);
				break;
			
			case ADJUSTSFXVOLUMER: FFCore.do_adjustsfxvolume(false); break;
			case ADJUSTSFXVOLUMEV: FFCore.do_adjustsfxvolume(true); break;	
			case ADJUSTVOLUMER: FFCore.do_adjustvolume(false); break;
			case ADJUSTVOLUMEV: FFCore.do_adjustvolume(true); break;
				
			case TRIGGERSECRETR:
				FFScript::do_triggersecret(false);
				break;
				
			case TRIGGERSECRETV:
				FFScript::do_triggersecret(true);
				break;
				
			case PLAYMIDIR:
				do_midi(false);
				break;
				
			case PLAYMIDIV:
				do_midi(true);
				break;
				
			case PLAYENHMUSIC:
				do_enh_music(false);
				break;
				
			case GETMUSICFILE:
				do_get_enh_music_filename(false);
				break;
				
			case GETMUSICTRACK:
				do_get_enh_music_track(false);
				break;
				
			case SETDMAPENHMUSIC:
				do_set_dmap_enh_music(false);
				break;
			
			// Audio->
			
			case ENDSOUNDR:
				stop_sfx(false);
				break;
				
			case ENDSOUNDV:
				stop_sfx(true);
				break;
			
			case PAUSESOUNDR:
				pause_sfx(false);
				break;
				
			case PAUSESOUNDV:
				pause_sfx(true);
				break;
			
			case RESUMESOUNDR:
				resume_sfx(false);
				break;
				
			case RESUMESOUNDV:
				resume_sfx(true);
				break;
			
			
			
			case PAUSESFX:
			{
				int32_t sound = ri->d[rINDEX]/10000;
				pause_sfx(sound);
				
			}
			break;

			case RESUMESFX:
			{
				int32_t sound = ri->d[rINDEX]/10000;
				resume_sfx(sound);
			}
			break;

			case ADJUSTSFX:
			{
				do_sfx_ex(false);
			}
			break;

			case PLAYSOUNDEX:
			{
				do_sfx_ex(true);
			}
			break;

			case GETSFXCOMPLETION:
			{
				do_get_sfx_completion();
			}
			break;

			case CONTINUESFX:
			{
				int32_t sound = ri->d[rINDEX]/10000;
				//Backend::sfx->cont_sfx(sound);
				
				//! cont_sfx was not ported to the new back end!!!
				// I believe this restarted the loop. 
				resume_sfx(sound);
				//What was the old instruction, again? Did it exist? -Z
				//continue_sfx(sound);
			}
			break;	

			
			/*
			case STOPITEMSOUND:
				void stop_item_sfx(int32_t family)
			*/
			
			// Note: these have never worked.
			case PAUSEMUSIC:
				//What was the instruction prior to adding backends?
				//! The pauseAll() function pauses sfx, not music, so this instruction is not doing what I intended. -Z
				//Check AllOff() -Z
				//zcmusic_pause(ZCMUSIC* zcm, int32_t pause); is in zcmusic.h
				// midi_paused = true; 
				//pause_all_sfx();
			
				//Backend::sfx->pauseAll();
				break;
			case RESUMEMUSIC:
				//What was the instruction prior to adding backends?
				//Check AllOff() -Z
				//resume_all_sfx();
				// midi_paused = false; 
				//Backend::sfx->resumeAll();
				break;
			
			//!!! typecasting
			case LWPNARRPTR:
			case EWPNARRPTR:
			case ITEMARRPTR:
			case IDATAARRPTR:
			case FFCARRPTR:
			case BOOLARRPTR:
			case NPCARRPTR:
				
			case LWPNARRPTR2:
			case EWPNARRPTR2:
			case ITEMARRPTR2:
			case IDATAARRPTR2:
			case FFCARRPTR2:
			case BOOLARRPTR2:
			case NPCARRPTR2:
				FFScript::do_typedpointer_typecast(false);
				break;
				
			case MSGSTRR:
				do_message(false);
				break;
				
			case MSGSTRV:
				do_message(true);
				break;
				
			case ITEMNAME:
				do_getitemname();
				break;
				
			case NPCNAME:
				do_getnpcname();
				break;
			
			case NPCDATAGETNAME:
				FFCore.do_getnpcdata_getname();
				break;
				
			case GETSAVENAME:
				do_getsavename();
				break;
				
			case SETSAVENAME:
				do_setsavename();
				break;
				
			case GETMESSAGE:
				do_getmessage(false);
				break;
			case SETMESSAGE:
				do_setmessage(false);
				break;
				
			case GETDMAPNAME:
				do_getdmapname(false);
				break;
				
			case GETDMAPTITLE:
				do_getdmaptitle(false);
				break;
				
			case GETDMAPINTRO:
				do_getdmapintro(false);
				break;
				
			case SETDMAPNAME:
				do_setdmapname(false);
				break;
				
			case SETDMAPTITLE:
				do_setdmaptitle(false);
				break;
			
			case SETDMAPINTRO:
				do_setdmapintro(false);
				break;
			
			case LOADLWEAPONR:
				do_loadlweapon(false);
				break;
				
			case LOADLWEAPONV:
				do_loadlweapon(true);
				break;
				
			case LOADEWEAPONR:
				do_loadeweapon(false);
				break;
				
			case LOADEWEAPONV:
				do_loadeweapon(true);
				break;
				
			case LOADITEMR:
				do_loaditem(false);
				break;
				
			case LOADITEMV:
				do_loaditem(true);
				break;
				
			case LOADITEMDATAR:
				do_loaditemdata(false);
				break;
			
			//New Datatypes
			case LOADSHOPR:
				FFScript::do_loadshopdata(false);
				break;
			case LOADSHOPV:
				FFScript::do_loadshopdata(true);
				break;
			
			case LOADINFOSHOPR:
				FFScript::do_loadinfoshopdata(false);
				break;
			case LOADINFOSHOPV:
				FFScript::do_loadinfoshopdata(true);
				break;
			case LOADNPCDATAR:
				FFScript::do_loadnpcdata(false);
				break;
			case LOADNPCDATAV:
				FFScript::do_loadnpcdata(true);
				break;
			
			case LOADCOMBODATAR:
				FFScript::do_loadcombodata(false);
				break;
			case LOADCOMBODATAV:
				FFScript::do_loadcombodata(true);
				break;
			
			case LOADMAPDATAR:
				FFScript::do_loadmapdata(false);
				break;
			case LOADMAPDATAV:
				FFScript::do_loadmapdata(true);
				break;
			case LOADTMPSCR:
				FFScript::do_loadmapdata_tempscr(false);
				break;
			case LOADSCROLLSCR:
				FFScript::do_loadmapdata_scrollscr(false);
				break;
			
			case LOADSPRITEDATAR:
				FFScript::do_loadspritedata(false);
				break;
			case LOADSPRITEDATAV:
				FFScript::do_loadspritedata(true);
				break;
			
			case LOADSCREENDATAR:
				FFScript::do_loadscreendata(false);
				break;
			case LOADSCREENDATAV:
				FFScript::do_loadscreendata(true);
				break;
			
			case LOADBITMAPDATAR:
				FFScript::do_loadbitmapid(false);
				break;
			
			
			case LOADBITMAPDATAV:
				FFScript::do_loadbitmapid(true);
				break;
			
			//functions
			case LOADDMAPDATAR: //command
				FFScript::do_loaddmapdata(false); break;
			case LOADDMAPDATAV: //command
				FFScript::do_loaddmapdata(true); break;
			case LOADSUBDATARV:
				FFScript::do_load_subscreendata(false, true); break;
			case SWAPSUBSCREENV:
			{
				auto ty = sarg1/10000;
				std::vector<ZCSubscreen>* vec = nullptr;
				switch(ty)
				{
					case sstACTIVE:
						vec = &subscreens_active;
						break;
					case sstPASSIVE:
						vec = &subscreens_passive;
						break;
					case sstOVERLAY:
						vec = &subscreens_overlay;
						break;
					default:
						Z_scripterrlog("Invalid Subscreen Type passed to ???: %d\n", ty);
						break;
				}
				if(vec)
				{
					auto& v = *vec;
					int p1 = SH::read_stack(ri->sp+1);
					int p2 = SH::read_stack(ri->sp+0);
					if(unsigned(p1) >= v.size())
						Z_scripterrlog("Invalid susbcr index '%d' passed to subscreendata->Swap*Pages()\n", p1);
					else if(unsigned(p2) >= v.size())
						Z_scripterrlog("Invalid susbcr index '%d' passed to subscreendata->Swap*Pages()\n", p2);
					else zc_swap(v[p1],v[p2]);
				}
				break;
			}
			case LOADDIRECTORYR:
				FFCore.do_loaddirectory(); break;
			case LOADSTACK:
				FFCore.do_loadstack(); break;
			case CREATEPALDATA:
				FFCore.do_create_paldata(); break;
			case CREATEPALDATACLR:
				FFCore.do_create_paldata_clr(); break;
			case MIXCLR:
				FFCore.do_mix_clr(); break;
			case CREATERGBHEX:
				FFCore.do_create_rgb_hex(); break;
			case CREATERGB:
				FFCore.do_create_rgb(); break;
			case CONVERTFROMRGB:
				FFCore.do_convert_from_rgb(); break;
			case CONVERTTORGB:
				FFCore.do_convert_to_rgb(); break;
			case PALDATALOADLEVEL:
				FFCore.do_paldata_load_level(); break;
			case PALDATALOADSPRITE:
				FFCore.do_paldata_load_sprite(); break;
			case PALDATALOADMAIN:
				FFCore.do_paldata_load_main(); break;
			case PALDATALOADCYCLE:
				FFCore.do_paldata_load_cycle(); break;
			case PALDATALOADBITMAP:
				FFCore.do_paldata_load_bitmap(); break;
			case PALDATAWRITELEVEL:
				FFCore.do_paldata_write_level(); break;
			case PALDATAWRITELEVELCS:
				FFCore.do_paldata_write_levelcset(); break;
			case PALDATAWRITESPRITE:
				FFCore.do_paldata_write_sprite(); break;
			case PALDATAWRITESPRITECS:
				FFCore.do_paldata_write_spritecset(); break;
			case PALDATAWRITEMAIN:
				FFCore.do_paldata_write_main(); break;
			case PALDATAWRITEMAINCS:
				FFCore.do_paldata_write_maincset(); break;
			case PALDATAWRITECYCLE:
				FFCore.do_paldata_write_cycle(); break;
			case PALDATAWRITECYCLECS:
				FFCore.do_paldata_write_cyclecset(); break;
			case PALDATAVALIDCLR:
				FFCore.do_paldata_colorvalid(); break;
			case PALDATACLEARCLR:
				FFCore.do_paldata_clearcolor(); break;
			case PALDATACLEARCSET:
				FFCore.do_paldata_clearcset(); break;
			case PALDATAMIX:
				FFCore.do_paldata_mix(); break;
			case PALDATAMIXCS:
				FFCore.do_paldata_mixcset(); break;
			case PALDATACOPY:
				FFCore.do_paldata_copy(); break;
			case PALDATACOPYCSET:
				FFCore.do_paldata_copycset(); break;
			case PALDATAFREE:
				if (user_paldata* pd = checkPalData(ri->paldataref, "Free()", true))
				{
					free_script_object(pd->id);
				}
				break;
			case PALDATAOWN:
				if (user_paldata* pd = checkPalData(ri->paldataref, "Own()", false))
				{
					own_script_object(pd, type, i);
				}
				break;
			case LOADDROPSETR: //command
				FFCore.do_loaddropset(false); break;
			case LOADRNG: //command
				FFCore.do_loadrng(); break;
			case LOADBOTTLETYPE: //command
				FFCore.do_loadbottle(false); break;
			case LOADBSHOPDATA: //command
				FFCore.do_loadbottleshop(false); break;

			case ITEMGETDISPLAYNAME: //command
				item_display_name(false); break;
			case ITEMSETDISPLAYNAME: //command
				item_display_name(true); break;
			case ITEMGETSHOWNNAME: //command
				item_shown_name(); break;

			case DMAPDATAGETNAMER: //command
				FFScript::do_getDMapData_dmapname(false); break;
			case DMAPDATAGETNAMEV: //command
				FFScript::do_getDMapData_dmapname(true); break;

			case DMAPDATASETNAMER: //command
				FFScript::do_setDMapData_dmapname(false); break;
			case DMAPDATASETNAMEV: //command
				FFScript::do_setDMapData_dmapname(true); break;



			case DMAPDATAGETTITLER: //command
				FFScript::do_getDMapData_dmaptitle(false); break;
			case DMAPDATAGETTITLEV: //command
				FFScript::do_getDMapData_dmaptitle(true); break;
			case DMAPDATASETTITLER: //command
				FFScript::do_setDMapData_dmaptitle(false); break;
			case DMAPDATASETTITLEV: //command
				FFScript::do_setDMapData_dmaptitle(true); break;


			case DMAPDATAGETINTROR: //command
				FFScript::do_getDMapData_dmapintro(false); break;
			case DMAPDATAGETINTROV: //command
				FFScript::do_getDMapData_dmapintro(true); break;
			case DMAPDATANSETITROR: //command
				FFScript::do_setDMapData_dmapintro(false); break;
			case DMAPDATASETINTROV: //command
				FFScript::do_setDMapData_dmapintro(true); break;


			case DMAPDATAGETMUSICR: //command, string to load a music file
				FFScript::do_getDMapData_music(false); break;
			case DMAPDATAGETMUSICV: //command, string to load a music file
				FFScript::do_getDMapData_music(true); break;
			case DMAPDATASETMUSICR: //command, string to load a music file
				FFScript::do_setDMapData_music(false); break;
			case DMAPDATASETMUSICV: //command, string to load a music file
				FFScript::do_setDMapData_music(true); break;

			case LOADMESSAGEDATAR: //COMMAND
				FFScript::do_loadmessagedata(false);
				break;
			case LOADMESSAGEDATAV: //COMMAND
				FFScript::do_loadmessagedata(false);
				break;
			

			case MESSAGEDATASETSTRINGR: //command
				FFScript::do_messagedata_setstring(false);
				break;
			case MESSAGEDATASETSTRINGV: //command
				FFScript::do_messagedata_setstring(false);
				break;
			
			case MESSAGEDATAGETSTRINGR: //command
				FFScript::do_messagedata_getstring(false);
				break;
			case MESSAGEDATAGETSTRINGV: //command
				FFScript::do_messagedata_getstring(false);
				break;	
			case LOADITEMDATAV:
				do_loaditemdata(true);
				break;
				
			case LOADNPCBYSUID:
				FFCore.do_loadnpc_by_script_uid(false);
				break;
			
			case LOADLWEAPONBYSUID:
				FFCore.do_loadlweapon_by_script_uid(false);
				break;
			
			case LOADWEAPONCBYSUID:
				FFCore.do_loadeweapon_by_script_uid(false);
				break;
			
			case LOADNPCR:
				do_loadnpc(false);
				break;
				
			case LOADNPCV:
				do_loadnpc(true);
				break;
				
			case CREATELWEAPONR:
				do_createlweapon(false);
				break;
				
			case CREATELWEAPONV:
				do_createlweapon(true);
				break;
				
			case CREATEEWEAPONR:
				do_createeweapon(false);
				break;
				
			case CREATEEWEAPONV:
				do_createeweapon(true);
				break;
				
			case CREATEITEMR:
				do_createitem(false);
				break;
				
			case CREATEITEMV:
				do_createitem(true);
				break;
				
			case CREATENPCR:
				do_createnpc(false);
				break;
				
			case CREATENPCV:
				do_createnpc(true);
				break;
				
			case ISVALIDARRAY:
				do_isvalidarray();
				break;
				
			case ISVALIDITEM:
				do_isvaliditem();
				break;
			
			case ISVALIDBITMAP:
				FFCore.do_isvalidbitmap();
				break;
			
			case ISALLOCATEDBITMAP:
				FFCore.do_isallocatedbitmap();
				break;
				
			case ISVALIDNPC:
				do_isvalidnpc();
				break;
				
			case ISVALIDLWPN:
				do_isvalidlwpn();
				break;
				
			case ISVALIDEWPN:
				do_isvalidewpn();
				break;
				
			case LWPNMAKEANGULAR:
				do_lwpnmakeangular();
				break;
				
			case EWPNMAKEANGULAR:
				do_ewpnmakeangular();
				break;
			
			case LWPNMAKEDIRECTIONAL:
				do_lwpnmakedirectional();
				break;
				
			case EWPNMAKEDIRECTIONAL:
				do_ewpnmakedirectional();
				break;
				
			case LWPNUSESPRITER:
				do_lwpnusesprite(false);
				break;
				
			case LWPNUSESPRITEV:
				do_lwpnusesprite(true);
				break;
				
			case EWPNUSESPRITER:
				do_ewpnusesprite(false);
				break;
				
			case EWPNUSESPRITEV:
				do_ewpnusesprite(true);
				break;
				
			case CLEARSPRITESR:
				do_clearsprites(false);
				break;
				
			case CLEARSPRITESV:
				do_clearsprites(true);
				break;
				
			case ISSOLID:
				do_issolid();
				break;
			
			case MAPDATAISSOLID:
				do_mapdataissolid();
				break;
				
			case MAPDATAISSOLIDLYR:
				do_mapdataissolid_layer();
				break;
				
			case ISSOLIDLAYER:
				do_issolid_layer();
				break;
				
			case SETSIDEWARP:
				do_setsidewarp();
				break;
				
			case SETTILEWARP:
				do_settilewarp();
				break;
				
			case GETSIDEWARPDMAP:
				do_getsidewarpdmap(false);
				break;
				
			case GETSIDEWARPSCR:
				do_getsidewarpscr(false);
				break;
				
			case GETSIDEWARPTYPE:
				do_getsidewarptype(false);
				break;
				
			case GETTILEWARPDMAP:
				do_gettilewarpdmap(false);
				break;
				
			case GETTILEWARPSCR:
				do_gettilewarpscr(false);
				break;
				
			case GETTILEWARPTYPE:
				do_gettilewarptype(false);
				break;
				
			case LAYERSCREEN:
				do_layerscreen();
				break;
				
			case LAYERMAP:
				do_layermap();
				break;
				
			case SECRETS:
				do_triggersecrets();
				break;
				
			case GETSCREENFLAGS:
				do_getscreenflags();
				break;
				
			case GETSCREENEFLAGS:
				do_getscreeneflags();
				break;
			
			case GRAPHICSGETPIXEL:
				FFCore.do_graphics_getpixel();
				break;
			case GRAPHICSCOUNTCOLOR:
				FFCore.do_bmpcollision();
				break;
			
			case GETSCREENDOOR:
				do_getscreendoor();
				break;
			
			case GETSCREENENEMY:
				do_getscreennpc();
				break;
			
			//screendata and mapdata
			case SETSCREENENEMY:
			{ //void SetScreenEnemy(int32_t map, int32_t screen, int32_t index, int32_t value);
				int32_t map     = (ri->d[rINDEX2] / 10000) - 1; 
				int32_t scrn  = ri->d[rEXP1] / 10000; 
				int32_t index = ri->d[rINDEX] / 10000; 
				int32_t nn = ri->d[rEXP2]/10000; 
			
				// int32_t x;
				
				// zprint("ri->d[rEXP2] is (%i), trying to use for '%s'\n", nn, "nn");
				// zprint("ri->d[rEXP1] is (%i), trying to use for '%s'\n", scrn, "scrn");
				// zprint("ri->d[rINDEX2] is (%i), trying to use for '%s'\n", map, "map");
				// zprint("ri->d[rINDEX] is (%i), trying to use for '%s'\n", index, "index");
				
				if(BC::checkMapID(map, "Game->SetScreenEnemy(...map...)") != SH::_NoError ||
					BC::checkBounds(scrn, 0, 0x87, "Game->SetScreenEnemy(...screen...)") != SH::_NoError ||
					BC::checkBounds(index, 0, 9, "Game->SetScreenEnemy(...index...)") != SH::_NoError)
					return RUNSCRIPT_ERROR;
				
				//	if ( BC::checkBounds(nn, 0, 2, "Game->SetScreenEnemy(...enemy...)") != SH::_NoError) x = 1;
				//	if ( BC::checkBounds(map, 20, 21, "Game->SetScreenEnemy(...map...)") != SH::_NoError) x = 2;
				FFScript::set_screenenemy(&TheMaps[map * MAPSCRS + scrn], index, nn); 
			}
			break;
			
			case SETSCREENDOOR:
			{ //void SetScreenDoor(int32_t map, int32_t screen, int32_t index, int32_t value);
				int32_t map     = (ri->d[rINDEX2] / 10000) - 1; 
				int32_t scrn  = ri->d[rEXP1] / 10000; 
				int32_t index = ri->d[rINDEX] / 10000; 
				int32_t nn = ri->d[rEXP2]/10000; 
				
				if(BC::checkMapID(map, "Game->SetScreenDoor(...map...)") != SH::_NoError ||
					BC::checkBounds(scrn, 0, 0x87, "Game->SetScreenDoor(...screen...)") != SH::_NoError ||
					BC::checkBounds(index, 0, 3, "Game->SetScreenDoor(...doorindex...)") != SH::_NoError)
				{
					return RUNSCRIPT_ERROR; break;
				}
				else
				{
					FFScript::set_screendoor(&TheMaps[map * MAPSCRS + scrn], index, nn); 
					break;
				}
				
			}
				
			case GETSCREENLAYOP:
				do_getscreenLayerOpacity();
				break;
			case GETSCREENSECCMB:
				do_getscreenSecretCombo();
				break;
			case GETSCREENSECCST:
				do_getscreenSecretCSet();
				break;
			case GETSCREENSECFLG:
				do_getscreenSecretFlag();
				break;
			case GETSCREENLAYMAP:
				do_getscreenLayerMap();
				break;
			case GETSCREENLAYSCR:
				do_getscreenLayerscreen();
				break;
			case GETSCREENPATH:
				do_getscreenPath();
				break;
			case GETSCREENWARPRX:
				do_getscreenWarpReturnX();
				break;
			case GETSCREENWARPRY:
				do_getscreenWarpReturnY();
				break;

			case COMBOTILE:
				do_combotile(false);
				break;
			
			case DRAWLIGHT_CIRCLE:
			{
				static const int ARGS = 7;
				zfix cx = zslongToFix(SH::read_stack(ri->sp + (ARGS-1)));
				zfix cy = zslongToFix(SH::read_stack(ri->sp + (ARGS-2)));
				int radius = SH::read_stack(ri->sp + (ARGS-3));
				int transp_rad = SH::read_stack(ri->sp + (ARGS-4));
				int dith_rad = SH::read_stack(ri->sp + (ARGS-5));
				int dith_type = SH::read_stack(ri->sp + (ARGS-6));
				int dith_arg = SH::read_stack(ri->sp + (ARGS-7));
				if(radius >= 0) radius /= 10000;
				else radius = game->get_light_rad();
				if(!radius) break;
				if(transp_rad >= 0) transp_rad /= 10000;
				if(dith_rad >= 0) dith_rad /= 10000;
				if(dith_type >= 0) dith_type /= 10000;
				if(dith_arg >= 0) dith_arg /= 10000;
				
				int32_t scrolldir = FFCore.ScrollingData[SCROLLDATA_DIR];
				int32_t scrollxoffs = 0, scrollyoffs = 0;
				switch(scrolldir)
				{
					case up:
						scrollyoffs = -176;
						break;
					case down:
						scrollyoffs = 176;
						break;
					case left:
						scrollxoffs = -256;
						break;
					case right:
						scrollxoffs = 256;
						break;
				}
				
				doDarkroomCircle(cx,cy,radius,darkscr_bmp_curscr,nullptr,dith_rad,transp_rad,dith_type,dith_arg);
				doDarkroomCircle(cx+scrollxoffs,cy+scrollyoffs,radius,darkscr_bmp_scrollscr,nullptr,dith_rad,transp_rad,dith_type,dith_arg);
				break;
			}
			case DRAWLIGHT_SQUARE:
			{
				static const int ARGS = 7;
				zfix cx = zslongToFix(SH::read_stack(ri->sp + (ARGS-1)));
				zfix cy = zslongToFix(SH::read_stack(ri->sp + (ARGS-2)));
				int radius = SH::read_stack(ri->sp + (ARGS-3));
				int transp_rad = SH::read_stack(ri->sp + (ARGS-4));
				int dith_rad = SH::read_stack(ri->sp + (ARGS-5));
				int dith_type = SH::read_stack(ri->sp + (ARGS-6));
				int dith_arg = SH::read_stack(ri->sp + (ARGS-7));
				if(radius >= 0) radius /= 10000;
				else radius = game->get_light_rad();
				if(!radius) break;
				if(transp_rad >= 0) transp_rad /= 10000;
				if(dith_rad >= 0) dith_rad /= 10000;
				if(dith_type >= 0) dith_type /= 10000;
				if(dith_arg >= 0) dith_arg /= 10000;
				
				int32_t scrolldir = FFCore.ScrollingData[SCROLLDATA_DIR];
				int32_t scrollxoffs = 0, scrollyoffs = 0;
				switch(scrolldir)
				{
					case up:
						scrollyoffs = -176;
						break;
					case down:
						scrollyoffs = 176;
						break;
					case left:
						scrollxoffs = -256;
						break;
					case right:
						scrollxoffs = 256;
						break;
				}
				
				doDarkroomSquare(cx,cy,radius,darkscr_bmp_curscr,nullptr,dith_rad,transp_rad,dith_type,dith_arg);
				doDarkroomSquare(cx+scrollxoffs,cy+scrollyoffs,radius,darkscr_bmp_scrollscr,nullptr,dith_rad,transp_rad,dith_type,dith_arg);
				break;
			}
			case DRAWLIGHT_CONE:
			{
				static const int ARGS = 8;
				zfix cx = zslongToFix(SH::read_stack(ri->sp + (ARGS-1)));
				zfix cy = zslongToFix(SH::read_stack(ri->sp + (ARGS-2)));
				int dir = SH::read_stack(ri->sp + (ARGS-3)) / 10000;
				int radius = SH::read_stack(ri->sp + (ARGS-4));
				int transp_rad = SH::read_stack(ri->sp + (ARGS-5));
				int dith_rad = SH::read_stack(ri->sp + (ARGS-6));
				int dith_type = SH::read_stack(ri->sp + (ARGS-7));
				int dith_arg = SH::read_stack(ri->sp + (ARGS-8));
				if(radius >= 0) radius /= 10000;
				else radius = game->get_light_rad()*2;
				if(!radius) break;
				if(dir < 0) break;
				else dir = NORMAL_DIR(dir);
				if(transp_rad >= 0) transp_rad /= 10000;
				if(dith_rad >= 0) dith_rad /= 10000;
				if(dith_type >= 0) dith_type /= 10000;
				if(dith_arg >= 0) dith_arg /= 10000;
				
				int32_t scrolldir = FFCore.ScrollingData[SCROLLDATA_DIR];
				int32_t scrollxoffs = 0, scrollyoffs = 0;
				switch(scrolldir)
				{
					case up:
						scrollyoffs = -176;
						break;
					case down:
						scrollyoffs = 176;
						break;
					case left:
						scrollxoffs = -256;
						break;
					case right:
						scrollxoffs = 256;
						break;
				}
				
				doDarkroomCone(cx,cy,radius,dir,darkscr_bmp_curscr,nullptr,dith_rad,transp_rad,dith_type,dith_arg);
				doDarkroomCone(cx+scrollxoffs,cy+scrollyoffs,radius,dir,darkscr_bmp_scrollscr,nullptr,dith_rad,transp_rad,dith_type,dith_arg);
				break;
			}
			
			case RECTR:
			case CIRCLER:
			case ARCR:
			case ELLIPSER:
			case LINER:
			case PUTPIXELR:
			case PIXELARRAYR:
			case TILEARRAYR:
			case LINESARRAY:
			case COMBOARRAYR:
			case DRAWTILER:
			case DRAWTILECLOAKEDR:
			case DRAWCOMBOR:
			case DRAWCOMBOCLOAKEDR:
			case DRAWCHARR:
			case DRAWINTR:
			case QUADR:
			case TRIANGLER:
			case QUAD3DR:
			case TRIANGLE3DR:
			case FASTTILER:
			case FASTCOMBOR:
			case DRAWSTRINGR:
			case DRAWSTRINGR2:
			case BMPDRAWSTRINGR2:
			case SPLINER:
			case BITMAPR:
			case BITMAPEXR:
			case DRAWLAYERR:
			case DRAWSCREENR:
			case POLYGONR:
			case FRAMER:
				do_drawing_command(scommand);
				break;
			
			case BMPRECTR:	
			case BMPCIRCLER:
			case BMPARCR:
			case BMPELLIPSER:
			case BMPLINER:
			case BMPSPLINER:
			case BMPPUTPIXELR:
			case BMPDRAWTILER:
			case BMPDRAWTILECLOAKEDR:
			case BMPDRAWCOMBOR:
			case BMPDRAWCOMBOCLOAKEDR:
			case BMPFASTTILER:
			case BMPFASTCOMBOR:
			case BMPDRAWCHARR:
			case BMPDRAWINTR:
			case BMPDRAWSTRINGR:
			case BMPQUADR:
			case BMPQUAD3DR:
			case BMPTRIANGLER:
			case BMPTRIANGLE3DR:
			case BMPPOLYGONR:
			case BMPDRAWLAYERR: 
			case BMPDRAWLAYERSOLIDR: 
			case BMPDRAWLAYERCFLAGR: 
			case BMPDRAWLAYERCTYPER: 
			case BMPDRAWLAYERCIFLAGR: 
			case BMPDRAWLAYERSOLIDITYR: 
			case BMPDRAWSCREENR:
			case BMPDRAWSCREENSOLIDR:
			case BMPDRAWSCREENSOLID2R:
			case BMPDRAWSCREENCOMBOFR:
			case BMPDRAWSCREENCOMBOIR:
			case BMPDRAWSCREENCOMBOTR:
			case BITMAPGETPIXEL:
			case BMPBLIT:
			case BMPBLITTO:
			case BMPMODE7:
			case WRITEBITMAP:
			case CLEARBITMAP:
			case BITMAPCLEARTOCOLOR:
			case BMPFRAMER:
			case BMPWRITETILE:
			case BMPDITHER:
			case BMPREPLCOLOR:
			case BMPSHIFTCOLOR:
			case BMPMASKDRAW:
			case BMPMASKDRAW2:
			case BMPMASKDRAW3:
			case BMPMASKBLIT:
			case BMPMASKBLIT2:
			case BMPMASKBLIT3:
				do_drawing_command(scommand);
				break;
			case READBITMAP:
			{
				uint32_t bitref = SH::read_stack(ri->sp+2);
				if(user_bitmap* b = checkBitmap(bitref,"Read()",false,true))
					do_drawing_command(scommand);
				else //If the pointer isn't allocated, attempt to allocate it first
				{
					bitref = FFCore.get_free_bitmap();
					ri->d[rEXP2] = bitref; //Return to ptr
					if(bitref) SH::write_stack(ri->sp+2,bitref); //Write the ref, for the drawing command to read
					else break; //No ref allocated; don't enqueue the drawing command.
					do_drawing_command(scommand);
				}
				break;
			}
			case REGENERATEBITMAP:
			{
				ri->d[rEXP2] = SH::read_stack(ri->sp+3);
				if(user_bitmap* b = checkBitmap(ri->d[rEXP2],"Create()",false,true))
					do_drawing_command(scommand);
				else //If the pointer isn't allocated
				{
					int32_t w = SH::read_stack(ri->sp) / 10000;
					int32_t h = SH::read_stack(ri->sp+1) / 10000;
					if ( get_qr(qr_OLDCREATEBITMAP_ARGS) )
					{
						//flip height and width
						h = h ^ w;
						w = h ^ w; 
						h = h ^ w;
					}
					
					ri->d[rEXP2] = FFCore.create_user_bitmap_ex(h,w); //Return to ptr
				}
				break;
			}
			
			case BITMAPFREE:
			{
				FFCore.do_deallocate_bitmap();
				break;
			}
			
			case BITMAPOWN:
			{
				if(FFCore.isSystemBitref(ri->bitmapref))
					break; //Don't attempt to own system bitmaps!

				if (auto bitmap = checkBitmap(ri->bitmapref, "Own()", false))
					own_script_object(bitmap, type, i);
				break;
			}
			
			case OBJ_OWN_BITMAP:
			{
				int bmpid = get_register(sarg1);
				if(FFCore.isSystemBitref(bmpid))
					break; //Don't attempt to own system bitmaps!
				user_bitmap* b = checkBitmap(bmpid, nullptr, false);
				if(!b) break;
				ScriptType own_type = (ScriptType)sarg2;
				int32_t own_i = get_own_i(own_type);
				own_script_object(b, own_type, own_i);
				break;
			}
			case OBJ_OWN_PALDATA:
			{
				int palid = get_register(sarg1);
				user_paldata* pd = checkPalData(palid, nullptr, false);
				if(!pd) break;
				ScriptType own_type = (ScriptType)sarg2;
				int32_t own_i = get_own_i(own_type);
				own_script_object(pd, own_type, own_i);
				break;
			}
			case OBJ_OWN_FILE:
			{
				int fileid = get_register(sarg1);
				user_file* f = checkFile(fileid, nullptr, false);
				if(!f) break;
				ScriptType own_type = (ScriptType)sarg2;
				int32_t own_i = get_own_i(own_type);
				own_script_object(f, own_type, own_i);
				break;
			}
			case OBJ_OWN_DIR:
			{
				int dirid = get_register(sarg1);
				user_dir* dr = checkDir(dirid, nullptr, false);
				if(!dr) break;
				ScriptType own_type = (ScriptType)sarg2;
				int32_t own_i = get_own_i(own_type);
				own_script_object(dr, own_type, own_i);
				break;
			}
			case OBJ_OWN_STACK:
			{
				int stackid = get_register(sarg1);
				user_stack* st = checkStack(stackid, nullptr, false);
				if(!st) break;
				ScriptType own_type = (ScriptType)sarg2;
				int32_t own_i = get_own_i(own_type);
				own_script_object(st, own_type, own_i);
				break;
			}
			case OBJ_OWN_RNG:
			{
				int rngid = get_register(sarg1);
				user_rng* r = checkRNG(rngid, nullptr, false);
				if(!r) break;
				ScriptType own_type = (ScriptType)sarg2;
				int32_t own_i = get_own_i(own_type);
				own_script_object(r, own_type, own_i);
				break;
			}
			case OBJ_OWN_CLASS:
			{
				int classid = get_register(sarg1);
				user_object* obj = checkObject(classid, false);
				if(!obj) break;
				ScriptType own_type = (ScriptType)sarg2;
				int32_t own_i = get_own_i(own_type);
				own_script_object(obj, own_type, own_i);
				break;
			}
			case OBJ_OWN_ARRAY:
			{
				int arrid = get_register(sarg1)/10000;
				ScriptType own_type = (ScriptType)sarg2;
				int32_t own_i = get_own_i(own_type);
				do_own_array(arrid, own_type, own_i);
				break;
			}
				
			case COPYTILEVV:
				do_copytile(true, true);
				break;
				
			case COPYTILEVR:
				do_copytile(true, false);
				break;
				
			case COPYTILERV:
				do_copytile(false, true);
				break;
				
			case COPYTILERR:
				do_copytile(false, false);
				break;
				
			case SWAPTILEVV:
				do_swaptile(true, true);
				break;
				
			case SWAPTILEVR:
				do_swaptile(true, false);
				break;
				
			case SWAPTILERV:
				do_swaptile(false, true);
				break;
				
			case SWAPTILERR:
				do_swaptile(false, false);
				break;
				
			case CLEARTILEV:
				do_cleartile(true);
				break;
				
			case CLEARTILER:
				do_cleartile(false);
				break;
				
			case OVERLAYTILEVV:
				do_overlaytile(true, true);
				break;
				
			case OVERLAYTILEVR:
				do_overlaytile(true, false);
				break;
				
			case OVERLAYTILERV:
				do_overlaytile(false, true);
				break;
				
			case OVERLAYTILERR:
				do_overlaytile(false, false);
				break;
				
			case FLIPROTTILEVV:
				do_fliprotatetile(true, true);
				break;
				
			case FLIPROTTILEVR:
				do_fliprotatetile(true, false);
				break;
				
			case FLIPROTTILERV:
				do_fliprotatetile(false, true);
				break;
				
			case FLIPROTTILERR:
				do_fliprotatetile(false, false);
				break;
				
			case GETTILEPIXEL:
				do_gettilepixel();
				break;
				
			case SETTILEPIXEL:
				do_settilepixel();
				break;
				
			case SHIFTTILEVV:
				do_shifttile(true, true);
				break;
				
			case SHIFTTILEVR:
				do_shifttile(true, false);
				break;
				
			case SHIFTTILERV:
				do_shifttile(false, true);
				break;
				
			case SHIFTTILERR:
				do_shifttile(false, false);
				break;
				
			case SETRENDERTARGET:
				do_set_rendertarget(true);
				break;
				
			case GAMEEND:
				if ( using_SRAM )
				{
					Z_scripterrlog("Cannot End Game while reading or writing to SRAM. Aborting End. /n");
					break;
				}
				Quit = qQUIT;
				skipcont = 1;
				scommand = 0xFFFF;
				break;
			case GAMERELOAD:
				if ( using_SRAM )
				{
					Z_scripterrlog("Cannot Reload Game while reading or writing to SRAM. Aborting Reload. /n");
					break;
				}
				Quit = qRELOAD;
				skipcont = 1;
				scommand = 0xFFFF;
				break;
			case GAMESETCUSTOMCURSOR:
			{
				int32_t bmpptr = SH::read_stack(ri->sp + 4);
				int fx = SH::read_stack(ri->sp + 3) / 10000;
				int fy = SH::read_stack(ri->sp + 2) / 10000;
				bool recolor = SH::read_stack(ri->sp + 1)!=0;
				bool scale = SH::read_stack(ri->sp + 0)!=0;
				if(user_bitmap* b = checkBitmap(bmpptr,nullptr,true))
				{
					custom_mouse(b->u_bmp,fx,fy,recolor,scale);
				}
				break;
			}
			case CURRENTITEMID:
			{
				int ity = SH::read_stack(ri->sp + 1) / 10000;
				int flags = SH::read_stack(ri->sp + 0) / 10000;
				bool checkcost = flags&0x01;
				bool checkjinx = flags&0x02;
				bool check_bunny = flags&0x04;
				ri->d[rEXP1] = current_item_id(ity,checkcost,checkjinx,check_bunny) * 10000;
				break;
			}
			
			case GAMECONTINUE:
				if ( using_SRAM )
				{
					Z_scripterrlog("Cannot Continue Game while reading or writing to SRAM. Aborting Continue. /n");
					break;
				}
				reset_combo_animations();
				reset_combo_animations2();
			
				Quit = qCONT;
				skipcont = 1;
				//cont_game();
				scommand = 0xFFFF;
				break;
				
			case GAMESAVEQUIT:
				if ( using_SRAM )
				{
					Z_scripterrlog("Cannot Save Game while reading or writing to SRAM. Aborting Save. /n");
					break;
				}
				Quit = qSAVE;
				skipcont = 1;
				scommand =0xFFFF;
				break;
				
			case GAMESAVECONTINUE:
				Quit = qSAVECONT;
				skipcont = 1;
				scommand =0xFFFF;
				break;
				
			case SAVE:
				if ( using_SRAM )
				{
					Z_scripterrlog("Cannot Save Game while reading or writing to SRAM. Aborting Save. /n");
					break;
				}
				if(scriptCanSave)
				{
					save_game(false);
					scriptCanSave=false;
				}
				break;
				
			case SAVESCREEN:
				do_showsavescreen();
				break;
			
			case SHOWF6SCREEN:
				onTryQuit();
				break;
				
			case SAVEQUITSCREEN:
				save_game(false, 1);
				break;
				
				//Not Implemented
			case ELLIPSE2:
			case FLOODFILL:
				break;
				
			case SETCOLORB:
			case SETDEPTHB:
			case GETCOLORB:
			case GETDEPTHB:
				break;
				
			case ENQUEUER:
				do_enqueue(false);
				break;
				
			case ENQUEUEV:
				do_enqueue(true);
				break;
				
			case DEQUEUE:
				do_dequeue(false);
				break;
			
			//Visual Effects
			case WAVYIN:
				FFScript::do_wavyin();
				break;
			case WAVYOUT:
				FFScript::do_wavyout();
				break;
			case ZAPIN:
				FFScript::do_zapin();
				break;
			case ZAPOUT:
				FFScript::do_zapout();
				break;
			case OPENWIPE:
			{
				FFScript::do_openscreen();
				break;
			}
			case CLOSEWIPE:
			{
				FFScript::do_closescreen();
				break;
			}
			case OPENWIPESHAPE:
			{
				FFScript::do_openscreenshape();
				break;
			}
			case CLOSEWIPESHAPE:
			{
				FFScript::do_closescreenshape();
				break;
			}
			
			//Monochrome
			case GREYSCALEON:
				setMonochrome(true);
				break;
			case GREYSCALEOFF:
				setMonochrome(false);
				break;
			
			case TINT:
			{
				FFCore.Tint();
				break;
			}
			
			case CLEARTINT:
			{
				FFCore.clearTint();
				break;
			}
			
			case MONOHUE:
			{
				FFCore.gfxmonohue();
				break;
			}
			
			case SCREENDOSPAWN:
			{
				ri->d[rEXP1] = scriptloadenemies() ? 10000 : 0;
				break;
			}
			
			case SCRTRIGGERCOMBO:
			{
				int32_t lyr = get_register(sarg1) / 10000;
				int32_t pos = get_register(sarg2) / 10000;
				set_register(sarg1, do_trigger_combo(lyr,pos) ? 10000 : 0);
				break;
			}
			
			case SWITCHNPC:
			{
				byte effect = vbound(get_register(sarg1)/10000, 0, 255);
				set_register(sarg1,0);
				if(Hero.switchhookclk) break; //Already switching!
				if(GuyH::loadNPC(ri->guyref, "npc->Switch()") == SH::_NoError)
				{
					switching_object = guys.spr(GuyH::getNPCIndex(ri->guyref));
					hooked_combopos = -1;
					hooked_layerbits = 0;
					switching_object->switch_hooked = true;
					Hero.doSwitchHook(effect);
					set_register(sarg1,10000);
				}
				break;
			}
			
			case SWITCHITM:
			{
				byte effect = vbound(get_register(sarg1)/10000, 0, 255);
				set_register(sarg1,0);
				if(Hero.switchhookclk) break; //Already switching!
				if(ItemH::loadItem(ri->itemref, "item->Switch()") == SH::_NoError)
				{
					switching_object = items.spr(ItemH::getItemIndex(ri->itemref));
					hooked_combopos = -1;
					hooked_layerbits = 0;
					switching_object->switch_hooked = true;
					Hero.doSwitchHook(effect);
					set_register(sarg1,10000);
				}
				break;
			}
			
			case SWITCHLW:
			{
				byte effect = vbound(get_register(sarg1)/10000, 0, 255);
				set_register(sarg1,0);
				if(Hero.switchhookclk) break; //Already switching!
				if(LwpnH::loadWeapon(ri->lwpn, "lweapon->Switch()") == SH::_NoError)
				{
					switching_object = Lwpns.spr(LwpnH::getLWeaponIndex(ri->lwpn));
					hooked_combopos = -1;
					hooked_layerbits = 0;
					switching_object->switch_hooked = true;
					Hero.doSwitchHook(effect);
					set_register(sarg1,10000);
				}
				break;
			}
			
			case SWITCHEW:
			{
				byte effect = vbound(get_register(sarg1)/10000, 0, 255);
				set_register(sarg1,0);
				if(Hero.switchhookclk) break; //Already switching!
				if(EwpnH::loadWeapon(ri->ewpn, "eweapon->Switch()") == SH::_NoError)
				{
					switching_object = Ewpns.spr(EwpnH::getEWeaponIndex(ri->lwpn));
					hooked_combopos = -1;
					hooked_layerbits = 0;
					switching_object->switch_hooked = true;
					Hero.doSwitchHook(effect);
					set_register(sarg1,10000);
				}
				break;
			}
			
			case SWITCHCMB:
			{
				int32_t pos = get_register(sarg1)/10000;
				set_register(sarg1,0);
				if(Hero.switchhookclk) break; //Already switching!
				if(unsigned(pos) > 176)
					break;
				switching_object = NULL;
				hooked_combopos = pos;
				hooked_layerbits = 0;
				Hero.doSwitchHook(get_register(sarg2)/10000);
				if(!hooked_layerbits) //failed
					Hero.reset_hookshot();
				else set_register(sarg1,10000); //success return
				break;
			}
			
			case LINKWARPEXR:
			{
				FFCore.do_warp_ex(false);
				break;
			}
			
			case KILLPLAYER:
			{
				Hero.kill(get_register(sarg1));
				break;
			}
			
			case HEROMOVEXY:
			{
				zfix dx = zslongToFix(SH::read_stack(ri->sp + 4));
				zfix dy = zslongToFix(SH::read_stack(ri->sp + 3));
				bool kb = SH::read_stack(ri->sp + 2)!=0;
				bool ign_sv = SH::read_stack(ri->sp + 1)!=0;
				bool shove = SH::read_stack(ri->sp + 0)!=0;
				ri->d[rEXP1] = Hero.movexy(dx, dy, kb, ign_sv, shove) ? 10000 : 0;
				break;
			}
			case HEROCANMOVEXY:
			{
				zfix dx = zslongToFix(SH::read_stack(ri->sp + 4));
				zfix dy = zslongToFix(SH::read_stack(ri->sp + 3));
				bool kb = SH::read_stack(ri->sp + 2)!=0;
				bool ign_sv = SH::read_stack(ri->sp + 1)!=0;
				bool shove = SH::read_stack(ri->sp + 0)!=0;
				ri->d[rEXP1] = Hero.can_movexy(dx, dy, kb, ign_sv, shove) ? 10000 : 0;
				break;
			}
			case HEROMOVEATANGLE:
			{
				zfix degrees = zslongToFix(SH::read_stack(ri->sp + 4));
				zfix pxamnt = zslongToFix(SH::read_stack(ri->sp + 3));
				bool kb = SH::read_stack(ri->sp + 2)!=0;
				bool ign_sv = SH::read_stack(ri->sp + 1)!=0;
				bool shove = SH::read_stack(ri->sp + 0)!=0;
				ri->d[rEXP1] = Hero.moveAtAngle(degrees, pxamnt, kb, ign_sv, shove) ? 10000 : 0;
				break;
			}
			case HEROCANMOVEATANGLE:
			{
				zfix degrees = zslongToFix(SH::read_stack(ri->sp + 4));
				zfix pxamnt = zslongToFix(SH::read_stack(ri->sp + 3));
				bool kb = SH::read_stack(ri->sp + 2)!=0;
				bool ign_sv = SH::read_stack(ri->sp + 1)!=0;
				bool shove = SH::read_stack(ri->sp + 0)!=0;
				ri->d[rEXP1] = Hero.can_moveAtAngle(degrees, pxamnt, kb, ign_sv, shove) ? 10000 : 0;
				break;
			}
			case HEROMOVE:
			{
				int dir = SH::read_stack(ri->sp + 4)/10000;
				zfix pxamnt = zslongToFix(SH::read_stack(ri->sp + 3));
				bool kb = SH::read_stack(ri->sp + 2)!=0;
				bool ign_sv = SH::read_stack(ri->sp + 1)!=0;
				bool shove = SH::read_stack(ri->sp + 0)!=0;
				ri->d[rEXP1] = Hero.moveDir(dir, pxamnt, kb, ign_sv, shove) ? 10000 : 0;
				break;
			}
			case HEROCANMOVE:
			{
				int dir = SH::read_stack(ri->sp + 4)/10000;
				zfix pxamnt = zslongToFix(SH::read_stack(ri->sp + 3));
				bool kb = SH::read_stack(ri->sp + 2)!=0;
				bool ign_sv = SH::read_stack(ri->sp + 1)!=0;
				bool shove = SH::read_stack(ri->sp + 0)!=0;
				ri->d[rEXP1] = Hero.can_moveDir(dir, pxamnt, kb, ign_sv, shove) ? 10000 : 0;
				break;
			}
			case HEROLIFTRELEASE:
			{
				if(Hero.lift_wpn)
				{
					ri->d[rEXP1] = Hero.lift_wpn->getUID();
					Lwpns.add(Hero.lift_wpn);
					Hero.lift_wpn = nullptr;
				}
				else ri->d[rEXP1] = 0;
				break;
			}
			case HEROLIFTGRAB:
			{
				auto lwuid = SH::read_stack(ri->sp + 2);
				auto lifttime = SH::read_stack(ri->sp + 1)/10000;
				auto liftheight = zslongToFix(SH::read_stack(ri->sp + 0));
				if(weapon* wpn = checkLWpn(lwuid,"Hero->Lift()"))
				{
					Hero.lift(wpn, lifttime, liftheight);
					if(Lwpns.find(wpn) > -1)
						Lwpns.remove(wpn);
					if(type == ScriptType::Lwpn && lwuid == i)
						earlyretval = RUNSCRIPT_SELFREMOVE;
				}
				break;
			}
			case HEROISFLICKERFRAME:
				ri->d[rEXP1] = Hero.is_hitflickerframe() ? 10000 : 0;
				break;
			case LOADPORTAL:
			{
				auto val = get_register(sarg1)/10000;
				if(val != -1)
				{
					portal* prt = (portal*)portals.spr(val);
					if(prt)
						val = prt->getUID();
					else
					{
						Z_scripterrlog("Tried to load invalid portal index '%d'\n", val);
						val = 0;
					}
				}
				ri->portalref = ri->d[rEXP1] = val;
				break;
			}
			case CREATEPORTAL:
			{
				portal* p = new portal();
				if(portals.add(p))
					ri->portalref = ri->d[rEXP1] = p->getUID();
				else
				{
					ri->portalref = ri->d[rEXP1] = 0;
					Z_scripterrlog("Unable to create new portal! Limit reached!\n");
				}
				break;
			}
			case LOADSAVPORTAL:
			{
				auto val = get_register(sarg1)/10000;
				savedportal* prt = checkSavedPortal(val,"Game->LoadSavedPortal");
				ri->saveportalref = ri->d[rEXP1] = prt ? val : 0;
				break;
			}
			case CREATESAVPORTAL:
			{
				if(game->user_portals.size() >= MAX_SAVED_PORTALS)
				{
					ri->saveportalref = ri->d[rEXP1] = 0;
					Z_scripterrlog("Cannot create any more Saved Portals! Remove some first!\n");
					break;
				}
				savedportal& ref = game->user_portals.emplace_back();
				ri->saveportalref = ri->d[rEXP1] = ref.getUID();
				break;
			}
			case PORTALREMOVE:
			{
				if(portal* p = checkPortal(ri->portalref, "Remove", true))
				{
					if(p == &mirror_portal)
						p->clear();
					else
					{
						auto id = portals.find(p);
						if(id > -1)
							portals.del(id,true);
					}
				}
				break;
			}
			case PORTALUSESPRITE:
				do_portalusesprite();
				break;
			case SAVEDPORTALREMOVE:
			{
				if(savedportal* sp = checkSavedPortal(ri->saveportalref, "Remove", true))
				{
					if(sp == &(game->saved_mirror_portal))
						sp->clear();
					else
					{
						//ensure all pointers to the object are cleared before deleting
						portals.forEach([&](sprite& spr)
						{
							portal* tmp = (portal*)&spr;
							if(sp->getUID() == tmp->saved_data)
							{
								tmp->saved_data = 0;
							}
							return false;
						});
						//delete the savedportal object from the vector
						for(auto it = game->user_portals.begin();
							it != game->user_portals.end();)
						{
							savedportal& tmp = *it;
							if(sp == &tmp)
							{
								game->user_portals.erase(it);
								break;
							}
							else ++it;
						}
					}
				}
				break;
			}
			case SAVEDPORTALGENERATE:
			{
				auto retval = 0;
				if(savedportal* sp = checkSavedPortal(ri->saveportalref, "Generate"))
				{
					retval = getPortalFromSaved(sp);
					if(!retval)
					{
						if(portal* p = loadportal(*sp))
							if(portals.add(p))
								retval = p->getUID();
					}
				}
				ri->d[rEXP1] = retval;
				break;
			}
			
			case LINKEXPLODER:
			{
				int32_t mode = get_register(sarg1) / 10000;
				if ( (unsigned) mode > 2 ) 
				{
					Z_scripterrlog("Invalid mode (%d) passed to Player->Explode(int32_t mode)\n",mode);
				}
				else Hero.explode(mode);
				break;
			}
			case NPCEXPLODER:
			{
				
				int32_t mode = get_register(sarg1) / 10000;
				al_trace("Called npc->Explode(%d), for enemy index %u\n", mode, ri->guyref);
				if ( (unsigned) mode > 2 ) 
				{
					Z_scripterrlog("Invalid mode (%d) passed to npc->Explode(int32_t mode)\n",mode);
				}
				else
				{
					if(GuyH::loadNPC(ri->guyref, "npc->Explode()") == SH::_NoError)
					{
						al_trace("npc->Explode() is loading the npc into a pointer.\n");
						//enemy *e = (enemy*)guys.spr(ri->guyref);
						al_trace("npc->Explode() is calling enemy::explode.\n");
						//(enemy *) guys.explode(eid);
						//e->explode(mode);
						//enemy *en=GuyH::getNPC();
						//en->stop_bgsfx(GuyH::getNPCIndex(ri->guyref));
						guys.spr(GuyH::getNPCIndex(ri->guyref))->explode(mode);
					}
				}
				break;
			}
			
			case ITEMEXPLODER:
			{
				
				int32_t mode = get_register(sarg1) / 10000;
				al_trace("Called item->Explode(%d), for item index %u\n", mode, ri->itemref);
				if ( (unsigned) mode > 2 ) 
				{
					Z_scripterrlog("Invalid mode (%d) passed to item->Explode(int32_t mode)\n",mode);
				}
				else
				{
					if(ItemH::loadItem(ri->itemref, "item->Explode()") == SH::_NoError)
					{
						items.spr(ItemH::getItemIndex(ri->itemref))->explode(mode);
					}
				}
				break;
			}
			case LWEAPONEXPLODER:
			{
				
				int32_t mode = get_register(sarg1) / 10000;
				al_trace("Called lweapon->Explode(%d), for lweapon index %u\n", mode, ri->lwpn);
				if ( (unsigned) mode > 2 ) 
				{
					Z_scripterrlog("Invalid mode (%d) passed to lweapon->Explode(int32_t mode)\n",mode);
				}
				else
				{
					if(LwpnH::loadWeapon(ri->lwpn, "lweapon->Explode()") == SH::_NoError)
					{
						Lwpns.spr(LwpnH::getLWeaponIndex(ri->lwpn))->explode(mode);
					}
				}
				break;
			}
			case EWEAPONEXPLODER:
			{
				
				int32_t mode = get_register(sarg1) / 10000;
				al_trace("Called eweapon->Explode(%d), for eweapon index %u\n", mode, ri->ewpn);
				if ( (unsigned) mode > 2 ) 
				{
					Z_scripterrlog("Invalid mode (%d) passed to eweapon->Explode(int32_t mode)\n",mode);
				}
				else
				{
					if(EwpnH::loadWeapon(ri->ewpn, "eweapon->Explode()") == SH::_NoError)
					{
						Ewpns.spr(EwpnH::getEWeaponIndex(ri->lwpn))->explode(mode);
					}
				}
				break;
			}
				
			case BOTTLENAMEGET:
			{
				int32_t arrayptr = get_register(sarg1) / 10000;
				int32_t id = ri->bottletyperef-1;
				if(unsigned(id) > 63)
				{
					Z_scripterrlog("Invalid bottledata ID (%d) passed to bottledata->GetName().\n", id);
					break;
				}
				
				if(ArrayH::setArray(arrayptr, QMisc.bottle_types[id].name) == SH::_Overflow)
					Z_scripterrlog("Array supplied to 'bottledata->GetName()' not large enough\n");
				break;
			}
			case BOTTLENAMESET:
			{
				int32_t arrayptr = get_register(sarg1) / 10000;
				int32_t id = ri->bottletyperef-1;
				if(unsigned(id) > 63)
				{
					Z_scripterrlog("Invalid bottledata ID (%d) passed to bottledata->SetName().\n", id+1);
					break;
				}
				string name;
				ArrayH::getString(arrayptr, name, 31);
				strcpy(QMisc.bottle_types[id].name, name.c_str());
				break;
			}
			case BSHOPNAMEGET:
			{
				int32_t arrayptr = get_register(sarg1) / 10000;
				int32_t id = ri->bottleshopref-1;
				if(unsigned(id) > 255)
				{
					Z_scripterrlog("Invalid bottleshopdata ID (%d) passed to bottleshopdata->GetName().\n", id+1);
					break;
				}
				
				if(ArrayH::setArray(arrayptr, QMisc.bottle_shop_types[id].name) == SH::_Overflow)
					Z_scripterrlog("Array supplied to 'bottleshopdata->GetName()' not large enough\n");
				break;
			}
			case BSHOPNAMESET:
			{
				int32_t arrayptr = get_register(sarg1) / 10000;
				int32_t id = ri->bottleshopref;
				if(unsigned(id) > 255)
				{
					Z_scripterrlog("Invalid bottleshopdata ID (%d) passed to bottleshopdata->SetName().\n", id);
					break;
				}
				string name;
				ArrayH::getString(arrayptr, name, 31);
				strcpy(QMisc.bottle_shop_types[id].name, name.c_str());
				break;
			}
			
			case RUNITEMSCRIPT:
			{
				int32_t itemid = ri->idata;
				if(unsigned(itemid) > MAXITEMS) break;
				int32_t mode = get_register(sarg1) / 10000;
				// zprint("Trying to run the script on item: %d\n",itemid);
				// zprint("The script ID is: %d\n",itemsbuf[itemid].script);
				// zprint("Runitemscript mode is: %d\n", mode);
				auto& data = get_script_engine_data(ScriptType::Item, itemid);
				switch(mode)
				{
					case 0:
					{
						data.doscript = 4;
						break;
					}
					case 1:
					{
						if ( itemsbuf[itemid].script != 0 ) //&& !data.doscript )
						{
							if ( !data.doscript ) 
							{
								data.ref.Clear();
								data.doscript = 1;
								//ZScriptVersion::RunScript(ScriptType::Item, itemsbuf[itemid].script, itemid);
							}
							else
							{
								//Emily, clear the stack here, clear refinfo, and set up to run again on the next frame from the beginning.
							}
						}
						break;
					}
					case 2:
					default:
					{
						if ( itemsbuf[itemid].script != 0 ) //&& !data.doscript )
						{
							if (data.doscript != 2 )data.doscript = 2;
						}
						break;
					}
					/*
					case 0:
					{
						data.doscript = 0;
						break;
					}
					default:
					{
					
						if ( itemsbuf[itemid].script != 0 ) //&& !data.doscript )
						{
							//itemScriptData[itemid].Clear();
							//for ( int32_t q = 0; q < 1024; q++ ) item_stack[itemid][q] = 0;
							//ZScriptVersion::RunScript(ScriptType::Item, itemsbuf[itemid].script, itemid & 0xFFF);
							data.doscript = 2;
						}
						break;
					}
					*/
				}
				break;
			}
			
			//case NPCData
			
			case GETNPCDATATILE: FFScript::getNPCData_tile(); break;
			case GETNPCDATAEHEIGHT: FFScript::getNPCData_e_height(); break;
			case GETNPCDATAFLAGS: FFScript::getNPCData_flags(); break;
			case GETNPCDATAFLAGS2: FFScript::getNPCData_flags2(); break;
			case GETNPCDATAWIDTH: FFScript::getNPCData_flags2(); break;
			case GETNPCDATAHEIGHT: FFScript::getNPCData_flags2(); break;
			case GETNPCDATASTILE: FFScript::getNPCData_s_tile(); break;
			case GETNPCDATASWIDTH: FFScript::getNPCData_s_width(); break;
			case GETNPCDATASHEIGHT: FFScript::getNPCData_s_height(); break;
			case GETNPCDATAETILE: FFScript::getNPCData_e_tile(); break;
			case GETNPCDATAEWIDTH: FFScript::getNPCData_e_width(); break;
			case GETNPCDATAHP: FFScript::getNPCData_hp(); break;
			case GETNPCDATAFAMILY: FFScript::getNPCData_family(); break;
			case GETNPCDATACSET: FFScript::getNPCData_cset(); break;
			case GETNPCDATAANIM: FFScript::getNPCData_anim(); break;
			case GETNPCDATAEANIM: FFScript::getNPCData_e_anim(); break;
			case GETNPCDATAFRAMERATE: FFScript::getNPCData_frate(); break;
			case GETNPCDATAEFRAMERATE: FFScript::getNPCData_e_frate(); break;
			case GETNPCDATATOUCHDMG: FFScript::getNPCData_dp(); break;
			case GETNPCDATAWPNDAMAGE: FFScript::getNPCData_wdp(); break;
			case GETNPCDATAWEAPON: FFScript::getNPCData_wdp(); break;
			case GETNPCDATARANDOM: FFScript::getNPCData_rate(); break;
			case GETNPCDATAHALT: FFScript::getNPCData_hrate(); break;
			case GETNPCDATASTEP: FFScript::getNPCData_step(); break;
			case GETNPCDATAHOMING: FFScript::getNPCData_homing(); break;
			case GETNPCDATAHUNGER: FFScript::getNPCData_grumble(); break;
			case GETNPCDATADROPSET: FFScript::getNPCData_item_set(); break;
			case GETNPCDATABGSFX: FFScript::getNPCData_bgsfx(); break;
			case GETNPCDATADEATHSFX: FFScript::getNPCData_deadsfx(); break; 
			case GETNPCDATAXOFS: FFScript::getNPCData_xofs(); break;
			case GETNPCDATAYOFS: FFScript::getNPCData_yofs(); break;
			case GETNPCDATAZOFS: FFScript::getNPCData_zofs(); break;
			case GETNPCDATAHXOFS: FFScript::getNPCData_hxofs(); break;
			case GETNPCDATAHYOFS: FFScript::getNPCData_hyofs(); break;
			case GETNPCDATAHITWIDTH: FFScript::getNPCData_hxsz(); break;
			case GETNPCDATAHITHEIGHT: FFScript::getNPCData_hysz(); break;
			case GETNPCDATAHITZ: FFScript::getNPCData_hzsz(); break;
			case GETNPCDATATILEWIDTH: FFScript::getNPCData_txsz(); break;
			case GETNPCDATATILEHEIGHT: FFScript::getNPCData_tysz(); break;
			case GETNPCDATAWPNSPRITE: FFScript::getNPCData_wpnsprite(); break;
			//case GETNPCDATASCRIPTDEF: FFScript::getNPCData_scriptdefence(); break; //2.future cross-compat. 
			case GETNPCDATADEFENSE: FFScript::getNPCData_defense(); break; 
			case GETNPCDATASIZEFLAG: FFScript::getNPCData_SIZEflags(); break;
			case GETNPCDATAATTRIBUTE: FFScript::getNPCData_misc(); break;
			case GETNPCDATAHITSFX: FFScript::getNPCData_hitsfx(); break;
				
			case SETNPCDATAFLAGS: FFScript::setNPCData_flags(); break;
			case SETNPCDATAFLAGS2: FFScript::setNPCData_flags2(); break;
			case SETNPCDATAWIDTH: FFScript::setNPCData_width(); break;
			case SETNPCDATAHEIGHT: FFScript::setNPCData_height(); break;
			case SETNPCDATASTILE: FFScript::setNPCData_s_tile(); break;
			case SETNPCDATASWIDTH: FFScript::setNPCData_s_width(); break;
			case SETNPCDATASHEIGHT: FFScript::setNPCData_s_height(); break;
			case SETNPCDATAETILE: FFScript::setNPCData_e_tile(); break;
			case SETNPCDATAEWIDTH: FFScript::setNPCData_e_width(); break;
			case SETNPCDATAHP: FFScript::setNPCData_hp(); break;
			case SETNPCDATAFAMILY: FFScript::setNPCData_family(); break;
			case SETNPCDATACSET: FFScript::setNPCData_cset(); break;
			case SETNPCDATAANIM: FFScript::setNPCData_anim(); break;
			case SETNPCDATAEANIM: FFScript::setNPCData_e_anim(); break;
			case SETNPCDATAFRAMERATE: FFScript::setNPCData_frate(); break;
			case SETNPCDATAEFRAMERATE: FFScript::setNPCData_e_frate(); break;
			case SETNPCDATATOUCHDMG: FFScript::setNPCData_dp(); break;
			case SETNPCDATAWPNDAMAGE: FFScript::setNPCData_wdp(); break;
			case SETNPCDATAWEAPON: FFScript::setNPCData_weapon(); break;
			case SETNPCDATARANDOM: FFScript::setNPCData_rate(); break;
			case SETNPCDATAHALT: FFScript::setNPCData_hrate(); break;
			case SETNPCDATASTEP: FFScript::setNPCData_step(); break;
			case SETNPCDATAHOMING: FFScript::setNPCData_homing(); break;
			case SETNPCDATAHUNGER: FFScript::setNPCData_grumble(); break;
			case SETNPCDATADROPSET: FFScript::setNPCData_item_set(); break;
			case SETNPCDATABGSFX: FFScript::setNPCData_bgsfx(); break;
			case SETNPCDATADEATHSFX: FFScript::setNPCData_hitsfx(); break;
			case SETNPCDATAXOFS: FFScript::setNPCData_xofs(); break;
			case SETNPCDATAYOFS: FFScript::setNPCData_yofs(); break;
			case SETNPCDATAZOFS: FFScript::setNPCData_zofs(); break;
			case SETNPCDATAHXOFS: FFScript::setNPCData_hxofs(); break;
			case SETNPCDATAHYOFS: FFScript::setNPCData_hyofs(); break;
			case SETNPCDATAHITWIDTH: FFScript::setNPCData_hxsz(); break;
			case SETNPCDATAHITHEIGHT: FFScript::setNPCData_hysz(); break;
			case SETNPCDATAHITZ: FFScript::setNPCData_hzsz(); break;
			case SETNPCDATATILEWIDTH: FFScript::setNPCData_txsz(); break;
			case SETNPCDATATILEHEIGHT: FFScript::setNPCData_tysz(); break;
			case SETNPCDATAWPNSPRITE: FFScript::setNPCData_wpnsprite(); break;
			case SETNPCDATAHITSFX: FFScript::setNPCData_hitsfx(); break;
			case SETNPCDATATILE: FFScript::setNPCData_tile(); break;
			case SETNPCDATAEHEIGHT: FFScript::setNPCData_e_height(); break;
			
			
			
			

				
			//case SETNPCDATASCRIPTDEF  : FFScript::setNPCData_scriptdefence(); break;
			case SETNPCDATADEFENSE : FFScript::setNPCData_defense(ri->d[rEXP1]); break;
			case SETNPCDATASIZEFLAG : FFScript::setNPCData_SIZEflags(ri->d[rEXP1]); break;
			case SETNPCDATAATTRIBUTE : FFScript::setNPCData_misc(ri->d[rEXP1]); break;
			
			
			//ComboData
			
			case GCDBLOCKENEM:  FFScript::getComboData_block_enemies(); break;
			case GCDBLOCKHOLE:  FFScript::getComboData_block_hole(); break;
			case GCDBLOCKTRIG:  FFScript::getComboData_block_trigger(); break;
			case GCDCONVEYSPDX:  FFScript::getComboData_conveyor_x_speed(); break;
			case GCDCONVEYSPDY:  FFScript::getComboData_conveyor_y_speed(); break;
			case GCDCREATEENEM:  FFScript::getComboData_create_enemy(); break;
			case GCDCREATEENEMWH:  FFScript::getComboData_create_enemy_when(); break;
			case GCDCREATEENEMCH:  FFScript::getComboData_create_enemy_change(); break;
			case GCDDIRCHTYPE:  FFScript::getComboData_directional_change_type(); break;
			case GCDDISTCHTILES:  FFScript::getComboData_distance_change_tiles(); break;
			case GCDDIVEITEM:  FFScript::getComboData_dive_item(); break;
			case GCDDOCK:  FFScript::getComboData_dock(); break;
			case GCDFAIRY:  FFScript::getComboData_fairy(); break;
			case GCDFFCOMBOATTRIB:  FFScript::getComboData_ff_combo_attr_change(); break;
			case GCDFOOTDECOTILE:  FFScript::getComboData_foot_decorations_tile(); break;
			case GCDFOOTDECOTYPE:  FFScript::getComboData_foot_decorations_type(); break;
			case GCDHOOKSHOTGRAB:  FFScript::getComboData_hookshot_grab_point(); break;
			case GCDLADDERPASS:  FFScript::getComboData_ladder_pass(); break;
			case GCDLOCKBLOCKTYPE:  FFScript::getComboData_lock_block_type(); break;
			case GCDLOCKBLOCKCHANGE:  FFScript::getComboData_lock_block_change(); break;
			case GCDMAGICMIRRORTYPE:  FFScript::getComboData_magic_mirror_type(); break;
			case GCDMODIFYHPAMOUNT:  FFScript::getComboData_modify_hp_amount(); break;
			case GCDMODIFYHPDELAY:  FFScript::getComboData_modify_hp_delay(); break;
			case GCDMODIFYHPTYPE:  FFScript::getComboData_modify_hp_type(); break;
			case GCDMODIFYMPAMOUNT:  FFScript::getComboData_modify_mp_amount(); break;
			case GCDMODIFYMPDELAY:  FFScript::getComboData_modify_mp_delay(); break;
			case GCDMODIFYMPTYPE:  FFScript::getComboData_modify_mp_type(); break;
			case GCDNOPUSHBLOCKS:  FFScript::getComboData_no_push_blocks(); break;
			case GCDOVERHEAD:  FFScript::getComboData_overhead(); break;
			case GCDPLACEENEMY:  FFScript::getComboData_place_enemy(); break;
			case GCDPUSHDIR:  FFScript::getComboData_push_direction(); break;
			case GCDPUSHWEIGHT:  FFScript::getComboData_push_weight(); break;
			case GCDPUSHWAIT:  FFScript::getComboData_push_wait(); break;
			case GCDPUSHED:  FFScript::getComboData_pushed(); break;
			case GCDRAFT:  FFScript::getComboData_raft(); break;
			case GCDRESETROOM:  FFScript::getComboData_reset_room(); break;
			case GCDSAVEPOINT:  FFScript::getComboData_save_point_type(); break;
			case GCDSCREENFREEZE:  FFScript::getComboData_screen_freeze_type(); break;
			case GCDSECRETCOMBO:  FFScript::getComboData_secret_combo(); break;
			case GCDSINGULAR:  FFScript::getComboData_singular(); break;
			case GCDSLOWMOVE:  FFScript::getComboData_slow_movement(); break;
			case GCDSTATUE:  FFScript::getComboData_statue_type(); break;
			case GCDSTEPTYPE:  FFScript::getComboData_step_type(); break;
			case GCDSTEPCHANGETO:  FFScript::getComboData_step_change_to(); break;
			case GCDSTRIKEREMNANTS:  FFScript::getComboData_strike_remnants(); break;
			case GCDSTRIKEREMNANTSTYPE:  FFScript::getComboData_strike_remnants_type(); break;
			case GCDSTRIKECHANGE:  FFScript::getComboData_strike_change(); break;
			case GCDSTRIKECHANGEITEM:  FFScript::getComboData_strike_item(); break;
			case GCDTOUCHITEM:  FFScript::getComboData_touch_item(); break;
			case GCDTOUCHSTAIRS:  FFScript::getComboData_touch_stairs(); break;
			case GCDTRIGGERTYPE:  FFScript::getComboData_trigger_type(); break;
			case GCDTRIGGERSENS:  FFScript::getComboData_trigger_sensitive(); break;
			case GCDWARPTYPE:  FFScript::getComboData_warp_type(); break;
			case GCDWARPSENS:  FFScript::getComboData_warp_sensitive(); break;
			case GCDWARPDIRECT:  FFScript::getComboData_warp_direct(); break;
			case GCDWARPLOCATION:  FFScript::getComboData_warp_location(); break;
			case GCDWATER:  FFScript::getComboData_water(); break;
			case GCDWHISTLE:  FFScript::getComboData_whistle(); break;
			case GCDWINGAME:  FFScript::getComboData_win_game(); break;
			case GCDBLOCKWEAPLVL:  FFScript::getComboData_block_weapon_lvl(); break;
			case GCDTILE:  FFScript::getComboData_tile(); break;
			case GCDFLIP:  FFScript::getComboData_flip(); break;
			case GCDWALK:  FFScript::getComboData_walk(); break;
			case GCDTYPE:  FFScript::getComboData_type(); break;
			case GCDCSETS:  FFScript::getComboData_csets(); break;
			case GCDFOO:  break;
			case GCDFRAMES:  FFScript::getComboData_frames(); break;
			case GCDSPEED:  FFScript::getComboData_speed(); break;
			case GCDNEXTCOMBO:  FFScript::getComboData_nextcombo(); break;
			case GCDNEXTCSET:  FFScript::getComboData_nextcset(); break;
			case GCDFLAG:  FFScript::getComboData_flag(); break;
			case GCDSKIPANIM:  FFScript::getComboData_skipanim(); break;
			case GCDNEXTTIMER:  FFScript::getComboData_nexttimer(); break;
			case GCDSKIPANIMY:  FFScript::getComboData_skipanimy(); break;
			case GCDANIMFLAGS:  FFScript::getComboData_animflags(); break;
			case GCDBLOCKWEAPON:  FFScript::getComboData_block_weapon(); break;
			case GCDEXPANSION:  FFScript::getComboData_expansion(); break;
			case GCDSTRIKEWEAPONS:  FFScript::getComboData_strike_weapons(); break;
			case SCDBLOCKENEM:  FFScript::setComboData_block_enemies(); break;
			case SCDBLOCKHOLE:  FFScript::setComboData_block_hole(); break;
			case SCDBLOCKTRIG:  FFScript::setComboData_block_trigger(); break;
			case SCDCONVEYSPDX:  FFScript::setComboData_conveyor_x_speed(); break;
			case SCDCONVEYSPDY:  FFScript::setComboData_conveyor_y_speed(); break;
			case SCDCREATEENEM:  FFScript::setComboData_create_enemy(); break;
			case SCDCREATEENEMWH:  FFScript::setComboData_create_enemy_when(); break;
			case SCDCREATEENEMCH:  FFScript::setComboData_create_enemy_change(); break;
			case SCDDIRCHTYPE:  FFScript::setComboData_directional_change_type(); break;
			case SCDDISTCHTILES:  FFScript::setComboData_distance_change_tiles(); break;
			case SCDDIVEITEM:  FFScript::setComboData_dive_item(); break;
			case SCDDOCK:  FFScript::setComboData_dock(); break;
			case SCDFAIRY:  FFScript::setComboData_fairy(); break;
			case SCDFFCOMBOATTRIB:  FFScript::setComboData_ff_combo_attr_change(); break;
			case SCDFOOTDECOTILE:  FFScript::setComboData_foot_decorations_tile(); break;
			case SCDFOOTDECOTYPE:  FFScript::setComboData_foot_decorations_type(); break;
			case SCDHOOKSHOTGRAB:  FFScript::setComboData_hookshot_grab_point(); break;
			case SCDLADDERPASS:  FFScript::setComboData_ladder_pass(); break;
			case SCDLOCKBLOCKTYPE:  FFScript::setComboData_lock_block_type(); break;
			case SCDLOCKBLOCKCHANGE:  FFScript::setComboData_lock_block_change(); break;
			case SCDMAGICMIRRORTYPE:  FFScript::setComboData_magic_mirror_type(); break;
			case SCDMODIFYHPAMOUNT:  FFScript::setComboData_modify_hp_amount(); break;
			case SCDMODIFYHPDELAY:  FFScript::setComboData_modify_hp_delay(); break;
			case SCDMODIFYHPTYPE:  FFScript::setComboData_modify_hp_type(); break;
			case SCDMODIFYMPAMOUNT:  FFScript::setComboData_modify_mp_amount(); break;
			case SCDMODIFYMPDELAY:  FFScript::setComboData_modify_mp_delay(); break;
			case SCDMODIFYMPTYPE:  FFScript::setComboData_modify_mp_type(); break;
			case SCDNOPUSHBLOCKS:  FFScript::setComboData_no_push_blocks(); break;
			case SCDOVERHEAD:  FFScript::setComboData_overhead(); break;
			case SCDPLACEENEMY:  FFScript::setComboData_place_enemy(); break;
			case SCDPUSHDIR:  FFScript::setComboData_push_direction(); break;
			case SCDPUSHWEIGHT:  FFScript::setComboData_push_weight(); break;
			case SCDPUSHWAIT:  FFScript::setComboData_push_wait(); break;
			case SCDPUSHED:  FFScript::setComboData_pushed(); break;
			case SCDRAFT:  FFScript::setComboData_raft(); break;
			case SCDRESETROOM:  FFScript::setComboData_reset_room(); break;
			case SCDSAVEPOINT:  FFScript::setComboData_save_point_type(); break;
			case SCDSCREENFREEZE:  FFScript::setComboData_screen_freeze_type(); break;
			case SCDSECRETCOMBO:  FFScript::setComboData_secret_combo(); break;
			case SCDSINGULAR:  FFScript::setComboData_singular(); break;
			case SCDSLOWMOVE:  FFScript::setComboData_slow_movement(); break;
			case SCDSTATUE:  FFScript::setComboData_statue_type(); break;
			case SCDSTEPTYPE:  FFScript::setComboData_step_type(); break;
			case SCDSTEPCHANGETO:  FFScript::setComboData_step_change_to(); break;
			case SCDSTRIKEREMNANTS:  FFScript::setComboData_strike_remnants(); break;
			case SCDSTRIKEREMNANTSTYPE:  FFScript::setComboData_strike_remnants_type(); break;
			case SCDSTRIKECHANGE:  FFScript::setComboData_strike_change(); break;
			case SCDSTRIKECHANGEITEM:  FFScript::setComboData_strike_item(); break;
			case SCDTOUCHITEM:  FFScript::setComboData_touch_item(); break;
			case SCDTOUCHSTAIRS:  FFScript::setComboData_touch_stairs(); break;
			case SCDTRIGGERTYPE:  FFScript::setComboData_trigger_type(); break;
			case SCDTRIGGERSENS:  FFScript::setComboData_trigger_sensitive(); break;
			case SCDWARPTYPE:  FFScript::setComboData_warp_type(); break;
			case SCDWARPSENS:  FFScript::setComboData_warp_sensitive(); break;
			case SCDWARPDIRECT:  FFScript::setComboData_warp_direct(); break;
			case SCDWARPLOCATION:  FFScript::setComboData_warp_location(); break;
			case SCDWATER:  FFScript::setComboData_water(); break;
			case SCDWHISTLE:  FFScript::setComboData_whistle(); break;
			case SCDWINGAME:  FFScript::setComboData_win_game(); break;
			case SCDBLOCKWEAPLVL:  FFScript::setComboData_block_weapon_lvl(); break;
			case SCDTILE:  FFScript::setComboData_tile(); break;
			case SCDFLIP:  FFScript::setComboData_flip(); break;
			case SCDWALK:  FFScript::setComboData_walk(); break;
			case SCDTYPE:  FFScript::setComboData_type(); break;
			case SCDCSETS:  FFScript::setComboData_csets(); break;
			case SCDFOO:  break;
			case SCDFRAMES:  FFScript::setComboData_frames(); break;
			case SCDSPEED:  FFScript::setComboData_speed(); break;
			case SCDNEXTCOMBO:  FFScript::setComboData_nextcombo(); break;
			case SCDNEXTCSET:  FFScript::setComboData_nextcset(); break;
			case SCDFLAG:  FFScript::setComboData_flag(); break;
			case SCDSKIPANIM:  FFScript::setComboData_skipanim(); break;
			case SCDNEXTTIMER:  FFScript::setComboData_nexttimer(); break;
			case SCDSKIPANIMY:  FFScript::setComboData_skipanimy(); break;
			case SCDANIMFLAGS:  FFScript::setComboData_animflags(); break;
			case SCDBLOCKWEAPON:  FFScript::setComboData_block_weapon(ri->d[rEXP1]); break;
			case SCDEXPANSION:  FFScript::setComboData_expansion(ri->d[rEXP1]); break;
			case SCDSTRIKEWEAPONS:  FFScript::setComboData_strike_weapons(ri->d[rEXP1]); break;

			//SpriteData
			
			//case GETSPRITEDATASTRING: 
			case GETSPRITEDATATILE: FFScript::getSpriteDataTile(); break;
			case GETSPRITEDATAMISC: FFScript::getSpriteDataCSets(); break;
			case GETSPRITEDATACGETS: FFScript::getSpriteDataCSets(); break;
			case GETSPRITEDATAFRAMES: FFScript::getSpriteDataFrames(); break;
			case GETSPRITEDATASPEED: FFScript::getSpriteDataSpeed(); break;
			case GETSPRITEDATATYPE: FFScript::getSpriteDataType(); break;

			//case SETSPRITEDATASTRING:
			case SETSPRITEDATATILE: FFScript::setSpriteDataTile(); break;
			case SETSPRITEDATAMISC: FFScript::setSpriteDataMisc(); break;
			case SETSPRITEDATACSETS: FFScript::setSpriteDataCSets(); break;
			case SETSPRITEDATAFRAMES: FFScript::setSpriteDataFrames(); break;
			case SETSPRITEDATASPEED: FFScript::setSpriteDataSpeed(); break;
			case SETSPRITEDATATYPE: FFScript::setSpriteDataType(); break;
			
			//Game over Screen
			case SETCONTINUESCREEN: FFScript::FFChangeSubscreenText(); break;
			case SETCONTINUESTRING: FFScript::FFSetSaveScreenSetting(); break;
			
			//new npc functions for npc scripts
			
			case NPCDEAD:
				FFCore.do_isdeadnpc();
				break;
			
			case NPCCANSLIDE:
				FFCore.do_canslidenpc();
				break;
			
			case NPCSLIDE:
				FFCore.do_slidenpc();
				break;
			
			case NPCKICKBUCKET:
			{
				FFScript::deallocateAllScriptOwned(ScriptType::NPC, ri->guyref);
				if(type == ScriptType::NPC && ri->guyref == i)
				{
					FFCore.do_npc_delete();
					return RUNSCRIPT_SELFDELETE;
				}
				FFCore.do_npc_delete();
				break;
			}
			case LWPNDEL:
			{
				FFScript::deallocateAllScriptOwned(ScriptType::Lwpn, ri->lwpn);
				if(type == ScriptType::Lwpn && ri->lwpn == i)
				{
					FFCore.do_lweapon_delete();
					return RUNSCRIPT_SELFDELETE;
				}
				FFCore.do_lweapon_delete();
				break;
			}
			case EWPNDEL:
			{
				FFScript::deallocateAllScriptOwned(ScriptType::Ewpn, ri->ewpn);
				if(type == ScriptType::Ewpn && ri->ewpn == i)
				{
					FFCore.do_eweapon_delete();
					return RUNSCRIPT_SELFDELETE;
				}
				FFCore.do_eweapon_delete();
				break;
			}
			case ITEMDEL:
			{
				FFScript::deallocateAllScriptOwned(ScriptType::ItemSprite, ri->itemref);
				if(type == ScriptType::ItemSprite && ri->itemref == i)
				{
					if(FFCore.do_itemsprite_delete())
						return RUNSCRIPT_SELFDELETE;
				}
				else FFCore.do_itemsprite_delete();
				break;
			}
			
			case NPCSTOPBGSFX:
				FFCore.do_npc_stopbgsfx();
				break;
			
			case NPCATTACK:
				FFCore.do_npcattack();
				break;
			
			case NPCNEWDIR:
				FFCore.do_npc_newdir();
				break;
			
			case NPCCONSTWALK:
				FFCore.do_npc_constwalk();
				break;
			
			
			
			case NPCVARWALK:
				FFCore.do_npc_varwalk();
				break;
			
			case NPCVARWALK8:
				FFCore.do_npc_varwalk8();
				break;
			
			case NPCCONSTWALK8:
				FFCore.do_npc_constwalk8();
				break;
			
			case NPCHALTWALK:
				FFCore.do_npc_haltwalk();
				break;
			
			case NPCHALTWALK8:
				FFCore.do_npc_haltwalk8();
				break;
			
			case NPCFLOATWALK:
				FFCore.do_npc_floatwalk();
				break;
			
			case NPCFIREBREATH:
				FFCore.do_npc_breathefire();
				break;
			
			case NPCNEWDIR8:
				FFCore.do_npc_newdir8();
				break;
			
			case NPCLINKINRANGE:
				FFCore.do_npc_hero_in_range(false);
				break;
			
			case NPCCANMOVE:
				FFCore.do_npc_canmove(false);
				break;
			
			case NPCHITWITH:
				FFCore.do_npc_simulate_hit(false);
				break;
				
			case NPCKNOCKBACK:
				FFCore.do_npc_knockback(false);
				break;
			
			case NPCGETINITDLABEL:
				FFCore.get_npcdata_initd_label(false);
				break;
			
			case NPCADD:
				FFCore.do_npc_add(false);
				break;
			
			case NPCMOVEPAUSED:
			{
				ri->d[rEXP1] = 0;
				if(GuyH::loadNPC(ri->guyref, "npc->MovePaused()") == SH::_NoError)
				{
					ri->d[rEXP1] = GuyH::getNPC()->is_move_paused() ? 10000 : 0;
				}
				break;
			}
			case NPCMOVE:
			{
				int32_t dir = ri->d[rINDEX] / 10000;
				zfix px = zslongToFix(ri->d[rEXP2]);
				int32_t special = ri->d[rEXP1] / 10000;
				ri->d[rEXP1] = 0;
				if(GuyH::loadNPC(ri->guyref, "npc->Move()") == SH::_NoError)
				{
					ri->d[rEXP1] = GuyH::getNPC()->moveDir(dir, px, special) ? 10000 : 0;
				}
				break;
			}
			case NPCMOVEANGLE:
			{
				zfix degrees = zslongToFix(ri->d[rINDEX]);
				zfix px = zslongToFix(ri->d[rEXP2]);
				int32_t special = ri->d[rEXP1] / 10000;
				ri->d[rEXP1] = 0;
				if(GuyH::loadNPC(ri->guyref, "npc->MoveAtAngle()") == SH::_NoError)
				{
					ri->d[rEXP1] = GuyH::getNPC()->moveAtAngle(degrees, px, special) ? 10000 : 0;
				}
				break;
			}
			case NPCMOVEXY:
			{
				zfix dx = zslongToFix(ri->d[rINDEX]);
				zfix dy = zslongToFix(ri->d[rEXP2]);
				int32_t special = ri->d[rEXP1] / 10000;
				ri->d[rEXP1] = 0;
				if(GuyH::loadNPC(ri->guyref, "npc->MoveXY()") == SH::_NoError)
				{
					ri->d[rEXP1] = GuyH::getNPC()->movexy(dx, dy, special) ? 10000 : 00;
				}
				break;
			}
			case NPCCANMOVEDIR:
			{
				int32_t dir = ri->d[rINDEX] / 10000;
				zfix px = zslongToFix(ri->d[rEXP2]);
				int32_t special = ri->d[rEXP1] / 10000;
				ri->d[rEXP1] = 0;
				if(GuyH::loadNPC(ri->guyref, "npc->CanMove()") == SH::_NoError)
				{
					ri->d[rEXP1] = GuyH::getNPC()->can_moveDir(dir, px, special) ? 10000 : 0;
				}
				break;
			}
			case NPCCANMOVEANGLE:
			{
				zfix degrees = zslongToFix(ri->d[rINDEX]);
				zfix px = zslongToFix(ri->d[rEXP2]);
				int32_t special = ri->d[rEXP1] / 10000;
				ri->d[rEXP1] = 0;
				if(GuyH::loadNPC(ri->guyref, "npc->CanMoveAtAngle()") == SH::_NoError)
				{
					ri->d[rEXP1] = GuyH::getNPC()->can_moveAtAngle(degrees, px, special) ? 10000 : 0;
				}
				break;
			}
			case NPCCANMOVEXY:
			{
				zfix dx = zslongToFix(ri->d[rINDEX]);
				zfix dy = zslongToFix(ri->d[rEXP2]);
				int32_t special = ri->d[rEXP1] / 10000;
				ri->d[rEXP1] = 0;
				if(GuyH::loadNPC(ri->guyref, "npc->CanMoveXY()") == SH::_NoError)
				{
					ri->d[rEXP1] = GuyH::getNPC()->can_movexy(dx, dy, special) ? 10000 : 0;
				}
				break;
			}
			case NPCCANPLACE:
			{
				ri->guyref = SH::read_stack(ri->sp + 6);
				ri->d[rEXP1] = 0;
				if(GuyH::loadNPC(ri->guyref, "npc->CanPlace()") == SH::_NoError)
				{
					zfix nx = zslongToFix(SH::read_stack(ri->sp + 5));
					zfix ny = zslongToFix(SH::read_stack(ri->sp + 4));
					int special = SH::read_stack(ri->sp + 3) / 10000;
					bool kb = SH::read_stack(ri->sp + 2)!=0;
					int nw = SH::read_stack(ri->sp + 1) / 10000;
					int nh = SH::read_stack(ri->sp + 0) / 10000;
					ri->d[rEXP1] = GuyH::getNPC()->scr_canplace(nx, ny, special, kb, nw, nh) ? 10000 : 0;
				}
				break;
			}
			case NPCISFLICKERFRAME:
			{
				ri->d[rEXP1] = 0;
				if (GuyH::loadNPC(ri->guyref, "npc->isFlickerFrame()") == SH::_NoError)
				{
					ri->d[rEXP1] = GuyH::getNPC()->is_hitflickerframe(get_qr(qr_OLDSPRITEDRAWS)) ? 10000 : 0;
				}
				break;
			}
			
			case PLAYENHMUSICEX:
				// DEPRECATED
				do_enh_music(false);
				break;
				
			case GETENHMUSICPOS:
				FFCore.do_get_music_position();
				break;
				
			case SETENHMUSICPOS:
				FFCore.do_set_music_position(false);
				break;
				
			case SETENHMUSICSPEED:
				FFCore.do_set_music_speed(false);
				break;

			case GETENHMUSICLEN:
				FFCore.do_get_music_length();
				break;

			case SETENHMUSICLOOP:
				FFCore.do_set_music_loop();
				break;

			case ENHCROSSFADE:
				do_enh_music_crossfade();
				break;
			
			case DIREXISTS:
				FFCore.do_checkdir(true);
				break;
			
			case FILEEXISTS:
				FFCore.do_checkdir(false);
				break;
			
			case FILESYSREMOVE:
				FFCore.do_fs_remove();
				break;
			
			case TOBYTE:
				do_tobyte();
				break;
			case TOWORD:
				do_toword();
				break;
			case TOSHORT: do_toshort(); break;
			case TOSIGNEDBYTE: do_tosignedbyte(); break;
			case TOINTEGER: do_tointeger(); break;
			case CEILING: do_ceiling(); break;
			case FLOOR: do_floor(); break;
			case TRUNCATE: do_trunc(); break;
			case ROUND: do_round(); break;
			case ROUNDAWAY: do_roundaway(); break;
			
			case FILECLOSE:
			{
				FFCore.do_fclose();
				break;
			}
			case FILEFREE:
			{
				FFCore.do_deallocate_file();
				break;
			}
			case FILEOWN:
			{
				user_file* f = checkFile(ri->fileref, "Own()", false);
				if(f) own_script_object(f, type, i);
				break;
			}
			case FILEISALLOCATED:
			{
				FFCore.do_file_isallocated();
				break;
			}
			case FILEISVALID:
			{
				FFCore.do_file_isvalid();
				break;
			}
			case FILEALLOCATE:
			{
				FFCore.do_allocate_file();
				break;
			}
			case FILEFLUSH:
			{
				FFCore.do_fflush();
				break;
			}
			case FILEREMOVE:
			{
				FFCore.do_fremove();
				break;
			}
			case FILEGETCHAR:
			{
				FFCore.do_file_getchar();
				break;
			}
			case FILEREWIND:
			{
				FFCore.do_file_rewind();
				break;
			}
			case FILECLEARERR:
			{
				FFCore.do_file_clearerr();
				break;
			}
			
			case FILEOPEN:
			{
				FFCore.do_fopen(false, "rb+");
				break;
			}
			case FILECREATE:
			{
				FFCore.do_fopen(false, "wb+");
				break;
			}
			case FILEOPENMODE:
			{
				int32_t arrayptr = get_register(sarg2) / 10000;
				string mode;
				ArrayH::getString(arrayptr, mode, 16);
				FFCore.do_fopen(false, mode.c_str());
				break;
			}
			case FILEREADSTR:
			{
				FFCore.do_file_readstring();
				break;
			}
			case FILEWRITESTR:
			{
				FFCore.do_file_writestring();
				break;
			}
			case FILEPUTCHAR:
			{
				FFCore.do_file_putchar();
				break;
			}
			case FILEUNGETCHAR:
			{
				FFCore.do_file_ungetchar();
				break;
			}
			
			case FILEREADCHARS:
			{
				FFCore.do_file_readchars();
				break;
			}
			case FILEREADBYTES:
			{
				FFCore.do_file_readbytes();
				break;
			}
			case FILEREADINTS:
			{
				FFCore.do_file_readints();
				break;
			}
			case FILEWRITECHARS:
			{
				FFCore.do_file_writechars();
				break;
			}
			case FILEWRITEBYTES:
			{
				FFCore.do_file_writebytes();
				break;
			}
			case FILEWRITEINTS:
			{
				FFCore.do_file_writeints();
				break;
			}
			case FILESEEK:
			{
				FFCore.do_file_seek();
				break;
			}
			case FILEGETERROR:
			{
				FFCore.do_file_geterr();
				break;
			}
			//Directory
			case DIRECTORYGET:
			{
				FFCore.do_directory_get();
				break;
			}
			case DIRECTORYRELOAD:
			{
				FFCore.do_directory_reload();
				break;
			}
			case DIRECTORYFREE:
			{
				FFCore.do_directory_free();
				break;
			}
			case DIRECTORYOWN:
			{
				if(user_dir* dr = checkDir(ri->directoryref, "Own()"))
				{
					own_script_object(dr, type, i);
				}
				break;
			}
			//Stack
			case STACKFREE:
			{
				if(user_stack* st = checkStack(ri->stackref, "Free()", true))
				{
					free_script_object(st->id);
				}
				break;
			}
			case STACKOWN:
			{
				if(user_stack* st = checkStack(ri->stackref, "Own()"))
				{
					own_script_object(st, type, i);
				}
				break;
			}
			case STACKCLEAR:
			{
				if(user_stack* st = checkStack(ri->stackref, "Clear()"))
				{
					st->clearStack();
				}
				break;
			}
			case STACKGET:
			{
				if(user_stack* st = checkStack(ri->stackref, "Get()", true))
				{
					int32_t indx = get_register(sarg1); //NOT /10000
					set_register(sarg1, st->get(indx)); //NOT *10000
				}
				else set_register(sarg1, 0L);
				break;
			}
			case STACKSET:
			{
				if(user_stack* st = checkStack(ri->stackref, "Set()", true))
				{
					int32_t indx = get_register(sarg1); //NOT /10000
					int32_t val = get_register(sarg2); //NOT /10000
					st->set(indx, val); //NOT *10000
				}
				break;
			}
			case STACKPOPBACK:
			{
				if(user_stack* st = checkStack(ri->stackref, "PopBack()", true))
				{
					set_register(sarg1, st->pop_back()); //NOT *10000
				}
				else set_register(sarg1, 0L);
				break;
			}
			case STACKPOPFRONT:
			{
				if(user_stack* st = checkStack(ri->stackref, "PopFront()", true))
				{
					set_register(sarg1, st->pop_front()); //NOT *10000
				}
				else set_register(sarg1, 0L);
				break;
			}
			case STACKPEEKBACK:
			{
				if(user_stack* st = checkStack(ri->stackref, "PeekBack()", true))
				{
					set_register(sarg1, st->peek_back()); //NOT *10000
				}
				else set_register(sarg1, 0L);
				break;
			}
			case STACKPEEKFRONT:
			{
				if(user_stack* st = checkStack(ri->stackref, "PeekFront()", true))
				{
					set_register(sarg1, st->peek_front()); //NOT *10000
				}
				else set_register(sarg1, 0L);
				break;
			}
			case STACKPUSHBACK:
			{
				if(user_stack* st = checkStack(ri->stackref, "PushBack()", true))
				{
					int32_t val = get_register(sarg1); //NOT /10000
					st->push_back(val);
				}
				break;
			}
			case STACKPUSHFRONT:
			{
				if(user_stack* st = checkStack(ri->stackref, "PushFront()", true))
				{
					int32_t val = get_register(sarg1); //NOT /10000
					st->push_front(val);
				}
				break;
			}
			
			//Module
			case MODULEGETIC:
			{
				
				int32_t buf_pointer = SH::get_arg(sarg1, false) / 10000;
				int32_t element = SH::get_arg(sarg2, false) / 10000;
				
				if ( ((unsigned)element) > 511 )
				{
					Z_scripterrlog("Illegal itemclass supplied to ZInfo->GetItemClass().\nLegal values are 1 to 511.\n");
				}
				else
				{
					char buffer[256] = {0};
					strcpy(buffer,ZI.getItemClassName(element));
					buffer[255] = '\0';
					if(ArrayH::setArray(buf_pointer, buffer) == SH::_Overflow)
					{
						Z_scripterrlog("Dest string supplied to 'Module->GetItemClass()' is not large enough\n");
					}
				}
			
				break;
			}
			
			//{ Randgen Stuff
			case RNGRAND1:
				if(user_rng* r = checkRNG(ri->rngref, "Rand()"))
				{
					ri->d[rEXP1] = r->rand(214748, -214748)*10000L;
				}
				else ri->d[rEXP1] = -10000L;
				break;
			case RNGRAND2:
				if(user_rng* r = checkRNG(ri->rngref, "Rand(int32_t)"))
				{
					set_register(sarg1,r->rand(get_register(sarg1)/10000L)*10000L);
				}
				else set_register(sarg1,-10000L);
				break;
			case RNGRAND3:
				if(user_rng* r = checkRNG(ri->rngref, "Rand(int32_t,int32_t)"))
				{
					set_register(sarg1,r->rand(get_register(sarg1)/10000L, get_register(sarg2)/10000L)* 10000L);
				}
				else set_register(sarg1,-10000L);
				break;
			case RNGLRAND1:
				if(user_rng* r = checkRNG(ri->rngref, "LRand()"))
				{
					ri->d[rEXP1] = r->rand();
				}
				else ri->d[rEXP1] = -10000L;
				break;
			case RNGLRAND2:
				if(user_rng* r = checkRNG(ri->rngref, "LRand(int32_t)"))
				{
					ri->d[rEXP1] = r->rand(get_register(sarg1));
				}
				else ri->d[rEXP1] = -10000L;
				break;
			case RNGLRAND3:
				if(user_rng* r = checkRNG(ri->rngref, "LRand(int32_t,int32_t)"))
				{
					ri->d[rEXP1] = r->rand(get_register(sarg1), get_register(sarg2));
				}
				else ri->d[rEXP1] = -10000L;
				break;
			case RNGSEED:
				if(user_rng* r = checkRNG(ri->rngref, "SRand(int32_t)"))
				{
					r->srand(get_register(sarg1));
				}
				break;
			case RNGRSEED:
				if(user_rng* r = checkRNG(ri->rngref, "SRand()"))
				{
					ri->d[rEXP1] = r->srand();
				}
				else ri->d[rEXP1] = -10000;
				break;
			case RNGFREE:
				if(user_rng* r = checkRNG(ri->rngref, "Free()", true))
				{
					free_script_object(r->id);
				}
				break;
			case RNGOWN:
				if(user_rng* r = checkRNG(ri->rngref, "Own()", false))
				{
					own_script_object(r, type, i);
				}
				break;
			//}
			case LOADGENERICDATA:
				FFCore.do_loadgenericdata(false); break;
			case RUNGENFRZSCR:
			{
				bool r = FFCore.runGenericFrozenEngine(word(ri->genericdataref));
				set_register(sarg1, r ? 10000L : 0L);
				break;
			}

			case REGION_SCREEN_FOR_COMBO_POS:
				do_getscreenforcombopos(false);
				break;

			case REGION_TRIGGER_SECRETS:
			{
				int screen_index = get_register(sarg1) / 10000;
				if (screen_index != currscr)
				{
					Z_scripterrlog("Screen->TriggerSecrets must be given a screen in the current region. got: %d\n", screen_index);
					break;
				}

				do_triggersecrets();
				break;
			}
			
			///----------------------------------------------------------------------------------------------------//
			
			case SUBDATA_GET_NAME:
			{
				if(ZCSubscreen* sub = checkSubData(ri->subdataref, "GetName"))
				{
					auto aptr = get_register(sarg1) / 10000;
					if(ArrayH::setArray(aptr, sub->name, true) == SH::_Overflow)
						Z_scripterrlog("Array supplied to 'subscreendata->GetName()' not large enough,"
							" and couldn't be resized!\n");
				}
				break;
			}
			case SUBDATA_SET_NAME:
			{
				if(ZCSubscreen* sub = checkSubData(ri->subdataref, "SetName"))
				{
					auto aptr = get_register(sarg1) / 10000;
					ArrayH::getString(aptr, sub->name);
				}
				break;
			}
			case SUBDATA_SWAP_PAGES:
			{
				ri->subdataref = SH::read_stack(ri->sp+2);
				if(ZCSubscreen* sub = checkSubData(ri->subdataref, "SwapPages"))
				{
					int p1 = SH::read_stack(ri->sp+1) / 10000;
					int p2 = SH::read_stack(ri->sp+0) / 10000;
					if(unsigned(p1) >= sub->pages.size())
						Z_scripterrlog("Invalid page index '%d' passed to subscreendata->SwapPages()\n", p1);
					else if(unsigned(p2) >= sub->pages.size())
						Z_scripterrlog("Invalid page index '%d' passed to subscreendata->SwapPages()\n", p2);
					else sub->swap_pages(p1,p2);
				}
				break;
			}
			case SUBPAGE_SWAP_WIDG:
			{
				ri->subpageref = SH::read_stack(ri->sp+2);
				if(SubscrPage* pg = checkSubPage(ri->subpageref, "SwapWidgets"))
				{
					int p1 = SH::read_stack(ri->sp+1) / 10000;
					int p2 = SH::read_stack(ri->sp+0) / 10000;
					if(unsigned(p1) >= pg->size())
						Z_scripterrlog("Invalid page index '%d' passed to subscreenpage->SwapWidgets()\n", p1);
					else if(unsigned(p2) >= pg->size())
						Z_scripterrlog("Invalid page index '%d' passed to subscreenpage->SwapWidgets()\n", p2);
					else pg->swap_widg(p1,p2);
				}
				break;
			}
			case SUBPAGE_FIND_WIDGET:
			{
				ri->d[rEXP1] = 0;
				ri->subpageref = SH::read_stack(ri->sp+1);
				if(SubscrPage* pg = checkSubPage(ri->subpageref, "FindWidget", sstACTIVE))
				{
					int cursorpos = SH::read_stack(ri->sp+0) / 10000;
					if(auto* widg = pg->get_widg_pos(cursorpos,false))
					{
						auto q = pg->widget_index(widg);
						if(q > -1)
						{
							auto [sub,ty,pgid,_ind] = from_subref(ri->subpageref);
							ri->d[rEXP1] = get_subref(sub,ty,pgid,q);
						}
					}
				}
				break;
			}
			case SUBPAGE_FIND_WIDGET_BY_LABEL:
			{
				ri->d[rEXP1] = 0;
				ri->subpageref = SH::read_stack(ri->sp+1);
				if(SubscrPage* pg = checkSubPage(ri->subpageref, "GetWidget"))
				{
					int aptr = SH::read_stack(ri->sp+0) / 10000;
					std::string lbl;
					ArrayH::getString(aptr, lbl);
					if(lbl.size())
					{
						auto q = pg->find_label_index(lbl);
						if(q > -1)
						{
							auto [sub,ty,pgid,_ind] = from_subref(ri->subpageref);
							ri->d[rEXP1] = get_subref(sub,ty,pgid,q);
						}
					}
				}
				break;
			}
			case SUBPAGE_MOVE_SEL:
			{
				#define SUBSEL_FLAG_NO_NONEQUIP 0x01
				#define SUBSEL_FLAG_NEED_ITEM 0x02
				ri->subpageref = SH::read_stack(ri->sp+3);
				if(SubscrPage* pg = checkSubPage(ri->subpageref, "SelectorMove"))
				{
					int flags = SH::read_stack(ri->sp+0) / 10000;
					int dir = SH::read_stack(ri->sp+1) / 10000;
					int pos = SH::read_stack(ri->sp+2) / 10000;
					switch(dir)
					{
						case up:
							dir = SEL_UP;
							break;
						case down:
							dir = SEL_DOWN;
							break;
						case left:
							dir = SEL_LEFT;
							break;
						case right: default:
							dir = SEL_RIGHT;
							break;
					}
					
					auto newpos = pg->movepos_legacy(dir, (pos<<8)|pg->getIndex(),
						255, 255, 255, flags&SUBSEL_FLAG_NO_NONEQUIP,
						flags&SUBSEL_FLAG_NEED_ITEM, true) >> 8;
					ri->d[rEXP1] = 10000*newpos;
				}
				break;
			}
			case SUBPAGE_NEW_WIDG:
			{
				ri->subpageref = SH::read_stack(ri->sp+1);
				if(SubscrPage* pg = checkSubPage(ri->subpageref, "CreateWidget"))
				{
					if(pg->size() == 0x2000)
						break; //Page is full!
					int ty = SH::read_stack(ri->sp+0) / 10000;
					if(auto* widg = SubscrWidget::newType(ty))
					{
						widg->posflags = sspUP | sspDOWN | sspSCROLLING;
						widg->w = 1;
						widg->h = 1;
						pg->push_back(widg);
						auto [sub,ty,pgid,_ind] = from_subref(ri->subpageref);
						ri->d[rEXP1] = get_subref(sub,ty,pgid,pg->size()-1);
					}
					else Z_scripterrlog("Invalid type %d passed to subscreenpage->CreateWidget()\n",ty);
				}
				break;
			}
			case SUBPAGE_DELETE:
			{
				if(SubscrPage* pg = checkSubPage(ri->subpageref, "Delete"))
				{
					auto [sub,_ty] = load_subdata(ri->subpageref);
					sub->delete_page(pg->getIndex());
				}
				break;
			}
			case SUBWIDG_GET_SELTEXT_OVERRIDE:
			{
				if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "GetSelTextOverride"))
				{
					auto aptr = get_register(sarg1) / 10000;
					if(ArrayH::setArray(aptr, widg->override_text, true) == SH::_Overflow)
						Z_scripterrlog("Array supplied to 'subscreenwidget->GetSelTextOverride()' not large enough,"
							" and couldn't be resized!\n");
				}
				break;
			}
			case SUBWIDG_SET_SELTEXT_OVERRIDE:
			{
				if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "SetSelTextOverride"))
				{
					auto aptr = get_register(sarg1) / 10000;
					ArrayH::getString(aptr, widg->override_text);
				}
				break;
			}
			case SUBWIDG_GET_LABEL:
			{
				if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "GetLabel"))
				{
					auto aptr = get_register(sarg1) / 10000;
					if(ArrayH::setArray(aptr, widg->label, true) == SH::_Overflow)
						Z_scripterrlog("Array supplied to 'subscreenwidget->GetLabel()' not large enough,"
							" and couldn't be resized!\n");
				}
				break;
			}
			case SUBWIDG_SET_LABEL:
			{
				if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "SetLabel"))
				{
					auto aptr = get_register(sarg1) / 10000;
					ArrayH::getString(aptr, widg->label);
				}
				break;
			}
			case SUBWIDG_TY_GETTEXT:
			{
				if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "GetText"))
				{
					std::string const* str = nullptr;
					byte ty = widg->getType();
					switch(ty)
					{
						case widgTEXT:
							str = &((SW_Text*)widg)->text;
							break;
						case widgTEXTBOX:
							str = &((SW_TextBox*)widg)->text;
							break;
						default:
							bad_subwidg_type("GetText()", true, ty);
							break;
					}
					if(str)
					{
						auto aptr = get_register(sarg1) / 10000;
						if(ArrayH::setArray(aptr, *str, true) == SH::_Overflow)
							Z_scripterrlog("Array supplied to 'subscreenwidget->GetText()' not large enough,"
								" and couldn't be resized!\n");
					}
				}
				break;
			}
			case SUBWIDG_TY_SETTEXT:
			{
				if(SubscrWidget* widg = checkSubWidg(ri->subwidgref, "SetText"))
				{
					std::string* str = nullptr;
					byte ty = widg->getType();
					switch(ty)
					{
						case widgTEXT:
							str = &((SW_Text*)widg)->text;
							break;
						case widgTEXTBOX:
							str = &((SW_TextBox*)widg)->text;
							break;
						default:
							bad_subwidg_type("SetText()", true, ty);
							break;
					}
					if(str)
					{
						auto aptr = get_register(sarg1) / 10000;
						ArrayH::getString(aptr, *str);
					}
				}
				break;
			}

			case WEBSOCKET_OWN:
			{
				if (auto ws = user_websockets.check(ri->websocketref, "Own()"))
				{
					own_script_object(ws, type, i);
				}
				break;
			}
			case WEBSOCKET_LOAD:
			{
				int arrayptr = SH::get_arg(sarg1, false) / 10000;
				std::string url;
				ArrayH::getString(arrayptr, url, 512);

				ri->websocketref = 0;
				ri->d[rEXP1] = 0;

				if (url.size() == 0 || !url.starts_with("ws"))
				{
					break;
				}

				auto ws = user_websockets.create();
				if (!ws)
				{
					break;
				}

				ws->connect(url);

				ri->websocketref = ws->id;
				ri->d[rEXP1] = ws->id;
				break;
			}
			case WEBSOCKET_FREE:
			{
				if (auto ws = checkPalData(ri->websocketref, "Free()", true))
				{
					free_script_object(ws->id);
				}
				break;
			}
			case WEBSOCKET_ERROR:
			{
				int32_t arrayptr = get_register(sarg1) / 10000;
				if (auto ws = user_websockets.check(ri->websocketref, "GetError()"))
				{
					ArrayH::setArray(arrayptr, ws->get_error(), true);
				}
				else
				{
					ArrayH::setArray(arrayptr, "Invalid pointer", true);
				}
				break;
			}
			case WEBSOCKET_SEND:
			{
				int32_t type = get_register(sarg1);
				int32_t arrayptr = get_register(sarg2) / 10000;
				if (BC::checkBounds(type, 1, 2, "Send() type") != SH::_NoError)
				{
					break;
				}

				std::string message;
				ArrayH::getString(arrayptr, message);
				if (auto ws = user_websockets.check(ri->websocketref, "Send()"))
				{
					ws->send((WebSocketMessageType)type, message);
				}
				break;
			}
			case WEBSOCKET_RECEIVE:
			{
				if (auto ws = user_websockets.check(ri->websocketref, "Receive()"))
				{
					if (!ws->has_message())
					{
						set_register(sarg1, 0);
						break;
					}
					std::string message = ws->receive_message();
					auto message_type = ws->last_message_type;

					if(!(ws->message_arrayptr && is_valid_array(ws->message_arrayptr)))
						ws->message_arrayptr = allocatemem(message.size() + 1, true, ScriptType::None, -1);

					if (message_type == WebSocketMessageType::Text)
						ArrayH::setArray(ws->message_arrayptr, message, true);
					else
						ArrayH::setArray(ws->message_arrayptr, message.size(), message.data(), false, true);

					set_register(sarg1, ws->message_arrayptr * 10000);
				}
				break;
			}

			case REF_INC:
			{
				int offset = ri->d[rSFRAME] + sarg1;
				if (!ri->stack_pos_is_object.contains(offset))
				{
					assert(false);
					break;
				}

				uint32_t id = SH::read_stack(offset);
				script_object_ref_inc(id);
				break;
			}
			case REF_DEC:
			{
				int offset = ri->d[rSFRAME] + sarg1;
				if (!ri->stack_pos_is_object.contains(offset))
				{
					assert(false);
					break;
				}

				uint32_t id = SH::read_stack(offset);
				script_object_ref_dec(id);
				break;
			}
			case REF_AUTORELEASE:
			{
				uint32_t id = get_register(sarg1);
				script_object_autorelease_pool.push_back(id);
				script_object_ref_inc(id);
				break;
			}
			case REF_COUNT:
			{
				if (!use_testingst_start)
				{
					Z_scripterrlog("RefCount can only be used in test mode\n");
					break;
				}

				uint32_t id = get_register(sarg1);
				auto object = get_script_object(id);
				int count = object ? object->ref_count : -1;
				set_register(sarg1, count);
				break;
			}
			case MARK_TYPE_STACK:
			{
				int offset = ri->d[rSFRAME] + sarg2;
				if (offset < 0 || offset >= MAX_SCRIPT_REGISTERS)
				{
					assert(false);
					break;
				}
				if (sarg1 < 0 || sarg1 > 1)
				{
					assert(false);
					break;
				}

				if (sarg1)
					ri->stack_pos_is_object.insert(offset);
				else
					ri->stack_pos_is_object.erase(offset);
				break;
			}
			case MARK_TYPE_REG:
			{
				// Currently only marking globals as objects is supported.
				if (!(sarg1 >= GD(0) && sarg1 <= GD(MAX_SCRIPT_REGISTERS)))
				{
					assert(false);
					break;
				}
				if (!(sarg2 >= 0 && sarg2 <= (int)script_object_type::last))
				{
					assert(false);
					break;
				}

				int index = sarg1 - GD(0);
				game->global_d_types[index] = (script_object_type)sarg2;
				break;
			}
			case REF_REMOVE:
			{
				int offset = ri->d[rSFRAME] + sarg1;
				script_remove_object_ref(offset);
				break;
			}
			case ZCLASS_MARK_TYPE:
			{
				auto& vec = *sargvec;
				assert(vec.size() % 2 == 0);

				uint32_t id = ri->thiskey;
				if (auto obj = user_objects.check(id, "ZCLASS_MARK_TYPE"))
				{
					for (size_t i = 0; i < vec.size(); i += 2)
					{
						int index = vec[i];
						assert(vec[i + 1] >= 0 && vec[i + 1] <= (int)script_object_type::last);
						auto type = (script_object_type)vec[i + 1];
						if (index >= obj->owned_vars)
						{
							int ptr = -obj->data[index] / 10000;
							if (ptr)
							{
								ZScriptArray& a = objectRAM.at(ptr);
								a.setObjectType(type);
							}
						}
						else
						{
							if (obj->var_types.size() <= index)
								obj->var_types.resize(index + 1);
							obj->var_types[index] = type;
						}
					}
				}
				break;
			}
			case GC:
			{
				if (!use_testingst_start)
				{
					Z_error_fatal("GC can only be used in test mode\n");
					break;
				}

				run_gc();
				break;
			}
			case SET_OBJECT:
			{
				if (!(sarg1 >= GD(0) && sarg1 <= GD(MAX_SCRIPT_REGISTERS)))
				{
					assert(false);
					break;
				}

				int value = get_register(sarg2);
				int index = sarg1-GD(0);
				assert(game->global_d_types[index] != script_object_type::none);
				script_object_ref_inc(value);
				script_object_ref_dec(game->global_d[index]);
				game->global_d[index] = value;
				break;
			}

			default:
			{
				Z_scripterrlog("Invalid ZASM command %lu reached; terminating\n", scommand);
				hit_invalid_zasm = true;
				scommand = 0xFFFF;
				break;
			}
		}
		if(earlyretval == RUNSCRIPT_SELFDELETE)
		{
			earlyretval = -1;
			return RUNSCRIPT_SELFDELETE;
		}
		if (ri->sp >= MAX_SCRIPT_REGISTERS)
		{
			if (old_script_funcrun)
				return RUNSCRIPT_OK;
			Z_scripterrlog("Stack over/underflow caused by command %d!\n", scommand);
		}
		if(hit_invalid_zasm) break;
		if(old_script_funcrun && (ri->pc == MAX_PC || scommand == RETURN))
			return RUNSCRIPT_OK;
		
		if (type == ScriptType::Combo)
		{
			if(combopos_modified == i)
			{
				//Combo changed! Abort script!
				return RUNSCRIPT_OK;
			}
		}
		if(scommand != 0xFFFF)
		{
			if(increment)	ri->pc++;
			else			increment = true;
			if ( ri->pc == MAX_PC ) //rolled over from overflow?
			{
				Z_scripterrlog("Script PC overflow! Too many ZASM lines?\n");
				ri->pc = 0;
				scommand = 0xFFFF;
			}
		}
		
		if(earlyretval > -1) //Should this be below the 'commands_run += 1'? Unsure. -Em
		{
			auto v = earlyretval;
			earlyretval = -1;
			return earlyretval;
		}
		
		// If running a JIT compiled script, we're only here to do a few commands.
		commands_run += 1;
		if (is_jitted && commands_run == jitted_uncompiled_command_count) break;
	}
	if(script_funcrun) return RUNSCRIPT_OK;
	
	if(!scriptCanSave)
		scriptCanSave=true;
	
	if(scommand == WAITDRAW)
	{
		switch(type)
		{
			case ScriptType::Global:
			case ScriptType::Player:
			case ScriptType::DMap:
			case ScriptType::OnMap:
			case ScriptType::ScriptedPassiveSubscreen:
			case ScriptType::ScriptedActiveSubscreen:
			case ScriptType::Screen:
			case ScriptType::Combo:
			case ScriptType::NPC:
			case ScriptType::Lwpn:
			case ScriptType::Ewpn:
			case ScriptType::ItemSprite:
				FFCore.waitdraw(type, i) = true;
				break;
			
			case ScriptType::Item:
			{
				if (!get_qr(qr_NOITEMWAITDRAW))
				{
					FFCore.waitdraw(ScriptType::Item, i) = true;
				}
				break;
			}
						
			case ScriptType::FFC:
			{
				if ( !(get_qr(qr_NOFFCWAITDRAW)) )
				{
					FFCore.waitdraw(ScriptType::FFC, i) = true;
				}
				else
				{
					Z_scripterrlog("Waitdraw cannot be used in script type: %s\n", "ffc, with Script Rule 'No FFC Waitdraw() enabled!");
				}
				break;
			}
			
			case ScriptType::Generic:
			case ScriptType::GenericFrozen:
			case ScriptType::EngineSubscreen:
				//No Waitdraw
				break;
			
			default:
				Z_scripterrlog("Waitdraw cannot be used in script type: %s\n", ScriptTypeToString(type));
				break;
		}
	}
	
	if(scommand == 0xFFFF) //Quit/command list end reached/bad command
	{
		script_exit_cleanup(no_dealloc);
		return RUNSCRIPT_STOPPED;
	}
	else
		ri->pc++;

	if(jit_waiting_nop)
		return RUNSCRIPT_STOPPED;

	return RUNSCRIPT_OK;
}

script_data* load_scrdata(ScriptType type, word script, int32_t i)
{
	switch(type)
	{
		case ScriptType::FFC:
			return ffscripts[script];
		case ScriptType::NPC:
			return guyscripts[guys.spr(GuyH::getNPCIndex(i))->script];
		case ScriptType::Lwpn:
			return lwpnscripts[Lwpns.spr(LwpnH::getLWeaponIndex(i))->weaponscript];
		case ScriptType::Ewpn:
			return ewpnscripts[Ewpns.spr(EwpnH::getEWeaponIndex(i))->weaponscript];
		case ScriptType::ItemSprite:
			return itemspritescripts[items.spr(ItemH::getItemIndex(i))->script];
		case ScriptType::Item:
			return itemscripts[script];
		case ScriptType::Global:
			return globalscripts[script];
		case ScriptType::Generic:
		case ScriptType::GenericFrozen:
			return genericscripts[script];
		case ScriptType::Player:
			return playerscripts[script];
		case ScriptType::DMap:
			return dmapscripts[script];
		case ScriptType::OnMap:
		case ScriptType::ScriptedActiveSubscreen:
		case ScriptType::ScriptedPassiveSubscreen:
			return dmapscripts[script];
		case ScriptType::Screen:
			return screenscripts[script];
		case ScriptType::Combo:
			return comboscripts[script];
		case ScriptType::EngineSubscreen:
			return subscreenscripts[script];
	}
	return nullptr;
}

//This keeps ffc scripts running beyond the first frame. 
int32_t ffscript_engine(const bool preload)
{
	if(preload)
	{
		throwGenScriptEvent(GENSCR_EVENT_FFC_PRELOAD);
	}
	if (!FFCore.system_suspend[susptFFCSCRIPTS])
	{
		//run screen script, first
		//zprint("Screen Script Preload? %s \n", ( tmpscr->preloadscript ? "true" : "false"));
		if(( preload && tmpscr->preloadscript) || !preload )
		{
			if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) 
			{
				if ( tmpscr->script > 0 && FFCore.doscript(ScriptType::Screen) )
				{
					ZScriptVersion::RunScript(ScriptType::Screen, tmpscr->script);
				}
			}
		}
		word c = tmpscr->numFFC();
		for(word i = 0; i < c; i++)
		{
			if(tmpscr->ffcs[i].script == 0)
				continue;
				
			if(preload && !(tmpscr->ffcs[i].flags&ffPRELOAD))
				continue;
				
			if((tmpscr->ffcs[i].flags&ffIGNOREHOLDUP)==0 && Hero.getHoldClk()>0)
				continue;
				
			ZScriptVersion::RunScript(ScriptType::FFC, tmpscr->ffcs[i].script, i);
		}
	}
	
	
	return 0;
}



///----------------------------------------------------------------------------------------------------

void FFScript::user_files_init()
{
	user_files.clear();
}

void FFScript::user_dirs_init()
{
	user_dirs.clear();
}
void FFScript::user_objects_init()
{
	for (auto id : script_object_ids_by_type[user_objects.type])
	{
		user_objects[id].clear_nodestruct();
	}
}

void FFScript::user_stacks_init()
{
	user_stacks.clear();
}

void FFScript::user_rng_init()
{
	user_rngs.clear();
	for(int32_t q = 0; q < MAX_USER_RNGS; ++q)
	{
		replay_register_rng(&script_rnggens[q]);

		// Just to seed it.
		user_rng rng;
		rng.set_gen(&script_rnggens[q]);
	}
}

void FFScript::user_paldata_init()
{
	user_paldatas.clear();
}

void FFScript::user_websockets_init()
{
	user_websockets.clear();
	websocket_pool_destroy();
}

// Gotten from 'https://fileinfo.com/filetypes/executable'
static std::set<std::string> banned_extensions = {".xlm",".caction",".8ck", ".actc",".a6p", ".m3g",".run",".workflow",".otm",".apk",".fxp",".73k",".0xe",".exe",".cmd",".jsx",".scar",".wcm",".jar",".ebs2",".ipa",".xap",".ba_",".ac",".bin",".vlx",".icd",".elf",".xbap",".89k",".widget",".a7r",".ex_",".zl9",".cgi",".scr",".coffee",".ahk",".plsc",".air",".ear",".app",".scptd",".xys",".hms",".cyw",".ebm",".pwc",".xqt",".msl",".seed",".vexe",".ebs",".mcr",".gpu",".celx",".wsh",".frs",".vxp",".action",".com",".out",".gadget",".command",".script",".rfu",".tcp",".widget",".ex4",".bat",".cof",".phar",".rxe",".scb",".ms",".isu",".fas",".mlx",".gpe",".mcr",".mrp",".u3p",".js",".acr",".epk",".exe1",".jsf",".rbf",".rgs",".vpm",".ecf",".hta",".dld",".applescript",".prg",".pyc",".spr",".nexe",".server",".appimage",".pyo",".dek",".mrc",".fpi",".rpj",".iim",".vbs",".pif",".mel",".scpt",".csh",".paf",".ws",".mm",".acc",".ex5",".mac",".plx",".snap",".ps1",".vdo",".mxe",".gs",".osx",".sct",".wiz",".x86",".e_e",".fky",".prg",".fas",".azw2",".actm",".cel",".tiapp",".thm",".kix",".wsf",".vbe",".lo",".ls",".tms",".ezs",".ds",".n",".esh",".vbscript",".arscript",".qit",".pex",".dxl",".wpm",".s2a",".sca",".prc",".shb",".rbx",".jse",".beam",".udf",".mem",".kx",".ksh",".rox",".upx",".ms",".mam",".btm",".es",".asb",".ipf",".mio",".sbs",".hpf",".ita",".eham",".ezt",".dmc",".qpx",".ore",".ncl",".exopc",".smm",".pvd",".ham",".wpk"};

// Any extension other than banned ones, including no extension, is allowed.
bool validate_userfile_extension(string const& path)
{
	std::string ext = std::filesystem::path(path).extension().string();
	return banned_extensions.find(ext) == banned_extensions.end();
}

bool FFScript::get_scriptfile_path(char* buf, const char* path)
{
	while((path[0] == '/' || path[0] == '\\') && path[0]) ++path;
	if(path[0])
		sprintf(buf, "%s%c%s", qst_files_path, PATH_SLASH, path);
	else sprintf(buf, "%s", qst_files_path);
	return true;
}

void check_file_error(int32_t ref)
{
	if(user_file* f = checkFile(ref, "", true, true))
	{
		int32_t err = ferror(f->file);
		if(err != 0)
		{
			Z_scripterrlog("File with UID '%ld' encountered an error.\n", ref);
			Z_scripterrlog("File error: %s\n", strerror(err));
		}
	}
}

void FFScript::do_fopen(const bool v, const char* f_mode)
{
	int32_t arrayptr = SH::get_arg(sarg1, v) / 10000;
	string filename_str;
	ArrayH::getString(arrayptr, filename_str, 512);
	regulate_path(filename_str);
	ri->d[rEXP1] = 0L; //Presume failure; update to 10000L on success
	ri->d[rEXP2] = 0;
	if(!valid_file(filename_str))
	{
		Z_scripterrlog("Path '%s' empty or points to a directory; must point to a file!\n",filename_str.c_str());
		return;
	}
	if(!validate_userfile_extension(filename_str))
	{
		Z_scripterrlog("Cannot open/create file with extension '%s'.\n", get_ext(filename_str).c_str());
		return;
	}
	if(filename_str.find("../") != string::npos
		|| filename_str.find("..\\") != string::npos)
	{
		Z_scripterrlog("Error: Script attempted to go up a directory in file load '%s'\n", filename_str.c_str());
		return;
	}
	char buf[2048+1] = {0};
	FFCore.get_scriptfile_path(buf, filename_str.c_str());
	user_file* f = checkFile(ri->fileref, "Open()", false, true);
	if(!f) //auto-allocate
	{
		ri->fileref = user_files.get_free();
		f = checkFile(ri->fileref, "Open()", false, true);
	}
	ri->d[rEXP2] = ri->fileref; //Returns to the variable!
	if(f)
	{
		f->close(); //Close the old FILE* before overwriting it!
		bool create = false;
		for(int32_t q = 0; f_mode[q]; ++q)
		{
			if(f_mode[q] == 'w' || f_mode[q] == 'a')
			{
				create = true;
				break;
			}
		}
		if(!create || create_path(buf))
		{
			f->file = fopen(buf, f_mode);
			fflush(f->file);
			zc_chmod(buf, SCRIPT_FILE_MODE);
			f->setPath(buf);
			//r+; read-write, will not create if does not exist, will not delete content if does exist.
			//w+; read-write, will create if does not exist, will delete all content if does exist.
			if(f->file)
			{
				ri->d[rEXP1] = 10000L; //Success
				return;
			}
		}
		else
		{
			Z_scripterrlog("Script failed to create directories for file path '%s'.\n", filename_str.c_str());
			ri->d[rEXP2] = 0;
			return;
		}
	}
}

void FFScript::do_fremove()
{
	if(user_file* f = checkFile(ri->fileref, "Remove()", true))
	{
		zprint2("Removing file %d\n", ri->fileref);
		ri->d[rEXP1] = f->do_remove() ? 0L : 10000L;
	}
	else ri->d[rEXP1] = 0L;
}

void FFScript::do_fclose()
{
	if(user_file* f = checkFile(ri->fileref, "Close()", false, true))
	{
		f->close();
	}
	//No else. If invalid, no error is thrown.
}

void FFScript::do_allocate_file()
{
	//Get a file and return it
	ri->fileref = user_files.get_free();
	ri->d[rEXP2] = ri->fileref; //Return to ptr
	ri->d[rEXP1] = (ri->d[rEXP2] == 0 ? 0L : 10000L);
}

void FFScript::do_deallocate_file()
{
	user_file* f = checkFile(ri->fileref, "Free()", false, true);
	if(f) free_script_object(f->id);
}

void FFScript::do_file_isallocated() //Returns true if file is allocated
{
	user_file* f = checkFile(ri->fileref, "isAllocated()", false, true);
	ri->d[rEXP1] = (f) ? 10000L : 0L;
}

void FFScript::do_file_isvalid() //Returns true if file is allocated and has an open FILE*
{
	user_file* f = checkFile(ri->fileref, "isValid()", true, true);
	ri->d[rEXP1] = (f) ? 10000L : 0L;
}

void FFScript::do_fflush()
{
	ri->d[rEXP1] = 0L;
	if(user_file* f = checkFile(ri->fileref, "Flush()", true))
	{
		if(!fflush(f->file))
			ri->d[rEXP1] = 10000L;
		check_file_error(ri->fileref);
	}
}

void FFScript::do_file_readchars()
{
	if(user_file* f = checkFile(ri->fileref, "ReadChars()", true))
	{
		uint32_t pos = zc_max(ri->d[rINDEX] / 10000,0);
		int32_t count = get_register(sarg2) / 10000;
		if(count == 0) return;
		int32_t arrayptr = get_register(sarg1) / 10000;
		ArrayManager am(arrayptr);
		int32_t sz = am.size();
		if(sz <= 0)
			return;
		if(pos >= sz)
		{
		    Z_scripterrlog("Pos (%d) passed to %s is outside the bounds of array %d. Aborting.\n", pos, "ReadChars()", arrayptr);
		    return;
		}
		if(count < 0 || unsigned(count) > sz-pos) count = sz-pos;
		int32_t limit = pos+count;
		char c;
		word q;
		ri->d[rEXP1] = 0;
		for(q = pos; q < limit; ++q)
		{
			c = fgetc(f->file);
			if(feof(f->file) || ferror(f->file))
				break;
			if(c <= 0)
				break;
			am.set(q,c * 10000L);
			++ri->d[rEXP1]; //Don't count nullchar towards length
		}
		if(q >= limit)
		{
			--q;
			--ri->d[rEXP1];
			ungetc(am.get(q), f->file); //Put the character back before overwriting it
		}
		am.set(q,0); //Force null-termination
		ri->d[rEXP1] *= 10000L;
		check_file_error(ri->fileref);
		return;
	}
	ri->d[rEXP1] = 0L;
}
void FFScript::do_file_readbytes()
{
	if(user_file* f = checkFile(ri->fileref, "ReadBytes()", true))
	{
		uint32_t pos = zc_max(ri->d[rINDEX] / 10000,0);
		int32_t count = get_register(sarg2) / 10000;
		if(count == 0) return;
		int32_t arrayptr = get_register(sarg1) / 10000;
		ArrayManager am(arrayptr);
		int32_t sz = am.size();
		if(sz <= 0)
			return;
		if(pos >= sz)
		{
		    Z_scripterrlog("Pos (%d) passed to %s is outside the bounds of array %d. Aborting.\n", pos, "ReadBytes()", arrayptr);
		    return;
		}
		if(count < 0 || unsigned(count) > sz-pos) count = sz-pos;
		std::vector<uint8_t> data(count);
		ri->d[rEXP1] = 10000L * fread((void*)&(data[0]), 1, count, f->file);
		for(int32_t q = 0; q < count; ++q)
		{
			am.set(q+pos, 10000L * data[q]);
		}
		check_file_error(ri->fileref);
		return;
	}
	ri->d[rEXP1] = 0L;
}
void FFScript::do_file_readstring()
{
	if(user_file* f = checkFile(ri->fileref, "ReadString()", true))
	{
		int32_t arrayptr = get_register(sarg1) / 10000;
		ArrayManager am(arrayptr);
		int32_t sz = am.size();
		if(sz <= 0)
			return;
		int32_t limit = sz;
		int32_t c;
		word q;
		ri->d[rEXP1] = 0;
		for(q = 0; q < limit; ++q)
		{
			c = fgetc(f->file);
			if(feof(f->file) || ferror(f->file))
				break;
			if(c <= 0)
				break;
			am.set(q,c * 10000L);
			++ri->d[rEXP1]; //Don't count nullchar towards length
			if(c == '\n')
			{
				++q;
				break;
			}
		}
		if(q >= limit)
		{
			--q;
			--ri->d[rEXP1];
			ungetc(am.get(q), f->file); //Put the character back before overwriting it
		}
		am.set(q,0); //Force null-termination
		ri->d[rEXP1] *= 10000L;
		check_file_error(ri->fileref);
		return;
	}
	ri->d[rEXP1] = 0L;
}
void FFScript::do_file_readints()
{
	if(user_file* f = checkFile(ri->fileref, "ReadInts()", true))
	{
		uint32_t pos = zc_max(ri->d[rINDEX] / 10000,0);
		int32_t count = get_register(sarg2) / 10000;
		if(count == 0) return;
		int32_t arrayptr = get_register(sarg1) / 10000;
		ArrayManager am(arrayptr);
		int32_t sz = am.size();
		if(sz <= 0)
			return;
		if(pos >= sz) 
		{
		    Z_scripterrlog("Pos (%d) passed to %s is outside the bounds of array %d. Aborting.\n", pos, "ReadInts()", arrayptr);
		    return;
		}
		if(count < 0 || unsigned(count) > sz-pos) count = sz-pos;
		
		std::vector<int32_t> data(count);
		ri->d[rEXP1] = 10000L * fread((void*)&(data[0]), 4, count, f->file);
		for(int32_t q = 0; q < count; ++q)
		{
			am.set(q+pos,data[q]);
		}
		check_file_error(ri->fileref);
		return;
	}
	ri->d[rEXP1] = 0L;
}
void FFScript::do_file_writechars()
{
	if(user_file* f = checkFile(ri->fileref, "WriteChars()", true))
	{
		int32_t pos = zc_max(ri->d[rINDEX] / 10000,0);
		int32_t count = get_register(sarg2) / 10000;
		if(count == 0) return;
		if(count == -1 || count > (MAX_ZC_ARRAY_SIZE-pos)) count = MAX_ZC_ARRAY_SIZE-pos;
		int32_t arrayptr = get_register(sarg1) / 10000;
		string output;
		ArrayH::getString(arrayptr, output, count, pos);
		uint32_t q = 0;
		for(; q < output.length(); ++q)
		{
			if(fputc(output[q], f->file)<0)
				break;
		}
		ri->d[rEXP1] = q * 10000L;
		check_file_error(ri->fileref);
		return;
	}
	ri->d[rEXP1] = 0L;
}

void FFScript::do_file_writebytes()
{
	if(user_file* f = checkFile(ri->fileref, "WriteBytes()", true))
	{
		uint32_t pos = zc_max(ri->d[rINDEX] / 10000,0);
		int32_t arg = get_register(sarg2) / 10000;
		if(arg == 0) return;
		uint32_t count = ((arg<0 || unsigned(arg) >(MAX_ZC_ARRAY_SIZE - pos)) ? MAX_ZC_ARRAY_SIZE - pos : unsigned(arg));
		int32_t arrayptr = get_register(sarg1) / 10000;
		string output;
		ArrayManager am(arrayptr);
		if(am.invalid()) return;
		int32_t sz = am.size();
		if(sz <= 0)
			return;
		if(pos >= sz)
		{
		    Z_scripterrlog("Pos (%d) passed to %s is outside the bounds of array %d. Aborting.\n", pos, "WriteBytes()", arrayptr);
		    return;
		}
		if(count < 0 || unsigned(count) > sz-pos) count = sz-pos;
		std::vector<uint8_t> data(count);
		for(uint32_t q = 0; q < count; ++q)
		{
			data[q] = am.get(q+pos) / 10000;
		}
		ri->d[rEXP1] = 10000L * fwrite((const void*)&(data[0]), 1, count, f->file);
		check_file_error(ri->fileref);
		return;
	}
	ri->d[rEXP1] = 0L;
}
void FFScript::do_file_writestring()
{
	if(user_file* f = checkFile(ri->fileref, "WriteString()", true))
	{
		int32_t arrayptr = get_register(sarg1) / 10000;
		string output;
		ArrayH::getString(arrayptr, output, ZSCRIPT_MAX_STRING_CHARS);
		uint32_t q = 0;
		for(; q < output.length(); ++q)
		{
			if(fputc(output[q], f->file)<0)
				break;
		}
		ri->d[rEXP1] = q * 10000L;
		check_file_error(ri->fileref);
		return;
	}
	ri->d[rEXP1] = 0L;
}
void FFScript::do_file_writeints()
{
	if(user_file* f = checkFile(ri->fileref, "WriteInts()", true))
	{
		uint32_t pos = zc_max(ri->d[rINDEX] / 10000,0);
		int32_t count = get_register(sarg2) / 10000;
		if(count == 0) return;
		int32_t arrayptr = get_register(sarg1) / 10000;
		ArrayManager am(arrayptr);
		if(am.invalid()) return;
		int32_t sz = am.size();
		if(sz <= 0)
			return;
		if(pos >= sz) 
		{
		    Z_scripterrlog("Pos (%d) passed to %s is outside the bounds of array %d. Aborting.\n", pos, "WriteInts()", arrayptr);
		    return;
		}
		
		if(count < 0 || unsigned(count) > sz-pos) count = sz-pos;
		std::vector<int32_t> data(count);
		for(int32_t q = 0; q < count; ++q)
		{
			data[q] = am.get(q+pos);
		}
		ri->d[rEXP1] = 10000L * fwrite((const void*)&(data[0]), 4, count, f->file);
		check_file_error(ri->fileref);
		return;
	}
	ri->d[rEXP1] = 0L;
}

void FFScript::do_file_getchar()
{
	if(user_file* f = checkFile(ri->fileref, "GetChar()", true))
	{
		ri->d[rEXP1] = fgetc(f->file) * 10000L;
		check_file_error(ri->fileref);
		return;
	}
	ri->d[rEXP1] = -10000L; //-1 == EOF; error value
}
void FFScript::do_file_putchar()
{
	if(user_file* f = checkFile(ri->fileref, "PutChar()", true))
	{
		int32_t c = get_register(sarg1) / 10000;
		if(char(c) != c)
		{
			Z_scripterrlog("Invalid character val %d passed to PutChar(); value will overflow.", c);
			c = char(c);
		}
		ri->d[rEXP1] = fputc(c, f->file) * 10000L;
		check_file_error(ri->fileref);
		return;
	}
	ri->d[rEXP1] = -10000L; //-1 == EOF; error value
}
void FFScript::do_file_ungetchar()
{
	if(user_file* f = checkFile(ri->fileref, "UngetChar()", true))
	{
		int32_t c = get_register(sarg1) / 10000;
		if(char(c) != c)
		{
			Z_scripterrlog("Invalid character val %d passed to UngetChar(); value will overflow.", c);
			c = char(c);
		}
		ri->d[rEXP1] = ungetc(c,f->file) * 10000L;
		check_file_error(ri->fileref);
		return;
	}
	ri->d[rEXP1] = -10000L; //-1 == EOF; error value
}

void FFScript::do_file_seek()
{
	if(user_file* f = checkFile(ri->fileref, "Seek()", true))
	{
		int32_t pos = get_register(sarg1); //NOT /10000 -V
		int32_t origin = get_register(sarg2) ? SEEK_CUR : SEEK_SET;
		ri->d[rEXP1] = fseek(f->file, pos, origin) ? 0L : 10000L;
		check_file_error(ri->fileref);
		return;
	}
	ri->d[rEXP1] = 0;
}
void FFScript::do_file_rewind()
{
	if(user_file* f = checkFile(ri->fileref, "Rewind()", true))
	{
		//fseek(f->file, 0L, SEEK_END);
		rewind(f->file);
		check_file_error(ri->fileref);
	}
}
void FFScript::do_file_clearerr()
{
	if(user_file* f = checkFile(ri->fileref, "ClearError()", true))
	{
		clearerr(f->file);
	}
}

void FFScript::do_file_geterr()
{
	if(user_file* f = checkFile(ri->fileref, "GetError()", true))
	{
		int32_t err = ferror(f->file);
		int32_t arrayptr = get_register(sarg1) / 10000;
		if(err)
		{
			string error = strerror(err);
			ArrayH::setArray(arrayptr, error);
		}
		else
		{
			ArrayH::setArray(arrayptr, "\0");
		}
	}
}
///----------------------------------------------------------------------------------------------------
//Directory

void FFScript::do_directory_get()
{
	if(user_dir* dr = checkDir(ri->directoryref, "GetFilename()", true))
	{
		int32_t indx = get_register(sarg1) / 10000L;
		int32_t arrayptr = get_register(sarg2) / 10000L;
		char buf[2048] = {0};
		set_register(sarg1, dr->get(indx, buf) ? 10000L : 0L);
		if(ArrayH::setArray(arrayptr, string(buf)) == SH::_Overflow)
			Z_scripterrlog("Array supplied to 'directory->GetFilename()' not large enough\n");
	}
	else set_register(sarg1, 0L);
}

void FFScript::do_directory_reload()
{
	if(user_dir* dr = checkDir(ri->directoryref, "Reload()", true))
	{
		dr->refresh();
	}
}

void FFScript::do_directory_free()
{
	if(user_dir* dr = checkDir(ri->directoryref, "Free()", true))
	{
		free_script_object(dr->id);
	}
}

///----------------------------------------------------------------------------------------------------

void FFScript::set_sarg1(int32_t v)
{
	set_register(sarg1, v);
}

void FFScript::do_isvalidbitmap()
{
	int32_t id = get_register(sarg1);

	if (id >= 0)
	{
		auto bmp = user_bitmaps.check(id, "", true);
		if (bmp && bmp->u_bmp)
		{
			set_register(sarg1, 10000);
			return;
		}
	}

	set_register(sarg1, 0);
}
void FFScript::do_isallocatedbitmap()
{
	int32_t id = get_register(sarg1);

	if (id >= 0)
	{
		auto bmp = user_bitmaps.check(id, "", true);
		if (bmp)
		{
			set_register(sarg1, 10000);
			return;
		}
	}

	set_register(sarg1, 0);
}

void FFScript::user_bitmaps_init()
{
	user_bitmaps.clear();
}

int32_t FFScript::do_create_bitmap()
{
	int32_t w = (ri->d[rINDEX2] / 10000);
	int32_t h = (ri->d[rINDEX]/10000);
	if ( get_qr(qr_OLDCREATEBITMAP_ARGS) )
	{
		std::swap(w, h);
	}
	
	return create_user_bitmap_ex(h,w);
}

uint32_t FFScript::create_user_bitmap_ex(int32_t w, int32_t h)
{
	auto bmp = user_bitmaps.create();
	if (!bmp)
		return 0;

	bmp->width = w;
	bmp->height = h;
	bmp->u_bmp = create_bitmap_ex(8,w,h);
	clear_bitmap(bmp->u_bmp);
	return bmp->id;
}

BITMAP* FFScript::GetScriptBitmap(int32_t id, bool skipError)
{
	switch (id - 10)
	{
		case rtSCREEN:
		case rtBMP0:
		case rtBMP1:
		case rtBMP2:
		case rtBMP3:
		case rtBMP4:
		case rtBMP5:
		case rtBMP6: //old system bitmaps (render targets)
		{
			return zscriptDrawingRenderTarget->GetBitmapPtr(id);
		}
	}

	if (auto bitmap = checkBitmap(id, NULL, true, skipError))
		return bitmap->u_bmp;

	return nullptr;
}

uint32_t FFScript::get_free_bitmap(bool skipError)
{
	auto bmp = user_bitmaps.create(skipError);
	if (!bmp)
		return 0;
	return bmp->id;
}

void FFScript::do_deallocate_bitmap()
{
	if (ZScriptVersion::gc())
		return;

	if(isSystemBitref(ri->bitmapref))
	{
		return; //Don't attempt to deallocate system bitmaps!
	}

	// Bitmaps are not deallocated right away, but deferred until the next call to scb.update()
	if (auto b = checkBitmap(ri->bitmapref, "Free()", false, true))
		b->free_obj();
}

bool FFScript::isSystemBitref(int32_t ref)
{
	switch(ref-10)
	{
		case rtSCREEN:
		case rtBMP0:
		case rtBMP1:
		case rtBMP2:
		case rtBMP3:
		case rtBMP4:
		case rtBMP5:
		case rtBMP6:
			return true;
	}
	return false;
}

///----------------------------------------------------------------------------------------------------

void FFScript::set_screenwarpReturnY(mapscr *m, int32_t d, int32_t value)
{
	int32_t y = vbound(value, 0, 255); //should be screen hight max, except that we may be able to move the subscreen.
	m->warpreturny[d] = y;
}

void FFScript::set_screendoor(mapscr *m, int32_t d, int32_t value)
{
	int32_t dr = vbound(d,0,3);
	int32_t doortype = vbound(value,0,16);
	m->door[dr] = doortype;
}


void FFScript::set_screenenemy(mapscr *m, int32_t index, int32_t value)
{
	int32_t enem_indx = vbound(index,0,9);
	m->enemy[enem_indx] = vbound(value,0,511);
}
void FFScript::set_screenlayeropacity(mapscr *m, int32_t d, int32_t value)
{
	int32_t layer = vbound(d,0,6); int32_t op;
	if ( value <= 64 ) op = 64; 
	else op = 128;
	m->layeropacity[layer] = op;
}
void FFScript::set_screensecretcombo(mapscr *m, int32_t d, int32_t value)
{
	int32_t indx = vbound(value,0,127);
	int32_t cmb = vbound(value,0,MAXCOMBOS);
	m->secretcombo[indx] = cmb;
}
void FFScript::set_screensecretcset(mapscr *m, int32_t d, int32_t value)
{
	int32_t indx = vbound(value,0,127);
	int32_t cs = vbound(value,0,15);
	m->secretcset[indx] = cs;
}
void FFScript::set_screensecretflag(mapscr *m, int32_t d, int32_t value)
{
	int32_t indx = vbound(d,0,127);
	int32_t flag = vbound(value,0,MAX_FLAGS);
	m->secretflag[indx] = flag;
}
void FFScript::set_screenlayermap(mapscr *m, int32_t d, int32_t value)
{
	int32_t layer = vbound(d, MIN_ZQ_LAYER, MAX_ZQ_LAYER);
	int32_t mp = vbound(value,0, (map_count-1));
	m->layermap[layer] = mp;
}
void FFScript::set_screenlayerscreen(mapscr *m, int32_t d, int32_t value)
{
	int32_t layer = vbound(d, MIN_ZQ_LAYER, MAX_ZQ_LAYER);
	int32_t sc = vbound(value,0, 0x87);
	m->layerscreen[layer] = sc;
}
void FFScript::set_screenpath(mapscr *m, int32_t d, int32_t value)
{
	int32_t indx = vbound(d,0,3);
	m->path[indx] = value;
}
void FFScript::set_screenwarpReturnX(mapscr *m, int32_t d, int32_t value)
{
	int32_t x = vbound(value,0,255);
	m->warpreturnx[d] = x;
}


void FFScript::set_screenGuy(mapscr *m, int32_t value)
{
	int32_t bloke = vbound(value,0,9); 
	m->guy = bloke ;
}
void FFScript::set_screenString(mapscr *m, int32_t value)
{
	int32_t string = vbound(value, 0, msg_count-1); //Sanity check to keep it within the legal string IDs.
	m->str = string;
}
void FFScript::set_screenRoomtype(mapscr *m, int32_t value)
{
	int32_t r = vbound(value, rNONE, (rMAX-1)); 
	m->room = r;
}
void FFScript::set_screenEntryX(mapscr *m, int32_t value)
{
	int32_t x = vbound(value,0,255);
	m->entry_x = x;
}
void FFScript::set_screenEntryY(mapscr *m, int32_t value)
{
	int32_t y = vbound(value,0,255);
	m->entry_y = y;
}
void FFScript::set_screenitem(mapscr *m, int32_t value)
{
	int32_t itm = vbound(value,0,MAXITEMS);
	m->item = itm;
}
void FFScript::set_screenundercombo(mapscr *m, int32_t value)
{
	int32_t cmb = vbound(value,0,MAXCOMBOS);
	m->undercombo = cmb;
}
void FFScript::set_screenundercset(mapscr *m, int32_t value)
{
	int32_t cs = vbound(value,0,15);
	m->undercset = cs;
}
void FFScript::set_screenatchall(mapscr *m, int32_t value)
{
	//What are ALL of the catchalls and their max (used) values?
	int32_t ctch = vbound(value, 0, 65535); //It is a word type. 
	m->catchall = ctch;
}


//One too many inputs here. -Z

int32_t FFScript::GetQuestVersion()
{
	return QHeader.zelda_version;
}
int32_t FFScript::GetQuestBuild()
{
	return QHeader.build;
}
int32_t FFScript::GetQuestSectionVersion(int32_t section)
{
	return QHeader.zelda_version;
}

int32_t FFScript::GetDefaultWeaponSprite(int32_t wpn_id)
{
	switch (wpn_id)
	{
		case wNone:
			return 0; 
		
		case wSword: return 0;
		case wBeam: return 1;
		case wBrang: return 4;
		case wBomb: return 9;
		case wSBomb: return 75;
		case wLitBomb: return 7;
		case wLitSBomb: return 8;
		case wArrow: return 10;
		case wRefArrow: return 10;
		case wFire: return 12;
		case wRefFire: return 12;
		case wRefFire2: return 12;
		case wWhistle: return 45; //blank, unused misc sprite
		case wBait: return 14;
		case wWand: return 15;
		case wMagic: return 16;
		case wCatching: return 45; //blank, unused misc sprite
		case wWind: return 13;
		case wRefMagic: return 16;
		case wRefFireball: return 17;
		case wRefRock: return 18;
		case wHammer: return 25;
		case wHookshot: return 26;
		case wHSHandle: return 28;
		case wHSChain: return 27;
		case wSSparkle: return 29;
		case wFSparkle: return 32;
		case wSmack: return 33;
		case wPhantom: return -1;
		case wCByrna: return 87;
		case wRefBeam: return 1;
		case wStomp: return 45; //blank, unused misc sprite
		case lwMax: return 45; //blank, unused misc sprite
		case wScript1: { if ( get_qr(qr_WRITING_NPC_WEAPON_UNIQUE_SPRITES ) ) return 246; else return 0; }
		case wScript2: { if ( get_qr(qr_WRITING_NPC_WEAPON_UNIQUE_SPRITES ) ) return 247; else return 0; }
		case wScript3: { if ( get_qr(qr_WRITING_NPC_WEAPON_UNIQUE_SPRITES ) ) return 248; else return 0; }
		case wScript4: { if ( get_qr(qr_WRITING_NPC_WEAPON_UNIQUE_SPRITES ) ) return 249; else return 0; }
		case wScript5: { if ( get_qr(qr_WRITING_NPC_WEAPON_UNIQUE_SPRITES ) ) return 250; else return 0; }
		case wScript6: { if ( get_qr(qr_WRITING_NPC_WEAPON_UNIQUE_SPRITES ) ) return 251; else return 0; }
		case wScript7: { if ( get_qr(qr_WRITING_NPC_WEAPON_UNIQUE_SPRITES ) ) return 252; else return 0; }
		case wScript8: { if ( get_qr(qr_WRITING_NPC_WEAPON_UNIQUE_SPRITES ) ) return 253; else return 0; }
		case wScript9: { if ( get_qr(qr_WRITING_NPC_WEAPON_UNIQUE_SPRITES ) ) return 254; else return 0; }
		case wScript10: { if ( get_qr(qr_WRITING_NPC_WEAPON_UNIQUE_SPRITES ) ) return 255; else return 0; }

		case wIce: return 83;
			//Cannot use any of these weapons yet. 
			//return -1;
		
		case wEnemyWeapons:
		case ewFireball: return 17;
		
		case ewArrow: return 19; 
		case ewBrang: return 4; 
		case ewSword: return 20; 
		case ewRock: return 18; 
		case ewMagic: return 21; 
		case ewBomb: return 78; 
		case ewSBomb: return 79; 
		case ewLitBomb: return 76; 
		case ewLitSBomb: return 77; 
		case ewFireTrail: return 80; 
		case ewFlame: return 35; 
		case ewWind: return 36; 
		case ewFlame2: return 81; 
		case ewFlame2Trail: return 82; 
		case ewIce: return 83; 
		case ewFireball2: return 17;  //fireball (rising)
		
			
		default:  return -1; //No assign.
		
	}
}

//bitmap->GetPixel()


int32_t FFScript::do_getpixel()
{
	int32_t xoffset = 0, yoffset = 0;
	int32_t xoff = 0; int32_t yoff = 0;
	const bool brokenOffset= ( (get_er(er_BITMAPOFFSET)!=0)
		|| (get_qr(qr_BITMAPOFFSETFIX)!=0) );
	
	BITMAP *bitty = FFCore.GetScriptBitmap(ri->bitmapref);
	if(!bitty)
	{
		bitty = scrollbuf;
	}
	// draw to screen with subscreen offset
	if(!brokenOffset && ri->bitmapref == rtSCREEN + 10 )
	{
		xoffset = xoff;
		yoffset = 56; //should this be -56?
	}
	else
	{
		xoffset = 0;
		yoffset = 0;
	}
	
	int32_t yv = ri->d[rINDEX2]/10000 + yoffset;
	int32_t ret =  getpixel(bitty, ri->d[rINDEX]/10000, yv); //This is a palette index value. 
	if(!get_qr(qr_BROKEN_GETPIXEL_VALUE))
		ret *= 10000;
	return ret;
}

void FFScript::do_bmpcollision()
{
	int32_t bmpref = SH::read_stack(ri->sp + 5);
	int32_t maskbmpref = SH::read_stack(ri->sp + 4);
	int32_t x = SH::read_stack(ri->sp + 3) / 10000;
	int32_t y = SH::read_stack(ri->sp + 2) / 10000;
	int32_t checkCol = SH::read_stack(ri->sp + 1) / 10000;
	int32_t maskCol = SH::read_stack(ri->sp + 0) / 10000;
	BITMAP *checkbit = FFCore.GetScriptBitmap(bmpref, true);
	BITMAP *maskbit = FFCore.GetScriptBitmap(maskbmpref, true);
	if(!(checkbit && maskbit))
	{
		set_register(sarg1, -10000);
		char buf1[16];
		char buf2[16];
		zc_itoa(bmpref, buf1);
		zc_itoa(maskbmpref, buf2);
		Z_scripterrlog("Invalid bitmap%s passed to 'bitmap->CountColor()': %s%s%s\n",
			(checkbit || maskbit) ? "" : "s", checkbit ? "" : buf1,
			(checkbit || maskbit) ? "" : ", ", maskbit ? "" : buf2);
		return;
	}
	int32_t ret = countColor(checkbit, maskbit, x, y, checkCol, maskCol);
	set_register(sarg1, ret*10000);
}


int32_t FFScript::loadMapData()
{
	int32_t _map = (ri->d[rINDEX] / 10000);
	int32_t _scr = (ri->d[rINDEX2]/10000);
	int32_t indx = (zc_max((_map)-1,0) * MAPSCRS + _scr);
	//zprint("LoadMapData Map Value: %d\n", _map);
	//zprint("LoadMapData Screen Value: %d\n", _scr);
	//zprint("LoadMapData Indx Value: %d\n", indx);
	 if ( _map < 1 || _map > map_count )
	{
		Z_scripterrlog("Invalid Map ID passed to Game->LoadMapData: %d\n", _map);
		ri->mapsref = MAX_SIGNED_32;
	}
	else if ( _scr < 0 || _scr > 129 ) //0x00 to 0x81 -Z
	{
		Z_scripterrlog("Invalid Screen ID passed to Game->LoadMapData: %d\n", _scr);
		ri->mapsref = MAX_SIGNED_32;
	}
	else ri->mapsref = indx;
	//zprint("LoadMapData Screen set ri->mapsref to: %d\n", ri->mapsref);
	return ri->mapsref;
}


// Called when leaving a screen; deallocate arrays created by FFCs that aren't carried over
void FFScript::deallocateZScriptArray(const int32_t ptrval)
{
	if(ptrval == 0) return;
	if(ptrval==0 || ptrval >= NUM_ZSCRIPT_ARRAYS)
		Z_scripterrlog("Script tried to deallocate memory at invalid address %ld\n", ptrval);
	else if(ptrval<0)
		Z_scripterrlog("Script tried to deallocate memory at object-based address %ld\n", ptrval);
	else
	{
		if(arrayOwner[ptrval].specOwned) return; //ignore this deallocation
		if(arrayOwner[ptrval].specCleared) return;
		arrayOwner[ptrval].clear();
		
		if(!localRAM[ptrval].Valid())
			Z_scripterrlog("Script tried to deallocate memory that was not allocated at address %ld\n", ptrval);
		else
		{
			if (localRAM[ptrval].HoldsObjects())
			{
				auto&& aptr = localRAM[ptrval];
				for (int i = 0; i < aptr.Size(); i++)
				{
					int id = aptr[i];
					script_object_ref_dec(id);
				}
			}
			localRAM[ptrval].Clear();
		}
	}
}

int32_t FFScript::get_screen_d(int32_t index1, int32_t index2)
{
	if(index2 < 0 || index2 > 7)
	{
		Z_scripterrlog("You were trying to reference an out-of-bounds array index for a screen's D[] array (%ld); valid indices are from 0 to 7.\n", index1);
		return 0;
	}
	if (index1 < 0 || index1 >= game->screen_d.size())
	{
		Z_scripterrlog("You were trying to reference an out-of-bounds screen for a D[] array (%ld); valid indices are from 0 to %ld.\n", index1, game->screen_d.size() - 1);
		return 0;
	}
	
	return game->screen_d[index1][index2];
}

void FFScript::set_screen_d(int32_t index1, int32_t index2, int32_t val)
{
	if(index2 < 0 || index2 > 7)
	{
		Z_scripterrlog("You were trying to reference an out-of-bounds array index for a screen's D[] array (%ld); valid indices are from 0 to 7.\n", index1);
		return;
	}
	if (index1 < 0 || index1 >= game->screen_d.size())
	{
		Z_scripterrlog("You were trying to reference an out-of-bounds screen for a D[] array (%ld); valid indices are from 0 to %ld.\n", index1, game->screen_d.size() - 1);
		return;
	}
	
	game->screen_d[index1][index2] = val;
}

// If scr is currently being used as a layer, return that layer no.
int32_t FFScript::whichlayer(int32_t scr)
{
	for(int32_t i = 0; i < 6; i++)
	{
		if(scr == (tmpscr->layermap[i] - 1) * MAPSCRS + tmpscr->layerscreen[i])
			return i;
	}
	
	return -1;
}

void FFScript::do_zapout()
{
	zapout();
}

void FFScript::do_zapin(){ zapin(); }

void FFScript::do_openscreen() { openscreen(); }
void FFScript::do_closescreen() { closescreen(); }
void FFScript::do_openscreenshape()
{
	int32_t shape = get_register(sarg1) / 10000;
	if(shape < 0 || shape >= bosMAX)
	{
		Z_scripterrlog("Invalid shape passed to %s! Valid range %d to %d. Using 'Circle' shape.\n", "Screen->OpeningWipe(int32_t)", 0, bosMAX-1);
		shape = bosCIRCLE;
	}
	openscreen(shape);
}
void FFScript::do_closescreenshape()
{
	int32_t shape = get_register(sarg1) / 10000;
	if(shape < 0 || shape >= bosMAX)
	{
		Z_scripterrlog("Invalid shape passed to %s! Valid range %d to %d. Using 'Circle' shape.\n", "Screen->ClosingWipe(int32_t)", 0, bosMAX-1);
		shape = bosCIRCLE;
	}
	closescreen(shape);
}
void FFScript::do_wavyin() { wavyin(); }
void FFScript::do_wavyout() { wavyout(false); }


void FFScript::do_triggersecret(const bool v)
{
	int32_t ID = vbound((SH::get_arg(sarg1, v) / 10000), 0, 255);
	mapscr *s = tmpscr;
	int32_t ft=0, checkflag; //Flag trigger, checked flag temp. 
	bool putit = true;  //Is set false with a mismatch (illegal value input).
	//Convert a flag type to a secret type. -Z
	switch(ID)
	{
		case mfANYFIRE:
			ft=sBCANDLE;
			break;
			
		case mfSTRONGFIRE:
			ft=sRCANDLE;
			break;
			
		case mfMAGICFIRE:
			ft=sWANDFIRE;
			break;
			
		case mfDIVINEFIRE:
			ft=sDIVINEFIRE;
			break;
			
		case mfARROW:
			ft=sARROW;
			break;
			
		case mfSARROW:
			ft=sSARROW;
			break;
			
		case mfGARROW:
			ft=sGARROW;
			break;
			
		case mfSBOMB:
			ft=sSBOMB;
			break;
			
		case mfBOMB:
			ft=sBOMB;
			break;
			
		case mfBRANG:
			ft=sBRANG;
			break;
			
		case mfMBRANG:
			ft=sMBRANG;
			break;
			
		case mfFBRANG:
			ft=sFBRANG;
			break;
			
		case mfWANDMAGIC:
			ft=sWANDMAGIC;
			break;
			
		case mfREFMAGIC:
			ft=sREFMAGIC;
			break;
			
		case mfREFFIREBALL:
			ft=sREFFIREBALL;
			break;
			
		case mfSWORD:
			ft=sSWORD;
			break;
			
		case mfWSWORD:
			ft=sWSWORD;
			break;
			
		case mfMSWORD:
			ft=sMSWORD;
			break;
			
		case mfXSWORD:
			ft=sXSWORD;
			break;
			
		case mfSWORDBEAM:
			ft=sSWORDBEAM;
			break;
			
		case mfWSWORDBEAM:
			ft=sWSWORDBEAM;
			break;
			
		case mfMSWORDBEAM:
			ft=sMSWORDBEAM;
			break;
			
		case mfXSWORDBEAM:
			ft=sXSWORDBEAM;
			break;
			
		case mfHOOKSHOT:
			ft=sHOOKSHOT;
			break;
			
		case mfWAND:
			ft=sWAND;
			break;
			
		case mfHAMMER:
			ft=sHAMMER;
			break;
			
		case mfSTRIKE:
			ft=sSTRIKE;
			break;
			
		default:
			putit = false;
			break;
	}
	if ( putit )
	{		
		for(int32_t iter=0; iter<2; ++iter)
		{
			for ( int32_t q = 0; q < 176; q++ ) 
			{		
				if(iter==1) checkflag=s->sflag[q]; //Placed
				else checkflag=combobuf[s->data[q]].flag; //Inherent
				Z_message("checkflag is: %d\n", checkflag);
				al_trace("checkflag is: %d\n", checkflag);
				
				Z_message("ID is: %ld\n", ID);
				al_trace("ID is: %d\n", ID);
				//cmbx = COMBOX(q);
				////cmby = COMBOY(q);
				
				//Placed flags
				if ( iter == 1 )
				{
					if ( s->sflag[q] == ID ) {
						screen_combo_modify_preroutine(s,q);
						s->data[q] = s->secretcombo[ft];
						s->cset[q] = s->secretcset[ft];
						s->sflag[q] = s->secretflag[ft];
						// newflag = s->secretflag[ft];
						screen_combo_modify_postroutine(s,q);
					}
				}
				//Inherent flags
				else
				{
					if ( combobuf[s->data[q]].flag == ID ) {
						screen_combo_modify_preroutine(s,q);
						s->data[q] = s->secretcombo[ft];
						s->cset[q] = s->secretcset[ft];
						//s->sflag[q] = s->secretflag[ft];
						screen_combo_modify_postroutine(s,q);
					}
					
				}
			}
		}
	}
	
}
//NPCData

//NPCData Getter Macros


	

//NPCData-> Function
#define GET_NPCDATA_FUNCTION_VAR_INT(member) \
{ \
	int32_t ID = get_register(sarg2) / 10000; \
	if(ID < 1 || ID > (MAXGUYS-1)) \
		set_register(sarg1, -10000); \
	else \
		set_register(sarg1, guysbuf[ID].member * 10000); \
}

#define GET_NPCDATA_FUNCTION_VAR_INDEX(member, indexbound) \
{ \
	int32_t ID = int32_t(ri->d[rINDEX] / 10000);\
	int32_t indx = vbound((ri->d[rINDEX2] / 10000), 0, indexbound); \
	if(ID < 1 || ID > (MAXGUYS-1)) \
		set_register(sarg1, -10000); \
	else \
		set_register(sarg1, guysbuf[ID].member[indx] * 10000); \
}

#define GET_NPCDATA_FUNCTION_VAR_FLAG(member) \
{ \
	int32_t ID = int32_t(ri->d[rINDEX] / 10000);\
	int32_t flag = int32_t(ri->d[rINDEX2] / 10000);\
	if(ID < 1 || ID > (MAXGUYS-1)) \
		set_register(sarg1, -10000); \
	else \
		set_register(sarg1, (guysbuf[ID].member&flag) ? 10000 : 0); \
}

void FFScript::getNPCData_tile(){ GET_NPCDATA_FUNCTION_VAR_INT(tile); } //word
void FFScript::getNPCData_e_height(){ GET_NPCDATA_FUNCTION_VAR_INT(e_height); } 
void FFScript::getNPCData_flags(){ GET_NPCDATA_FUNCTION_VAR_INT(flags); } //word
void FFScript::getNPCData_flags2(){ GET_NPCDATA_FUNCTION_VAR_INT(flags2); } 
void FFScript::getNPCData_width(){ GET_NPCDATA_FUNCTION_VAR_INT(width); } 
void FFScript::getNPCData_height(){ GET_NPCDATA_FUNCTION_VAR_INT(height); } 
void FFScript::getNPCData_s_tile(){ GET_NPCDATA_FUNCTION_VAR_INT(s_tile); } 
void FFScript::getNPCData_s_width(){ GET_NPCDATA_FUNCTION_VAR_INT(s_width); } 
void FFScript::getNPCData_s_height(){ GET_NPCDATA_FUNCTION_VAR_INT(s_height); } 
void FFScript::getNPCData_e_tile(){ GET_NPCDATA_FUNCTION_VAR_INT(e_tile); } 
void FFScript::getNPCData_e_width(){ GET_NPCDATA_FUNCTION_VAR_INT(e_width); } 
void FFScript::getNPCData_hp(){ GET_NPCDATA_FUNCTION_VAR_INT(hp); } 
void FFScript::getNPCData_family(){ GET_NPCDATA_FUNCTION_VAR_INT(family); } 
void FFScript::getNPCData_cset(){ GET_NPCDATA_FUNCTION_VAR_INT(cset); } 
void FFScript::getNPCData_anim(){ GET_NPCDATA_FUNCTION_VAR_INT(anim); } 
void FFScript::getNPCData_e_anim(){ GET_NPCDATA_FUNCTION_VAR_INT(e_anim); } 
void FFScript::getNPCData_frate(){ GET_NPCDATA_FUNCTION_VAR_INT(frate); } 
void FFScript::getNPCData_e_frate(){ GET_NPCDATA_FUNCTION_VAR_INT(e_frate); } 
void FFScript::getNPCData_dp(){ GET_NPCDATA_FUNCTION_VAR_INT(dp); } 
void FFScript::getNPCData_wdp(){ GET_NPCDATA_FUNCTION_VAR_INT(wdp); } 
void FFScript::getNPCData_weapon(){ GET_NPCDATA_FUNCTION_VAR_INT(weapon); } 
void FFScript::getNPCData_rate(){ GET_NPCDATA_FUNCTION_VAR_INT(rate); } 
void FFScript::getNPCData_hrate(){ GET_NPCDATA_FUNCTION_VAR_INT(hrate); } 
void FFScript::getNPCData_step(){ GET_NPCDATA_FUNCTION_VAR_INT(step); } 
void FFScript::getNPCData_homing(){ GET_NPCDATA_FUNCTION_VAR_INT(homing); } 
void FFScript::getNPCData_grumble(){ GET_NPCDATA_FUNCTION_VAR_INT(grumble); } 
void FFScript::getNPCData_item_set(){ GET_NPCDATA_FUNCTION_VAR_INT(item_set); } 
void FFScript::getNPCData_bgsfx(){ GET_NPCDATA_FUNCTION_VAR_INT(bgsfx); } 
void FFScript::getNPCData_hitsfx(){ GET_NPCDATA_FUNCTION_VAR_INT(hitsfx); } 
void FFScript::getNPCData_deadsfx(){ GET_NPCDATA_FUNCTION_VAR_INT(deadsfx); } 
void FFScript::getNPCData_xofs(){ GET_NPCDATA_FUNCTION_VAR_INT(xofs); } 
void FFScript::getNPCData_yofs(){ GET_NPCDATA_FUNCTION_VAR_INT(yofs); } 
void FFScript::getNPCData_zofs(){ GET_NPCDATA_FUNCTION_VAR_INT(zofs); } 
void FFScript::getNPCData_hxofs(){ GET_NPCDATA_FUNCTION_VAR_INT(hxofs); } 
void FFScript::getNPCData_hyofs(){ GET_NPCDATA_FUNCTION_VAR_INT(hyofs); } 
void FFScript::getNPCData_hxsz(){ GET_NPCDATA_FUNCTION_VAR_INT(hxsz); } 
void FFScript::getNPCData_hysz(){ GET_NPCDATA_FUNCTION_VAR_INT(hysz); } 
void FFScript::getNPCData_hzsz(){ GET_NPCDATA_FUNCTION_VAR_INT(hzsz); } 
void FFScript::getNPCData_txsz(){ GET_NPCDATA_FUNCTION_VAR_INT(txsz); } 
void FFScript::getNPCData_tysz(){ GET_NPCDATA_FUNCTION_VAR_INT(tysz); } 
void FFScript::getNPCData_wpnsprite(){ GET_NPCDATA_FUNCTION_VAR_INT(wpnsprite); } 

//NPCData Getters, two inputs, one return, similar to ISSolid

/*

void do_issolid()
{
	int32_t x = int32_t(ri->d[rINDEX] / 10000);
	int32_t y = int32_t(ri->d[rINDEX2] / 10000);
	
	set_register(sarg1, (_walkflag(x, y, 1) ? 10000 : 0));
}

*/






//void FFScript::getNPCData_scriptdefence(){GET_NPCDATA_FUNCTION_VAR_INDEX(scriptdefence)};


void FFScript::getNPCData_defense(){GET_NPCDATA_FUNCTION_VAR_INDEX(defense,int32_t(edefLAST255))};


void FFScript::getNPCData_SIZEflags(){GET_NPCDATA_FUNCTION_VAR_FLAG(SIZEflags);}


void FFScript::getNPCData_misc()
{
	int32_t ID = int32_t(ri->d[rINDEX] / 10000); //the enemy ID value
	int32_t indx = int32_t(ri->d[rINDEX2] / 10000); //the misc index ID
	if ((ID < 1 || ID > 511) || ( indx < 0 || indx > 15 ))
		set_register(sarg1, -10000); 
	switch ( indx )
	{
		case 0: set_register(sarg1, guysbuf[ID].misc1 * 10000); break;
		case 1: set_register(sarg1, guysbuf[ID].misc2 * 10000); break;
		case 2: set_register(sarg1, guysbuf[ID].misc3 * 10000); break;
		case 3: set_register(sarg1, guysbuf[ID].misc4 * 10000); break;
		case 4: set_register(sarg1, guysbuf[ID].misc5 * 10000); break;
		case 5: set_register(sarg1, guysbuf[ID].misc6 * 10000); break;
		case 6: set_register(sarg1, guysbuf[ID].misc7 * 10000); break;
		case 7: set_register(sarg1, guysbuf[ID].misc8 * 10000); break;
		case 8: set_register(sarg1, guysbuf[ID].misc9 * 10000); break;
		case 9: set_register(sarg1, guysbuf[ID].misc10 * 10000); break;
		case 10: set_register(sarg1, guysbuf[ID].misc11 * 10000); break;
		case 11: set_register(sarg1, guysbuf[ID].misc12 * 10000); break;
		case 12: set_register(sarg1, guysbuf[ID].misc13 * 10000); break;
		case 13: set_register(sarg1, guysbuf[ID].misc14 * 10000); break;
		case 14: set_register(sarg1, guysbuf[ID].misc15 * 10000); break;
		default: set_register(sarg1, -10000); break;
	}
}

//NPCData Setters, two inputs, no return; similar to void GetDMapIntro(int32_t DMap, int32_t buffer[]);

/*

void do_getdmapintro(const bool v)
{
	int32_t ID = SH::get_arg(sarg1, v) / 10000;
	int32_t arrayptr = get_register(sarg2) / 10000;
	
	if(BC::checkDMapID(ID, "Game->GetDMapIntro") != SH::_NoError)
		return;
		
	if(ArrayH::setArray(arrayptr, string(DMaps[ID].intro)) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'Game->GetDMapIntro' not large enough\n");
}

*/

//NPCData Setter Macros

//Variables for spritedata sp->member
	
	

//Functions for NPCData->

#define SET_NPCDATA_FUNCTION_VAR_INT(member, bound) \
{ \
	int32_t ID = get_register(sarg1) / 10000; \
	int32_t val = get_register(sarg2) / 10000; \
	if(ID < 1 || ID > (MAXGUYS-1)) \
		set_register(sarg1, -10000); \
	else \
		guysbuf[ID].member = vbound(val,0,bound); \
}



#define SET_NPCDATA_FUNCTION_VAR_INT_NOBOUND(member) \
{ \
	int32_t ID = get_register(sarg1) / 10000; \
	int32_t val = get_register(sarg2) / 10000; \
	if(ID < 1 || ID > (MAXGUYS-1)) \
		set_register(sarg1, -10000); \
	else \
		guysbuf[ID].member = val; \
}


//SET_NPC_VAR_INDEX(member,value)
#define SET_NPCDATA_FUNCTION_VAR_INDEX(member, val, bound, indexbound) \
{ \
	int32_t ID = (ri->d[rINDEX]/10000);  \
	int32_t indx =  vbound((ri->d[rINDEX2]/10000),0,indexbound);  \
	if(ID < 1 || ID > (MAXGUYS-1)) \
		return; \
	else \
		guysbuf[ID].member[indx] = vbound(val,0,bound); \
}

//Special case for flags, three inputs one return
#define SET_NPCDATA_FUNCTION_VAR_FLAG(member, val) \
{ \
	int32_t ID = (ri->d[rINDEX]/10000);  \
	int32_t flag =  (ri->d[rINDEX2]/10000);  \
	if(ID < 1 || ID > (MAXGUYS-1)) \
		return; \
	else \
	{ \
		if ( val != 0 ) guysbuf[ID].member|=flag; \
		else guysbuf[ID].member|= ~flag; \
	}\
}

void FFScript::setNPCData_flags(){SET_NPCDATA_FUNCTION_VAR_INT(flags,ZS_DWORD);} //word
void FFScript::setNPCData_flags2(){SET_NPCDATA_FUNCTION_VAR_INT(flags2,ZS_DWORD);}
void FFScript::setNPCData_width(){SET_NPCDATA_FUNCTION_VAR_INT(width,ZS_BYTE);}
void FFScript::setNPCData_tile(){SET_NPCDATA_FUNCTION_VAR_INT(tile,ZS_WORD);}
void FFScript::setNPCData_e_height(){SET_NPCDATA_FUNCTION_VAR_INT(e_height,ZS_BYTE);}
void FFScript::setNPCData_height(){SET_NPCDATA_FUNCTION_VAR_INT(height,ZS_BYTE);}
void FFScript::setNPCData_s_tile(){SET_NPCDATA_FUNCTION_VAR_INT(s_tile,ZS_WORD);}
void FFScript::setNPCData_s_width(){SET_NPCDATA_FUNCTION_VAR_INT(s_width,ZS_BYTE);}
void FFScript::setNPCData_s_height(){SET_NPCDATA_FUNCTION_VAR_INT(s_height,ZS_BYTE);}
void FFScript::setNPCData_e_tile(){SET_NPCDATA_FUNCTION_VAR_INT(e_tile,ZS_WORD);}
void FFScript::setNPCData_e_width(){SET_NPCDATA_FUNCTION_VAR_INT(e_width,ZS_BYTE);}
void FFScript::setNPCData_hp(){SET_NPCDATA_FUNCTION_VAR_INT(hp,ZS_SHORT);}
void FFScript::setNPCData_family(){SET_NPCDATA_FUNCTION_VAR_INT(family,ZS_SHORT);}
void FFScript::setNPCData_cset(){SET_NPCDATA_FUNCTION_VAR_INT(cset,ZS_SHORT);}
void FFScript::setNPCData_anim(){SET_NPCDATA_FUNCTION_VAR_INT(anim,ZS_SHORT);}
void FFScript::setNPCData_e_anim(){SET_NPCDATA_FUNCTION_VAR_INT(e_anim,ZS_SHORT);}
void FFScript::setNPCData_frate(){SET_NPCDATA_FUNCTION_VAR_INT(frate,ZS_SHORT);}
void FFScript::setNPCData_e_frate(){SET_NPCDATA_FUNCTION_VAR_INT(e_frate,ZS_SHORT);}
void FFScript::setNPCData_dp(){SET_NPCDATA_FUNCTION_VAR_INT(dp,ZS_SHORT);}
void FFScript::setNPCData_wdp(){SET_NPCDATA_FUNCTION_VAR_INT(wdp,ZS_SHORT);}
void FFScript::setNPCData_weapon(){SET_NPCDATA_FUNCTION_VAR_INT(weapon,ZS_SHORT);}
void FFScript::setNPCData_rate(){SET_NPCDATA_FUNCTION_VAR_INT(rate,ZS_SHORT);}
void FFScript::setNPCData_hrate(){SET_NPCDATA_FUNCTION_VAR_INT(hrate,ZS_SHORT);}
void FFScript::setNPCData_step(){SET_NPCDATA_FUNCTION_VAR_INT(step,ZS_SHORT);}
void FFScript::setNPCData_homing(){SET_NPCDATA_FUNCTION_VAR_INT(homing,ZS_SHORT);}
void FFScript::setNPCData_grumble(){SET_NPCDATA_FUNCTION_VAR_INT(grumble,ZS_SHORT);}
void FFScript::setNPCData_item_set(){SET_NPCDATA_FUNCTION_VAR_INT(item_set,ZS_SHORT);}
void FFScript::setNPCData_bgsfx(){SET_NPCDATA_FUNCTION_VAR_INT(bgsfx,ZS_SHORT);}
void FFScript::setNPCData_hitsfx(){SET_NPCDATA_FUNCTION_VAR_INT(hitsfx,ZS_BYTE);}
void FFScript::setNPCData_deadsfx(){SET_NPCDATA_FUNCTION_VAR_INT(deadsfx,ZS_BYTE);}
void FFScript::setNPCData_xofs(){SET_NPCDATA_FUNCTION_VAR_INT_NOBOUND(xofs);}
void FFScript::setNPCData_yofs(){SET_NPCDATA_FUNCTION_VAR_INT_NOBOUND(yofs);}
void FFScript::setNPCData_zofs(){SET_NPCDATA_FUNCTION_VAR_INT_NOBOUND(zofs);}
void FFScript::setNPCData_hxofs(){SET_NPCDATA_FUNCTION_VAR_INT_NOBOUND(hxofs);}
void FFScript::setNPCData_hyofs(){SET_NPCDATA_FUNCTION_VAR_INT_NOBOUND(hyofs);}
void FFScript::setNPCData_hxsz(){SET_NPCDATA_FUNCTION_VAR_INT_NOBOUND(hxsz);}
void FFScript::setNPCData_hysz(){SET_NPCDATA_FUNCTION_VAR_INT_NOBOUND(hysz);}
void FFScript::setNPCData_hzsz(){SET_NPCDATA_FUNCTION_VAR_INT_NOBOUND(hzsz);}
void FFScript::setNPCData_txsz(){SET_NPCDATA_FUNCTION_VAR_INT_NOBOUND(txsz);}
void FFScript::setNPCData_tysz(){SET_NPCDATA_FUNCTION_VAR_INT_NOBOUND(tysz);}
void FFScript::setNPCData_wpnsprite(){SET_NPCDATA_FUNCTION_VAR_INT(wpnsprite,511);}

//NPCData Setters, three inputs, no return. works as SetDMapScreenD function







//void FFScript::setNPCData_scriptdefence(){SET_NPCDATA_FUNCTION_VAR_INDEX(scriptdefence);}
void FFScript::setNPCData_defense(int32_t v){SET_NPCDATA_FUNCTION_VAR_INDEX(defense,v, ZS_INT, int32_t(edefLAST255) );}
void FFScript::setNPCData_SIZEflags(int32_t v){SET_NPCDATA_FUNCTION_VAR_FLAG(SIZEflags,v);}
void FFScript::setNPCData_misc(int32_t val)
{
	int32_t ID = int32_t(ri->d[rINDEX] / 10000); //the enemy ID value
	int32_t indx = int32_t(ri->d[rINDEX2] / 10000); //the misc index ID
	if ((ID < 1 || ID > 511) || ( indx < 0 || indx > 15 )) return;
	switch ( indx )
	{
		case 0: guysbuf[ID].misc1 = val; break;
		case 1: guysbuf[ID].misc2 = val; break;
		case 2: guysbuf[ID].misc3 = val; break;
		case 3: guysbuf[ID].misc4 = val; break;
		case 4: guysbuf[ID].misc5 = val; break;
		case 5: guysbuf[ID].misc6 = val; break;
		case 6: guysbuf[ID].misc7 = val; break;
		case 7: guysbuf[ID].misc8 = val; break;
		case 8: guysbuf[ID].misc9 = val; break;
		case 9: guysbuf[ID].misc10 = val; break;
		case 10: guysbuf[ID].misc11 = val; break;
		case 11: guysbuf[ID].misc12 = val; break;
		case 12: guysbuf[ID].misc13 = val; break;
		case 13: guysbuf[ID].misc14 = val; break;
		case 14: guysbuf[ID].misc15 = val; break;
		default: break;
	}
	
};

//ComboData

//Macros

//Are these right? newcombo is *combo_class_buf and the others are *combobuf

//Getters for ComboData 'Type' submembers. 
#define GET_COMBODATA_TYPE_INT(member) \
{ \
	int32_t ID = vbound((get_register(sarg2) / 10000),0,MAXCOMBOS);\
	set_register(sarg1, combo_class_buf[combobuf[ID].type].member * 10000); \
}

//this may need additional macros. 
//for combo_class_buf[ID].member ?
//I'm not sure which it needs to be at present. 

#define GET_COMBODATA_TYPE_INDEX(member, bound) \
{ \
	int32_t ID = int32_t(vbound((ri->d[rINDEX] / 10000),0,MAXCOMBOS));\
	int32_t indx = int32_t(vbound((ri->d[rINDEX2] / 10000), 0, bound));\
	set_register(sarg1, combo_class_buf[combobuf[ID].type].member[indx] * 10000); \
}

#define GET_COMBODATA_TYPE_FLAG(member) \
{ \
	int32_t ID = int32_t(vbound(ri->d[rINDEX] / 10000),0,MAXCOMBOS);\
	int32_t flag = int32_t(ri->d[rINDEX2] / 10000);\
	set_register(sarg1, (combo_class_buf[combobuf[ID].type].member&flag) ? 10000 : 0); \
}



//Getters for ComboData main members. 
#define GET_COMBODATA_VAR_INT(member) \
{ \
	int32_t ID = vbound( (get_register(sarg2) / 10000), 0, MAXCOMBOS);\
	set_register(sarg1, combobuf[ID].member * 10000); \
}

#define GET_COMBODATA_VAR_INDEX(member, bound) \
{ \
	int32_t ID = int32_t( vbound( (ri->d[rINDEX] / 10000),0,MAXCOMBOS) );\
	int32_t indx = int32_t ( vbound( (ri->d[rINDEX2] / 10000),0,bound) );\
	set_register(sarg1, combobuf[ID].member[indx] * 10000); \
}

#define GET_COMBODATA_VAR_FLAG(member) \
{ \
	int32_t ID = int32_t( vbound( ( ri->d[rINDEX] / 10000),0,MAXCOMBOS) );\
	int32_t flag = int32_t(ri->d[rINDEX2] / 10000);\
	set_register(sarg1, (combobuf[ID].member&flag) ? 10000 : 0); \
}



//ComboData Setter Macros

//Setters for ComboData 'type' submembers.
#define SET_COMBODATA_TYPE_INT(member, bound) \
{ \
	int32_t ID = get_register(sarg1) / 10000; \
	int32_t val = vbound( (get_register(sarg2) / 10000), 0, bound); \
	if(ID < 1 || ID > 511) \
		set_register(sarg1, -10000); \
	else \
		combo_class_buf[combobuf[ID].type].member = val; \
}

#define SET_COMBODATA_TYPE_INDEX(member, val, bound, indexbound) \
{ \
	int32_t ID = vbound((ri->d[rINDEX]/10000),0,MAXCOMBOS);  \
	int32_t indx =  vbound((ri->d[rINDEX2]/10000),0,indexbound);  \
	combo_class_buf[combobuf[ID].type].member[indx] = vbound(val,0,bound); \
}

#define SET_COMBODATA_TYPE_FLAG(member, val, bound) \
{ \
	int32_t ID = vbound((ri->d[rINDEX]/10000),0,MAXCOMBOS);  \
	int32_t flag =  (ri->d[rINDEX2]/10000);  \
	combo_class_buf[combobuf[ID].type].member&flag = ((vbound(val,0,bound))!=0); \
 \


//Setters for ComboData main members
#define SET_COMBODATA_VAR_INT(member, bound) \
{ \
	int32_t ID = vbound( (get_register(sarg1) / 10000), 0, MAXCOMBOS); \
	int32_t val = vbound((get_register(sarg2) / 10000),0,bound); \
	combobuf[ID].member = val; \
}

//SET_NPC_VAR_INDEX(member,value)
#define SET_COMBODATA_VAR_INDEX(member, val, bound, indexbound) \
{ \
	int32_t ID = vbound((ri->d[rINDEX]/10000),0,MAXCOMBOS);  \
	int32_t indx =  vbound((ri->d[rINDEX2]/10000),0,indexbound);  \
	combobuf[ID].member[indx] = vbound(val,0,bound); \
}

//Special case for flags, three inputs one return
#define SET_COMBODATA_VAR_FLAG(member, val, bound) \
{ \
	int32_t ID = vbound((ri->d[rINDEX]/10000),0,MAXCOMBOS);  \
	int32_t flag =  (ri->d[rINDEX2]/10000);  \
	else \
	{ \
		combobuf[ID].member&flag = ((bvound(val,0,bound))!=0); \
	}\
}

//Getters

//one input, one return
void FFScript::getComboData_block_enemies(){ GET_COMBODATA_TYPE_INT(block_enemies); } //byte a
void FFScript::getComboData_block_hole(){ GET_COMBODATA_TYPE_INT(block_hole); } //byte b
void FFScript::getComboData_block_trigger(){ GET_COMBODATA_TYPE_INT(block_trigger); } //byte c
void FFScript::getComboData_conveyor_x_speed(){ GET_COMBODATA_TYPE_INT(conveyor_x_speed); } //int16_t e
void FFScript::getComboData_conveyor_y_speed(){ GET_COMBODATA_TYPE_INT(conveyor_y_speed); } //int16_t f
void FFScript::getComboData_create_enemy(){ GET_COMBODATA_TYPE_INT(create_enemy); } //word g
void FFScript::getComboData_create_enemy_when(){ GET_COMBODATA_TYPE_INT(create_enemy_when); } //byte h
void FFScript::getComboData_create_enemy_change(){ GET_COMBODATA_TYPE_INT(create_enemy_change); } //int32_t i
void FFScript::getComboData_directional_change_type(){ GET_COMBODATA_TYPE_INT(directional_change_type); } //byte j
void FFScript::getComboData_distance_change_tiles(){ GET_COMBODATA_TYPE_INT(distance_change_tiles); } //int32_t k
void FFScript::getComboData_dive_item(){ GET_COMBODATA_TYPE_INT(dive_item); } //int16_t l
void FFScript::getComboData_dock(){ GET_COMBODATA_TYPE_INT(dock); } //byte m
void FFScript::getComboData_fairy(){ GET_COMBODATA_TYPE_INT(fairy); } //byte n
void FFScript::getComboData_ff_combo_attr_change(){ GET_COMBODATA_TYPE_INT(ff_combo_attr_change); } //byte o
void FFScript::getComboData_foot_decorations_tile(){ GET_COMBODATA_TYPE_INT(foot_decorations_tile); } //int32_t p
void FFScript::getComboData_foot_decorations_type(){ GET_COMBODATA_TYPE_INT(foot_decorations_type); } //byte q
void FFScript::getComboData_hookshot_grab_point(){ GET_COMBODATA_TYPE_INT(hookshot_grab_point); } //byte r
void FFScript::getComboData_ladder_pass(){ GET_COMBODATA_TYPE_INT(ladder_pass); } //byte s
void FFScript::getComboData_lock_block_type(){ GET_COMBODATA_TYPE_INT(lock_block_type); } //byte t
void FFScript::getComboData_lock_block_change(){ GET_COMBODATA_TYPE_INT(lock_block_change); } //int32_t u
void FFScript::getComboData_magic_mirror_type(){ GET_COMBODATA_TYPE_INT(magic_mirror_type); } //byte v
void FFScript::getComboData_modify_hp_amount(){ GET_COMBODATA_TYPE_INT(modify_hp_amount); } //int16_t w
void FFScript::getComboData_modify_hp_delay(){ GET_COMBODATA_TYPE_INT(modify_hp_delay); } //byte x
void FFScript::getComboData_modify_hp_type(){ GET_COMBODATA_TYPE_INT(modify_hp_type); } //byte y
void FFScript::getComboData_modify_mp_amount(){ GET_COMBODATA_TYPE_INT(modify_mp_amount); } //int16_t z
void FFScript::getComboData_modify_mp_delay(){ GET_COMBODATA_TYPE_INT(modify_mp_delay); } //byte aa
void FFScript::getComboData_modify_mp_type(){ GET_COMBODATA_TYPE_INT(modify_mp_type); } //byte ab
void FFScript::getComboData_no_push_blocks(){ GET_COMBODATA_TYPE_INT(no_push_blocks); } //byte ac
void FFScript::getComboData_overhead(){ GET_COMBODATA_TYPE_INT(overhead); } //byte ad
void FFScript::getComboData_place_enemy(){ GET_COMBODATA_TYPE_INT(place_enemy); } //byte ae
void FFScript::getComboData_push_direction(){ GET_COMBODATA_TYPE_INT(push_direction); } //byte af
void FFScript::getComboData_push_weight(){ GET_COMBODATA_TYPE_INT(push_weight); } //byte ag  heavy or not
void FFScript::getComboData_push_wait(){ GET_COMBODATA_TYPE_INT(push_wait); } //byte ah
void FFScript::getComboData_pushed(){ GET_COMBODATA_TYPE_INT(pushed); } //byte ai
void FFScript::getComboData_raft(){ GET_COMBODATA_TYPE_INT(raft); } //byte aj
void FFScript::getComboData_reset_room(){ GET_COMBODATA_TYPE_INT(reset_room); } //byte ak
void FFScript::getComboData_save_point_type(){ GET_COMBODATA_TYPE_INT(save_point_type); } //byte al
void FFScript::getComboData_screen_freeze_type(){ GET_COMBODATA_TYPE_INT(screen_freeze_type); } //byte am

void FFScript::getComboData_secret_combo(){ GET_COMBODATA_TYPE_INT(secret_combo); } //byte an
void FFScript::getComboData_singular(){ GET_COMBODATA_TYPE_INT(singular); } //byte ao
void FFScript::getComboData_slow_movement(){ GET_COMBODATA_TYPE_INT(slow_movement); } //byte ap
void FFScript::getComboData_statue_type(){ GET_COMBODATA_TYPE_INT(statue_type); } //byte aq
void FFScript::getComboData_step_type(){ GET_COMBODATA_TYPE_INT(step_type); } //byte ar
void FFScript::getComboData_step_change_to(){ GET_COMBODATA_TYPE_INT(step_change_to); } //int32_t as
void FFScript::getComboData_strike_remnants(){ GET_COMBODATA_TYPE_INT(strike_remnants); } //int32_t au
void FFScript::getComboData_strike_remnants_type(){ GET_COMBODATA_TYPE_INT(strike_remnants_type); } //byte av
void FFScript::getComboData_strike_change(){ GET_COMBODATA_TYPE_INT(strike_change); } //int32_t aw
void FFScript::getComboData_strike_item(){ GET_COMBODATA_TYPE_INT(strike_item); } //int16_t ax
void FFScript::getComboData_touch_item(){ GET_COMBODATA_TYPE_INT(touch_item); } //int16_t ay
void FFScript::getComboData_touch_stairs(){ GET_COMBODATA_TYPE_INT(touch_stairs); } //byte az
void FFScript::getComboData_trigger_type(){ GET_COMBODATA_TYPE_INT(trigger_type); } //byte ba
void FFScript::getComboData_trigger_sensitive(){ GET_COMBODATA_TYPE_INT(trigger_sensitive); } //byte bb
void FFScript::getComboData_warp_type(){ GET_COMBODATA_TYPE_INT(warp_type); } //byte bc
void FFScript::getComboData_warp_sensitive(){ GET_COMBODATA_TYPE_INT(warp_sensitive); } //byte bd
void FFScript::getComboData_warp_direct(){ GET_COMBODATA_TYPE_INT(warp_direct); } //byte be
void FFScript::getComboData_warp_location(){ GET_COMBODATA_TYPE_INT(warp_location); } //byte bf
void FFScript::getComboData_water(){ GET_COMBODATA_TYPE_INT(water); } //byte bg
void FFScript::getComboData_whistle(){ GET_COMBODATA_TYPE_INT(whistle); } //byte bh
void FFScript::getComboData_win_game(){ GET_COMBODATA_TYPE_INT(win_game); } //byte bi
void FFScript::getComboData_block_weapon_lvl(){ GET_COMBODATA_TYPE_INT(block_weapon_lvl); } //byte bj - max level of weapon to block

void FFScript::getComboData_tile(){ GET_COMBODATA_VAR_INT(tile); } //newcombo, word
void FFScript::getComboData_flip(){ GET_COMBODATA_VAR_INT(flip); } //newcombo byte

void FFScript::getComboData_walk(){ GET_COMBODATA_VAR_INT(walk); } //newcombo byte
void FFScript::getComboData_type(){ GET_COMBODATA_VAR_INT(type); } //newcombo byte
void FFScript::getComboData_csets(){ GET_COMBODATA_VAR_INT(csets); } //newcombo byte
void FFScript::getComboData_frames(){ GET_COMBODATA_VAR_INT(frames); } //newcombo byte
void FFScript::getComboData_speed(){ GET_COMBODATA_VAR_INT(speed); } //newcombo byte
void FFScript::getComboData_nextcombo(){ GET_COMBODATA_VAR_INT(nextcombo); } //newcombo word
void FFScript::getComboData_nextcset(){ GET_COMBODATA_VAR_INT(nextcset); } //newcombo byte
void FFScript::getComboData_flag(){ GET_COMBODATA_VAR_INT(flag); } //newcombo byte
void FFScript::getComboData_skipanim(){ GET_COMBODATA_VAR_INT(skipanim); } //newcombo byte
void FFScript::getComboData_nexttimer(){ GET_COMBODATA_VAR_INT(nexttimer); } //newcombo word
void FFScript::getComboData_skipanimy(){ GET_COMBODATA_VAR_INT(skipanimy); } //newcombo byte
void FFScript::getComboData_animflags(){ GET_COMBODATA_VAR_INT(animflags); } //newcombo byte


//two inputs, one return
void FFScript::getComboData_block_weapon(){ GET_COMBODATA_TYPE_INDEX(block_weapon,32); } //byte array[32] d (ID of LWeapon)
void FFScript::getComboData_expansion(){ GET_COMBODATA_VAR_INDEX(expansion,6); } //newcombo byte, arr[6]
void FFScript::getComboData_strike_weapons(){ GET_COMBODATA_TYPE_INDEX(strike_weapons,32); } //byte at, arr[32]

//Setters, two inputs no returns

void FFScript::setComboData_block_enemies(){ SET_COMBODATA_TYPE_INT(block_enemies,ZS_BYTE); } //byte a
void FFScript::setComboData_block_hole(){ SET_COMBODATA_TYPE_INT(block_hole,ZS_BYTE); } //byte b
void FFScript::setComboData_block_trigger(){ SET_COMBODATA_TYPE_INT(block_trigger,ZS_BYTE); } //byte c
void FFScript::setComboData_conveyor_x_speed(){ SET_COMBODATA_TYPE_INT(conveyor_x_speed,ZS_SHORT); } //int16_t e
void FFScript::setComboData_conveyor_y_speed(){ SET_COMBODATA_TYPE_INT(conveyor_y_speed,ZS_SHORT); } //int16_t f
void FFScript::setComboData_create_enemy(){ SET_COMBODATA_TYPE_INT(create_enemy,ZS_WORD); } //word g
void FFScript::setComboData_create_enemy_when(){ SET_COMBODATA_TYPE_INT(create_enemy_when,ZS_BYTE); } //byte h
void FFScript::setComboData_create_enemy_change(){ SET_COMBODATA_TYPE_INT(create_enemy_change,ZS_LONG); } //int32_t i
void FFScript::setComboData_directional_change_type(){ SET_COMBODATA_TYPE_INT(directional_change_type,ZS_BYTE); } //byte j
void FFScript::setComboData_distance_change_tiles(){ SET_COMBODATA_TYPE_INT(distance_change_tiles,ZS_LONG); } //int32_t k
void FFScript::setComboData_dive_item(){ SET_COMBODATA_TYPE_INT(dive_item,ZS_SHORT); } //int16_t l
void FFScript::setComboData_dock(){ SET_COMBODATA_TYPE_INT(dock,ZS_BYTE); } //byte m
void FFScript::setComboData_fairy(){ SET_COMBODATA_TYPE_INT(fairy,ZS_BYTE); } //byte n
void FFScript::setComboData_ff_combo_attr_change(){ SET_COMBODATA_TYPE_INT(ff_combo_attr_change,ZS_BYTE); } //byte o
void FFScript::setComboData_foot_decorations_tile(){ SET_COMBODATA_TYPE_INT(foot_decorations_tile,ZS_LONG); } //int32_t p
void FFScript::setComboData_foot_decorations_type(){ SET_COMBODATA_TYPE_INT(foot_decorations_type,ZS_BYTE); } //byte q
void FFScript::setComboData_hookshot_grab_point(){ SET_COMBODATA_TYPE_INT(hookshot_grab_point,ZS_BYTE); } //byte r
void FFScript::setComboData_ladder_pass(){ SET_COMBODATA_TYPE_INT(ladder_pass,ZS_BYTE); } //byte s
void FFScript::setComboData_lock_block_type(){ SET_COMBODATA_TYPE_INT(lock_block_type,ZS_BYTE); } //byte t
void FFScript::setComboData_lock_block_change(){ SET_COMBODATA_TYPE_INT(lock_block_change,ZS_LONG); } //int32_t u
void FFScript::setComboData_magic_mirror_type(){ SET_COMBODATA_TYPE_INT(magic_mirror_type,ZS_BYTE); } //byte v
void FFScript::setComboData_modify_hp_amount(){ SET_COMBODATA_TYPE_INT(modify_hp_amount,ZS_SHORT); } //int16_t w
void FFScript::setComboData_modify_hp_delay(){ SET_COMBODATA_TYPE_INT(modify_hp_delay,ZS_BYTE); } //byte x
void FFScript::setComboData_modify_hp_type(){ SET_COMBODATA_TYPE_INT(modify_hp_type,ZS_BYTE); } //byte y
void FFScript::setComboData_modify_mp_amount(){ SET_COMBODATA_TYPE_INT(modify_mp_amount,ZS_SHORT); } //int16_t z
void FFScript::setComboData_modify_mp_delay(){ SET_COMBODATA_TYPE_INT(modify_mp_delay,ZS_BYTE); } //byte aa
void FFScript::setComboData_modify_mp_type(){ SET_COMBODATA_TYPE_INT(modify_mp_type,ZS_BYTE); } //byte ab
void FFScript::setComboData_no_push_blocks(){ SET_COMBODATA_TYPE_INT(no_push_blocks,ZS_BYTE); } //byte ac
void FFScript::setComboData_overhead(){ SET_COMBODATA_TYPE_INT(overhead,ZS_BYTE); } //byte ad
void FFScript::setComboData_place_enemy(){ SET_COMBODATA_TYPE_INT(place_enemy,ZS_BYTE); } //byte ae
void FFScript::setComboData_push_direction(){ SET_COMBODATA_TYPE_INT(push_direction,ZS_BYTE); } //byte af
void FFScript::setComboData_push_weight(){ SET_COMBODATA_TYPE_INT(push_weight,ZS_BYTE); } //byte ag  heavy or not
void FFScript::setComboData_push_wait(){ SET_COMBODATA_TYPE_INT(push_wait,ZS_BYTE); } //byte ah
void FFScript::setComboData_pushed(){ SET_COMBODATA_TYPE_INT(pushed,ZS_BYTE); } //byte ai
void FFScript::setComboData_raft(){ SET_COMBODATA_TYPE_INT(raft,ZS_BYTE); } //byte aj
void FFScript::setComboData_reset_room(){ SET_COMBODATA_TYPE_INT(reset_room,ZS_BYTE); } //byte ak
void FFScript::setComboData_save_point_type(){ SET_COMBODATA_TYPE_INT(save_point_type,ZS_BYTE); } //byte al
void FFScript::setComboData_screen_freeze_type(){ SET_COMBODATA_TYPE_INT(screen_freeze_type,ZS_BYTE); } //byte am

void FFScript::setComboData_secret_combo(){ SET_COMBODATA_TYPE_INT(secret_combo,ZS_BYTE); } //byte an
void FFScript::setComboData_singular(){ SET_COMBODATA_TYPE_INT(singular,ZS_BYTE); } //byte ao
void FFScript::setComboData_slow_movement(){ SET_COMBODATA_TYPE_INT(slow_movement,ZS_BYTE); } //byte ap
void FFScript::setComboData_statue_type(){ SET_COMBODATA_TYPE_INT(statue_type,ZS_BYTE); } //byte aq
void FFScript::setComboData_step_type(){ SET_COMBODATA_TYPE_INT(step_type,ZS_BYTE); } //byte ar
void FFScript::setComboData_step_change_to(){ SET_COMBODATA_TYPE_INT(step_change_to,ZS_LONG); } //int32_t as

void FFScript::setComboData_strike_remnants(){ SET_COMBODATA_TYPE_INT(strike_remnants,ZS_LONG); } //int32_t au
void FFScript::setComboData_strike_remnants_type(){ SET_COMBODATA_TYPE_INT(strike_remnants_type,ZS_BYTE); } //byte av
void FFScript::setComboData_strike_change(){ SET_COMBODATA_TYPE_INT(strike_change,ZS_LONG); } //int32_t aw
void FFScript::setComboData_strike_item(){ SET_COMBODATA_TYPE_INT(strike_item,ZS_SHORT); } //int16_t ax
void FFScript::setComboData_touch_item(){ SET_COMBODATA_TYPE_INT(touch_item,ZS_SHORT); } //int16_t ay
void FFScript::setComboData_touch_stairs(){ SET_COMBODATA_TYPE_INT(touch_stairs,ZS_BYTE); } //byte az
void FFScript::setComboData_trigger_type(){ SET_COMBODATA_TYPE_INT(trigger_type,ZS_BYTE); } //byte ba
void FFScript::setComboData_trigger_sensitive(){ SET_COMBODATA_TYPE_INT(trigger_sensitive,ZS_BYTE); } //byte bb
void FFScript::setComboData_warp_type(){ SET_COMBODATA_TYPE_INT(warp_type,ZS_BYTE); } //byte bc
void FFScript::setComboData_warp_sensitive(){ SET_COMBODATA_TYPE_INT(warp_sensitive,ZS_BYTE); } //byte bd
void FFScript::setComboData_warp_direct(){ SET_COMBODATA_TYPE_INT(warp_direct,ZS_BYTE); } //byte be
void FFScript::setComboData_warp_location(){ SET_COMBODATA_TYPE_INT(warp_location,ZS_BYTE); } //byte bf
void FFScript::setComboData_water(){ SET_COMBODATA_TYPE_INT(water,ZS_BYTE); } //byte bg
void FFScript::setComboData_whistle(){ SET_COMBODATA_TYPE_INT(whistle,ZS_BYTE); } //byte bh
void FFScript::setComboData_win_game(){ SET_COMBODATA_TYPE_INT(win_game,ZS_BYTE); } //byte bi
void FFScript::setComboData_block_weapon_lvl(){ SET_COMBODATA_TYPE_INT(block_weapon_lvl,ZS_BYTE); } //byte bj - max level of weapon to block

//combobuf
void FFScript::setComboData_tile(){ SET_COMBODATA_VAR_INT(tile,ZS_WORD); } //newcombo, word
void FFScript::setComboData_flip(){ SET_COMBODATA_VAR_INT(flip,ZS_BYTE); } //newcombo byte

void FFScript::setComboData_walk(){ SET_COMBODATA_VAR_INT(walk,ZS_BYTE); } //newcombo byte
void FFScript::setComboData_type(){ SET_COMBODATA_VAR_INT(type,ZS_BYTE); } //newcombo byte
void FFScript::setComboData_csets(){ SET_COMBODATA_VAR_INT(csets,ZS_BYTE); } //newcombo byte
void FFScript::setComboData_frames(){ SET_COMBODATA_VAR_INT(frames,ZS_BYTE); } //newcombo byte
void FFScript::setComboData_speed(){ SET_COMBODATA_VAR_INT(speed,ZS_BYTE); } //newcombo byte
void FFScript::setComboData_nextcombo(){ SET_COMBODATA_VAR_INT(nextcombo,ZS_WORD); } //newcombo word
void FFScript::setComboData_nextcset(){ SET_COMBODATA_VAR_INT(nextcset,ZS_BYTE); } //newcombo byte
void FFScript::setComboData_flag(){ SET_COMBODATA_VAR_INT(flag,ZS_BYTE); } //newcombo byte
void FFScript::setComboData_skipanim(){ SET_COMBODATA_VAR_INT(skipanim,ZS_BYTE); } //newcombo byte
void FFScript::setComboData_nexttimer(){ SET_COMBODATA_VAR_INT(nexttimer,ZS_WORD); } //newcombo word
void FFScript::setComboData_skipanimy(){ SET_COMBODATA_VAR_INT(skipanimy,ZS_BYTE); } //newcombo byte
void FFScript::setComboData_animflags(){ SET_COMBODATA_VAR_INT(animflags,ZS_BYTE); } //newcombo byte

//three inputs, no returns
void FFScript::setComboData_block_weapon(int32_t v){ SET_COMBODATA_TYPE_INDEX(block_weapon,v,ZS_BYTE,32); } //byte array[32] d (ID of LWeapon)
void FFScript::setComboData_strike_weapons(int32_t v){ SET_COMBODATA_TYPE_INDEX(strike_weapons,v,ZS_BYTE,32); } //byte at, arr[32]
void FFScript::setComboData_expansion(int32_t v){ SET_COMBODATA_VAR_INDEX(expansion,v,ZS_BYTE,6); } //newcombo byte, arr[6]

//SpriteData Macros
#define GET_SPRITEDATA_TYPE_INT(member) \
{ \
	int32_t ID = vbound((get_register(sarg2) / 10000),0,255);\
	set_register(sarg1, wpnsbuf[ID].member * 10000); \
}

#define SET_SPRITEDATA_TYPE_INT(member, bound) \
{ \
	int32_t ID = get_register(sarg1) / 10000; \
	int32_t val = vbound( (get_register(sarg2) / 10000), 0, bound); \
	if(ID < 1 || ID > 255) \
		set_register(sarg1, -10000); \
	else \
		wpnsbuf[ID].member = val; \
}

#define SET_SPRITEDATA_TYPE_INT_NOBOUND(member) \
{ \
	int32_t ID = get_register(sarg1) / 10000; \
	int32_t val = get_register(sarg2) / 10000; \
	if(ID < 1 || ID > 255) \
		set_register(sarg1, -10000); \
	else \
		wpnsbuf[ID].member = val; \
}


void FFScript::getSpriteDataTile(){GET_SPRITEDATA_TYPE_INT(tile);}
void FFScript::getSpriteDataMisc(){GET_SPRITEDATA_TYPE_INT(misc);}
void FFScript::getSpriteDataCSets(){GET_SPRITEDATA_TYPE_INT(csets);}
void FFScript::getSpriteDataFrames(){GET_SPRITEDATA_TYPE_INT(frames);}
void FFScript::getSpriteDataSpeed(){GET_SPRITEDATA_TYPE_INT(speed);}
void FFScript::getSpriteDataType(){GET_SPRITEDATA_TYPE_INT(type);}
//void FFScript::getSpriteDataString();



void FFScript::setSpriteDataTile(){SET_SPRITEDATA_TYPE_INT(tile,ZS_WORD);}
void FFScript::setSpriteDataMisc(){SET_SPRITEDATA_TYPE_INT(misc,ZS_CHAR);}
void FFScript::setSpriteDataCSets(){SET_SPRITEDATA_TYPE_INT(csets,ZS_CHAR);}
void FFScript::setSpriteDataFrames(){SET_SPRITEDATA_TYPE_INT(frames,ZS_CHAR);}
void FFScript::setSpriteDataSpeed(){SET_SPRITEDATA_TYPE_INT(speed,ZS_CHAR);}
void FFScript::setSpriteDataType(){SET_SPRITEDATA_TYPE_INT(type,ZS_CHAR);}
//void FFScript::setSpriteDataString();


void FFScript::do_setMIDI_volume(int32_t m)
{
	master_volume(-1,(vbound(m,0,255)));
}
void FFScript::do_setMusic_volume(int32_t m)
{
	emusic_volume = vbound(m,0,255);
}
void FFScript::do_setDIGI_volume(int32_t m)
{
	master_volume((vbound(m,0,255)),-1);
}
void FFScript::do_setSFX_volume(int32_t m)
{
	sfx_volume = m;
}
void FFScript::do_setSFX_pan(int32_t m)
{
	pan_style = vbound(m,0,3);
}
int32_t FFScript::do_getMIDI_volume()
{
	return ((int32_t)midi_volume);
}
int32_t FFScript::do_getMusic_volume()
{
	return ((int32_t)emusic_volume);
}
int32_t FFScript::do_getDIGI_volume()
{
	return ((int32_t)digi_volume);
}
int32_t FFScript::do_getSFX_volume()
{
	return ((int32_t)sfx_volume);
}
int32_t FFScript::do_getSFX_pan()
{
	return ((int32_t)pan_style);
}


//Change Game Over Screen Values
void FFScript::FFSetSaveScreenSetting() 
{
	
	int32_t indx = get_register(sarg1) / 10000; 
	int32_t value = get_register(sarg2) / 10000; //bounded in zelda.cpp 
	if(indx < 0 || indx > 11) 
		set_register(sarg1, -10000); 
	else 
		SetSaveScreenSetting(indx, value); 
}
	
	
	
void FFScript::FFChangeSubscreenText() 
{ 
	
	int32_t index = get_register(sarg1) / 10000;
	int32_t arrayptr = get_register(sarg2) / 10000;
	
	if ( index < 0 || index > 3 ) 
	{
		al_trace("The index supplied to Game->SetSubscreenText() is invalid. The index specified was: %d /n", index);
		return;
	}

	string filename_str;

		
		
	ArrayH::getString(arrayptr, filename_str, 73);
	ChangeSubscreenText(index,filename_str.c_str());
	
	//newtext[32]='\0';
	
	
	
}

void FFScript::do_typedpointer_typecast(const bool v)
{
	 int32_t ptr = SH::get_arg(sarg1, v);
	 set_register(sarg1, ptr);
}

void FFScript::SetItemMessagePlayed(int32_t itm)
{
	game->item_messages_played[itm] = 1;
}
bool FFScript::GetItemMessagePlayed(int32_t itm)
{
	return ((game->item_messages_played[itm] ) ? true : false);
}

int32_t FFScript::getQRBit(int32_t rule)
{
	return ( get_qr(rule) ? 1 : 0 );
}

void FFScript::setHeroAction(int32_t a)
{
	FF_hero_action = vbound(a, 0, 255);
}

int32_t FFScript::getHeroAction()
{
	int32_t special_action = Hero.getAction2();
	if ( special_action != -1 ) return special_action; //spin, dive, charge
	else return FF_hero_action; //everything else
}
//get_bit

int32_t FFScript::GetScriptObjectUID(int32_t type)
{
	++script_UIDs[type];
	return script_UIDs[type];
}

void FFScript::init()
{
	eventData.clear();
	countGenScripts();
	for ( int32_t q = 0; q < wexLast; q++ ) warpex[q] = 0;
	
	temp_no_stepforward = 0;
	nostepforward = 0;
	
	can_neg_array = !get_qr(qr_ZS_NO_NEG_ARRAY);
	
	numscriptdraws = 0;
	skipscriptdraws = false;
	max_ff_rules = qr_MAX;
	coreflags = 0;
	skip_ending_credits = 0;
	music_update_cond = 0;
	music_update_flags = 0;
	//quest_format : is this properly initialised?
	for ( int32_t q = 0; q < susptLAST; q++ ) { system_suspend[q] = 0; }
	for ( int32_t q = 0; q < UID_TYPES; ++q ) { script_UIDs[q] = 0; }
	//for ( int32_t q = 0; q < 512; q++ ) FF_rules[q] = 0;

	usr_midi_volume = midi_volume;
	usr_digi_volume = digi_volume;
	usr_sfx_volume = sfx_volume;
	usr_music_volume = emusic_volume;

	usr_panstyle = pan_style;
	FF_hero_action = 0;
	enemy_removal_point[spriteremovalY1] = -32767;
	enemy_removal_point[spriteremovalY2] = 32767;
	enemy_removal_point[spriteremovalX1] = -32767;
	enemy_removal_point[spriteremovalX2] = 32767;
	enemy_removal_point[spriteremovalZ1] = -32767;
	enemy_removal_point[spriteremovalZ2] = 32767;
	
	//Clear internal arrays for use by <std>, <ghost>, <tango>
	for ( int32_t q = 0; q < 256; ++q )
	{
		StdArray[q] = 0;
		GhostArray[q] = 0;
		TangoArray[q] = 0;
	}
		
	for ( int32_t q = 0; q < 4; q++ ) 
	{
		FF_screenbounds[q] = 0;
		FF_screen_dimensions[q] = 0;
		FF_subscreen_dimensions[q] = 0;
		FF_eweapon_removal_bounds[q] = 0; 
		FF_lweapon_removal_bounds[q] = 0;
	}
	for ( int32_t q = 0; q < FFSCRIPTCLASS_CLOCKS; q++ )
	{
		FF_clocks[q] = 0;
	}
	for ( int32_t q = 0; q < SCRIPT_DRAWING_RULES; q++ )
	{
		ScriptDrawingRules[q] = 0;
	}
	for ( int32_t q = 0; q < NUM_USER_MIDI_OVERRIDES; q++ ) 
	{
		FF_UserMidis[q] = 0;
	}
	subscreen_scroll_speed = 0; //make a define for a default and read quest override! -Z
	kb_typing_mode = false;
	initIncludePaths();
	initRunString();
	//clearRunningItemScripts();
	tempScreens[0] = tmpscr;
	ScrollingScreens[0] = tmpscr+1;
	for(int32_t q = 0; q < 6; ++q)
	{
		tempScreens[q+1] = tmpscr2+q;
		ScrollingScreens[q+1] = tmpscr3+q;
	}
	ScrollingData[SCROLLDATA_DIR] = -1;
	ScrollingData[SCROLLDATA_NX] = 0;
	ScrollingData[SCROLLDATA_NY] = 0;
	ScrollingData[SCROLLDATA_OX] = 0;
	ScrollingData[SCROLLDATA_OY] = 0;
	user_rng_init();
	clear_script_engine_data();
	for (auto &it : jitted_scripts)
	{
		if (it.second) jit_delete_script_handle(it.second);
	}
	jitted_scripts.clear();
	script_debug_handles.clear();
	runtime_script_debug_handle = nullptr;
}

void FFScript::shutdown()
{
	for (auto &it : jitted_scripts)
	{
		if (it.second) jit_delete_script_handle(it.second);
	}
	jitted_scripts.clear();
	objectRAM.clear();
	script_objects.clear();
}


void FFScript::SetFFEngineFlag(int32_t flag, bool state)
{
	if ( state ) { coreflags |= flag; }
	else coreflags &= ~flag;
}

void FFScript::setSubscreenScrollSpeed(byte n)
{
	subscreen_scroll_speed = n;
}

int32_t FFScript::getSubscreenScrollSpeed()
{
	return (int32_t)subscreen_scroll_speed;
}

void FFScript::do_greyscale(const bool v)
{
	bool on = (SH::get_arg(sarg1, v)) != 0;
	setMonochrome(on);
}

void FFScript::do_monochromatic(const bool v)
{
	int32_t colour = SH::get_arg(sarg1, v)/10000;
	setMonochromatic(colour);
}

void FFScript::gfxmonohue()
{
	int32_t _r   = SH::read_stack(ri->sp + 3) / 10000;
	int32_t _g = SH::read_stack(ri->sp + 2) / 10000;
	int32_t _b   = SH::read_stack(ri->sp + 1) / 10000;
	bool m   = (SH::read_stack(ri->sp + 0) / 10000);
	doGFXMonohue(_r,_g,_b,m);
}

void FFScript::clearTint()
{
	doClearTint();
}

void FFScript::Tint()
{
	int32_t _r   = SH::read_stack(ri->sp + 2) / 10000;
	int32_t _g = SH::read_stack(ri->sp + 1) / 10000;
	int32_t _b   = SH::read_stack(ri->sp + 0) / 10000;
	doTint(_r,_g,_b);
}

void FFScript::do_fx_zap(const bool v)
{
	int32_t out = SH::get_arg(sarg1, v);

	if ( out ) { FFScript::do_zapout(); } 
	else FFScript::do_zapin();
}

void FFScript::do_fx_wavy(const bool v)
{
	int32_t out = SH::get_arg(sarg1, v);

	if ( out ) { FFScript::do_wavyout(); } 
	else FFScript::do_wavyin();
}

int32_t FFScript::getQuestHeaderInfo(int32_t type)
{
	return quest_format[type];
}

string get_filestr(const bool relative) //Used for 'FileSystem' functions.
{
	int32_t strptr = get_register(sarg1)/10000;
	string the_string;
	ArrayH::getString(strptr, the_string, 512);
	the_string = the_string.substr(the_string.find_first_not_of('/'),string::npos); //Kill leading '/'
	size_t last = the_string.find_last_not_of('/');
	if(last!=string::npos)++last;
	the_string = the_string.substr(0,last); //Kill trailing '/'
	if(relative)
	{
		char buf[2048+1] = {0};
		if(FFCore.get_scriptfile_path(buf, the_string.c_str()))
			the_string = buf;
	}
	return the_string;
}

void FFScript::do_checkdir(const bool is_dir)
{
	string the_string = get_filestr(get_qr(qr_BITMAP_AND_FILESYSTEM_PATHS_ALWAYS_RELATIVE));
	set_register(sarg1, checkPath(the_string.c_str(), is_dir) ? 10000 : 0);
}

void FFScript::do_fs_remove()
{
	string the_string = get_filestr(true);
	set_register(sarg1, remove(the_string.c_str()) ? 0 : 10000);
}

void FFScript::Play_Level_Music()
{
	int32_t m=tmpscr->screen_midi;
	
	switch(m)
	{
	case -2:
		music_stop();
		break;
		
	case -1:
		play_DmapMusic();
		break;
		
	case 1:
		jukebox(ZC_MIDI_OVERWORLD);
		break;
		
	case 2:
		jukebox(ZC_MIDI_DUNGEON);
		break;
		
	case 3:
		jukebox(ZC_MIDI_LEVEL9);
		break;
		
	default:
		if(m>=4 && m<4+MAXCUSTOMMIDIS)
			jukebox(m+MIDIOFFSET_MAPSCR);
		else
			music_stop();
	}
}

void FFScript::do_warp_ex(bool v)
{
	int32_t zscript_array_ptr = SH::get_arg(sarg1, v) / 10000;
	ArrayManager am(zscript_array_ptr);
	if(am.invalid()) return;
	int32_t zscript_array_size = am.size();
	switch(zscript_array_size)
	{
		case 8: // {int32_t type, int32_t dmap, int32_t screen, int32_t x, int32_t y, int32_t effect, int32_t sound, int32_t flags}
		case 9: // {int32_t type, int32_t dmap, int32_t screen, int32_t x, int32_t y, int32_t effect, int32_t sound, int32_t flags, int32_t dir}
		{
			int32_t tmpwarp[9]={0};
			for ( int32_t q = 0; q < 8; q++ )
			{
				tmpwarp[q] = (am.get(q)/10000);
			}
			tmpwarp[wexDir] = zscript_array_size < 9 ? -1 : (am.get(8)/10000);\
			if ( ((unsigned)tmpwarp[1]) >= MAXDMAPS ) 
			{
				Z_scripterrlog("Invalid DMap ID (%d) passed to WarpEx(). Aborting.\n", tmpwarp[1]);
				return;
			}
			if ( ((unsigned)tmpwarp[2]) >= MAPSCRS ) 
			{
				Z_scripterrlog("Invalid Screen ID (%d) passed to WarpEx(). Aborting.\n", tmpwarp[2]);
				return;
			}
			//Extra sanity guard.
			if ( DMaps[tmpwarp[1]].map*MAPSCRS+DMaps[tmpwarp[1]].xoff+tmpwarp[2] >= (int32_t)TheMaps.size() )
			{
				Z_scripterrlog("Invalid destination passed to WarpEx(). Aborting.\n");
				return;
			}
			if(get_qr(qr_OLD_BROKEN_WARPEX_MUSIC))
			{
				SETFLAG(tmpwarp[wexFlags],warpFlagFORCECONTINUEMUSIC,tmpwarp[wexFlags]&warpFlagFORCERESETMUSIC);
				TOGGLEFLAG(tmpwarp[wexFlags],warpFlagFORCERESETMUSIC);
			}
			//If we passed the sanity checks, populate the FFCore array and begin the action!
			for ( int32_t q = 0; q < wexActive; q++ )
			{
				FFCore.warpex[q] = tmpwarp[q];
			}
			FFCore.warpex[wexActive] = 1;
			break;
		}
	
		default: 
		{
			Z_scripterrlog("Array supplied to Player->WarpEx() is the wrong size!\n The array size was: &d, and valid sizes are [8] and [9].\n",zscript_array_size);
			break;
		}
	}
}

///////////////////////////////
//* SCRIPT ENGINE FUNCTIONS *//
////////////////////////////////////////////////////////////////////////////

void FFScript::clearRunningItemScripts()
{
	//for ( byte q = 0; q < 256; q++ ) runningItemScripts[q] = 0;
}


void FFScript::warpScriptCheck()
{
	if(get_qr(qr_SCRIPTDRAWSINWARPS))
	{
		FFCore.runWarpScripts(false);
		FFCore.runWarpScripts(true); //Waitdraw
	}
	else if(get_qr(qr_PASSIVE_SUBSCRIPT_RUNS_WHEN_GAME_IS_FROZEN) && doscript(ScriptType::ScriptedPassiveSubscreen))
	{
		if(DMaps[currdmap].passive_sub_script != 0)
			ZScriptVersion::RunScript(ScriptType::ScriptedPassiveSubscreen, DMaps[currdmap].passive_sub_script, currdmap);
		if (waitdraw(ScriptType::ScriptedPassiveSubscreen) && DMaps[currdmap].passive_sub_script != 0 && doscript(ScriptType::ScriptedPassiveSubscreen))
		{
			ZScriptVersion::RunScript(ScriptType::ScriptedPassiveSubscreen, DMaps[currdmap].passive_sub_script, currdmap);
			waitdraw(ScriptType::ScriptedPassiveSubscreen) = false;
		}	
	}
}

void FFScript::runWarpScripts(bool waitdraw)
{
	if(waitdraw)
	{
		if ((!( FFCore.system_suspend[susptGLOBALGAME] )) && FFCore.waitdraw(ScriptType::Global, GLOBAL_SCRIPT_GAME))
		{
			ZScriptVersion::RunScript(ScriptType::Global, GLOBAL_SCRIPT_GAME, GLOBAL_SCRIPT_GAME);
			FFCore.waitdraw(ScriptType::Global, GLOBAL_SCRIPT_GAME) = false;
		}
		if ( !FFCore.system_suspend[susptITEMSCRIPTENGINE] )
		{
			FFCore.itemScriptEngineOnWaitdraw();
		}
		if ( (!( FFCore.system_suspend[susptHEROACTIVE] )) && FFCore.waitdraw(ScriptType::Player) && FFCore.getQuestHeaderInfo(vZelda) >= 0x255 )
		{
			ZScriptVersion::RunScript(ScriptType::Player, SCRIPT_PLAYER_ACTIVE);
			FFCore.waitdraw(ScriptType::Player) = false;
		}
		if ( (!( FFCore.system_suspend[susptDMAPSCRIPT] )) && FFCore.waitdraw(ScriptType::DMap) && FFCore.getQuestHeaderInfo(vZelda) >= 0x255 )
		{
			ZScriptVersion::RunScript(ScriptType::DMap, DMaps[currdmap].script,currdmap);
			FFCore.waitdraw(ScriptType::DMap) = false;
		}
		if ( (!( FFCore.system_suspend[susptDMAPSCRIPT] )) && FFCore.waitdraw(ScriptType::ScriptedPassiveSubscreen) && FFCore.getQuestHeaderInfo(vZelda) >= 0x255 )
		{
			ZScriptVersion::RunScript(ScriptType::ScriptedPassiveSubscreen, DMaps[currdmap].passive_sub_script,currdmap);
			FFCore.waitdraw(ScriptType::ScriptedPassiveSubscreen) = false;
		}
		//no doscript check here, becauseb of preload? Do we want to write doscript here? -Z 13th July, 2019
		if ( (!( FFCore.system_suspend[susptSCREENSCRIPTS] )) && tmpscr->script != 0 && FFCore.waitdraw(ScriptType::Screen) && tmpscr->preloadscript && FFCore.getQuestHeaderInfo(vZelda) >= 0x255 )
		{
			ZScriptVersion::RunScript(ScriptType::Screen, tmpscr->script);  
			FFCore.waitdraw(ScriptType::Screen) = 0;		
		}
	}
	else
	{
		if ((!( FFCore.system_suspend[susptGLOBALGAME] )) && FFCore.doscript(ScriptType::Global, GLOBAL_SCRIPT_GAME))
		{
			ZScriptVersion::RunScript(ScriptType::Global, GLOBAL_SCRIPT_GAME, GLOBAL_SCRIPT_GAME);
		}
		if ( !FFCore.system_suspend[susptITEMSCRIPTENGINE] )
		{
			FFCore.itemScriptEngine();
		}
		if ((!( FFCore.system_suspend[susptHEROACTIVE] )) && doscript(ScriptType::Player) && FFCore.getQuestHeaderInfo(vZelda) >= 0x255)
		{
			ZScriptVersion::RunScript(ScriptType::Player, SCRIPT_PLAYER_ACTIVE);
		}
		if ( (!( FFCore.system_suspend[susptDMAPSCRIPT] )) && doscript(ScriptType::DMap) && FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) 
		{
			ZScriptVersion::RunScript(ScriptType::DMap, DMaps[currdmap].script,currdmap);
		}
		if ( (!( FFCore.system_suspend[susptDMAPSCRIPT] )) && FFCore.doscript(ScriptType::ScriptedPassiveSubscreen) && FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) 
		{
			ZScriptVersion::RunScript(ScriptType::ScriptedPassiveSubscreen, DMaps[currdmap].passive_sub_script,currdmap);
		}
		if ( (!( FFCore.system_suspend[susptSCREENSCRIPTS] )) && tmpscr->script != 0 && tmpscr->preloadscript && FFCore.getQuestHeaderInfo(vZelda) >= 0x255 )
		{
			ZScriptVersion::RunScript(ScriptType::Screen, tmpscr->script);
		}
	}
}

void FFScript::runF6Engine()
{
	if(!Quit && (GameFlags&GAMEFLAG_TRYQUIT) && !(GameFlags&GAMEFLAG_F6SCRIPT_ACTIVE))
	{
		if(globalscripts[GLOBAL_SCRIPT_F6]->valid())
		{
			//Incase this was called mid-another script, store ref data
			push_ri();
			//
			clear_bitmap(f6_menu_buf);
			blit(framebuf, f6_menu_buf, 0, 0, 0, 0, 256, 224);
			initZScriptGlobalScript(GLOBAL_SCRIPT_F6);
			int32_t openingwipe = black_opening_count;
			int32_t openingshape = black_opening_shape;
			black_opening_count = 0; //No opening wipe during F6 menu
			if(black_opening_shape==bosFADEBLACK) black_fade(0);
			GameFlags |= GAMEFLAG_F6SCRIPT_ACTIVE;
			//auto tmpDrawCommands = script_drawing_commands.pop_commands();
			pause_all_sfx();

			auto& data = get_script_engine_data(ScriptType::Global, GLOBAL_SCRIPT_F6);
			while (data.doscript)
			{
				script_drawing_commands.Clear();
				load_control_state(); 
				ZScriptVersion::RunScript(ScriptType::Global, GLOBAL_SCRIPT_F6, GLOBAL_SCRIPT_F6);
				if (data.waitdraw)
				{
					ZScriptVersion::RunScript(ScriptType::Global, GLOBAL_SCRIPT_F6, GLOBAL_SCRIPT_F6);
					data.waitdraw = false;
				}
				//Draw
				clear_bitmap(framebuf);
				if( !FFCore.system_suspend[susptCOMBOANIM] ) animate_combos();
				doScriptMenuDraws();
				//
				advanceframe(true,true,false);
				if(Quit) break; //Something quit, end script running
			}
			resume_all_sfx();
			script_drawing_commands.Clear();
			//script_drawing_commands.push_commands(tmpDrawCommands);
			GameFlags &= ~GAMEFLAG_F6SCRIPT_ACTIVE;
			//Restore opening wipe
			black_opening_count = openingwipe;
			black_opening_shape = openingshape;
			if(openingshape == bosFADEBLACK)
			{
				refreshTints();
				memcpy(tempblackpal, RAMpal, PAL_SIZE*sizeof(RGB));
			}
			//Restore script refinfo
			pop_ri();
			//
			if(!Quit)
			{
				if(!get_qr(qr_NOCONTINUE))
					f_Quit(qQUIT);
			}
		}
		else f_Quit(qQUIT);
		zc_readkey(KEY_F6);
		GameFlags &= ~GAMEFLAG_TRYQUIT;
	}
}
void FFScript::runOnDeathEngine()
{
	if(!playerscripts[SCRIPT_PLAYER_DEATH]->valid()) return; //No script to run
	clear_bitmap(script_menu_buf);
	blit(framebuf, script_menu_buf, 0, 0, 0, 0, 256, 224);
	initZScriptHeroScripts();
	GameFlags |= GAMEFLAG_SCRIPTMENU_ACTIVE;
	kill_sfx(); //No need to pause/resume; the player is dead.
	//auto tmpDrawCommands = script_drawing_commands.pop_commands();
	
	auto& data = get_script_engine_data(ScriptType::Player);
	while (data.doscript && !Quit)
	{
		script_drawing_commands.Clear();
		load_control_state();
		ZScriptVersion::RunScript(ScriptType::Player, SCRIPT_PLAYER_DEATH);
		if (data.waitdraw)
		{
			ZScriptVersion::RunScript(ScriptType::Player, SCRIPT_PLAYER_DEATH);
			data.waitdraw = false;
		}
		//Draw
		clear_bitmap(framebuf);
		if( !FFCore.system_suspend[susptCOMBOANIM] ) animate_combos();
		doScriptMenuDraws();
		//
		advanceframe(true);
	}
	script_drawing_commands.Clear();
	//script_drawing_commands.push_commands(tmpDrawCommands);
	GameFlags &= ~GAMEFLAG_SCRIPTMENU_ACTIVE;
}
void FFScript::runOnLaunchEngine()
{
	if(!globalscripts[GLOBAL_SCRIPT_ONLAUNCH]->valid()) return; //No script to run
	//Do NOT blit the prior screen to this bitmap; that would be the TITLE SCREEN.
	clear_to_color(script_menu_buf,BLACK);
	initZScriptGlobalScript(GLOBAL_SCRIPT_ONLAUNCH);
	GameFlags |= GAMEFLAG_SCRIPTMENU_ACTIVE;
	//auto tmpDrawCommands = script_drawing_commands.pop_commands();

	auto& data = get_script_engine_data(ScriptType::Global, GLOBAL_SCRIPT_ONLAUNCH);
	while (data.doscript && !Quit)
	{
		script_drawing_commands.Clear();
		load_control_state();
		ZScriptVersion::RunScript(ScriptType::Global, GLOBAL_SCRIPT_ONLAUNCH, GLOBAL_SCRIPT_ONLAUNCH);
		if (data.waitdraw)
		{
			ZScriptVersion::RunScript(ScriptType::Global, GLOBAL_SCRIPT_ONLAUNCH, GLOBAL_SCRIPT_ONLAUNCH);
			data.waitdraw = false;
		}
		//Draw
		clear_bitmap(framebuf);
		if( !FFCore.system_suspend[susptCOMBOANIM] ) animate_combos();
		
		doScriptMenuDraws();
		//
		advanceframe(true);
	}
	script_drawing_commands.Clear();
	//script_drawing_commands.push_commands(tmpDrawCommands);
	GameFlags &= ~GAMEFLAG_SCRIPTMENU_ACTIVE;
}
bool FFScript::runGenericFrozenEngine(const word script, const int32_t *init_data)
{
	user_genscript& scr = user_genscript::get(script);
	if(script < 1 || script >= NUMSCRIPTSGENERIC) return false;
	if(init_data)
	{
		for(int q = 0; q < 8; ++q)
			scr.initd[q] = init_data[q];
	}
	if(!genericscripts[script]->valid()) return false; //No script to run
	//Store script refinfo
	push_ri();
	int local_i = int(gen_frozen_index++);
	reset_script_engine_data(ScriptType::GenericFrozen, local_i);
	//run script
	uint32_t fl = GameFlags & GAMEFLAG_SCRIPTMENU_ACTIVE;
	BITMAP* tmpbuf = script_menu_buf;
	if(fl)
	{
		script_menu_buf = create_bitmap_ex(8,256,224);
	}
	clear_bitmap(script_menu_buf);
	blit(framebuf, script_menu_buf, 0, 0, 0, 0, 256, 224);
	GameFlags |= GAMEFLAG_SCRIPTMENU_ACTIVE;
	//auto tmpDrawCommands = script_drawing_commands.pop_commands();
	while(doscript(ScriptType::GenericFrozen, local_i) && !Quit)
	{
		script_drawing_commands.Clear();
		load_control_state();
		ZScriptVersion::RunScript(ScriptType::GenericFrozen, script, local_i);
		//Draw
		clear_bitmap(framebuf);
		if( !FFCore.system_suspend[susptCOMBOANIM] ) animate_combos();
		doScriptMenuDraws();
		//
		advanceframe(true);
	}
	script_drawing_commands.Clear();
	//script_drawing_commands.push_commands(tmpDrawCommands);
	//clear
	GameFlags &= ~GAMEFLAG_SCRIPTMENU_ACTIVE;
	if(fl)
	{
		GameFlags |= fl;
		destroy_bitmap(script_menu_buf);
		script_menu_buf = tmpbuf;
	}
	clear_script_engine_data(ScriptType::GenericFrozen, local_i);
	--gen_frozen_index;
	//Restore script refinfo
	pop_ri();
	return true;
}

bool FFScript::runScriptedActiveSusbcreen()
{
	word activesubscript = DMaps[currdmap].active_sub_script;
	if(!activesubscript || !dmapscripts[activesubscript]->valid()) return false; //No script to run
	word passivesubscript = DMaps[currdmap].passive_sub_script;
	word dmapactivescript = DMaps[currdmap].script;
	clear_bitmap(script_menu_buf);
	blit(framebuf, script_menu_buf, 0, 0, 0, 0, 256, 224);
	initZScriptScriptedActiveSubscreen();
	GameFlags |= GAMEFLAG_SCRIPTMENU_ACTIVE;
	word script_dmap = currdmap;
	//auto tmpDrawCommands = script_drawing_commands.pop_commands();
	pause_all_sfx();
	auto& data = get_script_engine_data(ScriptType::ScriptedActiveSubscreen);
	while (data.doscript && !Quit)
	{
		script_drawing_commands.Clear();
		load_control_state();
		if(get_qr(qr_DMAP_ACTIVE_RUNS_DURING_ACTIVE_SUBSCRIPT) && DMaps[script_dmap].script != 0 && doscript(ScriptType::DMap))
		{
			ZScriptVersion::RunScript(ScriptType::DMap, dmapactivescript, script_dmap);
		}
		if(get_qr(qr_PASSIVE_SUBSCRIPT_RUNS_DURING_ACTIVE_SUBSCRIPT)!=0 && DMaps[script_dmap].passive_sub_script != 0 && FFCore.doscript(ScriptType::ScriptedPassiveSubscreen))
		{
			ZScriptVersion::RunScript(ScriptType::ScriptedPassiveSubscreen, passivesubscript, script_dmap);
		}
		ZScriptVersion::RunScript(ScriptType::ScriptedActiveSubscreen, activesubscript, script_dmap);
		if(waitdraw(ScriptType::DMap) && (get_qr(qr_DMAP_ACTIVE_RUNS_DURING_ACTIVE_SUBSCRIPT) && DMaps[script_dmap].script != 0 && doscript(ScriptType::DMap)))
		{
			ZScriptVersion::RunScript(ScriptType::DMap, dmapactivescript, script_dmap);
			waitdraw(ScriptType::DMap) = false;
		}
		if(waitdraw(ScriptType::ScriptedPassiveSubscreen) && (get_qr(qr_PASSIVE_SUBSCRIPT_RUNS_DURING_ACTIVE_SUBSCRIPT)!=0 && DMaps[script_dmap].passive_sub_script != 0 && FFCore.doscript(ScriptType::ScriptedPassiveSubscreen)))
		{
			ZScriptVersion::RunScript(ScriptType::ScriptedPassiveSubscreen, passivesubscript, script_dmap);
			waitdraw(ScriptType::ScriptedPassiveSubscreen) = false;
		}
		if (data.waitdraw && data.doscript)
		{
			ZScriptVersion::RunScript(ScriptType::ScriptedActiveSubscreen, activesubscript, script_dmap);
			data.waitdraw = false;
		}
		//Draw
		clear_bitmap(framebuf);
		if(currdmap == script_dmap && ( !FFCore.system_suspend[susptCOMBOANIM] ) ) animate_combos();
		doScriptMenuDraws();
		//
		advanceframe(true);
		//Handle warps; run game_loop once!
		if(currdmap != script_dmap)
		{
			activesubscript = DMaps[currdmap].active_sub_script;
			if(!activesubscript || !dmapscripts[activesubscript]->valid()) return true; //No script to run
			passivesubscript = DMaps[currdmap].passive_sub_script;
			dmapactivescript = DMaps[currdmap].script;
			script_dmap = currdmap;
			//Reset the background image
			game_loop();
			clear_bitmap(script_menu_buf);
			blit(framebuf, script_menu_buf, 0, 0, 0, 0, 256, 224);
			//Now loop without advancing frame, so that the subscreen script can draw immediately.
		}
	}
	resume_all_sfx();
	script_drawing_commands.Clear();
	//script_drawing_commands.push_commands(tmpDrawCommands);
	GameFlags &= ~GAMEFLAG_SCRIPTMENU_ACTIVE;
	GameFlags |= GAMEFLAG_RESET_GAME_LOOP;
	return true;
}
bool FFScript::runOnMapScriptEngine()
{
	word onmap_script = DMaps[currdmap].onmap_script;
	if(!onmap_script || !dmapscripts[onmap_script]->valid()) return false; //No script to run
	clear_bitmap(script_menu_buf);
	blit(framebuf, script_menu_buf, 0, 0, 0, 0, 256, 224);
	initZScriptOnMapScript();
	GameFlags |= GAMEFLAG_SCRIPTMENU_ACTIVE;
	word script_dmap = currdmap;
	//auto tmpDrawCommands = script_drawing_commands.pop_commands();
	pause_all_sfx();

	auto& data = get_script_engine_data(ScriptType::OnMap);
	while (data.doscript && !Quit)
	{
		script_drawing_commands.Clear();
		load_control_state();
		ZScriptVersion::RunScript(ScriptType::OnMap, onmap_script, script_dmap);
		if (data.waitdraw && data.doscript)
		{
			ZScriptVersion::RunScript(ScriptType::OnMap, onmap_script, script_dmap);
			data.waitdraw = false;
		}
		//Draw
		clear_bitmap(framebuf);
		if(currdmap == script_dmap && ( !FFCore.system_suspend[susptCOMBOANIM] ) ) animate_combos();
		doScriptMenuDraws();
		//
		advanceframe(true);
		//Handle warps; run game_loop once!
		if(currdmap != script_dmap)
		{
			onmap_script = DMaps[currdmap].onmap_script;
			if(!onmap_script || !dmapscripts[onmap_script]->valid()) return true; //No script to run
			script_dmap = currdmap;
			//Reset the background image
			game_loop();
			clear_bitmap(script_menu_buf);
			blit(framebuf, script_menu_buf, 0, 0, 0, 0, 256, 224);
			//Now loop without advancing frame, so that the subscreen script can draw immediately.
		}
	}
	resume_all_sfx();
	script_drawing_commands.Clear();
	//script_drawing_commands.push_commands(tmpDrawCommands);
	GameFlags &= ~GAMEFLAG_SCRIPTMENU_ACTIVE;
	GameFlags |= GAMEFLAG_RESET_GAME_LOOP;
	return true;
}

void FFScript::doScriptMenuDraws()
{
	BITMAP* menu_buf = ((GameFlags & GAMEFLAG_F6SCRIPT_ACTIVE) != 0) ? f6_menu_buf : script_menu_buf;
	blit(menu_buf, framebuf, 0, 0, 0, 0, 256, 224);
	//Script draws
	do_script_draws(framebuf, tmpscr, 0, playing_field_offset);
}

void FFScript::runOnSaveEngine()
{
	if(globalscripts[GLOBAL_SCRIPT_ONSAVE]->valid())
	{
		push_ri();
		//Prevent getting here via Quit from causing a forced-script-quit after 1000 commands!
		int32_t tQuit = Quit;
		Quit = 0;
		//
		initZScriptGlobalScript(GLOBAL_SCRIPT_ONSAVE);
		ZScriptVersion::RunScript(ScriptType::Global, GLOBAL_SCRIPT_ONSAVE, GLOBAL_SCRIPT_ONSAVE);
		//
		pop_ri();
		Quit = tQuit;
	}
}

bool FFScript::itemScriptEngine()
{
	if ( FFCore.system_suspend[susptITEMSCRIPTENGINE] ) return false;
	//zprint("Trying to check if an %s is running.\n","item script");
	for ( int32_t q = 0; q < MAXITEMS; q++ )
	{
		
		//zprint("Checking item ID: %d\n",q);
		if ( itemsbuf[q].script <= 0 || itemsbuf[q].script > NUMSCRIPTITEM ) continue; // > NUMSCRIPTITEM as someone could force an invaid script slot!
		
		auto& data = get_script_engine_data(ScriptType::Item, q);
		if ( data.doscript < 1 ) continue;
		
		//Passive items
		if (((itemsbuf[q].flags&ITEM_PASSIVESCRIPT)))
		{
			if(game->item[q] && (get_qr(qr_ITEMSCRIPTSKEEPRUNNING)))
			{
				if(get_qr(qr_PASSIVE_ITEM_SCRIPT_ONLY_HIGHEST)
					&& current_item(itemsbuf[q].family) > itemsbuf[q].fam_type)
					data.doscript = 0;
				else ZScriptVersion::RunScript(ScriptType::Item, itemsbuf[q].script, q&0xFFF);
				if(!data.doscript)  //Item script ended. Clear the data, if any remains.
				{
					data.ref.Clear();
					data.initialized = false;
					data.waitdraw = false;
					FFScript::deallocateAllScriptOwned(ScriptType::Item, q);
				}
			}
		}
		else
		{
		
			//Normal Items 
			//zprint("Running ItemScriptEngine() for item ID: %dn", q);
			/*! What happens here: When an item script is first run by the user using that utem, the script runs for one frame.
				After executing RunScript(), item_doscript is set to '1' in hero.cpp.
				If the quest allows the item to continue running, the itemScriptEngine() function ignores running the
				  same item script (again) that frame, and insteads increments item_doscript to '2'.
				If item_doscript == 2, then we know we are on the second frame, and we run it perpetually.
				If the QR to enable item scripts to run for more than one frame is not enabled, then item_doscript is set to '0'.
				If the item flag 'PERPETUAL SCRIPT' is enabled, then we ignore the lack of item_doscript==2.
				  This allows passive item scripts to function. 
			*/

			auto& data = get_script_engine_data(ScriptType::Item, q);
			
			if ( data.doscript == 1 ) // FIrst frame, normally set in hero.cpp
			{
				if ( get_qr(qr_ITEMSCRIPTSKEEPRUNNING) )
				{
					data.doscript = 2;
				}
			}
			else if (data.doscript == 2) //Second frame and later, if scripts continue to run.
			{
				ZScriptVersion::RunScript(ScriptType::Item, itemsbuf[q].script, q&0xFFF);
			}
			else if (data.doscript == 3) //Run via itemdata->RunScript
			{
				if ( (get_qr(qr_ITEMSCRIPTSKEEPRUNNING)) ) 
				{
					data.doscript = 2; //Reduce to normal run status
				}
				else 
				{
					ZScriptVersion::RunScript(ScriptType::Item, itemsbuf[q].script, q & 0xFFF);
					data.doscript = 0;
				}
			}
			else if(data.doscript==4)  //Item set itself false, kill script and clear data here
			{
				data.doscript = 0;
			}
			if(data.doscript==0)  //Item script ended. Clear the data, if any remains.
			{
				data.ref.Clear();
				data.initialized = false;
				data.waitdraw = false;
				FFScript::deallocateAllScriptOwned(ScriptType::Item, q);
			}
		}
	}
	return false;
}

bool FFScript::itemScriptEngineOnWaitdraw()
{
	if ( FFCore.system_suspend[susptITEMSCRIPTENGINE] ) return false;
	//zprint("Trying to check if an %s is running.\n","item script");
	for ( int32_t q = 0; q < MAXITEMS; q++ )
	{
		//zprint("Checking item ID: %d\n",q);
		if ( itemsbuf[q].script <= 0 || itemsbuf[q].script > NUMSCRIPTITEM ) continue; // > NUMSCRIPTITEM as someone could force an invaid script slot!
		
		auto& data = get_script_engine_data(ScriptType::Item, q);

		if ( data.doscript < 1 ) continue;
		if (!data.waitdraw) continue;
		else data.waitdraw = false;
		
		//zprint("Running ItemScriptEngine() for item ID: %dn", q);
		/*! What happens here: When an item script is first run by the user using that utem, the script runs for one frame.
			After executing RunScript(), item_doscript is set to '1' in hero.cpp.
			If the quest allows the item to continue running, the itemScriptEngine() function ignores running the
			  same item script (again) that frame, and insteads increments item_doscript to '2'.
			If item_doscript == 2, then we know we are on the second frame, and we run it perpetually.
			If the QR to enable item scripts to run for more than one frame is not enabled, then item_doscript is set to '0'.
			If the item flag 'PERPETUAL SCRIPT' is enabled, then we ignore the lack of item_doscript==2.
			  This allows passive item scripts to function. 
		*/
		//Passive items
		if ((itemsbuf[q].flags&ITEM_PASSIVESCRIPT))
		{
			if(game->item[q] && (get_qr(qr_ITEMSCRIPTSKEEPRUNNING)))
			{
				if(get_qr(qr_PASSIVE_ITEM_SCRIPT_ONLY_HIGHEST)
					&& current_item(itemsbuf[q].family) > itemsbuf[q].fam_type)
					data.doscript = 0;
				else ZScriptVersion::RunScript(ScriptType::Item, itemsbuf[q].script, q&0xFFF);
				if(!data.doscript)  //Item script ended. Clear the data, if any remains.
				{
					data.ref.Clear();
					data.initialized = false;
					data.waitdraw = false;
					FFScript::deallocateAllScriptOwned(ScriptType::Item, q);
				}
			}
		}
		else
		{
			//Normal items
			if ( data.doscript == 1 ) // FIrst frame, normally set in hero.cpp
			{
				if ( get_qr(qr_ITEMSCRIPTSKEEPRUNNING) )
				{
					data.doscript = 2;
				}
				else data.doscript = 0;
			}
			else if (data.doscript == 2) //Second frame and later, if scripts continue to run.
			{
				ZScriptVersion::RunScript(ScriptType::Item, itemsbuf[q].script, q&0xFFF);
			}
			else if (data.doscript == 3) //Run via itemdata->RunScript
			{
				if ( (get_qr(qr_ITEMSCRIPTSKEEPRUNNING)) ) 
				{
					data.doscript = 2; //Reduce to normal run status
				}
				else 
				{
					ZScriptVersion::RunScript(ScriptType::Item, itemsbuf[q].script, q & 0xFFF);
					data.doscript = 0;
				}
			}
			else if(data.doscript==4)  //Item set itself false, kill script and clear data here.
			{
				data.doscript = 0;
			}
			if(!data.doscript)  //Item script ended. Clear the data, if any remains.
			{
				data.ref.Clear();
				data.initialized = false;
				data.waitdraw = false;
				FFScript::deallocateAllScriptOwned(ScriptType::Item, q);
			}
		}
	}
	return false;
}
void FFScript::npcScriptEngineOnWaitdraw()
{
	if ( FFCore.system_suspend[susptNPCSCRIPTS] ) return;
	guys.run_script(MODE_WAITDRAW);
}

void FFScript::eweaponScriptEngine()
{
	if ( FFCore.system_suspend[susptEWEAPONSCRIPTS] ) return;
	Ewpns.run_script(MODE_NORMAL);
}

void FFScript::lweaponScriptEngineOnWaitdraw()
{
	if ( FFCore.system_suspend[susptLWEAPONSCRIPTS] ) return;
	Lwpns.run_script(MODE_WAITDRAW);
}

void FFScript::eweaponScriptEngineOnWaitdraw()
{
	if ( FFCore.system_suspend[susptEWEAPONSCRIPTS] ) return;
	Ewpns.run_script(MODE_WAITDRAW);
}

void FFScript::itemSpriteScriptEngine()
{
	if ( FFCore.system_suspend[susptITEMSPRITESCRIPTS] ) return;
	items.run_script(MODE_NORMAL);
}

void FFScript::itemSpriteScriptEngineOnWaitdraw()
{
	if ( FFCore.system_suspend[susptITEMSPRITESCRIPTS] ) return;
	items.run_script(MODE_WAITDRAW);
}


int32_t FFScript::getTime(int32_t type)
{
	//struct tm *tm_struct = localtime(time(NULL));
	struct tm * tm_struct;
	time_t sysRTC;
	time (&sysRTC);
	tm_struct = localtime (&sysRTC);
	int32_t rval = -1;
	
	switch(type)
	{
		case curyear:
		{
			//Year format starts at 1900, yeat
			//A raw read of '2018' would be '118', so we add 1900 to it to derive the actual year. 
			rval = tm_struct->tm_year + 1900; break;
			
		}
		case curmonth:
		{
			//Months start at 0, but we want 1->12
			//al_trace("The current month is: %d\n",month);
			rval = tm_struct->tm_mon +1; break;
		}
		case curday_month:
		{
			rval = tm_struct->tm_mday; break;
		}
		case curday_week: 
		{
			//It seems that weekdays are a value range of 1 to 7.
			rval = tm_struct->tm_wday; break;
		}
		case curhour:
		{
			rval = tm_struct->tm_hour; break;
		}
		case curminute: 
		{
			rval = tm_struct->tm_min; break;
		}
		case cursecond:
		{
			rval = tm_struct->tm_sec; break;
		}
		case curdayyear:
		{
			//The day (n/365) out of the entire year. 
			rval = tm_struct->tm_yday; break;
		}
		case curDST:
		{
			//Returns if the user is in a Time Zone with Daylight TIme of some sort. 
			//View the time.h docs for the actual values of this struct element.
			rval = tm_struct->tm_isdst;; break;
		}
		default: 
		{
			al_trace("Invalid category passed to GetSystemTime(%d)\n",type);
			rval = -1;  break;
		}
		
	}
	return rval;
}

void FFScript::do_isdeadnpc()
{
	//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
	if(GuyH::loadNPC(ri->guyref, "npc->isDead") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		//int32_t dead = (int32_t)e->Dead(GuyH::getNPCIndex(ri->guyref));
		//GuyH::getNPC()->Dead(GuyH::getNPCIndex(ri->guyref));
		set_register(sarg1,
			((GuyH::getNPC()->dying && !GuyH::getNPC()->immortal)
				? 10000 : 0));
	}
	else set_register(sarg1, 0);
}


void FFScript::do_canslidenpc()
{
	
	if(GuyH::loadNPC(ri->guyref, "npc->CanSlide") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		//bool candoit = e->can_slide();
		set_register(sarg1, ((GuyH::getNPC()->can_slide()) ? 10000 : 0));
	}
	else set_register(sarg1, -10000);
}

void FFScript::do_slidenpc()
{
	
	if(GuyH::loadNPC(ri->guyref, "npc->Slide()") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		//bool candoit = e->slide();
		set_register(sarg1, ((GuyH::getNPC()->slide())*10000));
	}
	else set_register(sarg1, -10000);
}

void FFScript::do_npc_stopbgsfx()
{
	//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
	if(GuyH::loadNPC(ri->guyref, "npc->StopBGSFX()") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		//e->stop_bgsfx(GuyH::getNPCIndex(ri->guyref));
		GuyH::getNPC()->stop_bgsfx(GuyH::getNPCIndex(ri->guyref));
	}
}

void FFScript::do_npc_delete()
{
	if(GuyH::loadNPC(ri->guyref, "npc->Remove()") == SH::_NoError)
	{
		auto ind = GuyH::getNPCIndex(ri->guyref);
		GuyH::getNPC()->stop_bgsfx(ind);
		guys.del(ind);
	}
}

void FFScript::do_lweapon_delete()
{
	if(0!=(s=checkLWpn(ri->lwpn,"Remove()")))
	{
		if(s==Hero.lift_wpn)
		{
			delete s;
			Hero.lift_wpn = nullptr;
		}
		else Lwpns.del(LwpnH::getLWeaponIndex(ri->lwpn));
	}
}

void FFScript::do_eweapon_delete()
{
	if(0!=(s=checkEWpn(ri->ewpn,"Remove()")))
	{
		Ewpns.del(EwpnH::getEWeaponIndex(ri->ewpn));
	}
}

bool FFScript::do_itemsprite_delete()
{
	if(0!=(s=checkItem(ri->itemref)))
	{
		auto ind = ItemH::getItemIndex(ri->itemref);
		if(!items.del(ind)) return false;
		for(int32_t i=0; i<Lwpns.Count(); i++)
		{
			weapon *w = (weapon*)Lwpns.spr(i);
			
			if(w->dragging==ind)
			{
				w->dragging=-1;
			}
			else if(w->dragging>ind)
			{
				w->dragging-=1;
			}
		}
		return true;
	}
	return false;
}

void FFScript::updateIncludePaths()
{
	includePaths.clear();
	int32_t pos = 0;
	for ( int32_t q = 0; includePathString[pos]; ++q )
	{
		int32_t dest = 0;
		char buf[2048] = {0};
		while(includePathString[pos] != ';' && includePathString[pos])
		{
			buf[dest] = includePathString[pos];
			++pos;
			++dest;
		}
		++pos;
		std::string str(buf);
		includePaths.push_back(str);
	}
}

void FFScript::initRunString()
{
	memset(scriptRunString,0,sizeof(scriptRunString));
	strcpy(scriptRunString,zc_get_config("Compiler","run_string","run",App::zscript));
}

void FFScript::initIncludePaths()
{
	memset(includePathString,0,sizeof(includePathString));
	FILE* f = fopen("includepaths.txt", "r");
	if(f)
	{
		int32_t pos = 0;
		int32_t c;
		do
		{
			c = fgetc(f);
			if(c!=EOF) 
				includePathString[pos++] = c;
		}
		while(c!=EOF && pos<MAX_INCLUDE_PATH_CHARS);
		if(pos<MAX_INCLUDE_PATH_CHARS)
			includePathString[pos] = '\0';
		includePathString[MAX_INCLUDE_PATH_CHARS-1] = '\0';
		fclose(f);
	}
	else strcpy(includePathString, "include/;headers/;scripts/;");
	al_trace("Full path string is: ");
	safe_al_trace(includePathString);
	al_trace("\n");
	updateIncludePaths();

	for ( size_t q = 0; q < includePaths.size(); ++q )
	{
		al_trace("Include path %zu: ",q);
		safe_al_trace(includePaths.at(q));
		al_trace("\n");
	}
}

void FFScript::do_npcattack()
{
	
	if(GuyH::loadNPC(ri->guyref, "npc->Attack()") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		//e->FireWeapon();
		//we could just do: 
		GuyH::getNPC()->FireWeapon();
	}
}
void FFScript::do_npc_newdir()
{
	int32_t arrayptr = get_register(sarg1) / 10000;
	ArrayManager am(arrayptr);
	if(am.invalid()) return;
	int32_t sz = am.size();
	
	if(GuyH::loadNPC(ri->guyref, "npc->NewDir()") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		
		if ( sz != -1 ) 
		{
			if ( sz != 3 ) 
			{
				Z_scripterrlog("Invalid array size (%d) passed to npc->VariableWalk(int32_t arr[])\n",sz);
				return;
			}
			GuyH::getNPC()->newdir((am.get(0)/10000), (am.get(1)/10000),
				(am.get(2)/10000));
		}
		//else e->newdir();
		else GuyH::getNPC()->newdir();
	}
}

void FFScript::do_npc_constwalk()
{
	int32_t arrayptr = get_register(sarg1) / 10000;
	ArrayManager am(arrayptr);
	if(am.invalid()) return;
	int32_t sz = am.size();
	
	if(GuyH::loadNPC(ri->guyref, "npc->ConstantWalk()") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		
		if ( sz != -1 ) 
		{
			if ( sz != 3 ) 
			{
				Z_scripterrlog("Invalid array size (%d) passed to npc->VariableWalk(int32_t arr[])\n",sz);
				return;
			}
			GuyH::getNPC()->constant_walk( (am.get(0)/10000), (am.get(1)/10000),
				(am.get(2)/10000) );
		}
		else GuyH::getNPC()->constant_walk();//e->constant_walk();
	}
}

void FFScript::do_npc_varwalk()
{
	int32_t arrayptr = get_register(sarg1) / 10000;
	ArrayManager am(arrayptr);
	if(am.invalid()) return;
	int32_t sz = am.size();
	
	if(GuyH::loadNPC(ri->guyref, "npc->VariableWalk()") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		
		if ( sz == 3 ) 
		{
			
			GuyH::getNPC()->variable_walk( (am.get(0)/10000), (am.get(1)/10000),
				(am.get(2)/10000) );
		}
		else Z_scripterrlog("Invalid array size (%d) passed to npc->VariableWalk(int32_t arr[])\n",sz);
	}
}

void FFScript::do_npc_varwalk8()
{
	int32_t arrayptr = get_register(sarg1) / 10000;
	ArrayManager am(arrayptr);
	if(am.invalid()) return;
	int32_t sz = am.size();
	
	if(GuyH::loadNPC(ri->guyref, "npc->VariableWalk8()") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		
		if ( sz == 4 ) 
		{
			GuyH::getNPC()->variable_walk_8( (am.get(0)/10000), (am.get(1)/10000),
				(am.get(2)/10000), (am.get(3)/10000) );
		}
		else if ( sz == 8 ) 
		{
			GuyH::getNPC()->variable_walk_8( (am.get(0)/10000), (am.get(1)/10000),
				(am.get(2)/10000), (am.get(3)/10000),
				(am.get(4)/10000), (am.get(5)/10000),
				(am.get(6)/10000), (am.get(7)/10000)
			);
		}
		else Z_scripterrlog("Invalid array size (%d) passed to npc->VariableWalk(int32_t arr[])\n",sz);
	}
}

void FFScript::do_npc_constwalk8()
{
	int32_t arrayptr = get_register(sarg1) / 10000;
	ArrayManager am(arrayptr);
	if(am.invalid()) return;
	int32_t sz = am.size();
	
	if(GuyH::loadNPC(ri->guyref, "npc->ConstantWalk8()") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		
		if ( sz == 3 ) 
		{
			GuyH::getNPC()->constant_walk_8( (am.get(0)/10000), (am.get(1)/10000),
				(am.get(2)/10000) );
		}
		
		else Z_scripterrlog("Invalid array size (%d) passed to npc->VariableWalk(int32_t arr[])\n",sz);
	}
}


void FFScript::do_npc_haltwalk()
{
	int32_t arrayptr = get_register(sarg1) / 10000;
	ArrayManager am(arrayptr);
	if(am.invalid()) return;
	int32_t sz = am.size();
	
	if(GuyH::loadNPC(ri->guyref, "npc->HaltingWalk()") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		
		if ( sz == 5 ) 
		{
			GuyH::getNPC()->halting_walk( (am.get(0)/10000), (am.get(1)/10000),
				(am.get(2)/10000), (am.get(3)/10000),
				(am.get(4)/10000));
		}
		else Z_scripterrlog("Invalid array size (%d) passed to npc->VariableWalk(int32_t arr[])\n",sz);
	}
}

void FFScript::do_npc_haltwalk8()
{
	int32_t arrayptr = get_register(sarg1) / 10000;
	ArrayManager am(arrayptr);
	if(am.invalid()) return;
	int32_t sz = am.size();
	
	if(GuyH::loadNPC(ri->guyref, "npc->HaltingWalk8()") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		
		if ( sz == 6 ) 
		{
			
			GuyH::getNPC()->halting_walk_8( (am.get(0)/10000), (am.get(1)/10000),
				(am.get(2)/10000), (am.get(3)/10000),
				(am.get(4)/10000),(am.get(5)/10000));
		}
		else Z_scripterrlog("Invalid array size (%d) passed to npc->VariableWalk(int32_t arr[])\n",sz);
	}
}


void FFScript::do_npc_floatwalk()
{
	int32_t arrayptr = get_register(sarg1) / 10000;
	ArrayManager am(arrayptr);
	if(am.invalid()) return;
	int32_t sz = am.size();
	
	if(GuyH::loadNPC(ri->guyref, "npc->FloatingWalk()") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		
		if ( sz == 3 ) 
		{
			
			GuyH::getNPC()->floater_walk( (am.get(0)/10000), (am.get(1)/10000),
				(zfix)(am.get(2)/10000));
		
		}
		else if ( sz == 7 ) 
		{
			
			GuyH::getNPC()->floater_walk( (am.get(0)/10000), (am.get(1)/10000),
				(zfix)(am.get(2)/10000), (zfix)(am.get(3)/10000),
				(am.get(4)/10000),(am.get(5)/10000),
				(am.get(6)/10000));
		}
		else Z_scripterrlog("Invalid array size (%d) passed to npc->VariableWalk(int32_t arr[])\n",sz);
	}
}

void FFScript::do_npc_breathefire()
{
	bool seek = (get_register(sarg1));
	if(GuyH::loadNPC(ri->guyref, "npc->BreathAttack()") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		GuyH::getNPC()->FireBreath(seek);
		
	}
}


void FFScript::do_npc_newdir8()
{
	int32_t arrayptr = get_register(sarg1) / 10000;
	ArrayManager am(arrayptr);
	if(am.invalid()) return;
	int32_t sz = am.size();
	
	if(GuyH::loadNPC(ri->guyref, "npc->NewDir8()") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		
		if ( sz == 3 ) 
		{
			
			GuyH::getNPC()->newdir_8( (am.get(0)/10000), (am.get(1)/10000),
				(am.get(2)/10000));
		
		}
		else if ( sz == 7 ) 
		{
			
			GuyH::getNPC()->newdir_8( (am.get(0)/10000), (am.get(1)/10000),
				(am.get(2)/10000), (am.get(3)/10000),
				(am.get(4)/10000),(am.get(5)/10000),
				(am.get(6)/10000));
		}
		else Z_scripterrlog("Invalid array size (%d) passed to npc->VariableWalk(int32_t arr[])\n",sz);
	}
}

	
int32_t FFScript::npc_collision()
{
	int32_t isColl = 0;
	if(GuyH::loadNPC(ri->guyref, "npc->Collision()") == SH::_NoError)
	{
		int32_t _obj_type = (ri->d[rINDEX] / 10000);
		int32_t _obj_ptr = (ri->d[rINDEX2]);
		
		switch(_obj_type)
		{
			case obj_type_lweapon:
			{
				isColl = 0;
				break;
			}
			case obj_type_eweapon:
			{
				isColl = 0;
				break;
			}
			case obj_type_npc:
			{
				isColl = 0;
				break;
			}
			case obj_type_player:
			{
				isColl = 0;
				break;
			}
			case obj_type_ffc:
			{
				_obj_ptr *= 10000; _obj_ptr -= 1;
				isColl = 0;
				break;
			}
			case obj_type_combo_pos:
			{
				_obj_ptr *= 10000;
				isColl = 0;
				break;
			}
			case obj_type_item:
			{
				isColl = 0;
				break;
			}
			default: 
			{
				Z_scripterrlog("Invalid object type (%d) passed to npc->Collision(int32_t type, int32_t ptr)\n", _obj_type);
				isColl = 0;
				break;
			}
		}
	}
	
	return isColl;
}


int32_t FFScript::npc_linedup()
{
	if(GuyH::loadNPC(ri->guyref, "npc->LinedUp()") == SH::_NoError)
	{
		int32_t range = (ri->d[rINDEX] / 10000);
		bool dir8 = (ri->d[rINDEX2]);
		return (int32_t)(GuyH::getNPC()->lined_up(range,dir8)*10000);
	}
	
	return 0;
}


void FFScript::do_npc_hero_in_range(const bool v)
{
	int32_t dist = get_register(sarg1) / 10000;
	if(GuyH::loadNPC(ri->guyref, "npc->LinedUp()") == SH::_NoError)
	{
		bool in_range = GuyH::getNPC()->HeroInRange(dist);
		set_register(sarg1, (in_range ? 10000 : 0)); //This isn't setting the right value, it seems. 
	}
	else set_register(sarg2, 0);
}






void FFScript::do_npc_simulate_hit(const bool v)
{
	int32_t arrayptr = SH::get_arg(sarg1, v) / 10000;
	ArrayManager am(arrayptr);
	if(am.invalid()) return;
	int32_t sz = am.size();
	bool ishit = false;
	
	if(GuyH::loadNPC(ri->guyref, "npc->SimulateHit()") == SH::_NoError)
	{
		// zprint("Trying to simulate a hit on npc\n");
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		if ( sz == 2 ) //type and pointer
		{
			// int32_t type = am.get(0)/10000;
			
			//switch(type)
			//{
			//	case simulate_hit_type_weapon:
			//	{
			//		ishit = e->hit(*);
			//		break;
			//	}
			//	case simulate_hit_type_sprite:
			//	{
			//		ishit = e->hit(*);
			//		break;
			//	}
			//}
			ishit = false;
		}
		if ( sz == 6 ) //hit(int32_t tx,int32_t ty,int32_t tz,int32_t txsz,int32_t tysz,int32_t tzsz);
		{
			ishit = GuyH::getNPC()->hit( (am.get(0)/10000), (am.get(1)/10000),
				(am.get(2)/10000), (am.get(3)/10000), 
				(am.get(4)/10000), (am.get(5)/10000) );			
			
		}
		else 
		{
			Z_scripterrlog("Invalid array size (%d) passed to npc->SimulateHit(). The array size must be [1] or [3].\n", sz);
			ishit = false;
		}
	}
	set_register(sarg1, ( ishit ? 10000 : 0));
}

void FFScript::do_npc_knockback(const bool v)
{
	int32_t time = SH::get_arg(sarg1, v) / 10000;
	int32_t dir = SH::get_arg(sarg2, v) / 10000;
	int32_t spd = vbound(ri->d[rINDEX] / 10000, 0, 255);
	//zprint("Knockback: time %d,dir %d,spd %d\n",time,dir,spd);
	bool ret = false;
	
	if(GuyH::loadNPC(ri->guyref, "npc->Knockback()") == SH::_NoError)
	{
		ret = GuyH::getNPC()->knockback(time, dir, spd);
	}
	set_register(sarg1, ( ret ? 10000 : 0));
}

void FFScript::do_npc_add(const bool v)
{
	
	int32_t arrayptr = SH::get_arg(sarg1, v) / 10000;
	ArrayManager am(arrayptr);
	if(am.invalid()) return;
	int32_t sz = am.size();
	
	int32_t id = 0, nx = 0, ny = 0;
	
	if ( sz < 1 ) 
	{
		Z_scripterrlog("Invalid array size (%d) passed to npc->Create(). The array size must be [1] or [3].\n", sz);
		return;
	}
	else //size is valid
	{
		id = (am.get(0)/10000);
		
		if ( sz == 3 ) //x and y
		{
			nx = (am.get(1)/10000);
			ny = (am.get(2)/10000);
		}
	}
	
	
	if(BC::checkGuyID(id, "npc->Create()") != SH::_NoError)
		return;
		
	//If we make a segmented enemy there'll be more than one sprite created
	word numcreated = addenemy(nx, ny, id, -10);
	
	if(numcreated == 0)
	{
		ri->guyref = MAX_DWORD;
		Z_scripterrlog("Couldn't create NPC \"%s\", screen NPC limit reached\n", guy_string[id]);
	}
	else
	{
		word index = guys.Count() - numcreated; //Get the main enemy, not a segment
		ri->guyref = guys.spr(index)->getUID();
		
		for(; index<guys.Count(); index++)
			((enemy*)guys.spr(index))->script_spawned=true;
		
		ri->d[rEXP1] = ri->guyref;
		ri->d[rEXP2] = ri->guyref;
		Z_eventlog("Script created NPC \"%s\" with UID = %ld\n", guy_string[id], ri->guyref);
	}
}

bool FFScript::checkExtension(std::string &filename, const std::string &extension)
//inline bool checkExtension(std::string filename, std::string extension)
{
	int32_t dot = filename.find_last_of(".");
	std::string exten = (dot == std::string::npos ? "" : filename.substr(dot, filename.length() - dot));
	return exten == extension;
}


void FFScript::do_loadgamestructs(const bool v, const bool v2)
{
	int32_t arrayptr = SH::get_arg(sarg1, v) / 10000;
	int32_t section_id = SH::get_arg(sarg2, v2) / 10000;
	zprint("do_loadgamestructs selected section is: %d\n", section_id);
	//Bitwise OR sections together
	string strA;
	ArrayH::getString(arrayptr, strA, 256);
	int32_t temp_sram_flags = section_id; int32_t sram_version = 0;

	if ( FFCore.checkExtension(strA, ".zcsram") )
	{
		PACKFILE *f = pack_fopen_password(strA.c_str(),F_READ, "");
		if (f)
		{
			p_igetl(&sram_version,f);
			p_igetl(&section_id,f);
			zprint("Reading ZCSRAM, Version: %d\n", sram_version);
			if ( sram_version > SRAM_VERSION ) //file version is greater than programme current version.
			{
				Z_scripterrlog("SRAM Version is from a version of ZC newer than the running version and cannot be loaded.\n");
				return;
			}
			if ( section_id != temp_sram_flags )
			{
				Z_scripterrlog("Reading an SRAM file with a section flag mismatch!\nThe file section flags are (%d) and the specified flagset is (%d).\nThis may cause errors!\n", section_id, temp_sram_flags);
			}
			
			if ( !section_id || section_id&svGUYS ) FFCore.read_enemies(f,sram_version);
			if ( !section_id || section_id&svITEMS )FFCore.read_items(f,sram_version);
			if ( !section_id || section_id&svWEAPONS ) FFCore.read_weaponsprtites(f,sram_version);
			if ( !section_id || section_id&svCOMBOS ) 
			{
				reset_combo_animations();
				reset_combo_animations2();
				FFCore.read_combos(f,sram_version);
			}
			if ( !section_id || section_id&svDMAPS ) FFCore.read_dmaps(f,sram_version);
			if ( !section_id || section_id&svMAPSCR ) FFCore.read_mapscreens(f,sram_version);
			pack_fclose(f);
			zprint("do_savegamestructs COMPLETED READINV %s, with section ID flags %d\n", "ALL", section_id);
			
			set_register(sarg1, 10000);
		}
		else 
		{
			Z_scripterrlog("FFCore.do_loadgamestructs could not read packfile!");
			set_register(sarg1, -10000);
		}
	}
	else
	{
		Z_scripterrlog("Tried to read a .zcsram file, but the file lacked the ..zcsram extension!\n");
		set_register(sarg1, -20000);
		
	}
}

void FFScript::do_savegamestructs(const bool v, const bool v2)
{
	int32_t arrayptr = SH::get_arg(sarg1, v) / 10000;
	int32_t section_id = SH::get_arg(sarg2, v2) / 10000;
	zprint("do_loadgamestructs selected section is: %d\n", section_id);
	//Bitwise OR sections together
	string strA;
	ArrayH::getString(arrayptr, strA, 256);
	int32_t cycles = 0;

	if ( FFCore.checkExtension(strA, ".zcsram") )
	{
		PACKFILE *f = pack_fopen_password(strA.c_str(),F_WRITE, "");
		if (f)
		{
			p_iputl(SRAM_VERSION,f);
			p_iputl(section_id,f);
			
			if ( !section_id || section_id&svGUYS ) FFCore.write_enemies(f,SRAM_VERSION);
			if ( !section_id || section_id&svITEMS ) FFCore.write_items(f,SRAM_VERSION);
			if ( !section_id || section_id&svWEAPONS ) FFCore.write_weaponsprtites(f,SRAM_VERSION);
			if ( !section_id || section_id&svCOMBOS ) 
			{
				reset_combo_animations();
				reset_combo_animations2();
				FFCore.write_combos(f,SRAM_VERSION);
			}
			if ( !section_id || section_id&svDMAPS ) FFCore.write_dmaps(f,SRAM_VERSION);
			if ( !section_id || section_id&svMAPSCR ) FFCore.write_mapscreens(f,SRAM_VERSION);
			pack_fclose(f);
			zprint("do_savegamestructs COMPLETED WRITING %s, with section ID flags %d\n", "ALL", section_id);
			set_register(sarg1, 10000);
		}
		else 
		{
			Z_scripterrlog("FFCore.do_loadgamestructs could not read packfile!");
			set_register(sarg1, -10000);
		}
	}
	else
	{
		Z_scripterrlog("Tried to write a .zcsram file, but the file lacked the ..zcsram extension!\n");
		set_register(sarg1, -20000);
	}
}

void FFScript::do_strcmp()
{
	int32_t arrayptr_a = ri->d[rINDEX]/10000; //get_register(sarg1) / 10000 ?
	int32_t arrayptr_b = ri->d[rINDEX2]/10000; //get_register(sarg2) / 10000?
	string strA;
	string strB;
	ArrayH::getString(arrayptr_a, strA);
	ArrayH::getString(arrayptr_b, strB);
	set_register(sarg1, (strcmp(strA.c_str(), strB.c_str()) * 10000));
}

void FFScript::do_stricmp()
{
	int32_t arrayptr_a = ri->d[rINDEX]/10000; //get_register(sarg1) / 10000? Index and Index2 are intentional.
	int32_t arrayptr_b = ri->d[rINDEX2]/10000; //get_register(sarg2) / 10000?
	string strA;
	string strB;
	ArrayH::getString(arrayptr_a, strA);
	ArrayH::getString(arrayptr_b, strB);
	set_register(sarg1, (stricmp(strA.c_str(), strB.c_str()) * 10000));
}

void FFScript::do_LowerToUpper(const bool v)
{
	
	int32_t arrayptr_a = get_register(sarg1) / 10000;
	string strA;
	ArrayH::getString(arrayptr_a, strA);
	if ( strA.size() < 1 ) 
	{
		Z_scripterrlog("String passed to UpperToLower() is too small. Size is: %d \n", strA.size());
		set_register(sarg1, 0); return;
	}
	for ( size_t q = 0; q < strA.size(); ++q )
	{
		strA[q] -= 32 * (strA[q] >= 'a' && strA[q] <= 'z');
		//if(( strA[q] >= 'a' && strA[q] <= 'z' ) || ( strA[q] >= 'A' && strA[q] <= 'Z' ))
		//{
		//	if ( strA[q] < 'a' ) { continue; }
		//	else strA[q] -= 32;
		//	continue;
		//}
		
	}
	//zprint("Converted string is: %s \n", strA.c_str());
	if(ArrayH::setArray(arrayptr_a, strA) == SH::_Overflow)
	{
		Z_scripterrlog("Dest string supplied to 'LowerToUpper()' not large enough\n");
		set_register(sarg1, 0);
	}
	else set_register(sarg1, (10000));
}

void FFScript::do_UpperToLower(const bool v)
{
	
	int32_t arrayptr_a = get_register(sarg1) / 10000;
	string strA;
	ArrayH::getString(arrayptr_a, strA);
	if ( strA.size() < 1 ) 
	{
		Z_scripterrlog("String passed to UpperToLower() is too small. Size is: %d \n", strA.size());
		set_register(sarg1, 0); return;
	}
	for ( size_t q = 0; q < strA.size(); ++q )
	{
		strA[q] += 32 * (strA[q] >= 'A' && strA[q] <= 'Z');
		//if(( strA[q] >= 'a' && strA[q] <= 'z' ) || ( strA[q] >= 'A' && strA[q] <= 'Z' ))
		//{
		//	if ( strA[q] < 'a' ) { strA[q] += 32; }
		//	else continue;
		//	continue;
		//}
	}
	//zprint("Converted string is: %s \n", strA.c_str());
	if(ArrayH::setArray(arrayptr_a, strA) == SH::_Overflow)
	{
		Z_scripterrlog("Dest string supplied to 'LowerToUpper()' not large enough\n");
		set_register(sarg1, 0);
	}
	else set_register(sarg1, (10000));
}

void FFScript::do_getnpcscript()
{
	do_get_script_index_by_name(name_to_slot_index_npcmap);
}

void FFScript::do_getcomboscript()
{
	do_get_script_index_by_name(name_to_slot_index_comboscriptmap);
}

void FFScript::do_getgenericscript()
{
	do_get_script_index_by_name(name_to_slot_index_genericmap);
}

void FFScript::do_getlweaponscript()
{
	do_get_script_index_by_name(name_to_slot_index_lwpnmap);
}
void FFScript::do_geteweaponscript()
{
	do_get_script_index_by_name(name_to_slot_index_ewpnmap);
}
void FFScript::do_getheroscript()
{
	do_get_script_index_by_name(name_to_slot_index_playermap);
}
void FFScript::do_getglobalscript()
{
	do_get_script_index_by_name(name_to_slot_index_globalmap);
}
void FFScript::do_getdmapscript()
{
	do_get_script_index_by_name(name_to_slot_index_dmapmap);
}
void FFScript::do_getscreenscript()
{
	do_get_script_index_by_name(name_to_slot_index_screenmap);
}
void FFScript::do_getitemspritescript()
{
	do_get_script_index_by_name(name_to_slot_index_itemspritemap);
}
//Not assigned to slots at present. If they ever are, then this would get the id of any script (any type) by name. -Z
void FFScript::do_getuntypedscript()
{
	set_register(sarg1, 0);
}
void FFScript::do_getsubscreenscript()
{
	do_get_script_index_by_name(name_to_slot_index_subscreenmap);
}
void FFScript::do_getnpcbyname()
{
	int32_t arrayptr = get_register(sarg1) / 10000;
	string the_string;
	int32_t num = -1;
	ArrayH::getString(arrayptr, the_string, 256); //What is the max length of a script identifier?
	
	for(int32_t q = 0; q < MAXNPCS; q++)
	{
		if(!(strcmp(the_string.c_str(), guy_string[q])))
		{
			num = q;
			break;
		}
	}
	set_register(sarg1, (num * 10000));
}	
void FFScript::do_getitembyname()
{
	int32_t arrayptr = get_register(sarg1) / 10000;
	string the_string;
	int32_t num = -1;
	ArrayH::getString(arrayptr, the_string, 256); //What is the max length of a script identifier?
	
	for(int32_t q = 0; q < MAXNPCS; q++)
	{
		if(!(strcmp(the_string.c_str(), item_string[q])))
		{
			num = q;
			break;
		}
	}
	set_register(sarg1, (num * 10000));
}	
void FFScript::do_getcombobyname()
{
	int32_t arrayptr = get_register(sarg1) / 10000;
	string the_string;
	int32_t num = -1;
	ArrayH::getString(arrayptr, the_string, 256);
	
	if (!the_string.empty())
	{
		for(int32_t q = 0; q < MAXCOMBOS; q++)
		{
			if (the_string == combobuf[q].label)
			{
				num = q;
				break;
			}
		}
	}
	set_register(sarg1, (num * 10000));
}
void FFScript::do_getdmapbyname()
{
	int32_t arrayptr = get_register(sarg1) / 10000;
	string the_string;
	int32_t num = -1;
	ArrayH::getString(arrayptr, the_string, 256); //What is the max length of a script identifier?
	
	for(int32_t q = 0; q < MAXDMAPS; q++)
	{
		if(!(strcmp(the_string.c_str(), DMaps[q].name)))
		{
			num = q;
			break;
		}
	}
	set_register(sarg1, (num * 10000));
}

////////////////////////
/// String Utilities ///
////////////////////////
void FFScript::do_ConvertCase(const bool v)
{
	int32_t arrayptr_a = get_register(sarg1) / 10000;
	string strA;
	ArrayH::getString(arrayptr_a, strA);
	if ( strA.size() < 1 ) 
	{
		Z_scripterrlog("String passed to UpperToLower() is too small. Size is: %d \n", strA.size());
		set_register(sarg1, 0); return;
	}
	for ( size_t q = 0; q < strA.size(); ++q )
	{
		if ( strA[q] < 'a' )
			strA[q] += 32 * (strA[q] >= 'A' && strA[q] <= 'Z');
			
		else 
			strA[q] -= 32 * (strA[q] >= 'a' && strA[q] <= 'z');
		//strA[q] -= (32 * (strA[q] >= 'a' && strA[q] <= 'z')) * (-1*((strA[q] >= 'A' && strA[q] <= 'Z')));
		//int32_t n = 'c';
		
		//strA[q] -= 32 * ((strA[q] >= 'a' && strA[q] <= 'z')) * (-1*((strA[q] >= 'A' && strA[q] <= 'Z')));
		//zprint2("n is %d\n", n);
		//if(( strA[q] >= 'a' || strA[q] <= 'z' ) || ( strA[q] >= 'A' || strA[q] <= 'Z' ))
		//{
		//	if ( strA[q] < 'a' ) { strA[q] += 32; }
		//	else strA[q] -= 32;
		//	continue;
		//}
		
	}
	//zprint("Converted string is: %s \n", strA.c_str());
	if(ArrayH::setArray(arrayptr_a, strA) == SH::_Overflow)
	{
		Z_scripterrlog("Dest string supplied to 'LowerToUpper()' not large enough\n");
		set_register(sarg1, 0);
	}
	else set_register(sarg1, (10000));
}

void FFScript::do_xlen(const bool v)
{
	//not implemented, xlen not found
	//zprint("Running: %s\n","strlen()");
	int32_t arrayptr = (SH::get_arg(sarg2, v) / 10000);
	string str;
	ArrayH::getString(arrayptr, str);
	//zprint("strlen string size is: %d\n", str.length());
	//set_register(sarg1, (xlen(str.c_str()) * 10000));
}

void FFScript::do_xtoi(const bool v)
{
	int32_t arrayptr = (SH::get_arg(sarg2, v) / 10000);
	string str;
	ArrayH::getString(arrayptr, str);
	//zprint2("xtoi array pointer is: %d\n", arrayptr);
	//zprint2("xtoi string is %s\n", str.c_str());
	double val = zc_xtoi(const_cast<char*>(str.c_str()));
	//zprint2("xtoi val is %f\n", val);
	set_register(sarg1, (int32_t)(val) * 10000);
}
void FFScript::do_xtoi2() 
{
	int32_t arrayptr_a = ri->d[rINDEX]/10000; //get_register(sarg1) / 10000? Index and Index2 are intentional.
	string strA;
	ArrayH::getString(arrayptr_a, strA);
	set_register(sarg1, (zc_xtoi(strA.c_str()) * 10000));
}

// Calculates log2 of number.  
double FFScript::Log2( double n )  
{  
    // log(n)/log(2) is log2.  
    return log( (double)n ) / log( (double)2 );  
}  

//xtoa, convert hex number to hex ascii
void FFScript::do_xtoa()
{
	
	int32_t arrayptr_a = get_register(sarg1) / 10000;
	int32_t number = get_register(sarg2) / 10000;//ri->d[rEXP2]/10000; //why are you not in sarg2?!!
	
	//for ( int32_t q = 0; q < 6; ++q )
	//	zprint2("ri->d[%d] is %d", q, ri->d[q]);
	
	// zprint2("xtoa_c arrayptr_a is: %d\n",arrayptr_a);
	// zprint2("xtoa_c number is: %d\n",number);
		
	
	
	
	bool isneg = false;
	if ( number < 0 ) 
	{
		isneg = true; 
		number *= -1;
	}
	double num = number;
	// zprint2("xtoa_c(), num is: %f\n", num);
	int32_t digits = num ? floor(FFCore.LogToBase(num, 16) + 1) : 1;
	//sizeof(number)*CHAR_BIT/4;
	// zprint2("xtoa_c, digits is: %d\n",digits);
	
	
	int32_t pos = 0;
	string strA;
	if(number == 0) //Needs to precede str.resize(digits+3) as if the number is <= 0 then this breaks.
	{
		strA.resize(3);
		strA[pos+2] = '0';
		if(ArrayH::setArray(arrayptr_a, strA) == SH::_Overflow)
		{
			Z_scripterrlog("Dest string supplied to 'itoa()' not large enough\n");
			set_register(sarg1, 0);
		}
		else set_register(sarg1, 30000); //returns the pointer to the dest
		return;
	}
	int32_t ret = 0;
	strA.resize(digits+3+(isneg?1:0));
	//num = Floor(Abs(num));
	if ( isneg )
	{
		strA[pos] = '-';
		strA[pos+1] = '0';
		strA[pos+2] = 'x';
		ret = 3;
	}
	else
	{
		strA[pos] = '0';
		strA[pos+1] = 'x';
		ret = 2;
	}

	int32_t alphaoffset = 'A' - 0xA;
	for(int32_t i = 0; i < digits; ++i)
	{
		int32_t coeff = ((int32_t)floor((double)(((double)number) / pow((float)0x10, digits - i - 1))) % 0x10);
		strA[pos + ret + i] = coeff < 0xA ? coeff + '0' : coeff + alphaoffset;
	}
	if(ArrayH::setArray(arrayptr_a, strA) == SH::_Overflow)
	{
		Z_scripterrlog("Dest string supplied to 'xtoa()' not large enough\n");
		set_register(sarg1, 0);
	}
	//set_register(sarg1, (strcat((char)strA.c_str(), strB.c_str()) * 10000));
	else set_register(sarg1, (ret + digits -(isneg?1:0))*10000); //don't count the - sign as a digit
}

void FFScript::do_ilen(const bool v)
{
	int32_t arrayptr = (SH::get_arg(sarg2, v) / 10000);
	string str;
	ArrayH::getString(arrayptr, str);
	//zprint("strlen string size is: %d\n", str.length());
	set_register(sarg1, (FFCore.ilen((char*)str.c_str()) * 10000));
}

//! Note atoi2 (atoi(str, len) can be accompished with str.resize after getString.
void FFScript::do_atoi(const bool v)
{
	int32_t arrayptr = (SH::get_arg(sarg2, v) / 10000);
	string str;
	ArrayH::getString(arrayptr, str);
	set_register(sarg1, (atoi(str.c_str()) * 10000));
}
void FFScript::do_atol(const bool v)
{
	int32_t arrayptr = (SH::get_arg(sarg2, v) / 10000);
	string str;
	ArrayH::getString(arrayptr, str);
	set_register(sarg1, (atoi(str.c_str())));
}

void FFScript::do_strstr()
{
	
	int32_t arrayptr_a = ri->d[rINDEX]/10000; //get_register(sarg1) / 10000? Index and Index2 are intentional.
	int32_t arrayptr_b = ri->d[rINDEX2]/10000; //get_register(sarg2) / 10000?
	string strA;
	string strB;
	ArrayH::getString(arrayptr_a, strA);
	ArrayH::getString(arrayptr_b, strB);
	if ( strA.size() < 1 ) 
	{
		Z_scripterrlog("String passed to strstr() is too small. Size is: %d \n", strA.size());
		set_register(sarg1,-10000);
		return;
	}
	set_register(sarg1, (strA.find(strB) * 10000));
}

void FFScript::do_strcat()
{
	
	int32_t arrayptr_a = ri->d[rINDEX]/10000; //get_register(sarg1) / 10000? Index and Index2 are intentional.
	int32_t arrayptr_b = ri->d[rINDEX2]/10000; //get_register(sarg2) / 10000?
	string strA;
	string strB;
	ArrayH::getString(arrayptr_a, strA);
	ArrayH::getString(arrayptr_b, strB);
	//char str_c[2048];
	//strcpy(str_c, strA.c_str());
	string strC = strA + strB;
	//zprint("strcat string: %s\n", strC.c_str());
	if(ArrayH::setArray(arrayptr_a, strC) == SH::_Overflow)
	{
		Z_scripterrlog("Dest string supplied to 'strcat()' not large enough\n");
		set_register(sarg1, 0);
	}
	//set_register(sarg1, (strcat((char)strA.c_str(), strB.c_str()) * 10000));
	else set_register(sarg1, arrayptr_a); //returns the pointer to the dest
}
void FFScript::do_strspn()
{
	
	int32_t arrayptr_a = ri->d[rINDEX]/10000; //get_register(sarg1) / 10000? Index and Index2 are intentional.
	int32_t arrayptr_b = ri->d[rINDEX2]/10000; //get_register(sarg2) / 10000?
	string strA;
	string strB;
	ArrayH::getString(arrayptr_a, strA);
	ArrayH::getString(arrayptr_b, strB);
	set_register(sarg1, (strspn(strA.c_str(), strB.c_str()) * 10000));
}

void FFScript::do_strcspn()
{
	
	int32_t arrayptr_a = ri->d[rINDEX]/10000; //get_register(sarg1) / 10000? Index and Index2 are intentional.
	int32_t arrayptr_b = ri->d[rINDEX2]/10000;
	string strA;
	string strB;
	ArrayH::getString(arrayptr_a, strA);
	ArrayH::getString(arrayptr_b, strB);
	set_register(sarg1, (strcspn(strA.c_str(), strB.c_str()) * 10000));
}

void FFScript::do_strchr()
{
	
	int32_t arrayptr_a = ri->d[rINDEX]/10000; //get_register(sarg1) / 10000? Index and Index2 are intentional.
	char chr_to_find = (ri->d[rINDEX2]/10000);
	string strA; 
	ArrayH::getString(arrayptr_a, strA);
	if ( strA.size() < 1 ) 
	{
		Z_scripterrlog("String passed to strchr() is too small. Size is: %d \n", strA.size());
		set_register(sarg1,-10000);
		return;
	}
	
	set_register(sarg1,strA.find_first_of(chr_to_find)*10000);
}
void FFScript::do_strrchr()
{
	int32_t arrayptr_a = ri->d[rINDEX]/10000; //get_register(sarg1) / 10000? Index and Index2 are intentional.
	char chr_to_find = (ri->d[rINDEX2]/10000);
	string strA; 
	ArrayH::getString(arrayptr_a, strA);
	if ( strA.size() < 1 ) 
	{
		Z_scripterrlog("String passed to strrchr() is too small. Size is: %d \n", strA.size());
		set_register(sarg1,-10000);
		return;
	}
	set_register(sarg1,strA.find_last_of(chr_to_find)*10000);
}

void FFScript::do_remchr2()
{
	//Not implemented, remchr not found
	//not part of any standard library
	int32_t arrayptr_a = ri->d[rINDEX]/10000; //get_register(sarg1) / 10000? Index and Index2 are intentional.
	string strA;
	ArrayH::getString(arrayptr_a, strA);
	//set_register(sarg1, (remchr(strA.c_str(), (ri->d[rINDEX2]/10000)) * 10000));
}
//Bookmark
void FFScript::do_atoi2()
{
	//not implemented; atoi does not take 2 params
	int32_t arrayptr_a = ri->d[rINDEX]/10000;
	string strA;
	ArrayH::getString(arrayptr_a, strA);
	//set_register(sarg1, (atoi(strA.c_str(), (ri->d[rINDEX2]/10000)) * 10000));
}
void FFScript::do_ilen2()
{
	//not implemented, ilen not found
	int32_t arrayptr_a = ri->d[rINDEX]/10000;
	string strA;
	ArrayH::getString(arrayptr_a, strA);
	//set_register(sarg1, (ilen(strA.c_str(), (ri->d[rINDEX2]/10000)) * 10000));
}
void FFScript::do_xlen2()
{
	//not implemented, xlen not found
	int32_t arrayptr_a = ri->d[rINDEX]/10000;
	string strA;
	ArrayH::getString(arrayptr_a, strA);
	//set_register(sarg1, (xlen(strA.c_str(), (ri->d[rINDEX2]/10000)) * 10000));
}

void FFScript::do_itoa()
{
	int32_t arrayptr_a = get_register(sarg1) / 10000;
	int32_t number = get_register(sarg2) / 10000;
	
	char buf[16];
	zc_itoa(number, buf, 10);
	int32_t ret = ::strlen(buf) * 10000L;
	string strA(buf);
	
	if(ArrayH::setArray(arrayptr_a, strA) == SH::_Overflow)
	{
		Z_scripterrlog("Dest string supplied to 'itoa()' not large enough\n");
		set_register(sarg1, -1);
	}
	else set_register(sarg1, ret); //returns the number of digits used
}

void FFScript::do_itoacat()
{
	
	int32_t arrayptr_a = get_register(sarg1) / 10000;
	int32_t number = get_register(sarg2) / 10000;
	
	// zprint2("itoacat arrayptr_a is: %d\n",arrayptr_a);
	// zprint2("itoacat number is: %d\n",number);
		
	double num = number;
	int32_t digits = FFCore.numDigits(number); //int32_t(log10(temp) * 10000.0)
	// zprint2("itoacat, digits is: %d\n",digits);
	int32_t pos = 0;
	int32_t ret = 0;
	string strA;
	string strB;
	strB.resize(digits);
	ArrayH::getString(arrayptr_a, strA);
	if(num < 0)
	{
		strB.resize(digits+1);
		strB[pos] = '-';
		++ret;
		num = -num;
	}
	else if(num == 0)
	{
		strB[pos] = '0';
		string strC = strA + strB;
		if(ArrayH::setArray(arrayptr_a, strC) == SH::_Overflow)
		{
			Z_scripterrlog("Dest string supplied to 'itoacat()' not large enough\n");
			set_register(sarg1, 0);
		}
		else set_register(sarg1, arrayptr_a); //returns the pointer to the dest
		return;
	}

	
	for(int32_t i = 0; i < digits; ++i)
		strB[pos + ret + i] = ((int32_t)floor((double)(num / pow((float)10, digits - i - 1))) % 10) + '0';
	
	string strC = strA + strB;
	if(ArrayH::setArray(arrayptr_a, strC) == SH::_Overflow)
	{
		Z_scripterrlog("Dest string supplied to 'itoacat()' not large enough\n");
		set_register(sarg1, 0);
	}
	//set_register(sarg1, (strcat((char)strB.c_str(), strB.c_str()) * 10000));
	else set_register(sarg1, arrayptr_a); //returns the pointer to the dest
}

/*
void FFScript::do_itoa()
{
	
	int32_t arrayptr_a = ri->d[rINDEX2]/10000;
	int32_t value = ri->d[rINDEX]/10000;
	char the_string[13];
	char* chrptr = NULL;
	chrptr = zc_itoa(value, the_string, 10);
	//Returns the number of characters used. 
	if(ArrayH::setArray(arrayptr_a, the_string) == SH::_Overflow)
		Z_scripterrlog("Dest string supplied to 'itoa()' not large enough\n");
	set_register(sarg1, (FFCore.zc_strlen(the_string)*10000));
}
*/

void FFScript::do_strcpy(const bool a, const bool b)
{
	int32_t arrayptr_b = SH::get_arg(sarg1, a) / 10000;
	int32_t arrayptr_a = SH::get_arg(sarg2, b) / 10000;
	
	string strA;

	ArrayH::getString(arrayptr_a, strA);

	if(ArrayH::setArray(arrayptr_b, strA) == SH::_Overflow)
		Z_scripterrlog("Dest string supplied to 'strcpy()' not large enough\n");
}
void FFScript::do_arraycpy(const bool a, const bool b)
{
	int32_t arrayptr_dest = SH::get_arg(sarg1, a) / 10000;
	int32_t arrayptr_src = SH::get_arg(sarg2, b) / 10000;
	ArrayH::copyValues(arrayptr_dest, arrayptr_src, ArrayH::getSize(arrayptr_src));
}
void FFScript::do_strlen(const bool v)
{
	//zprint("Running: %s\n","strlen()");
	int32_t arrayptr = (SH::get_arg(sarg2, v) / 10000);
	string str;
	ArrayH::getString(arrayptr, str);
	//zprint("strlen string size is: %d\n", str.length());
	set_register(sarg1, (str.length() * 10000));
}

void FFScript::do_strncmp()
{
	int32_t arrayptr_a = ri->d[rINDEX]/10000;
	int32_t arrayptr_b = ri->d[rEXP2]/10000;
	int32_t len = ri->d[rEXP1]/10000;
	string strA;
	string strB;
	ArrayH::getString(arrayptr_a, strA);
	ArrayH::getString(arrayptr_b, strB);
	set_register(sarg1, (strncmp(strA.c_str(), strB.c_str(), len) * 10000));
}

void FFScript::do_strnicmp()
{
	int32_t arrayptr_a = ri->d[rINDEX]/10000;
	int32_t arrayptr_b = ri->d[rEXP2]/10000;
	int32_t len = ri->d[rEXP1]/10000;
	string strA;
	string strB;
	ArrayH::getString(arrayptr_a, strA);
	ArrayH::getString(arrayptr_b, strB);
	set_register(sarg1, (ustrnicmp(strA.c_str(), strB.c_str(), len) * 10000));
}

void FFScript::do_npc_canmove(const bool v)
{
	int32_t arrayptr = SH::get_arg(sarg1, v) / 10000;
	int32_t sz = ArrayH::getSize(arrayptr);
	//bool can_mv = false;
	if(GuyH::loadNPC(ri->guyref, "npc->CanMove()") == SH::_NoError)
	{
		ArrayManager am(arrayptr);
		if(am.invalid()) return;
		if ( sz == 1 ) //bool canmove(int32_t ndir): dir only, uses 'step' IIRC
		{
			set_register(sarg1, ( GuyH::getNPC()->canmove((am.get(0)/10000),false)) ? 10000 : 0);
		}
		else if ( sz == 2 ) //bool canmove(int32_t ndir, int32_t special): I think that this also uses the default 'step'
		{
			set_register(sarg1, ( GuyH::getNPC()->canmove((am.get(0)/10000),(zfix)(am.get(1)/10000), false)) ? 10000 : 0);
		}
		else if ( sz == 3 ) //bool canmove(int32_t ndir,zfix s,int32_t special) : I'm pretty sure that 'zfix s' is 'step' here. 
		{
			set_register(sarg1, ( GuyH::getNPC()->canmove((am.get(0)/10000),(zfix)(am.get(1)/10000),(am.get(2)/10000),false)) ? 10000 : 0);
		}
		else if ( sz == 7 ) //bool canmove(int32_t ndir,zfix s,int32_t special) : I'm pretty sure that 'zfix s' is 'step' here. 
		{
			set_register(sarg1, ( GuyH::getNPC()->canmove((am.get(0)/10000),(zfix)(am.get(1)/10000),(am.get(2)/10000),(am.get(3)/10000),(am.get(4)/10000),(am.get(5)/10000),(am.get(6)/10000),false)) ? 10000 : 0);
		}
		else 
		{
			Z_scripterrlog("Invalid array size (%d) passed to npc->CanMove(). The array size must be [1], [2], [3], or [7].\n", sz);
			//can_mv = false;
			set_register(sarg1, 0);
		}
	}
	//set_register(sarg1, ( can_mv ? 10000 : 0));
}

//void do_get_enh_music_filename(const bool v)
void FFScript::get_npcdata_initd_label(const bool v)
{
	int32_t init_d_index = SH::get_arg(sarg1, v) / 10000;
	int32_t arrayptr = get_register(sarg2) / 10000;
	
	if((unsigned)init_d_index > 7)
	{
	Z_scripterrlog("Invalid InitD[] index (%d) passed to npcdata->GetInitDLabel().\n", init_d_index);
	return;
	}
		
	if(ArrayH::setArray(arrayptr, string(guysbuf[ri->npcdataref].initD_label[init_d_index])) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'npcdata->GetInitDLabel()' not large enough\n");
}

/////////////////////
/// MATHS HELPERS ///
/////////////////////

//Returns the log of val to the base 10. Any value <= 0 will return 0.
int32_t FFScript::Log10(double temp)
{
	int32_t ret = 0;
	if(temp > 0)
		ret = int32_t(log10(temp) * 10000.0);
	else ret = 0;
	return ret;
}

//Returns the number of digits in a given integer. 
int32_t FFScript::numDigits(int32_t number)
{
	int32_t digits = 0;
	while (number) 
	{
		number /= 10;
		digits++;
	}
	return digits;
}

// Returns the natural logarithm of val (to the base e). Any value <= 0 will return 0.
double FFScript::ln(double temp)
{
	
	if(temp > 0)
		return (log(temp));
	else
	{
		return 0;
	}
}

// Returns the logarithm of x to the given base.
double FFScript::LogToBase(double x, double base)
{
	if(x <= 0 || base <= 0) return 0;
	return FFCore.ln(x)/FFCore.ln(base);
}


///----------------------------------------------------------------------------------------------------//
//Debugger and Logging Consoles

template <typename ...Params>
void FFScript::ZScriptConsole(int32_t attributes,const char *format, Params&&... params)
{
	//if ( open )
	{
		zscript_coloured_console.Create("ZQuest Classic Logging Console", 600, 200, NULL, NULL);
		zscript_coloured_console.cls(CConsoleLoggerEx::COLOR_BACKGROUND_BLACK);
		zscript_coloured_console.gotoxy(0,0);
		zscript_coloured_console.cprintf( CConsoleLoggerEx::COLOR_BLUE | CConsoleLoggerEx::COLOR_INTENSITY |
		CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"ZQuest Classic Logging Console\n");
	
		zscript_coloured_console.cprintf( attributes, format, std::forward<Params>(params)...);
	}
	//else
	//{
		//close
	//	zscript_coloured_console.Close();
	//}
}

void clearConsole()
{
	zscript_coloured_console.cls(CConsoleLoggerEx::COLOR_BACKGROUND_BLACK);
	zscript_coloured_console.gotoxy(0,0);

	zscript_coloured_console.cprintf( CConsoleLoggerEx::COLOR_RED | CConsoleLoggerEx::COLOR_BLUE | CConsoleLoggerEx::COLOR_INTENSITY |
		CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"\n       _____   ____                  __ \n");
	zscript_coloured_console.cprintf( CConsoleLoggerEx::COLOR_RED | CConsoleLoggerEx::COLOR_BLUE | CConsoleLoggerEx::COLOR_INTENSITY |
		CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"      /__  /  / __ \\__  _____  _____/ /_\n");
	zscript_coloured_console.cprintf( CConsoleLoggerEx::COLOR_RED | CConsoleLoggerEx::COLOR_BLUE | CConsoleLoggerEx::COLOR_INTENSITY |
		CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"        / /  / / / / / / / _ \\/ ___/ __/\n");
	zscript_coloured_console.cprintf( CConsoleLoggerEx::COLOR_RED | CConsoleLoggerEx::COLOR_BLUE | CConsoleLoggerEx::COLOR_INTENSITY |
		CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"       / /__/ /_/ / /_/ /  __(__  ) /_ \n");
	zscript_coloured_console.cprintf( CConsoleLoggerEx::COLOR_RED | CConsoleLoggerEx::COLOR_BLUE | CConsoleLoggerEx::COLOR_INTENSITY |
		CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"      /____/\\___\\_\\__,_/\\___/____/\\__/\n\n");

	zscript_coloured_console.cprintf( CConsoleLoggerEx::COLOR_BLUE | CConsoleLoggerEx::COLOR_INTENSITY |
		CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"ZC Console\n");
	
	zscript_coloured_console.cprintf( CConsoleLoggerEx::COLOR_BLUE |CConsoleLoggerEx::COLOR_GREEN | CConsoleLoggerEx::COLOR_INTENSITY |
		CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"Running: %s\n", getVersionString());
	if ( FFCore.getQuestHeaderInfo(vZelda) > 0 )
	{
		char const* verstr = QHeader.getVerStr();
		if(verstr[0])
		{
			auto vercmp = QHeader.compareVer();
			auto astatecmp = compare(int32_t(QHeader.getAlphaState()), getAlphaState());
			auto avercmp = compare(QHeader.getAlphaVer(), 0);
			auto timecmp = QHeader.compareDate();
			if(!(vercmp || astatecmp || avercmp))
			{
				if(!timecmp || !QHeader.new_version_is_nightly)
					zscript_coloured_console.cprintf( CConsoleLoggerEx::COLOR_BLUE |CConsoleLoggerEx::COLOR_GREEN | CConsoleLoggerEx::COLOR_INTENSITY |
						CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"Quest Made in this build\n", verstr);
				else if(timecmp < 0)
				{
					zscript_coloured_console.cprintf( CConsoleLoggerEx::COLOR_BLUE |CConsoleLoggerEx::COLOR_GREEN | CConsoleLoggerEx::COLOR_INTENSITY |
						CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"Quest Made in an earlier nightly of the same build\n", verstr);
				}
				else
				{
					zscript_coloured_console.cprintf( CConsoleLoggerEx::COLOR_BLUE |CConsoleLoggerEx::COLOR_GREEN | CConsoleLoggerEx::COLOR_INTENSITY |
						CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"Quest Made in an LATER nightly of the same build!\n"
							"This may be unsafe to play in this version!\n", verstr);
				}
			}
			else zscript_coloured_console.cprintf( CConsoleLoggerEx::COLOR_BLUE |CConsoleLoggerEx::COLOR_GREEN | CConsoleLoggerEx::COLOR_INTENSITY |
				CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"Quest Made in: %s\n", verstr);
		}
	}
}
void FFScript::ZScriptConsole(bool open)
{
	if ( open )
	{
		zscript_coloured_console.Create("ZC Console", 600, 200, NULL, NULL);
		clearConsole();
		console_enabled = 1;
	}
	else
	{
		zscript_coloured_console.Close();
		console_enabled = 0;
	}
	zc_set_config("CONSOLE","enabled",console_enabled);
}

///----------------------------------------------------------------------------------------------------//
//Tracing

void FFScript::do_trace(bool v)
{
	bool should_replay_trace = replay_is_active() && replay_get_meta_bool("script_trace");
	// For now, only prevent tracing to allegro log for Web version. Some quests may expect players to
	// look in the logs for spoiler/secret stuff.
#ifdef __EMSCRIPTEN__
	bool should_trace = console_enabled || should_replay_trace;
	if (!should_trace) return;
#endif

	int32_t temp = SH::get_arg(sarg1, v);
	
	char tmp[100];
	sprintf(tmp, (temp < 0 ? "%06d" : "%05d"), temp);
	string s2(tmp);
	s2 = s2.substr(0, s2.size() - 4) + "." + s2.substr(s2.size() - 4, 4) + "\n";
	TraceScriptIDs();
	al_trace("%s", s2.c_str());
	if (should_replay_trace)
		replay_step_comment("trace: " + s2);
	
	if ( console_enabled ) 
	{
		zscript_coloured_console.safeprint((CConsoleLoggerEx::COLOR_WHITE | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK),s2.c_str());
	}
}
void FFScript::do_tracel(bool v)
{
	int32_t temp = SH::get_arg(sarg1, v);
	
	char tmp[32];
	sprintf(tmp, "%d\n", temp);
	TraceScriptIDs();
	al_trace("%s", tmp);
	if (replay_is_active() && replay_get_meta_bool("script_trace"))
		replay_step_comment(fmt::format("trace: {}", temp));
	
	if ( console_enabled ) 
	{
		zscript_coloured_console.safeprint((CConsoleLoggerEx::COLOR_WHITE | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK),tmp);
	}
}

void FFScript::do_tracebool(const bool v)
{
	int32_t temp = SH::get_arg(sarg1, v);
	TraceScriptIDs();
	char const* str = temp ? "true\n" : "false\n";
	al_trace("%s", str);
	if (replay_is_active() && replay_get_meta_bool("script_trace"))
		replay_step_comment(fmt::format("trace: {}", (bool)temp));
	
	if ( console_enabled ) 
	{
		zscript_coloured_console.safeprint((CConsoleLoggerEx::COLOR_WHITE | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK),str);
	}
}

void traceStr(string const& str)
{
	FFCore.TraceScriptIDs();
	safe_al_trace(str);
	if (replay_is_active() && replay_get_meta_bool("script_trace"))
		replay_step_comment("trace: " + str);
	
	if ( console_enabled ) 
	{
		zscript_coloured_console.safeprint((CConsoleLoggerEx::COLOR_WHITE | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK),str.c_str());
	}
}

void FFScript::do_tracestring()
{
	int32_t arrayptr = get_register(sarg1) / 10000;
	string str;
	ArrayH::getString(arrayptr, str, 512);
	str += "\0"; //In the event that the user passed an array w/o NULL, don't crash.
	traceStr(str);
}

bool is_valid_format(char c)
{
	switch(c)
	{
		case 'f': case 'd': case 'i': case 'p':
		case 'l': case 's': case 'c': case 'X':
		case 'x': case 'b': case 'B': case 'a':
			return true;
	}
	return false;
}
#define FORMATTER_FLAG_0FILL    0x01
char const* zs_formatter(char const* format, int32_t arg, int32_t mindig, dword flags)
{
	static std::string ret;
	
	ret.clear();
	if(format)
	{
		std::string mdstr = fmt::format("%{}{}{}",(flags&FORMATTER_FLAG_0FILL)?"0":"",
			mindig, (format[0] == 'x' || format[0] == 'X') ? format[0] : 'd');
		char const* mindigbuf = mdstr.c_str();
		bool tempbool = false;
		switch(format[0])
		{
			case 'f':
				tempbool = true;
				[[fallthrough]];
			case 'd':
				if(arg%10000)
					tempbool = true;
				[[fallthrough]];
			case 'i':
			case 'p':
			{
				char argbuf[32] = {0};
				bool neg = arg < 0;
				if(mindig)
					sprintf(argbuf,mindigbuf,arg / 10000);
				else zc_itoa(arg / 10000, argbuf);
				
				if(tempbool) //add decimal places
				{
					arg = abs(arg);
					auto ind = strlen(argbuf);
					argbuf[ind++] = '.';
					for(int div = 1000; div > 0; div /= 10)
						argbuf[ind++] = '0' + (arg/div)%10;
					for(--ind; argbuf[ind]=='0' && argbuf[ind-1]!='-'; --ind)
					{
						argbuf[ind] = 0;
					}
				}
				
				if(neg && argbuf[0] != '-')
					ret = "-";
				ret += argbuf;
				return ret.c_str();
			}
			//
			case 'l':
			{
				char argbuf[32] = {0};
				if(mindig)
					sprintf(argbuf, mindigbuf, arg);
				else zc_itoa(arg, argbuf);
				
				ret = argbuf;
				return ret.c_str();
			}
			//
			case 's':
			{
				if(mindig)
					Z_scripterrlog("Cannot use minimum digits flag for '%%s'\n");
				if(arg)
				{
					int32_t strptr = (arg / 10000);
					ArrayManager am(strptr);
					if(am.invalid())
						ret = "<INVALID STRING>";
					else ArrayH::getString(strptr, ret, MAX_ZC_ARRAY_SIZE);
				}
				else ret = "<NULL>";
				return ret.c_str();
			}
			case 'c':
			{
				if(mindig)
					Z_scripterrlog("Cannot use minimum digits flag for '%%c'\n");
				int32_t c = (arg / 10000);
				if ( (byte(c)) != c )
				{
					Z_scripterrlog("Illegal char value (%d) passed to sprintf as '%%c' arg\n", c);
					Z_scripterrlog("Value of invalid char will overflow.\n");
				}
				ret.push_back(byte(c));
				return ret.c_str();
			}
			//
			case 'X':
				tempbool = true;
				[[fallthrough]];
			case 'x':
			{
				char argbuf[32] = {0};
				if(mindig)
					sprintf(argbuf,mindigbuf,arg / 10000);
				else zc_itoa( (arg/10000), argbuf, 16 ); //base 16; hex
				
				for ( int32_t inx = 0; inx < 16; ++inx ) //set chosen caps
				{
					argbuf[inx] = ( tempbool ? toupper(argbuf[inx]) : tolower(argbuf[inx]) );
				}
				ret = "0x";
				ret += argbuf;
				return ret.c_str();
			}
			//
			case 'b': //int binary
				arg /= 10000;
				[[fallthrough]];
			case 'B': //long binary
			{
				char argbuf[33] = {0};
				int num_digits = mindig;
				for(int q = num_digits; q < 32; ++q)
					if(arg&(1<<q))
						num_digits = q+1;
				for(int q = 0; q < num_digits; ++q)
				{
					argbuf[q] = (arg&(1<<(num_digits-q-1)))
						? '1' : '0';
				}
				ret = argbuf;
				return ret.c_str();
			}
			case 'a': //array
			{
				if(arg)
				{
					if(!is_valid_format(format[1]))
					{
						Z_scripterrlog("Format '%%a%c' is invalid!\n",format[1]);
						break;
					}
					ArrayManager am(arg/10000);
					ret = am.asString([&](int32_t val)
						{
							return zs_formatter(format+1, val, mindig, flags);
						}, 214748);
				}
				else ret = "{ NULL }";
				return ret.c_str();
			}
			default:
			{
				Z_scripterrlog("Error: '%%%c' is not a valid printf argument.\n",format[0]);
				return ret.c_str();
			}
		}
	}
	Z_scripterrlog("Error: No format parameter given for zs_formatter\n");
	return ret.c_str();
}

static int32_t zspr_varg_getter(int32_t,int32_t next_arg)
{
	return zs_vargs.at(next_arg);
}
static int32_t zspr_stack_getter(int32_t num_args, int32_t next_arg)
{
	return SH::read_stack(((ri->sp + num_args) - 1) - next_arg);
}
string zs_sprintf(char const* format, int32_t num_args, std::function<int32_t(int32_t,int32_t)> arg_getter)
{
	int32_t next_arg = 0;
	bool is_old_args = get_qr(qr_OLD_PRINTF_ARGS);
	ostringstream oss;
	while(format[0] != '\0')
	{
		int32_t arg_val = 0;
		if(next_arg < num_args)
		{
			arg_val = arg_getter(num_args,next_arg);
		}
		else if(get_qr(qr_PRINTF_NO_0FILL))
		{
			oss << format;
			return oss.str();
		}
		char buf[256] = {0};
		for ( int32_t q = 0; q < 256; ++q )
		{
			if(format[0] == '\0') //done
			{
				oss << buf;
				return oss.str();
			}
			else if(format[0] == '%')
			{
				++format;
				int32_t min_digits = 0;
				dword formatter_flags = 0;
				if(format[0] >= '0' && format[0] <= '9' && !is_old_args)
				{
					char argbuf[4] = {0};
					int32_t q = 0;
					if(format[0] == '0') //Leading 0 means to 0-fill, and gets eaten
						formatter_flags |= FORMATTER_FLAG_0FILL;
					else --format; //else don't eat
					while(q < 4)
					{
						++format;
						char c = format[0];
						if(c == '\0')
						{
							Z_scripterrlog("Cannot use minimum digits flag with no argument\n");
							oss << buf;
							return oss.str();
						}
						if(c >= '0' && c <= '9')
							argbuf[q++] = c;
						else
						{
							--format;
							break;
						}
					}
					++format;
					min_digits = atoi(argbuf);
					if(!min_digits)
					{
						Z_scripterrlog("Error formatting string: Invalid number '%s'\n", argbuf);
					}
				}
				bool bin = (format[0] == 'b' || format[0] == 'B');
				bool hex = (format[0] == 'x' || format[0] == 'X');
				if(bin)
				{
					if(min_digits > 32)
					{
						Z_scripterrlog("Min digits argument cannot be larger than 32!"
							" Value will be truncated to 32.");
						min_digits = 32;
					}
				}
				else if(min_digits > 10)
				{
					Z_scripterrlog("Min digits argument cannot be larger than 10!"
						" Value will be truncated to 10.");
					min_digits = 10;
				}
				
				bool tempbool = false;
				switch( format[0] )
				{
					case 'd':
					case 'f':
					case 'i': case 'p':
					case 'l':
					case 's':
					case 'c':
					case 'x': case 'X':
					case 'b':  case 'B':
					{
						++next_arg;
						oss << buf << zs_formatter(format,arg_val,min_digits,formatter_flags);
						q = 300; //break main loop
						break;
					}
					case 'a': //array print
					{
						++next_arg;
						oss << buf << zs_formatter(format,arg_val,min_digits,formatter_flags);
						while(format[0] == 'a')
						{
							if(is_valid_format(format[1]))
								++format;
							else break;
						}
						q = 300; //break main loop
						break;
					}
					case '%':
					{
						if(min_digits)
							Z_scripterrlog("Cannot use minimum digits flag for '%%%%'\n");
						buf[q] = '%';
						break;
					}
					default:
					{
						if(is_old_args)
							buf[q] = format[0];
						else
						{
							Z_scripterrlog("Error: '%%%c' is not a valid printf argument.\n",format[0]);
						}
						break;
					}
				}
				++format;
			}
			else
			{
				buf[q] = format[0];
				++format;
			}
			if(q == 255)
			{
				oss << buf;
				break;
			}
		}
	}
	return oss.str();
}

void FFScript::do_printf(const bool v, const bool varg)
{
	int32_t num_args, format_arrayptr;
	if(varg)
	{
		num_args = zs_vargs.size();
		format_arrayptr = SH::read_stack(ri->sp) / 10000;
	}
	else
	{
		num_args = SH::get_arg(sarg1, v) / 10000;
		format_arrayptr = SH::read_stack(ri->sp + num_args) / 10000;
	}
	ArrayManager fmt_am(format_arrayptr);
	if(!fmt_am.invalid())
	{
		string formatstr;
		ArrayH::getString(format_arrayptr, formatstr, MAX_ZC_ARRAY_SIZE);
		
		traceStr(zs_sprintf(formatstr.c_str(), num_args, varg ? zspr_varg_getter : zspr_stack_getter));
	}
	if(varg)
		zs_vargs.clear();
}
void FFScript::do_sprintf(const bool v, const bool varg)
{
	int32_t num_args, dest_arrayptr, format_arrayptr;
	if(varg)
	{
		num_args = zs_vargs.size();
		dest_arrayptr = SH::read_stack(ri->sp + 1) / 10000;
		format_arrayptr = SH::read_stack(ri->sp) / 10000;
	}
	else
	{
		num_args = SH::get_arg(sarg1, v) / 10000;
		dest_arrayptr = SH::read_stack(ri->sp + num_args + 1) / 10000;
		format_arrayptr = SH::read_stack(ri->sp + num_args) / 10000;
	}
	ArrayManager fmt_am(format_arrayptr);
	ArrayManager dst_am(dest_arrayptr);
	if(fmt_am.invalid() || dst_am.invalid())
		ri->d[rEXP1] = 0;
	else
	{
		string formatstr;
		ArrayH::getString(format_arrayptr, formatstr, MAX_ZC_ARRAY_SIZE);
		
		string output = zs_sprintf(formatstr.c_str(), num_args, varg ? zspr_varg_getter : zspr_stack_getter);
		if(ArrayH::setArray(dest_arrayptr, output, true) == SH::_Overflow)
		{
			Z_scripterrlog("Dest string supplied to 'sprintf()' not large enough and cannot be resized\n");
			ri->d[rEXP1] = ArrayH::strlen(dest_arrayptr);
		}
		else ri->d[rEXP1] = output.size();
	}
	if(varg)
		zs_vargs.clear();
}
void FFScript::do_printfarr()
{
	int32_t format_arrayptr = SH::read_stack(ri->sp + 1) / 10000,
		args_arrayptr = SH::read_stack(ri->sp + 0) / 10000;
	ArrayManager fmt_am(format_arrayptr);
	ArrayManager arg_am(args_arrayptr);
	if(!(fmt_am.invalid() || arg_am.invalid()))
	{
		auto num_args = arg_am.size();
		string formatstr;
		ArrayH::getString(format_arrayptr, formatstr, MAX_ZC_ARRAY_SIZE);
		
		traceStr(zs_sprintf(formatstr.c_str(), num_args,
			[&](int32_t,int32_t next_arg)
			{
				return arg_am.get(next_arg);
			}));
	}
}
void FFScript::do_sprintfarr()
{
	int32_t dest_arrayptr = SH::read_stack(ri->sp + 2) / 10000,
		format_arrayptr = SH::read_stack(ri->sp + 1) / 10000,
		args_arrayptr = SH::read_stack(ri->sp + 0) / 10000;
	ArrayManager fmt_am(format_arrayptr);
	ArrayManager arg_am(args_arrayptr);
	ArrayManager dst_am(dest_arrayptr);
	if(fmt_am.invalid() || arg_am.invalid() || dst_am.invalid())
		ri->d[rEXP1] = 0;
	else
	{
		auto num_args = arg_am.size();
		string formatstr;
		ArrayH::getString(format_arrayptr, formatstr, MAX_ZC_ARRAY_SIZE);
		
		string output = zs_sprintf(formatstr.c_str(), num_args,
			[&](int32_t,int32_t next_arg)
			{
				return arg_am.get(next_arg);
			});
		
		if(ArrayH::setArray(dest_arrayptr, output, true) == SH::_Overflow)
		{
			Z_scripterrlog("Dest string supplied to 'sprintfa()' not large enough and cannot be resized\n");
			ri->d[rEXP1] = ArrayH::strlen(dest_arrayptr);
		}
		else ri->d[rEXP1] = output.size();
	}
}
void FFScript::do_varg_max()
{
	int32_t num_args = zs_vargs.size();
	int32_t val = 0;
	if (num_args > 0)
		val = zs_vargs.at(0);
	for(auto q = 1; q < num_args; ++q)
	{
		int32_t tval = zs_vargs.at(q);
		if(tval > val) val = tval;
	}
	zs_vargs.clear();
	ri->d[rEXP1] = val;
}
void FFScript::do_varg_min()
{
	int32_t num_args = zs_vargs.size();
	int32_t val = 0;
	if (num_args > 0)
		val = zs_vargs.at(0);
	for(auto q = 1; q < num_args; ++q)
	{
		int32_t tval = zs_vargs.at(q);
		if(tval < val) val = tval;
	}
	zs_vargs.clear();
	ri->d[rEXP1] = val;
}
void FFScript::do_varg_choose()
{
	int32_t num_args = zs_vargs.size();
	int32_t val = 0;
	if(num_args > 0)
	{
		int32_t choice = zc_rand(num_args-1);
		val = zs_vargs.at(choice);
	}
	zs_vargs.clear();
	ri->d[rEXP1] = val;
}
void FFScript::do_varg_makearray(ScriptType type, const uint32_t UID)
{
	size_t num_args = zs_vargs.size();
	//
	dword ptrval;
	for(ptrval = 1; localRAM[ptrval].Valid(); ptrval++) ;
	
	if(ptrval >= NUM_ZSCRIPT_ARRAYS)
	{
		Z_scripterrlog("%d local arrays already in use, no more can be allocated\n", NUM_ZSCRIPT_ARRAYS-1);
		ptrval = 0;
	}
	else
	{
		ZScriptArray &a = localRAM[ptrval]; //marginally faster for large arrays if we use a reference
		
		a.Resize(num_args);
		a.setValid(true);
		
		for(size_t j = 0; j < num_args; ++j)
			a[j] = zs_vargs[j]; //initialize array
		
		arrayOwner[ptrval].reown(type, UID);
	}
	//
	zs_vargs.clear();
	ri->d[rEXP1] = ptrval*10000;
}

void FFScript::do_breakpoint()
{
	// TODO: implement as `debugger;` statement when VS Code extension exists.
}

void FFScript::do_tracenl()
{
	safe_al_trace("\n");
	
	if ( console_enabled ) 
	{
		zscript_coloured_console.safeprint((CConsoleLoggerEx::COLOR_WHITE | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK),"\n");
	}
}


void FFScript::TraceScriptIDs()
{
	if(DEVTIMESTAMP)
	{
		CConsoleLoggerEx console = zscript_coloured_console;
		bool cond = console_enabled;
		
		char buf[256] = {0};
		//Calculate timestamp
		struct tm * tm_struct;
		time_t sysRTC;
		time (&sysRTC);
		tm_struct = localtime (&sysRTC);
		
		sprintf(buf, "[%d:%d:%d] ", tm_struct->tm_hour, tm_struct->tm_min, tm_struct->tm_sec);
		//
		
		al_trace("%s", buf);
		if ( cond ) {console.safeprint((CConsoleLoggerEx::COLOR_GREEN | CConsoleLoggerEx::COLOR_INTENSITY | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK),buf); }
	}
	if(get_qr(qr_TRACESCRIPTIDS) || DEVLOGGING )
	{
		CConsoleLoggerEx console = zscript_coloured_console;
		bool cond = console_enabled;
		char buf[256] = {0};
		if(script_funcrun)
		{
			sprintf(buf, "Destructor(%d,%s): ", ri->thiskey, destructstr?destructstr->c_str():"UNKNOWN");
		}
		else switch(curScriptType)
		{
			case ScriptType::Global:
			{
				switch(curScriptNum)
				{
					case GLOBAL_SCRIPT_INIT:
						sprintf(buf, "Global Init(%s): ", globalmap[curScriptNum].scriptname.c_str());
						break;
					case GLOBAL_SCRIPT_GAME:
						sprintf(buf, "Global Active(%s): ", globalmap[curScriptNum].scriptname.c_str());
						break;
					case GLOBAL_SCRIPT_END:
						sprintf(buf, "Global Exit(%s): ", globalmap[curScriptNum].scriptname.c_str());
						break;
					case GLOBAL_SCRIPT_ONSAVELOAD:
						sprintf(buf, "Global SaveLoad(%s): ", globalmap[curScriptNum].scriptname.c_str());
						break;
					case GLOBAL_SCRIPT_ONLAUNCH:
						sprintf(buf, "Global Launch(%s): ", globalmap[curScriptNum].scriptname.c_str());
						break;
					case GLOBAL_SCRIPT_ONCONTGAME:
						sprintf(buf, "Global ContGame(%s): ", globalmap[curScriptNum].scriptname.c_str());
						break;
					case GLOBAL_SCRIPT_F6:
						sprintf(buf, "Global F6Menu(%s): ", globalmap[curScriptNum].scriptname.c_str());
						break;
					case GLOBAL_SCRIPT_ONSAVE:
						sprintf(buf, "Global Save(%s): ", globalmap[curScriptNum].scriptname.c_str());
						break;
				}
				break;
			}
			
			case ScriptType::Player:
			{
				switch(curScriptNum)
				{
					case SCRIPT_PLAYER_INIT:
						sprintf(buf, "Player Init(%s): ", playermap[curScriptNum-1].scriptname.c_str());
						break;
					case SCRIPT_PLAYER_ACTIVE:
						sprintf(buf, "Player Active(%s): ", playermap[curScriptNum-1].scriptname.c_str());
						break;
					case SCRIPT_PLAYER_DEATH:
						sprintf(buf, "Player Death(%s): ", playermap[curScriptNum-1].scriptname.c_str());
						break;
					case SCRIPT_PLAYER_WIN:
						sprintf(buf, "Player Win(%s): ", playermap[curScriptNum-1].scriptname.c_str());
						break;
				}
				break;
			}
			
			case ScriptType::Lwpn:
				sprintf(buf, "LWeapon(%u, %s): ", curScriptNum,lwpnmap[curScriptNum-1].scriptname.c_str());
				break;
			
			case ScriptType::Ewpn:
				sprintf(buf, "EWeapon(%u, %s): ", curScriptNum,ewpnmap[curScriptNum-1].scriptname.c_str());
				break;
			
			case ScriptType::NPC:
				sprintf(buf, "NPC(%u, %s): ", curScriptNum,npcmap[curScriptNum-1].scriptname.c_str());
				break;
				
			case ScriptType::FFC:
				sprintf(buf, "FFC(%u, %s): ", curScriptNum,ffcmap[curScriptNum-1].scriptname.c_str());
				break;
				
			case ScriptType::Item:
				sprintf(buf, "Item(%u, %s): ", curScriptNum,itemmap[curScriptNum-1].scriptname.c_str());
				break;
			
			case ScriptType::OnMap:
				sprintf(buf, "DMapMap(%u, %s): ", curScriptNum,dmapmap[curScriptNum-1].scriptname.c_str());
				break;
			case ScriptType::ScriptedActiveSubscreen:
				sprintf(buf, "DMapASub(%u, %s): ", curScriptNum,dmapmap[curScriptNum-1].scriptname.c_str());
				break;
			case ScriptType::ScriptedPassiveSubscreen:
				sprintf(buf, "DMapPSub(%u, %s): ", curScriptNum,dmapmap[curScriptNum-1].scriptname.c_str());
				break;
			case ScriptType::DMap:
				sprintf(buf, "DMap(%u, %s): ", curScriptNum,dmapmap[curScriptNum-1].scriptname.c_str());
				break;
			
			case ScriptType::ItemSprite:
				sprintf(buf, "ItemSprite(%u, %s): ", curScriptNum,itemspritemap[curScriptNum-1].scriptname.c_str());
				break;
			
			case ScriptType::Screen:
				sprintf(buf, "Screen(%u, %s): ", curScriptNum,screenmap[curScriptNum-1].scriptname.c_str());
				break;
			
			case ScriptType::Combo:
				sprintf(buf, "Combo(%u, %s): ", curScriptNum,comboscriptmap[curScriptNum-1].scriptname.c_str());
				break;
				
			case ScriptType::Generic:
				sprintf(buf, "Generic(%u, %s): ", curScriptNum,genericmap[curScriptNum-1].scriptname.c_str());
				break;
				
			case ScriptType::GenericFrozen:
				sprintf(buf, "GenericFRZ(%u, %s): ", curScriptNum,genericmap[curScriptNum-1].scriptname.c_str());
				break;
				
			case ScriptType::EngineSubscreen:
				sprintf(buf, "Subscreen(%u, %s): ", curScriptNum,subscreenmap[curScriptNum-1].scriptname.c_str());
				break;
		}
		
		al_trace("%s", buf);
		if ( cond )
			console.safeprint((CConsoleLoggerEx::COLOR_GREEN|CConsoleLoggerEx::COLOR_INTENSITY|
				CConsoleLoggerEx::COLOR_BACKGROUND_BLACK),buf);
	}
}

void FFScript::do_cleartrace()
{
	zc_trace_clear();
	clearConsole();
}

string inttobase(word base, int32_t x, word mindigits)
{
	static const char coeff[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	
	string s2;
	word digits = zc_max(mindigits - 1, word(floor(log(double(x)) / log(double(base)))));
	
	for(int32_t i = digits; i >= 0; i--)
	{
		s2 += coeff[word(floor(x / pow(double(base), i))) % base];
	}
	
	return s2;
}

void FFScript::do_tracetobase()
{
	int32_t x = SH::read_stack(ri->sp + 2) / 10000;
	uint32_t base = vbound(SH::read_stack(ri->sp + 1) / 10000, 2, 36);
	uint32_t mindigits = zc_max(1, SH::read_stack(ri->sp) / 10000);
	
	string s2 = x < 0 ? "-": "";
	
	switch(base)
	{
	case 8:
		s2 += '0';
		break;
		
	case 16:
		s2 += "0x";
		break;
	}
	
	s2 += inttobase(base, int32_t(fabs(double(x))), mindigits);
	
	switch(base)
	{
	case 8:
	case 10:
	case 16:
		break;
		
	case 2:
		s2 += 'b';
		break;
		
	default:
		std::stringstream ss;
		ss << " (Base " << base << ')';
		s2 += ss.str();
		break;
	}
	TraceScriptIDs();
	s2 += "\n";
	al_trace("%s", s2.c_str());
	
	if ( console_enabled ) 
	{
		zscript_coloured_console.safeprint((CConsoleLoggerEx::COLOR_WHITE | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK),s2.c_str());
	}
}

//SRAM Functions
void FFScript::write_dmaps(PACKFILE *f, int32_t vers_id)
{
	word dmap_count=count_dmaps();
  
		dmap_count=zc_min(dmap_count, 512);
		dmap_count=zc_min(dmap_count, MAXDMAPS-0);
		
		//finally...  section data
		if(!p_iputw(dmap_count,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",5);
		}
		
		
		for(int32_t i=0; i<dmap_count; i++)
		{
			if(!p_putc(DMaps[i].map,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",6);
			}
			
			if(!p_iputw(DMaps[i].level,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",7);
			}
			
			if(!p_putc(DMaps[i].xoff,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",8);
			}
			
			if(!p_putc(DMaps[i].compass,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",9);
			}
			
			if(!p_iputw(DMaps[i].color,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",10);
			}
			
			if(!p_putc(DMaps[i].midi,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",11);
			}
			
			if(!p_putc(DMaps[i].cont,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",12);
			}
			
			if(!p_putc(DMaps[i].type,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",13);
			}
			
			for(int32_t j=0; j<8; j++)
			{
				if(!p_putc(DMaps[i].grid[j],f))
				{
					Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",14);
				}
			}
			
			//16
			if(!pfwrite(&DMaps[i].name,sizeof(DMaps[0].name),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",15);
			}
			
			if(!p_putwstr(DMaps[i].title,f))
            {
                Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",16);
            }
			
			if(!pfwrite(&DMaps[i].intro,sizeof(DMaps[0].intro),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",17);
			}
			
			if(!p_iputl(DMaps[i].minimap_1_tile,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",18);
			}
			
			if(!p_putc(DMaps[i].minimap_1_cset,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",19);
			}
			
			if(!p_iputl(DMaps[i].minimap_2_tile,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",20);
			}
			
			if(!p_putc(DMaps[i].minimap_2_cset,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",21);
			}
			
			if(!p_iputl(DMaps[i].largemap_1_tile,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",22);
			}
			
			if(!p_putc(DMaps[i].largemap_1_cset,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",23);
			}
			
			if(!p_iputl(DMaps[i].largemap_2_tile,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",24);
			}
			
			if(!p_putc(DMaps[i].largemap_2_cset,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",25);
			}
			
			if(!pfwrite(&DMaps[i].tmusic,sizeof(DMaps[0].tmusic),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",26);
			}
			
			if(!p_putc(DMaps[i].tmusictrack,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",25);
			}
			
			if(!p_putc(DMaps[i].active_subscreen,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",26);
			}
			
			if(!p_putc(DMaps[i].passive_subscreen,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",27);
			}
			
			byte disabled[32];
			memset(disabled,0,32);
			
			for(int32_t j=0; j<MAXITEMS; j++)
			{
				if(DMaps[i].disableditems[j])
				{
					disabled[j/8] |= (1 << (j%8));
				}
			}
			
			if(!pfwrite(disabled,32,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",28);
			}
			
			if(!p_iputl(DMaps[i].flags,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",29);
			}
		if(!p_putc(DMaps[i].sideview,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",30);
			}
		if(!p_iputw(DMaps[i].script,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",31);
			}
		for ( int32_t q = 0; q < 8; q++ )
		{
		if(!p_iputl(DMaps[i].initD[q],f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",32);
		}
			
		}
		for ( int32_t q = 0; q < 8; q++ )
		{
			for ( int32_t w = 0; w < 65; w++ )
			{
			if (!p_putc(DMaps[i].initD_label[q][w],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",33);
			}
		}
		}
		}
}
void FFScript::read_dmaps(PACKFILE *f, int32_t vers_id)
{
	word dmap_count=count_dmaps();
  
		dmap_count=zc_min(dmap_count, 512);
		dmap_count=zc_min(dmap_count, MAXDMAPS-0);
		
		//finally...  section data
		if(!p_igetw(&dmap_count,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",5);
		}
		
		
		for(int32_t i=0; i<dmap_count; i++)
		{
			if(!p_getc(&DMaps[i].map,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",6);
			}
			
			if(!p_igetw(&DMaps[i].level,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",7);
			}
			
			if(!p_getc(&DMaps[i].xoff,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",8);
			}
			
			if(!p_getc(&DMaps[i].compass,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",9);
			}
			
			if(!p_igetw(&DMaps[i].color,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",10);
			}
			
			if(!p_getc(&DMaps[i].midi,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",11);
			}
			
			if(!p_getc(&DMaps[i].cont,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",12);
			}
			
			if(!p_getc(&DMaps[i].type,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",13);
			}
			
			for(int32_t j=0; j<8; j++)
			{
				if(!p_getc(&DMaps[i].grid[j],f))
				{
					Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",14);
				}
			}
			
			//16
			if(!pfread((&DMaps[i].name),sizeof(DMaps[0].name),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",15);
			}
			
			if (!p_getwstr(&DMaps[i].title, f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",16);
			}
			
			if(!pfread((&DMaps[i].intro),sizeof(DMaps[0].intro),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",17);
			}
			
			if(!p_igetl(&DMaps[i].minimap_1_tile,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",18);
			}
			
			if(!p_getc(&DMaps[i].minimap_1_cset,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",19);
			}
			
			if(!p_igetl(&DMaps[i].minimap_2_tile,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",20);
			}
			
			if(!p_getc(&DMaps[i].minimap_2_cset,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",21);
			}
			
			if(!p_igetl(&DMaps[i].largemap_1_tile,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",22);
			}
			
			if(!p_getc(&DMaps[i].largemap_1_cset,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",23);
			}
			
			if(!p_igetl(&DMaps[i].largemap_2_tile,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",24);
			}
			
			if(!p_getc(&DMaps[i].largemap_2_cset,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",25);
			}
			
			if(!pfread((&DMaps[i].tmusic),sizeof(DMaps[0].tmusic),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",26);
			}
			
			if(!p_getc(&DMaps[i].tmusictrack,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",25);
			}
			
			if(!p_getc(&DMaps[i].active_subscreen,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",26);
			}
			
			if(!p_getc(&DMaps[i].passive_subscreen,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",27);
			}
			
			byte disabled[32];
			memset(disabled,0,32);
			
			for(int32_t j=0; j<MAXITEMS; j++)
			{
				if(&DMaps[i].disableditems[j])
				{
					disabled[j/8] |= (1 << (j%8));
				}
			}
			
			if(!pfread(disabled,32,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",28);
			}
			
			if(!p_igetl(&DMaps[i].flags,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",29);
			}
		if(!p_getc(&DMaps[i].sideview,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",30);
			}
		if(!p_igetw(&DMaps[i].script,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",31);
			}
		for ( int32_t q = 0; q < 8; q++ )
		{
		if(!p_igetl(&DMaps[i].initD[q],f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",32);
		}
			
		}
		for ( int32_t q = 0; q < 8; q++ )
		{
			for ( int32_t w = 0; w < 65; w++ )
			{
			if (!p_getc(&DMaps[i].initD_label[q][w],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",33);
			}
		}
		}
		}
}



void FFScript::read_combos(PACKFILE *f, int32_t version_id)
{
	
	word combos_used = 0;
	
		if(!p_igetw(&combos_used,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",5);
		}
		
		for(int32_t i=0; i<combos_used; i++)
		{
			if(!p_igetl(&combobuf[i].tile,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",6);
			}
			
			if(!p_getc(&combobuf[i].flip,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",7);
			}
			
			if(!p_getc(&combobuf[i].walk,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",8);
			}
			
			if(!p_getc(&combobuf[i].type,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",9);
			}
			
			if(!p_getc(&combobuf[i].csets,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",10);
			}
			
			if(!p_getc(&combobuf[i].frames,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",11);
			}
			
			if(!p_getc(&combobuf[i].speed,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",12);
			}
			
			if(!p_igetw(&combobuf[i].nextcombo,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",13);
			}
			
			if(!p_getc(&combobuf[i].nextcset,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",14);
			}
			
			if(!p_getc(&combobuf[i].flag,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",15);
			}
			
			if(!p_getc(&combobuf[i].skipanim,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",16);
			}
			
			if(!p_igetw(&combobuf[i].nexttimer,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",17);
			}
			
			if(!p_getc(&combobuf[i].skipanimy,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",18);
			}
			
			if(!p_getc(&combobuf[i].animflags,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",19);
			}
		
		for ( int32_t q = 0; q < NUM_COMBO_ATTRIBUTES; q++ )
		{
		if(!p_igetl(&combobuf[i].attributes[q],f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",20);
		}
		}
		if(!p_igetl(&combobuf[i].usrflags,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",21);
		}	 
		for ( int32_t q = 0; q < 6; q++ ) 
		{
			if(!p_igetl(&combobuf[i].triggerflags[q],f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",22);
			}
		}
		
		if(!p_igetl(&combobuf[i].triggerlevel,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",23);
		}	
		for ( int32_t q = 0; q < 11; q++ ) 
		{
			if(!p_getc(&combobuf[i].label[q],f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",24);
			}
		}
		for ( int32_t q = 0; q < NUM_COMBO_ATTRIBUTES; q++ )
		{
			if(!p_getc(&combobuf[i].attribytes[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",25);
			}
		}
		if(!p_igetw(&combobuf[i].script,f))
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",26);
		for ( int32_t q = 0; q < 2; q++ )
		{
			if(!p_igetl(&combobuf[i].initd[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",27);
			}
		}
		if(!p_igetl(&combobuf[i].o_tile,f))
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",28);
		if(!p_getc(&combobuf[i].cur_frame,f))
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",29);
		if(!p_getc(&combobuf[i].aclk,f))
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",30);
		}
}

void FFScript::write_combos(PACKFILE *f, int32_t version_id)
{
	
	word combos_used = 0;
	
		//finally...  section data
		combos_used=count_combos()-0;
		combos_used=zc_min(combos_used, MAXCOMBOS);
		
		if(!p_iputw(combos_used,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",5);
		}
		
		for(int32_t i=0; i<combos_used; i++)
		{
			if(!p_iputl(combobuf[i].tile,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",6);
			}
			
			if(!p_putc(combobuf[i].flip,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",7);
			}
			
			if(!p_putc(combobuf[i].walk,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",8);
			}
			
			if(!p_putc(combobuf[i].type,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",9);
			}
			
			if(!p_putc(combobuf[i].csets,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",10);
			}
			
			if(!p_putc(combobuf[i].frames,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",11);
			}
			
			if(!p_putc(combobuf[i].speed,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",12);
			}
			
			if(!p_iputw(combobuf[i].nextcombo,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",13);
			}
			
			if(!p_putc(combobuf[i].nextcset,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",14);
			}
			
			if(!p_putc(combobuf[i].flag,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",15);
			}
			
			if(!p_putc(combobuf[i].skipanim,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",16);
			}
			
			if(!p_iputw(combobuf[i].nexttimer,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",17);
			}
			
			if(!p_putc(combobuf[i].skipanimy,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",18);
			}
			
			if(!p_putc(combobuf[i].animflags,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",19);
			}
		
		for ( int32_t q = 0; q < NUM_COMBO_ATTRIBUTES; q++ )
		{
		if(!p_iputl(combobuf[i].attributes[q],f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",20);
		}
		}
		if(!p_iputl(combobuf[i].usrflags,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",21);
		}	 
		for ( int32_t q = 0; q < 6; q++ ) 
		{
			if(!p_iputl(combobuf[i].triggerflags[q],f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",22);
			}
		}
		
		if(!p_iputl(combobuf[i].triggerlevel,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",23);
		}	
		for ( int32_t q = 0; q < 11; q++ ) 
		{
			if(!p_putc(combobuf[i].label[q],f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",24);
			}
		}
		for ( int32_t q = 0; q < NUM_COMBO_ATTRIBUTES; q++ )
		{
			if(!p_putc(combobuf[i].attribytes[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",25);
			}
		}
		if(!p_iputw(combobuf[i].script,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",26);
		}
		for ( int32_t q = 0; q < 2; q++ )
		{
			if(!p_iputl(combobuf[i].initd[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",27);
			}
		}
		if(!p_iputl(combobuf[i].o_tile,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",28);
		}
		if(!p_putc(combobuf[i].cur_frame,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",29);
		}
		if(!p_putc(combobuf[i].aclk,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",30);
		}
			
		}
}
void FFScript::read_weaponsprtites(PACKFILE *f, int32_t vers_id)
{   
	for(int32_t i=0; i<MAXWPNS; i++)
	{
		word oldtile = 0;
		if(!p_igetw(&oldtile,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",6);
		}
			
		if(!p_getc(&wpnsbuf[i].misc,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",7);
		}
			
		if(!p_getc(&wpnsbuf[i].csets,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",8);
		}
			
		if(!p_getc(&wpnsbuf[i].frames,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",9);
		}
			
		if(!p_getc(&wpnsbuf[i].speed,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",10);
		}
			
		if(!p_getc(&wpnsbuf[i].type,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",11);
		}
		
		if(!p_igetw(&wpnsbuf[i].script,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",12);
		}

		if(!p_igetl(&wpnsbuf[i].tile,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",12);
		}
	}
}
void FFScript::write_weaponsprtites(PACKFILE *f, int32_t vers_id)
{   
	for(int32_t i=0; i<MAXWPNS; i++)
	{
		if(!p_iputw(wpnsbuf[i].tile,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",6);
		}
			
		if(!p_putc(wpnsbuf[i].misc,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",7);
		}
			
		if(!p_putc(wpnsbuf[i].csets,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",8);
		}
			
		if(!p_putc(wpnsbuf[i].frames,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",9);
		}
			
		if(!p_putc(wpnsbuf[i].speed,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",10);
		}
			
		if(!p_putc(wpnsbuf[i].type,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",11);
		}
		
		if(!p_iputw(wpnsbuf[i].script,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",12);
		}
		
		if(!p_iputl(wpnsbuf[i].tile,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",12);
		}
	}
}


void FFScript::read_enemies(PACKFILE *f, int32_t vers_id)
{
	if ( !f ) return;
	for(int32_t i=0; i<MAXGUYS; i++)
	{
			if(!p_igetl(&guysbuf[i].flags,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",6);
			}
			
			if(!p_igetl(&guysbuf[i].flags2,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",7);
			}
			
			if(!p_igetl(&guysbuf[i].tile,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",8);
			}
			
			if(!p_getc(&guysbuf[i].width,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",9);
			}
			
			if(!p_getc(&guysbuf[i].height,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",10);
			}
			
			if(!p_igetl(&guysbuf[i].s_tile,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",11);
			}
			
			if(!p_getc(&guysbuf[i].s_width,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",12);
			}
			
			if(!p_getc(&guysbuf[i].s_height,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",13);
			}
			
			if(!p_igetl(&guysbuf[i].e_tile,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",14);
			}
			
			if(!p_getc(&guysbuf[i].e_width,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",15);
			}
			
			if(!p_getc(&guysbuf[i].e_height,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",16);
			}
			
			if(!p_igetw(&guysbuf[i].hp,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",17);
			}
			
			if(!p_igetw(&guysbuf[i].family,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",18);
			}
			
			if(!p_igetw(&guysbuf[i].cset,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",19);
			}
			
			if(!p_igetw(&guysbuf[i].anim,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",20);
			}
			
			if(!p_igetw(&guysbuf[i].e_anim,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",21);
			}
			
			if(!p_igetw(&guysbuf[i].frate,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",22);
			}
			
			if(!p_igetw(&guysbuf[i].e_frate,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",23);
			}
			
			if(!p_igetw(&guysbuf[i].dp,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",24);
			}
			
			if(!p_igetw(&guysbuf[i].wdp,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",25);
			}
			
			if(!p_igetw(&guysbuf[i].weapon,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",26);
			}
			
			if(!p_igetw(&guysbuf[i].rate,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",27);
			}
			
			if(!p_igetw(&guysbuf[i].hrate,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",28);
			}
			
			if(!p_igetw(&guysbuf[i].step,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",29);
			}
			
			if(!p_igetw(&guysbuf[i].homing,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",30);
			}
			
			if(!p_igetw(&guysbuf[i].grumble,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",31);
			}
			
			if(!p_igetw(&guysbuf[i].item_set,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",32);
			}
			
			if(!p_igetl(&guysbuf[i].misc1,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",33);
			}
			
			if(!p_igetl(&guysbuf[i].misc2,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",34);
			}
			
			if(!p_igetl(&guysbuf[i].misc3,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",35);
			}
			
			if(!p_igetl(&guysbuf[i].misc4,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",36);
			}
			
			if(!p_igetl(&guysbuf[i].misc5,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",37);
			}
			
			if(!p_igetl(&guysbuf[i].misc6,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",38);
			}
			
			if(!p_igetl(&guysbuf[i].misc7,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",39);
			}
			
			if(!p_igetl(&guysbuf[i].misc8,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",40);
			}
			
			if(!p_igetl(&guysbuf[i].misc9,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",41);
			}
			
			if(!p_igetl(&guysbuf[i].misc10,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",42);
			}
			
			if(!p_igetw(&guysbuf[i].bgsfx,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",43);
			}
			
			if(!p_igetw(&guysbuf[i].bosspal,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",44);
			}
			
			if(!p_igetw(&guysbuf[i].extend,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",45);
			}
			
			for(int32_t j=0; j < edefLAST; j++)
			{
			if(!p_getc(&guysbuf[i].defense[j],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",46);
			}
			}
			
			if(!p_getc(&guysbuf[i].hitsfx,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",47);
			}
			
			if(!p_getc(&guysbuf[i].deadsfx,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",48);
			}
			
			if(!p_igetl(&guysbuf[i].misc11,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",49);
			}
			
			if(!p_igetl(&guysbuf[i].misc12,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",50);
			}
			
			//New 2.6 defences
			for(int32_t j=edefLAST; j < edefLAST255; j++)
			{
			if(!p_getc(&guysbuf[i].defense[j],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",51);
			}
			}
			
			//tilewidth, tileheight, hitwidth, hitheight, hitzheight, hitxofs, hityofs, hitzofs
			if(!p_igetl(&guysbuf[i].txsz,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",52);
			}
			if(!p_igetl(&guysbuf[i].tysz,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",53);
			}
			if(!p_igetl(&guysbuf[i].hxsz,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",54);
			}
			if(!p_igetl(&guysbuf[i].hysz,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",55);
			}
			if(!p_igetl(&guysbuf[i].hzsz,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",56);
			}
			// These are not fixed types, but ints, so they are safe to use here. 
			if(!p_igetl(&guysbuf[i].hxofs,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",57);
			}
			if(!p_igetl(&guysbuf[i].hyofs,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",58);
			}
			if(!p_igetl(&guysbuf[i].xofs,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",59);
			}
			if(!p_igetl(&guysbuf[i].yofs,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",60);
			}
			if(!p_igetl(&guysbuf[i].zofs,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",61);
			}
			if(!p_igetl(&guysbuf[i].wpnsprite,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",62);
			}
			if(!p_igetl(&guysbuf[i].SIZEflags,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",63);
			}
			if(!p_igetl(&guysbuf[i].frozentile,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",64);
			}
			if(!p_igetl(&guysbuf[i].frozencset,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",65);
			}
			if(!p_igetl(&guysbuf[i].frozenclock,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",66);
			}
			
			for ( int32_t q = 0; q < 10; q++ ) 
			{
			if(!p_igetw(&guysbuf[i].frozenmisc[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",67);
			}
			}
			if(!p_igetw(&guysbuf[i].firesfx,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",68);
			}
			//misc 16->31
			if(!p_igetl(&guysbuf[i].misc16,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",69);
			}
			if(!p_igetl(&guysbuf[i].misc17,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",70);
			}
			if(!p_igetl(&guysbuf[i].misc18,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",71);
			}
			if(!p_igetl(&guysbuf[i].misc19,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",72);
			}
			if(!p_igetl(&guysbuf[i].misc20,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",73);
			}
			if(!p_igetl(&guysbuf[i].misc21,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",74);
			}
			if(!p_igetl(&guysbuf[i].misc22,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",75);
			}
			if(!p_igetl(&guysbuf[i].misc23,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",76);
			}
			if(!p_igetl(&guysbuf[i].misc24,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",77);
			}
			if(!p_igetl(&guysbuf[i].misc25,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",78);
			}
			if(!p_igetl(&guysbuf[i].misc26,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",79);
			}
			if(!p_igetl(&guysbuf[i].misc27,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",80);
			}
			if(!p_igetl(&guysbuf[i].misc28,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",81);
			}
			if(!p_igetl(&guysbuf[i].misc29,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",82);
			}
			if(!p_igetl(&guysbuf[i].misc30,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",83);
			}
			if(!p_igetl(&guysbuf[i].misc31,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",84);
			}
			if(!p_igetl(&guysbuf[i].misc32,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",85);
			}
			for ( int32_t q = 0; q < 32; q++ )
			{
				if(!p_igetl(&guysbuf[i].movement[q],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",86);
				}
			}
			for ( int32_t q = 0; q < 32; q++ )
			{
				if(!p_igetl(&guysbuf[i].new_weapon[q],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",87);
				}
			}
			if(!p_igetw(&guysbuf[i].script,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",88);
			}
			for ( int32_t q = 0; q < 8; q++ )
			{
			if(!p_igetl(&guysbuf[i].initD[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",89);
			}
			}
			for ( int32_t q = 0; q < 2; q++ )
			{
			if(!p_igetl(&guysbuf[i].initA[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",90);
			}
			}
			if(!p_igetl(&guysbuf[i].editorflags,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",91);
			}
			//somehow forgot these in the older builds -Z
			if(!p_igetl(&guysbuf[i].misc13,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",92);
			}
			if(!p_igetl(&guysbuf[i].misc14,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",93);
			}
			if(!p_igetl(&guysbuf[i].misc15,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",94);
			}
			
			//Enemy Editor InitD[] labels
			for ( int32_t q = 0; q < 8; q++ )
			{
				for ( int32_t w = 0; w < 65; w++ )
				{
					if(!p_getc(&guysbuf[i].initD_label[q][w],f))
					{
						Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",95);
					} 
				}
				for ( int32_t w = 0; w < 65; w++ )
				{
					if(!p_getc(&guysbuf[i].weapon_initD_label[q][w],f))
					{
						Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",96);
					} 
				}
			}
			if(!p_igetw(&guysbuf[i].weaponscript,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",97);
			}
			//eweapon initD
			for ( int32_t q = 0; q < 8; q++ )
			{
			if(!p_igetl(&guysbuf[i].weap_initiald[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",98);
			}
			}
			
	}
}

void FFScript::write_enemies(PACKFILE *f, int32_t vers_id)
{
	if ( !f ) return;
	for(int32_t i=0; i<MAXGUYS; i++)
	{
		if(!p_iputl(guysbuf[i].flags,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",6);
		}
		
		if(!p_iputl(guysbuf[i].flags2,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",7);
		}
		
		if(!p_iputl(guysbuf[i].tile,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",8);
		}
		
		if(!p_putc(guysbuf[i].width,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",9);
		}
		
		if(!p_putc(guysbuf[i].height,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",10);
		}
		
		if(!p_iputl(guysbuf[i].s_tile,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",11);
		}
		
		if(!p_putc(guysbuf[i].s_width,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",12);
		}
		
		if(!p_putc(guysbuf[i].s_height,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",13);
		}
		
		if(!p_iputl(guysbuf[i].e_tile,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",14);
		}
		
		if(!p_putc(guysbuf[i].e_width,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",15);
		}
		
		if(!p_putc(guysbuf[i].e_height,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",16);
		}
		
		if(!p_iputw(guysbuf[i].hp,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",17);
		}
		
		if(!p_iputw(guysbuf[i].family,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",18);
		}
		
		if(!p_iputw(guysbuf[i].cset,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",19);
		}
		
		if(!p_iputw(guysbuf[i].anim,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",20);
		}
		
		if(!p_iputw(guysbuf[i].e_anim,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",21);
		}
		
		if(!p_iputw(guysbuf[i].frate,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",22);
		}
		
		if(!p_iputw(guysbuf[i].e_frate,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",23);
		}
		
		if(!p_iputw(guysbuf[i].dp,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",24);
		}
		
		if(!p_iputw(guysbuf[i].wdp,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",25);
		}
		
		if(!p_iputw(guysbuf[i].weapon,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",26);
		}
		
		if(!p_iputw(guysbuf[i].rate,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",27);
		}
		
		if(!p_iputw(guysbuf[i].hrate,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",28);
		}
		
		if(!p_iputw(guysbuf[i].step,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",29);
		}
		
		if(!p_iputw(guysbuf[i].homing,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",30);
		}
		
		if(!p_iputw(guysbuf[i].grumble,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",31);
		}
		
		if(!p_iputw(guysbuf[i].item_set,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",32);
		}
		
		if(!p_iputl(guysbuf[i].misc1,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",33);
		}
		
		if(!p_iputl(guysbuf[i].misc2,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",34);
		}
		
		if(!p_iputl(guysbuf[i].misc3,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",35);
		}
		
		if(!p_iputl(guysbuf[i].misc4,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",36);
		}
		
		if(!p_iputl(guysbuf[i].misc5,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",37);
		}
		
		if(!p_iputl(guysbuf[i].misc6,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",38);
		}
		
		if(!p_iputl(guysbuf[i].misc7,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",39);
		}
		
		if(!p_iputl(guysbuf[i].misc8,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",40);
		}
		
		if(!p_iputl(guysbuf[i].misc9,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",41);
		}
		
		if(!p_iputl(guysbuf[i].misc10,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",42);
		}
		
		if(!p_iputw(guysbuf[i].bgsfx,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",43);
		}
		
		if(!p_iputw(guysbuf[i].bosspal,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",44);
		}
		
		if(!p_iputw(guysbuf[i].extend,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",45);
		}
		
		for(int32_t j=0; j < edefLAST; j++)
		{
		if(!p_putc(guysbuf[i].defense[j],f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",46);
		}
		}
		
		if(!p_putc(guysbuf[i].hitsfx,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",47);
		}
		
		if(!p_putc(guysbuf[i].deadsfx,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",48);
		}
		
		if(!p_iputl(guysbuf[i].misc11,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",49);
		}
		
		if(!p_iputl(guysbuf[i].misc12,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",50);
		}
		
		//New 2.6 defences
		for(int32_t j=edefLAST; j < edefLAST255; j++)
		{
		if(!p_putc(guysbuf[i].defense[j],f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",51);
		}
		}
		
		//tilewidth, tileheight, hitwidth, hitheight, hitzheight, hitxofs, hityofs, hitzofs
		if(!p_iputl(guysbuf[i].txsz,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",52);
		}
		if(!p_iputl(guysbuf[i].tysz,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",53);
		}
		if(!p_iputl(guysbuf[i].hxsz,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",54);
		}
		if(!p_iputl(guysbuf[i].hysz,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",55);
		}
		if(!p_iputl(guysbuf[i].hzsz,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",56);
		}
		// These are not fixed types, but ints, so they are safe to use here. 
		if(!p_iputl(guysbuf[i].hxofs,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",57);
		}
		if(!p_iputl(guysbuf[i].hyofs,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",58);
		}
		if(!p_iputl(guysbuf[i].xofs,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",59);
		}
		if(!p_iputl(guysbuf[i].yofs,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",60);
		}
		if(!p_iputl(guysbuf[i].zofs,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",61);
		}
		if(!p_iputl(guysbuf[i].wpnsprite,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",62);
		}
		if(!p_iputl(guysbuf[i].SIZEflags,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",63);
		}
		if(!p_iputl(guysbuf[i].frozentile,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",64);
		}
		if(!p_iputl(guysbuf[i].frozencset,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",65);
		}
		if(!p_iputl(guysbuf[i].frozenclock,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",66);
		}
		
		for ( int32_t q = 0; q < 10; q++ ) 
		{
		if(!p_iputw(guysbuf[i].frozenmisc[q],f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",67);
		}
		}
		if(!p_iputw(guysbuf[i].firesfx,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",68);
		}
		//misc 16->31
		if(!p_iputl(guysbuf[i].misc16,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",69);
		}
		if(!p_iputl(guysbuf[i].misc17,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",70);
		}
		if(!p_iputl(guysbuf[i].misc18,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",71);
		}
		if(!p_iputl(guysbuf[i].misc19,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",72);
		}
		if(!p_iputl(guysbuf[i].misc20,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",73);
		}
		if(!p_iputl(guysbuf[i].misc21,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",74);
		}
		if(!p_iputl(guysbuf[i].misc22,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",75);
		}
		if(!p_iputl(guysbuf[i].misc23,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",76);
		}
		if(!p_iputl(guysbuf[i].misc24,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",77);
		}
		if(!p_iputl(guysbuf[i].misc25,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",78);
		}
		if(!p_iputl(guysbuf[i].misc26,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",79);
		}
		if(!p_iputl(guysbuf[i].misc27,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",80);
		}
		if(!p_iputl(guysbuf[i].misc28,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",81);
		}
		if(!p_iputl(guysbuf[i].misc29,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",82);
		}
		if(!p_iputl(guysbuf[i].misc30,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",83);
		}
		if(!p_iputl(guysbuf[i].misc31,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",84);
		}
		if(!p_iputl(guysbuf[i].misc32,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",85);
		}
		for ( int32_t q = 0; q < 32; q++ )
		{
			if(!p_iputl(guysbuf[i].movement[q],f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",86);
			}
		}
		for ( int32_t q = 0; q < 32; q++ )
		{
			if(!p_iputl(guysbuf[i].new_weapon[q],f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",87);
			}
		}
		if(!p_iputw(guysbuf[i].script,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",88);
		}
		for ( int32_t q = 0; q < 8; q++ )
		{
		if(!p_iputl(guysbuf[i].initD[q],f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",89);
		}
		}
		for ( int32_t q = 0; q < 2; q++ )
		{
		if(!p_iputl(guysbuf[i].initA[q],f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",90);
		}
		}
		if(!p_iputl(guysbuf[i].editorflags,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",91);
		}
		//somehow forgot these in the older builds -Z
		if(!p_iputl(guysbuf[i].misc13,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",92);
		}
		if(!p_iputl(guysbuf[i].misc14,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",93);
		}
		if(!p_iputl(guysbuf[i].misc15,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",94);
		}
		
		//Enemy Editor InitD[] labels
		for ( int32_t q = 0; q < 8; q++ )
		{
			for ( int32_t w = 0; w < 65; w++ )
			{
				if(!p_putc(guysbuf[i].initD_label[q][w],f))
				{
					Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",95);
				} 
			}
			for ( int32_t w = 0; w < 65; w++ )
			{
				if(!p_putc(guysbuf[i].weapon_initD_label[q][w],f))
				{
					Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",96);
				} 
			}
		}
		if(!p_iputw(guysbuf[i].weaponscript,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",97);
		}
		//eweapon initD
		for ( int32_t q = 0; q < 8; q++ )
		{
		if(!p_iputl(guysbuf[i].weap_initiald[q],f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",98);
		}
		}
		
	}
}


void FFScript::write_items(PACKFILE *f, int32_t vers_id)
{
		for(int32_t i=0; i<MAXITEMS; i++)
		{
			if(!p_iputl(itemsbuf[i].tile,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",6);
			}
			
			if(!p_putc(itemsbuf[i].misc_flags,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",7);
			}
			
			if(!p_putc(itemsbuf[i].csets,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",8);
			}
			
			if(!p_putc(itemsbuf[i].frames,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",9);
			}
			
			if(!p_putc(itemsbuf[i].speed,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",10);
			}
			
			if(!p_putc(itemsbuf[i].delay,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",11);
			}
			
			if(!p_iputl(itemsbuf[i].ltm,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",12);
			}
			
			if(!p_iputl(itemsbuf[i].family,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",13);
			}
			
			if(!p_putc(itemsbuf[i].fam_type,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",14);
			}
			
			if(!p_iputl(itemsbuf[i].power,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",14);
			}
			
			if(!p_iputl(itemsbuf[i].flags,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",15);
			}
			
			if(!p_iputw(itemsbuf[i].script,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",16);
			}
			
			if(!p_putc(itemsbuf[i].count,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",17);
			}
			
			if(!p_iputw(itemsbuf[i].amount,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",18);
			}
			
			if(!p_iputw(itemsbuf[i].collect_script,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",19);
			}
			
			if(!p_iputw(itemsbuf[i].setmax,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",21);
			}
			
			if(!p_iputw(itemsbuf[i].max,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",22);
			}
			
			if(!p_putc(itemsbuf[i].playsound,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",23);
			}
			
			for(int32_t j=0; j<8; j++)
			{
				if(!p_iputl(itemsbuf[i].initiald[j],f))
				{
					Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",24);
				}
			}
			
			for(int32_t j=0; j<2; j++)
			{
				if(!p_putc(itemsbuf[i].initiala[j],f))
				{
					Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",25);
				}
			}
			
			if(!p_putc(itemsbuf[i].wpn,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",26);
			}
			
			if(!p_putc(itemsbuf[i].wpn2,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",27);
			}
			
			if(!p_putc(itemsbuf[i].wpn3,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",28);
			}
			
			if(!p_putc(itemsbuf[i].wpn4,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",29);
			}
			
			if(!p_putc(itemsbuf[i].wpn5,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",30);
			}
			
			if(!p_putc(itemsbuf[i].wpn6,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",31);
			}
			
			if(!p_putc(itemsbuf[i].wpn7,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",32);
			}
			
			if(!p_putc(itemsbuf[i].wpn8,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",33);
			}
			
			if(!p_putc(itemsbuf[i].wpn9,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",34);
			}
			
			if(!p_putc(itemsbuf[i].wpn10,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",35);
			}
			
			if(!p_putc(itemsbuf[i].pickup_hearts,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",36);
			}
			
			if(!p_iputl(itemsbuf[i].misc1,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",37);
			}
			
			if(!p_iputl(itemsbuf[i].misc2,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",38);
			}
			
			if(!p_putc(itemsbuf[i].cost_amount[0],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",39);
			}
			
			if(!p_iputl(itemsbuf[i].misc3,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",40);
			}
			
			if(!p_iputl(itemsbuf[i].misc4,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",41);
			}
			
			if(!p_iputl(itemsbuf[i].misc5,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",42);
			}
			
			if(!p_iputl(itemsbuf[i].misc6,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",43);
			}
			
			if(!p_iputl(itemsbuf[i].misc7,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",44);
			}
			
			if(!p_iputl(itemsbuf[i].misc8,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",45);
			}
			
			if(!p_iputl(itemsbuf[i].misc9,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",46);
			}
			
			if(!p_iputl(itemsbuf[i].misc10,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",47);
			}
			
			if(!p_putc(itemsbuf[i].usesound,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",48);
			}
			
			if(!p_putc(itemsbuf[i].usesound2,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",48);
			}
		
		//New itemdata vars -Z
		//! version 27
		
		if(!p_putc(itemsbuf[i].useweapon,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",49);
			}
		if(!p_putc(itemsbuf[i].usedefence,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",50);
			}
		if(!p_iputl(itemsbuf[i].weaprange,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",51);
			}
		if(!p_iputl(itemsbuf[i].weapduration,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",52);
			}
		for ( int32_t q = 0; q < ITEM_MOVEMENT_PATTERNS; q++ ) {
			if(!p_iputl(itemsbuf[i].weap_pattern[q],f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",53);
			}
		}
		//version 28
		if(!p_iputl(itemsbuf[i].duplicates,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",54);
		}
		for ( int32_t q = 0; q < INITIAL_D; q++ )
		{
			if(!p_iputl(itemsbuf[i].weap_initiald[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",55);
			}
		}
		for ( int32_t q = 0; q < INITIAL_A; q++ )
		{
			if(!p_putc(itemsbuf[i].weap_initiala[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",56);
			}
		}

		if(!p_putc(itemsbuf[i].drawlayer,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",57);
		}


		if(!p_iputl(itemsbuf[i].hxofs,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",58);
		}
		if(!p_iputl(itemsbuf[i].hyofs,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",59);
		}
		if(!p_iputl(itemsbuf[i].hxsz,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",60);
		}
		if(!p_iputl(itemsbuf[i].hysz,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",61);
		}
		if(!p_iputl(itemsbuf[i].hzsz,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",62);
		}
		if(!p_iputl(itemsbuf[i].xofs,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",63);
		}
		if(!p_iputl(itemsbuf[i].yofs,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",64);
		}
		if(!p_iputl(itemsbuf[i].weap_hxofs,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",65);
		}
		if(!p_iputl(itemsbuf[i].weap_hyofs,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",66);
		}
		if(!p_iputl(itemsbuf[i].weap_hxsz,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",67);
		}
		if(!p_iputl(itemsbuf[i].weap_hysz,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",68);
		}
		if(!p_iputl(itemsbuf[i].weap_hzsz,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",69);
		}
		if(!p_iputl(itemsbuf[i].weap_xofs,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",70);
		}
		if(!p_iputl(itemsbuf[i].weap_yofs,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",71);
		}
		if(!p_iputw(itemsbuf[i].weaponscript,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",72);
		}
		if(!p_iputl(itemsbuf[i].wpnsprite,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",73);
		}
		if(!p_iputl(itemsbuf[i].magiccosttimer[0],f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",74);
		}
		if(!p_iputl(itemsbuf[i].overrideFLAGS,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",75);
		}
		if(!p_iputl(itemsbuf[i].tilew,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",76);
		}
		if(!p_iputl(itemsbuf[i].tileh,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",77);
		}
		if(!p_iputl(itemsbuf[i].weapoverrideFLAGS,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",78);
		}
		if(!p_iputl(itemsbuf[i].weap_tilew,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",79);
		}
		if(!p_iputl(itemsbuf[i].weap_tileh,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",80);
		}
		if(!p_iputl(itemsbuf[i].pickup,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",81);
		}
		if(!p_iputw(itemsbuf[i].pstring,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",82);
		}
		if(!p_iputw(itemsbuf[i].pickup_string_flags,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",83);
		}
		
		if(!p_putc(itemsbuf[i].cost_counter[0],f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",84);
		}
		
		//InitD[] labels
		for ( int32_t q = 0; q < 8; q++ )
		{
			for ( int32_t w = 0; w < 65; w++ )
			{
				if(!p_putc(itemsbuf[i].initD_label[q][w],f))
				{
					Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",85);
				} 
			}
			for ( int32_t w = 0; w < 65; w++ )
			{
				if(!p_putc(itemsbuf[i].weapon_initD_label[q][w],f))
				{
					Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",86);
				} 
			}
			for ( int32_t w = 0; w < 65; w++ )
			{
				if(!p_putc(itemsbuf[i].sprite_initD_label[q][w],f))
				{
					Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",87);
				} 
			}
			if(!p_iputl(itemsbuf[i].sprite_initiald[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",88);
			} 
		}
		for ( int32_t q = 0; q < 2; q++ )
		{
			if(!p_putc(itemsbuf[i].sprite_initiala[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",89);
			} 
			
		}
		if(!p_iputw(itemsbuf[i].sprite_script,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",90);
		} 
		
		
		}
}

void FFScript::read_items(PACKFILE *f, int32_t vers_id)
{
		for(int32_t i=0; i<MAXITEMS; i++)
		{
			if(!p_igetl(&itemsbuf[i].tile,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",6);
			}
			
			if(!p_getc(&itemsbuf[i].misc_flags,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",7);
			}
			
			if(!p_getc(&itemsbuf[i].csets,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",8);
			}
			
			if(!p_getc(&itemsbuf[i].frames,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",9);
			}
			
			if(!p_getc(&itemsbuf[i].speed,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",10);
			}
			
			if(!p_getc(&itemsbuf[i].delay,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",11);
			}
			
			if(!p_igetl(&itemsbuf[i].ltm,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",12);
			}
			
			if(!p_igetl(&itemsbuf[i].family,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",13);
			}
			
			if(!p_getc(&itemsbuf[i].fam_type,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",14);
			}
			
			if(!p_igetl(&itemsbuf[i].power,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",14);
			}
			
			if(!p_igetl(&itemsbuf[i].flags,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",15);
			}
			
			if(!p_igetw(&itemsbuf[i].script,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",16);
			}
			
			if(!p_getc(&itemsbuf[i].count,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",17);
			}
			
			if(!p_igetw(&itemsbuf[i].amount,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",18);
			}
			
			if(!p_igetw(&itemsbuf[i].collect_script,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",19);
			}
			
			if(!p_igetw(&itemsbuf[i].setmax,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",21);
			}
			
			if(!p_igetw(&itemsbuf[i].max,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",22);
			}
			
			if(!p_getc(&itemsbuf[i].playsound,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",23);
			}
			
			for(int32_t j=0; j<8; j++)
			{
				if(!p_igetl(&itemsbuf[i].initiald[j],f))
				{
					Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",24);
				}
			}
			
			for(int32_t j=0; j<2; j++)
			{
				if(!p_getc(&itemsbuf[i].initiala[j],f))
				{
					Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",25);
				}
			}
			
			if(!p_getc(&itemsbuf[i].wpn,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",26);
			}
			
			if(!p_getc(&itemsbuf[i].wpn2,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",27);
			}
			
			if(!p_getc(&itemsbuf[i].wpn3,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",28);
			}
			
			if(!p_getc(&itemsbuf[i].wpn4,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",29);
			}
			
			if(!p_getc(&itemsbuf[i].wpn5,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",30);
			}
			
			if(!p_getc(&itemsbuf[i].wpn6,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",31);
			}
			
			if(!p_getc(&itemsbuf[i].wpn7,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",32);
			}
			
			if(!p_getc(&itemsbuf[i].wpn8,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",33);
			}
			
			if(!p_getc(&itemsbuf[i].wpn9,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",34);
			}
			
			if(!p_getc(&itemsbuf[i].wpn10,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",35);
			}
			
			if(!p_getc(&itemsbuf[i].pickup_hearts,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",36);
			}
			
			if(!p_igetl(&itemsbuf[i].misc1,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",37);
			}
			
			if(!p_igetl(&itemsbuf[i].misc2,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",38);
			}
			
			if(!p_getc(&itemsbuf[i].cost_amount[0],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",39);
			}
			
			if(!p_igetl(&itemsbuf[i].misc3,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",40);
			}
			
			if(!p_igetl(&itemsbuf[i].misc4,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",41);
			}
			
			if(!p_igetl(&itemsbuf[i].misc5,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",42);
			}
			
			if(!p_igetl(&itemsbuf[i].misc6,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",43);
			}
			
			if(!p_igetl(&itemsbuf[i].misc7,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",44);
			}
			
			if(!p_igetl(&itemsbuf[i].misc8,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",45);
			}
			
			if(!p_igetl(&itemsbuf[i].misc9,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",46);
			}
			
			if(!p_igetl(&itemsbuf[i].misc10,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",47);
			}
			
			if(!p_getc(&itemsbuf[i].usesound,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",48);
			}
			
			if(!p_getc(&itemsbuf[i].usesound2,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",48);
			}
		
		//New itemdata vars -Z
		//! version 27
		
		if(!p_getc(&itemsbuf[i].useweapon,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",49);
			}
		if(!p_getc(&itemsbuf[i].usedefence,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",50);
			}
		if(!p_igetl(&itemsbuf[i].weaprange,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",51);
			}
		if(!p_igetl(&itemsbuf[i].weapduration,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",52);
			}
		for ( int32_t q = 0; q < ITEM_MOVEMENT_PATTERNS; q++ ) {
			if(!p_igetl(&itemsbuf[i].weap_pattern[q],f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",53);
			}
		}
		//version 28
		if(!p_igetl(&itemsbuf[i].duplicates,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",54);
		}
		for ( int32_t q = 0; q < INITIAL_D; q++ )
		{
			if(!p_igetl(&itemsbuf[i].weap_initiald[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",55);
			}
		}
		for ( int32_t q = 0; q < INITIAL_A; q++ )
		{
			if(!p_getc(&itemsbuf[i].weap_initiala[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",56);
			}
		}

		if(!p_getc(&itemsbuf[i].drawlayer,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",57);
		}


		if(!p_igetl(&itemsbuf[i].hxofs,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",58);
		}
		if(!p_igetl(&itemsbuf[i].hyofs,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",59);
		}
		if(!p_igetl(&itemsbuf[i].hxsz,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",60);
		}
		if(!p_igetl(&itemsbuf[i].hysz,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",61);
		}
		if(!p_igetl(&itemsbuf[i].hzsz,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",62);
		}
		if(!p_igetl(&itemsbuf[i].xofs,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",63);
		}
		if(!p_igetl(&itemsbuf[i].yofs,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",64);
		}
		if(!p_igetl(&itemsbuf[i].weap_hxofs,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",65);
		}
		if(!p_igetl(&itemsbuf[i].weap_hyofs,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",66);
		}
		if(!p_igetl(&itemsbuf[i].weap_hxsz,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",67);
		}
		if(!p_igetl(&itemsbuf[i].weap_hysz,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",68);
		}
		if(!p_igetl(&itemsbuf[i].weap_hzsz,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",69);
		}
		if(!p_igetl(&itemsbuf[i].weap_xofs,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",70);
		}
		if(!p_igetl(&itemsbuf[i].weap_yofs,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",71);
		}
		if(!p_igetw(&itemsbuf[i].weaponscript,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",72);
		}
		if(!p_igetl(&itemsbuf[i].wpnsprite,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",73);
		}
		if(!p_igetl(&itemsbuf[i].magiccosttimer[0],f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",74);
		}
		if(!p_igetl(&itemsbuf[i].overrideFLAGS,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",75);
		}
		if(!p_igetl(&itemsbuf[i].tilew,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",76);
		}
		if(!p_igetl(&itemsbuf[i].tileh,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",77);
		}
		if(!p_igetl(&itemsbuf[i].weapoverrideFLAGS,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",78);
		}
		if(!p_igetl(&itemsbuf[i].weap_tilew,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",79);
		}
		if(!p_igetl(&itemsbuf[i].weap_tileh,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",80);
		}
		if(!p_igetl(&itemsbuf[i].pickup,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",81);
		}
		if(!p_igetw(&itemsbuf[i].pstring,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",82);
		}
		if(!p_igetw(&itemsbuf[i].pickup_string_flags,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",83);
		}
		
		if(!p_getc(&itemsbuf[i].cost_counter[0],f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",84);
		}
		
		//InitD[] labels
		for ( int32_t q = 0; q < 8; q++ )
		{
			for ( int32_t w = 0; w < 65; w++ )
			{
				if(!p_getc(&itemsbuf[i].initD_label[q][w],f))
				{
					Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",85);
				} 
			}
			for ( int32_t w = 0; w < 65; w++ )
			{
				if(!p_getc(&itemsbuf[i].weapon_initD_label[q][w],f))
				{
					Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",86);
				} 
			}
			for ( int32_t w = 0; w < 65; w++ )
			{
				if(!p_getc(&itemsbuf[i].sprite_initD_label[q][w],f))
				{
					Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",87);
				} 
			}
			if(!p_igetl(&itemsbuf[i].sprite_initiald[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",88);
			} 
		}
		for ( int32_t q = 0; q < 2; q++ )
		{
			if(!p_getc(&itemsbuf[i].sprite_initiala[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",89);
			} 
			
		}
		if(!p_igetw(&itemsbuf[i].sprite_script,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",90);
		} 
		
		
		}
}
	
void FFScript::write_mapscreens(PACKFILE *f,int32_t vers_id)
{
	for(int32_t i=0; i<map_count && i<MAXMAPS; i++)
		{
		for(int32_t j=0; j<MAPSCRS; j++)
		{
			mapscr *m = &TheMaps[i*MAPSCRS+j];
			
			if(!p_putc(m->valid,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->guy,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			{
			if(!p_iputw(m->str,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			if(!p_putc(m->room,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->item,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->hasitem, f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			for(int32_t k=0; k<4; k++)
			{
			if(!p_putc(m->tilewarptype[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			if(!p_iputw(m->door_combo_set,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			for(int32_t k=0; k<4; k++)
			{
			if(!p_putc(m->warpreturnx[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			for(int32_t k=0; k<4; k++)
			{
			if(!p_putc(m->warpreturny[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			if(!p_iputw(m->warpreturnc,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->stairx,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->stairy,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->itemx,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->itemy,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_iputw(m->color,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->enemyflags,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			for(int32_t k=0; k<4; k++)
			{
			if(!p_putc(m->door[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			for(int32_t k=0; k<4; k++)
			{
			if(!p_iputw(m->tilewarpdmap[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			for(int32_t k=0; k<4; k++)
			{
			if(!p_putc(m->tilewarpscr[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			if(!p_putc(m->tilewarpoverlayflags,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->exitdir,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			for(int32_t k=0; k<10; k++)
			{
			{
				if(!p_iputw(m->enemy[k],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
			}
			}
			
			if(!p_putc(m->pattern,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			for(int32_t k=0; k<4; k++)
			{
			if(!p_putc(m->sidewarptype[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			if(!p_putc(m->sidewarpoverlayflags,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->warparrivalx,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->warparrivaly,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			for(int32_t k=0; k<4; k++)
			{
			if(!p_putc(m->path[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			for(int32_t k=0; k<4; k++)
			{
			if(!p_putc(m->sidewarpscr[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			for(int32_t k=0; k<4; k++)
			{
			if(!p_iputw(m->sidewarpdmap[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			if(!p_putc(m->sidewarpindex,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_iputw(m->undercombo,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->undercset,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_iputw(m->catchall,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->flags,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->flags2,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->flags3,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->flags4,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->flags5,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_iputw(m->noreset,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_iputw(m->nocarry,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->flags6,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->flags7,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->flags8,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->flags9,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->flags10,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->csensitive,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->oceansfx,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->bosssfx,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->secretsfx,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->holdupsfx,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			for(int32_t k=0; k<6; k++)
			{
			if(!p_putc(m->layermap[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			for(int32_t k=0; k<6; k++)
			{
			if(!p_putc(m->layerscreen[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			for(int32_t k=0; k<6; k++)
			{
			if(!p_putc(m->layeropacity[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			if(!p_iputw(m->timedwarptics,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->nextmap,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->nextscr,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			for(int32_t k=0; k<128; k++)
			{
			if(!p_iputw(m->secretcombo[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			for(int32_t k=0; k<128; k++)
			{
			if(!p_putc(m->secretcset[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			for(int32_t k=0; k<128; k++)
			{
			if(!p_putc(m->secretflag[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			for(int32_t k=0; k<176; k++)
			{
			try
			{
				if(!p_iputw(m->data[k],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
			}
			catch(std::out_of_range& )
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			for(int32_t k=0; k<176; k++)
			{
			try
			{
				if(!p_putc(m->sflag[k], f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
			}
			catch(std::out_of_range& )
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			for(int32_t k=0; k<176; k++)
			{
			try
			{
				if(!p_putc(m->cset[k],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
			}
			catch(std::out_of_range& )
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			if(!p_iputw(m->screen_midi,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->lens_layer,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			for(int32_t k=0; k<32; k++)
			{
			
				if(!p_iputw(m->ffcs[k].data,f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_putc(m->ffcs[k].cset,f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputw(m->ffcs[k].delay,f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputzf(m->ffcs[k].x,f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputzf(m->ffcs[k].y,f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputzf(m->ffcs[k].vx,f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputzf(m->ffcs[k].vy,f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputzf(m->ffcs[k].ax,f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputzf(m->ffcs[k].ay,f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_putc(m->ffcs[k].link,f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputl(m->ffcs[k].hit_width,f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputl(m->ffcs[k].hit_height,f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_putc(m->ffcs[k].txsz,f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_putc(m->ffcs[k].tysz,f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputl(m->ffcs[k].flags,f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputw(m->ffcs[k].script,f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputl(m->ffcs[k].initd[0],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputl(m->ffcs[k].initd[1],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputl(m->ffcs[k].initd[2],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputl(m->ffcs[k].initd[3],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputl(m->ffcs[k].initd[4],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputl(m->ffcs[k].initd[5],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputl(m->ffcs[k].initd[6],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputl(m->ffcs[k].initd[7],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
			
			}
			
			for ( int32_t q = 0; q < 10; q++ ) 
			{
			if(!p_iputl(m->npcstrings[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			} 
			}
			for ( int32_t q = 0; q < 10; q++ ) 
			{
			if(!p_iputw(m->new_items[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			} 
			}
			for ( int32_t q = 0; q < 10; q++ ) 
			{
			if(!p_iputw(m->new_item_x[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			} 
			}
			for ( int32_t q = 0; q < 10; q++ ) 
			{
			if(!p_iputw(m->new_item_y[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			} 
			}
			if(!p_iputw(m->script,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			} 
			for ( int32_t q = 0; q < 8; q++ )
			{
			if(!p_iputl(m->screeninitd[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			} 
				
			}
			if(!p_putc(m->preloadscript,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->hidelayers,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}  
			if(!p_putc(m->hidescriptlayers,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}    
				
			
		} //end mapscr for loop
	}
}
void FFScript::read_mapscreens(PACKFILE *f,int32_t vers_id)
{
	for(int32_t i=0; i<map_count && i<MAXMAPS; i++)
		{
		for(int32_t j=0; j<MAPSCRS; j++)
		{
			mapscr *m = &TheMaps[i*MAPSCRS+j];
			
			if(!p_getc(&(m->valid),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->guy),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			{
			if(!p_igetw(&(m->str),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			if(!p_getc(&(m->room),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->item),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->hasitem), f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			for(int32_t k=0; k<4; k++)
			{
			if(!p_getc(&(m->tilewarptype[k]),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			if(!p_igetw(&(m->door_combo_set),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			for(int32_t k=0; k<4; k++)
			{
			if(!p_getc(&(m->warpreturnx[k]),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			for(int32_t k=0; k<4; k++)
			{
			if(!p_getc(&(m->warpreturny[k]),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			if(!p_igetw(&(m->warpreturnc),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->stairx),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->stairy),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->itemx),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->itemy),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_igetw(&(m->color),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->enemyflags),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			for(int32_t k=0; k<4; k++)
			{
			if(!p_getc(&(m->door[k]),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			for(int32_t k=0; k<4; k++)
			{
			if(!p_igetw(&(m->tilewarpdmap[k]),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			for(int32_t k=0; k<4; k++)
			{
			if(!p_getc(&(m->tilewarpscr[k]),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			if(!p_getc(&(m->tilewarpoverlayflags),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->exitdir),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			for(int32_t k=0; k<10; k++)
			{
			{
				if(!p_igetw(&(m->enemy[k]),f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
			}
			}
			
			if(!p_getc(&(m->pattern),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			for(int32_t k=0; k<4; k++)
			{
			if(!p_getc(&(m->sidewarptype[k]),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			if(!p_getc(&(m->sidewarpoverlayflags),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->warparrivalx),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->warparrivaly),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			for(int32_t k=0; k<4; k++)
			{
			if(!p_getc(&(m->path[k]),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			for(int32_t k=0; k<4; k++)
			{
			if(!p_getc(&(m->sidewarpscr[k]),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			for(int32_t k=0; k<4; k++)
			{
			if(!p_igetw(&(m->sidewarpdmap[k]),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			if(!p_getc(&(m->sidewarpindex),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_igetw(&(m->undercombo),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->undercset),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_igetw(&(m->catchall),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->flags),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->flags2),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->flags3),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->flags4),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->flags5),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_igetw(&(m->noreset),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_igetw(&(m->nocarry),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->flags6),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->flags7),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->flags8),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->flags9),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->flags10),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->csensitive),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->oceansfx),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->bosssfx),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->secretsfx),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->holdupsfx),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			for(int32_t k=0; k<6; k++)
			{
			if(!p_getc(&(m->layermap[k]),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			for(int32_t k=0; k<6; k++)
			{
			if(!p_getc(&(m->layerscreen[k]),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			for(int32_t k=0; k<6; k++)
			{
			if(!p_getc(&(m->layeropacity[k]),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			if(!p_igetw(&(m->timedwarptics),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->nextmap),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->nextscr),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			for(int32_t k=0; k<128; k++)
			{
			if(!p_igetw(&(m->secretcombo[k]),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			for(int32_t k=0; k<128; k++)
			{
			if(!p_getc(&(m->secretcset[k]),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			for(int32_t k=0; k<128; k++)
			{
			if(!p_getc(&(m->secretflag[k]),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			for(int32_t k=0; k<176; k++)
			{
			try
			{
				if(!p_igetw(&(m->data[k]),f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
			}
			catch(std::out_of_range& )
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			for(int32_t k=0; k<176; k++)
			{
			try
			{
				if(!p_getc(&(m->sflag[k]),f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
			}
			catch(std::out_of_range& )
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			for(int32_t k=0; k<176; k++)
			{
			try
			{
				if(!p_getc(&(m->cset[k]),f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
			}
			catch(std::out_of_range& )
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			if(!p_igetw(&(m->screen_midi),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->lens_layer),f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			word tempw;
			for(int32_t k=0; k<32; k++)
			{
			
				if(!p_igetw(&tempw,f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				zc_ffc_set(m->ffcs[k], tempw);
				
				if(!p_getc(&(m->ffcs[k].cset),f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetw(&(m->ffcs[k].delay),f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetzf(&(m->ffcs[k].x),f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetzf(&(m->ffcs[k].y),f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetzf(&(m->ffcs[k].vx),f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetzf(&(m->ffcs[k].vy),f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetzf(&(m->ffcs[k].ax),f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetzf(&(m->ffcs[k].ay),f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_getc(&(m->ffcs[k].link),f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetl(&(m->ffcs[k].hit_width),f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetl(&(m->ffcs[k].hit_height),f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_getc(&(m->ffcs[k].txsz),f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_getc(&(m->ffcs[k].tysz),f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetl(&(m->ffcs[k].flags),f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetw(&(m->ffcs[k].script),f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetl(&(m->ffcs[k].initd[0]),f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetl(&(m->ffcs[k].initd[1]),f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetl(&(m->ffcs[k].initd[2]),f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetl(&(m->ffcs[k].initd[3]),f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetl(&(m->ffcs[k].initd[4]),f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetl(&(m->ffcs[k].initd[5]),f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetl(&(m->ffcs[k].initd[6]),f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetl(&(m->ffcs[k].initd[7]),f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
			
			}
			
			for ( int32_t q = 0; q < 10; q++ ) 
			{
			if(!p_igetl(&(m->npcstrings[q]),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			} 
			}
			for ( int32_t q = 0; q < 10; q++ ) 
			{
			if(!p_igetw(&(m->new_items[q]),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			} 
			}
			for ( int32_t q = 0; q < 10; q++ ) 
			{
			if(!p_igetw(&(m->new_item_x[q]),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			} 
			}
			for ( int32_t q = 0; q < 10; q++ ) 
			{
			if(!p_igetw(&(m->new_item_y[q]),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			} 
			}
			if(!p_igetw(&(m->script),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			} 
			for ( int32_t q = 0; q < 8; q++ )
			{
			if(!p_igetl(&(m->screeninitd[q]),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			} 
				
			}
			if(!p_getc(&(m->preloadscript),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if ( vers_id >= 2 )
			{
			if(!p_getc(&(m->hidelayers),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}  
			if(!p_getc(&(m->hidescriptlayers),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}    
				
			}
			
			
		}//end mapscr all for loop
		
	}
}
/*
void FFScript::write_maps(PACKFILE *f, int32_t vers_id)
{
		for(int32_t i=0; i<map_count && i<MAXMAPS; i++)
		{
		for(int32_t j=0; j<MAPSCRS; j++)
		{
			if ( !(FFCore.write_mapscreen(f,i,j,vers_id)) )
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODE: %d",i*j);
			}
		}
		}
}

void FFScript::read_maps(PACKFILE *f, int32_t vers_id)
{
		for(int32_t i=0; i<map_count && i<MAXMAPS; i++)
		{
		for(int32_t j=0; j<MAPSCRS; j++)
		{
			if ( !(FFCore.read_mapscreen(f,i,j,vers_id)) )
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE: %d",i*j);
			}
		}
		}
}
*/


int32_t FFScript::getHeroOTile(int32_t index1, int32_t index2)
{
	{
		herospritetype lst = (herospritetype)index1;
		int32_t dir = index2;
		int32_t the_ret = 0;
		switch(lst)
		{
		case LSprwalkspr: the_ret = walkspr[dir][0]; break;
			case LSprstabspr: the_ret = stabspr[dir][0]; break;
			case LSprslashspr: the_ret = slashspr[dir][0]; break;
			case LSprrevslashspr: the_ret = revslashspr[dir][0]; break;
			case LSprfloatspr: the_ret = floatspr[dir][0]; break;
			case LSprswimspr: the_ret = swimspr[dir][0]; break;
			case LSprdivespr: the_ret = divespr[dir][0]; break;
			case LSprdrownspr: the_ret = drowningspr[dir][0]; break;
			case LSprsidedrownspr: the_ret = sidedrowningspr[dir][0]; break;
			case LSprlavadrownspr: the_ret = drowning_lavaspr[dir][0]; break;
			case LSprsideswimspr: the_ret = sideswimspr[dir][0]; break;
			case LSprsideswimslashspr: the_ret = sideswimslashspr[dir][0]; break;
			case LSprsideswimstabspr: the_ret = sideswimstabspr[dir][0]; break;
			case LSprsideswimpoundspr: the_ret = sideswimpoundspr[dir][0]; break;
			case LSprsideswimchargespr: the_ret = sideswimchargespr[dir][0]; break;
			case LSprpoundspr: the_ret = poundspr[dir][0]; break;
			case LSprjumpspr: the_ret = jumpspr[dir][0]; break;
			case LSprchargespr: the_ret = chargespr[dir][0]; break;
			case LSprcastingspr: the_ret = castingspr[0]; break;
			case LSprsideswimcastingspr: the_ret = sideswimcastingspr[0]; break;
			case LSprholdspr1: the_ret = holdspr[0][0][0]; break;
			case LSprholdspr2:  the_ret = holdspr[0][1][0]; break;
			case LSprholdsprw1: the_ret = holdspr[1][0][0]; break;
			case LSprholdsprw2: the_ret = holdspr[1][1][0]; break;
			case LSprholdsprSw1: the_ret = sideswimholdspr[0][0]; break;
			case LSprholdsprSw2: the_ret = sideswimholdspr[1][0]; break;
			default: the_ret = 0;
		}
	
	return the_ret*10000;
	}
}

defWpnSprite FFScript::getDefWeaponSprite(int32_t wpnid)
{
	switch(wpnid)
	{
		case wNone: return ws_0;
		case wSword: return ws_0;
		case wBeam: return wsBeam;
		case wBrang : return wsBrang;
		case wBomb: return wsBomb;
		case wSBomb: return wsSBomb;
		case wLitBomb: return wsBombblast;
		case wLitSBomb: return wsBombblast;
		case wArrow: return wsArrow;
		case wRefArrow: return wsArrow;
		case wFire: return wsFire;
		case wRefFire: return wsFire;
		case wRefFire2: return wsFire;
		case wWhistle: return wsUnused45;
		case wBait: return wsBait;
		case wWand: return wsWandHandle;
		case wMagic: return wsMagic;
		case wCatching: return wsUnused45;
		case wWind: return wsWind;
		case wRefMagic: return wsRefMagic;
		case wRefFireball: return wsRefFireball;
		case wRefRock: return wsRock;
		case wHammer: return wsHammer;
		case wHookshot: return wsHookshotHead;
		case wHSHandle: return wsHookshotHandle;
		case wHSChain: return wsHookshotChainH;
		case wSSparkle: return wsSilverSparkle;
		case wFSparkle: return wsGoldSparkle;
		case wSmack: return wsHammerSmack;
		case wPhantom: return wsUnused45;
		case wCByrna: return wsByrnaCane;
		case wRefBeam: return wsRefBeam;
		case wStomp: return wsUnused45;
		case lwMax: return wsUnused45;
		case wScript1: 
		case wScript2:
		case wScript3:
		case wScript4:
		case wScript5:
		case wScript6:
		case wScript7:
		case wScript8:
		case wScript9:
		case wScript10: return ws_0;
		case wIce: return wsIce; //new
		case wFlame: return wsEFire2; //new
		//not implemented; t/b/a
		case wSound:
		case wThrown: 
		case wPot:
		case wLit:
		case wBombos:
		case wEther:
		case wQuake:
		case wSword180:
		case wSwordLA:  return wsUnused45;
	
		case ewFireball: return wsFireball2;
		case ewArrow: return wsEArrow;
		case ewBrang: return wsBrang;
		case ewSword: return wsEBeam;
		case ewRock: return wsRock;
		case ewMagic: return wsEMagic;
		case ewBomb: return wsEBomb;
		case ewSBomb: return wsESbomb;
		case ewLitBomb: return wsEBombblast;
		case ewLitSBomb: return wsESbombblast;
		case ewFireTrail: return wsEFiretrail;
		case ewFlame: return wsEFire;
		case ewWind: return wsEWind;
		case ewFlame2: return wsEFire2;
		case ewFlame2Trail: return wsEFiretrail2;
		case ewIce: return wsIce;
		case ewFireball2: return wsFireball2;
		default: return wsUnused45;
	}
};


int32_t FFScript::getEnemyByScriptUID(int32_t sUID)
{
	
	for(word i = 0; i < guys.Count(); i++)
		{
			enemy *w = (enemy*)guys.spr(i);
			if ( w ->script_UID == sUID ) return i;
		}
	return -1;
}

int32_t FFScript::getLWeaponByScriptUID(int32_t sUID)
{
	
	for(word i = 0; i < Lwpns.Count(); i++)
		{
			weapon *w = (weapon*)Lwpns.spr(i);
			if ( w ->script_UID == sUID ) return i;
		}
	return -1;
}

int32_t FFScript::getEWeaponByScriptUID(int32_t sUID)
{
	
	for(word i = 0; i < Ewpns.Count(); i++)
		{
			weapon *w = (weapon*)Ewpns.spr(i);
			if ( w ->script_UID == sUID ) return i;
		}
	return -1;
}


void FFScript::do_loadlweapon_by_script_uid(const bool v)
{
	int32_t sUID = SH::get_arg(sarg1, v); //literal, not div by 10000

	int32_t indx = FFCore.getLWeaponByScriptUID(sUID);
	if ( indx > -1 ) 
		ri->lwpn = Lwpns.spr(indx)->getUID();
	else
	{
		ri->lwpn = 0;
		if(get_qr(qr_LOG_INVALID_UID_LOAD))
			Z_scripterrlog("There is no valid LWeapon associated with UID (%) at this time.\nThe UID is stale, or invalid.\n", sUID);
	}
}

void FFScript::do_loadeweapon_by_script_uid(const bool v)
{
	
	int32_t sUID = SH::get_arg(sarg1, v); //literal, not div by 10000

	int32_t indx = FFCore.getEWeaponByScriptUID(sUID);
	if ( indx > -1 ) 
		ri->ewpn = Ewpns.spr(indx)->getUID();
	else
	{
		ri->ewpn = 0;
		if(get_qr(qr_LOG_INVALID_UID_LOAD))
			Z_scripterrlog("There is no valid EWeapon associated with UID (%) at this time.\nThe UID is stale, or invalid.\n", sUID);
	}
}


void FFScript::do_loadnpc_by_script_uid(const bool v)
{
	
	int32_t sUID = SH::get_arg(sarg1, v); //literal, not div by 10000

	int32_t indx = FFCore.getEnemyByScriptUID(sUID);
	if ( indx > -1 ) 
		ri->guyref = guys.spr(indx)->getUID();
	else
	{
		ri->guyref = 0;
		if(get_qr(qr_LOG_INVALID_UID_LOAD))
			Z_scripterrlog("There is no valid NPC associated with UID (%) at this time.\nThe UID is stale, or invalid.\n", sUID);
	}
}

//Combo Scripts

void FFScript::clear_combo_scripts()
{
	memset(combo_id_cache, -1, sizeof(combo_id_cache));
	clear_script_engine_data_of_type(ScriptType::Combo);
}

void FFScript::clear_combo_script(int32_t lyr, int32_t pos)
{
	if(lyr < 0) return;

	
	int32_t index = get_combopos_ref(pos, lyr);
	if (index >= 176*7) return;

	combo_id_cache[index] = -1;
	combopos_modified = index;
	clear_script_engine_data(ScriptType::Combo, index);
}

int32_t FFScript::getComboDataLayer(int32_t c, ScriptType scripttype)
{
	if ( scripttype != ScriptType::Combo )
	{
		Z_scripterrlog("combodata->Layer() only runs from combo scripts, not from script type &s\n", ScriptTypeToString(scripttype));
		return -1;
	}
	else
	{
		int32_t l = 0;
		for (int32_t q = 176; q < 1232; q+= 176 )
		{
			if ( c < q )
			{
				return l;
			}
			++l;
		}
		return -1;
	}
}

int32_t FFScript::getCombodataPos(int32_t c, ScriptType scripttype)
{
	if ( scripttype != ScriptType::Combo )
	{
		Z_scripterrlog("combodata->Pos() only runs from combo scripts, not from script type &s\n", ScriptTypeToString(scripttype));
		return -1;
	}
	else return ((c%176));
}

int32_t FFScript::getCombodataX(int32_t c, ScriptType scripttype)
{
	if ( scripttype != ScriptType::Combo )
	{
		Z_scripterrlog("combodata->X() only runs from combo scripts, not from script type &s\n", ScriptTypeToString(scripttype));
		return -1;
	}
	else
	{
		int32_t pos = getCombodataPos(c, scripttype);
		return COMBOX(pos);
	}
}

int32_t FFScript::getCombodataY(int32_t c, ScriptType scripttype)
{
	if ( scripttype != ScriptType::Combo )
	{
		Z_scripterrlog("combodata->Y() only runs from combo scripts, not from script type &s\n", ScriptTypeToString(scripttype));
		return -1;
	}
	else
	{
		int32_t pos = getCombodataPos(c, scripttype);
		return COMBOY(pos);
	}
}

void FFScript::ClearComboScripts()
{
	for ( int32_t c = 0; c < 176; c++ )
	{
		reset_script_engine_data(ScriptType::Combo, c);
	}
}

int32_t FFScript::combo_script_engine(const bool preload, const bool waitdraw)
{
	///non-scripted effects
	for ( int32_t q = 0; q < 7; ++q )
	{
		if (!get_qr(qr_COMBOSCRIPTS_LAYER_0+q))
			continue;
		for ( int32_t c = 0; c < 176; ++c )
		{
			// int32_t ls = (q ? tmpscr->layerscreen[q-1] : 0);
			// int32_t lm = (q ? tmpscr->layermap[q-1] : 0);
			// if(q && !lm) continue; //No layer for this screen
			int32_t idval = get_combopos_ref(c, q);
			mapscr* m = FFCore.tempScreens[q]; //get templayer mapscr for any layer (including 0)
			word cid = m->data[c];
			if(combo_id_cache[idval] < 0)
				combo_id_cache[idval] = cid;
			else if(combo_id_cache[idval] != cid)
			{
				combopos_modified = idval;
				combo_id_cache[idval] = cid;
				clear_script_engine_data(ScriptType::Combo, idval);
			}
			
			if ( combobuf[cid].script )
			{
				auto& data = get_script_engine_data(ScriptType::Combo, idval);
				if (data.doscript)
				{
					if (waitdraw && !data.waitdraw) continue;

					ZScriptVersion::RunScript(ScriptType::Combo, combobuf[cid].script, idval);
					if (waitdraw) data.waitdraw = false;
				}
			}
		}
	}
	return 1;
}

//Config for file->

/*         ______   ___    ___
 *        /\  _  \ /\_ \  /\_ \ 
 *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
 *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
 *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
 *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
 *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
 *                                           /\____/
 *                                           \_/__/
 *
 *      Ported from Allegro 4.4.3.1 Configuration routines.
 *
 *      By Shawn Hargreaves; C++ Port by ZoriaRPG
 *
 *      Hook functions added by Martijn Versteegh.
 *
 *      Annie Testes lifted several hardcoded length limitations.
 *
 *      See readme.txt for copyright information.
 */


#include "allegro.h"
#include "allegro/internal/aintern.h"





/* zscript_flush_config:
 *  Writes out a config structure to disk if the contents
 *  have changed.
 */
void zscript_flush_config(ZSCRIPT_CONFIG *cfg)
{
	ZSCRIPT_CONFIG_ENTRY *pos;
	PACKFILE *f;
	char cr[16];

	usetc(cr+usetc(cr, '\n'), 0);

	if (cfg && cfg->filename && cfg->dirty) 
	{
		/* write changed data to disk */
		f = pack_fopen(cfg->filename, F_WRITE);
	
		if (f) 
		{
			pos = cfg->head;

			while (pos) 
			{
				if (pos->name) 
				{
					pack_fputs(pos->name, f);

					if (ugetc(pos->name) != '[') 
					{
						pack_putc(' ', f);
						pack_putc('=', f);
						pack_putc(' ', f);
					}
				}

				if (pos->data)
					pack_fputs(pos->data, f);

				pack_fputs(cr, f);

				pos = pos->next;
			}

			pack_fclose(f);
			cfg->dirty = FALSE;
		}
	}
}



/* zscript_flush_config_file:
 *  Writes out the config file to disk if the contents
 *  have changed.
 */
void zscript_flush_config_file(void)
{
	zscript_flush_config(config[0]);
}



/* zscript_destroy_config:
 *  Destroys a config structure, writing it out to disk if the contents
 *  have changed.
 */
void zscript_destroy_config(ZSCRIPT_CONFIG *cfg)
{
	ZSCRIPT_CONFIG_ENTRY *pos, *prev;
	
	if (cfg) 
	{
		zscript_flush_config(cfg);

		if (cfg->filename)
			_AL_FREE(cfg->filename);

		/* destroy the variable list */
		pos = cfg->head;

		while (pos) 
		{
			prev = pos;
			pos = pos->next;

			if (prev->name)
				_AL_FREE(prev->name);

			if (prev->data)
				_AL_FREE(prev->data);

			_AL_FREE(prev);
		}

		_AL_FREE(cfg);
	}
}



/* zscript_config_cleanup:
 *  Called at shutdown time to free memory being used by the config routines,
 *  and write any changed data out to disk.
 */
void zscript_config_cleanup(void)
{
	ZSCRIPT_CONFIG_HOOK *hook, *nexthook;
	int32_t i;

	for (i=0; i<MAX_CONFIGS; i++) 
	{
		if (config[i]) 
		{
			zscript_destroy_config(config[i]);
			config[i] = NULL;
		}
	}

	if (config_override) 
	{
		zscript_destroy_config(config_override);
		config_override = NULL;
	}

	if (config_language) 
	{
		zscript_destroy_config(config_language);
		config_language = NULL;
	}

	if (system_config) 
	{
		zscript_destroy_config(system_config);
		system_config = NULL;
	}

	if (config_hook) 
	{
		hook = config_hook;

		while (hook) 
		{
			if (hook->section)
				_AL_FREE(hook->section);

			nexthook = hook->next; 
			_AL_FREE(hook);
			hook = nexthook;
		}

		config_hook = NULL;
	}

	_AL_FREE(config_argv);
	config_argv = NULL;
   
	_AL_FREE(argv_buf);
	argv_buf = NULL;
   
	argv_buf_size = 0;

	_remove_exit_func(zscript_config_cleanup);
	config_installed = FALSE;
}



/* zscript_init_config:
 *  Sets up the configuration routines ready for use, also loading the
 *  default config file if the loaddata flag is set and no other config
 *  file is in memory.
 */
void zscript_init_config(int32_t loaddata)
{
	char filename[1024], tmp[128], *cfg_name;

	if (!config_installed) 
	{
		_add_exit_func(zscript_config_cleanup, "zscript_config_cleanup");
		config_installed = TRUE;
	}

	if ((loaddata) && (!config[0])) 
	{
		cfg_name = uconvert_ascii("allegro.cfg", tmp);

		if (find_allegro_resource(filename, cfg_name, NULL, NULL, NULL, NULL, NULL, sizeof(filename)) != 0) 
		{
			get_executable_name(filename, sizeof(filename));
			usetc(get_filename(filename), 0);
			ustrzcat(filename, sizeof(filename), cfg_name);
		}

		zscript_set_config_file(filename);
	}

	if (!system_config) 
	{
		system_config = (struct ZSCRIPT_CONFIG*)malloc(sizeof(ZSCRIPT_CONFIG));
		if (system_config) 
		{
			system_config->head = NULL;
			system_config->filename = NULL;
			system_config->dirty = FALSE;
		}
	}
}



/* zscript_get_config_line:
 *  Helper for splitting files up into individual lines. Returns the length
 *  in bytes of the sequence of characters delimited by the first EOL marker
 *  in the array DATA of length LENGTH, and allocates NAME and VAL to record
 *  the name and the value of the config entry respectively; otherwise set
 *  NAME to NULL and returns a copy of the line through VAL if the line was
 *  blank or a comment. Returns -1 and set allegro_errno on failure.
 */
int32_t zscript_get_config_line(const char *data, int32_t length, char **name, char **val)
{
	char *buf;
	int32_t buf_size=256;
	int32_t inpos, outpos, i, j;
	int32_t c, c2, w0;

	inpos = 0;
	outpos = 0;
	w0 = ucwidth(0);

	buf = (char*)_AL_MALLOC_ATOMIC(buf_size);
	if (!buf) 
	{
		*allegro_errno = ENOMEM;
		return -1;
	}

	/* search for an EOL marker */
	while (inpos<length) 
	{
		c = ugetc(data+inpos);
		if ((c == '\r') || (c == '\n')) 
		{
			inpos += uwidth(data+inpos);
			if (inpos < length) 
			{
				c2 = ugetc(data+inpos);
				if (((c == '\r') && (c2 == '\n')) || ((c == '\n') && (c2 == '\r')))
					inpos += uwidth(data+inpos);
			}
			break;
		}

		/* increase the buffer size if needed */
		if (outpos>=(int32_t)buf_size-w0) 
		{
			buf_size *= 2;
			buf = (char*)_al_sane_realloc(buf, buf_size);
			if (!buf) 
			{
				*allegro_errno = ENOMEM;
				return -1;
			}
		}

		outpos += usetc(buf+outpos, c);
		inpos += uwidth(data+inpos);
	}

	usetc(buf+outpos, 0);

	/* skip leading spaces */
	i = 0;
	c = ugetc(buf);

	while ((c) && (uisspace(c))) 
	{
		i += uwidth(buf+i);
		c = ugetc(buf+i);
	}

	/* read name string */
	j = 0;

	/* compute name length */
	while ((c) && (!uisspace(c)) && (c != '=') && (c != '#')) 
	{
		j += ucwidth(c);
		i += uwidth(buf+i);
		c = ugetc(buf+i);
	}

	if (j) 
	{
		/* got a variable */
		*name = (char*)_AL_MALLOC_ATOMIC(j+w0);
		if (!(*name)) 
		{
			*allegro_errno = ENOMEM;
			_AL_FREE(buf);
			return -1;
		}

		ustrzcpy(*name, j+w0, buf+i-j);

		while ((c) && ((uisspace(c)) || (c == '='))) 
		{
			i += uwidth(buf+i);
			c = ugetc(buf+i);
		}

		*val = _al_ustrdup(buf+i);
		if (!(*val)) 
		{
			_AL_FREE(name);
			_AL_FREE(buf);
			return -1;
		}

		/* strip trailing spaces */
		i = ustrlen(*val) - 1;
		while ((i >= 0) && (uisspace(ugetat(*val, i))))
			usetat(*val, i--, 0);
	}
	else 
	{
		/* blank line or comment */
		*name = NULL;
		*val = _al_ustrdup(buf);
		if (!(*val)) 
		{
			_AL_FREE(buf);
			return -1;
		}
	}

	_AL_FREE(buf);

	return inpos;
}



/* zscript_set_config:
 *  Does the work of setting up a config structure.
 */
void zscript_set_config(ZSCRIPT_CONFIG **config, const char *data, int32_t length, const char *filename)
{
	ZSCRIPT_CONFIG_ENTRY **prev, *p;
	char *name, *val;
	int32_t ret, pos;

	zscript_init_config(FALSE);

	if (*config) 
	{
		zscript_destroy_config(*config);
		*config = NULL;
	}

	*config = (struct ZSCRIPT_CONFIG*)_AL_MALLOC(sizeof(ZSCRIPT_CONFIG));
	if (!(*config)) 
	{
		*allegro_errno = ENOMEM;
		return;
	}

	(*config)->head = NULL;
	(*config)->dirty = FALSE;

	if (filename) 
	{
		(*config)->filename = _al_ustrdup(filename);
		if (!(*config)->filename) 
		{
			_AL_FREE(*config);
			*config = NULL;
			return;
		}
	}
	else
		(*config)->filename = NULL;

	prev = &(*config)->head;
	pos = 0;

	while (pos < length) 
	{
		ret = zscript_get_config_line(data+pos, length-pos, &name, &val);
		if (ret<0) 
		{
			_AL_FREE(*config);
			*config = NULL;
			return;
		}

		pos += ret;

		p = (struct ZSCRIPT_CONFIG_ENTRY*)_AL_MALLOC(sizeof(ZSCRIPT_CONFIG_ENTRY));
		if (!p) 
		{
			*allegro_errno = ENOMEM;
			_AL_FREE(*config);
			*config = NULL;
			return;
		}

		p->name = name;
		p->data = val;

		p->next = NULL;
		*prev = p;
		prev = &p->next;
	}
}



/* zscript_load_config_file:
 *  Does the work of loading a config file.
 */
void zscript_load_config_file(ZSCRIPT_CONFIG **config, const char *filename, const char *savefile)
{
	char *tmp, *tmp2;
	uint64_t length;

	if (*config) 
	{
		zscript_destroy_config(*config);
		*config = NULL;
	}

	/* Special case when allegro_init has not been called yet. */
	if (!system_driver) 
	{
		zscript_set_config(config, NULL, 0, savefile);
		return;
	}

	length = file_size_ex(filename);

	if (length > 0) 
	{
		PACKFILE *f = pack_fopen(filename, F_READ);

		if (f) 
		{
			tmp = (char*)_AL_MALLOC_ATOMIC(length+1);

			if (tmp) 
			{
				pack_fread(tmp, length, f);
				tmp[length] = 0;

				if (need_uconvert(tmp, U_UTF8, U_CURRENT)) 
				{
					length = uconvert_size(tmp, U_UTF8, U_CURRENT);
					tmp2 = (char*)_AL_MALLOC_ATOMIC(length);

					if (tmp2)
						do_uconvert(tmp, U_UTF8, tmp2, U_CURRENT, length);

					length -= ucwidth(0);
				}
				else
					tmp2 = tmp;

				if (tmp2) 
				{
					zscript_set_config(config, tmp2, length, savefile);

					if (tmp2 != tmp)
					_AL_FREE(tmp2);
				}

				_AL_FREE(tmp);
			}
			else
				zscript_set_config(config, NULL, 0, savefile);

			pack_fclose(f);
		}
		else
			zscript_set_config(config, NULL, 0, savefile);
	}
	else
		zscript_set_config(config, NULL, 0, savefile);
}



/* zscript_set_config_file:
 *  Sets the file to be used for all future configuration operations.
 */
void zscript_set_config_file(const char *filename)
{
	ASSERT(filename);
	zscript_load_config_file(&config[0], filename, filename);
}



/* zscript_set_config_data:
 *  Sets the block of data to be used for all future configuration 
 *  operations.
 */
void zscript_set_config_data(const char *data, int32_t length)
{
	ASSERT(data);
	zscript_set_config(&config[0], data, length, NULL);
}



/* zscript_override_config_file:
 *  Sets the file that will override all future configuration operations.
 */
void zscript_override_config_file(const char *filename)
{
	/* load other configuration file to override settings */
	if (filename)
		zscript_load_config_file(&config_override, filename, filename);
	/* destroy the current one */
	else if (config_override) 
	{
		zscript_destroy_config(config_override);
		config_override = NULL;
	}
}



/* zscript_override_config_data:
 *  Sets the block of data that will override all future configuration 
 *  operations.
 */
void zscript_override_config_data(const char *data, int32_t length)
{
	ASSERT(data);
	zscript_set_config(&config_override, data, length, NULL);
}



/* zscript_push_config_state:
 *  Pushes the current config state onto the stack.
 */
void zscript_push_config_state(void)
{
	int32_t i;

	if (config[MAX_CONFIGS-1])
		zscript_destroy_config(config[MAX_CONFIGS-1]);

	for (i=MAX_CONFIGS-1; i>0; i--)
		config[i] = config[i-1];

	config[0] = NULL;
}



/* zscript_pop_config_state:
 *  Pops the current config state off the stack.
 */
void zscript_pop_config_state(void)
{
	int32_t i;

	if (config[0])
		zscript_destroy_config(config[0]);

	for (i=0; i<MAX_CONFIGS-1; i++)
		config[i] = config[i+1];

	config[MAX_CONFIGS-1] = NULL;
}



/* zscript_prettify_config_section_name:
 *  Helper for ensuring that a section name is enclosed by [ ] braces.
 */
void zscript_prettify_config_section_name(const char *in, char *out, int32_t out_size)
{
	int32_t p;

	if ((in) && (ustrlen(in))) 
	{
		if (ugetc(in) != '[') 
		{
			p = usetc(out, '[');
			usetc(out+p, 0);
		}
		else
			usetc(out, 0);

		ustrzcat(out, out_size - ucwidth(']'), in);

		out += uoffset(out, -1);

		if (ugetc(out) != ']') 
		{
			out += uwidth(out);
			out += usetc(out, ']');
			usetc(out, 0);
		}
	}
	else
		usetc(out, 0);
}



/* zscript_hook_config_section:
 *  Hooks a config section to a set of getter/setter functions. This will 
 *  override the normal table of values, and give the provider of the hooks 
 *  complete control over that section.
 */
void zscript_hook_config_section(const char *section, int32_t (*intgetter)(const char *, int32_t), const char *(*stringgetter)(const char *, const char *), void (*stringsetter)(const char *, const char *))
{
	ZSCRIPT_CONFIG_HOOK *hook, **prev;
	char section_name[256];

	zscript_init_config(FALSE);
	
	zscript_prettify_config_section_name(section, section_name, sizeof(section_name));

	hook = config_hook;
	prev = &config_hook;

	while (hook) 
	{
		if (ustricmp(section_name, hook->section) == 0) 
		{
			if ((intgetter) || (stringgetter) || (stringsetter)) 
			{
				/* modify existing hook */
				hook->intgetter = intgetter;
				hook->stringgetter = stringgetter;
				hook->stringsetter = stringsetter;
			}
			else 
			{
				/* remove a hook */
				*prev = hook->next;
				_AL_FREE(hook->section);
			}

			return;
		}

		prev = &hook->next;
		hook = hook->next;
	}

	/* add a new hook */
	hook = (struct ZSCRIPT_CONFIG_HOOK*)_AL_MALLOC(sizeof(ZSCRIPT_CONFIG_HOOK));
	if (!hook)
	return;

	hook->section = _al_ustrdup(section_name);
	if (!(hook->section)) 
	{
		_AL_FREE(hook);
		return;
	}

	hook->intgetter = intgetter;
	hook->stringgetter = stringgetter;
	hook->stringsetter = stringsetter;

	hook->next = config_hook;
	config_hook = hook;
}



/* is_config_hooked:
 *  Checks whether a specific section is hooked in any way.
 */
int32_t zscript_config_is_hooked(const char *section)
{
	ZSCRIPT_CONFIG_HOOK *hook = config_hook;
	char section_name[256];

	zscript_prettify_config_section_name(section, section_name, sizeof(section_name));

	while (hook) 
	{
		if (ustricmp(section_name, hook->section) == 0)
			return TRUE;

		hook = hook->next;
	}

	return FALSE;
}



/* zscript_find_config_string:
 *  Helper for finding an entry in the configuration file.
 */
ZSCRIPT_CONFIG_ENTRY *zscript_find_config_string(ZSCRIPT_CONFIG *config, const char *section, const char *name, ZSCRIPT_CONFIG_ENTRY **prev)
{
	ZSCRIPT_CONFIG_ENTRY *p;
	int32_t in_section;

	if (config) 
	{
		p = config->head;

		if (prev)
			*prev = NULL;

		if (section && ugetc(section))
			in_section = FALSE;
		else
			in_section = TRUE;

		while (p) 
		{
			if (p->name) 
			{
				if ((section) && (ugetc(p->name) == '[') && (ugetat(p->name, -1) == ']')) 
				{
					/* change section */
					in_section = (ustricmp(section, p->name) == 0);
				}
				if ((in_section) || (ugetc(name) == '[')) 
				{
					/* is this the one? */
					if (ustricmp(p->name, name) == 0)
						return p;
				}
			}

			if (prev)
				*prev = p;

			p = p->next;
		}
	}

	return NULL;
}



/* zscript_get_config_string:
 *  Reads a string from the configuration file.
 */
const char *zscript_get_config_string(const char *section, const char *name, const char *def)
{
	char section_name[256];
	ZSCRIPT_CONFIG_HOOK *hook;
	ZSCRIPT_CONFIG_ENTRY *p;

	zscript_init_config(TRUE);

	zscript_prettify_config_section_name(section, section_name, sizeof(section_name));

	/* check for hooked sections */
	hook = config_hook;

	while (hook) 
	{
		if (ustricmp(section_name, hook->section) == 0) 
		{
			if (hook->stringgetter)
				return hook->stringgetter(name, def);
			else
				return def;
		}
		hook = hook->next;
	}

	/* find the string */
	p = zscript_find_config_string(config_override, section_name, name, NULL);

	if (!p) 
	{
		if ((ugetc(name) == '#') || ((ugetc(section_name) == '[') && (ugetat(section_name, 1) == '#')))
			p = zscript_find_config_string(system_config, section_name, name, NULL);
		else
			p = zscript_find_config_string(config[0], section_name, name, NULL);
	}

	if (p && p->data && (ustrlen(p->data) != 0))
		return p->data;
	else
		return def;
}



/* zscript_get_config_int:
 *  Reads an integer from the configuration file.
 */
int32_t zscript_get_config_int(const char *section, const char *name, int32_t def)
{
	ZSCRIPT_CONFIG_HOOK *hook;
	char section_name[256];
	const char *s;

	zscript_prettify_config_section_name(section, section_name, sizeof(section_name));

	/* check for hooked sections */
	hook = config_hook;

	while (hook) 
	{
		if (ustricmp(section_name, hook->section) == 0) 
		{
			if (hook->intgetter) 
			{
				return hook->intgetter(name, def);
			}
			else if (hook->stringgetter) 
			{
				s = hook->stringgetter(name, NULL);
				if ((s) && (ugetc(s)))
					return ustrtol(s, NULL, 0);
				else
					return def;
			}
			else
				return def;
		}
		hook = hook->next;
	}

	/* read normal data */
	s = zscript_get_config_string(section_name, name, NULL);

	if ((s) && (ugetc(s)))
		return ustrtol(s, NULL, 0);

	return def;
}



/* zscript_get_config_hex:
 *  Reads a hexadecimal integer from the configuration file.
 */
int32_t zscript_get_config_hex(const char *section, const char *name, int32_t def)
{
	const char *s = zscript_get_config_string(section, name, NULL);
	char tmp[64];
	int32_t i;

	if ((s) && (ugetc(s))) 
	{
		i = ustrtol(s, NULL, 16);
		if ((i == 0x7FFFFFFF) && (ustricmp(s, uconvert_ascii("7FFFFFFF", tmp)) != 0))
			i = -1;
		return i;
	}

	return def;
}



/* zscript_get_config_float:
 *  Reads a float from the configuration file.
 */
float zscript_get_config_float(const char *section, const char *name, float def)
{
	const char* s = zscript_get_config_string(section, name, NULL);

	if ((s) && (ugetc(s)))
		return uatof(s);

	return def;
}



/* zscript_get_config_id:
 *  Reads a driver ID number from the configuration file.
 */
int32_t zscript_get_config_id(const char *section, const char *name, int32_t def)
{
	const char *s = zscript_get_config_string(section, name, NULL);
	char tmp[4];
	char* endp;
	int32_t val, i;

	if ((s) && (ugetc(s))) 
	{
		val = ustrtol(s, &endp, 0);
		if (!ugetc(endp))
			return val;

		tmp[0] = tmp[1] = tmp[2] = tmp[3] = ' ';

		for (i=0; i<4; i++) 
		{
			if (ugetat(s, i))
				tmp[i] = utoupper(ugetat(s ,i));
			else
				break;
		}

		return AL_ID(tmp[0], tmp[1], tmp[2], tmp[3]);
	}

	return def;
}



/* zscript_get_config_argv:
 *  Reads an argc/argv style token list from the configuration file.
 */
char **zscript_get_config_argv(const char *section, const char *name, int32_t *argc)
{
	int32_t pos, ac, q, c;
	int32_t s_size;
	int32_t i;

	const char *s = zscript_get_config_string(section, name, NULL);

	if (!s) 
	{
		*argc = 0;
		return NULL;
	}

	/* clean up the old argv that was allocated the last time this function was
	* called.
	*/
	_AL_FREE(config_argv);
	config_argv = NULL;

	/* increase the buffer size if needed */
	s_size = ustrsizez(s);
	if (s_size>argv_buf_size) 
	{
		argv_buf_size = s_size;
		argv_buf = (char*)_al_sane_realloc(argv_buf, argv_buf_size);
		if (!argv_buf) 
		{
			*allegro_errno = ENOMEM;
			*argc = 0;
			return NULL;
		}
	}

	ustrzcpy(argv_buf, argv_buf_size, s);
	pos = 0;
	ac = 0;

	/* tokenize the buffer and count the number of words; every space character
	* as well as single and double quotes are replaced with zeros; comments * that start with # are also cut off with a 0
	*/
	c = ugetc(argv_buf);
	while ((c) && (c != '#')) 
	{
		/* replace all spaces up to the next word with 0 */
		while ((c) && (uisspace(c))) 
		{
			usetat(argv_buf+pos, 0, 0);
			pos += ucwidth(0);
			c = ugetc(argv_buf+pos);
		}

		/* quit if we reached the end of the buffer or a comment */
		if ((c) && (c != '#')) 
		{
			/* found another word! */
			ac++;

			/* cut away quotes by replacing them with 0 */
			if ((c == '\'') || (c == '"')) 
			{
				q = c;
				usetat(argv_buf+pos, 0, 0);
				pos += ucwidth(0);
				c = ugetc(argv_buf+pos);
			}
			else 
			{
				q = 0;
			}
	
			/* search for the end of the word */
			while ((c) && ((q) ? (c != q) : (!uisspace(c)))) 
			{
				pos += ucwidth(c);
				c = ugetc(argv_buf+pos);
			}
		}
	}

	/* now that we know how many words there are in the buffer, allocate enough
	* space for a list of pointers to them, or return 0 if there are no words
	*/
	if (ac > 0) 
	{
		config_argv = (char**)_AL_MALLOC(ac*sizeof *config_argv);
	}
	else 
	{
		*argc = 0;
		return NULL;
	}

	/* go through the tokenized buffer and assign pointers in argv to point to
	* the beginning of each individual word
	*/
	for (i=0,pos=0,c=ugetc(argv_buf); i<ac; i++) 
	{
		/* find next word */
		while (!c) 
		{
			pos += ucwidth(c);
			c = ugetc(argv_buf+pos);
		}

		/* assign pointer */
		config_argv[i] = argv_buf+pos;

		/* find end of the word */
		while (c) 
		{
			pos += ucwidth(c);
			c = ugetc(argv_buf+pos);
		}
	}

	*argc = ac;
	return config_argv;
}



/* zscript_insert_config_variable:
 *  Helper for inserting a new variable into a configuration file.
 */
ZSCRIPT_CONFIG_ENTRY *zscript_insert_config_variable(ZSCRIPT_CONFIG *the_config, ZSCRIPT_CONFIG_ENTRY *p, const char *name, const char *data)
{
	ZSCRIPT_CONFIG_ENTRY *n = (struct ZSCRIPT_CONFIG_ENTRY*)_AL_MALLOC(sizeof(ZSCRIPT_CONFIG_ENTRY));

	if (!n)
		return NULL;

	if (name)
		n->name = _al_ustrdup(name);
	else
		n->name = NULL;

	if (data)
		n->data = _al_ustrdup(data);
	else
		n->data = NULL;

	if (p) 
	{
		n->next = p->next;
		p->next = n; 
	}
	else 
	{
		n->next = NULL;
		the_config->head = n;
	}

	return n;
}



/* zscript_set_config_string:
 *  Writes a string to the configuration file.
 */
void zscript_set_config_string(const char *section, const char *name, const char *val)
{
	ZSCRIPT_CONFIG *the_config;
	ZSCRIPT_CONFIG_HOOK *hook;
	ZSCRIPT_CONFIG_ENTRY *p, *prev;
	char section_name[256];

	zscript_init_config(TRUE);

	zscript_prettify_config_section_name(section, section_name, sizeof(section_name));

	/* check for hooked sections */
	hook = config_hook;

	while (hook) 
	{
		if (ustricmp(section_name, hook->section) == 0) 
		{
			if (hook->stringsetter)
			hook->stringsetter(name, val);
			return;
		}
		hook = hook->next;
	}

	/* decide which config file to use */
	if ((ugetc(name) == '#') || ((ugetc(section_name) == '[') && (ugetat(section_name, 1) == '#')))
		the_config = system_config;
	else if (config_override)
		the_config = config_override;
	else
		the_config = config[0];

	if (the_config) 
	{
		p = zscript_find_config_string(the_config, section_name, name, &prev);

		if (p) 
		{
			if ((val) && (ugetc(val))) 
			{
				/* modify existing variable */
				if (p->data)
				_AL_FREE(p->data);

				p->data = _al_ustrdup(val);
			}
			else 
			{
				/* delete variable */
				if (p->name)
					_AL_FREE(p->name);
		
				if (p->data)
					_AL_FREE(p->data);

				if (prev)
					prev->next = p->next;
				else
					the_config->head = p->next;

				_AL_FREE(p);
			}
		}
		else 
		{
			if ((val) && (ugetc(val))) 
			{
				/* add a new variable */
				if (ugetc(section_name)) 
				{
					p = zscript_find_config_string(the_config, NULL, section_name, &prev);

					if (!p) 
					{
						/* create a new section */
						p = the_config->head;
						while ((p) && (p->next))
							p = p->next;

						if ((p) && (p->data) && (ugetc(p->data)))
							p = zscript_insert_config_variable(the_config, p, NULL, NULL);

						p = zscript_insert_config_variable(the_config, p, section_name, NULL);
					}

					/* append to the end of the section */
					while ((p) && (p->next) && 
						(((p->next->name) && (ugetc(p->next->name))) || 
						((p->next->data) && (ugetc(p->next->data)))))
					{
						p = p->next;
					}

					p = zscript_insert_config_variable(the_config, p, name, val);
				}
				else 
				{
					/* global variable */
					p = the_config->head;
					zscript_insert_config_variable(the_config, NULL, name, val);
					the_config->head->next = p;
				}
			} 
		}

		the_config->dirty = TRUE;
	}
}



/* zscript_set_config_int:
 *  Writes an integer to the configuration file.
 */
void zscript_set_config_int(const char *section, const char *name, int32_t val)
{
	char buf[32], tmp[32];
	uszprintf(buf, sizeof(buf), uconvert_ascii("%d", tmp), val);
	zscript_set_config_string(section, name, buf);
}



/* zscript_set_config_hex:
 *  Writes a hexadecimal integer to the configuration file.
 */
void zscript_set_config_hex(const char *section, const char *name, int32_t val)
{
	char buf[32], tmp[32];

	if (val >= 0) 
	{
		uszprintf(buf, sizeof(buf), uconvert_ascii("%X", tmp), val);
		zscript_set_config_string(section, name, buf);
	}
	else
		zscript_set_config_string(section, name, uconvert_ascii("-1", buf));
}



/* zscript_set_config_float:
 *  Writes a float to the configuration file.
 */
void zscript_set_config_float(const char *section, const char *name, float val)
{
	char buf[32], tmp[32];
	uszprintf(buf, sizeof(buf), uconvert_ascii("%f", tmp), val);
	zscript_set_config_string(section, name, buf);
}



/* zscript_set_config_id:
 *  Writes a driver ID to the configuration file.
 */
void zscript_set_config_id(const char *section, const char *name, int32_t val)
{
	char buf[32], tmp[32];
	int32_t v[4];
	int32_t pos = 0;
	int32_t i;

	if (val < 256) 
	{
		uszprintf(buf, sizeof(buf), uconvert_ascii("%d", tmp), val);
	}
	else 
	{
		v[0] = (val>>24)&0xFF;
		v[1] = (val>>16)&0xFF;
		v[2] = (val>>8)&0xFF;
		v[3] = val&0xFF;
	
		for (i=0; (i<4) && (v[i]) && (v[i] != ' '); i++)
			pos += usetc(buf+pos, v[i]);

		usetc(buf+pos, 0);
	}

	zscript_set_config_string(section, name, buf);
}



/* _zscript_reload_config:
 *  Internal helper to reload the configuration from allegro_init, in case
 *  zscript_set_config_file was called before allegro_init.
 */
void _zscript_reload_config(void)
{
	if (config[0]) 
	{
		char *name = _al_ustrdup(config[0]->filename);
		zscript_set_config_file(name);
		_AL_FREE(name);
	}
}



/* zscript_reload_config_texts:
 *  Reads in a block of translated system text, looking for either a
 *  user-specified file, a ??text.cfg file, or a language.dat#??TEXT_CFG 
 *  datafile object. If new_language is not NULL, the language config
 *  variable will be set to new_language before reloading the
 *  configuration files.
 */
void zscript_reload_config_texts(const char *new_language)
{
	char filename[1024], tmp1[128], tmp2[128];
	const char *name, *ext, *datafile;
	char *namecpy;

	if (config_language) 
	{
		zscript_destroy_config(config_language);
		config_language = NULL;
	}

	if (new_language)
		zscript_set_config_string("system", "language", new_language);

	name = zscript_get_config_string(uconvert_ascii("system", tmp1), uconvert_ascii("language", tmp2), NULL);

	if ((name) && (ugetc(name))) 
	{
		namecpy = _al_ustrdup(name);
		ustrlwr (namecpy);
		if ((ustrlen(namecpy)<4) || (ustricmp(namecpy+uoffset(namecpy, -4), uconvert_ascii("text", tmp1)) != 0))
			ext = uconvert_ascii("text.cfg", tmp1);
		else
			ext = uconvert_ascii(".cfg", tmp1);

		datafile = uconvert_ascii("language.dat", tmp2);

		if (find_allegro_resource(filename, namecpy, ext, datafile, NULL, NULL, NULL, sizeof(filename)) == 0) 
		{
			_AL_FREE(namecpy);
			zscript_load_config_file(&config_language, filename, NULL);
			return;
		}

		_AL_FREE(namecpy);
	}

	config_language = (struct ZSCRIPT_CONFIG*)_AL_MALLOC(sizeof(ZSCRIPT_CONFIG));
	if (config_language ) 
	{
		config_language ->head = NULL;
		config_language ->filename = NULL;
		config_language ->dirty = FALSE;
	}
}



/* zscript_get_config_text:
 *  Looks up a translated version of the specified English string,
 *  returning a suitable message in the current language if one is
 *  available, or a copy of the parameter if no translation can be found.
 */
const char *zscript_get_config_text(const char *msg)
{
	char tmp1[256];
	const char *section;
	const char *umsg;
	const char *s;
	const char *ret = NULL;
	char *name;
	ZSCRIPT_CONFIG_HOOK *hook;
	ZSCRIPT_CONFIG_ENTRY *p;
	int32_t c, pos, size;
	ASSERT(msg);

	/* Hack: the inline definition of install_allegro() from 4.2.0 calls
	* zscript_get_config_text() even before Allegro has been initialised, leading
	* to a crash in get_executable_name().  To retain binary compatibility
	* we check for this case.
	*/
	if (_allegro_count == 0) 
	{
		return msg;
	}

	zscript_init_config(TRUE);

	section = uconvert_ascii("[language]", tmp1);

	/* allocate memory and convert message to current encoding format */
	if (need_uconvert(msg, U_ASCII, U_CURRENT)) 
	{
		size = uconvert_size(msg, U_ASCII, U_CURRENT);
		umsg = (char*)_AL_MALLOC_ATOMIC(size);
		if (!umsg) 
		{
			*allegro_errno = ENOMEM;
			return empty_string;
		}

		name = (char*)_AL_MALLOC_ATOMIC(size);
		if (!name) 
		{
			_AL_FREE((char *)umsg);  /* remove constness */
			*allegro_errno = ENOMEM;
			return empty_string;
		}

		do_uconvert(msg, U_ASCII, (char*)umsg, U_CURRENT, size);
	}
	else 
	{
		umsg = msg;
		name = (char*)_AL_MALLOC_ATOMIC(ustrsizez(msg));
		if (!name) 
		{
			*allegro_errno = ENOMEM;
			return empty_string;
		}
	}

	s = umsg;
	pos = 0;

	while ((c = ugetxc(&s)) != 0) 
	{
		if ((uisspace(c)) || (c == '=') || (c == '#'))
			pos += usetc(name+pos, '_');
		else
			pos += usetc(name+pos, c);
	}

	usetc(name+pos, 0);

	/* check for hooked sections */
	hook = config_hook;

	while (hook) 
	{
		if (ustricmp(section, hook->section) == 0) 
		{
			if (hook->stringgetter) 
			{
				ret = hook->stringgetter(name, umsg);
				break;
			}
		}

		hook = hook->next;
	}

	if (!ret) 
	{
		/* find the string */
		p = zscript_find_config_string(config_override, section, name, NULL);

		if (!p) 
		{
			p = zscript_find_config_string(config[0], section, name, NULL);

			if (!p)
				p = zscript_find_config_string(config_language, section, name, NULL);
		}

		if (p) 
		{
			ret = (p->data ? p->data : empty_string);
		}
		else 
		{
			/* no translation, so store off this value in the file */
			p = config_language->head;
			zscript_insert_config_variable(config_language, NULL, name, umsg);
			config_language->head->next = p;
			ret = config_language->head->data;
		}
	}

	/* free memory */
	if (umsg!=msg)
		_AL_FREE((char*) umsg);  /* remove constness */

	_AL_FREE(name);

	return ret;
}



/* zscript_add_unique_config_name
 *  Helper to add a name to a list of names.
 */
int32_t zscript_add_unique_config_name(const char ***names, int32_t n, char const *name)
{
	int32_t i;
	/* FIXME: use better search algorithm */
	for (i = 0; i < n; i++)
		if (!ustrcmp((*names)[i], name))
	return n;

	*names = (const char**)_al_sane_realloc((void *)*names, (n + 1) * sizeof **names);
	(*names)[n] = name;
	return n + 1;
}



/* zscript_attach_config_entries
 *  Helper function to attach key or section names to a list of strings.
 */
int32_t zscript_attach_config_entries(ZSCRIPT_CONFIG *conf, const char *section, int32_t n, const char ***names, int32_t list_sections)
{
	ZSCRIPT_CONFIG_ENTRY *p;
	char section_name[256];
	int32_t in_section;

	zscript_prettify_config_section_name(section, section_name, sizeof(section_name));

	if (conf) 
	{
		p = conf->head;
	
		/* If section is NULL, only initial, section-less entries are used. */
		if (ugetc(section_name))
			in_section = FALSE;
		else
			in_section = TRUE;

		while (p) 
		{
			if (p->name) 
			{
				/* a section start is just a list entry enclosed in [] */
				if (ugetc(p->name) == '[' && ugetat(p->name, -1) == ']') 
				{
					if (list_sections) 
					{
						n = zscript_add_unique_config_name(names, n, p->name);
					}
					in_section = (ustricmp(section_name, p->name) == 0);
				}
				else if (in_section && !list_sections) 
				{
					n = zscript_add_unique_config_name(names, n, p->name);
				}
			}
			p = p->next;
		}
	}
	return n;
}



/* list_config_entires:
 *  Returns the names of all config entries in a section. The names parameter is
 *  a pointer to a strings array that will contain the config keys. If it points to
 *  a NULL pointer, it will be allocated, or else re-allocated accordingly. The
 *  return value tells how many valid string pointers it contains after the
 *  function returns.
 */
int32_t zscript_list_config_entries(const char *section, const char ***names)
{
	int32_t n = 0;
	n = zscript_attach_config_entries(config_override, section, n, names, 0);
	n = zscript_attach_config_entries(config[0], section, n, names, 0);
	return n;
}



/* zscript_list_config_sections:
 *  Returns the names of all current config sections, enclodes in []. The names
 *  parameter and return value is like in list_config_entires above.
 */
int32_t zscript_list_config_sections(const char ***names)
{
	int32_t n = 0;
	n = zscript_attach_config_entries(config_override, NULL, n, names, 1);
	n = zscript_attach_config_entries(config[0], NULL, n, names, 1);
	return n;
}



/* zscript_free_config_entries:
 *  Frees the entries list returned by list_config_entires or
 *  zscript_list_config_sections again.
 */
void zscript_free_config_entries(const char ***names)
{
	_AL_FREE(*names);
	*names = NULL;
}

int32_t FFScript::Distance(double x1, double y1, double x2, double y2) 
{
	double x = (x1-x2);
	double y = (y1-y2);
	double sum = (x*x)+(y*y);
	//if(((int32_t)sum) < 0)
	//{
	//	Z_scripterrlog("Distance() attempted to calculate square root of %ld!\n", ((int32_t)sum));
	//	return -10000;;
	//}
	sum *= 1000000.0;
	double total = sqrt(sum)*10;
	return int32_t(total);
}

int32_t FFScript::Distance(double x1, double y1, double x2, double y2, int32_t scale) 
{
	double x3 = x1+(x2-x1)/scale;
	double y3 = y1+(y2-y1)/scale;
	//double sum = (x*x)+(y*y);
	//if(((int32_t)sum) < 0)
	//{
	//	Z_scripterrlog("Distance() attempted to calculate square root of %ld!\n", ((int32_t)sum));
	//	return -10000;
	//}
	//sum *= 1000000.0;
	//double total = sqrt(sum)*10;
	//return int32_t(total*scale);
	return (FFCore.Distance(x1, y1, x3, y3)*scale);
}

int32_t FFScript::LongDistance(double x1, double y1, double x2, double y2) 
{
	double x = (x1-x2);
	double y = (y1-y2);
	double sum = (x*x)+(y*y);
	//if(((int32_t)sum) < 0)
	//{
	//	Z_scripterrlog("Distance() attempted to calculate square root of %ld!\n", ((int32_t)sum));
	//	return -10000;;
	//}
	double total = sqrt(sum);
	return int32_t(total);
}

int32_t FFScript::LongDistance(double x1, double y1, double x2, double y2, int32_t scale) 
{
	double x3 = x1+(x2-x1)/scale;
	double y3 = y1+(y2-y1)/scale;
	//double sum = (x*x)+(y*y);
	//if(((int32_t)sum) < 0)
	//{
	//	Z_scripterrlog("Distance() attempted to calculate square root of %ld!\n", ((int32_t)sum));
	//	return -10000;
	//}
	//sum *= 1000000.0;
	//double total = sqrt(sum)*10;
	//return int32_t(total*scale);
	return (FFCore.LongDistance(x1, y1, x3, y3)*scale);
}

void FFScript::do_distance()
{
	double x1 = double(ri->d[rSFTEMP] / 10000.0);
	double x2 = double(ri->d[rINDEX] / 10000.0);
	double y1 = double(ri->d[rINDEX2] / 10000.0);
	double y2 = double(ri->d[rEXP1] / 10000.0);
	
	int32_t result = FFCore.Distance(x1, x2, y1, y2);
	//ret = result*10000;

}

bool command_is_wait(int command)
{
	switch (command)
	{
	case WAITFRAME:
	case WAITDRAW:
	case WAITTO:
	case WAITEVENT:
	case WAITFRAMESR:
		return true;
	}
	return false;
}

bool command_is_goto(int command)
{
	// GOTOR/return ops left out on purpose.
	switch (command)
	{
	case GOTO:
	case GOTOCMP:
	case GOTOLESS:
	case GOTOMORE:
	case GOTOTRUE:
	case GOTOFALSE:
		return true;
	}
	return false;
}

bool command_uses_comparison_result(int command)
{
	switch (command)
	{
	case GOTOTRUE:
	case GOTOFALSE:
	case GOTOMORE:
	case GOTOLESS:
	case GOTOCMP:
	case SETCMP:
	case SETTRUE:
	case SETTRUEI:
	case SETFALSE:
	case SETFALSEI:
	case SETMOREI:
	case SETLESSI:
	case SETMORE:
	case SETLESS:
	case STACKWRITEATVV_IF:
		return true;
	}
	return false;
}

bool command_writes_comparison_result(int command)
{
	switch (command)
	{
	case SETCMP:
	case SETTRUE:
	case SETTRUEI:
	case SETFALSE:
	case SETFALSEI:
	case SETMOREI:
	case SETLESSI:
	case SETMORE:
	case SETLESS:
		return true;
	}
	return false;
}

int command_to_cmp(int command, int arg)
{
	switch (command)
	{
		case SETCMP:
		case GOTOCMP:
			return arg;
		
		case GOTOTRUE:
			return CMP_EQ;
		case GOTOFALSE:
			return CMP_NE;
		case GOTOMORE:
			return CMP_GE;
		case GOTOLESS:
			return get_qr(qr_GOTOLESSNOTEQUAL) ? CMP_LE : CMP_LT;

		case SETTRUE:
			return CMP_EQ;
		case SETFALSE:
			return CMP_NE;
		case SETMORE:
			return CMP_GE;
		case SETLESS:
			return CMP_LE;
		
		case SETTRUEI:
			return CMP_SETI|CMP_EQ;
		case SETFALSEI:
			return CMP_SETI|CMP_NE;
		case SETMOREI:
			return CMP_SETI|CMP_GE;
		case SETLESSI:
			return CMP_SETI|CMP_LE;
	}

	ASSERT(false);
	return 0;
}

bool command_could_return_not_ok(int command)
{
	switch (command)
	{
	case 0xFFFF:
	case EWPNDEL:
	case GAMECONTINUE:
	case GAMEEND:
	case GAMERELOAD:
	case GAMESAVECONTINUE:
	case GAMESAVEQUIT:
	case ITEMDEL:
	case LWPNDEL:
	case NPCKICKBUCKET:
		return true;
	}
	return false;
}

bool command_is_pure(int command)
{
	switch (command)
	{
		case ABS:
		case ADDR:
		case ADDV:
		case ANDR:
		case ANDR32:
		case ANDV:
		case ANDV32:
		case ARCCOSR:
		case ARCCOSV:
		case ARCSINR:
		case ARCSINV:
		case BITNOT:
		case BITNOT32:
		case CASTBOOLF:
		case CEILING:
		case COMPAREV2:
		case COSR:
		case COSV:
		case DIVV2:
		case FACTORIAL:
		case FLOOR:
		case IPOWERR:
		case IPOWERV:
		case ISALLOCATEDBITMAP:
		case LOAD:
		case LOADD:
		case LOADI:
		case LOG10:
		case LOGE:
		case LSHIFTR:
		case LSHIFTR32:
		case LSHIFTV:
		case LSHIFTV32:
		case MAXR:
		case MAXV:
		case MAXVARG:
		case MINR:
		case MINV:
		case MINVARG:
		case MODR:
		case MODV:
		case MODV2:
		case NANDR:
		case NANDV:
		case NORR:
		case NORV:
		case NOT:
		case ORR:
		case ORR32:
		case ORV:
		case ORV32:
		case PEEK:
		case PEEKATV:
		case POWERR:
		case POWERV:
		case ROUND:
		case ROUNDAWAY:
		case RSHIFTR:
		case RSHIFTR32:
		case RSHIFTV:
		case RSHIFTV32:
		case SETCMP:
		case SETFALSE:
		case SETFALSEI:
		case SETLESS:
		case SETLESSI:
		case SETMORE:
		case SETMOREI:
		case SETR:
		case SETTRUE:
		case SETTRUEI:
		case SETV:
		case SINR:
		case SINV:
		case SUBR:
		case SUBV:
		case SUBV2:
		case TANR:
		case TANV:
		case TOBYTE:
		case TOINTEGER:
		case TOSHORT:
		case TOSIGNEDBYTE:
		case TOWORD:
		case TRUNCATE:
		case XNORR:
		case XNORV:
		case XORR:
		case XORR32:
		case XORV:
		case XORV32:
			return true;
	}

	return false;
}

int32_t get_combopos_ref(int32_t pos, int32_t layer)
{
	return layer * 176 + pos;
}

int32_t combopos_ref_to_pos(int32_t combopos_ref)
{
	return combopos_ref % 176;
}

int32_t combopos_ref_to_layer(int32_t combopos_ref)
{
	return combopos_ref / 176;
}

