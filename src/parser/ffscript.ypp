/* -*- mode: bison; tab-width: 4 -*-
 * Parser for the scripting language compiler. Intended for use with Flex
 * and Bison. Use this file to generate y.tab.cpp:
 * $ bison -b y -v -d ffscript.ypp
 */

/* declarations */
%{
#include "parserDefs.h"
#include <stdlib.h>
#include <stdio.h>
#include <cassert>
#include <string>
#include <set>
#include <sstream>
#include "ASTVisitors.h"
#include "CompileOption.h"
#include "zsyssimple.h"
#include "parser/ParserHelper.h"
#include "base/util.h"

using std::string;
using std::ostringstream;
using namespace ZScript;

#define YYINCLUDED_STDLIB_H
extern int32_t yydebug;
extern int32_t yyrow;
extern int32_t yycol;
extern char* yytext;
extern int32_t yyleng;
extern int32_t yylex(void);
extern FILE *yyin, *yyout;
extern ZScript::AST* first_identifier_for_line;
extern void resetLexer();
void yyerror(std::unique_ptr<ASTFile>& root, const char* s);
void yymsg(string const& message, int32_t row = yyrow, int32_t col = yycol, char const* txt = yytext);
void yywarn(string const& message, int32_t row = yyrow, int32_t col = yycol, char const* txt = yytext);
void yyerrmsg(string const& message, int32_t row = yyrow, int32_t col = yycol, char const* txt = yytext);
void yydb(string const& message, int32_t row = yyrow, int32_t col = yycol, char const* txt = yytext);
std::string curfilename;
extern YYLTYPE noloc;

#define push_front(v, elem) (v).insert((v).begin(), elem)
void trunc_str(std::string& str, size_t sz, std::string const& header, int32_t row = yyrow,
	int32_t col = yycol, char const* txt = yytext)
{
	if(str.size() > sz)
	{
		yyerrmsg("ERROR: "+header+": String value '" + str + "' is too long. Max '"+std::to_string(sz)+"' characters.", row, col, txt);
		str = str.substr(0,sz);
	}
}

enum
{
	ANNTY_NONE,
	ANNTY_STR,
	ANNTY_INT,
	ANNTY_MAX
};
static string annot_tys[ANNTY_MAX] = {"Empty", "String", "Number"};

int annot_row, annot_col;
string annot_err_txt;
static const string annot_err_header = "ERROR: Bad Annotation Value";
struct AnnotData
{
	string key, strval;
	string val, unescaped_val;
	zfix intval;
	uint type;
};
void annot_errstr(string const& str)
{
	yyerrmsg(str, annot_row, annot_col, annot_err_txt.c_str());
}
void annot_trunc_str(string& str, size_t size)
{
	trunc_str(str, size, annot_err_header, annot_row, annot_col, annot_err_txt.c_str());
}
bool annot_type_check(uint expected, AnnotData const& data)
{
	if(expected == data.type)
		return true;
	annot_errstr("ERROR: Bad Annotation Value: @"+data.key
		+" expects a "+annot_tys[expected]+", not a "+annot_tys[data.type]);
	return false;
}
void annot_incompatible(string const& key1, string const& key2)
{
	annot_errstr(fmt::format("ERROR: Annotation '@{}' not compatible with '@{}'", key1, key2));
}
void handle_annotations(ASTAnnotationList* list, std::function<bool(AnnotData&)> fn)
{
	owning_vector<ASTAnnotation>& set = list->set;
	annot_row = list->location.first_line;
	annot_col = list->location.first_column;
	std::set<std::string> used_keys;
	for(size_t q = 0; q < set.size(); ++q)
	{
		ASTAnnotation* a = set[q];
		AnnotData data = AnnotData();
		data.key = a->key->getValue();
		data.type = ANNTY_NONE;
		data.strval = "";
		data.intval = 0;
		if(a->strval)
		{
			data.type = ANNTY_STR;
			data.strval = a->strval->getValue();
		}
		else if(a->intval)
		{
			data.type = ANNTY_INT;
			data.intval = zslongToFix(a->intval->getValue(nullptr));
		}
		
		data.val = "";
		data.unescaped_val = "";
		switch(data.type)
		{
			case ANNTY_STR:
				data.val = data.strval;
				data.unescaped_val = util::disallow_escapes(util::escape_characters(data.strval));
				break;
			case ANNTY_INT:
				data.val = data.unescaped_val = data.intval.str();
				break;
		}
		annot_err_txt = "@" + data.key + "(" + data.val + ")";
		
		if(used_keys.contains(data.key))
		{
			annot_errstr("ERROR: Duplicate Annotation Key: @"+data.key+" was already set.");
			continue;
		}
		if(!fn(data))
			annot_errstr("ERROR: Bad Annotation Key: '"+data.val+"'");
	}
	delete list;
}

ASTExpr* handle_statement_expr(ASTExpr* expr)
{
	if(ASTExprIncrement* increm = dynamic_cast<ASTExprIncrement*>(expr))
	{
		increm->is_pre = true;
	}
	else if(ASTExprDecrement* decrem = dynamic_cast<ASTExprDecrement*>(expr))
	{
		decrem->is_pre = true;
	}
	return expr;
}

#pragma warning( disable : 4065 )
%}

%code requires {
	namespace ZScript
	{
		class ASTFile;
		std::unique_ptr<ZScript::ASTFile> parseFile(std::string const& filename);
	};
}

%glr-parser
%expect 6
%define parse.error verbose
%start Init
%parse-param {std::unique_ptr<ZScript::ASTFile>& root}

%define api.token.prefix {TOK_}

 // Keywords
%token SCRIPT
%token ZCLASS
%token FOR
%token LOOP
%token IF
%token ELSE
%token SWITCH
%token CASE
%token DEFAULT
%token RETURN
%token IMPORT
%token ZTRUE
%token ZFALSE
%token WHILE
%token BREAK
%token CONTINUE
%token ZCONST
%token DO
%token TYPEDEF
%token EXPECTERROR
%token OPTIONVALUE
%token ISINCLUDED
%token DEFINE
%token ENUM
%token NAMESPACE
%token USING
%token ALWAYS
%token ZASM
%token INCLUDE
%token INCLUDEPATH
%token INCLUDEIF
%token UNTIL
%token UNLESS
%token REPEAT
%token INLINE
%token INTERNAL
%token STATIC
%token CONSTEXPR
%left NEW
%left DELETE
%token CASSERT

 // Types
%token ZAUTO
%token ZVOID
%token UNTYPED
%token ZBOOL
%token ZFLOAT
%token ZCHAR
%token ZLONG
%token ZRGB

 // Syntax
%token COMMA
%token DOT
%token SEMICOLON
%token SCOPERES
%token COLON
%token IN
%token LPAREN
%token RPAREN
%token EMPTYBRACKETS
%token LBRACKET
%token RBRACKET
%token LBRACE
%token RBRACE
%token QMARK

 // Operators
%token ARROW
%left INCREMENT DECREMENT
%left NOT BITNOT
%left EXPN
%left TIMES DIVIDE MODULO
%left PLUS MINUS
%left LSHIFT RSHIFT
%left LE LT GE GT EQ NE
%left BITAND BITXOR BITOR
%left AND OR XOR
%token ASSIGN
%token PLUSASSIGN
%token MINUSASSIGN
%token TIMESASSIGN
%token DIVIDEASSIGN
%token MODULOASSIGN
%token LSHIFTASSIGN
%token RSHIFTASSIGN
%token BITANDASSIGN
%token BITXORASSIGN
%token BITORASSIGN
%token ANDASSIGN
%token ORASSIGN
%token CAST
%token RANGE
%token RANGE_L
%token RANGE_R
%token RANGE_LR
%token RANGE_N
%token APPXEQUAL
%token DOUBLEBANG
%token PERCENT
%token BITNOTASSIGN
%token INVMOD
%token DOUBLEADDR
%token DOUBLESTAR
%token HANDLE
%token HANDLETOHANDLE
%token ADDR

 // Hash Only
%token HASH
%token ENDLINE
%token OPTION
%token INHERIT

 // Others
%token IDENTIFIER
%token QUOTEDSTRING
%token CASESTRING
%token IMPORTSTRING
%token SINGLECHAR
%token NUMBER
%token LONGNUMBER

 // Precedence setting
%precedence RPAREN
%precedence ELSE

%%

////////////////////////////////////////////////////////////////

Init : Global_List {$$ = $1;};

////////////////////////////////////////////////////////////////
// Global

Global_List :
	Global_List Global_Statement {
		ASTDecl* declaration = (ASTDecl*)$2;
		root->addDeclaration(declaration);}
	| Global_List Option {
		ASTSetOption* option = (ASTSetOption*)$2;
		root->options.push_back(option);
		if (root->hasDeclarations())
			yywarn("WARNING: Options should come before everything else.");}
	| %empty {root.reset(new ASTFile(noloc));}
	;

Global_Statement :
	Import {$$ = $1;}
	| IncludePath {$$ = $1;}
	| Namespace {$$ = $1;}
	| DataTypeDef SEMICOLON {$$ = $1;}
	| ScriptTypeDef SEMICOLON {$$ = $1;}
	| Data SEMICOLON {$$ = $1;}
	| Function {$$ = $1;}
	| Script {$$ = $1;}
	| Annotated_Script {$$ = $1;}
	| Class {$$ = $1;}
	| Annotated_Enum SEMICOLON {$$ = $1;}
	| Using SEMICOLON {$$ = $1;}
	| AlwaysUsing SEMICOLON {$$ = $1;}
	| Statement_Assert SEMICOLON {$$ = $1;}
	| EXPECTERROR LPAREN Expression_Constant RPAREN Global_Statement {
		ASTExprConst* errorId = (ASTExprConst*)$3;
		ASTDecl* declaration = (ASTDecl*)$5;
		declaration->compileErrorCatches.push_back(errorId);
		$$ = declaration;}
	;

Trail_Comma_RBrace:
	COMMA RBRACE {$$ = $1;}
	| RBRACE {$$ = $1;}

////////////////////////////////////////////////////////////////
// Namespace Declaration

Namespace :
	NAMESPACE Scoperes_Identifier_List LBRACE RBRACE {
		ASTExprIdentifier* idens = (ASTExprIdentifier*)$2;
		ASTNamespace* namesp = new ASTNamespace(@$);
		namesp->identifier = idens->componentNodes.front()->clone();
		if (!ParserHelper::isValidIdentifier(namesp->getName()))
			yyerrmsg("ERROR: invalid identifier",idens->location.first_line,idens->location.first_column,namesp->getName().c_str());
		auto& components = idens->componentNodes;
		if(components.size() > 1)
			for(auto it = components.begin() + 1;
				it != components.end(); ++it)
			{
				ASTNamespace* subsp = new ASTNamespace(@$);
				subsp->identifier = (*it)->clone();
				if (!ParserHelper::isValidIdentifier(subsp->getName()))
					yyerrmsg("ERROR: invalid identifier",idens->location.first_line,idens->location.first_column,subsp->getName().c_str());
				namesp->namespaces.push_back(subsp);
			}
		delete idens;
		$$ = namesp;
	}
	| NAMESPACE Scoperes_Identifier_List LBRACE Namespace_Block_List RBRACE {
		ASTExprIdentifier* idens = (ASTExprIdentifier*)$2;
		auto& components = idens->componentNodes;
		int32_t size = components.size();
		if(size == 1)
		{
			ASTNamespace* namesp = (ASTNamespace*)$4;
			namesp->identifier = components.front()->clone();
			namesp->location = @$;
			delete idens;
			$$ = namesp;
		}
		else if(size == 2)
		{
			ASTNamespace* top = new ASTNamespace(@$);
			top->identifier = components.front()->clone();
			ASTNamespace* namesp = (ASTNamespace*)$4;
			namesp->identifier = components[1]->clone();
			namesp->location = @$;
			top->namespaces.push_back(namesp);
			delete idens;
			$$ = top;
		}
		else
		{
			ASTNamespace* top = new ASTNamespace(@$);
			top->identifier = components.front()->clone();
			ASTNamespace* temp = top;
			ASTNamespace* temp2;
			ASTNamespace* namesp = (ASTNamespace*)$4;
			namesp->identifier = components.back()->clone();
			components.pop_back();
			namesp->location = @$;
			for(auto it = components.begin() + 1;
				it != components.end(); ++it)
			{
				temp2 = new ASTNamespace(@$);
				temp->identifier = (*it)->clone();
				temp->namespaces.push_back(temp2);
				temp = temp2;
			}
			temp->namespaces.push_back(namesp);
			delete idens;
			$$ = top;
		}

		auto ns = (ASTNamespace*)$$;
		if (!ParserHelper::isValidIdentifier(ns->getName()))
			yyerrmsg("ERROR: invalid identifier",idens->location.first_line,idens->location.first_column,ns->getName().c_str());
	}
	;

Namespace_Block_List :
	Namespace_Block_List Namespace_Statement {
		ASTNamespace* namesp = (ASTNamespace*)$1;
		ASTDecl* declaration = (ASTDecl*)$2;
		namesp->addDeclaration(*declaration);
		namesp->location = @$;
		$$ = namesp;}
	| Namespace_Block_List Option {
		ASTNamespace* namesp = (ASTNamespace*)$1;
		ASTSetOption* option = (ASTSetOption*)$2;
		namesp->options.push_back(option);
		namesp->location = @$;
		$$ = namesp;
		if (!namesp->variables.empty()
		    || !namesp->functions.empty()
		    || !namesp->dataTypes.empty()
		    || !namesp->scriptTypes.empty()) {
			yywarn("WARNING: Options should come before everything else.");}}
	| Namespace_Statement {
		ASTNamespace* namesp = new ASTNamespace(@$);
		ASTDecl* declaration = (ASTDecl*)$1;
		namesp->addDeclaration(*declaration);
		$$ = namesp;}
	| Option {
		ASTNamespace* namesp = new ASTNamespace(@$);
		ASTSetOption* option = (ASTSetOption*)$1;
		namesp->options.push_back(option);
		$$ = namesp;}
	;

Namespace_Statement :
	Namespace {$$ = $1;}
	| DataTypeDef SEMICOLON {$$ = $1;}
	| ScriptTypeDef SEMICOLON {$$ = $1;}
	| Data SEMICOLON {$$ = $1;}
	| Function {$$ = $1;}
	| Script {$$ = $1;}
	| Annotated_Script {$$ = $1;}
	| Class {$$ = $1;}
	| Annotated_Enum SEMICOLON {$$ = $1;}
	| Using SEMICOLON {$$ = $1;}
	| Statement_Assert SEMICOLON {$$ = $1;}
	| EXPECTERROR LPAREN Expression_Constant RPAREN Namespace_Statement {
		ASTExprConst* errorId = (ASTExprConst*)$3;
		ASTDecl* declaration = (ASTDecl*)$5;
		declaration->compileErrorCatches.push_back(errorId);
		$$ = declaration;}
	;

// Using

Using :
	USING NAMESPACE Scoperes_Identifier_List {
		ASTExprIdentifier* idlist = (ASTExprIdentifier*)$3;
		$$ = new ASTUsingDecl(idlist, @$);
	};

AlwaysUsing :
	ALWAYS USING NAMESPACE Scoperes_Identifier_List {
		ASTExprIdentifier* idlist = (ASTExprIdentifier*)$4;
		$$ = new ASTUsingDecl(idlist, @$, true);
	};

////////////////////////////////////////////////////////////////
// Import Declaration

Import :
	IMPORT IMPORTSTRING {
		ASTString* str = (ASTString*)$2;
		$$ = new ASTImportDecl(str, @$);
		}
	| HASH INCLUDE IMPORTSTRING {
		ASTString* str = (ASTString*)$3;
		$$ = new ASTImportDecl(str, @$, true);
		}
	| HASH INCLUDEIF LPAREN Expression_Constant COMMA IMPORTSTRING RPAREN {
		ASTString* str = (ASTString*)$6;
		ASTExprConst* cond = (ASTExprConst*)$4;
		ASTImportDecl* decl = new ASTImportDecl(str, @$, true);
		$$ = new ASTImportCondDecl(cond, decl, @$);
		}
	;

IncludePath :
	HASH INCLUDEPATH IMPORTSTRING {
		ASTString* str = (ASTString*)$3;
		$$ = new ASTIncludePath(str->getValue(), @$);
		delete str;}
	;

////////////////////////////////////////////////////////////////
// Compile Option

Option :
	HASH OPTION IDENTIFIER Expression_Constant ENDLINE {
		ASTString* name = (ASTString*)$3;
		ASTExprConst* expr = (ASTExprConst*)$4;
		$$ = new ASTSetOption(name->getValue(), expr, @$);
		delete name;}
	|
	HASH OPTION IDENTIFIER INHERIT ENDLINE {
		ASTString* name = (ASTString*)$3;
		$$ = new ASTSetOption(
				name->getValue(), CompileOptionSetting::Inherit, @$);
		delete name;}
	| HASH OPTION IDENTIFIER DEFAULT ENDLINE {
		ASTString* name = (ASTString*)$3;
		$$ = new ASTSetOption(
				name->getValue(), CompileOptionSetting::Default, @$);
		delete name;}
	| HASH OPTION DEFAULT Expression_Constant ENDLINE {
		ASTExprConst* expr = (ASTExprConst*)$4;
		$$ = new ASTSetOption("default", expr, @$);}
	| HASH OPTION DEFAULT INHERIT ENDLINE {
		$$ = new ASTSetOption(
				"default", CompileOptionSetting::Inherit, @$);}
	| HASH OPTION DEFAULT DEFAULT ENDLINE {
		$$ = new ASTSetOption(
				"default", CompileOptionSetting::Default, @$);}
	;

////////////////////////////////////////////////////////////////
// Assertion

Statement_Assert :
	CASSERT LPAREN Expression_Constant RPAREN {
		$$ = new ASTAssert((ASTExprConst*)$3, NULL, @$);
	}
	| CASSERT LPAREN Expression_Constant COMMA QuotedString RPAREN {
		$$ = new ASTAssert((ASTExprConst*)$3, (ASTString*)$5, @$);
	}
	;

////////////////////////////////////////////////////////////////
// Type Declaration

DataTypeDef : StandardDataTypedef {$$ = $1;}
	;

StandardDataTypedef : TYPEDEF DataType IDENTIFIER {
	ASTDataType* type = (ASTDataType*)$2;
	ASTString* name = (ASTString*)$3;
	$$ = new ASTDataTypeDef(type, name->getValue(), @1);
	delete name;}
	;

DataType :
	DataType EMPTYBRACKETS {
		ASTDataType* dtype = (ASTDataType*)$1;
		++dtype->becomeArray;
		$$ = dtype;
	}
	| DataType_Mods {$$ = $1;}
	;

DataType_Mods : 
	ZCONST DataType_Base {
		ASTDataType* dtype = (ASTDataType*)$2;
		++dtype->constant_; //Increment the number of `const` keywords. If >1, this will produce an error later.
		$$ = dtype;
	}
	| DataType_Base {$$ = $1;}
	;

DataType_Base :
	//Standard types
	ZAUTO {$$ = new ASTDataType(DataType::ZAUTO, @$);}
	| ZVOID {$$ = new ASTDataType(DataType::ZVOID, @$);}
	| UNTYPED {$$ = new ASTDataType(DataType::UNTYPED, @$);}
	| ZBOOL {$$ = new ASTDataType(DataType::BOOL, @$);}
	| ZFLOAT {$$ = new ASTDataType(DataType::FLOAT, @$);}
	| ZCHAR {$$ = new ASTDataType(DataType::CHAR, @$);}
	| ZLONG {$$ = new ASTDataType(DataType::LONG, @$);}
	| ZRGB {$$ = new ASTDataType(DataType::RGBDATA, @$);}
	//Typedef types
	| Identifier_List {
			ASTExprIdentifier* iden = (ASTExprIdentifier*)$1;
			std::string comment = std::move(iden->doc_comment);
			ASTDataType* datatype = new ASTDataType(new DataTypeUnresolved(iden), @$);
			datatype->doc_comment = std::move(comment);
			$$ = datatype;
			}
	;

ScriptTypeDef : SCRIPT TYPEDEF Script_Type IDENTIFIER {
	ASTScriptType* oldType = static_cast<ASTScriptType*>($3);
	ASTString* newName = static_cast<ASTString*>($4);
	$$ = new ASTScriptTypeDef(oldType, newName->getValue(), @$);
	delete newName;}
	;

////////////////////////////////////////////////////////////////
// Data Declaration

Data : 
	INTERNAL Data {
		ASTDataDeclList* list = (ASTDataDeclList*)$2;
		if (list->internal)
			yyerrmsg("internal modifier used twice");
		list->internal = true;
		$$ = list;}
	| DataType Data_List {
		ASTDataType* type = (ASTDataType*)$1;
		ASTDataDeclList* list = (ASTDataDeclList*)$2;
		list->baseType = type;
		if (!type->doc_comment.empty())
			list->doc_comment = std::move(type->doc_comment);
		list->location = @$;
		$$ = list;}
	;

Data_List :
	Data_List COMMA Data_Element {
			ASTDataDeclList* list = (ASTDataDeclList*)$1;
			ASTDataDecl* element = (ASTDataDecl*)$3;
			list->addDeclaration(element);
			list->location = @$;
			$$ = list;}
	| Data_Element {
			ASTDataDecl* element = (ASTDataDecl*)$1;
			ASTDataDeclList* list = new ASTDataDeclList(@$);
			list->addDeclaration(element);
			if (!element->doc_comment.empty())
				list->doc_comment = std::move(element->doc_comment);
			$$ = list;}
	;

Data_Element :
	Data_Element_Array_List ASSIGN Expression {
			ASTDataDecl* element = (ASTDataDecl*)$1;
			ASTExpr* initializer = (ASTExpr*)$3;
			element->setInitializer(initializer);
			element->location = @$;
			$$ = element;}
	| Data_Element_Array_List {$$ = $1;}
	;

Data_Element_Array_List :
	Data_Element_Array_List Data_Element_Array_Element {
			ASTDataDecl* element = (ASTDataDecl*)$1;
			ASTDataDeclExtraArray* extraArray = (ASTDataDeclExtraArray*)$2;
			element->extraArrays.push_back(extraArray);
			element->location = @$;
			$$ = element;}
	| Identifier {
			ASTString* name = (ASTString*)$1;
			ASTDataDecl* element = new ASTDataDecl(@$);
			element->identifier = name;
			if (!ParserHelper::isValidIdentifier(name->getValue()))
				yyerrmsg("ERROR: invalid identifier",name->location.first_line,name->location.first_column,name->getValue().c_str());
			element->doc_comment = std::move(name->doc_comment);
			if (!first_identifier_for_line) first_identifier_for_line = element;
			$$ = element;
		}
	;

Single_Data_req_assign :
	DataType Identifier ASSIGN Expression {
		ASTDataType* type = (ASTDataType*)$1;
		ASTString* name = (ASTString*)$2;
		ASTDataDecl* element = new ASTDataDecl(@$);
		element->identifier = name;
		ASTExpr* initializer = (ASTExpr*)$4;
		element->setInitializer(initializer);
		element->baseType = type;
		element->location = @$;
		$$ = element;}
	;

Data_Element_Array_Element :
	LBRACKET Data_Element_Array_Element_Size_List RBRACKET {
		ASTDataDeclExtraArray* extraArray = (ASTDataDeclExtraArray*)$2;
		extraArray->location = @$;
		$$ = extraArray;}
	| EMPTYBRACKETS {$$ = new ASTDataDeclExtraArray(@$);}
	;

Data_Element_Array_Element_Size_List :
	Data_Element_Array_Element_Size_List COMMA Expression_Constant {
		ASTDataDeclExtraArray* extraArray = (ASTDataDeclExtraArray*)$1;
		ASTExpr* size = (ASTExpr*)$3;
		extraArray->dimensions.push_back(size);
		extraArray->location = @$;
		$$ = extraArray;}
	| Expression_Constant {
		ASTExpr* size = (ASTExpr*)$1;
		ASTDataDeclExtraArray* extraArray = new ASTDataDeclExtraArray(@$);
		extraArray->dimensions.push_back(size);
		$$ = extraArray;}
	;

////////////////////////////////////////////////////////////////
// Function Declaration

Function :
	CONSTEXPR Function
	{
		ASTFuncDecl* func = (ASTFuncDecl*)$2;
		if(func->getFlag(FUNCFLAG_CONSTEXPR))
		{
			func->setFlag(FUNCFLAG_INVALID);
			func->invalidMsg += " Duplicate `constexpr`.";
		}
		func->setFlag(FUNCFLAG_CONSTEXPR);
		$$ = func;
	}
	| STATIC Function
	{
		ASTFuncDecl* func = (ASTFuncDecl*)$2;
		if(func->getFlag(FUNCFLAG_STATIC))
		{
			func->setFlag(FUNCFLAG_INVALID);
			func->invalidMsg += " Duplicate `static`.";
		}
		else if(func->getFlag(FUNCFLAG_DESTRUCTOR|FUNCFLAG_CONSTRUCTOR))
		{
			func->setFlag(FUNCFLAG_INVALID);
			func->invalidMsg += " Constructors and destructors cannot be static.";
		}
		else func->setFlag(FUNCFLAG_STATIC);
		$$ = func;
	}
	| INLINE Function
	{
		ASTFuncDecl* func = (ASTFuncDecl*)$2;
		if(func->getFlag(FUNCFLAG_INLINE))
		{
			func->setFlag(FUNCFLAG_INVALID);
			func->invalidMsg += " Duplicate `inline`.";
		}
		else func->setFlag(FUNCFLAG_INLINE);
		$$ = func;
	}
	| INTERNAL Function
	{
		ASTFuncDecl* func = (ASTFuncDecl*)$2;
		if(func->getFlag(FUNCFLAG_INTERNAL))
		{
			func->setFlag(FUNCFLAG_INVALID);
			func->invalidMsg += " Duplicate `internal`.";
		}
		if(func->block)
		{
			func->setFlag(FUNCFLAG_INVALID);
			func->invalidMsg += " Internal function must not have a body.";
		}
		func->setFlag(FUNCFLAG_INTERNAL);
		func->prototype = false;
		$$ = func;
	}
	| DataType Function_Typeless {
		ASTDataType* returnType = (ASTDataType*)$1;
		ASTFuncDecl* func = (ASTFuncDecl*)$2;
		if (!returnType->doc_comment.empty())
			func->doc_comment = std::move(returnType->doc_comment);
		func->returnType = returnType;
		$$ = func;}
	;

Function_Typeless :
	Function_Heading Statement_Block
	{
		ASTFuncDecl* func = (ASTFuncDecl*)$1;
		func->block = (ASTBlock*)$2;
		$$ = func;}
	| Function_Heading SEMICOLON {
		ASTFuncDecl* func = (ASTFuncDecl*)$1;
		func->prototype = true;
		func->defaultReturn = new ASTExprConst(new ASTExprCast(new ASTDataType(DataType::CUNTYPED, @$), new ASTNumberLiteral(new ASTFloat(0, 0, @$), @$), @$), @$);
		$$ = func;}
	| Function_Heading COLON DEFAULT Expression_Constant SEMICOLON {
		ASTFuncDecl* func = (ASTFuncDecl*)$1;
		func->prototype = true;
		func->defaultReturn = (ASTExprConst*)$4;
		$$ = func;}
	;
Function_Heading :
	Identifier_List LPAREN Function_Parameters_List RPAREN
	{
		ASTExprIdentifier* iden = (ASTExprIdentifier*)$1;
		ASTFuncDecl* func = (ASTFuncDecl*)$3;
		func->identifier = iden;
		func->location = @$;
		func->doc_comment = std::move(iden->doc_comment);
		$$ = func;}
	| Identifier_List LT FunctionTemplateList GT LPAREN Function_Parameters_List RPAREN
	{
		ASTExprIdentifier* iden = (ASTExprIdentifier*)$1;
		ASTStringList* template_list = (ASTStringList*)$3;
		ASTFuncDecl* func = (ASTFuncDecl*)$6;
		func->identifier = iden;
		func->templates.swap(template_list->strings);
		delete template_list;
		func->location = @$;
		func->doc_comment = std::move(iden->doc_comment);
		$$ = func;}
	;

FunctionTemplateList :
	Identifier {
		ASTStringList* list = new ASTStringList(@$);
		ASTString* templ = (ASTString*)$1;
		list->strings.push_back(templ);
		$$ = list;}
	| FunctionTemplateList COMMA Identifier {
		ASTStringList* list = (ASTStringList*)$1;
		ASTString* templ = (ASTString*)$3;
		list->location = @$;
		list->strings.push_back(templ);
		$$ = list;}

Function_Parameters_List :
	Function_Parameters_Element COMMA Function_Parameters_List {
			ASTDataDecl* param = (ASTDataDecl*)$1;
			ASTFuncDecl* func = (ASTFuncDecl*)$3;
			push_front(func->parameters, param);
			func->location = @$;
			$$ = func;}
	| Function_Parameters_Element {
			ASTDataDecl* param = (ASTDataDecl*)$1;
			ASTFuncDecl* func = new ASTFuncDecl(@$);
			push_front(func->parameters, param);
			$$ = func;}
	| Function_OptParams_List {$$ = $1;}
	| Function_VarArg_Element {$$ = $1;}
	| %empty {$$ = new ASTFuncDecl(@$);}
	;

Function_Parameters_Element :
	DataType Identifier {
		ASTDataType* type = (ASTDataType*)$1;
		ASTString* name = (ASTString*)$2;
		ASTDataDecl* element = new ASTDataDecl(@$);
		element->identifier = name;
		element->baseType = type;
		$$ = element;}
	;

Function_OptParams_List :
	Function_Parameters_Element ASSIGN Expression_Constant COMMA Function_OptParams_List {
			ASTFuncDecl* func = (ASTFuncDecl*)$5;
			ASTDataDecl* param = (ASTDataDecl*)$1;
			ASTExprConst* cval = (ASTExprConst*)$3;
			push_front(func->parameters, param);
			push_front(func->optparams, cval);
			func->location = @$;
			$$ = func;}
	| Function_Parameters_Element ASSIGN Expression_Constant {
			ASTDataDecl* param = (ASTDataDecl*)$1;
			ASTExprConst* cval = (ASTExprConst*)$3;
			ASTFuncDecl* func = new ASTFuncDecl(@$);
			push_front(func->parameters, param);
			push_front(func->optparams, cval);
			$$ = func;}
	;

Function_VarArg_Element :
	RANGE Function_Parameters_Element {
		ASTFuncDecl* func = new ASTFuncDecl(@$);
		push_front(func->parameters, (ASTDataDecl*)$2);
		func->setFlag(FUNCFLAG_VARARGS);
		$$ = func;}

////////////////////////////////////////////////////////////////
// Class Declaration
Class_Ident :
	IDENTIFIER {$$ = $1;};

Class :
	ZCLASS Class_Ident Class_Block {
		ASTString* name = (ASTString*)$2;
		ASTClass* user_class = (ASTClass*)$3;
		user_class->location = name->location;
		user_class->identifier = name;
		user_class->doc_comment = std::move(name->doc_comment);
		if (!first_identifier_for_line) first_identifier_for_line = user_class;
		$$ = user_class;}
	;

Class_Block :
	LBRACE Class_Block_List RBRACE {$$ = $2;}
	| LBRACE RBRACE {$$ = new ASTClass(@$);}
	;

Class_Block_List :
	Class_Block_List Class_Block_Element {
		ASTClass* user_class = (ASTClass*)$1;
		ASTDecl* declaration = (ASTDecl*)$2;
		user_class->addDeclaration(*declaration);
		user_class->location = @$;
		$$ = user_class;}
	| Class_Block_List Option {
		ASTClass* user_class = (ASTClass*)$1;
		ASTSetOption* option = (ASTSetOption*)$2;
		user_class->options.push_back(option);
		user_class->location = @$;
		$$ = user_class;
		if (!user_class->variables.empty()
		    || !user_class->functions.empty()
		    || !user_class->types.empty()) {
			yywarn("WARNING: Options should come before everything else.");}}
	| Class_Block_List Class_Constructor {
		ASTClass* user_class = (ASTClass*)$1;
		ASTFuncDecl* func = (ASTFuncDecl*)$2;
		user_class->constructors.push_back(func);
		$$ = user_class;}
	| Class_Block_List Class_Destructor {
		ASTClass* user_class = (ASTClass*)$1;
		ASTFuncDecl* func = (ASTFuncDecl*)$2;
		if(user_class->destructor)
		{
			auto const& loc = func->location;
			yyerrmsg("ERROR: Class can only have one destructor!",loc.first_line,loc.first_column,func->getName().c_str());
			delete func;
		}
		else user_class->destructor = func;
		$$ = user_class;}
	| Class_Block_Element {
		ASTClass* user_class = new ASTClass(@$);
		ASTDecl* declaration = (ASTDecl*)$1;
		user_class->addDeclaration(*declaration);
		$$ = user_class;}
	| Option {
		ASTClass* user_class = new ASTClass(@$);
		ASTSetOption* option = (ASTSetOption*)$1;
		user_class->options.push_back(option);
		$$ = user_class;}
	| Class_Constructor {
		ASTClass* user_class = new ASTClass(@$);
		ASTFuncDecl* func = (ASTFuncDecl*)$1;
		user_class->constructors.push_back(func);
		$$ = user_class;}
	| Class_Destructor {
		ASTClass* user_class = new ASTClass(@$);
		ASTFuncDecl* func = (ASTFuncDecl*)$1;
		if(user_class->destructor)
		{
			auto const& loc = func->location;
			yyerrmsg("ERROR: Class can only have one destructor!",loc.first_line,loc.first_column,func->getName().c_str());
			delete func;
		}
		else user_class->destructor = func;
		$$ = user_class;}
	;

Class_Constructor :
	INTERNAL Class_Constructor {
		ASTFuncDecl* func = (ASTFuncDecl*)$2;
		if(func->getFlag(FUNCFLAG_INTERNAL))
		{
			func->setFlag(FUNCFLAG_INVALID);
			func->invalidMsg += " Duplicate `internal`.";
		}
		else func->setFlag(FUNCFLAG_INTERNAL);
		func->prototype = false;
		$$ = func;}
	| Function_Typeless {
		ASTFuncDecl* func = (ASTFuncDecl*)$1;
		ASTDataType* returnType = new ASTDataType(DataType::ZVOID, @$);
		func->returnType = returnType;
		func->setFlag(FUNCFLAG_CONSTRUCTOR|FUNCFLAG_CLASSFUNC);
		if(func->getFlag(FUNCFLAG_STATIC))
		{
			func->setFlag(FUNCFLAG_INVALID);
			func->invalidMsg += " Constructors and destructors cannot be static.";
		}
		$$ = func;}
	;
Class_Destructor :
	BITNOT Function_Typeless {
		ASTFuncDecl* func = (ASTFuncDecl*)$2;
		ASTDataType* returnType = new ASTDataType(DataType::ZVOID, @$);
		func->returnType = returnType;
		func->setFlag(FUNCFLAG_DESTRUCTOR|FUNCFLAG_CLASSFUNC);
		if(func->getFlag(FUNCFLAG_STATIC))
		{
			func->setFlag(FUNCFLAG_INVALID);
			func->invalidMsg += " Constructors and destructors cannot be static.";
		}
		$$ = func;}
	;

Class_Data :
	Data {$$ = $1;}
	;

Class_Block_Element :
	Class_Data SEMICOLON {$$ = $1;}
	| Function {
		ASTFuncDecl* func = (ASTFuncDecl*)$1;
		func->setFlag(FUNCFLAG_CLASSFUNC);
		$$ = func;}
	| DataTypeDef SEMICOLON {$$ = $1;}
	| Annotated_Enum SEMICOLON {$$ = $1;}
	| Using SEMICOLON {$$ = $1;}
	| Statement_Assert SEMICOLON {$$ = $1;}
	| EXPECTERROR LPAREN Expression_Constant RPAREN Class_Block_Element {
		ASTExprConst* errorId = (ASTExprConst*)$3;
		ASTDecl* declaration = (ASTDecl*)$5;
		declaration->compileErrorCatches.push_back(errorId);
		$$ = declaration;}
	;

////////////////////////////////////////////////////////////////
// Script Declaration

Annotated_Script :
	Annotation_List Script {
		ASTAnnotationList* list = (ASTAnnotationList*)$1;
		ASTScript* script = (ASTScript*)$2;
		handle_annotations(list, [&](AnnotData& data)
		{
			auto& key = data.key;
			if(key == "Author")
			{
				if(annot_type_check(ANNTY_STR, data))
				{
					annot_trunc_str(data.unescaped_val, 255);
					script->metadata.author = data.unescaped_val;
				}
				return true;
			}
			else if(key == "InitScript")
			{
				if(annot_type_check(ANNTY_INT, data))
					script->init_weight = data.intval.getZLong();
				return true;
			}
			else if((key.size() == 5 || key.size() == 6) && !key.compare(0,4,"Flag"))
			{
				byte c = key[4]-'0';
				if(key.size() == 6)
					c = (c*10)+key[5]-'0';
				if(c < 16)
				{
					if(annot_type_check(ANNTY_STR, data))
					{
						annot_trunc_str(data.unescaped_val, 255);
						script->metadata.usrflags[c] = data.unescaped_val;
					}
					return true;
				}
			}
			else if((key.size() == 9 || key.size() == 10) && !key.compare(0,8,"FlagHelp"))
			{
				byte c = key[8]-'0';
				if(key.size() == 10)
					c = (c*10)+key[9]-'0';
				if(c < 16)
				{
					if(annot_type_check(ANNTY_STR, data))
					{
						annot_trunc_str(data.val, 65535);
						script->metadata.usrflags_help[c] = data.val;
					}
					return true;
				}
			}
			else if(key.size() == 6 && !key.compare(0,5,"InitD"))
			{
				byte c = key[5]-'0';
				if(c < 8)
				{
					if(annot_type_check(ANNTY_STR, data))
					{
						annot_trunc_str(data.unescaped_val, 255);
						script->metadata.initd[c] = data.unescaped_val;
					}
					return true;
				}
			}
			else if(key.size() == 10)
			{
				byte c = key[9]-'0';
				if(!key.compare(0,9,"InitDType"))
				{
					if(c < 8)
					{
						if(annot_type_check(ANNTY_STR, data))
						{
							int8_t v = -1;
							upperstr(data.val);
							if(data.val.size() == 2 && data.val[0] == 'L')
							{
								switch(data.val[1])
								{
									case 'D': v = nswapLDEC; break;
									case 'H': v = nswapLHEX; break;
								}
							}
							else if(data.val.size() == 1)
							{
								switch(data.val[0])
								{
									case 'D': v = nswapDEC; break;
									case 'H': v = nswapHEX; break;
									case 'B': v = nswapBOOL; break;
								}
							}
							if(unsigned(v) < nswapMAX)
								script->metadata.initd_type[c] = v;
							else if(data.val == "-1")
								script->metadata.initd_type[c] = -1;
							else annot_errstr("ERROR: Bad Annotation Value: '@" + key + "' must be"
									" exactly 'D','H','LD','LH','B', or '-1' NOT '" + data.strval + "'.");
						}
						return true;
					}
				}
				else if(!key.compare(0,9,"InitDHelp"))
				{
					if(c < 8)
					{
						if(annot_type_check(ANNTY_STR, data))
						{
							annot_trunc_str(data.val, 65535);
							script->metadata.initd_help[c] = data.val;
						}
						return true;
					}
				}
				else if(!key.compare(0,9,"Attribute"))
				{
					if(c < 10)
					{
						if(annot_type_check(ANNTY_STR, data))
						{
							annot_trunc_str(data.unescaped_val, 255);
							script->metadata.attributes[c] = data.unescaped_val;
						}
						return true;
					}
				}
				else if(!key.compare(0,9,"Attribyte"))
				{
					if(c < 8)
					{
						if(annot_type_check(ANNTY_STR, data))
						{
							annot_trunc_str(data.unescaped_val, 255);
							script->metadata.attribytes[c] = data.unescaped_val;
						}
						return true;
					}
				}
			}
			else if(key.size() == 11 && !key.compare(0,10,"Attrishort"))
			{
				byte c = key[10]-'0';
				if(c < 8)
				{
					if(annot_type_check(ANNTY_STR, data))
					{
						annot_trunc_str(data.unescaped_val, 255);
						script->metadata.attrishorts[c] = data.unescaped_val;
					}
					return true;
				}
			}
			else if(key.size() == 14)
			{
				if(!key.compare(0,13,"AttributeHelp"))
				{
					byte c = key[13]-'0';
					if(c < 10)
					{
						if(annot_type_check(ANNTY_STR, data))
						{
							annot_trunc_str(data.val, 65535);
							script->metadata.attributes_help[c] = data.val;
						}
						return true;
					}
				}
				else if(!key.compare(0,13,"AttribyteHelp"))
				{
					byte c = key[13]-'0';
					if(c < 8)
					{
						if(annot_type_check(ANNTY_STR, data))
						{
							annot_trunc_str(data.val, 65535);
							script->metadata.attribytes_help[c] = data.val;
						}
						return true;
					}
				}
			}
			else if(key.size() == 15 && !key.compare(0,14,"AttrishortHelp"))
			{
				byte c = key[14]-'0';
				if(c < 8)
				{
					if(annot_type_check(ANNTY_STR, data))
					{
						annot_trunc_str(data.val, 65535);
						script->metadata.attrishorts_help[c] = data.val;
					}
					return true;
				}
			}
			return false;
		});
		$$ = script;}
	;

Script :
	Script_Type SCRIPT IDENTIFIER Script_Block {
		ASTScriptType* type = (ASTScriptType*)$1;
		ASTString* name = (ASTString*)$3;
		ASTScript* script = (ASTScript*)$4;
		script->identifier = name;
		script->type = type;
		script->metadata.script_name = name->getValue();
		script->location = @$;
		$$ = script;}
	;


Script_Type :
	IDENTIFIER {
		ASTString* name = static_cast<ASTString*>($1);
		$$ = new ASTScriptType(name->getValue(), @$);
		delete name;}
	;

Script_Block :
	LBRACE Script_Block_List RBRACE {$$ = $2;}
	| LBRACE RBRACE {$$ = new ASTScript(@$);}
	;

Script_Block_List :
	Script_Block_List Script_Block_Element {
		ASTScript* script = (ASTScript*)$1;
		ASTDecl* declaration = (ASTDecl*)$2;
		script->addDeclaration(*declaration);
		script->location = @$;
		$$ = script;}
	| Script_Block_List Option {
		ASTScript* script = (ASTScript*)$1;
		ASTSetOption* option = (ASTSetOption*)$2;
		script->options.push_back(option);
		script->location = @$;
		$$ = script;
		if (!script->variables.empty()
		    || !script->functions.empty()
		    || !script->types.empty()) {
			yywarn("WARNING: Options should come before everything else.");}}
	| Script_Block_Element {
		ASTScript* script = new ASTScript(@$);
		ASTDecl* declaration = (ASTDecl*)$1;
		script->addDeclaration(*declaration);
		$$ = script;}
	| Option {
		ASTScript* script = new ASTScript(@$);
		ASTSetOption* option = (ASTSetOption*)$1;
		script->options.push_back(option);
		$$ = script;}
	;

Script_Block_Element :
	Data SEMICOLON {$$ = $1;}
	| Function {$$ = $1;}
	| DataTypeDef SEMICOLON {$$ = $1;}
	| Annotated_Enum SEMICOLON {$$ = $1;}
	| Using SEMICOLON {$$ = $1;}
	| Statement_Assert SEMICOLON {$$ = $1;}
	| EXPECTERROR LPAREN Expression_Constant RPAREN Script_Block_Element {
		ASTExprConst* errorId = (ASTExprConst*)$3;
		ASTDecl* declaration = (ASTDecl*)$5;
		declaration->compileErrorCatches.push_back(errorId);
		$$ = declaration;}
	;

Annotation_List :
	Annotation_List COMMA Annotation {
		ASTAnnotationList* list = (ASTAnnotationList*)$1;
		list->set.push_back((ASTAnnotation*)$3);
		$$ = list;}
	| Annotation {
		ASTAnnotationList* list = new ASTAnnotationList(@$);
		list->set.push_back((ASTAnnotation*)$1);
		$$ = list;}
	;

Annotation :
	HANDLE IDENTIFIER LPAREN QuotedString RPAREN {
		ASTString* key = (ASTString*)$2;
		ASTString* val = (ASTString*)$4;
		ASTAnnotation* a = new ASTAnnotation(key, val, @$);
		$$ = a;}
	| HANDLE IDENTIFIER LPAREN NUMBER RPAREN {
		ASTString* key = (ASTString*)$2;
		ASTFloat* val = (ASTFloat*)$4;
		ASTAnnotation* a = new ASTAnnotation(key, val, @$);
		$$ = a;}
	| HANDLE IDENTIFIER LPAREN LONGNUMBER RPAREN {
		ASTString* key = (ASTString*)$2;
		ASTFloat* val = (ASTFloat*)$4;
		ASTAnnotation* a = new ASTAnnotation(key, val, @$);
		$$ = a;}
	| HANDLE IDENTIFIER LPAREN MINUS NUMBER RPAREN {
		ASTString* key = (ASTString*)$2;
		ASTFloat* val = (ASTFloat*)$5;
		val->negative = !val->negative;
		ASTAnnotation* a = new ASTAnnotation(key, val, @$);
		$$ = a;}
	| HANDLE IDENTIFIER LPAREN MINUS LONGNUMBER RPAREN {
		ASTString* key = (ASTString*)$2;
		ASTFloat* val = (ASTFloat*)$5;
		val->negative = !val->negative;
		ASTAnnotation* a = new ASTAnnotation(key, val, @$);
		$$ = a;}
	| HANDLE IDENTIFIER LPAREN RPAREN {
		ASTString* key = (ASTString*)$2;
		ASTAnnotation* a = new ASTAnnotation(key, @$);
		$$ = a;}
	;

////////////////////////////////////////////////////////////////
// Statements

Block_Statement :
	Statement {
		ASTStmt* stmt = (ASTStmt*)$1;
		if(ASTBlock* existing_block = dynamic_cast<ASTBlock*>(stmt))
		{
			$$ = existing_block;
		}
		else
		{
			ASTBlock* block = new ASTBlock(@$);
			block->statements.push_back(stmt);
			$$ = block;
		}
	}
	;

Statement :
	// Declarations
	Data SEMICOLON {$$ = $1;}
	| DataTypeDef SEMICOLON {$$ = $1;}
	| Annotated_Enum SEMICOLON {$$ = $1;}
	| Using SEMICOLON {$$ = $1;}
	// Normal Statements
	| Statement_Expression SEMICOLON {$$ = $1;}
	| Statement_Block {$$ = $1;}
	| Statement_If {$$ = $1;}
	| Statement_Switch {$$ = $1;}
	| Statement_For {$$ = $1;}
	| Annotated_Loop {$$ = $1;}
	| Statement_While {$$ = $1;}
	| Statement_Do {$$ = $1;}
	| Statement_Repeat {$$ = $1;}
	| Statement_Return SEMICOLON {$$ = $1;}
	| BREAK SEMICOLON {$$ = new ASTStmtBreak(NULL, @$);}
	| BREAK NUMBER SEMICOLON {
		ASTFloat* val = (ASTFloat*)$2;
		ASTNumberLiteral* lit = new ASTNumberLiteral(val, @$);
		$$ = new ASTStmtBreak(lit, @$);
	}
	| CONTINUE SEMICOLON {$$ = new ASTStmtContinue(NULL, @$);}
	| CONTINUE NUMBER SEMICOLON {
		ASTFloat* val = (ASTFloat*)$2;
		ASTNumberLiteral* lit = new ASTNumberLiteral(val, @$);
		$$ = new ASTStmtContinue(lit, @$);
	}
	| SEMICOLON {$$ = new ASTStmtEmpty(@$);}
	| Statement_CompileError SEMICOLON {$$ = $1;}
	| Statement_Assert SEMICOLON {$$ = $1;}
	;

Statement_NoSemicolon:
	// Declarations
	Data {$$ = $1;}
	| DataTypeDef {$$ = $1;}
	| Annotated_Enum {$$ = $1;}
	// Normal Statements
	| Statement_Expression {$$ = $1;}
	| Statement_Block {$$ = $1;}
	| Statement_If {$$ = $1;}
	| Statement_Switch {$$ = $1;}
	| Statement_For {$$ = $1;}
	| Annotated_Loop {$$ = $1;}
	| Statement_While {$$ = $1;}
	| Statement_Do {$$ = $1;}
	| Statement_Return {$$ = $1;}
	| BREAK {$$ = new ASTStmtBreak(NULL,@$);}
	| BREAK NUMBER {
		ASTFloat* val = (ASTFloat*)$2;
		ASTNumberLiteral* lit = new ASTNumberLiteral(val, @$);
		$$ = new ASTStmtBreak(lit, @$);
	}
	| CONTINUE {$$ = new ASTStmtContinue(NULL,@$);}
	| CONTINUE NUMBER {
		ASTFloat* val = (ASTFloat*)$2;
		ASTNumberLiteral* lit = new ASTNumberLiteral(val, @$);
		$$ = new ASTStmtContinue(lit, @$);
	}
	| %empty {$$ = new ASTStmtEmpty(@$);}
	| Statement_CompileError {$$ = $1;}
	;

Statement_Block :
	LBRACE Statement_Block_List RBRACE {$$ = $2;}
	| LBRACE RBRACE {$$ = new ASTBlock(@$);}
	;

Statement_Block_List :
	Statement_Block_List Statement {
		ASTBlock* block = (ASTBlock*)$1;
		ASTStmt* stmt = (ASTStmt*)$2;
		block->statements.push_back(stmt);
		$$ = block;}
	| Statement_Block_List Option {
		ASTBlock* block = (ASTBlock*)$1;
		ASTSetOption* option = (ASTSetOption*)$2;
		block->options.push_back(option);
		$$ = block;
		if (!block->statements.empty()) {
			yywarn("WARNING: Options should come before everything else.");}}
	| Statement {
		ASTStmt* stmt = (ASTStmt*)$1;
		ASTBlock* block = new ASTBlock(@$);
		block->statements.push_back(stmt);
		$$ = block;}
	| Option {
		ASTSetOption* option = (ASTSetOption*)$1;
		ASTBlock* block = new ASTBlock(@$);
		block->options.push_back(option);
		$$ = block;}
	;

Statement_If :
	IF If_Body {$$ = $2;}
	| UNLESS If_Body {
		ASTStmtIf* stmt = (ASTStmtIf*)$2;
		stmt->invert();
		$$ = stmt;
	}
	;

If_Body :
	LPAREN Single_Data_req_assign RPAREN Block_Statement {
		ASTDataDecl* decl = (ASTDataDecl*)$2;
		ASTBlock* stmt = (ASTBlock*)$4;
		$$ = new ASTStmtIf(decl, stmt, @$);}
	| LPAREN Single_Data_req_assign RPAREN Block_Statement ELSE Block_Statement {
		ASTDataDecl* decl = (ASTDataDecl*)$2;
		ASTBlock* thenStatement = (ASTBlock*)$4;
		ASTBlock* elseStatement = (ASTBlock*)$6;
		$$ = new ASTStmtIfElse(decl, thenStatement, elseStatement, @$);}
	| LPAREN Expression RPAREN Block_Statement {
		ASTExpr* cond = (ASTExpr*)$2;
		ASTBlock* stmt = (ASTBlock*)$4;
		$$ = new ASTStmtIf(cond, stmt, @$);}
	| LPAREN Expression RPAREN Block_Statement ELSE Block_Statement {
		ASTExpr* test = (ASTExpr*)$2;
		ASTBlock* thenStatement = (ASTBlock*)$4;
		ASTBlock* elseStatement = (ASTBlock*)$6;
		$$ = new ASTStmtIfElse(test, thenStatement, elseStatement, @$);}
	;

Statement_Switch :
	SWITCH LPAREN Expression RPAREN LBRACE Statement_Switch_Body RBRACE {
		ASTExpr* key = (ASTExpr*)$3;
		ASTStmtSwitch* sw = (ASTStmtSwitch*)$6;
		sw->key = key;
		$$ = sw;}

Statement_Switch_Body :
	Statement_Switch_Body Statement_Switch_Cases Statement_Block_List {
		ASTStmtSwitch* sw = (ASTStmtSwitch*)$1;
		ASTSwitchCases* cases = (ASTSwitchCases*)$2;
		ASTBlock* block = (ASTBlock*)$3;
		cases->block = block;
		sw->cases.push_back(cases);
		$$ = sw;}
	| Statement_Switch_Cases Statement_Block_List {
		ASTStmtSwitch* sw = new ASTStmtSwitch(@$);
		ASTSwitchCases* cases = (ASTSwitchCases*)$1;
		ASTBlock* block = (ASTBlock*)$2;
		cases->block = block;
		sw->cases.push_back(cases);
		$$ = sw;}
	;

Statement_Switch_Cases :
	Statement_Switch_Cases CASE Expression_Constant COLON {
		ASTSwitchCases* cases = (ASTSwitchCases*)$1;
		ASTExprConst* key = (ASTExprConst*)$3;
		cases->cases.push_back(key);
		$$ = cases;}
	| Statement_Switch_Cases DEFAULT COLON {
		ASTSwitchCases* cases = (ASTSwitchCases*)$1;
		cases->isDefault = true;
		$$ = cases;}
	| Statement_Switch_Cases CASE Expression_Const_Range COLON {
		ASTSwitchCases* cases = (ASTSwitchCases*)$1;
		ASTRange* range = (ASTRange*)$3;
		cases->ranges.push_back(range);
		$$ = cases;}
	| Statement_Switch_Cases CASE CASESTRING COLON {
		ASTString* rawstring = (ASTString*)$3;
		ASTStringLiteral* key = new ASTStringLiteral(*rawstring);
		delete rawstring;
		ASTSwitchCases* cases = (ASTSwitchCases*)$1;
		cases->str_cases.push_back(key);
		$$ = cases;}
	| CASE Expression_Constant COLON {
		ASTSwitchCases* cases = new ASTSwitchCases(@$);
		ASTExprConst* key = (ASTExprConst*)$2;
		cases->cases.push_back(key);
		$$ = cases;}
	| CASE Expression_Const_Range COLON {
		ASTSwitchCases* cases = new ASTSwitchCases(@$);
		ASTRange* range = (ASTRange*)$2;
		cases->ranges.push_back(range);
		$$ = cases;}
	| CASE CASESTRING COLON {
		ASTSwitchCases* cases = new ASTSwitchCases(@$);
		ASTString* rawstring = (ASTString*)$2;
		ASTStringLiteral* key = new ASTStringLiteral(*rawstring);
		delete rawstring;
		cases->str_cases.push_back(key);
		$$ = cases;}
	| DEFAULT COLON {
		ASTSwitchCases* cases = new ASTSwitchCases(@$);
		cases->isDefault = true;
		$$ = cases;}
	;

Statement_For :
	Statement_For_Standard {$$ = $1;}
	| Statement_For_Each {$$ = $1;}
	;

Statement_CommaList :
	Statement_CommaList COMMA Statement_NoSemicolon {
		ASTNodeList<ASTStmt>* list = (ASTNodeList<ASTStmt>*)$1;
		list->push((ASTStmt*)$3);
		$$ = list;
	}
	| Statement_NoSemicolon {
		ASTNodeList<ASTStmt>* list = new ASTNodeList<ASTStmt>();
		list->push((ASTStmt*)$1);
		$$ = list;
	}
	;

Statement_For_Standard :
	FOR LPAREN
		Statement_NoSemicolon SEMICOLON
		Expression SEMICOLON
		Statement_CommaList RPAREN
		Block_Statement
	{
		ASTStmt* setup = (ASTStmt*)$3;
		ASTExpr* test = (ASTExpr*)$5;
		ASTNodeList<ASTStmt>* increments = (ASTNodeList<ASTStmt>*)$7;
		ASTStmt* body = (ASTStmt*)$9;
		$$ = new ASTStmtFor(setup, test, increments, body, nullptr, @$);
	}
	| FOR LPAREN
		Statement_NoSemicolon SEMICOLON
		Expression SEMICOLON
		Statement_CommaList RPAREN
		Block_Statement ELSE Block_Statement
	{
		ASTStmt* setup = (ASTStmt*)$3;
		ASTExpr* test = (ASTExpr*)$5;
		ASTNodeList<ASTStmt>* increments = (ASTNodeList<ASTStmt>*)$7;
		ASTStmt* body = (ASTStmt*)$9;
		ASTBlock* elseStatement = (ASTBlock*)$11;
		$$ = new ASTStmtFor(setup, test, increments, body, elseStatement, @$);
	}
	;

Statement_For_Each :
	FOR LPAREN Identifier Token_In Expression RPAREN
		Block_Statement
	{
		ASTString* iden = (ASTString*)$3;
		ASTExpr* expr = (ASTExpr*)$5;
		ASTStmt* body = (ASTExpr*)$7;
		
		$$ = new ASTStmtForEach(iden, expr, body, nullptr, @$);
	}
	| FOR LPAREN Identifier Token_In Expression RPAREN
		Block_Statement ELSE Block_Statement
	{
		ASTString* iden = (ASTString*)$3;
		ASTExpr* expr = (ASTExpr*)$5;
		ASTStmt* body = (ASTExpr*)$7;
		ASTStmt* elseblock = (ASTExpr*)$9;
		
		$$ = new ASTStmtForEach(iden, expr, body, elseblock, @$);
	}
	;

Annotated_Loop :
	Annotation_List Statement_Loop {
		ASTAnnotationList* list = (ASTAnnotationList*)$1;
		ASTStmtRangeLoop* loop = (ASTStmtRangeLoop*)$2;
		handle_annotations(list, [&](AnnotData& data)
		{
			auto& key = data.key;
			if(key == "AlwaysRunEndpoint")
			{
				if(annot_type_check(ANNTY_STR, data))
				{
					if(data.strval == "off")
						loop->overflow = ASTStmtRangeLoop::OVERFLOW_ALLOW;
					else if(data.strval == "int")
						loop->overflow = ASTStmtRangeLoop::OVERFLOW_INT;
					else if(data.strval == "long" || data.strval == "float")
						loop->overflow = ASTStmtRangeLoop::OVERFLOW_LONG;
					else annot_errstr(annot_err_header+": '@"+key+"' must be"
							" exactly 'off','int','float', or 'long', NOT '" + data.strval + "'.");
				}
				return true;
			}
			return false;
		});
		$$ = loop;}
	| Statement_Loop {$$ = $1;}
	;

Statement_Loop :
	Statement_Loop_Inf {$$ = $1;}
	| Statement_Loop_Range {$$ = $1;}
	;

Statement_Loop_Inf :
	LOOP LPAREN RPAREN Block_Statement
	{
		ASTExpr* test = new ASTBoolLiteral(true, @$);
		ASTStmt* body = (ASTStmt*)$4;
		$$ = new ASTStmtWhile(test,body,nullptr,@$);
	};

Statement_Loop_Range :
	Statement_Loop_Range_Base ELSE Block_Statement
	{
		ASTStmtRangeLoop* loop = (ASTStmtRangeLoop*)$1;
		ASTStmt* elseblock = (ASTExpr*)$3;
		loop->elseBlock = elseblock;
		$$ = loop;
	}
	| Statement_Loop_Range_Base {$$ = $1;}
	;
	
Statement_Loop_Range_Base :
	LOOP LPAREN DataType IDENTIFIER Token_In Expression_Range COMMA Expression RPAREN Block_Statement
	{
		ASTDataType* type = (ASTDataType*)$3;
		ASTString* iden = (ASTString*)$4;
		ASTRange* range = (ASTRange*)$6;
		ASTExpr* incr = (ASTExpr*)$8;
		ASTStmt* body = (ASTStmt*)$10;
		$$ = new ASTStmtRangeLoop(type, iden, range, incr, body, @$);
	}
	| LOOP LPAREN IDENTIFIER Token_In Expression_Range COMMA Expression RPAREN Block_Statement
	{
		ASTDataType* type = new ASTDataType(DataType::CFLOAT, @$);
		ASTString* iden = (ASTString*)$3;
		ASTRange* range = (ASTRange*)$5;
		ASTExpr* incr = (ASTExpr*)$7;
		ASTStmt* body = (ASTStmt*)$9;
		$$ = new ASTStmtRangeLoop(type, iden, range, incr, body, @$);
	}
	| LOOP LPAREN Expression_Range COMMA Expression RPAREN Block_Statement
	{
		ASTDataType* type = new ASTDataType(DataType::CFLOAT, @$);
		ASTRange* range = (ASTRange*)$3;
		ASTExpr* incr = (ASTExpr*)$5;
		ASTStmt* body = (ASTStmt*)$7;
		$$ = new ASTStmtRangeLoop(type, new ASTString("__LOOP_ITER", @$), range, incr, body, @$);
	}
	| LOOP LPAREN DataType IDENTIFIER Token_In Expression_Range RPAREN Block_Statement
	{
		ASTDataType* type = (ASTDataType*)$3;
		ASTString* iden = (ASTString*)$4;
		ASTRange* range = (ASTRange*)$6;
		ASTExpr* incr = new ASTNumberLiteral(new ASTFloat("1", ASTFloat::TYPE_DECIMAL, @$), @$);
		ASTStmt* body = (ASTStmt*)$8;
		$$ = new ASTStmtRangeLoop(type, iden, range, incr, body, @$);
	}
	| LOOP LPAREN IDENTIFIER Token_In Expression_Range RPAREN Block_Statement
	{
		ASTDataType* type = new ASTDataType(DataType::CFLOAT, @$);
		ASTString* iden = (ASTString*)$3;
		ASTRange* range = (ASTRange*)$5;
		ASTExpr* incr = new ASTNumberLiteral(new ASTFloat("1", ASTFloat::TYPE_DECIMAL, @$), @$);
		ASTStmt* body = (ASTStmt*)$7;
		$$ = new ASTStmtRangeLoop(type, iden, range, incr, body, @$);
	}
	| LOOP LPAREN Expression_Range RPAREN Block_Statement
	{
		ASTDataType* type = new ASTDataType(DataType::CFLOAT, @$);
		ASTRange* range = (ASTRange*)$3;
		ASTExpr* incr = new ASTNumberLiteral(new ASTFloat("1", ASTFloat::TYPE_DECIMAL, @$), @$);
		ASTStmt* body = (ASTStmt*)$5;
		$$ = new ASTStmtRangeLoop(type, new ASTString("__LOOP_ITER", @$), range, incr, body, @$);
	}
	;

Token_In :
	COLON {$$ = $1;}
	| IN {$$ = $1;}
	;

Statement_While :
	WHILE LPAREN Expression RPAREN Block_Statement {
		ASTExpr* test = (ASTExpr*)$3;
		ASTStmt* body = (ASTStmt*)$5;
		$$ = new ASTStmtWhile(test, body, nullptr, @$);}
	| WHILE LPAREN Expression RPAREN Block_Statement ELSE Block_Statement {
		ASTExpr* test = (ASTExpr*)$3;
		ASTStmt* body = (ASTStmt*)$5;
		ASTBlock* elseblock = (ASTBlock*)$7;
		$$ = new ASTStmtWhile(test, body, elseblock, @$);}
	| UNTIL LPAREN Expression RPAREN Block_Statement {
		ASTExpr* test = (ASTExpr*)$3;
		ASTStmt* body = (ASTStmt*)$5;
		ASTStmtWhile* stmt = new ASTStmtWhile(test, body, nullptr, @$);
		stmt->invert();
		$$ = stmt;}
	| UNTIL LPAREN Expression RPAREN Block_Statement ELSE Block_Statement {
		ASTExpr* test = (ASTExpr*)$3;
		ASTStmt* body = (ASTStmt*)$5;
		ASTBlock* elseblock = (ASTBlock*)$7;
		ASTStmtWhile* stmt = new ASTStmtWhile(test, body, elseblock, @$);
		stmt->invert();
		$$ = stmt;}
	;

Statement_Do :
	DO Block_Statement WHILE LPAREN Expression RPAREN {
		ASTStmt* body = (ASTStmt *)$2;
		ASTExpr* test = (ASTExpr*)$5;
		$$ = new ASTStmtDo(test, body, nullptr, @$);}
	| DO Block_Statement WHILE LPAREN Expression RPAREN ELSE Block_Statement {
		ASTStmt* body = (ASTStmt *)$2;
		ASTExpr* test = (ASTExpr*)$5;
		ASTBlock* elseblock = (ASTBlock*)$8;
		$$ = new ASTStmtDo(test, body, elseblock, @$);}
	| DO Block_Statement UNTIL LPAREN Expression RPAREN {
		ASTStmt* body = (ASTStmt *)$2;
		ASTExpr* test = (ASTExpr*)$5;
		ASTStmtDo* stmt = new ASTStmtDo(test, body, nullptr, @$);
		stmt->invert();
		$$ = stmt;}
	| DO Block_Statement UNTIL LPAREN Expression RPAREN ELSE Block_Statement {
		ASTStmt* body = (ASTStmt *)$2;
		ASTExpr* test = (ASTExpr*)$5;
		ASTBlock* elseblock = (ASTBlock*)$8;
		ASTStmtDo* stmt = new ASTStmtDo(test, body, elseblock, @$);
		stmt->invert();
		$$ = stmt;}
	;

Statement_Repeat :
	REPEAT LPAREN Expression_Constant RPAREN Statement {
		ASTExprConst* expr = (ASTExprConst*)$3;
		ASTStmt* body = (ASTStmt*)$5;
		$$ = new ASTStmtRepeat(expr, body, @$);}
	;

Statement_Return :
	RETURN Expression {
		ASTExpr* value = (ASTExpr*)$2;
		$$ = new ASTStmtReturnVal(value, @$);}
	| RETURN {$$ = new ASTStmtReturn(@$);}
	;

Statement_CompileError :
	EXPECTERROR LPAREN Expression_Constant RPAREN Statement_NoSemicolon {
		ASTExprConst* errorId = (ASTExprConst*)$3;
		ASTStmt* statement = (ASTStmt*)$5;
		statement->compileErrorCatches.push_back(errorId);
		$$ = statement;}
	;

Annotated_Enum:
	Annotation_List DataEnum {
		ASTAnnotationList* list = (ASTAnnotationList*)$1;
		ASTDataEnum* en = dynamic_cast<ASTDataEnum*>($2);
		ASTCustomDataTypeDef* tdef = dynamic_cast<ASTCustomDataTypeDef*>($2);
		if(tdef) en = tdef->definition.get();
		handle_annotations(list, [&](AnnotData& data)
		{
			auto& key = data.key;
			if(key == "Increment")
			{
				if(en->getBitMode() != ASTDataEnum::BIT_NONE)
					annot_incompatible("Increment", "Bitflags");
				else if(annot_type_check(ANNTY_INT, data))
					en->increment_val = data.intval;
				return true;
			}
			else if(key == "Bitflags")
			{
				if(en->increment_val)
					annot_incompatible("Bitflags", "Increment");
				else if(annot_type_check(ANNTY_STR, data))
				{
					if(data.strval == "int")
						en->setBitMode(ASTDataEnum::BIT_INT);
					else if(data.strval == "long")
						en->setBitMode(ASTDataEnum::BIT_LONG);
				}
				return true;
			}
			return false;
		});
		$$ = $2;}
	| DataEnum {$$ = $1;}

DataEnum:
	ENUM LBRACE Enum_Block Trail_Comma_RBrace {$$ = $3;}
	| ENUM ASSIGN DataType LBRACE Enum_Block Trail_Comma_RBrace {
		ASTDataEnum* list = (ASTDataEnum*)$5;
		ASTDataType* type = (ASTDataType*)$3;
		type->constant_ = 1; //force to be constant, skip `const const` errors
		list->baseType = type;
		list->location = @$;
		$$ = list;}
	| ENUM IDENTIFIER LBRACE Enum_Block Trail_Comma_RBrace {
		ASTDataEnum* en = (ASTDataEnum*)$4;
		en->location = @$;
		ASTString* identifier = (ASTString*)$2;
		auto custom_typedef = new ASTCustomDataTypeDef(NULL, identifier, en, @$);
		custom_typedef->doc_comment = std::move(identifier->doc_comment);
		$$ = custom_typedef;};

Enum_Block:
	Enum_Block COMMA Data_Element {
			ASTDataEnum* list = (ASTDataEnum*)$1;
			ASTDataDecl* element = (ASTDataDecl*)$3;
			list->addDeclaration(element);
			$$ = list;}
	| Data_Element {
			ASTDataDecl* element = (ASTDataDecl*)$1;
			ASTDataEnum* list = new ASTDataEnum(@$);
			list->addDeclaration(element);
			$$ = list;}
	;

	/*Enum_Block COMMA IDENTIFIER {
		ASTDataEnum* en = (ASTDataEnum*)$1;
		ASTString* name = (ASTString*)$3;
		ASTDataDecl* element = new ASTDataDecl(@$);
		element->name = name->getValue();
		element->doc_comment = std::move(name->doc_comment);
		en->add(element);
		delete name;
		$$ = en;}
	| Enum_Block COMMA IDENTIFIER ASSIGN Expression_Constant {
		ASTDataEnum* en = (ASTDataEnum*)$1;
		ASTString* name = (ASTString*)$3;
		ASTDataDecl* element = new ASTDataDecl(@$);
		element->name = name->getValue();
		element->doc_comment = std::move(name->doc_comment);
		ASTExprConst* value = (ASTExprConst*)$5;
		element->setInitializer(value);
		en->add(element);
		delete name;
		$$ = en;}
	| IDENTIFIER {
		ASTDataEnum* en = new ASTDataEnum(@$);
		ASTString* name = (ASTString*)$1;
		ASTDataDecl* element = new ASTDataDecl(@$);
		element->name = name->getValue();
		element->doc_comment = std::move(name->doc_comment);
		en->add(element);
		delete name;
		$$ = en;}
	| IDENTIFIER ASSIGN Expression_Constant {
		ASTDataEnum* en = new ASTDataEnum(@$);
		ASTString* name = (ASTString*)$1;
		ASTDataDecl* element = new ASTDataDecl(@$);
		element->name = name->getValue();
		element->doc_comment = std::move(name->doc_comment);
		ASTExprConst* value = (ASTExprConst*)$3;
		element->setInitializer(value);
		en->add(element);
		delete name;
		$$ = en;}*/

////////////////////////////////////////////////////////////////
// Expression Helpers

ScopeRes :
	SCOPERES {$$ = $1;}
	//| RANGE_N {$$ = $1;}
	;

Identifier_List :
	Mixed_Identifier_List {$$ = $1;}
	| idlist_scopres {$$ = $1;}
	| idlist_dot {$$ = $1;}
	| Ambigious_Iden_List {$$ = $1;}
	;

Scoperes_Identifier_List:
	idlist_scopres {$$ = $1;}
	| Ambigious_Iden_List {$$ = $1;}
	;

/*Dot_Identifier_List:
	idlist_dot {$$ = $1;}
	| Ambigious_Iden_List {$$ = $1}
	;*/

Mixed_Identifier_List:
	Mixed_Identifier_List DOT Identifier {
		ASTExprIdentifier* identifier = (ASTExprIdentifier*)$1;
		ASTString* name = (ASTString*)$3;
		identifier->components.push_back(name->getValue());
		identifier->componentNodes.push_back(std::shared_ptr<ASTString>(name));
		identifier->delimiters.push_back(".");
		identifier->location = @$;
		$$ = identifier;}
	| idlist_scopres DOT Identifier {
		ASTExprIdentifier* identifier = (ASTExprIdentifier*)$1;
		ASTString* name = (ASTString*)$3;
		identifier->components.push_back(name->getValue());
		identifier->componentNodes.push_back(std::shared_ptr<ASTString>(name));
		identifier->delimiters.push_back(".");
		identifier->location = @$;
		$$ = identifier;}
	| Mixed_Identifier_List ScopeRes Identifier {
		ASTExprIdentifier* identifier = (ASTExprIdentifier*)$1;
		ASTString* name = (ASTString*)$3;
		identifier->components.push_back(name->getValue());
		identifier->componentNodes.push_back(std::shared_ptr<ASTString>(name));
		identifier->delimiters.push_back("::");
		identifier->location = @$;
		$$ = identifier;}
	| idlist_dot ScopeRes Identifier {
		ASTExprIdentifier* identifier = (ASTExprIdentifier*)$1;
		ASTString* name = (ASTString*)$3;
		identifier->components.push_back(name->getValue());
		identifier->componentNodes.push_back(std::shared_ptr<ASTString>(name));
		identifier->delimiters.push_back("::");
		identifier->location = @$;
		$$ = identifier;}
	;

idlist_scopres:
	idlist_scopres ScopeRes Identifier {
		ASTExprIdentifier* identifier = (ASTExprIdentifier*)$1;
		ASTString* name = (ASTString*)$3;
		identifier->components.push_back(name->getValue());
		identifier->componentNodes.push_back(std::shared_ptr<ASTString>(name));
		identifier->delimiters.push_back("::");
		identifier->location = @$;
		$$ = identifier;}
	| Ambigious_Iden_List ScopeRes Identifier {
		ASTExprIdentifier* identifier = (ASTExprIdentifier*)$1;
		ASTString* name = (ASTString*)$3;
		identifier->components.push_back(name->getValue());
		identifier->componentNodes.push_back(std::shared_ptr<ASTString>(name));
		identifier->delimiters.push_back("::");
		identifier->location = @$;
		$$ = identifier;}
	| ScopeRes Ambigious_Iden_List {
		ASTExprIdentifier* identifier = (ASTExprIdentifier*)$2;
		identifier->noUsing = true;
		$$ = identifier;}
	;

idlist_dot:
	idlist_dot DOT Identifier {
		ASTExprIdentifier* identifier = (ASTExprIdentifier*)$1;
		ASTString* name = (ASTString*)$3;
		identifier->components.push_back(name->getValue());
		identifier->componentNodes.push_back(std::shared_ptr<ASTString>(name));
		identifier->delimiters.push_back(".");
		identifier->location = @$;
		$$ = identifier;}
	| Ambigious_Iden_List DOT Identifier {
		ASTExprIdentifier* identifier = (ASTExprIdentifier*)$1;
		ASTString* name = (ASTString*)$3;
		identifier->components.push_back(name->getValue());
		identifier->componentNodes.push_back(std::shared_ptr<ASTString>(name));
		identifier->delimiters.push_back(".");
		identifier->location = @$;
		$$ = identifier;}
	;

Ambigious_Iden_List:
	Identifier {
		ASTString* name = (ASTString*)$1;
		ASTExprIdentifier* identifier = new ASTExprIdentifier(std::shared_ptr<ASTString>(name), @$);
		identifier->doc_comment = std::move(name->doc_comment);
		if (!first_identifier_for_line) first_identifier_for_line = identifier;
		$$ = identifier;}
	;

Identifier :
	IDENTIFIER {$$ = $1;}
	;

Func_Left :
	Expr_Arrow {$$ = $1;}
	| Identifier_List {$$ = $1;}
	;

Function_Call :
	NEW Identifier_List LPAREN RPAREN {
		ASTExprCall* call = new ASTExprCall(@$);
		call->setConstructor(true);
		ASTExpr* left = (ASTExpr*)$2;
		call->left = left;
		call->location = @$;
		$$ = call;}
	| NEW Identifier_List LPAREN Function_Call_Parameters RPAREN {
		ASTExprCall* call = (ASTExprCall*)$4;
		call->setConstructor(true);
		ASTExpr* left = (ASTExpr*)$2;
		call->left = left;
		call->location = @$;
		$$ = call;}
	| Func_Left LPAREN RPAREN {
		ASTExprCall* call = new ASTExprCall(@$);
		ASTExpr* left = (ASTExpr*)$1;
		call->left = left;
		call->location = @$;
		$$ = call;}
	| Func_Left LPAREN Function_Call_Parameters RPAREN {
		ASTExpr* left = (ASTExpr*)$1;
		ASTExprCall* call = (ASTExprCall*)$3;
		call->left = left;
		call->location = @$;
		$$ = call;}
	;

Function_Call_Parameters :
	Function_Call_Parameters COMMA Expression {
		ASTExprCall* call = (ASTExprCall*)$1;
		ASTExpr* e = (ASTExpr*)$3;
		call->parameters.push_back(e);
		call->location = @$;
		$$ = call;}
	| Expression {
		ASTExprCall* call = new ASTExprCall(@$);
		ASTExpr* e = (ASTExpr*)$1;
		call->parameters.push_back(e);
		$$ = call;}
	;

////////////////////////////////////////////////////////////////
// Expressions - in order of precedence.
//   (Roughly following http://en.cppreference.com/w/cpp/language/operator_precedence).

Expr_1 :
	Identifier_List {$$ = $1;}
	| Literal {$$ = $1;}
	| LPAREN Expression RPAREN {$$ = $2;}

Expr_2 : Expr_1 {$$ = $1;}
	//Casting
	//cast<type>(expr) //Not using this, yet at least. -V
	/*| CAST LT DataType GT LPAREN Expr_2 RPAREN {
		ASTDataType* type = (ASTDataType*)$3;
		ASTExpr* expr = (ASTExpr*)$6;
		ASTExprCast* cast = new ASTExprCast(type, expr, @$);
		cast->operand = expr;
		$$ = cast;}*/
	//<type>expr
	| LT DataType GT Expr_2 {
		ASTDataType* type = (ASTDataType*)$2;
		ASTExpr* expr = (ASTExpr*)$4;
		ASTExprCast* cast = new ASTExprCast(type, expr, @$);
		$$ = cast;}
	;

Expr_Arrow :
	Expr_3 ARROW IDENTIFIER {
			ASTExpr* left = (ASTExpr*)$1;
			ASTString* right = (ASTString*)$3;
			$$ = new ASTExprArrow(left, right, @$);}
	;

Expr_3 : Expr_2 {$$ = $1;}
	// Post Increment
	| Expr_3 INCREMENT {$$ = new ASTExprIncrement(false, (ASTExpr*)$1, @$);}
	// Post Decrement
	| Expr_3 DECREMENT {$$ = new ASTExprDecrement(false, (ASTExpr*)$1, @$);}
	// Function Call
	| Function_Call {$$ = $1;}
	// Subscript
	| Expr_3 LBRACKET Expression RBRACKET {
		$$ = new ASTExprIndex((ASTExpr*)$1, (ASTExpr*)$3, @$);;}
	// Access
	| Expr_Arrow {$$ = $1;}
	;

Expr_4 : Expr_3 {$$ = $1;}
	// Pre Increment
	| INCREMENT Expr_4 {$$ = new ASTExprIncrement(true, (ASTExpr*)$2, @$);}
	// Pre Decrement
	| DECREMENT Expr_4 {$$ = new ASTExprDecrement(true, (ASTExpr*)$2, @$);}
	// Unary Minus
	| MINUS Expr_4 {$$ = new ASTExprNegate((ASTExpr*)$2, @$);}
	// Logical Not
	| NOT Expr_4 {$$ = new ASTExprNot((ASTExpr*)$2, @$);}
	// Bitwise Not
	| BITNOT Expr_4 {$$ = new ASTExprBitNot((ASTExpr*)$2, @$);}
	;

Expr_5 : Expr_4 {$$ = $1;}
	// Exponentiation
	| Expr_5 EXPN Expr_4 {$$ = new ASTExprExpn((ASTExpr*)$1, (ASTExpr*)$3, @$);}
	;

Expr_6 : Expr_5 {$$ = $1;}
	// Multiplication
	| Expr_6 TIMES Expr_5 {$$ = new ASTExprTimes((ASTExpr*)$1, (ASTExpr*)$3, @$);}
	// Division
	| Expr_6 DIVIDE Expr_5 {$$ = new ASTExprDivide((ASTExpr*)$1, (ASTExpr*)$3, @$);}
	// Remainder
	| Expr_6 MODULO Expr_5 {$$ = new ASTExprModulo((ASTExpr*)$1, (ASTExpr*)$3, @$);}
	;

Expr_7 : Expr_6 {$$ = $1;}
	// Addition
	| Expr_7 PLUS Expr_6 {$$ = new ASTExprPlus((ASTExpr*)$1, (ASTExpr*)$3, @$);}
	// Subtraction
	| Expr_7 MINUS Expr_6 {$$ = new ASTExprMinus((ASTExpr*)$1, (ASTExpr*)$3, @$);}
	;

Expr_8 : Expr_7 {$$ = $1;}
	// Left Shift
	| Expr_8 LSHIFT Expr_7 {$$ = new ASTExprLShift((ASTExpr*)$1, (ASTExpr*)$3, @$);}
	// Right Shift
	| Expr_8 RSHIFT Expr_7 {$$ = new ASTExprRShift((ASTExpr*)$1, (ASTExpr*)$3, @$);}
	;

Expr_9 : Expr_8 {$$ = $1;}
	// Less Than
	| Expr_9 LT Expr_8 {$$ = new ASTExprLT((ASTExpr*)$1, (ASTExpr*)$3, @$);}
	// Less Than or Equal
	| Expr_9 LE Expr_8 {$$ = new ASTExprLE((ASTExpr*)$1, (ASTExpr*)$3, @$);}
	// Greater Than
	| Expr_9 GT Expr_8 {$$ = new ASTExprGT((ASTExpr*)$1, (ASTExpr*)$3, @$);}
	// Greater Than or Equal
	| Expr_9 GE Expr_8 {$$ = new ASTExprGE((ASTExpr*)$1, (ASTExpr*)$3, @$);}
	;

Expr_10 : Expr_9 {$$ = $1;}
	// Equality
	| Expr_10 EQ Expr_9 {$$ = new ASTExprEQ((ASTExpr*)$1, (ASTExpr*)$3, @$);}
	// Inequality
	| Expr_10 NE Expr_9 {$$ = new ASTExprNE((ASTExpr*)$1, (ASTExpr*)$3, @$);}
	// Approximate Equality
	| Expr_10 APPXEQUAL Expr_9 {$$ = new ASTExprAppxEQ((ASTExpr*)$1, (ASTExpr*)$3, @$);}
	// Logical XOR
	| Expr_10 XOR Expr_9 {$$ = new ASTExprXOR((ASTExpr*)$1, (ASTExpr*)$3, @$);}
	;

Expr_11 : Expr_10 {$$ = $1;}
	// Bitwise And
	| Expr_11 BITAND Expr_10 {$$ = new ASTExprBitAnd((ASTExpr*)$1, (ASTExpr*)$3, @$);}
	;

Expr_12 : Expr_11 {$$ = $1;}
	// Bitwise Xor
	| Expr_12 BITXOR Expr_11 {$$ = new ASTExprBitXor((ASTExpr*)$1, (ASTExpr*)$3, @$);}
	;

Expr_13 : Expr_12 {$$ = $1;}
	// Bitwise Or
	| Expr_13 BITOR Expr_12 {$$ = new ASTExprBitOr((ASTExpr*)$1, (ASTExpr*)$3, @$);}
	;

Expr_14 : Expr_13 {$$ = $1;}
	// Logical And
	| Expr_14 AND Expr_13 {$$ = new ASTExprAnd((ASTExpr*)$1, (ASTExpr*)$3, @$);}
	;

Expr_15 : Expr_14 {$$ = $1;}
	// Logical Or
	| Expr_15 OR Expr_14 {$$ = new ASTExprOr((ASTExpr*)$1, (ASTExpr*)$3, @$);}
	;

Expr_16 : Expr_15 {$$ = $1;}
	//Ternary
	| Expr_15 QMARK Expr_16 COLON Expr_16
	{
		ASTExpr* left = (ASTExpr*)$1;
		ASTExpr* middle = (ASTExpr*)$3;
		ASTExpr* right = (ASTExpr*)$5;
		$$ = new ASTTernaryExpr(left, middle, right, @$);
	}
	;

Expr_17 : Expr_16 {$$ = $1;}
	| DELETE Expr_17 {
		ASTExprDelete* del = new ASTExprDelete(@$);
		ASTExpr* operand = (ASTExpr*)$2;
		del->operand = operand;
		$$ = del;}
	;

Expr_18 : Expr_17 {$$ = $1;}
	// Assignment
	| Expr_17 ASSIGN Expr_18 {$$ = new ASTExprAssign((ASTExpr*)$1, (ASTExpr*)$3, @$);}
	// Addition Assignment
	| Expr_17 PLUSASSIGN Expr_18 {
		ASTExpr* left = (ASTExpr*)$1;
		ASTExpr* right = (ASTExpr*)$3;
		$$ = new ASTExprAssign(left, new ASTExprPlus(left->clone(), right, @3), @$);}
	// Subtraction Assignment
	| Expr_17 MINUSASSIGN Expr_18 {
		ASTExpr* left = (ASTExpr*)$1;
		ASTExpr* right = (ASTExpr*)$3;
		$$ = new ASTExprAssign(left, new ASTExprMinus(left->clone(), right, @3), @$);}
	// Multiplication Assignment
	| Expr_17 TIMESASSIGN Expr_18 {
		ASTExpr* left = (ASTExpr*)$1;
		ASTExpr* right = (ASTExpr*)$3;
		$$ = new ASTExprAssign(left, new ASTExprTimes(left->clone(), right, @3), @$);}
	// Division Assignment
	| Expr_17 DIVIDEASSIGN Expr_18 {
		ASTExpr* left = (ASTExpr*)$1;
		ASTExpr* right = (ASTExpr*)$3;
		$$ = new ASTExprAssign(left, new ASTExprDivide(left->clone(), right, @3), @$);}
	// Modulus Assignment
	| Expr_17 MODULOASSIGN Expr_18 {
		ASTExpr* left = (ASTExpr*)$1;
		ASTExpr* right = (ASTExpr*)$3;
		$$ = new ASTExprAssign(left, new ASTExprModulo(left->clone(), right, @3), @$);}
	// Left Shift Assignment
	| Expr_17 LSHIFTASSIGN Expr_18 {
		ASTExpr* left = (ASTExpr*)$1;
		ASTExpr* right = (ASTExpr*)$3;
		$$ = new ASTExprAssign(left, new ASTExprLShift(left->clone(), right, @3), @$);}
	// Right Shift Assignment
	| Expr_17 RSHIFTASSIGN Expr_18 {
		ASTExpr* left = (ASTExpr*)$1;
		ASTExpr* right = (ASTExpr*)$3;
		$$ = new ASTExprAssign(left, new ASTExprRShift(left->clone(), right, @3), @$);}
	// Bitwise And Assignment
	| Expr_17 BITANDASSIGN Expr_18 {
		ASTExpr* left = (ASTExpr*)$1;
		ASTExpr* right = (ASTExpr*)$3;
		$$ = new ASTExprAssign(left, new ASTExprBitAnd(left->clone(), right, @3), @$);}
	// BitNot Assignment
	// `a ~= b` == `a &= ~b` == `a = a & ~b`
	| Expr_17 BITNOTASSIGN Expr_18 {
		ASTExpr* left = (ASTExpr*)$1;
		ASTExpr* right = (ASTExpr*)$3;
		ASTExprBitAnd* rval = new ASTExprBitAnd(left->clone(), new ASTExprBitNot(right, @$), @3);
		$$ = new ASTExprAssign(left, rval, @$);}
	// Bitwise Xor Assignment
	| Expr_17 BITXORASSIGN Expr_18 {
		ASTExpr* left = (ASTExpr*)$1;
		ASTExpr* right = (ASTExpr*)$3;
		$$ = new ASTExprAssign(left, new ASTExprBitXor(left->clone(), right, @3), @$);}
	// Bitwise Or Assignment
	| Expr_17 BITORASSIGN Expr_18 {
		ASTExpr* left = (ASTExpr*)$1;
		ASTExpr* right = (ASTExpr*)$3;
		$$ = new ASTExprAssign(left, new ASTExprBitOr(left->clone(), right, @3), @$);}
	// Logical And Assignment
	| Expr_17 ANDASSIGN Expr_18 {
		ASTExpr* left = (ASTExpr*)$1;
		ASTExpr* right = (ASTExpr*)$3;
		$$ = new ASTExprAssign(left, new ASTExprAnd(left->clone(), right, @3), @$);}
	// Logical Or Assignment
	| Expr_17 ORASSIGN Expr_18 {
		ASTExpr* left = (ASTExpr*)$1;
		ASTExpr* right = (ASTExpr*)$3;
		$$ = new ASTExprAssign(left, new ASTExprOr(left->clone(), right, @3), @$);}
		 ;

Expression : Expr_18 {$$ = $1;};

Statement_Expression :
	Expression {
		ASTExpr* expr = (ASTExpr*)$1;
		expr = handle_statement_expr(expr);
		$$ = expr;}
	;

Expression_Constant :
	Expression {
		ASTExpr* content = (ASTExpr*)$1;
		$$ = new ASTExprConst(content, @$);}
	;

Expression_Const_Range :
	Expression_Range {
		ASTRange* range = (ASTRange*)$1;
		ASTExpr* start = range->start.release();
		range->start = new ASTExprConst(start, start->location);
		ASTExpr* end = range->end.release();
		range->end = new ASTExprConst(end, end->location);
		$$ = range;
	};
	
Expression_Range :
	//Classic A...B -> A <= x <= B
	Expression RANGE Expression {
		ASTExpr* start = (ASTExpr*)$1;
		ASTExpr* end = (ASTExpr*)$3;
		$$ = new ASTRange(start, end, ASTRange::RANGE_LR, @$);}
	//New A=..=B -> A <= x <= B
	| Expression RANGE_LR Expression {
		ASTExpr* start = (ASTExpr*)$1;
		ASTExpr* end = (ASTExpr*)$3;
		$$ = new ASTRange(start, end, ASTRange::RANGE_LR, @$);}
	//New A=..B -> A <= x < B
	| Expression RANGE_L Expression {
		ASTExpr* start = (ASTExpr*)$1;
		ASTExpr* end = (ASTExpr*)$3;
		$$ = new ASTRange(start, end, ASTRange::RANGE_L, @$);}
	//New A..=B -> A < x <= B
	| Expression RANGE_R Expression {
		ASTExpr* start = (ASTExpr*)$1;
		ASTExpr* end = (ASTExpr*)$3;
		$$ = new ASTRange(start, end, ASTRange::RANGE_R, @$);}
	//New A..B -> A < x < B
	| Expression RANGE_N Expression {
		ASTExpr* start = (ASTExpr*)$1;
		ASTExpr* end = (ASTExpr*)$3;
		$$ = new ASTRange(start, end, ASTRange::RANGE_N, @$);}
	//Mathematical [A, B] -> A <= x <= B
	| LBRACKET Expression COMMA Expression RBRACKET {
		ASTExpr* start = (ASTExpr*)$2;
		ASTExpr* end = (ASTExpr*)$4;
		$$ = new ASTRange(start, end, ASTRange::RANGE_LR, @$);}
	//Mathematical [A, B) -> A <= x < B
	| LBRACKET Expression COMMA Expression RPAREN {
		ASTExpr* start = (ASTExpr*)$2;
		ASTExpr* end = (ASTExpr*)$4;
		$$ = new ASTRange(start, end, ASTRange::RANGE_L, @$);}
	//Mathematical (A, B] -> A < x <= B
	| LPAREN Expression COMMA Expression RBRACKET {
		ASTExpr* start = (ASTExpr*)$2;
		ASTExpr* end = (ASTExpr*)$4;
		$$ = new ASTRange(start, end, ASTRange::RANGE_R, @$);}
	//Mathematical (A, B) -> A < x < B
	| LPAREN Expression COMMA Expression RPAREN {
		ASTExpr* start = (ASTExpr*)$2;
		ASTExpr* end = (ASTExpr*)$4;
		$$ = new ASTRange(start, end, ASTRange::RANGE_N, @$);}
	;

////////////////////////////////////////////////////////////////
// Literals

Literal :
	NUMBER {
		ASTFloat* val = (ASTFloat*)$1;
		$$ = new ASTNumberLiteral(val, @$);}
	| LONGNUMBER {
		ASTFloat* val = (ASTFloat*)$1;
		$$ = new ASTLongNumberLiteral(val, @$);}
	| SINGLECHAR {
		ASTString* as = (ASTString*)$1;
		ASTFloat* number = new ASTFloat(int(as->getValue().at(1)), 0, @$);
		$$ = new ASTCharLiteral(number, @$);}
	| Literal_String {$$ = $1;}
	| Literal_Bool {$$ = $1;}
	| Literal_Array {$$ = $1;}
	| OPTIONVALUE LPAREN IDENTIFIER RPAREN {
		ASTString* name = (ASTString*)$3;
		$$ = new ASTOptionValue(name->getValue(), @$);
		delete name;}
	| ISINCLUDED LPAREN IMPORTSTRING RPAREN {
		ASTString* name = (ASTString*)$3;
		$$ = new ASTIsIncluded(name->getValue(), @$);
		delete name;}
	;

QuotedString :
	QuotedString QUOTEDSTRING {
		ASTString* str = (ASTString*)$1;
		ASTString* rawstr = (ASTString*)$2;
		str->append(rawstr->getValue());
		delete rawstr;
		$$ = str;}
	| QUOTEDSTRING {$$ = $1;}
	;

Literal_String :
	QuotedString {
		ASTString* rawstring = (ASTString*)$1;
		ASTStringLiteral* str = new ASTStringLiteral(*rawstring);
		delete rawstring;
		$$ = str;}
	;


Literal_Bool :
	ZTRUE {$$ = new ASTBoolLiteral(true, @$);}
	| ZFALSE {$$ = new ASTBoolLiteral(false, @$);}
	;

Literal_Array :
	// (int32_t[5]){1, 2, 3}
	LT DataType LBRACKET Expression_Constant RBRACKET GT
		  LBRACE Literal_Array_Body Trail_Comma_RBrace
	{
		ASTDataType* type = (ASTDataType*)$2;
		ASTExpr* size = (ASTExpr*)$4;
		ASTArrayLiteral* al = (ASTArrayLiteral*)$8;
		al->type = type;
		al->size = size;
		al->location = @$;
		$$ = al;
	}
	// (int32_t[5]){}
	| LT DataType LBRACKET Expression_Constant RBRACKET
		  GT LBRACE RBRACE
	{
		ASTDataType* type = (ASTDataType*)$2;
		ASTExpr* size = (ASTExpr*)$4;
		ASTArrayLiteral* al = new ASTArrayLiteral(@$);
		al->type = type;
		al->size = size;
		$$ = al;
	}
	// {1, 2, 3}
	| LBRACE Literal_Array_Body Trail_Comma_RBrace {
		ASTArrayLiteral* al = (ASTArrayLiteral*)$2;
		al->location = @$;
		$$ = al;}
	;

Literal_Array_Body :
	Literal_Array_Body COMMA Expression {
		ASTArrayLiteral* al = (ASTArrayLiteral*)$1;
		ASTExpr* element = (ASTExpr*)$3;
		al->elements.push_back(element);
		$$ = al;}
	| Expression {
		ASTExpr* element = (ASTExpr*)$1;
		ASTArrayLiteral* al = new ASTArrayLiteral(@$);
		al->elements.push_back(element);
		$$ = al;}
	;

////////////////////////////////////////////////////////////////

%%

/*        programs */

std::string yyerrstr(string const& msg, int32_t row, int32_t col, char const* txt)
{
	ostringstream out;
	out << msg << " ["
	    << curfilename << " "
	    << "Line " << row << " "
	    << "Column " << col;
	if (yyleng)
	    out << " '" << txt << "'";
	out << "]";
	return out.str();
}
void yymsg(string const& message, int32_t row, int32_t col, char const* txt)
{
	zconsole_info(yyerrstr(message,row,col,txt).c_str());
}
void yywarn(string const& message, int32_t row, int32_t col, char const* txt)
{
	zconsole_warn(yyerrstr(message,row,col,txt).c_str());
	zparser_warn_out(message);
}
void yyerrmsg(string const& message, int32_t row, int32_t col, char const* txt)
{
	zconsole_error(yyerrstr(message,row,col,txt).c_str());
	zparser_error_out(message);
}
void yydb(string const& message, int32_t row, int32_t col, char const* txt)
{
	zconsole_db(yyerrstr(message,row,col,txt).c_str());
}

void yyerror(std::unique_ptr<ASTFile>&, const char *s)
{
	yyerrmsg(s);
}

namespace ZScript
{
	std::unique_ptr<ASTFile> parseFile(std::string const& filename)
	{
		std::unique_ptr<ASTFile> result;

		// Reset lexer.
		yyin = NULL;
		resetLexer();

		// Read in the file.
		yyin = fopen(filename.c_str(), "r");
		yyout = std::tmpfile();
		if (!yyin)
		{
			zconsole_error("Can't open input file");
			return nullptr;
		}
		curfilename = filename;

		// Run the parser.
		if (yyparse(result))
		{
			result.reset();
		}
		fclose(yyout);
		fclose(yyin);

		return std::unique_ptr<ASTFile>(result.release());
	}
};
