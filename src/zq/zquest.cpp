
//--------------------------------------------------------
//  Zelda Classic
//  by Jeremy Craner, 1999-2000
//
//  zquest.cc
//
//  Main code for the quest editor.
//
//--------------------------------------------------------

/*
  #define  INTERNAL_VERSION  0xA721
  */


#define MIDI_TRACK_BUFFER_SIZE 50

#include "precompiled.h" //always first
#include <memory>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sstream>
#include <ctype.h>
#include <assert.h>
#include <time.h>
#include <vector>
#ifdef __APPLE__
// malloc.h is deprecated, but malloc also lives in stdlib
#include <stdlib.h>
#else
#include <malloc.h>
#endif

#include "parser/Compiler.h"
#include "base/zc_alleg.h"
#include "particles.h"
#include "dialog/alert.h"
#include "dialog/alertfunc.h"
particle_list particles;
void setZScriptVersion(int32_t) { } //bleh...

#include <al5img.h>
#include <loadpng.h>

#include "dialog/cheat_codes.h"
#include "dialog/room.h"
#include "dialog/set_password.h"
#include "dialog/foodlg.h"
#include "dialog/quest_rules.h"
#include "dialog/script_rules.h"
#include "dialog/headerdlg.h"
#include "dialog/ffc_editor.h"

#include "base/gui.h"
#include "zc_list_data.h"
#include "editbox.h"
#include "zq_misc.h"
#include "zq_tiles.h"                                       // tile and combo code

#include "zquest.h"
#include "zquestdat.h"
#include "ffasm.h"
#include "render.h"

// the following are used by both zelda.cc and zquest.cc
#include "base/zdefs.h"
#include "tiles.h"
#include "base/colors.h"
#include "qst.h"
#include "base/zsys.h"
#include "base/zapp.h"
#include "play_midi.h"
#include "zcmusic.h"

#include "midi.h"
#include "sprite.h"
#include "items.h"
#include "fontsdat.h"
#include "base/jwinfsel.h"
#include "zq_class.h"
#include "subscr.h"
#include "zq_subscr.h"
#include "ffscript.h"
#include "EditboxNew.h"
#include "sfx.h"
#include "zq_custom.h" // custom items and guys
#include "zq_strings.h"
#include "questReport.h"
#include "ffasmexport.h"
#include <fstream>
#include "base/module.h"
//#include "zscrdata.h"
#include "drawing.h"
#include "ConsoleLogger.h"

extern CConsoleLoggerEx parser_console;
//Windows mmemory tools
#ifdef _WIN32
#include <windows.h>
#include <stdio.h>
#include <psapi.h>
#pragma comment(lib, "psapi.lib") // Needed to avoid linker issues. -Z
#endif

#ifdef __EMSCRIPTEN__
#include <emscripten/emscripten.h>
#endif

//SDL_Surface *sdl_screen;

#ifdef ALLEGRO_DOS
static const char *data_path_name   = "dos_data_path";
static const char *midi_path_name   = "dos_midi_path";
static const char *image_path_name  = "dos_image_path";
static const char *tmusic_path_name = "dos_tmusic_path";
static const char *last_quest_name  = "dos_last_quest";
static const char *qtname_name      = "dos_qtname%d";
static const char *qtpath_name      = "dos_qtpath%d";
#elif defined(ALLEGRO_WINDOWS)
static const char *data_path_name   = "win_data_path";
static const char *midi_path_name   = "win_midi_path";
static const char *image_path_name  = "win_image_path";
static const char *tmusic_path_name = "win_tmusic_path";
static const char *last_quest_name  = "win_last_quest";
static const char *qtname_name      = "win_qtname%d";
static const char *qtpath_name      = "win_qtpath%d";
#elif defined(ALLEGRO_LINUX)
static const char *data_path_name   = "linux_data_path";
static const char *midi_path_name   = "linux_midi_path";
static const char *image_path_name  = "linux_image_path";
static const char *tmusic_path_name = "linux_tmusic_path";
static const char *last_quest_name  = "linux_last_quest";
static const char *qtname_name      = "linux_qtname%d";
static const char *qtpath_name      = "linux_qtpath%d";
#elif defined(__APPLE__)
static const char *data_path_name   = "macosx_data_path";
static const char *midi_path_name   = "macosx_midi_path";
static const char *image_path_name  = "macosx_image_path";
static const char *tmusic_path_name = "macosx_tmusic_path";
static const char *last_quest_name  = "macosx_last_quest";
static const char *qtname_name      = "macosx_qtname%d";
static const char *qtpath_name      = "macosx_qtpath%d";
#endif

#include "base/win32.h"

#include "zq_init.h"
#include "zq_doors.h"
#include "zq_cset.h"

#ifdef _MSC_VER
#include <crtdbg.h>

#endif

#define zc_max(a,b)  ((a)>(b)?(a):(b))
#define zc_min(a,b)  ((a)<(b)?(a):(b))

// MSVC fix
#if _MSC_VER >= 1900
FILE _iob[] = { *stdin, *stdout, *stderr };
extern "C" FILE * __cdecl __iob_func(void) { return _iob; }
#endif

extern byte monochrome_console;

#include "ConsoleLogger.h"

CConsoleLoggerEx coloured_console;
extern CConsoleLoggerEx zscript_coloured_console;

uint8_t console_is_open = 0;
uint8_t __isZQuest = 1; //Shared functionscan reference this. -Z

#include "base/util.h"

#ifdef __EMSCRIPTEN__
#include "base/emscripten_utils.h"
#endif

using namespace util;

using std::vector;
using std::map;
using std::stringstream;

FFScript FFCore;
ZModule zcm;
zcmodule moduledata;

void load_size_poses();
void do_previewtext();
bool do_slots(map<string, disassembled_script_data> &scripts);
void do_script_disassembly(map<string, disassembled_script_data>& scripts, bool fromCompile);

int32_t startdmapxy[6] = {-1000, -1000, -1000, -1000, -1000, -1000};
bool cancelgetnum=false;

int32_t tooltip_timer=0, tooltip_maxtimer=30, tooltip_current_combo=0, tooltip_current_ffc=0;
int32_t mousecomboposition;

int32_t original_playing_field_offset=0;
int32_t playing_field_offset=original_playing_field_offset;
int32_t passive_subscreen_height=56;
int32_t passive_subscreen_offset=0;

bool disable_saving=false, OverwriteProtection;
bool halt=false;
bool show_sprites=true;
bool show_hitboxes = false;

// Used to find FFC script names
vector<string> asffcscripts;
vector<string> asglobalscripts;
vector<string> asitemscripts;
vector<string> asnpcscripts;
vector<string> aseweaponscripts;
vector<string> aslweaponscripts;
vector<string> asplayerscripts;
vector<string> asdmapscripts;
vector<string> asscreenscripts;
vector<string> asitemspritescripts;
vector<string> ascomboscripts;
vector<string> asgenericscripts;

vector<string> ZQincludePaths;

int32_t CSET_SIZE = 16;
int32_t CSET_SHFT = 4;
//editbox_data temp_eb_data;
/*
  #define CSET(x)         ((x)<<CSET_SHFT)
  #define csBOSS          14
  */

/*
  enum { m_block, m_coords, m_flags, m_guy, m_warp, m_misc, m_layers,
  m_menucount };
  */
void update_combo_cycling();
void update_freeform_combos();

/*
  #define MAXMICE 14
  #define MAXARROWS 8
  #define SHADOW_DEPTH 2
  */
int32_t coord_timer=0, coord_frame=0;
int32_t blackout_color, zq_screen_w, zq_screen_h;
int32_t draw_mode=0;

size_and_pos minimap;

size_and_pos map_page_bar[9];
int32_t mappage_count = 9;

size_and_pos combolist[4];
size_and_pos combolistscrollers[4];
int32_t num_combo_cols = 4;

size_and_pos compactbtn;
size_and_pos mainbar;

size_and_pos screrrorpos;

size_and_pos comboaliaslist[4];
size_and_pos comboalias_preview;
size_and_pos combopool_preview;
size_and_pos combopool_prevbtn;

size_and_pos combo_merge_btn;

size_and_pos combo_preview;
size_and_pos combolist_window;
size_and_pos drawmode_btn;
size_and_pos panel[9];
size_and_pos favorites_window;
size_and_pos favorites_list;
size_and_pos favorites_x;
size_and_pos commands_window;
size_and_pos commands_list;
size_and_pos layer_panel;

size_and_pos tooltip_box;
size_and_pos tooltip_trigger;
size_and_pos tooltip_highlight;

size_and_pos itemsqr_pos;
size_and_pos flagsqr_pos;
size_and_pos stairsqr_pos;
size_and_pos warparrival_pos;
size_and_pos warpret_pos[4];
size_and_pos enemy_prev_pos;

size_and_pos txtoffs_single;
size_and_pos txtoffs_double_1;
size_and_pos txtoffs_double_2;
int32_t panel_align = 1;

int32_t command_buttonwidth = 88;
int32_t command_buttonheight = 19;

int32_t layerpanel_buttonwidth = 58;
int32_t layerpanel_buttonheight = 16;

int32_t layerpanel_checkbox_hei = 13;
int32_t layerpanel_checkbox_wid = 13;

int32_t favorite_combos[MAXFAVORITECOMBOS];
int32_t favorite_comboaliases[MAXFAVORITECOMBOALIASES];
int32_t favorite_commands[MAXFAVORITECOMMANDS];

void write_fav_command(int ind, int val)
{
	favorite_commands[ind] = val;
    char buf[32];
	sprintf(buf, "command%02d", ind+1);
	zc_set_config("zquest", buf, val);
}

#define MAXPOOLCOMBOS MAXFAVORITECOMBOS

struct cmbdat_pair
{
    int32_t data;
    byte cset;
    cmbdat_pair() { clear(); }
    void clear()
    {
        data = -1;
        cset = 0;
    }
    bool valid() const
    {
        return data > -1;
    }
};
bool pool_dirty=true;
cmbdat_pair pool_combos[MAXPOOLCOMBOS];
static std::vector<byte> pool;

bool pool_valid()
{
	if(pool_dirty)
	{
		pool.clear();
		for(auto q = 0; q < MAXPOOLCOMBOS; ++q)
		{
			if(pool_combos[q].valid())
				pool.push_back(q);
		}
		pool_dirty = false;
	}
	return pool.size() > 0;
}
cmbdat_pair const& get_pool_combo()
{
	if(!pool_valid()) return pool_combos[0];
	auto ind = zc_rand(pool.size()-1);
	return pool_combos[pool.at(ind)];
}

int32_t mapscreen_x, mapscreen_y, mapscreensize, showedges, showallpanels;
int32_t mouse_scroll_h;


int32_t readsize, writesize;
bool fake_pack_writing=false;

int32_t showxypos_x;
int32_t showxypos_y;
int32_t showxypos_w;
int32_t showxypos_h;
int32_t showxypos_color;
int32_t showxypos_ffc=-1000;
bool showxypos_icon=false;

int32_t showxypos_cursor_x;
int32_t showxypos_cursor_y;
bool showxypos_cursor_icon=false;
int32_t showxypos_cursor_color;
bool showxypos_dummy = false;

bool canfill=true;                                          //to prevent double-filling (which stops undos)
bool resize_mouse_pos=false;                                //for eyeball combos
int32_t lens_hint_item[MAXITEMS][2];                            //aclk, aframe
int32_t lens_hint_weapon[MAXWPNS][5];                           //aclk, aframe, dir, x, y
//int32_t mode, switch_mode, orig_mode;
int32_t tempmode=GFX_AUTODETECT;
RGB_MAP zq_rgb_table;
COLOR_MAP trans_table, trans_table2;
char *datafile_str;
DATAFILE *zcdata=NULL, *fontsdata=NULL, *sfxdata=NULL;
MIDI *song=NULL;
BITMAP *menu1, *menu3, *mapscreenbmp, *tmp_scr, *screen2, *mouse_bmp[MOUSE_BMP_MAX][4], *mouse_bmp_1x[MOUSE_BMP_MAX][4], *icon_bmp[ICON_BMP_MAX][4], *select_bmp[2], *dmapbmp_small, *dmapbmp_large;
BITMAP *arrow_bmp[MAXARROWS],*brushbmp, *brushscreen, *tooltipbmp;//*brushshadowbmp;
byte *colordata=NULL, *trashbuf=NULL;
itemdata *itemsbuf;
wpndata  *wpnsbuf;
comboclass *combo_class_buf;
guydata  *guysbuf;
item_drop_object    item_drop_sets[MAXITEMDROPSETS];
newcombo curr_combo;
PALETTE RAMpal;
midi_info Midi_Info;
bool zq_showpal=false;
bool combo_cols=true;
bool is_large = true;
bool is_compact = false;

int pixeldb = 1;
bool large_merged_combopane = false;
bool compact_merged_combopane = true;
int combo_col_scale = 1;

byte BMM = 3; // Big Minimap

script_data *ffscripts[NUMSCRIPTFFC];
script_data *itemscripts[NUMSCRIPTITEM];
script_data *guyscripts[NUMSCRIPTGUYS];
script_data *wpnscripts[NUMSCRIPTWEAPONS];
script_data *lwpnscripts[NUMSCRIPTWEAPONS];
script_data *ewpnscripts[NUMSCRIPTWEAPONS];
script_data *globalscripts[NUMSCRIPTGLOBAL];
script_data *genericscripts[NUMSCRIPTSGENERIC];
script_data *playerscripts[NUMSCRIPTPLAYER];
script_data *screenscripts[NUMSCRIPTSCREEN];
script_data *dmapscripts[NUMSCRIPTSDMAP];
script_data *itemspritescripts[NUMSCRIPTSITEMSPRITE];
script_data *comboscripts[NUMSCRIPTSCOMBODATA];

// Dummy - needed to compile, but unused
refInfo ffcScriptData[MAXFFCS];

extern string zScript;
char zScriptBytes[512];
char zLastVer[512] = { 0 };
SAMPLE customsfxdata[WAV_COUNT];
uint8_t customsfxflag[WAV_COUNT>>3];
int32_t sfxdat=1;

extern void deallocate_biic_list();

zinitdata zinit;

int32_t onImport_ComboAlias();
int32_t onExport_ComboAlias();

void set_console_state();

void clearConsole()
{
	if(!console_is_open) return;
	zscript_coloured_console.cls(CConsoleLoggerEx::COLOR_BACKGROUND_BLACK);
	zscript_coloured_console.gotoxy(0,0);
	zscript_coloured_console.cprintf( CConsoleLoggerEx::COLOR_BLUE | CConsoleLoggerEx::COLOR_INTENSITY |
		CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"ZQuest Creator Logging Console\n");
}

void initConsole()
{
	if(console_is_open) return;
	console_is_open = 1;
	set_console_state();
	zscript_coloured_console.Create("ZQuest Creator Logging Console", 600, 200);
	clearConsole();
}

void killConsole()
{
	if(!console_is_open) return;
	console_is_open = 0;
	set_console_state();
	zscript_coloured_console.kill();
}

int32_t toggleConsole()
{
	console_is_open ? killConsole() : initConsole();
	zc_set_config("zquest","open_debug_console",console_is_open?1:0);
	return D_O_K;
}

typedef struct map_and_screen
{
    int32_t map;
    int32_t screen;
} map_and_screen;

typedef int32_t (*intF)();
typedef struct command_pair
{
    char name[80];
    int32_t flags;
    intF command;
} command_pair;

extern command_pair commands[cmdMAX];

map_and_screen map_page[9]= {{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0}};

static int32_t do_OpenQuest()
{
	//clear the panel recent screen buttons to prevent crashes from invalid maps
	for ( int32_t q = 0; q < 9; q++ )
	{
		map_page[q].map = 0;
		map_page[q].screen = 0;
	}
	return onOpen();
}

static int32_t do_NewQuest()
{
	//clear the panel recent screen buttons to prevent crashes from invalid maps
	for ( int32_t q = 0; q < 9; q++ )
	{
		map_page[q].map = 0;
		map_page[q].screen = 0;
	}
	Map.setCurrMap(0);
	Map.setCurrScr(0);
	return onNew();
}

int32_t alignment_arrow_timer=0;
int32_t  Flip=0,Combo=0,CSet=2,First[3]= {0,0,0},current_combolist=0,current_comboalist=0,current_cpoollist=0,current_mappage=0;
int32_t  Flags=0,Flag=0,menutype=(m_block);
int32_t MouseScroll = 0, SavePaths = 0, CycleOn = 0, ShowGrid = 0, GridColor = 0,
	TileProtection = 0, InvalidStatic = 0, NoScreenPreview = 0, MMapCursorStyle = 0,
	BlinkSpeed = 20, UseSmall = 0, RulesetDialog = 0, EnableTooltips = 0,
	TooltipsHighlight = 0, ShowFFScripts = 0, ShowSquares = 0, ShowFFCs = 0,
	ShowInfo = 0, skipLayerWarning = 0, WarnOnInitChanged = 0, DisableLPalShortcuts = 1,
	DisableCompileConsole = 0, numericalFlags = 0;
int32_t FlashWarpSquare = -1, FlashWarpClk = 0; // flash the destination warp return when ShowSquares is active
uint8_t ViewLayer3BG = 0, ViewLayer2BG = 0; 
int32_t window_width, window_height;
bool Vsync = false, ShowFPS = false, SaveDragResize = false, DragAspect = false, SaveWinPos=false;
double aspect_ratio = LARGE_H / double(LARGE_W);
int32_t ComboBrush = 0;                                             //show the brush instead of the normal mouse
int32_t ComboBrushPause = 0;                                        //temporarily disable the combo brush
int32_t FloatBrush = 0;                                             //makes the combo brush float a few pixels up and left
//complete with shadow
int32_t OpenLastQuest = 0;                                          //makes the program reopen the quest that was
//open at the time you quit
int32_t ShowMisalignments = 0;                                      //makes the program display arrows over combos that are
//not aligned with the next screen.
int32_t AnimationOn = 0;                                            //animate the combos in zquest?
int32_t AutoBackupRetention = 0;                                    //use auto-backup feature?  if so, how many backups (1-10) to keep
int32_t AutoSaveInterval = 0;                                       //how often a timed autosave is made (not overwriting the current file)
int32_t UncompressedAutoSaves = 0;                                  //should timed saves be uncompressed/encrypted?
int32_t KeyboardRepeatDelay = 0;                                    //the time in milliseconds after holding down a key that the key starts to repeat
int32_t KeyboardRepeatRate = 0;                                     //the time in milliseconds between each repetition of a repeated key

time_t auto_save_time_start, auto_save_time_current;
double auto_save_time_diff = 0;
int32_t AutoSaveRetention = 0;                                      //how many autosaves of a quest to keep
int32_t ImportMapBias = 0;                                          //tells what has precedence on map importing
int32_t BrushWidth=1, BrushHeight=1;
bool quit=false,saved=true;
bool __debug=false;
//bool usetiles=true;
int32_t LayerMaskInt[7]={0};
int32_t CurrentLayer=0;
int32_t DuplicateAction[4]={0};
int32_t OnlyCheckNewTilesForDuplicates = 0;
int32_t try_recovering_missing_scripts = 0;

uint8_t PreFillTileEditorPage = 0, PreFillComboEditorPage = 0, PreFillMapTilePage = 0;
int32_t DMapEditorLastMaptileUsed = 0;

/*
  , HorizontalDuplicateAction;
  int32_t VerticalDuplicateAction, BothDuplicateAction;
  */
word msg_count = 0, qt_count = 0;
int32_t LeechUpdate = 0;
int32_t LeechUpdateTiles = 0;
int32_t SnapshotFormat = 0;

int32_t memrequested = 0;
byte Color = 0;
extern int32_t jwin_pal[jcMAX];
int32_t gui_colorset=99;

combo_alias combo_aliases[MAXCOMBOALIASES];
static int32_t combo_apos=0; //currently selected combo alias
static int32_t combo_alistpos[4]= {0,0,0,0}; //first displayed combo alias
int32_t alias_origin=0;
int32_t alias_cset_mod=0;

combo_pool combo_pools[MAXCOMBOPOOLS];
static int32_t combo_pool_pos=0; //currently selected combo pool
static int32_t combo_pool_listpos[4]= {0,0,0,0}; //first displayed combo pool
bool weighted_cpool = true;
bool cpool_prev_visible = false;

bool trip=false;

int32_t fill_type=1;

bool first_save=false;
char *filepath,*temppath,*midipath,*datapath,*imagepath,*tmusicpath,*last_timed_save;
char *helpbuf, *shieldblockhelpbuf, *zscripthelpbuf, *zstringshelpbuf;
string helpstr, shieldblockhelpstr, zscripthelpstr, zstringshelpstr;

ZCMUSIC *zcmusic = NULL;
int32_t midi_volume = 255;
extern int32_t prv_mode;
int32_t prv_warp = 0;
int32_t prv_twon = 0;
int32_t ff_combo = 0;

int32_t Frameskip = 0, RequestedFPS = 60, zqUseWin32Proc = 1, ForceExit = 0;
int32_t zqColorDepth = 8;
int32_t joystick_index=0;

char *getBetaControlString();

void set_last_timed_save(char const* buf)
{
	if(buf && buf[0])
	{
		if(buf != last_timed_save)
			strcpy(last_timed_save, buf);
    }
	else
	{
		last_timed_save[0] = 0;
		buf = nullptr;
	}
	zc_set_config("zquest","last_timed_save",buf);
}

void loadlvlpal(int32_t level);
bool get_debug()
{
    return __debug;
    //return true;
}

void set_debug(bool d)
{
    __debug=d;
    return;
}

// **** Timers ****

volatile int32_t lastfps=0;
volatile int32_t framecnt=0;
volatile int32_t myvsync = 0;

void myvsync_callback()
{
    ++myvsync;
}

END_OF_FUNCTION(myvsync_callback)

// quest data
zquestheader header;
byte                quest_rules[QUESTRULES_NEW_SIZE];
byte                extra_rules[EXTRARULES_SIZE];
byte                midi_flags[MIDIFLAGS_SIZE];
byte                music_flags[MUSICFLAGS_SIZE];
word                map_count;
miscQdata           misc;
vector<mapscr> TheMaps;
zcmap               *ZCMaps;
byte                *quest_file;
dmap                *DMaps;
MsgStr              *MsgStrings;
int32_t					msg_strings_size;
//DoorComboSet      *DoorComboSets;
zctune              *customtunes;
//emusic            *enhancedMusic;
ZCHEATS             zcheats;
byte                use_cheats;
byte                use_tiles;
extern zinitdata    zinit;
char                palnames[MAXLEVELS][17];
quest_template      QuestTemplates[MAXQTS];
char                fontsdat_sig[52];
char                zquestdat_sig[52];
char                qstdat_sig[52];
char                sfxdat_sig[52];
char		    qstdat_str[2048];
miscQdata           QMisc;

int32_t gme_track=0;

int32_t dlevel; // just here until gamedata is properly done

bool bad_version(int32_t ver)
{
    if(ver < 0x170)
        return true;
        
    return false;
}

zfix HeroModifiedX()
{
    if(resize_mouse_pos)
    {
        return (zfix)((gui_mouse_x()/mapscreensize)-((8*mapscreensize)-1)+(showedges?8:0));
    }
    else
    {
        return (zfix)(gui_mouse_x()-7);
    }
}

zfix HeroModifiedY()
{
    if(resize_mouse_pos)
    {
        return (zfix)((gui_mouse_y()/mapscreensize)-((8*mapscreensize)-1)-16+(showedges?16:0));
    }
    else
    {
        return (zfix)(gui_mouse_y()-7);
    }
}

static MENU import_250_menu[] =
{
    { (char *)"&DMaps",                     onImport_DMaps,            NULL,                     0,            NULL   },
    
    
    
    { (char *)"&Combo Table",               onImport_Combos,           NULL,                     0,            NULL   },
    { (char *)"&Combo Alias",               onImport_ComboAlias,       NULL,                     0,            NULL   },
    // { (char *)"&Graphics Pack",             onImport_ZGP,              NULL,                     0,            NULL   },
    { (char *)"&Quest Template",            onImport_ZQT,              NULL,                     0,            NULL   },
    { (char *)"&Unencoded Quest",           onImport_UnencodedQuest,   NULL,                     0,            NULL   },
    {  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

static MENU import_graphics[]=
{
	{ (char *)"&Palettes",                  onImport_Pals,             NULL,                     0,            NULL   },
	{ (char *)"",                           NULL,                      NULL,                     0,            NULL   },
	{ (char *)"Tileset (&Full)",                     onImport_Tiles,            NULL,                     0,            NULL   },
	{ (char *)"&Tile Pack",           	    onImport_Tilepack,   NULL,                     0,            NULL   },
	{ (char *)"T&ile Pack to...",           	    onImport_Tilepack_To,   NULL,                     0,            NULL   },
    
	{ (char *)"",                           NULL,                      NULL,                     0,            NULL   },
    
    { (char *)"&Combo Set (Range)",               onImport_Combos,           NULL,                     0,            NULL   },
    { (char *)"Combo Pack (Full, 1:1)",           	    onImport_Combopack,   NULL,                     0,            NULL   },
    { (char *)"Combo Pack to... (Dest)",           	    onImport_Combopack_To,   NULL,                     0,            NULL   },
    { (char *)"",                           NULL,                      NULL,                     0,            NULL   },
    
    { (char *)"Combo &Alias Pack",           	    onImport_Comboaliaspack,   NULL,                     0,            NULL   },
    { (char *)"Combo A&lias Pack to...",           	    onImport_Comboaliaspack_To,   NULL,                     0,            NULL   },
    { (char *)"",                           NULL,                      NULL,                     0,            NULL   },
    
    { (char *)"&Doorsets",           	    onImport_Doorset,   NULL,                     0,            NULL   },
    {  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

static MENU import_menu[] =
{
    
    { (char *)"&Enemies",                   onImport_Guys,             NULL,                     0,            NULL   },
    { (char *)"&Map",                       onImport_Map,              NULL,                     0,            NULL   },
    { (char *)"&DMaps",                     onImport_DMaps,            NULL,                     0,            NULL   },
    { (char *)"Su&bscreen",                 onImport_Subscreen,        NULL,                     0,            NULL   },
    { (char *)"&String Table",              onImport_Msgs,             NULL,                     0,            NULL   },
    // { (char *)"",                           NULL,                      NULL,                     0,            NULL   },
    // { (char *)"ZASM Script",           onExport_ZASM,   NULL,                     0,            NULL   },
    { (char *)"",                           NULL,                      NULL,                     0,            NULL   },
    { (char *)"&Graphics",                  NULL,                      import_graphics,               0,            NULL   },
    { (char *)"",                           NULL,                      NULL,                     0,            NULL   },
    { (char *)"2.50 (Broken)",                  NULL,                      import_250_menu,               0,            NULL   },
    {  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

static MENU export_250_menu[] =
{
    
    { (char *)"&DMaps",                     onExport_DMaps,            NULL,                     0,            NULL   },
   
    { (char *)"&Combo Table",               onExport_Combos,           NULL,                     0,            NULL   },
    { (char *)"&Combo Alias",               onExport_ComboAlias,       NULL,                     0,            NULL   },
    { (char *)"&Graphics Pack",             onExport_ZGP,              NULL,                     0,            NULL   },
    { (char *)"&Quest Template",            onExport_ZQT,              NULL,                     0,            NULL   },
    { (char *)"&Unencoded Quest",           onExport_UnencodedQuest,   NULL,                     0,            NULL   },
    {  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

static MENU zq_help_menu[] =
{
	{ (char *)"&Editor Help",                     onHelp,            NULL,                     0,            NULL   },
	{ (char *)"&ZScript Help",                     onZScripthelp,            NULL,                     0,            NULL   },
	{ (char *)"&Strings Help",                     onZstringshelp,            NULL,                     0,            NULL   },
	
	{  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

static MENU export_graphics[]=
{
	{ (char *)"&Palettes",                  onExport_Pals,             NULL,                     0,            NULL   },
	{ (char *)"",                           NULL,                      NULL,                     0,            NULL   },
	{ (char *)"Tileset (&Full)",                     onExport_Tiles,            NULL,                     0,            NULL   },
	{ (char *)"&Tile Pack",           	    onExport_Tilepack,   NULL,                     0,            NULL   },
	{ (char *)"",                           NULL,                      NULL,                     0,            NULL   },
    { (char *)"&Combo Set",               onExport_Combos,           NULL,                     0,            NULL   },
    
    { (char *)"Combo Pack",           	    onExport_Combopack,   NULL,                     0,            NULL   },
    { (char *)"",                           NULL,                      NULL,                     0,            NULL   },
    
    { (char *)"Combo &Alias Pack",           	    onExport_Comboaliaspack,   NULL,                     0,            NULL   },
    { (char *)"",                           NULL,                      NULL,                     0,            NULL   },
	{ (char *)"&Doorsets",           	    onExport_Doorset,   NULL,                     0,            NULL   },
	{  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

static MENU export_menu[] =
{
    
    { (char *)"&Enemies",                   onExport_Guys,             NULL,                     0,            NULL   },
    { (char *)"&Map",                       onExport_Map,              NULL,                     0,            NULL   },
    { (char *)"&DMaps",                       onExport_DMaps,              NULL,                     0,            NULL   },
    { (char *)"Su&bscreen",                 onExport_Subscreen,        NULL,                     0,            NULL   },
    { (char *)"",                           NULL,                      NULL,                     0,            NULL   },
       
    { (char *)"&String Table",              onExport_Msgs,             NULL,                     0,            NULL   },
    { (char *)"Text &Dump",                  onExport_MsgsText,         NULL,                     0,            NULL   },
    
    { (char *)"",                           NULL,                      NULL,                     0,            NULL   },
    { (char *)"&Graphics",                  NULL,                      export_graphics,               0,            NULL   },
    { (char *)"",                           NULL,                      NULL,                     0,            NULL   },
    
    { (char *)"2.50 (Broken)",                  NULL,                      export_250_menu,               0,            NULL   },
    
    {  NULL,                                NULL,                      NULL,                     0,            NULL   }
};


static MENU recent_menu[11];
static char rec_menu_fullpaths[10][512];
static char rec_menu_strs[10][64];

int32_t customOpen(char const* path);
void do_recent_quest(uint32_t ind)
{
	if(ind > 9) return;
	strcpy(temppath, rec_menu_fullpaths[ind]);
	customOpen(temppath);
}
int32_t do_RecentQuest_0() { do_recent_quest(0); return D_O_K; }
int32_t do_RecentQuest_1() { do_recent_quest(1); return D_O_K; }
int32_t do_RecentQuest_2() { do_recent_quest(2); return D_O_K; }
int32_t do_RecentQuest_3() { do_recent_quest(3); return D_O_K; }
int32_t do_RecentQuest_4() { do_recent_quest(4); return D_O_K; }
int32_t do_RecentQuest_5() { do_recent_quest(5); return D_O_K; }
int32_t do_RecentQuest_6() { do_recent_quest(6); return D_O_K; }
int32_t do_RecentQuest_7() { do_recent_quest(7); return D_O_K; }
int32_t do_RecentQuest_8() { do_recent_quest(8); return D_O_K; }
int32_t do_RecentQuest_9() { do_recent_quest(9); return D_O_K; }

void refresh_recent_menu()
{
	int32_t (*procs[10])(void) = { 
		do_RecentQuest_0, do_RecentQuest_1, do_RecentQuest_2, do_RecentQuest_3,
		do_RecentQuest_4, do_RecentQuest_5, do_RecentQuest_6,
		do_RecentQuest_7, do_RecentQuest_8, do_RecentQuest_9
	};
	for(auto q = 0; q < 10; ++q)
	{
        bool valid = rec_menu_fullpaths[q][0] != '-';
		recent_menu[q].text = rec_menu_strs[q];
		recent_menu[q].proc = valid ? procs[q] : nullptr;
		recent_menu[q].child = nullptr;
		recent_menu[q].flags = valid ? 0 : D_DISABLED;
		recent_menu[q].dp = rec_menu_fullpaths[q];
	}
	recent_menu[10].text = nullptr;
	recent_menu[10].proc = nullptr;
	recent_menu[10].child = nullptr;
	recent_menu[10].flags = 0;
	recent_menu[10].dp = nullptr;
}

void load_recent_quests()
{
	char configname[64] = "rec_qst_";
	char* ptr = &configname[strlen(configname)];
	char buf[512] = {0};
	for(auto q = 0; q < 10; ++q)
	{
		sprintf(ptr, "%d", q); //increment the configname value
		char const* qst_str = zc_get_config("zquest",configname,nullptr);
		if(qst_str[0])
		{
			strncpy(rec_menu_fullpaths[q], qst_str, 511);
			relativize_path(buf, rec_menu_fullpaths[q]);
			if(strlen(buf) > 62)
			{
				buf[60] = buf[61] = buf[62] = '.'; //add "..." as the last 3 characters
			}
			strncpy(rec_menu_strs[q], buf, 63);
		}
		else
		{
			strcpy(rec_menu_fullpaths[q], "---");
			strcpy(rec_menu_strs[q], "---");
		}
		rec_menu_fullpaths[q][511] = 0;
		rec_menu_strs[q][63] = 0;
	}
	refresh_recent_menu();
}

void write_recent_quests()
{
	char configname[64] = "rec_qst_";
	char* ptr = &configname[strlen(configname)];
	for(auto q = 0; q < 10; ++q)
	{
		sprintf(ptr, "%d", q); //increment the configname value
		zc_set_config("zquest",configname,(rec_menu_fullpaths[q][0]!='-') ? rec_menu_fullpaths[q] : nullptr);
	}
}

void update_recent_quest(char const* path)
{
	int32_t ind = -1;
	for(auto q = 0; q < 10; ++q)
	{
		if(!strcmp(path, rec_menu_fullpaths[q]))
		{
			ind = q;
			break;
		}
	}
	if(ind > -1)
	{
		for(auto q = ind; q > 0; --q)
		{
			strcpy(rec_menu_fullpaths[q], rec_menu_fullpaths[q-1]);
			strcpy(rec_menu_strs[q], rec_menu_strs[q-1]);
		}
	}
	else
	{
		int32_t free_ind = 9; //if none found, override the last index
		for(auto q = 0; q < 9; ++q)
		{
			if(rec_menu_fullpaths[q][0] == '-')
			{
				free_ind = q;
				break;
			}
		}
		
		for(auto q = free_ind; q > 0; --q)
		{
			strcpy(rec_menu_fullpaths[q], rec_menu_fullpaths[q-1]);
			strcpy(rec_menu_strs[q], rec_menu_strs[q-1]);
		}
	}
	char buf[512] = {0};
	strcpy(rec_menu_fullpaths[0], path);
	relativize_path(buf, rec_menu_fullpaths[0]);
	if(strlen(buf) > 62)
	{
		buf[60] = buf[61] = buf[62] = '.'; //add "..." as the last 3 characters
	}
	strncpy(rec_menu_strs[0], buf, 63);
	refresh_recent_menu();
	zc_set_config("zquest",last_quest_name,path);
	write_recent_quests();
}

void reload_zq_gui()
{
	init_custom_fonts();
	load_size_poses();
	refresh(rCLEAR|rALL);
}
void toggle_is_compact()
{
	is_compact = !is_compact;
	zc_set_config("ZQ_GUI","compact_mode",is_compact?1:0);
	reload_zq_gui();
}
void toggle_merged_mode()
{
	if(is_compact)
	{
		compact_merged_combopane = !compact_merged_combopane;
		zc_set_config("ZQ_GUI","merge_cpane_compact",compact_merged_combopane?1:0);
	}
	else
	{
		large_merged_combopane = !large_merged_combopane;
		zc_set_config("ZQ_GUI","merge_cpane_large",large_merged_combopane?1:0);
	}
	reload_zq_gui();
}

enum
{
	fileSave = 4,
	fileSaveAs,
	fileRevert
};

static MENU file_menu[] =
{
	{ (char *)"&New",                       do_NewQuest,               NULL,                     0,            NULL   },
	{ (char *)"&Open\tF3",                  do_OpenQuest,              NULL,                     0,            NULL   },
	{ (char *)"Recent\t ",                  NULL,                      recent_menu,              0,            NULL   },
	{ (char *)"",                           NULL,                      NULL,                     0,            NULL   },
	{ (char *)"&Save\tF2",                  onSave,                    NULL,                     0,            NULL   },
	{ (char *)"Save &as...",                onSaveAs,                  NULL,                     0,            NULL   },
	{ (char *)"&Revert",                    onRevert,                  NULL,                     0,            NULL   },
	{ (char *)"Quest &Templates...",        onQuestTemplates,          NULL,                     0,            NULL   },
	{ (char *)"",                           NULL,                      NULL,                     0,            NULL   },
	{ (char *)"&Import\t ",                 NULL,                      import_menu,              0,            NULL   },
	{ (char *)"&Export\t ",                 NULL,                      export_menu,              0,            NULL   },
#ifndef __EMSCRIPTEN__
	{ (char *)"",                           NULL,                      NULL,                     0,            NULL   },
	{ (char *)"E&xit\tESC",                 onExit,                    NULL,                     0,            NULL   },
#endif
	{  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

static MENU maps_menu[] =
{
    { (char *)"&Goto Map...",               onGotoMap,                 NULL,                     0,            NULL   },
    { (char *)"Next Map\t.",                onIncMap,                  NULL,                     0,            NULL   },
    { (char *)"Previous Map\t,",            onDecMap,                  NULL,                     0,            NULL   },
    { (char *)"",                           NULL,                      NULL,                     0,            NULL   },
    { (char *)"D&elete Map",                onDeleteMap,               NULL,                     0,            NULL   },
    {  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

static MENU misc_menu[] =
{
    { (char *)"S&ubscreens",                onEditSubscreens,          NULL,                     0,            NULL   },
    { (char *)"&Master Subscreen Type",     onSubscreen,               NULL,                     0,            NULL   },
    { (char *)"&Shop Types",                onShopTypes,               NULL,                     0,            NULL   },
    { (char *)"&Bottle Types",              onBottleTypes,             NULL,                     0,            NULL   },
    { (char *)"Bottle S&hop Types",         onBottleShopTypes,         NULL,                     0,            NULL   },
    { (char *)"&Info Types",                onInfoTypes,               NULL,                     0,            NULL   },
    { (char *)"&Warp Rings",                onWarpRings,               NULL,                     0,            NULL   },
    { (char *)"&Triforce Pieces",           onTriPieces,               NULL,                     0,            NULL   },
    { (char *)"&End String",                onEndString,               NULL,                     0,            NULL   },
    { (char *)"Item &Drop Sets",            onItemDropSets,            NULL,                     0,            NULL   },
// { (char *)"Screen &Opening/Closing",    onScreenOpeningClosing,    NULL,                     0,            NULL   },
    {  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

static MENU spr_menu[] =
{
    { (char *)"&Sprite Data",               onCustomWpns,              NULL,                     0,            NULL   },
    { (char *)"&Player",                      onCustomHero,              NULL,                     0,            NULL   },
    { (char *)"&Misc Sprites",              onMiscSprites,             NULL,                     0,            NULL   },
    {  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

MENU colors_menu[] =
{
    { (char *)"&Main   ",                   onColors_Main,             NULL,                     0,            NULL   },
    { (char *)"&Levels   ",                 onColors_Levels,           NULL,                     0,            NULL   },
    { (char *)"&Sprites   ",                onColors_Sprites,          NULL,                     0,            NULL   },
    {  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

static MENU defs_menu[] =
{
    { (char *)"&Palettes",                  onDefault_Pals,            NULL,                     0,            NULL   },
    { (char *)"&Tiles",                     onDefault_Tiles,           NULL,                     0,            NULL   },
    { (char *)"&Combos",                    onDefault_Combos,          NULL,                     0,            NULL   },
    { (char *)"&Items",                     onDefault_Items,           NULL,                     0,            NULL   },
    { (char *)"&Enemies",                   onDefault_Guys,            NULL,                     0,            NULL   },
    { (char *)"&Sprite Data",               onDefault_Weapons,         NULL,                     0,            NULL   },
    { (char *)"&Map Styles",                onDefault_MapStyles,       NULL,                     0,            NULL   },
    { (char *)"SF&X Data",                  onDefault_SFX,             NULL,                     0,            NULL   },
    {  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

int32_t onEditComboAlias();
int32_t onEditComboPool();

static MENU graphics_menu[] =
{
    { (char *)"&Palettes\t ",               NULL,                      colors_menu,              0,            NULL   },
    { (char *)"&Sprites\t ",                NULL,                      spr_menu,                 0,            NULL   },
    { (char *)"&Combos",                    onCombos,                  NULL,                     0,            NULL   },
    { (char *)"&Tiles",                     onTiles,                   NULL,                     0,            NULL   },
    { (char *)"&Game icons",                onIcons,                   NULL,                     0,            NULL   },
    { (char *)"Misc co&lors",               onMiscColors,              NULL,                     0,            NULL   },
    { (char *)"&Map styles",                onMapStyles,               NULL,                     0,            NULL   },
    { (char *)"&Door Combo Sets",           onDoorCombos,              NULL,                     0,            NULL   },
    { (char *)"Combo &Aliases",             onEditComboAlias,          NULL,                     0,            NULL   },
    {  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

static MENU audio_menu[] =
{
    { (char *)"SF&X Data",                  onSelectSFX,               NULL,                     0,            NULL   },
    { (char *)"&MIDIs",                     onMidis,                   NULL,                     0,            NULL   },
    { (char *)"Mis&c SFX",                  onMiscSFX,                 NULL,                     0,            NULL   },
// { (char *)"&Enhanced Music",            onEnhancedMusic,           NULL,                     D_DISABLED,   NULL   },
    {  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

static MENU script_menu[] =
{
    { (char *)"Compile &ZScript...",        onCompileScript,           NULL,                     0,            NULL   },
    {  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

void set_rules(byte* newrules);

void call_testqst_dialog();
int32_t onTestQst()
{
	call_testqst_dialog();
	return D_O_K;
}

int32_t onRulesDlg()
{
	call_qr_dialog((is_large?21:12), set_rules);
	return D_O_K;
}

int32_t onRulesSearch()
{
	call_qrsearch_dialog(set_rules);
	return D_O_K;
}

int32_t onZScriptSettings()
{
	ScriptRulesDialog(quest_rules, (is_large?17:13), [](byte* newrules)
	{
		saved = false;
		memcpy(quest_rules, newrules, QR_SZ);
	}).show();
	return D_O_K;
}

void call_zinf_dlg();
int32_t onZInfo()
{
	call_zinf_dlg();
	return D_O_K;
}

static MENU quest_menu[] = 
{
    { (char *)"&Options\t ",          onRulesDlg,                      NULL,                     0,            NULL   },
    { (char *)"&Test",                 onTestQst,                      NULL,                     0,            NULL   },
    { (char *)"&Items",            onCustomItems,                      NULL,                     0,            NULL   },
    { (char *)"Ene&mies",        onCustomEnemies,                      NULL,                     0,            NULL   },
    { (char *)"&Player",            onCustomHero,                      NULL,                     0,            NULL   },
    { (char *)"&Strings",              onStrings,                      NULL,                     0,            NULL   },
    { (char *)"&DMaps",                  onDmaps,                      NULL,                     0,            NULL   },
    { (char *)"I&nit Data",               onInit,                      NULL,                     0,            NULL   },
    { (char *)"Misc D&ata\t ",              NULL,                 misc_menu,                     0,            NULL   },
    { (char *)"&ZInfo",                  onZInfo,                      NULL,                     0,            NULL   },
    { (char *)"",                           NULL,                      NULL,                     0,            NULL   },
    { (char *)"&Graphics\t ",               NULL,             graphics_menu,                     0,            NULL   },
    { (char *)"A&udio\t ",                  NULL,                audio_menu,                     0,            NULL   },
    { (char *)"",                           NULL,                      NULL,                     0,            NULL   },
    { (char *)"De&faults\t ",               NULL,                 defs_menu,                     0,            NULL   },
    { (char *)"",                           NULL,                      NULL,                     0,            NULL   },
    { (char *)"Misc[]",            onQMiscValues,                      NULL,                     0,            NULL   },
    {  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

static MENU paste_menu[] =
{
    { (char *)"Paste &To All",              onPasteToAll,              NULL,                     0,            NULL   },
    { (char *)"Paste &All To All",          onPasteAllToAll,           NULL,                     0,            NULL   },
    {  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

static MENU paste_item_menu[] =
{
    { (char *)"&Undercombo",                onPasteUnderCombo,         NULL,                     0,            NULL   },
    { (char *)"&Secret Combos",             onPasteSecretCombos,       NULL,                     0,            NULL   },
    { (char *)"&Freeform Combos",           onPasteFFCombos,           NULL,                     0,            NULL   },
    { (char *)"Screen &Data",               onPasteScreenData,         NULL,                     0,            NULL   },
    { (char *)"&Warps",                     onPasteWarps,              NULL,                     0,            NULL   },
    { (char *)"Warp &Return",               onPasteWarpLocations,      NULL,                     0,            NULL   },
    { (char *)"&Enemies",                   onPasteEnemies,            NULL,                     0,            NULL   },
    { (char *)"Room &Type Data",            onPasteRoom,               NULL,                     0,            NULL   },
    { (char *)"&Guy/String",                onPasteGuy,                NULL,                     0,            NULL   },
    { (char *)"Doo&rs",                     onPasteDoors,              NULL,                     0,            NULL   },
    { (char *)"&Layers",                    onPasteLayers,             NULL,                     0,            NULL   },
    { (char *)"&Palette",                   onPastePalette,            NULL,                     0,            NULL   },
    {  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

static MENU edit_menu[] =
{
    { (char *)"&Undo\tU",                   onUndo,                    NULL,                     0,            NULL   },
    { (char *)"&Redo\tCtrl+Y",              onRedo,                    NULL,                     0,            NULL   },
    { (char *)"&Copy\tC",                   onCopy,                    NULL,                     0,            NULL   },
    { (char *)"&Paste\tV",                  onPaste,                   NULL,                     0,            NULL   },
    { (char *)"Paste A&ll",                 onPasteAll,                NULL,                     0,            NULL   },
    { (char *)"&Adv. Paste\t ",             NULL,                      paste_menu,               0,            NULL   },
    { (char *)"Paste &Spec.\t ",            NULL,                      paste_item_menu,          0,            NULL   },
    { (char *)"&Delete\tDel",               onDelete,                  NULL,                     0,            NULL   },
    { (char *)"",                           NULL,                      NULL,                     0,            NULL   },
    { (char *)"&Maps\t ",                   NULL,                      maps_menu,                0,            NULL   },
    {  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

static MENU drawing_mode_menu[] =
{
    { (char *)"&Normal",                    onDrawingModeNormal,       NULL,                     0,            NULL   },
    { (char *)"&Relational",                onDrawingModeRelational,   NULL,                     0,            NULL   },
    { (char *)"&Dungeon Carving",           onDrawingModeDungeon,      NULL,                     0,            NULL   },
    { (char *)"&Combo Alias",               onDrawingModeAlias,        NULL,                     0,            NULL   },
    { (char *)"&Pool",                      onDrawingModePool,         NULL,                     0,            NULL   },
    {  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

static MENU integrity_check_menu[] =
{
    { (char *)"&All ",                      onIntegrityCheckAll,       NULL,                     0,            NULL   },
    { (char *)"&Screens ",                  onIntegrityCheckRooms,     NULL,                     0,            NULL   },
    { (char *)"&Warps ",                    onIntegrityCheckWarps,     NULL,                     0,            NULL   },
    {  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

static MENU quest_reports_menu[] =
{
    { (char *)"&Bugged Next-> Combo Locations",           onBuggedNextComboLocationReport,         NULL,                     0,            NULL   },
    { (char *)"&Combo Locations",           onComboLocationReport,     NULL,                     0,            NULL   },
    { (char *)"&Combo Type Locations",      onComboTypeLocationReport, NULL,                     0,            NULL   },
    { (char *)"&Enemy Locations",           onEnemyLocationReport,     NULL,                     0,            NULL   },
    { (char *)"&Item Locations",            onItemLocationReport,      NULL,                     0,            NULL   },
    { (char *)"&Script Locations",          onScriptLocationReport,    NULL,                     0,            NULL   },
    { (char *)"&What Links Here",           onWhatWarpsReport,         NULL,                     0,            NULL   },
    { (char *)"In&tegrity Check\t ",        NULL,                      integrity_check_menu,     0,            NULL   },
    {  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

int32_t onPalFix();
int32_t onPitFix();
int32_t onStrFix()
{
	if(get_bit(quest_rules, qr_OLD_STRING_EDITOR_MARGINS))
	{
		AlertDialog("Fix: Old Margins",
			"Fixing margins may cause strings that used to spill outside the textbox"
			" to instead be cut off. Are you sure?",
			[&](bool ret,bool)
			{
				if(ret)
				{
					set_bit(quest_rules, qr_OLD_STRING_EDITOR_MARGINS, 0);
					saved = false;
				}
			}).show();
	}
	if(get_bit(quest_rules, qr_STRING_FRAME_OLD_WIDTH_HEIGHT))
	{
		AlertDialog("Fix: Old Frame Size",
			"This will fix the frame size of all strings. No visual changes should occur,"
			" as the string width/height will be fixed, but the compat QR will also be unchecked.",
			[&](bool ret,bool)
			{
				if(ret)
				{
					for(auto q = 0; q < msg_count; ++q)
					{
						MsgStrings[q].w += 16;
						MsgStrings[q].h += 16;
					}
					set_bit(quest_rules, qr_STRING_FRAME_OLD_WIDTH_HEIGHT, 0);
					saved = false;
				}
			}).show();
	}
	return D_O_K;
}

enum
{
	ftCSFix, ftLSFix, ftESFix,
	ftLPFix, ftPLDFix, ftOSFix,
	ft_size
};
static MENU fixtools_menu[] =
{
    { (char*)"&Color Set Fix",             onCSetFix,                 NULL,                     0,            NULL   },
    { (char*)"&Liquid Solidity Fix",       onWaterSolidity,           NULL,                     0,            NULL   },
    { (char*)"&Effect Square Fix",         onEffectFix,               NULL,                     0,            NULL   },
    { (char*)"&Level Palette Fix",         onPalFix,                  NULL,                     0,            NULL   },
    { (char*)"&Pit and Liquid Damage Fix", onPitFix,                  NULL,                     0,            NULL   },
    { (char*)"&Old Strings Fix",           onStrFix,                  NULL,                     0,            NULL   },
    {  NULL,                                NULL,                     NULL,                     0,            NULL   }
};

static MENU tool_menu[] =
{
	{ (char *)"Combo &Flags\tF8",           onFlags,                   NULL,                     0,            NULL   },
	{ (char *)"Fix &Tools\t ",              NULL,                      fixtools_menu,            0,            NULL   },
	{ (char *)"&NES Dungeon Template",      onTemplate,                NULL,                     0,            NULL   },
	{ (char *)"&Apply Template to All",     onReTemplate,              NULL,                     0,            NULL   },
	{ (char *)"",                           NULL,                      NULL,                     0,            NULL   },
	{ (char *)"&Preview Mode\tX",           onPreviewMode,             NULL,                     0,            NULL   },
	{ (char *)"Drawing &Mode\t ",           NULL,                      drawing_mode_menu,        0,            NULL   },
	{ (char *)"",                           NULL,                      NULL,                     0,            NULL   },
	{ (char *)"&List Combos Used\t'",       onUsedCombos,              NULL,                     0,            NULL   },
	{ (char *)"&Quest Reports\t ",          NULL,                      quest_reports_menu,       0,            NULL   },
	{  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

int32_t onLayer3BG()
{
	if ( ViewLayer3BG ) ViewLayer3BG = 0;
	else ViewLayer3BG = 1;
	return D_O_K;
}
int32_t onLayer2BG()
{
	if ( ViewLayer2BG ) ViewLayer2BG = 0;
	else ViewLayer2BG = 1;
	return D_O_K;
}
MENU view_menu[] =
{
    { (char *)"View &Map...",               onViewMap,                 NULL,                     0,            NULL   },
    { (char *)"View &Palette",              onShowPal,                 NULL,                     0,            NULL   },
    { (char *)"",                           NULL,                      NULL,                     0,            NULL   },
    { (char *)"Show &Walkability\tW",       onShowWalkability,         NULL,                     0,            NULL   },
    { (char *)"Show &Flags\tF",             onShowFlags,               NULL,                     0,            NULL   },
    { (char *)"Show &CSets",                onShowCSet,                NULL,                     0,            NULL   },
    { (char *)"Show &Types",                onShowCType,               NULL,                     0,            NULL   },
    { (char *)"",                           NULL,                      NULL,                     0,            NULL   },
    { (char *)"Show Screen &Info\tN",       onToggleShowInfo,          NULL,                     0,            NULL   },
    { (char *)"Show &Squares",              onToggleShowSquares,       NULL,                     0,            NULL   },
    { (char *)"Show FFCs",                  onToggleShowFFCs,          NULL,                     0,            NULL   },
    { (char *)"Show Script &Names",         onToggleShowScripts,       NULL,                     0,            NULL   },
    { (char *)"Show &Grid\t~",              onToggleGrid,              NULL,                     0,            NULL   },
    { (char *)"Show &Darkness\tL",          onShowDarkness,            NULL,                     0,            NULL   },
    { (char *)"Layer 3 is Background",      onLayer3BG,                NULL,                     0,            NULL   },
    { (char *)"Layer 2 is Background",      onLayer2BG,                NULL,                     0,            NULL   },
    {  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

void set_rules(byte* newrules)
{
	saved = false;
	if(newrules != quest_rules)
		memcpy(quest_rules, newrules, QR_SZ);
	if(!get_bit(quest_rules,qr_ALLOW_EDITING_COMBO_0))
	{
		combobuf[0].walk = 0xF0;
		combobuf[0].type = 0;
		combobuf[0].flag = 0;
	}
	
	// For 2.50.0 and 2.50.1
	if(get_bit(quest_rules, qr_VERYFASTSCROLLING))
		set_bit(quest_rules, qr_FASTDNGN, 1);
	
	//this is only here until the subscreen style is selectable by itself
	zinit.subscreen_style=get_bit(quest_rules,qr_COOLSCROLL)?1:0;
}

int32_t onSelectFFCombo();

static MENU data_menu[] =
{
    { (char *)"&Screen Data\tF9",           onScrData,                 NULL,                     0,            NULL   },
    { (char *)"&Freeform Combos\tF7",       onSelectFFCombo,           NULL,                     0,            NULL   },
    { (char *)"La&yers\tF12",               onLayers,                  NULL,                     0,            NULL   },
    { (char *)"&Tile Warp\tF10",            onTileWarp,                NULL,                     0,            NULL   },
    { (char *)"Side &Warp\tF11",            onSideWarp,                NULL,                     0,            NULL   },
    { (char *)"Secret &Combos\tF5",         onSecretCombo,             NULL,                     0,            NULL   },
    { (char *)"&Under Combo",               onUnderCombo,              NULL,                     0,            NULL   },
    { (char *)"&Doors\tF6",                 onDoors,                   NULL,                     0,            NULL   },
    { (char *)"Ma&ze Path",                 onPath,                    NULL,                     0,            NULL   },
    { (char *)"",                           NULL,                      NULL,                     0,            NULL   },
    { (char *)"&Room Data\tR",              onRoom,                    NULL,                     0,            NULL   },

    { (char *)"",                           NULL,                      NULL,                     0,            NULL   },
    { (char *)"&Item\tI",                   onItem,                    NULL,                     0,            NULL   },
    { (char *)"&Enemies\tE",                onEnemies,                 NULL,                     0,            NULL   },
    { (char *)"&Palette\tF4",               onScreenPalette,           NULL,                     0,            NULL   },
    { (char *)"",                           NULL,                      NULL,                     0,            NULL   },
    { (char *)"Script",                   onScreenScript,                    NULL,                     0,            NULL   },
    
    {  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

static MENU tunes_menu[] =
{
    { (char *)"Wind Fish",				  playTune1,                 NULL,                     0,            NULL   },
    { (char *)"Overworld",				  playTune2,                 NULL,                     0,            NULL   },
    { (char *)"Hyrule Castle",			  playTune3,                 NULL,                     0,            NULL   },
    { (char *)"Lost Woods",			      playTune4,                 NULL,                     0,            NULL   },
    { (char *)"Great Sea",				  playTune5,                 NULL,                     0,            NULL   },
    { (char *)"East Hyrule",				  playTune6,                 NULL,                     0,            NULL   },
    { (char *)"Dancing Dragon",			  playTune7,                 NULL,                     0,            NULL   },
    { (char *)"Stone Tower",				  playTune8,                 NULL,                     0,            NULL   },
    { (char *)"Villages",				      playTune9,                 NULL,                     0,            NULL   },
    { (char *)"Swamp + Desert",		      playTune10,                NULL,                     0,            NULL   },
    { (char *)"Outset Island",			  playTune11,                NULL,                     0,            NULL   },
    { (char *)"Kakariko Village",			  playTune12,                NULL,                     0,            NULL   },
    { (char *)"Clock Town",				  playTune13,                NULL,                     0,            NULL   },
    { (char *)"Temple",				      playTune14,                NULL,                     0,            NULL   },
    { (char *)"Dark World",				  playTune15,                NULL,                     0,            NULL   },
    { (char *)"Dragon Roost",				  playTune16,                NULL,                     0,            NULL   },
    { (char *)"Horse Race",				  playTune17,                NULL,                     0,            NULL   },
    { (char *)"Credits",				      playTune18,                NULL,                     0,            NULL   },
    { (char *)"Zelda's Lullaby",			  playTune19,                NULL,                     0,            NULL   },
    {  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

//New Modules Menu for 2.55+
static MENU module_menu[] =
{
    { (char *)"&Load Module...",        load_zmod_module_file,           NULL,                     0,            NULL   },
    { (char *)"&About Module",        onAbout_Module,           NULL,                     0,            NULL   },
    //divider
    { (char *)"",                               NULL,                      NULL,                     0,            NULL   },
    { (char *)"&Template",                  onTemplates,               NULL,                     0,            NULL   },

    {  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

static MENU etc_menu[] =
{
	{ (char *)"&Help",                      NULL /*onHelp*/,           zq_help_menu,             0,            NULL   },
	{ (char *)"&About",                     onAbout,                   NULL,                     0,            NULL   },
	{ (char *)"&Video Mode",                onZQVidMode,               NULL,                     0,            NULL   },
	{ (char *)"&Options...",                onOptions,                 NULL,                     0,            NULL   },
	{ (char *)"&Fullscreen",                onFullScreen,              NULL,                     0,            NULL   },
	// 5
	{ (char *)"",                           NULL,                      NULL,                     0,            NULL   },
	{ (char *)"&View Pic...",               onViewPic,                 NULL,                     0,            NULL   },
	{ (char *)"",                           NULL,                      NULL,                     0,            NULL   },
	{ (char *)"Ambient Music  ",            NULL,                      tunes_menu,               0,            NULL   },
	{ (char *)"&Play music",                playMusic,                 NULL,                     0,            NULL   },
	// 10
	{ (char *)"&Change track",              changeTrack,               NULL,                     0,            NULL   },
	{ (char *)"&Stop tunes",                stopMusic,                 NULL,                     0,            NULL   },
	{ (char *)"",                           NULL,                      NULL,                     0,            NULL   },
	{ (char *)"&Debug Console",             toggleConsole,             NULL,                     0,            NULL   },
	{ (char *)"C&lear Quest Filepath",      onClearQuestFilepath,      NULL,                     0,            NULL   },
	// 15
	{ (char *)"&Take Snapshot\tZ",          onSnapshot,                NULL,                     0,            NULL   },
	{ (char *)"&Modules",                   NULL,                      module_menu,              0,            NULL   },
	{  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

static MENU media_menu[] =
{
	{ (char *)"Ambient Music  ",        NULL,                      tunes_menu,               0,            NULL   },
    { (char *)"&Play music",                playMusic,                 NULL,                     0,            NULL   },
    { (char *)"&Change track",              changeTrack,               NULL,                     0,            NULL   },
    { (char *)"&Stop tunes",                stopMusic,                 NULL,                     0,            NULL   },
    {  NULL,                                NULL,                      NULL,                     0,            NULL   }

};



//New ZScript Menu for 2.55 Alpha 16
static MENU zscript_menu[] =
{
	{ (char *)"Compile &ZScript...",            onCompileScript,           NULL,                     0,            NULL   },
	{ (char *)"&Assign Slots...",               onSlotAssign,              NULL,                     0,            NULL   },
	//divider	
	{ (char *)"",                               NULL,                      NULL,                     0,            NULL   },
	{ (char *)"&Compiler Settings",             onZScriptCompilerSettings, NULL,                     0,            NULL   },
	{ (char *)"&Quest Script Settings",         onZScriptSettings,         NULL,                     0,            NULL   },
	//divider
	{ (char *)"",                               NULL,                      NULL,                     0,            NULL   },
	{ (char *)"&Export ZASM Script",            onExportZASM,              NULL,                     0,            NULL   },
	{ (char *)"&Import ZASM Script",            onImportZASM,              NULL,                     0,            NULL   },
//	{ (char *)"Set Include Path",               onZScriptSetIncludePath,   NULL,                     0,            NULL   },

	{  NULL,                                    NULL,                      NULL,                     0,            NULL   }
};



static MENU etc_menu_smallmode[] =
{
	{ (char *)"&Help",                      NULL /*onHelp*/,           zq_help_menu,             0,            NULL   },
	{ (char *)"&About",                     onAbout,                   NULL,                     0,            NULL   },
	{ (char *)"&Video Mode",                onZQVidMode,               NULL,                     0,            NULL   },
	{ (char *)"&Options...",                onOptions,                 NULL,                     0,            NULL   },
	{ (char *)"&Fullscreen",                onFullScreen,              NULL,                     0,            NULL   },
	// 5
	{ (char *)"",                           NULL,                      NULL,                     0,            NULL   },
	{ (char *)"&View Pic...",               onViewPic,                 NULL,                     0,            NULL   },
	{ (char *)"Media",                      NULL,                      media_menu,               0,            NULL   },
	{ (char *)"",                           NULL,                      NULL,                     0,            NULL   },
	{ (char *)"&Debug Console",             toggleConsole,             NULL,                     0,            NULL   },
	// 10
	{ (char *)"Clear Quest Filepath",       onClearQuestFilepath,      NULL,                     0,            NULL   },
	{ (char *)"&Take ZQ Snapshot\tZ",       onSnapshot,                NULL,                     0,            NULL   },
	{ (char *)"Take &Screen Snapshot",      onMapscrSnapshot,          NULL,                     0,            NULL   },
	{ (char *)"",                           NULL,                      NULL,                     0,            NULL   },
	{ (char *)"&Modules",                   NULL,                      module_menu,              0,            NULL   },
	// 15
	{  NULL,                                NULL,                      NULL,                     0,            NULL   }
};
void set_console_state()
{
	SETFLAG(etc_menu[13].flags, D_SELECTED, console_is_open);
	SETFLAG(etc_menu_smallmode[9].flags, D_SELECTED, console_is_open);
}

MENU the_menu_large_old[] =
{
    
    { (char *)"&File",                      NULL, (MENU *) file_menu,       0,            NULL   },
    { (char *)"&Quest",                     NULL, (MENU *) quest_menu,      0,            NULL   },
    { (char *)"&Edit",                      NULL, (MENU *) edit_menu,       0,            NULL   },
    { (char *)"&View",                      NULL, (MENU *) view_menu,       0,            NULL   },
    { (char *)"&Tools",                     NULL, (MENU *) tool_menu,       0,            NULL   },
    { (char *)"&Screen",                    NULL, (MENU *) data_menu,       0,            NULL   },
    { (char *)"&ZScript",                       NULL, (MENU *) zscript_menu,        0,            NULL   },
    { (char *)"Et&c",                       NULL, (MENU *) etc_menu_smallmode,        0,            NULL   },
    {  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

MENU the_menu[] =
{
    { (char *)"Z&C",                       NULL, (MENU *) etc_menu_smallmode,        0,            NULL   },
    { (char *)"&File",                      NULL, (MENU *) file_menu,       0,            NULL   },
    { (char *)"&Quest",                     NULL, (MENU *) quest_menu,      0,            NULL   },
    { (char *)"&Edit",                      NULL, (MENU *) edit_menu,       0,            NULL   },
    { (char *)"&View",                      NULL, (MENU *) view_menu,       0,            NULL   },
    { (char *)"&Tools",                     NULL, (MENU *) tool_menu,       0,            NULL   },
    { (char *)"&Screen",                    NULL, (MENU *) data_menu,       0,            NULL   },
    { (char *)"&ZScript",                       NULL, (MENU *) zscript_menu,        0,            NULL   },

    {  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

MENU the_menu_large[] =
{
    { (char *)"&File",                      NULL, (MENU *) file_menu,       0,            NULL   },
    { (char *)"&Quest",                     NULL, (MENU *) quest_menu,      0,            NULL   },
    { (char *)"&Edit",                      NULL, (MENU *) edit_menu,       0,            NULL   },
    { (char *)"&View",                      NULL, (MENU *) view_menu,       0,            NULL   },
    { (char *)"&Tools",                     NULL, (MENU *) tool_menu,       0,            NULL   },
    { (char *)"&Screen",                    NULL, (MENU *) data_menu,       0,            NULL   },
    { (char *)"&ZScript",                       NULL, (MENU *) zscript_menu,        0,            NULL   },
    { (char *)"Et&C",                       NULL, (MENU *) etc_menu_smallmode,        0,            NULL   },
    {  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

MENU the_menu_small[] =
{
    { (char *)"&File",                      NULL, (MENU *) file_menu,       0,            NULL   },
    { (char *)"&Quest",                     NULL, (MENU *) quest_menu,      0,            NULL   },
    { (char *)"&Edit",                      NULL, (MENU *) edit_menu,       0,            NULL   },
    { (char *)"&View",                      NULL, (MENU *) view_menu,       0,            NULL   },
    { (char *)"&Tools",                     NULL, (MENU *) tool_menu,       0,            NULL   },
    { (char *)"&Screen",                    NULL, (MENU *) data_menu,       0,            NULL   },
    { (char *)"&ZScript",                       NULL, (MENU *) zscript_menu,        0,            NULL   },
    { (char *)"Et&C",                       NULL, (MENU *) etc_menu_smallmode,        0,            NULL   },
    {  NULL,                                NULL,                      NULL,                     0,            NULL   },
    {  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

MENU the_menu_large_zcleft[] =
{
    { (char *)"Z&C",                       NULL, (MENU *) etc_menu_smallmode,        0,            NULL   },
    { (char *)"&File",                      NULL, (MENU *) file_menu,       0,            NULL   },
    { (char *)"&Quest",                     NULL, (MENU *) quest_menu,      0,            NULL   },
    { (char *)"&Edit",                      NULL, (MENU *) edit_menu,       0,            NULL   },
    { (char *)"&View",                      NULL, (MENU *) view_menu,       0,            NULL   },
    { (char *)"&Tools",                     NULL, (MENU *) tool_menu,       0,            NULL   },
    { (char *)"&Screen",                    NULL, (MENU *) data_menu,       0,            NULL   },
    { (char *)"&ZScript",                       NULL, (MENU *) zscript_menu,        0,            NULL   },
    {  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

MENU the_menu_small_zcleft[] =
{
    { (char *)"Z&C",                       NULL, (MENU *) etc_menu_smallmode,        0,            NULL   }, 
    { (char *)"&File",                      NULL, (MENU *) file_menu,       0,            NULL   },
    { (char *)"&Quest",                     NULL, (MENU *) quest_menu,      0,            NULL   },
    { (char *)"&Edit",                      NULL, (MENU *) edit_menu,       0,            NULL   },
    { (char *)"&View",                      NULL, (MENU *) view_menu,       0,            NULL   },
    { (char *)"&Tools",                     NULL, (MENU *) tool_menu,       0,            NULL   },
    { (char *)"&Screen",                    NULL, (MENU *) data_menu,       0,            NULL   },
    { (char *)"&ZScript",                       NULL, (MENU *) zscript_menu,        0,            NULL   },
    {  NULL,                                NULL,                      NULL,                     0,            NULL   },
    {  NULL,                                NULL,                      NULL,                     0,            NULL   }
};

void rebuild_trans_table();
int32_t launchPicViewer(BITMAP **pictoview, PALETTE pal,
                    int32_t *px2, int32_t *py2, double *scale, bool isviewingmap);

int32_t onResetTransparency()
{
    restore_mouse();
    rebuild_trans_table();
    jwin_alert("Notice","Translucency Table Rebuilt",NULL,NULL,"OK",NULL,13,27,lfont);
    
    refresh(rALL);
    return D_O_K;
}

int32_t onFullScreen()
{
	
    if(jwin_alert3(
			(is_windowed_mode()) ? "Fullscreen Warning" : "Change to Windowed Mode", 
			(is_windowed_mode()) ? "Some video chipsets/drivers do not support 8-bit native fullscreen" : "Proceeding will drop from Fullscreen to Windowed Mode", 
			(is_windowed_mode()) ? "We strongly advise saving your quest before shifting from windowed to fullscreen!": "Do you wish to shift from Fullscreen to Windowed mode?",
			(is_windowed_mode()) ? "Do you wish to continue to fullscreen mode?" : NULL,
		 "&Yes", 
		"&No", 
		NULL, 
		'y', 
		'n', 
		0, 
		lfont) == 1)	
    {
	#ifdef ALLEGRO_DOS
	    return D_O_K;
	#endif
	    get_palette(RAMpal);
	    show_mouse(NULL);
	    bool windowed=is_windowed_mode()!=0;
	    
	    int32_t ret=set_gfx_mode(windowed?GFX_AUTODETECT_FULLSCREEN:GFX_AUTODETECT_WINDOWED,zq_screen_w,zq_screen_h,0,0);
	    if(ret!=0)
	    {
			Z_message("Can't set video mode (%d).\n", ret);
			Z_message(allegro_error);
			// quit_game();
			exit(1);
	    }
	    
	    gui_mouse_focus=0;
	    gui_bg_color=jwin_pal[jcBOX];
	    gui_fg_color=jwin_pal[jcBOXFG];
	    set_mouse_sprite(mouse_bmp[MOUSE_BMP_NORMAL][0]);
	    set_palette(RAMpal);
	    position_mouse(zq_screen_w/2,zq_screen_h/2);
	    show_mouse(screen);
	    set_display_switch_mode(SWITCH_BACKGROUND);
	    set_display_switch_callback(SWITCH_OUT, switch_out);
	    set_display_switch_callback(SWITCH_IN, switch_in);
		zc_set_config("zquest","fullscreen", is_windowed_mode() ? 0 : 1);
	    return D_REDRAW;
    }
    else return D_O_K;
}

int32_t onEnter()
{
#ifdef ALLEGRO_DOS
#else

    if(key[KEY_ALT]||key[KEY_ALTGR])
    {
        return onFullScreen();
    }

#endif
    return D_O_K;
}

//PROC, x, y, w, h, fg, bg, key, flags, d1, d2, *dp, *dp2, *dp3

//*text, (*proc), *child, flags, *dp

int32_t d_nbmenu_proc(int32_t msg,DIALOG *d,int32_t c);


/*int32_t onY()
{
  return D_O_K;
}*/

int32_t onToggleGrid()
{
    if(key[KEY_ZC_LCONTROL] || key[KEY_ZC_RCONTROL])
    {
        GridColor=(GridColor+8)%16;
		zc_set_config("zquest", "grid_color", GridColor);
    }
    else
    {
        ShowGrid=!ShowGrid;
		zc_set_config("zquest","show_grid",ShowGrid);
    }
    
    return D_O_K;
}

int32_t onToggleShowScripts()
{
    ShowFFScripts=!ShowFFScripts;
    zc_set_config("zquest","showffscripts",ShowFFScripts);
    return D_O_K;
}

int32_t onToggleShowFFCs()
{
    ShowFFCs=!ShowFFCs;
    zc_set_config("zquest","showffcs",ShowFFCs);
    return D_O_K;
}

int32_t onToggleShowSquares()
{
    ShowSquares=!ShowSquares;
    zc_set_config("zquest","showsquares",ShowSquares);
    return D_O_K;
}

int32_t onToggleShowInfo()
{
    ShowInfo=!ShowInfo;
	zc_set_config("zquest","showinfo",ShowInfo);
    return D_O_K;
}

int onKeySlash()
{
	if(key[KEY_LSHIFT] || key[KEY_RSHIFT])
	{
		onAbout();
	}
	return D_O_K;
}

int onAKey()
{
	if(prv_mode)
		Map.set_prvadvance(1);
	return D_O_K;
}

int onRKey()
{
	if(prv_mode)
	{
		Map.set_prvscr(Map.get_prv_map(), Map.get_prv_scr());
		Map.set_prvcmb(0);
	}
	else
		onRoom();
	return D_O_K;
}

int onSKey()
{
	if(key[KEY_ZC_LCONTROL] || key[KEY_ZC_RCONTROL])
	{
		if(key[KEY_LSHIFT] || key[KEY_RSHIFT])
		{
			onSaveAs();
		}
		else
		{
			if(!saved)
				onSave();
		}
	}
	else if(prv_mode)
	{
		Map.prv_secrets(false);
		refresh(rALL);
	}
	else onStrings();
	return D_O_K;
}

/* Notice: If you insert or remove entries from dialogs[], you will need
	to adjust hardcoded values to indices of dialogs[] in main(). 
*/

static DIALOG dialogs[] =
{
    /* (dialog proc)     (x)   (y)   (w)   (h)   (fg)  (bg)  (key)    (flags)  (d1)         (d2)     (dp) */
    // { d_nbmenu_proc,     0,    0,    0,    13,    0,    0,    0,       D_USER,  0,             0, ((is_large) ? (void *) the_menu_large : (void *) the_menu), NULL, NULL },
    { d_nbmenu_proc,     0,    2,    0,    13,    0,    0,    0,       D_USER,  0,             0, (void *) the_menu, NULL, NULL },
    
    { d_dummy_proc,   0,    0,    0,    0,    0,    0,    0,     0,       0,              0, (void *) onIncreaseCSet, NULL, NULL },
    { d_dummy_proc,   0,    0,    0,    0,    0,    0,    0,     0,       0,              0, (void *) onDecreaseCSet, NULL, NULL },

    { d_keyboard_proc_m, 0,    0,    0,    0,    0,    0,    0,       0, KEY_Z, KB_COMMAND_FLAG|KB_SHIFT_FLAG, (void *) onRedo, NULL, NULL },
    { d_keyboard_proc_m, 0,    0,    0,    0,    0,    0,    0,       0, KEY_Z, KB_COMMAND_FLAG,               (void *) onUndo, NULL, NULL },
    { d_keyboard_proc_m, 0,    0,    0,    0,    0,    0,    0,       0, KEY_Y, KB_COMMAND_FLAG,               (void *) onRedo, NULL, NULL },

    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    '*',     0,       0,              0, (void *) onIncreaseFlag, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_CLOSEBRACE, 0, (void *) onIncreaseFlag, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    '/',     0,       0,              0, (void *) onDecreaseFlag, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_OPENBRACE,  0, (void *) onDecreaseFlag, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_UP,         0, (void *) onUp, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_DOWN,       0, (void *) onDown, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_LEFT,       0, (void *) onLeft, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_RIGHT,      0, (void *) onRight, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_PGUP,       0, (void *) onPgUp, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_PGDN,       0, (void *) onPgDn, NULL, NULL },
    // { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_PLUS_PAD,   0, (void *) onIncreaseCSet, NULL, NULL },
    // { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_MINUS_PAD,  0, (void *) onDecreaseCSet, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_ASTERISK,   0, (void *) onIncreaseFlag, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_SLASH_PAD,  0, (void *) onDecreaseFlag, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_F1,         0, (void *) onHelp, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_F2,         0, (void *) onSave, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_F3,         0, (void *) do_OpenQuest, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_F4,         0, (void *) onScreenPalette, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_F5,         0, (void *) onSecretCombo, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_F6,         0, (void *) onDoors, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_F7,         0, (void *) onSelectFFCombo, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_F8,         0, (void *) onFlags, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_F9,         0, (void *) onScrData, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_F10,        0, (void *) onTileWarp, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_F11,        0, (void *) onSideWarp, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_F12,        0, (void *) onLayers, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_ESC,        0, (void *) onExit, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_B,          0, (void *) onResetTransparency, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_C,          0, (void *) onCopy, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_D,          0, (void *) onToggleDarkness, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_E,          0, (void *) onEnemies, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_F,          0, (void *) onShowFlags, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_H,          0, (void *) onH, NULL, NULL },      //Flip
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_I,          0, (void *) onItem, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_J,          0, (void *) onJ, NULL, NULL },      //This does nothing
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_K,          0, (void *) onCombos, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_L,          0, (void *) onShowDarkness, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_M,          0, (void *) onM, NULL, NULL },      // This does nothing
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_N,          0, (void *) onToggleShowInfo, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_O,          0, (void *) onDrawingMode, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_P,          0, (void *) onGotoPage, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_Q,          0, (void *) onShowComboInfoCSet, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_R,          0, (void *) onRKey, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_S,          0, (void *) onSKey, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_T,          0, (void *) onTiles, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_U,          0, (void *) onUndo, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_V,          0, (void *) onPaste, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_W,          0, (void *) onShowWalkability, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_X,          0, (void *) onPreviewMode, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_Y,          0, (void *) onCompileScript, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_Z,          0, (void *) onSnapshot, NULL, NULL },
    //slash is also question mark
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_SLASH,          0, (void *) onKeySlash, NULL, NULL },
    // { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       0,          0, (void *) onPasteAllToAll, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_0,          0, (void *) on0, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_1,          0, (void *) on1, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_2,          0, (void *) on2, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_3,          0, (void *) on3, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_4,          0, (void *) on4, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_5,          0, (void *) on5, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_6,          0, (void *) on6, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_7,          0, (void *) on7, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_8,          0, (void *) on8, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_9,          0, (void *) on9, NULL, NULL },
    { d_dummy_proc,      0,    0,    0,    0,    0,    0,    0,       0,       0,              0, (void *) on10, NULL, NULL },
    { d_dummy_proc,      0,    0,    0,    0,    0,    0,    0,       0,       0,              0, (void *) on11, NULL, NULL },
    { d_dummy_proc,      0,    0,    0,    0,    0,    0,    0,       0,       0,              0, (void *) on12, NULL, NULL },
    { d_dummy_proc,      0,    0,    0,    0,    0,    0,    0,       0,       0,              0, (void *) on13, NULL, NULL },
    { d_dummy_proc,      0,    0,    0,    0,    0,    0,    0,       0,       0,              0, (void *) on14, NULL, NULL },
    { d_dummy_proc,      0,    0,    0,    0,    0,    0,    0,       0,       0,              0, (void *) on15, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    ',',     0,       0,              0, (void *) onDecMap, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    '.',     0,       0,              0, (void *) onIncMap, NULL, NULL },

    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_MINUS,          0, (void *) onDecColour, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_EQUALS,          0, (void *) onIncColour, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_MINUS_PAD,          0, (void *) onDecColour, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_PLUS_PAD,          0, (void *) onIncColour, NULL, NULL },
    
    // { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    '=',     0,       0,              0, (void *) onIncreaseCSet, NULL, NULL },
    // { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    '-',     0,       0,              0, (void *) onDecreaseCSet, NULL, NULL },
    
    // { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    '<',     0,       0,              0, (void *) onDecScrPal, NULL, NULL },
    // { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    '>',     0,       0,              0, (void *) onIncScrPal, NULL, NULL },
    // { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    '_',     0,       0,              0, (void *) onDecScrPal16, NULL, NULL },
    // { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    '+',     0,       0,              0, (void *) onIncScrPal16, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_TILDE,      0, (void *) onToggleGrid, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    39,      0,       0,              0, (void *) onUsedCombos, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_SPACE,      0, (void *) onSpacebar, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_DEL,        0, (void *) onDelete, NULL, NULL },      //
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_ENTER,      0, (void *) onEnter, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_0_PAD,      0, (void *) on0, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_1_PAD,      0, (void *) on1, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_2_PAD,      0, (void *) on2, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_3_PAD,      0, (void *) on3, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_4_PAD,      0, (void *) on4, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_5_PAD,      0, (void *) on5, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_6_PAD,      0, (void *) on6, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_7_PAD,      0, (void *) on7, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_8_PAD,      0, (void *) on8, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_9_PAD,      0, (void *) on9, NULL, NULL },
    { NULL,              0,    0,    0,    0,    0,    0,    0,       0,       0,              0,       NULL, NULL, NULL }
};


int32_t onDecColour()
{
	if ( key[KEY_ZC_LCONTROL] || key[KEY_ZC_RCONTROL] )
	{
		return onDecScrPal16();
	}
	
	else if ( key[KEY_LSHIFT] || key[KEY_RSHIFT] )
	{
		return onDecScrPal();
	}
	
	else
	{
		return onDecreaseCSet();
	}
}

int32_t onIncColour()
{
	
	if ( key[KEY_ZC_LCONTROL] || key[KEY_ZC_RCONTROL] )
	{
		return onIncScrPal16();
	}
	
	else if ( key[KEY_LSHIFT] || key[KEY_RSHIFT] )
	{
		return onIncScrPal();
	}
	
	else
	{
		return onIncreaseCSet();
	}
 }

static DIALOG getnum_dlg[] =
{
    // (dialog proc)       (x)   (y)    (w)     (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp)
    { jwin_win_proc,        80,   80,     160,    72,   vc(0),              vc(11),           0,       D_EXIT,     0,             0,       NULL, NULL, NULL },
    { jwin_rtext_proc,      114,  104+4,  48,     8,    jwin_pal[jcBOXFG],  jwin_pal[jcBOX],  0,       0,          0,             0, (void *) "Value:", NULL, NULL },
    { jwin_edit_proc,       168,  104,    48,     16,    0,                 0,                0,       0,          6,             0,       NULL, NULL, NULL },
    { jwin_button_proc,     90,   126,    61,     21,   vc(0),              vc(11),           13,      D_EXIT,     0,             0, (void *) "OK", NULL, NULL },
    { jwin_button_proc,     170,  126,    61,     21,   vc(0),              vc(11),           27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

int32_t getnumber(const char *prompt,int32_t initialval)
{
    cancelgetnum=true;
    char buf[20];
    sprintf(buf,"%d",initialval);
    getnum_dlg[0].dp=(void *)prompt;
    getnum_dlg[0].dp2=lfont;
    getnum_dlg[2].dp=(void *)buf;
    
    if(is_large)
        large_dialog(getnum_dlg);
        
    int32_t ret=zc_popup_dialog(getnum_dlg,2);
    
    if(ret!=0&&ret!=4)
    {
        cancelgetnum=false;
    }
    
    if(ret==3)
        return atoi(buf);
        
    return initialval;
}

static DIALOG save_tiles_dlg[] =
{
    // (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp)


	{ jwin_win_proc,      0,   0,   120,  100,  vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "Save Tile Pack", NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    //for future tabs
    { d_dummy_proc,         120,  128,  80+1,   8+1,    vc(14),  vc(1),  0,       0,          1,             0,       NULL, NULL, NULL },
    { d_dummy_proc,         120,  128,  80+1,   8+1,    vc(14),  vc(1),  0,       0,          1,             0,       NULL, NULL, NULL },
    //4
    {  jwin_text_proc,        10,    28,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void *) "First",               NULL,   NULL  },
    { jwin_edit_proc,          55,     26,    40,     16,    vc(12),                 vc(1),                   0,       0,          63,    0,  NULL,                                           NULL,   NULL                  },
    //6
    {  jwin_text_proc,        10,    46,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void *) "Count",               NULL,   NULL  },
    { jwin_edit_proc,          55,     44,    40,     16,    vc(12),                 vc(1),                   0,       0,          63,    0,  NULL,                                           NULL,   NULL                  },
    //8
    { jwin_button_proc,   15,   72,  36,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "Save", NULL, NULL },
    { jwin_button_proc,   69,  72,  36,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};


void savesometiles(const char *prompt,int32_t initialval)
{
	
	char firsttile[8], tilecount[8];
	int32_t first_tile_id = 0; int32_t the_tile_count = 1;
	sprintf(firsttile,"%d",0);
	sprintf(tilecount,"%d",1);
	//int32_t ret;
	
	
	
	save_tiles_dlg[0].dp2 = lfont;
	
	sprintf(firsttile,"%d",0);
	sprintf(tilecount,"%d",1);
	
	save_tiles_dlg[5].dp = firsttile;
	save_tiles_dlg[7].dp = tilecount;
	
	if(is_large)
		large_dialog(save_tiles_dlg);
	
	int32_t ret = zc_popup_dialog(save_tiles_dlg,-1);
	jwin_center_dialog(save_tiles_dlg);
	
	if(ret == 8)
	{
		first_tile_id = vbound(atoi(firsttile), 0, NEWMAXTILES);
		the_tile_count = vbound(atoi(tilecount), 1, NEWMAXTILES-first_tile_id);
		if(getname("Save ZTILE(.ztile)", "ztile", NULL,datapath,false))
		{  
			char name[PATH_MAX];
			extract_name(temppath,name,FILENAMEALL);
			PACKFILE *f=pack_fopen_password(temppath,F_WRITE, "");
			if(f)
			{
				writetilefile(f,first_tile_id,the_tile_count);
				pack_fclose(f);
				char tmpbuf[PATH_MAX+20]={0};
				sprintf(tmpbuf,"Saved %s",name);
				jwin_alert("Success!",tmpbuf,NULL,NULL,"O&K",NULL,'k',0,lfont);
			}
		}
	}
}

static DIALOG module_info_dlg[] =
{
    // (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp)


    { jwin_win_proc,      0,   0,   200,  200,  vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "About Current Module", NULL, NULL },
    //1
    {  jwin_text_proc,        10,    20,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void*)"Module:",               NULL,   NULL  },
    //2
    {  jwin_text_proc,        50,    20,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void*)"",               NULL,   NULL  },
   {  jwin_text_proc,        10,    30,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void*)"Author:",               NULL,   NULL  },
    //4
    {  jwin_text_proc,        50,    30,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void*)"",               NULL,   NULL  },
    {  jwin_text_proc,        10,    40,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void*)"",               NULL,   NULL  },
    {  jwin_text_proc,        10,    50,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void*)"Information:",               NULL,   NULL  },
    //7
    
    {  jwin_text_proc,        10,    60,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void*)"",               NULL,   NULL  },
    {  jwin_text_proc,        10,    70,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void*)"",               NULL,   NULL  },
    {  jwin_text_proc,        10,    80,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void*)"",               NULL,   NULL  },
    {  jwin_text_proc,        10,    90,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void*)"",               NULL,   NULL  },
    {  jwin_text_proc,        10,    100,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void*)"",               NULL,   NULL  },
    {  jwin_text_proc,        10,    120,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void*)"",               NULL,   NULL  },
    {  jwin_text_proc,        10,    130,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void*)"",               NULL,   NULL  },
    {  jwin_text_proc,        10,    140,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void*)"",               NULL,   NULL  },
    {  jwin_text_proc,        10,    150,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void*)"",               NULL,   NULL  },
   
    { jwin_button_proc,   40,   160,  50,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "OK", NULL, NULL },
    { jwin_button_proc,   200-40-50,  160,  50,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};



void about_module(const char *prompt,int32_t initialval)
{	
	
	module_info_dlg[0].dp2 = lfont;
	if ( moduledata.moduletitle[0] != 0 )
		module_info_dlg[2].dp = (char*)moduledata.moduletitle;
	
	if ( moduledata.moduleauthor[0] != 0 )
		module_info_dlg[4].dp = (char*)moduledata.moduleauthor;
	
	if ( moduledata.moduleinfo0[0] != 0 )
		module_info_dlg[7].dp = (char*)moduledata.moduleinfo0;
	if ( moduledata.moduleinfo1[0] != 0 )
		module_info_dlg[8].dp = (char*)moduledata.moduleinfo1;
	if ( moduledata.moduleinfo2[0] != 0 )
		module_info_dlg[9].dp = (char*)moduledata.moduleinfo2;
	if ( moduledata.moduleinfo3[0] != 0 )
		module_info_dlg[10].dp = (char*)moduledata.moduleinfo3;
	if ( moduledata.moduleinfo4[0] != 0 )
		module_info_dlg[11].dp = (char*)moduledata.moduleinfo4;
	
	char module_date[255];
	memset(module_date, 0, sizeof(module_date));
	sprintf(module_date,"Build Date: %s %s, %d at @ %d:%d %s", dayextension(moduledata.modday).c_str(), 
			(char*)months[moduledata.modmonth], moduledata.modyear, moduledata.modhour, moduledata.modminute, moduledata.moduletimezone);
	
	
	
	char module_vers[255];
	memset(module_vers, 0, sizeof(module_vers));
	sprintf(module_vers, "Version: %d.%d.%d.%d", moduledata.modver_1, moduledata.modver_2, moduledata.modver_3, moduledata.modver_4);
	
	
	//sprintf(tilecount,"%d",1);
	
	char module_build[255];
	memset(module_build, 0, sizeof(module_build));
	if ( moduledata.modbeta )
		sprintf(module_build,"Module Build: %d, %s: %d", moduledata.modbuild, (moduledata.modbeta<0) ? "Alpha" : "Beta", moduledata.modbeta );
	else
		sprintf(module_build,"Module Build: %d", moduledata.modbuild);
	
	module_info_dlg[12].dp = (char*)module_date;
	module_info_dlg[13].dp = (char*)module_vers;
	module_info_dlg[14].dp = (char*)module_build;
	
	if(is_large)
		large_dialog(module_info_dlg);
	
	int32_t ret = zc_popup_dialog(module_info_dlg,-1);
	jwin_center_dialog(module_info_dlg);
	
	
}





static DIALOG read_tiles_dlg[] =
{
    // (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp)


	{ jwin_win_proc,      0,   0,   120,  100,  vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "Load Tilepack To:", NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    //for future tabs
    { d_dummy_proc,         120,  128,  80+1,   8+1,    vc(14),  vc(1),  0,       0,          1,             0,       NULL, NULL, NULL },
    { d_dummy_proc,         120,  128,  80+1,   8+1,    vc(14),  vc(1),  0,       0,          1,             0,       NULL, NULL, NULL },
    //4
    {  jwin_text_proc,        10,    28,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void *) "Starting at:",               NULL,   NULL  },
    { jwin_edit_proc,          55,     26,    40,     16,    vc(12),                 vc(1),                   0,       0,          63,    0,  NULL,                                           NULL,   NULL                  },
    //6
    {  d_dummy_proc,        10,    46,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void *) "Count",               NULL,   NULL  },
    { d_dummy_proc,          55,     44,    40,     16,    vc(12),                 vc(1),                   0,       0,          63,    0,  NULL,                                           NULL,   NULL                  },
    //8
    { jwin_button_proc,   15,   72,  36,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "Load", NULL, NULL },
    { jwin_button_proc,   69,  72,  36,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};


void writesometiles_to(const char *prompt,int32_t initialval)
{
	
	char firsttile[8];;
	int32_t first_tile_id = 0; int32_t the_tile_count = 1;
	sprintf(firsttile,"%d",0);
		//int32_t ret;
	
	
	
	read_tiles_dlg[0].dp2 = lfont;
	
	sprintf(firsttile,"%d",0);
	//sprintf(tilecount,"%d",1);
	
	read_tiles_dlg[5].dp = firsttile;
	
	if(is_large)
		large_dialog(read_tiles_dlg);
	
	int32_t ret = zc_popup_dialog(read_tiles_dlg,-1);
	jwin_center_dialog(read_tiles_dlg);
	
	if(ret == 8)
	{
		first_tile_id = vbound(atoi(firsttile), 0, NEWMAXTILES);
		//the_tile_count = vbound(atoi(tilecount), 1, NEWMAXTILES-first_tile_id);
		if(getname("Load ZTILE(.ztile)", "ztile", NULL,datapath,false))
		{  
			
			char name[256];
			extract_name(temppath,name,FILENAMEALL);
			PACKFILE *f=pack_fopen_password(temppath,F_READ, "");
			if(f)
			{
				
				if (!readtilefile_to_location(f,first_tile_id))
				{
					al_trace("Could not read from .ztile packfile %s\n", name);
					jwin_alert("ZTILE File: Error","Could not load the specified Tile.",NULL,NULL,"O&K",NULL,'k',0,lfont);
				}
				else
				{
					jwin_alert("ZTILE File: Success!","Loaded the source tiles to your tile sheets!",NULL,NULL,"O&K",NULL,'k',0,lfont);
				}
				pack_fclose(f);
			}
		}
	}
}


static DIALOG save_combofiles_dlg[] =
{
    // (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp)


	{ jwin_win_proc,      0,   0,   120,  100,  vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "Save Combo Pack", NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    //for future tabs
    { d_dummy_proc,         120,  128,  80+1,   8+1,    vc(14),  vc(1),  0,       0,          1,             0,       NULL, NULL, NULL },
    { d_dummy_proc,         120,  128,  80+1,   8+1,    vc(14),  vc(1),  0,       0,          1,             0,       NULL, NULL, NULL },
    //4
    {  jwin_text_proc,        10,    28,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void *) "First",               NULL,   NULL  },
    { jwin_edit_proc,          55,     26,    40,     16,    vc(12),                 vc(1),                   0,       0,          63,    0,  NULL,                                           NULL,   NULL                  },
    //6
    {  jwin_text_proc,        10,    46,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void *) "Count",               NULL,   NULL  },
    { jwin_edit_proc,          55,     44,    40,     16,    vc(12),                 vc(1),                   0,       0,          63,    0,  NULL,                                           NULL,   NULL                  },
    //8
    { jwin_button_proc,   15,   72,  36,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "Save", NULL, NULL },
    { jwin_button_proc,   69,  72,  36,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};


void savesomecombos(const char *prompt,int32_t initialval)
{
	
	char firsttile[8], tilecount[8];
	int32_t first_tile_id = 0; int32_t the_tile_count = 1;
	sprintf(firsttile,"%d",0);
	sprintf(tilecount,"%d",1);
	//int32_t ret;
	
	
	
	save_combofiles_dlg[0].dp2 = lfont;
	
	sprintf(firsttile,"%d",0);
	sprintf(tilecount,"%d",1);
	
	save_combofiles_dlg[5].dp = firsttile;
	save_combofiles_dlg[7].dp = tilecount;
	
	if(is_large)
		large_dialog(save_combofiles_dlg);
	
	int32_t ret = zc_popup_dialog(save_combofiles_dlg,-1);
	jwin_center_dialog(save_combofiles_dlg);
	
	if(ret == 8)
	{
		first_tile_id = vbound(atoi(firsttile), 0, (MAXCOMBOS-1));
		the_tile_count = vbound(atoi(tilecount), 1, (MAXCOMBOS-1)-first_tile_id);
		if(getname("Save ZCOMBO(.zcombo)", "zcombo", NULL,datapath,false))
		{  
			char name[PATH_MAX];
			extract_name(temppath,name,FILENAMEALL);
			PACKFILE *f=pack_fopen_password(temppath,F_WRITE, "");
			if(f)
			{
				writecombofile(f,first_tile_id,the_tile_count);
				pack_fclose(f);
				char tmpbuf[PATH_MAX+20]={0};
				sprintf(tmpbuf,"Saved %s",name);
				jwin_alert("Success!",tmpbuf,NULL,NULL,"O&K",NULL,'k',0,lfont);
			}
		}
	}
}


static DIALOG load_comboset_dlg[] =
{
    // (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp)


	{ jwin_win_proc,      0,   0,   120,  100,  vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "Combo Set (Range)", NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    //for future tabs
    { d_dummy_proc,         120,  128,  80+1,   8+1,    vc(14),  vc(1),  0,       0,          1,             0,       NULL, NULL, NULL },
    { d_dummy_proc,         120,  128,  80+1,   8+1,    vc(14),  vc(1),  0,       0,          1,             0,       NULL, NULL, NULL },
    //4
    {  jwin_text_proc,        10,    28,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void *) "First:",               NULL,   NULL  },
    { jwin_edit_proc,          55,     26,    40,     16,    vc(12),                 vc(1),                   0,       0,          63,    0,  NULL,                                           NULL,   NULL                  },
    //6
    {  d_dummy_proc,        10,    46,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void *) "Count",               NULL,   NULL  },
    { d_dummy_proc,          55,     44,    40,     16,    vc(12),                 vc(1),                   0,       0,          63,    0,  NULL,                                           NULL,   NULL                  },
    //8
    { jwin_button_proc,   15,   72,  36,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "Load", NULL, NULL },
    { jwin_button_proc,   69,  72,  36,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { jwin_check_proc,        10,     46,     95,      9,    vc(14),                 vc(1),                   0,       0,           1,    0, (void *) "Don't Overwrite",                      NULL,   NULL                  },
    
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

void writesomecombos(const char *prompt,int32_t initialval)
{
	
	char firsttile[8];
	int32_t first_tile_id = 0; int32_t the_tile_count = 1;
	sprintf(firsttile,"%d",0);
		//int32_t ret;
	
	
	
	load_comboset_dlg[0].dp2 = lfont;
	
	sprintf(firsttile,"%d",0);
	//sprintf(tilecount,"%d",1);
	
	load_comboset_dlg[5].dp = firsttile;
	
	byte nooverwrite = 0;
	
	
	if(is_large)
		large_dialog(load_comboset_dlg);
	
	int32_t ret = zc_popup_dialog(load_comboset_dlg,-1);
	jwin_center_dialog(load_comboset_dlg);
	
	if(ret == 8)
	{
		if (load_comboset_dlg[10].flags & D_SELECTED) nooverwrite = 1;
	
		al_trace("Nooverwrite is: %d\n", nooverwrite);
		first_tile_id = vbound(atoi(firsttile), 0, (MAXCOMBOS-1));
		//the_tile_count = vbound(atoi(tilecount), 1, NEWMAXTILES-first_tile_id);
		if(getname("Load ZCOMBO(.zcombo)", "zcombo", NULL,datapath,false))
		{  
			char name[256];
			extract_name(temppath,name,FILENAMEALL);
			PACKFILE *f=pack_fopen_password(temppath,F_READ, "");
			if(f)
			{
				
				if (!readcombofile(f,first_tile_id,nooverwrite))
				{
					al_trace("Could not read from .zcombo packfile %s\n", name);
					jwin_alert("ZCOMBO File: Error","Could not load the specified combos.",NULL,NULL,"O&K",NULL,'k',0,lfont);
				}
				else
				{
					jwin_alert("ZCOMBO File: Success!","Loaded the source combos to your combo pages!",NULL,NULL,"O&K",NULL,'k',0,lfont);
					saved=false;
				}
				pack_fclose(f);
			}
			
		}
	}
}

static DIALOG load_combopack_dlg[] =
{
    // (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp)


	{ jwin_win_proc,      0,   0,   120,  100,  vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "Import Full Combo Package 1:1", NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    //for future tabs
    { d_dummy_proc,         120,  128,  80+1,   8+1,    vc(14),  vc(1),  0,       0,          1,             0,       NULL, NULL, NULL },
    { d_dummy_proc,         120,  128,  80+1,   8+1,    vc(14),  vc(1),  0,       0,          1,             0,       NULL, NULL, NULL },
    //4
    {  d_dummy_proc,        10,    28,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void *) "Starting at:",               NULL,   NULL  },
    { d_dummy_proc,          55,     26,    40,     16,    vc(12),                 vc(1),                   0,       0,          63,    0,  NULL,                                           NULL,   NULL                  },
    //6
    {  d_dummy_proc,        10,    46,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void *) "Count",               NULL,   NULL  },
    { d_dummy_proc,          55,     44,    40,     16,    vc(12),                 vc(1),                   0,       0,          63,    0,  NULL,                                           NULL,   NULL                  },
    //8
    { jwin_button_proc,   15,   72,  36,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "Load", NULL, NULL },
    { jwin_button_proc,   69,  72,  36,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { jwin_check_proc,        10,     42,     95,      9,    vc(14),                 vc(1),                   0,       0,           1,    0, (void *) "Don't Overwrite",                      NULL,   NULL                  },
    
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

void loadcombopack(const char *prompt,int32_t initialval)
{
	
	char firsttile[8];
	int32_t first_tile_id = 0; int32_t the_tile_count = 1;
	sprintf(firsttile,"%d",0);
		//int32_t ret;
	
	
	
	load_combopack_dlg[0].dp2 = lfont;
	
	sprintf(firsttile,"%d",0);
	//sprintf(tilecount,"%d",1);
	
	load_combopack_dlg[5].dp = firsttile;
	
	byte nooverwrite = 0;
	
	
	if(is_large)
		large_dialog(load_combopack_dlg);
	
	int32_t ret = zc_popup_dialog(load_combopack_dlg,-1);
	jwin_center_dialog(load_combopack_dlg);
	
	if(ret == 8)
	{
		if (load_combopack_dlg[10].flags & D_SELECTED) nooverwrite = 1;
	
		al_trace("Nooverwrite is: %d\n", nooverwrite);
		first_tile_id = vbound(atoi(firsttile), 0, (MAXCOMBOS-1));
		//the_tile_count = vbound(atoi(tilecount), 1, NEWMAXTILES-first_tile_id);
		if(getname("Load ZCOMBO(.zcombo)", "zcombo", NULL,datapath,false))
		{  
			char name[256];
			extract_name(temppath,name,FILENAMEALL);
			PACKFILE *f=pack_fopen_password(temppath,F_READ, "");
			if(f)
			{
				//need dialogue here
				if (!readcombofile(f,0,nooverwrite))
				{
					al_trace("Could not read from .zcombo packfile %s\n", name);
					jwin_alert("ZCOMBO File: Error","Could not load the specified Tile.",NULL,NULL,"O&K",NULL,'k',0,lfont);
				}
				else
				{
					jwin_alert("ZCOMBO File: Success!","Loaded the source combos to your combo pages!",NULL,NULL,"O&K",NULL,'k',0,lfont);
					saved=false;
				}
			}
	
			pack_fclose(f);
		}
	}
}


static DIALOG read_combopack_dlg[] =
{
    // (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp)


	{ jwin_win_proc,      0,   0,   120,  100,  vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "Load Combos (Specific Dest)", NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    //for future tabs
    { d_dummy_proc,         120,  128,  80+1,   8+1,    vc(14),  vc(1),  0,       0,          1,             0,       NULL, NULL, NULL },
    { d_dummy_proc,         120,  128,  80+1,   8+1,    vc(14),  vc(1),  0,       0,          1,             0,       NULL, NULL, NULL },
    //4
    {  jwin_text_proc,        10,    24,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void *) "Starting at:",               NULL,   NULL  },
    { jwin_edit_proc,          55,     22,    40,     16,    vc(12),                 vc(1),                   0,       0,          63,    0,  NULL,                                           NULL,   NULL                  },
    //6
    {  d_dummy_proc,        10,    46,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void *) "Count",               NULL,   NULL  },
    { d_dummy_proc,          55,     44,    40,     16,    vc(12),                 vc(1),                   0,       0,          63,    0,  NULL,                                           NULL,   NULL                  },
    //8
    { jwin_button_proc,   15,   72,  36,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "Load", NULL, NULL },
    { jwin_button_proc,   69,  72,  36,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    //10
    { jwin_check_proc,        10,     58,     95,      9,    vc(14),                 vc(1),                   0,       0,           1,    0, (void *) "Don't Overwrite",                      NULL,   NULL                  },
    //11
    {  jwin_text_proc,        10,    42,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void *) "Skip:",               NULL,   NULL  },
    //12
    { jwin_edit_proc,          55,     40,    40,     16,    vc(12),                 vc(1),                   0,       0,          63,    0,  NULL,                                           NULL,   NULL                  },
    
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};



void writesomecombos_to(const char *prompt,int32_t initialval)
{
	
	char firsttile[8];
	char skiptile[8];
	int32_t first_tile_id = 0; int32_t the_tile_count = 1;
	sprintf(firsttile,"%d",0);
		//int32_t ret;
	
	
	
	read_combopack_dlg[0].dp2 = lfont;
	
	sprintf(skiptile,"%d",0);
	//sprintf(tilecount,"%d",1);
	
	read_combopack_dlg[5].dp = firsttile;
	
	byte nooverwrite = 0;
	int32_t skipover = 0;
	
	sprintf(skiptile,"%d",0);
	//sprintf(tilecount,"%d",1);
	
	read_combopack_dlg[12].dp = skiptile;
	
	if(is_large)
		large_dialog(read_combopack_dlg);
	
	int32_t ret = zc_popup_dialog(read_combopack_dlg,-1);
	jwin_center_dialog(read_combopack_dlg);
	
	if(ret == 8)
	{
		if (read_combopack_dlg[10].flags & D_SELECTED) nooverwrite = 1;
		
		first_tile_id = vbound(atoi(firsttile), 0, (MAXCOMBOS-1));
		skipover = vbound(atoi(skiptile), 0, (MAXCOMBOS-1));
		al_trace("skipover is: %d\n", skipover);
		//skipover = vbound(skipover, 0, (MAXCOMBOS-1-skipover));
		//the_tile_count = vbound(atoi(tilecount), 1, NEWMAXTILES-first_tile_id);
		if(getname("Load ZCOMBO(.zcombo)", "zcombo", NULL,datapath,false))
		{  
			char name[256];
			extract_name(temppath,name,FILENAMEALL);
			PACKFILE *f=pack_fopen_password(temppath,F_READ, "");
			if(f)
			{
				
				if (!readcombofile_to_location(f,first_tile_id,nooverwrite, skipover))
				{
					al_trace("Could not read from .zcombo packfile %s\n", name);
					jwin_alert("ZCOMBO File: Error","Could not load the specified combos.",NULL,NULL,"O&K",NULL,'k',0,lfont);
				}
				else
				{
					jwin_alert("ZCOMBO File: Success!","Loaded the source combos to your combo pages!",NULL,NULL,"O&K",NULL,'k',0,lfont);
					saved=false;
				}
				pack_fclose(f);
			}
			
		}
	}
}



static DIALOG save_dmaps_dlg[] =
{
    // (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp)


	{ jwin_win_proc,      0,   0,   120,  100,  vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "Save DMaps (.zdmap)", NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    //for future tabs
    { d_dummy_proc,         120,  128,  80+1,   8+1,    vc(14),  vc(1),  0,       0,          1,             0,       NULL, NULL, NULL },
    { d_dummy_proc,         120,  128,  80+1,   8+1,    vc(14),  vc(1),  0,       0,          1,             0,       NULL, NULL, NULL },
    //4
    {  jwin_text_proc,        10,    28,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void *) "First",               NULL,   NULL  },
    { jwin_edit_proc,          55,     26,    40,     16,    vc(12),                 vc(1),                   0,       0,          63,    0,  NULL,                                           NULL,   NULL                  },
    //6
    {  jwin_text_proc,        10,    46,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void *) "Last",               NULL,   NULL  },
    { jwin_edit_proc,          55,     44,    40,     16,    vc(12),                 vc(1),                   0,       0,          63,    0,  NULL,                                           NULL,   NULL                  },
    //8
    { jwin_button_proc,   15,   72,  36,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "Save", NULL, NULL },
    { jwin_button_proc,   69,  72,  36,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};


void savesomedmaps(const char *prompt,int32_t initialval)
{
	
	char firstdmap[8], lastdmap[8];
	int32_t first_dmap_id = 0; int32_t last_dmap_id = 0;
	sprintf(firstdmap,"%d",0);
	sprintf(lastdmap,"%d",1);
	//int32_t ret;
	
	
	
	save_dmaps_dlg[0].dp2 = lfont;
	
	sprintf(firstdmap,"%d",0);
	sprintf(lastdmap,"%d",0);
	
	save_dmaps_dlg[5].dp = firstdmap;
	save_dmaps_dlg[7].dp = lastdmap;
	
	if(is_large)
		large_dialog(save_dmaps_dlg);
	
	int32_t ret = zc_popup_dialog(save_dmaps_dlg,-1);
	jwin_center_dialog(save_dmaps_dlg);
	
	if(ret == 8)
	{
		first_dmap_id = vbound(atoi(firstdmap), 0, MAXDMAPS-1);
		last_dmap_id = vbound(atoi(lastdmap), 0,  MAXDMAPS-1);
		
		if ( last_dmap_id < first_dmap_id )
		{
			int32_t swap = last_dmap_id;
			last_dmap_id = first_dmap_id;
			first_dmap_id = swap;			
		}
		if(!getname("Export DMaps(.zdmapzq)_)","zdmap",NULL,datapath,false))
		
		
		saved=false;
	    
		PACKFILE *f=pack_fopen_password(temppath,F_WRITE, "");
		if(f)
		{
			if(!writesomedmaps(f,first_dmap_id,last_dmap_id,MAXDMAPS))
			{
				char buf[PATH_MAX+20],name[PATH_MAX];
				extract_name(temppath,name,FILENAMEALL);
				sprintf(buf,"Unable to load %s",name);
				jwin_alert("Error",buf,NULL,NULL,"O&K",NULL,'k',0,lfont);
			}
			else
			{
				char name[PATH_MAX];
				extract_name(temppath,name,FILENAMEALL);
				char tmpbuf[PATH_MAX+20]={0};
				sprintf(tmpbuf,"Saved %s",name);
				jwin_alert("Success!",tmpbuf,NULL,NULL,"O&K",NULL,'k',0,lfont);
			}
		}
		pack_fclose(f);
	}
}

static DIALOG save_comboaliasfiles_dlg[] =
{
    // (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp)


	{ jwin_win_proc,      0,   0,   120,  100,  vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "Save Combo Alias Pack", NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    //for future tabs
    { d_dummy_proc,         120,  128,  80+1,   8+1,    vc(14),  vc(1),  0,       0,          1,             0,       NULL, NULL, NULL },
    { d_dummy_proc,         120,  128,  80+1,   8+1,    vc(14),  vc(1),  0,       0,          1,             0,       NULL, NULL, NULL },
    //4
    {  jwin_text_proc,        10,    28,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void *) "First",               NULL,   NULL  },
    { jwin_edit_proc,          55,     26,    40,     16,    vc(12),                 vc(1),                   0,       0,          63,    0,  NULL,                                           NULL,   NULL                  },
    //6
    {  jwin_text_proc,        10,    46,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void *) "Count",               NULL,   NULL  },
    { jwin_edit_proc,          55,     44,    40,     16,    vc(12),                 vc(1),                   0,       0,          63,    0,  NULL,                                           NULL,   NULL                  },
    //8
    { jwin_button_proc,   15,   72,  36,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "Save", NULL, NULL },
    { jwin_button_proc,   69,  72,  36,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};


void savesomecomboaliases(const char *prompt,int32_t initialval)
{
	
	char firsttile[8], tilecount[8];
	int32_t first_tile_id = 0; int32_t the_tile_count = 1;
	sprintf(firsttile,"%d",0);
	sprintf(tilecount,"%d",1);
	//int32_t ret;
	
	
	
	save_comboaliasfiles_dlg[0].dp2 = lfont;
	
	sprintf(firsttile,"%d",0);
	sprintf(tilecount,"%d",1);
	
	save_comboaliasfiles_dlg[5].dp = firsttile;
	save_comboaliasfiles_dlg[7].dp = tilecount;
	
	if(is_large)
		large_dialog(save_comboaliasfiles_dlg);
	
	int32_t ret = zc_popup_dialog(save_comboaliasfiles_dlg,-1);
	jwin_center_dialog(save_comboaliasfiles_dlg);
	
	if(ret == 8)
	{
		first_tile_id = vbound(atoi(firsttile), 0, (MAXCOMBOALIASES-1));
		the_tile_count = vbound(atoi(tilecount), 1, (MAXCOMBOALIASES-1)-first_tile_id);
		if(getname("Save ZALIAS(.zalias)", "zalias", NULL,datapath,false))
		{  
			char name[PATH_MAX];
			extract_name(temppath,name,FILENAMEALL);
			PACKFILE *f=pack_fopen_password(temppath,F_WRITE, "");
			if(f)
			{
				writecomboaliasfile(f,first_tile_id,the_tile_count);
				pack_fclose(f);
				char tmpbuf[PATH_MAX+20]={0};
				sprintf(tmpbuf,"Saved %s",name);
				jwin_alert("Success!",tmpbuf,NULL,NULL,"O&K",NULL,'k',0,lfont);
			}
		}
	}
}


static DIALOG read_comboaliaspack_dlg[] =
{
    // (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp)


	{ jwin_win_proc,      0,   0,   120,  100,  vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "Load Combo Pack To:", NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    //for future tabs
    { d_dummy_proc,         120,  128,  80+1,   8+1,    vc(14),  vc(1),  0,       0,          1,             0,       NULL, NULL, NULL },
    { d_dummy_proc,         120,  128,  80+1,   8+1,    vc(14),  vc(1),  0,       0,          1,             0,       NULL, NULL, NULL },
    //4
    {  jwin_text_proc,        10,    28,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void *) "Starting at:",               NULL,   NULL  },
    { jwin_edit_proc,          55,     26,    40,     16,    vc(12),                 vc(1),                   0,       0,          63,    0,  NULL,                                           NULL,   NULL                  },
    //6
    {  d_dummy_proc,        10,    46,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void *) "Count",               NULL,   NULL  },
    { d_dummy_proc,          55,     44,    40,     16,    vc(12),                 vc(1),                   0,       0,          63,    0,  NULL,                                           NULL,   NULL                  },
    //8
    { jwin_button_proc,   15,   72,  36,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "Load", NULL, NULL },
    { jwin_button_proc,   69,  72,  36,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};


void writesomecomboaliases_to(const char *prompt,int32_t initialval)
{
	
	char firsttile[8];;
	int32_t first_tile_id = 0; int32_t the_tile_count = 1;
	sprintf(firsttile,"%d",0);
		//int32_t ret;
	
	
	
	read_comboaliaspack_dlg[0].dp2 = lfont;
	
	sprintf(firsttile,"%d",0);
	//sprintf(tilecount,"%d",1);
	
	read_comboaliaspack_dlg[5].dp = firsttile;
	
	if(is_large)
		large_dialog(read_comboaliaspack_dlg);
	
	int32_t ret = zc_popup_dialog(read_comboaliaspack_dlg,-1);
	jwin_center_dialog(read_comboaliaspack_dlg);
	
	if(ret == 8)
	{
		first_tile_id = vbound(atoi(firsttile), 0, (MAXCOMBOALIASES-1));
		//the_tile_count = vbound(atoi(tilecount), 1, NEWMAXTILES-first_tile_id);
		if(getname("Load ZALIAS(.zalias)", "zalias", NULL,datapath,false))
		{  
			char name[256];
			extract_name(temppath,name,FILENAMEALL);
			PACKFILE *f=pack_fopen_password(temppath,F_READ, "");
			if(f)
			{
				
				if (!readcomboaliasfile_to_location(f,first_tile_id))
				{
					al_trace("Could not read from .zcombo packfile %s\n", name);
					jwin_alert("ZALIAS File: Error","Could not load the specified combo aliases.",NULL,NULL,"O&K",NULL,'k',0,lfont);
				}
				else
				{
					jwin_alert("ZALIAS File: Success!","Loaded the source combos to your combo alias table!",NULL,NULL,"O&K",NULL,'k',0,lfont);
					saved=false;
				}
				pack_fclose(f);
			}
		}
	}
}




//Doorsets

static DIALOG save_doorset_dlg[] =
{
    // (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp)
    { jwin_win_proc,      0,   0,   120,  100,  vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "Save Doorset", NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    //for future tabs
    { d_dummy_proc,         120,  128,  80+1,   8+1,    vc(14),  vc(1),  0,       0,          1,             0,       NULL, NULL, NULL },
    { d_dummy_proc,         120,  128,  80+1,   8+1,    vc(14),  vc(1),  0,       0,          1,             0,       NULL, NULL, NULL },
    //4
    {  jwin_text_proc,        10,    28,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void *) "First",               NULL,   NULL  },
    { jwin_edit_proc,          55,     26,    40,     16,    vc(12),                 vc(1),                   0,       0,          63,    0,  NULL,                                           NULL,   NULL                  },
    //6
    {  jwin_text_proc,        10,    46,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void *) "Count",               NULL,   NULL  },
    { jwin_edit_proc,          55,     44,    40,     16,    vc(12),                 vc(1),                   0,       0,          63,    0,  NULL,                                           NULL,   NULL                  },
    //8
    { jwin_button_proc,   15,   72,  36,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "Save", NULL, NULL },
    { jwin_button_proc,   69,  72,  36,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};


void do_exportdoorset(const char *prompt,int32_t initialval)
{
	char firstdoor[8], doorct[8];
	int32_t first_doorset_id = 0; int32_t the_doorset_count = 1;
	sprintf(firstdoor,"%d",0);
	sprintf(doorct,"%d",1);
	//int32_t ret;
	save_doorset_dlg[0].dp2 = lfont;
	
	sprintf(firstdoor,"%d",0);
	sprintf(doorct,"%d",1);
	
	save_doorset_dlg[5].dp = firstdoor;
	save_doorset_dlg[7].dp = doorct;
	
	if(is_large)
		large_dialog(save_doorset_dlg);
	
	int32_t ret = zc_popup_dialog(save_doorset_dlg,-1);
	jwin_center_dialog(save_doorset_dlg);
	
	if(ret == 8) //OK
	{
		/* sanity bounds
		first_doorset_id = vbound(atoi(firstdoor), 0, (MAXCOMBOS-1));
		the_doorset_count = vbound(atoi(doorct), 1, (MAXCOMBOS-1)-first_doorset_id);
		*/
		if(getname("Save ZDOORS(.zdoors)", "zdoors", NULL,datapath,false))
		{  
			char name[256];
			extract_name(temppath,name,FILENAMEALL);
			PACKFILE *f=pack_fopen_password(temppath,F_WRITE, "");
			if(f)
			{
				writezdoorsets(f,first_doorset_id,the_doorset_count);
				pack_fclose(f);
				char tmpbuf[512]={0};
				sprintf(tmpbuf,"Saved %s",name);
				jwin_alert("Success!",tmpbuf,NULL,NULL,"O&K",NULL,'k',0,lfont);
			}
		}
	}
}

static DIALOG load_doorset_dlg[] =
{
    // (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp)
    { jwin_win_proc,      0,   0,   120,  124,  vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "Door Set (Range)", NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    //for future tabs
    { d_dummy_proc,         120,  128,  80+1,   8+1,    vc(14),  vc(1),  0,       0,          1,             0,       NULL, NULL, NULL },
    { d_dummy_proc,         120,  128,  80+1,   8+1,    vc(14),  vc(1),  0,       0,          1,             0,       NULL, NULL, NULL },
    //4
    {  jwin_text_proc,        10,    28,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void *) "First:",               NULL,   NULL  },
    { jwin_edit_proc,          55,     26,    40,     16,    vc(12),                 vc(1),                   0,       0,          63,    0,  NULL,                                           NULL,   NULL                  },
    //6
    {  jwin_text_proc,        10,    46,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void *) "Count",               NULL,   NULL  },
    { jwin_edit_proc,          55,     44,    40,     16,    vc(12),                 vc(1),                   0,       0,          63,    0,  NULL,                                           NULL,   NULL                  },
    //8
    { jwin_button_proc,   15,   92,  36,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "Load", NULL, NULL },
    { jwin_button_proc,   69,  92,  36,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    //10
    {  jwin_text_proc,        10,    64,     20,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void *) "Dest",               NULL,   NULL  },
    { jwin_edit_proc,          55,     63,    40,     16,    vc(12),                 vc(1),                   0,       0,          63,    0,  NULL,                                           NULL,   NULL                  },
    //8
    
    // { jwin_check_proc,        10,     46,     95,      9,    vc(14),                 vc(1),                   0,       0,           1,    0, (void *) "Don't Overwrite",                      NULL,   NULL                  },
    
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

void do_importdoorset(const char *prompt,int32_t initialval)
{
	
	char firstdoor[8], doorct[8], destid[8];
	int32_t first_doorset_id = 0; int32_t the_doorset_count = 1;
	int32_t the_dest_id = 0;
	sprintf(firstdoor,"%d",0);
	sprintf(doorct,"%d",1);
	sprintf(destid,"%d",0);
		//int32_t ret;
	
	save_doorset_dlg[0].dp2 = lfont;
	
	load_doorset_dlg[5].dp = firstdoor;
	load_doorset_dlg[7].dp = doorct;
	load_doorset_dlg[11].dp = destid;
	
	byte nooverwrite = 0;
	
	if(is_large)
		large_dialog(load_doorset_dlg);
	
	int32_t ret = zc_popup_dialog(load_doorset_dlg,-1);
	jwin_center_dialog(load_doorset_dlg);
	
	if(ret == 8) //OK
	{
		//if (load_doorset_dlg[10].flags & D_SELECTED) nooverwrite = 1;
	
		//al_trace("Nooverwrite is: %d\n", nooverwrite);
		//sanity bound
		first_doorset_id = vbound(atoi(firstdoor), 0, door_combo_set_count);
		the_doorset_count = vbound(atoi(doorct), 1, door_combo_set_count);
		the_dest_id = vbound(atoi(destid), 0, door_combo_set_count);
		if(getname("Load ZDOORS(.zdoors)", "zdoors", NULL,datapath,false))
		{  
			char name[256];
			extract_name(temppath,name,FILENAMEALL);
			PACKFILE *f=pack_fopen_password(temppath,F_READ, "");
			if(f)
			{
				int32_t ret = readzdoorsets(f,first_doorset_id,the_doorset_count, the_dest_id);
				
				if (!ret)
				{
					al_trace("Could not read from .zdoors packfile %s\n", name);
					jwin_alert("ZDOORS File: Error","Could not load the specified doorsets.",NULL,NULL,"O&K",NULL,'k',0,lfont);
				}
				else if ( ret == 1 )
				{
					jwin_alert("ZDOORS File: Success!","Loaded the source doorsets!",NULL,NULL,"O&K",NULL,'k',0,lfont);
					saved=false;
				}
				else if ( ret == 2 )
				{
					jwin_alert("ZDOORS File: Issue:","Targets exceed doorset count!",NULL,NULL,"O&K",NULL,'k',0,lfont);
					saved=false;
				}
				pack_fclose(f);
			}
		}
	}
}

int32_t gettilepagenumber(const char *prompt, int32_t initialval)
{
    char buf[20];
    sprintf(buf,"%d",initialval);
    getnum_dlg[0].dp=(void *)prompt;
    getnum_dlg[0].dp2=lfont;
    getnum_dlg[2].dp=buf;
    
    if(is_large)
        large_dialog(getnum_dlg);
        
    int32_t ret = zc_popup_dialog(getnum_dlg,2);
    
    if(ret==3)
        return atoi(buf);
        
    return -1;
}

int32_t gethexnumber(const char *prompt,int32_t initialval)
{
    cancelgetnum=true;
    char buf[20];
    sprintf(buf,"%X",initialval);
    getnum_dlg[0].dp=(void *)prompt;
    getnum_dlg[0].dp2=lfont;
    getnum_dlg[2].dp=(void *)buf;
    
    if(is_large)
        large_dialog(getnum_dlg);
        
    int32_t ret=zc_popup_dialog(getnum_dlg,2);
    
    if(ret!=0&&ret!=4)
    {
        cancelgetnum=false;
    }
    
    if(ret==3)
        return zc_xtoi(buf);
        
    return initialval;
}

void update_combo_cycling()
{
    Map.update_combo_cycling();
}

void update_freeform_combos()
{
    Map.update_freeform_combos();
}

bool layers_valid(mapscr *tempscr)
{
    for(int32_t i=0; i<6; i++)
    {
        if(tempscr->layermap[i]>map_count)
        {
            return false;
        }
    }
    
    return true;
}

void fix_layers(mapscr *tempscr, bool showwarning)
{
    char buf[80]="layers have been changed: ";
    
    for(int32_t i=0; i<6; i++)
    {
        if(tempscr->layermap[i]>map_count)
        {
            strcat(buf, "%d ");
            sprintf(buf, buf, i+1);
            tempscr->layermap[i]=0;
        }
    }
    
    if(showwarning)
    {
        jwin_alert("Invalid layers detected",
                   "One or more layers on this screen used",
                   "maps that do not exist. The settings of these",
                   buf, "O&K", NULL, 'o', 0, lfont);
    }
}

/***********************/
/*** dialog handlers ***/
/***********************/

extern const char *colorlist(int32_t index, int32_t *list_size);

static char autobackup_str_buf[32];
const char *autobackuplist(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        bound(index,0,10);
        
        if(index==0)
        {
            sprintf(autobackup_str_buf,"Disabled");
        }
        else
        {
            sprintf(autobackup_str_buf,"%2d",index);
        }
        
        return autobackup_str_buf;
    }
    
    *list_size=11;
    return NULL;
}

static char autosave_str_buf[32];
const char *autosavelist(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        bound(index,0,10);
        
        if(index==0)
        {
            sprintf(autosave_str_buf,"Disabled");
        }
        else
        {
            sprintf(autosave_str_buf,"%2d Minute%c",index,index>1?'s':0);
        }
        
        return autosave_str_buf;
    }
    
    *list_size=11;
    return NULL;
}

const char *autosavelist2(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        bound(index,0,9);
        sprintf(autosave_str_buf,"%2d",index+1);
        return autosave_str_buf;
    }
    
    *list_size=10;
    return NULL;
}


static int32_t options_1_list[] =
{
    // dialog control number
    4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, -1
};

static int32_t options_2_list[] =
{
    // dialog control number
	50, 51, -1
};

static int32_t options_3_list[] =
{
    // dialog control number
    31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, -1
};
static int32_t options_4_list[] =
{
	57, 58, 59, 60,
	-1
};

static TABPANEL options_tabs[] =
{
    // (text)
    { (char *)" 1 ",       D_SELECTED,   options_1_list,  0, NULL },
    { (char *)" 2 ",       0,            options_2_list,  0, NULL },
    { (char *)" 3 ",       0,            options_3_list,  0, NULL },
    { (char *)" 4 ",       0,            options_4_list,  0, NULL },
    { NULL,                0,            NULL, 0, NULL }
};

static ListData autobackup_list(autobackuplist, &font);
static ListData autosave_list(autosavelist, &font);
static ListData autosave_list2(autosavelist2, &font);
static ListData color_list(colorlist, &font);
static ListData snapshotformat_list(snapshotformatlist, &font);
void init_ffpos();

static DIALOG options_dlg[] =
{
    /* (dialog proc)           (x)     (y)     (w)     (h)    (fg)        (bg)      (key)    (flags)    (d1)  (d2) (dp) */
    { jwin_win_proc,            0,      0,    260,    238,    vc(14),     vc(1),       0,    D_EXIT,     0,    0, (void *) "ZQuest Options",                                              NULL,   NULL                },
    { jwin_tab_proc,            4,     23,    252,    182,    vc(0),      vc(15),      0,    0,          0,    0, (void *) options_tabs,                                                  NULL, (void *)options_dlg },
    { jwin_button_proc,        60,    212,     61,     21,    vc(14),     vc(1),      13,    D_EXIT,     0,    0, (void *) "OK",                                                          NULL,   NULL                },
    { jwin_button_proc,       140,    212,     61,     21,    vc(14),     vc(1),      27,    D_EXIT,     0,    0, (void *) "Cancel",                                                      NULL,   NULL                },
    // 4
    { jwin_check_proc,         12,     44,    129,      9,    vc(14),     vc(1),       0,    0,          1,    0, (void *) "Mouse scroll",                                                NULL,   NULL                },
    { jwin_check_proc,         12,     54,    129,      9,    vc(14),     vc(1),       0,    0,          1,    0, (void *) "Save paths",                                                  NULL,   NULL                },
    { jwin_check_proc,         12,     64,    129,      9,    vc(14),     vc(1),       0,    0,          1,    0, (void *) "Palette cycle",                                               NULL,   NULL                },
    { jwin_check_proc,         12,     74,    129,      9,    vc(14),     vc(1),       0,    0,          1,    0, (void *) "Vsync",                                                       NULL,   NULL                },
    { jwin_check_proc,         12,     84,    129,      9,    vc(14),     vc(1),       0,    0,          1,    0, (void *) "Show Frames Per Second",                                      NULL,   NULL                },
    { jwin_check_proc,         12,     94,    129,      9,    vc(14),     vc(1),       0,    0,          1,    0, (void *) "Combo Brush",                                                 NULL,   NULL                },
    // 10
	{ jwin_check_proc,         12,    104,    129,      9,    vc(14),     vc(1),       0,    0,          1,    0, (void *) "Floating Brush",                                              NULL,   NULL                },
    { jwin_check_proc,         12,    114,    129,      9,    vc(14),     vc(1),       0,    0,          1,    0, (void *) "Reload Last Quest",                                                 NULL,   NULL                },
    { jwin_check_proc,         12,    124,    129,      9,    vc(14),     vc(1),       0,    0,          1,    0, (void *) "Show Misaligns",                                              NULL,   NULL                },
    { jwin_check_proc,         12,    134,    129,      9,    vc(14),     vc(1),       0,    0,          1,    0, (void *) "Animate Combos",                                              NULL,   NULL                },
    { jwin_check_proc,         12,    144,    129,      9,    vc(14),     vc(1),       0,    0,          1,    0, (void *) "Overwrite Protection",                                        NULL,   NULL                },
    // 15
	{ jwin_check_proc,         12,    154,    129,      9,    vc(14),     vc(1),       0,    0,          1,    0, (void *) "Tile Protection",                                             NULL,   NULL                },
    { jwin_check_proc,         12,    164,    129,      9,    vc(14),     vc(1),       0,    0,          1,    0, (void *) "Use Static for Invalid Data",                                 NULL,   NULL                },
    { jwin_check_proc,         12,    174,    129,      9,    vc(14),     vc(1),       0,    0,          1,    0, (void *) "Use Small Mode",                                              NULL,   NULL                },
    { jwin_check_proc,         12,    184,    129,      9,    vc(14),     vc(1),       0,    0,          1,    0, (void *) "Show Ruleset Dialog When Creating New Quests",                NULL,   NULL                },
    { jwin_check_proc,         12,    194,    129,      9,    vc(14),     vc(1),       0,    0,          1,    0, (void *) "Enable Tooltips",                                             NULL,   NULL                },
    
    // 20
    { d_dummy_proc,             0,      0,      0,      0,    vc(14),     vc(1),       0,    0,          0,    0,  NULL,                                                                   NULL,   NULL                },
    { d_dummy_proc,             0,      0,      0,      0,    vc(14),     vc(1),       0,    0,          0,    0,  NULL,                                                                   NULL,   NULL                },
    { d_dummy_proc,             0,      0,      0,      0,    vc(14),     vc(1),       0,    0,          0,    0,  NULL,                                                                   NULL,   NULL                },
    { d_dummy_proc,             0,      0,      0,      0,    vc(14),     vc(1),       0,    0,          0,    0,  NULL,                                                                   NULL,   NULL                },
    { d_dummy_proc,             0,      0,      0,      0,    vc(14),     vc(1),       0,    0,          0,    0,  NULL,                                                                   NULL,   NULL                },
    // 25
	{ d_dummy_proc,             0,      0,      0,      0,    vc(14),     vc(1),       0,    0,          0,    0,  NULL,                                                                   NULL,   NULL                },
    { d_dummy_proc,             0,      0,      0,      0,    vc(14),     vc(1),       0,    0,          0,    0,  NULL,                                                                   NULL,   NULL                },
    { d_dummy_proc,             0,      0,      0,      0,    vc(14),     vc(1),       0,    0,          0,    0,  NULL,                                                                   NULL,   NULL                },
    { d_dummy_proc,             0,      0,      0,      0,    vc(14),     vc(1),       0,    0,          0,    0,  NULL,                                                                   NULL,   NULL                },
    { d_dummy_proc,             0,      0,      0,      0,    vc(14),     vc(1),       0,    0,          0,    0,  NULL,                                                                   NULL,   NULL                },
    // 30
	{ d_dummy_proc,             0,      0,      0,      0,    vc(14),     vc(1),       0,    0,          0,    0,  NULL,                                                                   NULL,   NULL                },
    
    // 31
    { jwin_text_proc,          12,     48,    129,      9,    0,          0,           0,    0,          0,    0, (void *) "Auto-backup Retention:",                                      NULL,   NULL                },
    { jwin_droplist_proc,     120,     44,     73,     16,    0,          0,           0,    0,          0,    0, (void *) &autobackup_list,                                              NULL,   NULL                },
    { jwin_text_proc,          12,     66,    129,      9,    0,          0,           0,    0,          0,    0, (void *) "Auto-save Interval:",                                         NULL,   NULL                },
    { jwin_droplist_proc,     105,     62,     86,     16,    0,          0,           0,    0,          0,    0, (void *) &autosave_list,                                                NULL,   NULL                },
    // 35
	{ jwin_text_proc,          12,     84,    129,      9,    0,          0,           0,    0,          0,    0, (void *) "Auto-save Retention:",                                        NULL,   NULL                },
    { jwin_droplist_proc,     111,     80,     49,     16,    0,          0,           0,    0,          0,    0, (void *) &autosave_list2,                                               NULL,   NULL                },
    { jwin_check_proc,         12,     98,    129,      9,    vc(14),     vc(1),       0,    0,          1,    0, (void *) "Uncompressed Auto-saves",                                     NULL,   NULL                },
    { jwin_text_proc,          12,    112,    129,      9,    0,          0,           0,    0,          0,    0, (void *) "Grid Color:",                                                 NULL,   NULL                },
    { jwin_droplist_proc,      64,    108,    100,     16,    0,          0,           0,    0,          0,    0, (void *) &color_list,                                                   NULL,   NULL                },
    // 40
	{ jwin_text_proc,          12,    130,    129,      9,    0,          0,           0,    0,          0,    0, (void *) "Snapshot Format:",                                            NULL,   NULL                },
    { jwin_droplist_proc,      93,    126,     55,     16,    0,          0,           0,    0,          0,    0, (void *) &snapshotformat_list,                                          NULL,   NULL                },
    
    // 42
    { jwin_text_proc,          12,    148,    129,      9,    0,          0,           0,    0,          0,    0, (void *) "Keyboard Repeat Delay:",                                      NULL,   NULL                },
    { jwin_edit_proc,         121,    144,     36,     16,    0,          0,           0,    0,          5,    0,  NULL,                                                                   NULL,   NULL                },
    { jwin_text_proc,          12,    166,    129,      9,    0,          0,           0,    0,          0,    0, (void *) "Keyboard Repeat Rate:",                                       NULL,   NULL                },
    // 45
	{ jwin_edit_proc,         121,    162,     36,     16,    0,          0,           0,    0,          5,    0,  NULL,                                                                   NULL,   NULL                },
    { d_dummy_proc,             0,      0,      0,      0,    vc(14),     vc(1),       0,    0,          0,    0,  NULL,                                                                   NULL,   NULL                },
    { d_dummy_proc,             0,      0,      0,      0,    vc(14),     vc(1),       0,    0,          0,    0,  NULL,                                                                   NULL,   NULL                },
    { d_dummy_proc,             0,      0,      0,      0,    vc(14),     vc(1),       0,    0,          0,    0,  NULL,                                                                   NULL,   NULL                },
    { d_dummy_proc,             0,      0,      0,      0,    vc(14),     vc(1),       0,    0,          0,    0,  NULL,                                                                   NULL,   NULL                },
    // 50
    { jwin_check_proc,         12,     44,    129,      9,    vc(14),     vc(1),       0,    0,          1,    0, (void *) "Listers use Pattern-Matching Search",                          NULL,   NULL                },
    { jwin_check_proc,         12,     54,    129,      9,    vc(14),     vc(1),       0,    0,          1,    0, (void *) "No Next-Screen Preview",                                       NULL,   NULL                },
    { d_dummy_proc,             0,      0,      0,      0,    vc(14),     vc(1),       0,    0,          0,    0,  NULL,                                                                   NULL,   NULL                },
    { d_dummy_proc,             0,      0,      0,      0,    vc(14),     vc(1),       0,    0,          0,    0,  NULL,                                                                   NULL,   NULL                },
    { d_dummy_proc,             0,      0,      0,      0,    vc(14),     vc(1),       0,    0,          0,    0,  NULL,                                                                   NULL,   NULL                },
    // 55
	{ d_dummy_proc,             0,      0,      0,      0,    vc(14),     vc(1),       0,    0,          0,    0,  NULL,                                                                   NULL,   NULL                },
    { d_timer_proc,             0,      0,      0,      0,    0,          0,           0,    0,          0,    0,  NULL,                                                                   NULL,   NULL                },
    
	{ jwin_text_proc,          12,     48,    129,      9,    0,          0,           0,    0,          0,    0, (void *) "Cursor Scale (Large Mode):",                                      NULL,   NULL                },
    { jwin_edit_proc,         121,     44,     36,     16,    0,          0,           0,    0,          8,    0,  NULL,                                                                   NULL,   NULL                },
    { jwin_text_proc,          12,     66,    129,      9,    0,          0,           0,    0,          0,    0, (void *) "Cursor Scale (Small Mode):",                                       NULL,   NULL                },
    // 60
	{ jwin_edit_proc,         121,     62,     36,     16,    0,          0,           0,    0,          8,    0,  NULL,                                                                   NULL,   NULL                },
    { NULL,                     0,      0,      0,      0,    0,          0,           0,    0,          0,    0,  NULL,                                                                   NULL,   NULL                }
};

void call_options_dlg();
int32_t onOptions()
{
	call_options_dlg();
    return D_O_K;
}

enum {dm_normal, dm_relational, dm_dungeon, dm_alias, dm_cpool, dm_max};
const char *dm_names[dm_max]=
{
    "Normal",
    "Relational",
    "Dungeon",
    "Alias",
	"Pool"
};

byte relational_tile_grid[11+(rtgyo*2)][16+(rtgxo*2)];

void fix_drawing_mode_menu()
{
    for(int32_t i=0; i<dm_max; ++i)
    {
        drawing_mode_menu[i].flags=0;
    }
    
    drawing_mode_menu[draw_mode].flags=D_SELECTED;
}

int32_t onDrawingMode()
{
    draw_mode=(draw_mode+1)%dm_max;
    memset(relational_tile_grid,(draw_mode==dm_relational?1:0),(11+(rtgyo*2))*(16+(rtgxo*2)));
    fix_drawing_mode_menu();
    restore_mouse();
    return D_O_K;
}

int32_t onDrawingModeNormal()
{
    draw_mode=dm_normal;
    memset(relational_tile_grid,(draw_mode==dm_relational?1:0),(11+(rtgyo*2))*(16+(rtgxo*2)));
    fix_drawing_mode_menu();
    restore_mouse();
    return D_O_K;
}

int32_t onDrawingModeRelational()
{
    if(draw_mode==dm_relational)
    {
        return onDrawingModeNormal();
    }
    
    draw_mode=dm_relational;
    memset(relational_tile_grid,(draw_mode==dm_relational?1:0),(11+(rtgyo*2))*(16+(rtgxo*2)));
    fix_drawing_mode_menu();
    restore_mouse();
    return D_O_K;
}

int32_t onDrawingModeDungeon()
{
    if(draw_mode==dm_dungeon)
    {
        return onDrawingModeNormal();
    }
    
    draw_mode=dm_dungeon;
    memset(relational_tile_grid,(draw_mode==dm_relational?1:0),(11+(rtgyo*2))*(16+(rtgxo*2)));
    fix_drawing_mode_menu();
    restore_mouse();
    return D_O_K;
}

int32_t onDrawingModeAlias()
{
    if(draw_mode==dm_alias)
    {
        return onDrawingModeNormal();
    }
    
    draw_mode=dm_alias;
    alias_cset_mod=0;
    memset(relational_tile_grid,(draw_mode==dm_relational?1:0),(11+(rtgyo*2))*(16+(rtgxo*2)));
    fix_drawing_mode_menu();
    restore_mouse();
    return D_O_K;
}

int32_t onDrawingModePool()
{
    if(draw_mode==dm_cpool)
    {
        return onDrawingModeNormal();
    }
    
    draw_mode=dm_cpool;
    memset(relational_tile_grid,(draw_mode==dm_relational?1:0),(11+(rtgyo*2))*(16+(rtgxo*2)));
    fix_drawing_mode_menu();
    restore_mouse();
    return D_O_K;
}

int32_t onReTemplate()
{
    if(jwin_alert("Confirm Overwrite","Apply NES Dungeon template to","all screens on this map?",NULL,"&Yes","&No",'y','n',lfont)==1)
    {
        Map.TemplateAll();
        refresh(rALL);
    }
    
    return D_O_K;
}

int32_t onUndo()
{
    Map.UndoCommand();
    refresh(rALL);
    return D_O_K;
}

int32_t onRedo()
{
    Map.RedoCommand();
    refresh(rALL);
    return D_O_K;
}

int32_t onCopy()
{
    if(prv_mode)
    {
        Map.set_prvcmb(Map.get_prvcmb()==0?1:0);
        
        init_ffpos();
        
        return D_O_K;
    }
    
    Map.Copy();
    return D_O_K;
}

int32_t onH()
{
    return D_O_K;
}

int32_t onPaste()
{
	if(key[KEY_LSHIFT] || key[KEY_RSHIFT])
	{
		if(key[KEY_ZC_LCONTROL] || key[KEY_ZC_RCONTROL])
			return onPasteAllToAll();
		else return onPasteAll();
	}
	else if(key[KEY_ZC_LCONTROL] || key[KEY_ZC_RCONTROL])
		return onPasteToAll();
	else
	{
		Map.DoPasteScreenCommand(PasteCommandType::ScreenPartial);
	}
	return D_O_K;
}

int32_t onPasteAll()
{
	Map.DoPasteScreenCommand(PasteCommandType::ScreenAll);
	return D_O_K;
}

int32_t onPasteToAll()
{
	if(confirmBox("You are about to paste to all screens on the current map."))
	{
		Map.DoPasteScreenCommand(PasteCommandType::ScreenPartialToEveryScreen);
	}
	return D_O_K;
}

int32_t onPasteAllToAll()
{
	if(confirmBox("You are about to paste to all screens on the current map."))
	{
		Map.DoPasteScreenCommand(PasteCommandType::ScreenAllToEveryScreen);
	}
	return D_O_K;
}

int32_t onPasteUnderCombo()
{
    Map.DoPasteScreenCommand(PasteCommandType::ScreenUnderCombo);
    return D_O_K;
}

int32_t onPasteSecretCombos()
{
    Map.DoPasteScreenCommand(PasteCommandType::ScreenSecretCombos);
    return D_O_K;
}

int32_t onPasteFFCombos()
{
    Map.DoPasteScreenCommand(PasteCommandType::ScreenFFCombos);
    return D_O_K;
}

int32_t onPasteWarps()
{
    Map.DoPasteScreenCommand(PasteCommandType::ScreenWarps);
    return D_O_K;
}

int32_t onPasteScreenData()
{
    Map.DoPasteScreenCommand(PasteCommandType::ScreenData);
    return D_O_K;
}

int32_t onPasteWarpLocations()
{
    Map.DoPasteScreenCommand(PasteCommandType::ScreenWarpLocations);
    return D_O_K;
}

int32_t onPasteDoors()
{
    Map.DoPasteScreenCommand(PasteCommandType::ScreenDoors);
    return D_O_K;
}

int32_t onPasteLayers()
{
    Map.DoPasteScreenCommand(PasteCommandType::ScreenLayers);
    return D_O_K;
}

int32_t onPastePalette()
{
    Map.DoPasteScreenCommand(PasteCommandType::ScreenPalette);
    return D_O_K;
}

int32_t onPasteRoom()
{
    Map.DoPasteScreenCommand(PasteCommandType::ScreenRoom);
    return D_O_K;
}

int32_t onPasteGuy()
{
    Map.DoPasteScreenCommand(PasteCommandType::ScreenGuy);
    return D_O_K;
}

int32_t onPasteEnemies()
{
    Map.DoPasteScreenCommand(PasteCommandType::ScreenEnemies);
    return D_O_K;
}

int32_t onDelete()
{
    restore_mouse();
    
    if(Map.CurrScr()->valid&mVALID)
    {
        if(jwin_alert("Confirm Delete","Delete this screen?", NULL, NULL, "Yes", "Cancel", 'y', 27,lfont) == 1)
        {
            Map.DoClearScreenCommand();
        }
    }
    
    memset(relational_tile_grid,(draw_mode==dm_relational?1:0),(11+(rtgyo*2))*(16+(rtgxo*2)));
    saved=false;
    return D_O_K;
}

int32_t onDeleteMap()
{
    if(jwin_alert("Confirm Delete","Clear this entire map?", NULL, NULL, "Yes", "Cancel", 'y', 27,lfont) == 1)
    {
        Map.clearmap(false);
        refresh(rALL);
        saved=false;
    }
    
    return D_O_K;
}

int32_t onToggleDarkness()
{
    Map.CurrScr()->flags^=4;
    refresh(rMAP+rMENU);
    saved=false;
    return D_O_K;
}

int32_t onIncMap()
{
    int32_t m=Map.getCurrMap();
    int32_t oldcolor=Map.getcolor();
    Map.setCurrMap(m+1>=map_count?0:m+1);
    Map.setCurrScr(Map.getCurrScr()); //Needed to refresh the screen info. -Z ( 26th March, 2019 )
    Map.setlayertarget(); //Needed to refresh the screen info. -Z ( 26th March, 2019 )
    if(m!=Map.getCurrMap())
    {
        memset(relational_tile_grid,(draw_mode==dm_relational?1:0),(11+(rtgyo*2))*(16+(rtgxo*2)));
    }
    
    int32_t newcolor=Map.getcolor();
    
    if(newcolor!=oldcolor)
    {
        rebuild_trans_table();
    }
    
    refresh(rALL);
    return D_O_K;
}

int32_t onDecMap()
{
    int32_t m=Map.getCurrMap();
    int32_t oldcolor=Map.getcolor();
    Map.setCurrMap((m-1<0)?map_count-1:zc_min(m-1,map_count-1));
    Map.setCurrScr(Map.getCurrScr()); //Needed to refresh the screen info. -Z ( 26th March, 2019 )
    Map.setlayertarget(); //Needed to refresh the screen info. -Z ( 26th March, 2019 )
    
    if(m!=Map.getCurrMap())
    {
        memset(relational_tile_grid,(draw_mode==dm_relational?1:0),(11+(rtgyo*2))*(16+(rtgxo*2)));
    }
    
    int32_t newcolor=Map.getcolor();
    
    if(newcolor!=oldcolor)
    {
        rebuild_trans_table();
    }
    
    refresh(rALL);
    return D_O_K;
}


int32_t onDefault_Pals()
{
    if(jwin_alert("Confirm Reset","Reset all palette data?", NULL, NULL, "Yes", "Cancel", 'y', 27,lfont) == 1)
    {
        saved=false;
        
        if(!init_colordata(true, &header, &misc))
        {
            jwin_alert("Error","Palette reset failed.",NULL,NULL,"O&K",NULL,'k',0,lfont);
        }
        
        refresh_pal();
    }
    
    return D_O_K;
}

int32_t onDefault_Combos()
{
    if(jwin_alert("Confirm Reset","Reset combo data?", NULL, NULL, "Yes", "Cancel", 'y', 27,lfont) == 1)
    {
        saved=false;
        
        if(!init_combos(true, &header))
        {
            jwin_alert("Error","Combo reset failed.",NULL,NULL,"O&K",NULL,'k',0,lfont);
        }
        
        refresh(rALL);
    }
    
    return D_O_K;
}

int32_t onDefault_Items()
{
    if(jwin_alert("Confirm Reset","Reset all items?", NULL, NULL, "Yes", "Cancel", 'y', 27,lfont) == 1)
    {
        saved=false;
        reset_items(true, &header);
    }
    
    return D_O_K;
}

int32_t onDefault_Weapons()
{
    if(jwin_alert("Confirm Reset","Reset weapon/misc. sprite data?", NULL, NULL, "Yes", "Cancel", 'y', 27,lfont) == 1)
    {
        saved=false;
        reset_wpns(true, &header);
    }
    
    return D_O_K;
}

int32_t onDefault_Guys()
{
    if(jwin_alert("Confirm Reset","Reset all enemy/NPC data?", NULL, NULL, "Yes", "Cancel", 'y', 27,lfont) == 1)
    {
        saved=false;
        reset_guys();
    }
    
    return D_O_K;
}


int32_t onDefault_Tiles()
{
    if(jwin_alert("Confirm Reset","Reset all tiles?", NULL, NULL, "Yes", "Cancel", 'y', 27,lfont) == 1)
    {
        saved=false;
        
        if(!init_tiles(true, &header))
        {
            jwin_alert("Error","Tile reset failed.",NULL,NULL,"O&K",NULL,'k',0,lfont);
        }
        
        refresh(rALL);
    }
    
    return D_O_K;
}

void change_sfx(SAMPLE *sfx1, SAMPLE *sfx2);

int32_t onDefault_SFX()
{
	if(jwin_alert("Confirm Reset","Reset all sound effects?", NULL, NULL, "Yes", "Cancel", 'y', 27,lfont) == 1)
	{
		saved=false;
		SAMPLE *temp_sample;
		
		for(int32_t i=1; i<WAV_COUNT; i++)
		{
			temp_sample = (SAMPLE *)sfxdata[zc_min(i,Z35)].dat;
			change_sfx(&customsfxdata[i], temp_sample);
			sprintf(sfx_string[i],"s%03d",i);
			
			if(i<Z35)
				strcpy(sfx_string[i], old_sfx_string[i-1]);
			set_bit(customsfxflag, i<Z35?1:0, i-1);
		}
	}
	
	return D_O_K;
}


int32_t onDefault_MapStyles()
{
    if(jwin_alert("Confirm Reset","Reset all map styles?", NULL, NULL, "Yes", "Cancel", 'y', 27,lfont) == 1)
    {
        saved=false;
        reset_mapstyles(true, &misc);
    }
    
    return D_O_K;
}

int32_t on0()
{
	if(key[KEY_LSHIFT] || key[KEY_RSHIFT])
	{
		return on10();
	}
	else if(key[KEY_LCONTROL]||key[KEY_RCONTROL])
	{
		CurrentLayer = 0;
		refresh(rALL);
	}
	else if(!DisableLPalShortcuts)
	{
		saved=false;
		Map.setcolor(0);
		refresh(rSCRMAP);
	}
	return D_O_K;
}
int32_t on1()
{
	if(key[KEY_LSHIFT] || key[KEY_RSHIFT])
	{
		return on11();
	}
	else if(key[KEY_LCONTROL]||key[KEY_RCONTROL])
	{
		if(Map.CurrScr()->layermap[0])
		{
			CurrentLayer = 1;
			refresh(rALL);
		}
	}
	else if(!DisableLPalShortcuts)
	{
		saved=false;
		Map.setcolor(1);
		refresh(rSCRMAP);
	}
	return D_O_K;
}
int32_t on2()
{
	if(key[KEY_LSHIFT] || key[KEY_RSHIFT])
	{
		return on12();
	}
	else if(key[KEY_LCONTROL]||key[KEY_RCONTROL])
	{
		if(Map.CurrScr()->layermap[1])
		{
			CurrentLayer = 2;
			refresh(rALL);
		}
	}
	else if(!DisableLPalShortcuts)
	{
		saved=false;
		Map.setcolor(2);
		refresh(rSCRMAP);
	}
	return D_O_K;
}
int32_t on3()
{
	if(key[KEY_LSHIFT] || key[KEY_RSHIFT])
	{
		return on13();
	}
	else if(key[KEY_LCONTROL]||key[KEY_RCONTROL])
	{
		if(Map.CurrScr()->layermap[2])
		{
			CurrentLayer = 3;
			refresh(rALL);
		}
	}
	else if(!DisableLPalShortcuts)
	{
		saved=false;
		Map.setcolor(3);
		refresh(rSCRMAP);
    }
	return D_O_K;
}
int32_t on4()
{
	if(key[KEY_LSHIFT] || key[KEY_RSHIFT])
	{
		return on14();
	}
	else if(key[KEY_LCONTROL]||key[KEY_RCONTROL])
	{
		if(Map.CurrScr()->layermap[3])
		{
			CurrentLayer = 4;
			refresh(rALL);
		}
	}
	else if(!DisableLPalShortcuts)
	{
		saved=false;
		Map.setcolor(4);
		refresh(rSCRMAP);
	}
	return D_O_K;
}
int32_t on5()
{
	if(key[KEY_LSHIFT] || key[KEY_RSHIFT])
	{
		return on15();
	}
	else if(key[KEY_LCONTROL]||key[KEY_RCONTROL])
	{
		if(Map.CurrScr()->layermap[4])
		{
			CurrentLayer = 5;
			refresh(rALL);
		}
	}
	else if(!DisableLPalShortcuts)
	{
		saved=false;
		Map.setcolor(5);
		refresh(rSCRMAP);
    }
	return D_O_K;
}

int32_t on6()
{
	if(key[KEY_LCONTROL]||key[KEY_RCONTROL])
	// if(key_shifts & KB_CTRL_FLAG)
	{
		if(Map.CurrScr()->layermap[5])
		{
			CurrentLayer = 6;
			refresh(rALL);
		}
	}
	else if(!DisableLPalShortcuts)
	{
		saved=false;
		Map.setcolor(6);
		refresh(rSCRMAP);
	}
	return D_O_K;
}
int32_t on7()
{
	if(!DisableLPalShortcuts)
	{
		saved=false;
		Map.setcolor(7);
		refresh(rSCRMAP);
	}
	return D_O_K;
}
int32_t on8()
{
	if(!DisableLPalShortcuts)
	{
		saved=false;
		Map.setcolor(8);
		refresh(rSCRMAP);
	}
	return D_O_K;
}
int32_t on9()
{
	if(!DisableLPalShortcuts)
	{
		saved=false;
		Map.setcolor(9);
		refresh(rSCRMAP);
	}
	return D_O_K;
}

int32_t on10()
{
	if(!DisableLPalShortcuts)
	{
		saved=false;
		Map.setcolor(10);
		refresh(rSCRMAP);
	}
	return D_O_K;
}
int32_t on11()
{
	if(!DisableLPalShortcuts)
	{
		saved=false;
		Map.setcolor(11);
		refresh(rSCRMAP);
	}
	return D_O_K;
}
int32_t on12()
{
	if(!DisableLPalShortcuts)
	{
		saved=false;
		Map.setcolor(12);
		refresh(rSCRMAP);
	}
	return D_O_K;
}
int32_t on13()
{
	if(!DisableLPalShortcuts)
	{
		saved=false;
		Map.setcolor(13);
		refresh(rSCRMAP);
	}
	return D_O_K;
}
int32_t on14()
{
	if(!DisableLPalShortcuts)
	{
		saved=false;
		Map.setcolor(14);
		refresh(rSCRMAP);
	}
	return D_O_K;
}
int32_t on15()
{
	if(!DisableLPalShortcuts)
	{
		saved=false;
		Map.setcolor(15);
		refresh(rSCRMAP);
	}
	return D_O_K;
}

int32_t onLeft()
{
    int32_t tempcurrscr=Map.getCurrScr();
    
    if(!key[KEY_LSHIFT] && !key[KEY_RSHIFT])
    {
        Map.scroll(2);
        
        if(tempcurrscr!=Map.getCurrScr())
        {
            memset(relational_tile_grid,(draw_mode==dm_relational?1:0),(11+(rtgyo*2))*(16+(rtgxo*2)));
        }
        
        refresh(rALL);
    }
    else if(draw_mode==dm_cpool)
		;
    else if((First[current_combolist]>0)&&(draw_mode!=dm_alias))
    {
        First[current_combolist]-=1;
        clear_tooltip();
        refresh(rCOMBOS);
    }
    else if((combo_alistpos[current_comboalist]>0)&&(draw_mode==dm_alias))
    {
        combo_alistpos[current_comboalist]-=1;
        clear_tooltip();
        refresh(rCOMBOS);
    }
    
    clear_keybuf();
    return D_O_K;
}

int32_t onRight()
{
    int32_t tempcurrscr=Map.getCurrScr();
    
    if(!key[KEY_LSHIFT] && !key[KEY_RSHIFT])
    {
        Map.scroll(3);
        
        if(tempcurrscr!=Map.getCurrScr())
        {
            memset(relational_tile_grid,(draw_mode==dm_relational?1:0),(11+(rtgyo*2))*(16+(rtgxo*2)));
        }
        
        refresh(rALL);
    }
    else if(draw_mode==dm_cpool)
		;
    else if((First[current_combolist]<(MAXCOMBOS-(combolist[0].w*combolist[0].h)))&&(draw_mode!=dm_alias))
    {
        First[current_combolist]+=1;
        clear_tooltip();
        refresh(rCOMBOS);
    }
    else if((combo_alistpos[current_comboalist]<(MAXCOMBOALIASES-(combolist[0].w*combolist[0].h)))&&(draw_mode==dm_alias))
    {
        combo_alistpos[current_comboalist]+=1;
        clear_tooltip();
        refresh(rCOMBOS);
    }
    
    clear_keybuf();
    return D_O_K;
}

int32_t onUp()
{
    int32_t tempcurrscr=Map.getCurrScr();
    
    if(!key[KEY_LSHIFT] && !key[KEY_RSHIFT])
    {
        Map.scroll(0);
        
        if(tempcurrscr!=Map.getCurrScr())
        {
            memset(relational_tile_grid,(draw_mode==dm_relational?1:0),(11+(rtgyo*2))*(16+(rtgxo*2)));
        }
        
        refresh(rALL);
    }
    else if(draw_mode==dm_cpool)
		;
    else if((First[current_combolist]>0)&&(draw_mode!=dm_alias))
    {
        First[current_combolist]-=zc_min(First[current_combolist],combolist[0].w);
        clear_tooltip();
        
        refresh(rCOMBOS);
    }
    else if((combo_alistpos[current_comboalist]>0)&&(draw_mode==dm_alias))
    {
        combo_alistpos[current_comboalist]-=zc_min(combo_alistpos[current_comboalist],combolist[0].w);
        clear_tooltip();
        refresh(rCOMBOS);
    }
    
    clear_keybuf();
    return D_O_K;
}

int32_t onDown()
{
    int32_t tempcurrscr=Map.getCurrScr();
    
    if(!key[KEY_LSHIFT] && !key[KEY_RSHIFT])
    {
        Map.scroll(1);
        
        if(tempcurrscr!=Map.getCurrScr())
        {
            memset(relational_tile_grid,(draw_mode==dm_relational?1:0),(11+(rtgyo*2))*(16+(rtgxo*2)));
        }
        
        refresh(rALL);
    }
    else if(draw_mode==dm_cpool)
		;
    else if((First[current_combolist]<(MAXCOMBOS-(combolist[0].w*combolist[0].h)))&&(draw_mode!=dm_alias))
    {
        First[current_combolist]+=zc_min((MAXCOMBOS-combolist[0].w)-First[current_combolist],combolist[0].w);
        clear_tooltip();
        refresh(rCOMBOS);
    }
    else if((combo_alistpos[current_comboalist]<(MAXCOMBOALIASES-(comboaliaslist[0].w*comboaliaslist[0].h)))&&(draw_mode==dm_alias))
    {
        combo_alistpos[current_comboalist]+=zc_min((MAXCOMBOALIASES-combolist[0].w)-combo_alistpos[current_comboalist],combolist[0].w);
        clear_tooltip();
        refresh(rCOMBOS);
    }
    
    clear_keybuf();
    return D_O_K;
}

int32_t onPgUp()
{
    if(!key[KEY_LSHIFT] && !key[KEY_RSHIFT] &&
            !key[KEY_ZC_LCONTROL] && !key[KEY_ZC_RCONTROL] && !is_large)
    {
        menutype=wrap(menutype-1,0,m_menucount-1);
        refresh(rMENU);
    }
    else switch(draw_mode)
	{
		case dm_alias:
			if(combo_alistpos[current_comboalist]>0)
			{
				if(key[KEY_ZC_LCONTROL] || key[KEY_ZC_RCONTROL])
				{
					combo_alistpos[current_comboalist]=0;
					clear_tooltip();
				}
				else
				{
					combo_alistpos[current_comboalist]-=zc_min(combo_alistpos[current_comboalist],(comboaliaslist[0].w*comboaliaslist[0].h));
					clear_tooltip();
				}
				
				refresh(rCOMBOS);
			}
			break;
		case dm_cpool:
			if(combo_pool_listpos[current_cpoollist]>0)
			{
				if(key[KEY_ZC_LCONTROL] || key[KEY_ZC_RCONTROL])
				{
					combo_pool_listpos[current_cpoollist]=0;
					clear_tooltip();
				}
				else
				{
					combo_pool_listpos[current_cpoollist]-=zc_min(combo_pool_listpos[current_cpoollist],(comboaliaslist[0].w*comboaliaslist[0].h));
					clear_tooltip();
				}
				
				refresh(rCOMBOS);
			}
			break;
		default:
			if(First[current_combolist]>0)
			{
				if(key[KEY_ZC_LCONTROL] || key[KEY_ZC_RCONTROL])
				{
					First[current_combolist]-=zc_min(First[current_combolist],256);
					clear_tooltip();
				}
				else
				{
					First[current_combolist]-=zc_min(First[current_combolist],(combolist[0].w*combolist[0].h));
					clear_tooltip();
				}
				
				refresh(rCOMBOS);
			}
	}
    return D_O_K;
}

int32_t onPgDn()
{
    if(!key[KEY_LSHIFT] && !key[KEY_RSHIFT] &&
            !key[KEY_ZC_LCONTROL] && !key[KEY_ZC_RCONTROL] && !is_large)
    {
        menutype=wrap(menutype+1,0,m_menucount-1);
        refresh(rMENU);
    }
    else switch(draw_mode)
	{
		case dm_alias:
			if(combo_alistpos[current_comboalist]<(MAXCOMBOALIASES-(comboaliaslist[0].w*comboaliaslist[0].h)))
			{
				if(key[KEY_ZC_LCONTROL] || key[KEY_ZC_RCONTROL])
				{
					combo_alistpos[current_comboalist]=MAXCOMBOALIASES-(comboaliaslist[0].w*comboaliaslist[0].h);
					clear_tooltip();
				}
				else
				{
					combo_alistpos[current_comboalist]=zc_min((MAXCOMBOALIASES-(comboaliaslist[0].w*comboaliaslist[0].h)),combo_alistpos[current_comboalist]+(comboaliaslist[0].w*comboaliaslist[0].h));
					clear_tooltip();
				}
				
				refresh(rCOMBOS);
			}
			break;
		case dm_cpool:
			if(combo_pool_listpos[current_cpoollist]<(MAXCOMBOALIASES-(comboaliaslist[0].w*comboaliaslist[0].h)))
			{
				if(key[KEY_ZC_LCONTROL] || key[KEY_ZC_RCONTROL])
				{
					combo_pool_listpos[current_cpoollist]=MAXCOMBOALIASES-(comboaliaslist[0].w*comboaliaslist[0].h);
					clear_tooltip();
				}
				else
				{
					combo_pool_listpos[current_cpoollist]=zc_min((MAXCOMBOALIASES-(comboaliaslist[0].w*comboaliaslist[0].h)),combo_pool_listpos[current_cpoollist]+(comboaliaslist[0].w*comboaliaslist[0].h));
					clear_tooltip();
				}
				
				refresh(rCOMBOS);
			}
			break;
		default:
			if(First[current_combolist]<(MAXCOMBOS-(combolist[0].w*combolist[0].h)))
			{
				if(key[KEY_ZC_LCONTROL] || key[KEY_ZC_RCONTROL])
				{
					First[current_combolist]=zc_min((MAXCOMBOS-combolist[0].w*combolist[0].h),First[current_combolist]+256);
					clear_tooltip();
				}
				else
				{
					First[current_combolist]=zc_min((MAXCOMBOS-(combolist[0].w*combolist[0].h)),First[current_combolist]+(combolist[0].w*combolist[0].h));
					clear_tooltip();
				}
				
				refresh(rCOMBOS);
			}
			break;
	}
    
    return D_O_K;
}

int32_t onIncreaseCSet()
{
    /*if(!key[KEY_LSHIFT] && !key[KEY_RSHIFT] &&
            !key[KEY_ZC_LCONTROL] && !key[KEY_ZC_RCONTROL] &&
            !key[KEY_ALT] && !key[KEY_ALTGR])
    {*/
        if(draw_mode!=dm_alias)
        {
            CSet=wrap(CSet+1,0,11);
            refresh(rCOMBOS+rMENU+rCOMBO);
        }
        else
        {
            alias_cset_mod=wrap(alias_cset_mod+1,0,11);
        }
    /*}
    else if(key[KEY_LSHIFT] || key[KEY_RSHIFT])
    {
        int32_t drawmap, drawscr;
        
        if(CurrentLayer==0)
        {
            drawmap=Map.getCurrMap();
            drawscr=Map.getCurrScr();
        }
        else
        {
            drawmap=Map.CurrScr()->layermap[CurrentLayer-1]-1;
            drawscr=Map.CurrScr()->layerscreen[CurrentLayer-1];
            
            if(drawmap<0)
            {
                return D_O_K;
            }
        }
        
        if(!(Map.AbsoluteScr(drawmap, drawscr)->valid&mVALID))
        {
            return D_O_K;
        }
        
        saved=false;
        Map.Ugo();
        int32_t changeby=1;
        
        if(key[KEY_ZC_LCONTROL] || key[KEY_ZC_RCONTROL])
        {
            changeby*=16;
        }
        
        if(key[KEY_ALT] || key[KEY_ALTGR])
        {
            changeby*=256;
        }
        
        for(int32_t i=0; i<176; i++)
        {
            int32_t temp=Map.AbsoluteScr(drawmap, drawscr)->data[i];
            
            temp+=changeby;
            
            if(temp>=MAXCOMBOS)
            {
                temp=temp-MAXCOMBOS;
            }
            
            Map.AbsoluteScr(drawmap, drawscr)->data[i]=temp;
        }
        
        refresh(rMAP+rSCRMAP);
    }
    */
    return D_O_K;
}

int32_t onDecreaseCSet()
{
    /*if(!key[KEY_LSHIFT] && !key[KEY_RSHIFT] &&
            !key[KEY_ZC_LCONTROL] && !key[KEY_ZC_RCONTROL] &&
            !key[KEY_ALT] && !key[KEY_ALTGR])
    {*/
        if(draw_mode!=dm_alias)
        {
            CSet=wrap(CSet-1,0,11);
            refresh(rCOMBOS+rMENU+rCOMBO);
        }
        else
        {
            alias_cset_mod=wrap(alias_cset_mod-1,0,11);
        }
    /*}
    else if(key[KEY_LSHIFT] || key[KEY_RSHIFT])
    {
        int32_t drawmap, drawscr;
        
        if(CurrentLayer==0)
        {
            drawmap=Map.getCurrMap();
            drawscr=Map.getCurrScr();
        }
        else
        {
            drawmap=Map.CurrScr()->layermap[CurrentLayer-1]-1;
            drawscr=Map.CurrScr()->layerscreen[CurrentLayer-1];
            
            if(drawmap<0)
            {
                return D_O_K;
            }
        }
        
        if(!(Map.AbsoluteScr(drawmap, drawscr)->valid&mVALID))
        {
            return D_O_K;
        }
        
        saved=false;
        Map.Ugo();
        int32_t changeby=1;
        
        if(key[KEY_ZC_LCONTROL] || key[KEY_ZC_RCONTROL])
        {
            changeby*=16;
        }
        
        if(key[KEY_ALT] || key[KEY_ALTGR])
        {
            changeby*=256;
        }
        
        for(int32_t i=0; i<176; i++)
        {
            int32_t temp=Map.AbsoluteScr(drawmap, drawscr)->data[i];
            temp-=changeby;
            
            if(temp<0)
            {
                temp=MAXCOMBOS+temp;
            }
            
            Map.AbsoluteScr(drawmap, drawscr)->data[i]=temp;
        }
        
        refresh(rMAP+rSCRMAP);
    }
    */
    return D_O_K;
}

int32_t onGotoPage()
{
    int32_t choosepage=getnumber("Scroll to Combo Page", 0);
    
    if(!cancelgetnum)
    {
		if (draw_mode==dm_alias) // This will need to suffice. It jumps a full page bank, and only the last 1/4 page cannot be jumped into. 
		{
			int32_t page=(vbound(choosepage,0,((MAXCOMBOALIASES/96))));
			//First[current_comboalist]=page<<8;
			combo_alistpos[current_comboalist] = vbound(page*96, 0, MAXCOMBOALIASES-97);
		}
		else if (draw_mode==dm_cpool) // This will need to suffice. It jumps a full page bank, and only the last 1/4 page cannot be jumped into. 
		{
			int32_t page=(vbound(choosepage,0,((MAXCOMBOPOOLS/96))));
			//First[current_comboalist]=page<<8;
			combo_pool_listpos[current_cpoollist] = vbound(page*96, 0, MAXCOMBOPOOLS-97);
		}
		else
		{
			int32_t page=(zc_min(choosepage,COMBO_PAGES-1));
			First[current_combolist]=page<<8;
		}
    }
    
    return D_O_K;
}

bool getname(const char *prompt,const char *ext,EXT_LIST *list,const char *def,bool usefilename)
{
    go();
    int32_t ret=0;
    ret = getname_nogo(prompt,ext,list,def,usefilename);
    comeback();
    return ret != 0;
}


bool getname_nogo(const char *prompt,const char *ext,EXT_LIST *list,const char *def,bool usefilename)
{
    if(def!=temppath)
        strcpy(temppath,def);
        
    if(!usefilename)
    {
        int32_t i=(int32_t)strlen(temppath);
        
        while(i>=0 && temppath[i]!='\\' && temppath[i]!='/')
            temppath[i--]=0;
    }
    
    //  int32_t ret = file_select_ex(prompt,temppath,ext,255,-1,-1);
    int32_t ret=0;
    int32_t sel=0;
    
    if(list==NULL)
    {
        ret = jwin_file_select_ex(prompt,temppath,ext,2048,-1,-1,lfont);
    }
    else
    {
        ret = jwin_file_browse_ex(prompt, temppath, list, &sel, 2048, -1, -1, lfont);
    }
    
    return ret!=0;
}


static char track_number_str_buf[MIDI_TRACK_BUFFER_SIZE] = {0};
const char *tracknumlist(int32_t index, int32_t *list_size)
{
    //memset(track_number_str_buf,0,50);
    if(index>=0)
    {
        bound(index,0,255);
        std::string name = zcmusic_get_track_name(zcmusic, index);
        sprintf(track_number_str_buf,"%02d %s",index+1, name.c_str());
        return track_number_str_buf;
    }
    
    *list_size=zcmusic_get_tracks(zcmusic);
    return NULL;
}

static ListData tracknum_list(tracknumlist, &font);

static DIALOG change_track_dlg[] =
{
    // (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp)
    { jwin_win_proc,      60-12,   40,   200-16,  72,  vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "Select Track", NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { jwin_droplist_proc, 72-12,   60+4,   161,  16,   jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,       0,     0,             0, (void *) &tracknum_list, NULL, NULL },
    { jwin_button_proc,   70,   87,  61,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "OK", NULL, NULL },
    { jwin_button_proc,   150,  87,  61,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};
//  return list_dlg[2].d1;

int32_t changeTrack()
{
    restore_mouse();
    change_track_dlg[0].dp2=lfont;
    change_track_dlg[2].d1=gme_track;
    
    if(is_large) large_dialog(change_track_dlg);
    
    if(zc_popup_dialog(change_track_dlg,2)==3)
    {
        gme_track=change_track_dlg[2].d1;
        zcmusic_change_track(zcmusic, gme_track);
    }
    
    return D_O_K;
}


int32_t playMusic()
{
    char *ext;
    bool ismidi=false;
    char allmusic_types[256];
    sprintf(allmusic_types, "%s;mid", zcmusic_types);
    
    if(getname("Load Music",(char*)allmusic_types,NULL,midipath,false))
    {
        strcpy(midipath,temppath);
        
        ext=get_extension(midipath);
        
        if(
            (stricmp(ext,"ogg")==0)||
            (stricmp(ext,"mp3")==0)||
            (stricmp(ext,"it")==0)||
            (stricmp(ext,"xm")==0)||
            (stricmp(ext,"s3m")==0)||
            (stricmp(ext,"mod")==0)||
            (stricmp(ext,"spc")==0)||
            (stricmp(ext,"gym")==0)||
            (stricmp(ext,"nsf")==0)||
            (stricmp(ext,"gbs")==0)||
            (stricmp(ext,"vgm")==0)
        )
        {
            ismidi=false;
        }
        else if((stricmp(ext,"mid")==0))
        {
            ismidi=true;
        }
        else
        {
            return D_O_K;
        }
        
        zc_stop_midi();
        
        if(zcmusic != NULL)
        {
            zcmusic_stop(zcmusic);
            zcmusic_unload_file(zcmusic);
            zcmusic = NULL;
        }
        
        if(ismidi)
        {
            packfile_password("");
            if((song=load_midi(midipath))!=NULL)
            {
                if(zc_play_midi(song,true)==0)
                {
                    etc_menu[8].flags =
                        commands[cmdPlayTune].flags = 0;
                        
                    etc_menu[9].flags = D_SELECTED;
                    commands[cmdPlayMusic].flags = 0;
                    
                    etc_menu[10].flags =
                        commands[cmdChangeTrack].flags = D_DISABLED;
                }
            }
        }
        else
        {
            gme_track=0;
            zcmusic = (ZCMUSIC*)zcmusic_load_file(midipath);
            
            if(zcmusic!=NULL)
            {
                etc_menu[8].flags =
                    commands[cmdPlayTune].flags = 0;
                    
                etc_menu[9].flags=D_SELECTED;
                commands[cmdPlayMusic].flags = 0;
                
                etc_menu[10].flags =
                    commands[cmdChangeTrack].flags = (zcmusic_get_tracks(zcmusic)<2)?D_DISABLED:0;
                    
                zcmusic_play(zcmusic, midi_volume);
            }
        }
    }
    
    return D_O_K;
}

// It took awhile to get these values right, so no meddlin'!
int32_t playTune1()
{
    return playTune(0);
}
int32_t playTune2()
{
    return playTune(81);
}
int32_t playTune3()
{
    return playTune(233);
}
int32_t playTune4()
{
    return playTune(553);
}
int32_t playTune5()
{
    return playTune(814);
}
int32_t playTune6()
{
    return playTune(985);
}
int32_t playTune7()
{
    return playTune(1153);
}
int32_t playTune8()
{
    return playTune(1333);
}
int32_t playTune9()
{
    return playTune(1556);
}
int32_t playTune10()
{
    return playTune(1801);
}
int32_t playTune11()
{
    return playTune(2069);
}
int32_t playTune12()
{
    return playTune(2189);
}
int32_t playTune13()
{
    return playTune(2569);
}
int32_t playTune14()
{
    return playTune(2753);
}
int32_t playTune15()
{
    return playTune(2856);
}
int32_t playTune16()
{
    return playTune(3042);
}
int32_t playTune17()
{
    return playTune(3125);
}
int32_t playTune18()
{
    return playTune(3217);
}
int32_t playTune19()
{
    return playTune(3296);
}

int32_t playTune(int32_t pos)
{
    zc_stop_midi();
    
    if(zcmusic != NULL)
    {
        zcmusic_stop(zcmusic);
        zcmusic_unload_file(zcmusic);
        zcmusic = NULL;
    }
    
    if(zc_play_midi((MIDI*)zcdata[THETRAVELSOFLINK_MID].dat,true)==0)
    {
        zc_midi_seek(pos);
        
        etc_menu[8].flags = D_SELECTED;
        commands[cmdPlayTune].flags = 0;
        
        etc_menu[9].flags =
            commands[cmdPlayMusic].flags = 0;
            
        etc_menu[10].flags =
            commands[cmdChangeTrack].flags = D_DISABLED;
    }
    
    return D_O_K;
}

int32_t stopMusic()
{
    zc_stop_midi();
    
    if(zcmusic != NULL)
    {
        zcmusic_stop(zcmusic);
        zcmusic_unload_file(zcmusic);
        zcmusic = NULL;
    }
    
    etc_menu[8].flags =
        etc_menu[9].flags =
            commands[cmdPlayTune].flags =
                commands[cmdPlayMusic].flags = 0;
                
    etc_menu[10].flags =
        commands[cmdChangeTrack].flags = D_DISABLED;
    return D_O_K;
}

static int32_t gamemisc1_list[] =
{
	5,6,7,8,
	9,10,11,12,
	
	37,38,39,40,
	41,42,43,44,
	
	71,72,73,74,
	75,76,77,78,
	
	-1
};

static int32_t gamemisc2_list[] =
{
	13,14,15,16,
	17,18,19,20,
	
	45,46,47,48,
	49,50,51,52,
	
	79,80,81,82,
	83,84,85,86,
	
	-1
};

static int32_t gamemisc3_list[] =
{
    21,22,23,24,
	25,26,27,28,
	
	53,54,55,56,
	57,58,59,60,
	
	87,88,89,90,
	91,92,93,94,
	
	-1
};

static int32_t gamemisc4_list[] =
{
	29,30,31,32,
	33,34,35,36,
	
	61,62,63,64,
	65,66,67,68,
	
	95,96,97,98,
	99,100,101,102,
	
	-1
};

static TABPANEL gamemisc_tabs[] =
{
    // (text)
    { (char *)" Misc[0-7] ",     D_SELECTED, gamemisc1_list, 0, NULL },
    { (char *)" Misc[8-15] ",     0,          gamemisc2_list, 0, NULL },
    { (char *)" Misc[16-23] ",     0,          gamemisc3_list, 0, NULL },
    { (char *)" Misc[24-31] ",     0,          gamemisc4_list, 0, NULL },
    { NULL,              0,          NULL,            0, NULL }
};


#include "zq_files.h"
//to do: Make string boxes larger, and split into two tabs. 
static DIALOG gamemiscarray_dlg[] =
{
	// (dialog proc)     (x)   (y)   (w)   (h)   (fg)                 (bg)                  (key)    (flags)     (d1)           (d2)     (dp)
	
	{ jwin_win_proc,       0,   10,  310,  224,  vc(14),              vc(1),                  0,      D_EXIT,     0,             0,       (void *) "Game->Misc[]", NULL, NULL },
	{ d_timer_proc,        0,    0,    0,    0,  0,                   0,                      0,           0,     0,             0,       NULL, NULL, NULL },
	{ jwin_tab_proc,         3,   26,   304,  174,    vc(14),   vc(1),      0,      0,          1,             0, (void *) gamemisc_tabs,	NULL, (void *)gamemiscarray_dlg },
	{  d_dummy_proc,           240,    144,     40,      8,    vc(14),                 vc(1),                   0,    0,           0,    0,  NULL,													       NULL,   NULL                 },
	{  d_dummy_proc,           240,    144,     40,      8,    vc(14),                 vc(1),                   0,    0,           0,    0,  NULL,													       NULL,   NULL                 },
	
	//5
	{ jwin_edit_proc,      8,   42,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	{ jwin_edit_proc,      8,   42+20,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	{ jwin_edit_proc,      8,   42+40,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	//8
	{ jwin_edit_proc,      8,   42+60,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	{ jwin_edit_proc,      8,   42+80,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	{ jwin_edit_proc,      8,   42+100,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	{ jwin_edit_proc,      8,   42+120,   100-12,    16, vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	{ jwin_edit_proc,      8,   42+140,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	//13
	{ jwin_edit_proc,     8,   42,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	{ jwin_edit_proc,     8,   42+20,   100-12,    16, vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	{ jwin_edit_proc,     8,   42+40,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	{ jwin_edit_proc,     8,   42+60,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	{ jwin_edit_proc,     8,   42+80,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	//18
	{ jwin_edit_proc,     8,   42+100,   100-12,    16, vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	{ jwin_edit_proc,     8,   42+120,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	{ jwin_edit_proc,     8,   42+140,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	{ jwin_edit_proc,      8,   42,   100-12,    16, vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	{ jwin_edit_proc,      8,   42+20,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	//23
	{ jwin_edit_proc,      8,   42+40,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	{ jwin_edit_proc,      8,   42+60,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	{ jwin_edit_proc,      8,   42+80,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	{ jwin_edit_proc,      8,   42+100,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	{ jwin_edit_proc,      8,   42+120,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	//28
	{ jwin_edit_proc,      8,   42+140,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	{ jwin_edit_proc,     8,   42,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	{ jwin_edit_proc,     8,   42+20,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	{ jwin_edit_proc,     8,   42+40,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	{ jwin_edit_proc,     8,   42+60,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	//33
	{ jwin_edit_proc,     8,   42+80,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	{ jwin_edit_proc,     8,   42+100,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	{ jwin_edit_proc,     8,   42+120,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	{ jwin_edit_proc,     8,   42+140,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
	//37
	{ jwin_numedit_swap_zsint_proc,     96,  42,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	{ jwin_numedit_swap_zsint_proc,     96,  42+20,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	//39
	{ jwin_numedit_swap_zsint_proc,     96,  42+40,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	{ jwin_numedit_swap_zsint_proc,     96,  42+60,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	{ jwin_numedit_swap_zsint_proc,     96,  42+80,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	{ jwin_numedit_swap_zsint_proc,     96,  42+100,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	{ jwin_numedit_swap_zsint_proc,     96,  42+120,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	//44
	{ jwin_numedit_swap_zsint_proc,     96,  42+140,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	{ jwin_numedit_swap_zsint_proc,     96,  42,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	{ jwin_numedit_swap_zsint_proc,     96,  42+20,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	
	{ jwin_numedit_swap_zsint_proc,     96,  42+40,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	{ jwin_numedit_swap_zsint_proc,     96,  42+60,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	//49
	{ jwin_numedit_swap_zsint_proc,     96,  42+80,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	{ jwin_numedit_swap_zsint_proc,     96,  42+100,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	{ jwin_numedit_swap_zsint_proc,     96,  42+120,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	{ jwin_numedit_swap_zsint_proc,     96,  42+140,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	{ jwin_numedit_swap_zsint_proc,     96,  42,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	//54
	{ jwin_numedit_swap_zsint_proc,     96,  42+20,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	{ jwin_numedit_swap_zsint_proc,     96,  42+40,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	{ jwin_numedit_swap_zsint_proc,     96,  42+60,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	{ jwin_numedit_swap_zsint_proc,     96,  42+80,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	{ jwin_numedit_swap_zsint_proc,     96,  42+100,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	//59
	{ jwin_numedit_swap_zsint_proc,     96,  42+120,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	{ jwin_numedit_swap_zsint_proc,     96,  42+140,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	{ jwin_numedit_swap_zsint_proc,     96,  42,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	{ jwin_numedit_swap_zsint_proc,     96,  42+20,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	{ jwin_numedit_swap_zsint_proc,     96,  42+40,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	//64
	{ jwin_numedit_swap_zsint_proc,     96,  42+60,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	{ jwin_numedit_swap_zsint_proc,     96,  42+80,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	{ jwin_numedit_swap_zsint_proc,     96,  42+100,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	{ jwin_numedit_swap_zsint_proc,     96,  42+120,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	{ jwin_numedit_swap_zsint_proc,     96,  42+140,   60,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
	//69
	{ jwin_button_proc,       70,    204,     61,     21,    vc(14),                 vc(1),                  13,       D_EXIT,      0,    0, (void *) "OK",                                  NULL,   NULL                  },
	{ jwin_button_proc,      170,    204,     61,     21,    vc(14),                 vc(1),                  27,       D_EXIT,      0,    0, (void *) "Cancel",                              NULL,   NULL                  },
	
	//71
	{ jwin_swapbtn_proc,    156,    42,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,    156,    62,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,    156,    82,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,    156,   102,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,    156,   122,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,    156,   142,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,    156,   162,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,    156,   182,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	//79
	{ jwin_swapbtn_proc,    156,    42,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,    156,    62,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,    156,    82,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,    156,   102,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,    156,   122,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,    156,   142,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,    156,   162,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,    156,   182,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	//87
	{ jwin_swapbtn_proc,    156,    42,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,    156,    62,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,    156,    82,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,    156,   102,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,    156,   122,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,    156,   142,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,    156,   162,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,    156,   182,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	//95
	{ jwin_swapbtn_proc,    156,    42,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,    156,    62,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,    156,    82,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,    156,   102,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,    156,   122,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,    156,   142,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,    156,   162,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,    156,   182,    16,    16,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL },
	
	{ NULL,                0,    0,    0,    0,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL }
};

void EditGameMiscArray()
{
	gamemiscarray_dlg[0].dp2=lfont;
	char miscvalue[32][14];
	char miscvalue_labels[32][65];
	memset(miscvalue, 0, sizeof(miscvalue));
	memset(miscvalue_labels, 0, sizeof(miscvalue_labels));
	for ( int32_t q = 0; q < 32; q++ )
	{
		gamemiscarray_dlg[37+q].dp = miscvalue[q];
		gamemiscarray_dlg[37+q].fg = misc.questmisc[q];
		gamemiscarray_dlg[37+q].dp3 = &(gamemiscarray_dlg[71+q]);
		
		strcpy(miscvalue_labels[q], misc.questmisc_strings[q]);
		if ( miscvalue_labels[q][0] == 0 ) sprintf(miscvalue_labels[q],"Misc[%d]",q);
		gamemiscarray_dlg[5+q].dp = miscvalue_labels[q];
		
	}
	//also questmisc_strings
	int32_t ret;
	if(is_large)
		large_dialog(gamemiscarray_dlg);
        
	do
	{
		ret = zc_popup_dialog(gamemiscarray_dlg,65);
		for ( int32_t q = 0; q < 32; q++ )
		{
			
			misc.questmisc[q] = gamemiscarray_dlg[37+q].fg;
			strcpy(misc.questmisc_strings[q], miscvalue_labels[q]);
		}
		
	}
	while(ret==68);
}

int32_t onQMiscValues()
{
    EditGameMiscArray();
    saved=false;
    return D_O_K;
}


int32_t onTemplates()
{
    edit_qt();
    return D_O_K;
}

//  +----------+
//  |          |
//  | View Pic |
//  |          |
//  |          |
//  |          |
//  +----------+

BITMAP *pic=NULL;
BITMAP *bmap=NULL;
PALETTE picpal;
PALETTE mappal;
int32_t  picx=0,picy=0,mapx=0,mapy=0,pblack,pwhite;

double picscale=1.0,mapscale=1.0;
bool vp_showpal=true, vp_showsize=true, vp_center=true;

//INLINE int32_t pal_sum(RGB p) { return p.r + p.g + p.b; }

void get_bw(RGB *pal,int32_t &black,int32_t &white)
{
    black=white=1;
    
    for(int32_t i=1; i<256; i++)
    {
        if(pal_sum(pal[i])<pal_sum(pal[black]))
            black=i;
            
        if(pal_sum(pal[i])>pal_sum(pal[white]))
            white=i;
    }
}

void draw_bw_mouse(int32_t white, int32_t old_mouse, int32_t new_mouse)
{
    blit(mouse_bmp[old_mouse][0],mouse_bmp[new_mouse][0],0,0,0,0,16,16);
    
    for(int32_t y=0; y<16; y++)
    {
        for(int32_t x=0; x<16; x++)
        {
            if(getpixel(mouse_bmp[new_mouse][0],x,y)!=0)
            {
                putpixel(mouse_bmp[new_mouse][0],x,y,white);
            }
        }
    }
}

int32_t load_the_pic(BITMAP **dst, PALETTE dstpal)
{
    PALETTE temppal;
    
    for(int32_t i=0; i<256; i++)
    {
        temppal[i]=dstpal[i];
        dstpal[i]=RAMpal[i];
    }
    
    // set up the new palette
    for(int32_t i=0; i<64; i++)
    {
        dstpal[i].r = i;
        dstpal[i].g = i;
        dstpal[i].b = i;
    }
    
    set_palette(dstpal);
    
    BITMAP *graypic = create_bitmap_ex(8,screen->w,screen->h);
    int32_t _w = screen->w-1;
    int32_t _h = screen->h-1;
    
    // gray scale the current frame
    for(int32_t y=0; y<_h; y++)
    {
        for(int32_t x=0; x<_w; x++)
        {
            int32_t c = screen->line[y][x];
            int32_t gray = zc_min((temppal[c].r*42 + temppal[c].g*75 + temppal[c].b*14) >> 7, 63);
            graypic->line[y][x] = gray;
        }
    }
    
    blit(graypic,screen,0,0,0,0,screen->w,screen->h);
    destroy_bitmap(graypic);
#ifdef __GNUC__
	#pragma GCC diagnostic ignored "-Wformat-overflow"
#endif
    char extbuf[2][80];
    memset(extbuf[0],0,80);
    memset(extbuf[1],0,80);
    sprintf(extbuf[0], "View Image (%s", snapshotformat_str[0][1]);
    strcpy(extbuf[1], snapshotformat_str[0][1]);
    
    for(int32_t i=1; i<ssfmtMAX; ++i)
    {
        sprintf(extbuf[0], "%s, %s", extbuf[0], snapshotformat_str[i][1]);
        sprintf(extbuf[1], "%s;%s", extbuf[1], snapshotformat_str[i][1]);
    }
    
    sprintf(extbuf[0], "%s)", extbuf[0]);
#ifdef __GNUC__
	#pragma GCC diagnostic pop
#endif
    
    int32_t gotit = getname(extbuf[0],extbuf[1],NULL,imagepath,true);
    
    if(!gotit)
    {
        set_palette(temppal);
        get_palette(dstpal);
        return 1;
    }
    
    strcpy(imagepath,temppath);
    
    if(*dst)
    {
        destroy_bitmap(*dst);
    }
    
    for(int32_t i=0; i<256; i++)
    {
        dstpal[i].r = 0;
        dstpal[i].g = 0;
        dstpal[i].b = 0;
    }
    
    *dst = load_bitmap(imagepath,picpal);
    
    if(!*dst)
    {
        jwin_alert("Error","Error loading image:",imagepath,NULL,"OK",NULL,13,27,lfont);
        return 2;
    }
    
    //  get_bw(picpal,pblack,pwhite);
    //  draw_bw_mouse(pwhite);
    //  gui_bg_color = pblack;
    //  gui_fg_color = pwhite;
    
    if(vp_center)
    {
        picx=picy=0;
    }
    else
    {
        picx=(*dst)->w-zq_screen_w;
        picy=(*dst)->h-zq_screen_h;
    }
    
    return 0;
}

int32_t mapMaker(BITMAP * _map, PALETTE _mappal)
{
    char buf[200];
    int32_t num=0;
    
    do
    {
        snprintf(buf, 200, "%szquest_map%05d.%s", get_snap_str(), ++num, snapshotformat_str[SnapshotFormat][1]);
        buf[199]='\0';
    }
    while(num<99999 && exists(buf));
    
    save_bitmap(buf,_map,_mappal);
    
    return D_O_K;
}

int32_t onViewPic()
{
    return launchPicViewer(&pic,picpal,&picx,&picy,&picscale,false);
}

int32_t launchPicViewer(BITMAP **pictoview, PALETTE pal, int32_t *px2, int32_t *py2, double *scale2, bool isviewingmap)
{
    restore_mouse();
    BITMAP *buf;
    bool done=false, redraw=true;
    
    go();
    scare_mouse();
    clear_bitmap(screen);
    
    // Always call load_the_map() when viewing the map.
    if((!*pictoview || isviewingmap) && (isviewingmap ? load_the_map() : load_the_pic(pictoview,pal)))
    {
        set_palette(RAMpal);
        unscare_mouse();
        comeback();
        return D_O_K;
    }
    
    get_bw(pal,pblack,pwhite);
    
    int32_t oldfgcolor = gui_fg_color;
    int32_t oldbgcolor = gui_bg_color;
    
    buf = create_bitmap_ex(8,zq_screen_w,zq_screen_h);
    
    if(!buf)
    {
        jwin_alert("Error","Error creating temp bitmap",NULL,NULL,"OK",NULL,13,27,lfont);
        return D_O_K;
    }
    
    //  go();
    //  scare_mouse();
    //  clear_bitmap(screen);
    set_palette(pal);
    
    do
    {
        if(redraw)
        {
            clear_to_color(buf,pblack);
            stretch_blit(*pictoview,buf,0,0,(*pictoview)->w,(*pictoview)->h,
                         int32_t(zq_screen_w+(*px2-(*pictoview)->w)* *scale2)/2,int32_t(zq_screen_h+(*py2-(*pictoview)->h)* *scale2)/2,
                         int32_t((*pictoview)->w* *scale2),int32_t((*pictoview)->h* *scale2));
                         
            if(vp_showpal)
                for(int32_t i=0; i<256; i++)
                    rectfill(buf,((i&15)<<2)+zq_screen_w-64,((i>>4)<<2)+zq_screen_h-64,((i&15)<<2)+zq_screen_w-64+3,((i>>4)<<2)+zq_screen_h-64+3,i);
                    
            if(vp_showsize)
            {
                //        text_mode(pblack);
                textprintf_ex(buf,font,0,zq_screen_h-8,pwhite,pblack,"%dx%d %.2f%%",(*pictoview)->w,(*pictoview)->h,*scale2*100.0);
            }
            
            blit(buf,screen,0,0,0,0,zq_screen_w,zq_screen_h);
            redraw=false;
        }
        
        custom_vsync();
        
        int32_t step = 4;
        
        if(*scale2 < 1.0)
            step = int32_t(4.0/ *scale2);
            
        if(key[KEY_LSHIFT] || key[KEY_RSHIFT])
            step <<= 2;
            
        if(key[KEY_ZC_LCONTROL] || key[KEY_ZC_RCONTROL])
            step = 1;
            
        if(key[KEY_UP])
        {
            *py2+=step;
            redraw=true;
        }
        
        if(key[KEY_DOWN])
        {
            *py2-=step;
            redraw=true;
        }
        
        if(key[KEY_LEFT])
        {
            *px2+=step;
            redraw=true;
        }
        
        if(key[KEY_RIGHT])
        {
            *px2-=step;
            redraw=true;
        }
        
        if(keypressed() && !redraw)
            switch(readkey()>>8)
            {
            case KEY_PGUP:
                *scale2*=0.95;
                
                if(*scale2<0.1) *scale2=0.1;
                
                redraw=true;
                break;
                
            case KEY_PGDN:
                *scale2/=0.95;
                
                if(*scale2>5.0) *scale2=5.0;
                
                redraw=true;
                break;
                
            case KEY_HOME:
                *scale2/=2.0;
                
                if(*scale2<0.1) *scale2=0.1;
                
                redraw=true;
                break;
                
            case KEY_END:
                *scale2*=2.0;
                
                if(*scale2>5.0) *scale2=5.0;
                
                redraw=true;
                break;
                
            case KEY_TILDE:
                *scale2=0.5;
                redraw=true;
                break;
                
            case KEY_Z:
                *px2=(*pictoview)->w-zq_screen_w;
                *py2=(*pictoview)->h-zq_screen_h;
                vp_center=false;
                redraw=true;
                break;
                
            case KEY_1:
                *scale2=1.0;
                redraw=true;
                break;
                
            case KEY_2:
                *scale2=2.0;
                redraw=true;
                break;
                
            case KEY_3:
                *scale2=3.0;
                redraw=true;
                break;
                
            case KEY_4:
                *scale2=4.0;
                redraw=true;
                break;
                
            case KEY_5:
                *scale2=5.0;
                redraw=true;
                break;
                
            case KEY_C:
                *px2=*py2=0;
                redraw=vp_center=true;
                break;
                
            case KEY_S:
                vp_showsize = !vp_showsize;
                redraw=true;
                break;
                
            case KEY_D:
                vp_showpal = !vp_showpal;
                redraw=true;
                break;
                
            case KEY_P:
                if(isviewingmap) break;
                
            case KEY_ESC:
                done=true;
                break;
                
            case KEY_SPACE:
                if(isviewingmap ? load_the_map() : load_the_pic(pictoview,pal)==2)
                {
                    done=true;
                }
                else
                {
                    redraw=true;
                    gui_bg_color = pblack;
                    gui_fg_color = pwhite;
                    *scale2=1.0;
                    set_palette(pal);
                }
                
                get_bw(pal,pblack,pwhite);
                break;
            }
    }
    while(!done);
    
    destroy_bitmap(buf);
    set_palette(RAMpal);
    unscare_mouse();
    gui_fg_color = oldfgcolor;
    gui_bg_color = oldbgcolor;
    
    comeback();
    position_mouse_z(0);
    return D_O_K;
}

static DIALOG loadmap_dlg[] =
{
    // (dialog proc)         (x)    (y)     (w)     (h)     (fg)        (bg)    (key)     (flags)  (d1)  (d2)   (dp)                                 (dp2)   (dp3)
    {  jwin_win_proc,          0,     0,    225,    113,    vc(14),     vc(1),      0,    D_EXIT,     0,    0, (void *) "View Map",                 NULL,   NULL  },
    {  d_timer_proc,           0,     0,      0,      0,    0,          0,          0,    0,          0,    0,  NULL,                                NULL,   NULL  },
    {  jwin_text_proc,        32,    26,     96,      8,    vc(11),     vc(1),      0,    0,          0,    0, (void *) "Resolution",               NULL,   NULL  },
    // 3
    {  jwin_radio_proc,       16,    36,     97,      9,    vc(14),     vc(1),      0,    0,          0,    0, (void *) "1/4 - 1024x352",		   NULL,   NULL  },
    {  jwin_radio_proc,       16,    46,     97,      9,    vc(14),     vc(1),      0,    0,          0,    0, (void *) "1/2 - 2048x704",		   NULL,   NULL  },
    {  jwin_radio_proc,       16,    56,     97,      9,    vc(14),     vc(1),      0,    0,          0,    0, (void *) "Full - 4096x1408",		   NULL,   NULL  },
    {  jwin_text_proc,       144,    26,     97,      9,    vc(11),     vc(1),      0,    0,          0,    0, (void *) "Options",                  NULL,   NULL  },
    // 7
    {  jwin_check_proc,      144,    36,     97,      9,    vc(14),     vc(1),      0,    0,          1,    0, (void *) "Walk",                     NULL,   NULL  },
    {  jwin_check_proc,      144,    46,     97,      9,    vc(14),     vc(1),      0,    0,          1,    0, (void *) "Flags",                    NULL,   NULL  },
    {  jwin_check_proc,      144,    56,     97,      9,    vc(14),     vc(1),      0,    0,          1,    0, (void *) "Dark",                     NULL,   NULL  },
    {  jwin_check_proc,      144,    66,     97,      9,    vc(14),     vc(1),      0,    0,          1,    0, (void *) "Items",                    NULL,   NULL  },
    // 11
    {  jwin_button_proc,      42,    80,     61,     21,    vc(14),     vc(1),     13,    D_EXIT,     0,    0, (void *) "OK",                       NULL,   NULL  },
    {  jwin_button_proc,     122,    80,     61,     21,    vc(14),     vc(1),     27,    D_EXIT,     0,    0, (void *) "Cancel",                   NULL,   NULL  },
    {  jwin_check_proc,       16,    68,     97,      9,    vc(14),     vc(1),      0,    0,          1,    0, (void *) "Save to File (Mapmaker)",  NULL,   NULL  },
    {  NULL,                   0,     0,      0,      0,    0,          0,          0,    0,          0,    0,  NULL,                                NULL,   NULL  }
};

int32_t load_the_map()
{
    static int32_t res = 1;
    static int32_t flags = cDEBUG;
    
    loadmap_dlg[0].dp2    = lfont;
    loadmap_dlg[3].flags  = (res==2) ? D_SELECTED : 0;
    loadmap_dlg[4].flags  = (res==1) ? D_SELECTED : 0;
    loadmap_dlg[5].flags  = (res==0) ? D_SELECTED : 0;
    loadmap_dlg[7].flags  = (flags&cWALK)   ? D_SELECTED : 0;
    loadmap_dlg[8].flags  = (flags&cFLAGS)  ? D_SELECTED : 0;
    loadmap_dlg[9].flags  = (flags&cNODARK) ? 0 : D_SELECTED;
    loadmap_dlg[10].flags = (flags&cNOITEM) ? 0 : D_SELECTED;
    loadmap_dlg[13].flags = 0;
    
    if(is_large)
        large_dialog(loadmap_dlg);
        
    if(zc_popup_dialog(loadmap_dlg,11) != 11)
    {
        return 1;
    }
    
    flags = cDEBUG;
    
    if(loadmap_dlg[3].flags&D_SELECTED)  res=2;
    
    if(loadmap_dlg[4].flags&D_SELECTED)  res=1;
    
    if(loadmap_dlg[5].flags&D_SELECTED)  res=0;
    
    if(loadmap_dlg[7].flags&D_SELECTED)  flags|=cWALK;
    
    if(loadmap_dlg[8].flags&D_SELECTED)  flags|=cFLAGS;
    
    if(!(loadmap_dlg[9].flags&D_SELECTED))  flags|=cNODARK;
    
    if(!(loadmap_dlg[10].flags&D_SELECTED)) flags|=cNOITEM;
    
    if(bmap)
    {
        destroy_bitmap(bmap);
    }
    
    
    bmap = create_bitmap_ex(8,(256*16)>>res,(176*8)>>res);
    
    if(!bmap)
    {
        jwin_alert("Error","Error creating bitmap.",NULL,NULL,"OK",NULL,13,27,lfont);
        return 2;
    }
    
    for(int32_t y=0; y<8; y++)
    {
        for(int32_t x=0; x<16; x++)
        {
            Map.draw(screen2, 0, 0, flags, -1, y*16+x);
            stretch_blit(screen2, bmap, 0, 0, 256, 176, x<<(8-res), (y*176)>>res, 256>>res,176>>res);
        }
    }
    
    memcpy(mappal,RAMpal,sizeof(RAMpal));
    vp_showpal = false;
    get_bw(picpal,pblack,pwhite);
    mapx = mapy = 0;
    mapscale = 1;
    imagepath[0] = 0;
    
    if(loadmap_dlg[13].flags & D_SELECTED) mapMaker(bmap, mappal);
    
    return 0;
}

int32_t onViewMap()
{
    int32_t temp_aligns=ShowMisalignments;
    ShowMisalignments=0;
    //if(load_the_map()==0)
    //{
    launchPicViewer(&bmap,mappal,&mapx, &mapy, &mapscale,true);
    //}
    ShowMisalignments=temp_aligns;
    return D_O_K;
}

static const char *dirstr[4] = {"North","South","West","East"};
char _pathstr[40]="North,North,North,North";

char *pathstr(byte path[])
{
    sprintf(_pathstr,"%s,%s,%s,%s",dirstr[path[0]],dirstr[path[1]],
            dirstr[path[2]],dirstr[path[3]]);
    return _pathstr;
}

char _ticksstr[32]="99.99 seconds";

char *ticksstr(int32_t tics)
{
    int32_t mins=tics/(60*60);
    tics=tics-(mins*60*60);
    int32_t secs=tics/60;
    tics=tics-(secs*60);
    tics=tics*100/60;
    
    if(mins>0)
    {
        sprintf(_ticksstr,"%d:%02d.%02d",mins, secs, tics);
    }
    else
    {
        sprintf(_ticksstr,"%d.%02d seconds",secs, tics);
    }
    
    return _ticksstr;
}
void textprintf_disabled(BITMAP *bmp, AL_CONST FONT *f, int32_t x, int32_t y, int32_t color_hl, int32_t color_sh, AL_CONST char *format, ...)
{
    char buf[512];
    va_list ap;
    ASSERT(bmp);
    ASSERT(f);
    ASSERT(format);
    
    va_start(ap, format);
    uvszprintf(buf, sizeof(buf), format, ap);
    va_end(ap);
    
    
    textout_ex(bmp, f, buf, x+1, y+1, color_hl, -1);
    
    textout_ex(bmp, f, buf, x, y, color_sh, -1);
}

void textprintf_centre_disabled(BITMAP *bmp, AL_CONST FONT *f, int32_t x, int32_t y, int32_t color_hl, int32_t color_sh, AL_CONST char *format, ...)
{
    char buf[512];
    va_list ap;
    ASSERT(bmp);
    ASSERT(f);
    ASSERT(format);
    
    va_start(ap, format);
    uvszprintf(buf, sizeof(buf), format, ap);
    va_end(ap);
    
    textout_centre_ex(bmp, f, buf, x+1, y+1, color_hl, -1);
    textout_centre_ex(bmp, f, buf, x, y, color_sh, -1);
}

void drawpanel(int32_t pnl)
{
    mapscr *scr=Map.CurrScr();
    int32_t NextCombo=combobuf[Combo].nextcombo;
    int32_t NextCSet=(combobuf[Combo].animflags & AF_CYCLENOCSET) ? CSet : combobuf[Combo].nextcset;
    
    if(prv_mode)
    {
        jwin_draw_frame(menu1,0,panel[8].y,panel[8].x+panel[8].w, panel[8].h, FR_WIN);
        rectfill(menu1,panel[8].x,panel[8].y+2,panel[8].x+panel[8].w-3,panel[8].y+panel[8].h-3,jwin_pal[jcBOX]);
    }
    else
    {
		auto x1 = 0, y1 = panel[8].y, x2 = panel[0].x+panel[0].w-1, y2 = panel[0].y+panel[0].h-1;
		rectfill(menu1,x1,y1,x2,y2, jwin_pal[jcBOX]);
		jwin_draw_frame(menu1,x1,y1,x2-x1+1,y2-y1+1, FR_WIN);
		refresh(rSCRMAP);
		
        if(!is_large)
        {
            jwin_draw_frame(menu1,combolistscrollers[0].x,combolistscrollers[0].y,combolistscrollers[0].w,combolistscrollers[0].h,FR_ETCHED);
            
            for(int32_t i=0; i<3; i++)
            {
                _allegro_hline(menu1,combolistscrollers[0].x+5-i,combolistscrollers[0].y+4+i, combolistscrollers[0].x+5+i, vc(0));
            }
            
            jwin_draw_frame(menu1,combolistscrollers[0].x,combolistscrollers[0].y+combolistscrollers[0].h-2,combolistscrollers[0].w,combolistscrollers[0].h,FR_ETCHED);
            
            for(int32_t i=0; i<3; i++)
            {
                _allegro_hline(menu1,combolistscrollers[0].x+5-i,combolistscrollers[0].y+combolistscrollers[0].h+4-i, combolistscrollers[0].x+5+i, vc(0));
            }
			
			textprintf_disabled(menu1,spfont,x2-7,y1+3,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"%d",menutype+1);
        }
        
        
        switch(pnl)
        {
            // New Large Mode single panel
        case -1:
		{
			//Item:
			auto itemx = itemsqr_pos.x;
			auto itemy = itemsqr_pos.y;
			jwin_draw_frame(menu1,itemx,itemy,20,20,FR_DEEP);
			if(scr->hasitem && scr->item > 0)
			{
				rectfill(menu1,itemx+2,itemy+2,itemx+17,itemy+17,0);
				overtile16(menu1, itemsbuf[scr->item].tile,itemx+2,itemy+2,itemsbuf[scr->item].csets&15,0);
			}
			else blit(icon_bmp[0][coord_frame], menu1, 0, 0, itemx+2,itemy+2, 16, 16);
			
			if(panel_align == 1)
			{
				textprintf_centre_ex(menu1,font,itemx+txtoffs_double_1.x,itemy+txtoffs_double_1.y,jwin_pal[jcBOXFG],-1,"%d",scr->itemx);
				textprintf_centre_ex(menu1,font,itemx+txtoffs_double_2.x,itemy+txtoffs_double_2.y,jwin_pal[jcBOXFG],-1,"%d",scr->itemy);
			}
			else
			{
				textprintf_ex(menu1,font,itemx+txtoffs_double_1.x,itemy+txtoffs_double_1.y,jwin_pal[jcBOXFG],-1,"%d",scr->itemx);
				textprintf_ex(menu1,font,itemx+txtoffs_double_2.x,itemy+txtoffs_double_2.y,jwin_pal[jcBOXFG],-1,"%d",scr->itemy);
			}
			
			//Flag:
			auto flagx = flagsqr_pos.x;
			auto flagy = flagsqr_pos.y;
			jwin_draw_frame(menu1,flagx,flagy,20,20,FR_DEEP);
			blit(icon_bmp[3][coord_frame], menu1, 0, 0, flagx+2,flagy+2, 16, 16);
			
			if(panel_align == 1)
			{
				textprintf_centre_ex(menu1,font,flagx+txtoffs_single.x,flagy+txtoffs_single.y,jwin_pal[jcBOXFG],-1,"%d",Flag);
			}
			else
			{
				textprintf_ex(menu1,font,flagx+txtoffs_single.x,flagy+txtoffs_single.y,jwin_pal[jcBOXFG],-1,"%d",Flag);
			}
			
			
			//Stairs:
			auto stairx = stairsqr_pos.x;
			auto stairy = stairsqr_pos.y;
			jwin_draw_frame(menu1,stairx,stairy,20,20,FR_DEEP);
			blit(icon_bmp[1][coord_frame], menu1, 0, 0, stairx+2,stairy+2, 16, 16);
			
			if(panel_align == 1)
			{
				textprintf_centre_ex(menu1,font,stairx+txtoffs_double_1.x,stairy+txtoffs_double_1.y,jwin_pal[jcBOXFG],-1,"%d",scr->stairx);
				textprintf_centre_ex(menu1,font,stairx+txtoffs_double_2.x,stairy+txtoffs_double_2.y,jwin_pal[jcBOXFG],-1,"%d",scr->stairy);
			}
			else
			{
				textprintf_ex(menu1,font,stairx+txtoffs_double_1.x,stairy+txtoffs_double_1.y,jwin_pal[jcBOXFG],-1,"%d",scr->stairx);
				textprintf_ex(menu1,font,stairx+txtoffs_double_2.x,stairy+txtoffs_double_2.y,jwin_pal[jcBOXFG],-1,"%d",scr->stairy);
			}
			
			//Green arrival square:
			bool disabled_arrival = get_bit(quest_rules,qr_NOARRIVALPOINT);
			auto arrivalx = warparrival_pos.x;
			auto arrivaly = warparrival_pos.y;
			
			if(disabled_arrival)
			{
				jwin_draw_frame(menu1,arrivalx,arrivaly,20,20,FR_DEEP);
				BITMAP* tmpbmp = create_bitmap_ex(8,16,16);
				blit(icon_bmp[2][0], tmpbmp, 0, 0, 0, 0, 16, 16);
				replColor(tmpbmp, 0xE7, 0xEA, 0xEA, false);
				replColor(tmpbmp, 0xE8, 0xE2, 0xE2, false);
				blit(tmpbmp, menu1, 0, 0, arrivalx+2,arrivaly+2, 16, 16);
				
				if(panel_align == 1)
				{
					textprintf_centre_ex(menu1,font,1+arrivalx+txtoffs_double_1.x,1+arrivaly+txtoffs_double_1.y,jwin_pal[jcLIGHT],jwin_pal[jcDISABLED_BG],"%d",scr->warparrivalx);
					textprintf_centre_ex(menu1,font,arrivalx+txtoffs_double_1.x,arrivaly+txtoffs_double_1.y,jwin_pal[jcDISABLED_FG],-1,"%d",scr->warparrivalx);
					
					textprintf_centre_ex(menu1,font,1+arrivalx+txtoffs_double_2.x,1+arrivaly+txtoffs_double_2.y,jwin_pal[jcLIGHT],jwin_pal[jcDISABLED_BG],"%d",scr->warparrivaly);
					textprintf_centre_ex(menu1,font,arrivalx+txtoffs_double_2.x,arrivaly+txtoffs_double_2.y,jwin_pal[jcDISABLED_FG],-1,"%d",scr->warparrivaly);
				}
				else
				{
					textprintf_ex(menu1,font,1+arrivalx+txtoffs_double_1.x,1+arrivaly+txtoffs_double_1.y,jwin_pal[jcLIGHT],jwin_pal[jcDISABLED_BG],"%d",scr->warparrivalx);
					textprintf_ex(menu1,font,arrivalx+txtoffs_double_1.x,arrivaly+txtoffs_double_1.y,jwin_pal[jcDISABLED_FG],-1,"%d",scr->warparrivalx);
					
					textprintf_ex(menu1,font,1+arrivalx+txtoffs_double_2.x,1+arrivaly+txtoffs_double_2.y,jwin_pal[jcLIGHT],jwin_pal[jcDISABLED_BG],"%d",scr->warparrivaly);
					textprintf_ex(menu1,font,arrivalx+txtoffs_double_2.x,arrivaly+txtoffs_double_2.y,jwin_pal[jcDISABLED_FG],-1,"%d",scr->warparrivaly);
				}
			}
			else
			{
				jwin_draw_frame(menu1,arrivalx,arrivaly,20,20,FR_DEEP);
				blit(icon_bmp[2][coord_frame], menu1, 0, 0, arrivalx+2,arrivaly+2, 16, 16);
				
				if(panel_align == 1)
				{
					textprintf_centre_ex(menu1,font,arrivalx+txtoffs_double_1.x,arrivaly+txtoffs_double_1.y,jwin_pal[jcBOXFG],-1,"%d",scr->warparrivalx);
					textprintf_centre_ex(menu1,font,arrivalx+txtoffs_double_2.x,arrivaly+txtoffs_double_2.y,jwin_pal[jcBOXFG],-1,"%d",scr->warparrivaly);
				}
				else
				{
					textprintf_ex(menu1,font,arrivalx+txtoffs_double_1.x,arrivaly+txtoffs_double_1.y,jwin_pal[jcBOXFG],-1,"%d",scr->warparrivalx);
					textprintf_ex(menu1,font,arrivalx+txtoffs_double_2.x,arrivaly+txtoffs_double_2.y,jwin_pal[jcBOXFG],-1,"%d",scr->warparrivaly);
				}
			}
			//Blue return squares:
			for(int32_t i=0; i<4; i++)
			{
				jwin_draw_frame(menu1,warpret_pos[i].x,warpret_pos[i].y,20,20,FR_DEEP);
				blit(icon_bmp[ICON_BMP_RETURN_A+i][coord_frame], menu1, 0, 0, warpret_pos[i].x+2, warpret_pos[i].y+2, 16, 16);
				
				if(panel_align == 1)
				{
					textprintf_centre_ex(menu1,font,warpret_pos[i].x+txtoffs_double_1.x,warpret_pos[i].y+txtoffs_double_1.y,jwin_pal[jcBOXFG],-1,"%d",scr->warpreturnx[i]);
					textprintf_centre_ex(menu1,font,warpret_pos[i].x+txtoffs_double_2.x,warpret_pos[i].y+txtoffs_double_2.y,jwin_pal[jcBOXFG],-1,"%d",scr->warpreturny[i]);
				}
				else
				{
					textprintf_ex(menu1,font,warpret_pos[i].x+txtoffs_double_1.x,warpret_pos[i].y+txtoffs_double_1.y,jwin_pal[jcBOXFG],-1,"%d",scr->warpreturnx[i]);
					textprintf_ex(menu1,font,warpret_pos[i].x+txtoffs_double_2.x,warpret_pos[i].y+txtoffs_double_2.y,jwin_pal[jcBOXFG],-1,"%d",scr->warpreturny[i]);
				}
			}
			
			// Enemies
			int32_t epx = enemy_prev_pos.x;
			int32_t epy = enemy_prev_pos.y;
			jwin_draw_frame(menu1, epx-2,epy-2, enemy_prev_pos.w,enemy_prev_pos.h,FR_DEEP);
			rectfill(menu1, epx, epy, -1+epx+16*4,-1+epy+16*3,vc(0));
			
			for(int32_t i=0; i< 10 && Map.CurrScr()->enemy[i]!=0; i++)
			{
				int32_t id = Map.CurrScr()->enemy[i];
				int32_t tile = get_bit(quest_rules, qr_NEWENEMYTILES) ? guysbuf[id].e_tile : guysbuf[id].tile;
				int32_t cset = guysbuf[id].cset;
				
				if(tile)
					overtile16(menu1, tile+efrontfacingtile(id),epx+(i%4)*16,epy+((i/4)*16),cset,0);
			}
        }
		break;
        
        case m_block:
        {
            char name[256], shortname[256];
            strncpy(name,get_filename(filepath),255);
            
            if(name[0]==0)
            {
                sprintf(name, "[Untitled]");
            }
            
            strip_extra_spaces(name);
            shorten_string(shortname, name, pfont, 255, (panel[0].x+panel[0].w-86)-(panel[0].x+1)-4);
            set_clip_rect(menu1,panel[0].x,panel[0].y,panel[0].x+panel[0].w-5,panel[0].y+46);
            extract_name(filepath,name,FILENAME8__);
            textprintf_disabled(menu1,pfont,panel[0].x+1,panel[0].y+3,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"File:");
            textprintf_ex(menu1,pfont,panel[0].x+1,panel[0].y+13,jwin_pal[jcTEXTFG],-1,"%s",shortname);
            textprintf_disabled(menu1,pfont,panel[0].x+1,panel[0].y+24,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"Combo:");
            textprintf_ex(menu1,pfont,panel[0].x+1+text_length(pfont, "Combo: "),panel[0].y+24,jwin_pal[jcTEXTFG],-1,"%d",Combo);
            textprintf_disabled(menu1,pfont,panel[0].x+1,panel[0].y+34,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"Type:");
//        textprintf_ex(menu1,pfont,panel[0].x+1+text_length(pfont, "Type: "),panel[0].y+34,jwin_pal[jcTEXTFG],-1,"%s",combotype_string[combobuf[Combo].type]);
            textprintf_ex(menu1,pfont,panel[0].x+1+text_length(pfont, "Type: "),panel[0].y+34,jwin_pal[jcTEXTFG],-1,"%s",combo_class_buf[combobuf[Combo].type].name);
            textprintf_centre_disabled(menu1,spfont,panel[0].x+panel[0].w-76,panel[0].y+3,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"Combo");
            jwin_draw_frame(menu1,panel[0].x+panel[0].w-86,panel[0].y+9,20, 20, FR_DEEP);
            put_combo(menu1,panel[0].x+panel[0].w-84,panel[0].y+11,Combo,CSet,0,0);
            
            textprintf_centre_disabled(menu1,spfont,panel[0].x+panel[0].w-52,panel[0].y+3,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"Walk");
            jwin_draw_frame(menu1,panel[0].x+panel[0].w-62,panel[0].y+9,20, 20, FR_DEEP);
            put_combo(menu1,panel[0].x+panel[0].w-60,panel[0].y+11,Combo,CSet,0,0);
            put_walkflags(menu1,panel[0].x+panel[0].w-60,panel[0].y+11,Combo,0);
            
            textprintf_centre_disabled(menu1,spfont,panel[0].x+panel[0].w-28,panel[0].y+3,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"Cycle");
            jwin_draw_frame(menu1,panel[0].x+panel[0].w-38,panel[0].y+9,20, 20, FR_DEEP);
            
            if(NextCombo>0)
            {
                put_combo(menu1,panel[0].x+panel[0].w-36,panel[0].y+11,NextCombo,NextCSet,0,0);
            }
            else
            {
                if(InvalidStatic)
                {
                    for(int32_t dy=0; dy<16; dy++)
                    {
                        for(int32_t dx=0; dx<16; dx++)
                        {
                            menu1->line[dy+panel[0].y+11][dx+panel[0].x+panel[0].w-36]=vc((((zc_oldrand()%100)/50)?0:8)+(((zc_oldrand()%100)/50)?0:7));
                        }
                    }
                }
                else
                {
                    rectfill(menu1, panel[0].x+panel[0].w-36,panel[0].y+11, panel[0].x+panel[0].w-36+15,panel[0].y+11+15,vc(0));
                    rect(menu1, panel[0].x+panel[0].w-36,panel[0].y+11, panel[0].x+panel[0].w-36+15,panel[0].y+11+15,vc(15));
                    line(menu1, panel[0].x+panel[0].w-36,panel[0].y+11, panel[0].x+panel[0].w-36+15,panel[0].y+11+15,vc(15));
                    line(menu1, panel[0].x+panel[0].w-36,panel[0].y+11+15, panel[0].x+panel[0].w-36+15,panel[0].y+11,vc(15));
                }
            }
            
            textprintf_disabled(menu1,spfont,panel[0].x+panel[0].w-28,panel[0].y+32,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"CSet");
            textprintf_ex(menu1,spfont,panel[0].x+panel[0].w-10,panel[0].y+32,jwin_pal[jcBOXFG],-1,"%d", CSet);
            
            textprintf_disabled(menu1,spfont,panel[0].x+panel[0].w-32,panel[0].y+39,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"Layer");
            textprintf_ex(menu1,spfont,panel[0].x+panel[0].w-10,panel[0].y+39,jwin_pal[jcBOXFG],-1,"%d", CurrentLayer);
        }
        break;
        
        case m_coords:
            set_clip_rect(menu1,panel[1].x,panel[1].y,panel[1].x+panel[1].w-5,panel[1].y+46);
            
            for(int32_t i=0; i<4; i++)
            {
                jwin_draw_frame(menu1,panel[1].x+14+(32*i),panel[1].y+4,20,20,FR_DEEP);
                
                if(i==0 && scr->hasitem && scr->item > 0)
                {
                    rectfill(menu1,panel[8].x+16+(32*i),panel[1].y+6,panel[1].x+31+(32*i),panel[1].y+21,0);
                    overtile16(menu1, itemsbuf[scr->item].tile,panel[1].x+16+(32*i),panel[1].y+6,itemsbuf[scr->item].csets&15,0);
                }
                else
                    blit(icon_bmp[i][coord_frame], menu1, 0, 0, panel[1].x+16+(32*i),panel[1].y+6, 16, 16);
            }
            
            textprintf_centre_ex(menu1,font,panel[1].x+24+0*32,panel[1].y+26,jwin_pal[jcBOXFG],-1,"%d",scr->itemx);
            textprintf_centre_ex(menu1,font,panel[1].x+24+1*32,panel[1].y+26,jwin_pal[jcBOXFG],-1,"%d",scr->stairx);
            //textprintf_centre_ex(menu1,font,panel[1].x+24+2*32,panel[1].y+26,jwin_pal[jcBOXFG],-1,"%d",scr->warpreturnx);
            textprintf_centre_ex(menu1,font,panel[1].x+24+2*32,panel[1].y+26,jwin_pal[jcBOXFG],-1,"%d",scr->warparrivalx);
            textprintf_centre_ex(menu1,font,panel[1].x+24+3*32,panel[1].y+26,jwin_pal[jcBOXFG],-1,"%d",Flag);
            
            textprintf_centre_ex(menu1,font,panel[1].x+24+0*32,panel[1].y+34,jwin_pal[jcBOXFG],-1,"%d",scr->itemy);
            textprintf_centre_ex(menu1,font,panel[1].x+24+1*32,panel[1].y+34,jwin_pal[jcBOXFG],-1,"%d",scr->stairy);
            //textprintf_centre_ex(menu1,font,panel[1].x+24+2*32,panel[1].y+34,jwin_pal[jcBOXFG],-1,"%d",scr->warpreturny);
            textprintf_centre_ex(menu1,font,panel[1].x+24+2*32,panel[1].y+34,jwin_pal[jcBOXFG],-1,"%d",scr->warparrivaly);
            
            break;
            
        case m_coords2:
            set_clip_rect(menu1,panel[7].x,panel[7].y,panel[7].x+panel[7].w-5,panel[7].y+46);
            
            for(int32_t i=0; i<4; i++)
            {
                jwin_draw_frame(menu1,panel[7].x+14+(32*i),panel[7].y+4,20,20,FR_DEEP);
                blit(icon_bmp[ICON_BMP_RETURN_A+i][coord_frame], menu1, 0, 0, panel[7].x+16+(32*i),panel[7].y+6, 16, 16);
            }
            
            textprintf_centre_ex(menu1,font,panel[7].x+24+0*32,panel[7].y+26,jwin_pal[jcBOXFG],-1,"%d",scr->warpreturnx[0]);
            textprintf_centre_ex(menu1,font,panel[7].x+24+1*32,panel[7].y+26,jwin_pal[jcBOXFG],-1,"%d",scr->warpreturnx[1]);
            textprintf_centre_ex(menu1,font,panel[7].x+24+2*32,panel[7].y+26,jwin_pal[jcBOXFG],-1,"%d",scr->warpreturnx[2]);
            textprintf_centre_ex(menu1,font,panel[7].x+24+3*32,panel[7].y+26,jwin_pal[jcBOXFG],-1,"%d",scr->warpreturnx[3]);
            //textprintf_centre_ex(menu1,font,panel[7].x+24+4*32,panel[7].y+26,jwin_pal[jcBOXFG],-1,"%d",Flag);
            
            textprintf_centre_ex(menu1,font,panel[7].x+24+0*32,panel[7].y+34,jwin_pal[jcBOXFG],-1,"%d",scr->warpreturny[0]);
            textprintf_centre_ex(menu1,font,panel[7].x+24+1*32,panel[7].y+34,jwin_pal[jcBOXFG],-1,"%d",scr->warpreturny[1]);
            textprintf_centre_ex(menu1,font,panel[7].x+24+2*32,panel[7].y+34,jwin_pal[jcBOXFG],-1,"%d",scr->warpreturny[2]);
            textprintf_centre_ex(menu1,font,panel[7].x+24+3*32,panel[7].y+34,jwin_pal[jcBOXFG],-1,"%d",scr->warpreturny[3]);
            
            break;
            
        case m_flags:
        {
            set_clip_rect(menu1,panel[2].x,panel[2].y,panel[2].x+panel[2].w-5,panel[2].y+46);
            
            byte f=scr->flags;
            byte wf=scr->flags2;
            byte f3=scr->flags3;
            char *flagheader=(char *)"E_WSLE_HET_S_MLW_DIB";
            char flagdata[30];
            
            for(byte i=0; i<strlen(flagheader); ++i)
            {
                textprintf_centre_disabled(menu1,font,panel[2].x+37+(i*6),panel[2].y+6,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"%c",flagheader[i]);
            }
            
            textprintf_disabled(menu1,font,panel[2].x+5,panel[2].y+14,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"Flags:");
            
            sprintf(flagdata,"%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d",bit(f3,7),bit(f3,6),bit(f3,5),bit(f3,4),bit(f3,3),bit(f3,2),bit(f3,1),bit(f3,0),bit(wf,7),bit(wf,6),bit(wf,5),bit(wf,4),bit(f,7),bit(f,6),bit(f,5),bit(f,4),bit(f,3),bit(f,2),bit(f,1),bit(f,0));
            
            for(byte i=0; i<strlen(flagheader); ++i)
            {
                textprintf_centre_ex(menu1,font,panel[2].x+37+(i*6),panel[2].y+14,jwin_pal[jcBOXFG],-1,"%c",flagdata[i]);
            }
            
            f=scr->enemyflags;
            char *enemyflagheader=(char *)"BILFR24Z";
            char enemyflagdata[30];
            
            for(byte i=0; i<strlen(enemyflagheader); ++i)
            {
                textprintf_centre_disabled(menu1,font,panel[2].x+43+(i*6),panel[2].y+26,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"%c",enemyflagheader[i]);
            }
            
            textprintf_disabled(menu1,font,panel[2].x+5,panel[2].y+34,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"Enemy:");
            sprintf(enemyflagdata,"%d%d%d%d%d%d%d%d",bit(f,7),bit(f,6),bit(f,5),bit(f,4),bit(f,3),bit(f,2),bit(f,1),bit(f,0));
            
            for(byte i=0; i<strlen(enemyflagheader); ++i)
            {
                textprintf_centre_ex(menu1,font,panel[2].x+43+(i*6),panel[2].y+34,jwin_pal[jcBOXFG],-1,"%c",enemyflagdata[i]);
            }
            
            textprintf_disabled(menu1,font,panel[2].x+101,panel[2].y+26,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"Pattern:");
            textprintf_ex(menu1,font,panel[2].x+101,panel[2].y+34,jwin_pal[jcBOXFG],-1,"%s",short_pattern_string[(Map.CurrScr()->pattern)]);
        }
        break;
        
        case m_guy:
        {
            set_clip_rect(menu1,panel[3].x,panel[3].y,panel[3].x+panel[3].w-5,panel[3].y+46);
            char buf[145], shortbuf[145];
            strncpy(buf,MsgString(scr->str, true, false),72);
            buf[144] = '\0';
            
            if((scr->str)==0)
            {
                sprintf(buf, "(None)");
            }
            
            strip_extra_spaces(buf);
            shorten_string(shortbuf, buf, pfont, 72, 140);
            textprintf_disabled(menu1,pfont,panel[3].x+6,panel[0].y+8,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"Guy:");
            textprintf_disabled(menu1,pfont,panel[3].x+6,panel[0].y+16,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"String:");
            textprintf_disabled(menu1,pfont,panel[3].x+6,panel[0].y+24,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"Room:");
            textprintf_ex(menu1,pfont,panel[3].x+40-16,panel[3].y+8,jwin_pal[jcBOXFG],-1,"%s",moduledata.guy_type_names[scr->guy]);
            textprintf_ex(menu1,pfont,panel[3].x+40-6,panel[3].y+16,jwin_pal[jcBOXFG],-1,"%s",shortbuf);
            //textprintf_ex(menu1,pfont,panel[3].x+40-10,panel[3].y+24,jwin_pal[jcBOXFG],-1,"%s",roomtype_string[scr->room]);
            textprintf_ex(menu1,pfont,panel[3].x+40-10,panel[3].y+24,jwin_pal[jcBOXFG],-1,"%s",(char *)moduledata.roomtype_names[scr->room]);
            int32_t rtype=scr->room;
            
            if(strcmp(catchall_string[rtype]," "))
            {
                textprintf_disabled(menu1,pfont,panel[3].x+6,panel[0].y+32,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"%s:",catchall_string[rtype]);
                int32_t xofs=text_length(pfont,catchall_string[rtype])+5;
                
                switch(rtype)
                {
                case rSP_ITEM:
                    textprintf_ex(menu1,pfont,panel[3].x+7+xofs,panel[3].y+32,jwin_pal[jcBOXFG],-1,"%s",item_string[scr->catchall]);
                    break;
                    
                case rINFO:
                    textprintf_ex(menu1,pfont,panel[3].x+7+xofs,panel[3].y+32,jwin_pal[jcBOXFG],-1,"(%d) %s",scr->catchall,misc.info[scr->catchall].name);
                    break;
                    
                case rP_SHOP:
                case rSHOP:
                    textprintf_ex(menu1,pfont,panel[3].x+7+xofs,panel[3].y+32,jwin_pal[jcBOXFG],-1,"(%d) %s",scr->catchall,misc.shop[scr->catchall].name);
                    break;
                case rBOTTLESHOP:
                    textprintf_ex(menu1,pfont,panel[3].x+7+xofs,panel[3].y+32,jwin_pal[jcBOXFG],-1,"(%d) %s",scr->catchall,misc.bottle_shop_types[scr->catchall].name);
                    break;
                    
                default:
                    textprintf_ex(menu1,pfont,panel[3].x+7+xofs,panel[3].y+32,jwin_pal[jcBOXFG],-1,"%d",scr->catchall);
                    break;
                }
            }
        }
        break;
        
        case m_warp:
            set_clip_rect(menu1,panel[4].x,panel[4].y,panel[4].x+panel[4].w-5,panel[4].y+46);
            
            textprintf_disabled(menu1,font,panel[4].x+7,panel[4].y+6,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"Tile Warp:");
            textprintf_disabled(menu1,font,panel[4].x+7,panel[4].y+14,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"Type:");
            textprintf_disabled(menu1,font,panel[4].x+7,panel[4].y+26,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"Side Warp:");
            textprintf_disabled(menu1,font,panel[4].x+7,panel[4].y+34,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"Type:");
            textprintf_ex(menu1,font,panel[4].x+59,panel[4].y+6,jwin_pal[jcBOXFG],-1,"%d:%02X",Map.CurrScr()->tilewarpdmap[0],scr->tilewarpscr[0]);
            textprintf_ex(menu1,font,panel[4].x+59,panel[4].y+14,jwin_pal[jcBOXFG],-1,"%s",warptype_string[scr->tilewarptype[0]]);
            
            textprintf_ex(menu1,font,panel[4].x+59,panel[4].y+26,jwin_pal[jcBOXFG],-1,"%d:%02X",Map.CurrScr()->sidewarpdmap[0],scr->sidewarpscr[0]);
            textprintf_ex(menu1,font,panel[4].x+59,panel[4].y+34,jwin_pal[jcBOXFG],-1,"%s",warptype_string[scr->sidewarptype[0]]);
            break;
            
        case m_misc:
        {
            set_clip_rect(menu1,panel[5].x,panel[5].y,panel[5].x+panel[5].w-5,panel[5].y+46);
            
            textprintf_disabled(menu1,font,panel[5].x+7,panel[5].y+14,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"Triggers:");
            byte wf=scr->flags2;
            char *triggerheader=(char *)"TBLR";
            char triggerdata[30];
            
            for(byte i=0; i<strlen(triggerheader); ++i)
            {
                textprintf_centre_disabled(menu1,font,panel[5].x+57+(i*6),panel[5].y+6,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"%c",triggerheader[i]);
            }
            
            sprintf(triggerdata,"%d%d%d%d",bit(wf,0),bit(wf,1),bit(wf,2),bit(wf,3));
            
            for(byte i=0; i<strlen(triggerheader); ++i)
            {
                textprintf_centre_ex(menu1,font,panel[5].x+57+(i*6),panel[5].y+14,jwin_pal[jcBOXFG],-1,"%c",triggerdata[i]);
            }
            
            textprintf_disabled(menu1,font,panel[5].x+7,panel[5].y+26,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"Path:");
            textprintf_disabled(menu1,font,panel[5].x+7,panel[5].y+34,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"Exit dir:");
            textprintf_ex(menu1,font,panel[5].x+54,panel[5].y+26,jwin_pal[jcBOXFG],-1,"%s",scr->flags&64?pathstr(scr->path):"(None)");
            textprintf_ex(menu1,font,panel[5].x+54,panel[5].y+34,jwin_pal[jcBOXFG],-1,"%s",scr->flags&64?dirstr[scr->exitdir]:"(None)");
        }
        break;
        
        case m_layers:
            if(!is_large)
            {
                set_clip_rect(menu1,panel[6].x,panel[6].y,panel[6].x+panel[6].w-5,panel[6].y+46);
                
                textprintf_centre_disabled(menu1,font,panel[6].x+88,panel[6].y+2,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"Layers");
                textprintf_centre_disabled(menu1,font,panel[6].x+13,panel[6].y+11,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"0");
                draw_checkbox(menu1,panel[6].x+9-3,panel[6].y+20,layerpanel_checkbox_wid,layerpanel_checkbox_hei,vc(1),vc(14), LayerMaskInt[0]!=0);
                textprintf_centre_disabled(menu1,font,panel[6].x+38,panel[6].y+11,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"1");
                draw_checkbox(menu1,panel[6].x+34-3,panel[6].y+20,layerpanel_checkbox_wid,layerpanel_checkbox_hei,vc(1),vc(14), LayerMaskInt[1]!=0);
                textprintf_centre_disabled(menu1,font,panel[6].x+63,panel[6].y+11,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"2");
                draw_checkbox(menu1,panel[6].x+59-3,panel[6].y+20,layerpanel_checkbox_wid,layerpanel_checkbox_hei,vc(1),vc(14), LayerMaskInt[2]!=0);
                textprintf_centre_disabled(menu1,font,panel[6].x+88,panel[6].y+11,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"3");
                draw_checkbox(menu1,panel[6].x+84-3,panel[6].y+20,layerpanel_checkbox_wid,layerpanel_checkbox_hei,vc(1),vc(14), LayerMaskInt[3]!=0);
                textprintf_centre_disabled(menu1,font,panel[6].x+113,panel[6].y+11,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"4");
                draw_checkbox(menu1,panel[6].x+109-3,panel[6].y+20,layerpanel_checkbox_wid,layerpanel_checkbox_hei,vc(1),vc(14), LayerMaskInt[4]!=0);
                textprintf_centre_disabled(menu1,font,panel[6].x+138,panel[6].y+11,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"5");
                draw_checkbox(menu1,panel[6].x+134-3,panel[6].y+20,layerpanel_checkbox_wid,layerpanel_checkbox_hei,vc(1),vc(14), LayerMaskInt[5]!=0);
                textprintf_centre_disabled(menu1,font,panel[6].x+163,panel[6].y+11,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"6");
                draw_checkbox(menu1,panel[6].x+159-3,panel[6].y+20,layerpanel_checkbox_wid,layerpanel_checkbox_hei,vc(1),vc(14), LayerMaskInt[6]!=0);
                draw_layerradio(menu1,panel[6].x+9,panel[6].y+30,vc(1),vc(14), CurrentLayer);
                
                textprintf_disabled(menu1,spfont,panel[6].x+panel[6].w-28,panel[6].y+36,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"CSet");
                textprintf_ex(menu1,spfont,panel[6].x+panel[6].w-10,panel[6].y+36,jwin_pal[jcBOXFG],-1,"%d", CSet);
            }
            
            break;
        }                                                         //switch(menutype)
    }
}

void show_screen_error(const char *str, int32_t i, int32_t c)
{
    rectfill(menu1, screrrorpos.x-text_length(lfont_l,str),screrrorpos.y-(i*16),screrrorpos.x,screrrorpos.y-((i-1)*16)-4,vc(0));
    textout_shadowed_ex(menu1,lfont_l, str,screrrorpos.x-text_length(lfont_l,str),screrrorpos.y-(i*16),c,vc(0),-1);
}

void tile_warp_notification(int32_t which, char *buf)
{
    char letter = 'A'+which;
    
    switch(Map.CurrScr()->tilewarptype[which])
    {
    case wtCAVE:
        sprintf(buf,"Tile Warp %c: Cave/Item Cellar",letter);
        break;
        
    default:
    {
        char buf2[30];
        
        if(strlen(DMaps[Map.CurrScr()->tilewarpdmap[which]].name)==0)
        {
            sprintf(buf2,"%d",Map.CurrScr()->tilewarpdmap[which]);
        }
        else
            sprintf(buf2,"%d-%s",Map.CurrScr()->tilewarpdmap[which],DMaps[Map.CurrScr()->tilewarpdmap[which]].name);
            
        sprintf(buf,"Tile Warp %c: %s, %02X", letter, buf2, Map.CurrScr()->tilewarpscr[which]);
        break;
    }
    
    case wtNOWARP:
        sprintf(buf,"Tile Warp %c: Cancel Warp", letter);
        break;
    }
}

void side_warp_notification(int32_t which, int32_t dir, char *buf)
{
    char letter = 'A'+which;
    char buf3[16];
    
    if(dir==0 && Map.CurrScr()->timedwarptics)
        sprintf(buf3,"%s, Timed",dirstr[dir]);
    else if(dir==4)
        sprintf(buf3,"Timed");
    else
        strcpy(buf3, dirstr[dir]);
        
    switch(Map.CurrScr()->sidewarptype[which])
    {
    case wtCAVE:
        sprintf(buf,"Side Warp %c (%s): Cave/Item Cellar",letter, buf3);
        break;
        
    default:
    {
        // Destination DMap name
        if(strlen(DMaps[Map.CurrScr()->sidewarpdmap[which]].name)==0)
        {
            sprintf(buf,"Side Warp %c (%s): %d, %02X", letter, buf3, Map.CurrScr()->sidewarpdmap[which], Map.CurrScr()->sidewarpscr[which]);
        }
        else
            sprintf(buf,"Side Warp %c (%s): %d-%s, %02X", letter, buf3, Map.CurrScr()->sidewarpdmap[which],DMaps[Map.CurrScr()->sidewarpdmap[which]].name, Map.CurrScr()->sidewarpscr[which]);
            
        break;
    }
    
    case wtNOWARP:
        sprintf(buf,"Side Warp %c (%s): Cancel Warp", letter, buf3);
        break;
    }
}

static bool arrowcursor = true; // Used by combo aliases and Combo Brush cursors. -L

bool isFavCmdSelected(int32_t cmd)
{
	switch(cmd)
	{
		case cmdViewL2BG:
			return ViewLayer2BG;
		case cmdViewL3BG:
			return ViewLayer3BG;
		case cmdDrawingModePool:
			return draw_mode==dm_cpool;
		case cmdDrawingModeRelational:
			return draw_mode==dm_relational;
		case cmdDrawingModeDungeon:
			return draw_mode==dm_dungeon;
		case cmdDrawingModeAlias:
			return draw_mode==dm_alias;
		case cmdDrawingModeNormal:
			return draw_mode==dm_normal;
		case cmdShowDark:
			return (get_bit(quest_rules,qr_NEW_DARKROOM) && (Flags&cNEWDARK));
	}
	return false;
}

void xout(BITMAP* dest, int x, int y, int x2, int y2, int c, int bgc = -1)
{
	//BG Fill
	if(bgc > -1)
		rectfill(dest, x, y, x2, y2, bgc);
	//Border
	//safe_rect(dest, x, y, x2, y2, c);
	line(dest, x, y, x2, y, c);
	line(dest, x, y, x, y2, c);
	//X
	line(dest, x, y, x2, y2, c);
	line(dest, x, y2, x2, y, c);
}
void refresh(int32_t flags)
{
	// CPage = Map.CurrScr()->cpage;
	
	if(flags&rCLEAR)
	{
		//magic pink = 0xED
		//system black = vc(0)
		clear_to_color(menu1,jwin_pal[jcBOX]);
	}
	
	if(flags&rSCRMAP)
	{
		auto mmx = minimap.x+3;
		auto mmy = minimap.y+12;
		auto txt_x = minimap.x;
		auto txt_y = minimap.y;
		
		if(is_large) //Adjust the old style positioning
		{
			mmy -= 7;
			txt_x += (8*3*BMM)+3+5;
			txt_y += (8*3*BMM)+8;
		}
		rectfill(menu1, minimap.x-1, minimap.y-2,minimap.x+minimap.w-1,minimap.y+minimap.h+(is_large?4:-1),jwin_pal[jcBOX]);
		jwin_draw_minimap_frame(menu1,mmx-3,mmy-3,minimap.w-1, minimap.h-10, (is_large?9:3), FR_DEEP);
		
		if(Map.getCurrMap()<Map.getMapCount())
		{
			for(int32_t i=0; i<MAPSCRS; i++)
			{
				if(Map.Scr(i)->valid&mVALID)
				{
					if(((Map.Scr(i)->color)&15)>0)
					{
						rectfill(menu1,(i&15)*3*BMM+mmx,(i/16)*3*BMM+mmy,
								 (i&15)*3*BMM+(is_large?8:2)+mmx,(i/16)*3*BMM+mmy+(is_large?8:2), lc1((Map.Scr(i)->color)&15));
						if(!is_large)
							putpixel(menu1,(i&15)*3*BMM+1+mmx,(i/16)*3*BMM+mmy+1,lc2((Map.Scr(i)->color)&15));
						else
							rectfill(menu1,(i&15)*3*BMM+3+mmx,(i/16)*3*BMM+mmy+3,(i&15)*3*BMM+5+mmx,(i/16)*3* BMM+mmy+5, lc2((Map.Scr(i)->color)&15));
					}
					else
					{
						rectfill(menu1,(i&15)*3*BMM+mmx,(i/16)*3*BMM+mmy,
										 (i&15)*3*BMM+(is_large?8:2)+mmx,(i/16)*3*BMM+mmy+(is_large?8:2), lc1((Map.Scr(i)->color)&15));
					}
					if(!(is_large || InvalidStatic))
					{
						/*Level palettes which display close to black get a white border*/
						RGB* col = &RAMpal[lc1(Map.Scr(i)->color&15)];
						RGB* col2 = &RAMpal[lc2(Map.Scr(i)->color&15)];
						if(col->r <= 10 && col->b <= 10 && col->g <= 10 && (!(((Map.Scr(i)->color)&15)>0) || (col2->r <= 10 && col2->b <= 10 && col2->g <= 10)))
							safe_rect(menu1,(i&15)*3*BMM+mmx,(i/16)*3*BMM+mmy,(i&15)*3*BMM+(is_large?8:2)+mmx,(i/16)*3*BMM+mmy+(is_large?8:2),vc(15));
					}
				}
				else
				{
					if(InvalidStatic)
					{
						for(int32_t dy=0; dy<3*BMM; dy++)
						{
							for(int32_t dx=0; dx<3*BMM; dx++)
							{
								menu1->line[dy+(i/16)*3*BMM+mmy][dx+(i&15)*3*BMM+mmx]=vc((((zc_oldrand()%100)/50)?0:8)+(((zc_oldrand()%100)/50)?0:7));
							}
						}
					}
					else
					{
						if(is_large)
						{
							int32_t offs = 2;
							draw_x(menu1, (i&15)*3*BMM+mmx+offs, (i/16)*3*BMM+mmy+offs, (i&15)*3*BMM+mmx-1+(BMM*BMM)-offs, (i/16)*3*BMM+mmy-1+(BMM*BMM)-offs, vc(15));
						}
						else
						{
							rectfill(menu1, (i&15)*3*BMM+mmx, (i/16)*3*BMM+mmy,
									 (i&15)*3*BMM+mmx-1+(BMM*BMM), (i/16)*3*BMM+mmy-1+(BMM*BMM), vc(0));
						}
					}
				}
			}
			
			int32_t s=Map.getCurrScr();
			// The white marker rect
			int32_t cursor_color = 0;
			switch(MMapCursorStyle)
			{
				case 0:
					cursor_color = vc(15);
					break;
				case 1:
					cursor_color = (framecnt%(BlinkSpeed*2))>=BlinkSpeed ? vc(0) : vc(15);
					break;
				case 2:
					cursor_color = (framecnt%(BlinkSpeed*2))>=BlinkSpeed ? vc(12) : vc(9);
					break;
			}
			if(cursor_color)
				safe_rect(menu1,(s&15)*3*BMM+mmx,(s/16)*3*BMM+mmy,(s&15)*3*BMM+(is_large?8:2)+mmx,(s/16)*3*BMM+mmy+(is_large?8:2),cursor_color);
			
			FONT* oldfont = font;
			font = nfont;
			if(is_large)
			{
				int32_t space = text_length(font, "255")+2, spc_s = text_length(font, "S")+2, spc_m = text_length(font, "M")+2;
				textprintf_disabled(menu1,font,txt_x,txt_y,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"M");
				//textprintf_ex(menu1,font,txt_x,txt_y,jwin_pal[jcBOXFG],jwin_pal[jcBOX],"M");
				textprintf_ex(menu1,font,txt_x+spc_m,txt_y,jwin_pal[jcBOXFG],jwin_pal[jcBOX],"%-3d",Map.getCurrMap()+1);
				
				textprintf_disabled(menu1,font,txt_x+spc_m+space,txt_y,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"S");
				//textprintf_ex(menu1,font,txt_x+spc_m+space,txt_y,jwin_pal[jcBOXFG],jwin_pal[jcBOX],"S");
				bool vertical = !is_compact;
				if(vertical)
				{
					textprintf_ex(menu1,font,txt_x+spc_m+space+spc_s,txt_y,jwin_pal[jcBOXFG],jwin_pal[jcBOX],"0x%02X", s);
					textprintf_ex(menu1,font,txt_x+spc_m+space+spc_s,txt_y+text_height(font)+2,jwin_pal[jcBOXFG],jwin_pal[jcBOX],"(%d)", s);
				}
				else textprintf_ex(menu1,font,txt_x+spc_m+space+spc_s,txt_y,jwin_pal[jcBOXFG],jwin_pal[jcBOX],"0x%02X (%d)",s, s);
			}
			else
			{
				textprintf_disabled(menu1,font,txt_x,txt_y,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"M");
				textprintf_ex(menu1,font,txt_x+8,txt_y,jwin_pal[jcBOXFG],jwin_pal[jcBOX],"%-3d",Map.getCurrMap()+1);
				
				textprintf_disabled(menu1,font,txt_x+36,txt_y,jwin_pal[jcLIGHT],jwin_pal[jcMEDDARK],"S");
				textprintf_ex(menu1,font,txt_x+36+8,txt_y,jwin_pal[jcBOXFG],jwin_pal[jcBOX],"%02X",s);
			}
			font = oldfont;
		}
	}
	
	if(flags&rMAP)
	{
		if(!layers_valid(Map.CurrScr()))
			fix_layers(Map.CurrScr(), true);
			
		clear_to_color(mapscreenbmp,vc(0));
		Map.draw(mapscreenbmp, showedges?16:0, showedges?16:0, Flags, -1, -1);
		if(showedges)
		{
			if(Map.getCurrScr()<128)
			{
				//not the first row of screens
				if(Map.getCurrScr()>15 && !NoScreenPreview)
				{
					Map.drawrow(mapscreenbmp, 16, 0, Flags, 160, -1, Map.getCurrScr()-16);
				}
				else
				{
					Map.drawstaticrow(mapscreenbmp, 16, 0);
				}
				
				//not the last row of screens
				if(Map.getCurrScr()<112 && !NoScreenPreview)
				{
					Map.drawrow(mapscreenbmp, 16, 192, Flags, 0, -1, Map.getCurrScr()+16);
				}
				else
				{
					Map.drawstaticrow(mapscreenbmp, 16, 192);
				}
				
				//not the first column of screens
				if(Map.getCurrScr()&0x0F && !NoScreenPreview)
				{
					Map.drawcolumn(mapscreenbmp, 0, 16, Flags, 15, -1, Map.getCurrScr()-1);
				}
				else
				{
					Map.drawstaticcolumn(mapscreenbmp, 0, 16);
				}
				
				//not the last column of screens
				if((Map.getCurrScr()&0x0F)<15 && !NoScreenPreview)
				{
					Map.drawcolumn(mapscreenbmp, 272, 16, Flags, 0, -1, Map.getCurrScr()+1);
				}
				else
				{
					Map.drawstaticcolumn(mapscreenbmp, 272, 16);
				}
				
				//not the first row or first column of screens
				if((Map.getCurrScr()>15)&&(Map.getCurrScr()&0x0F) && !NoScreenPreview)
				{
					Map.drawblock(mapscreenbmp, 0, 0, Flags, 175, -1, Map.getCurrScr()-17);
				}
				else
				{
					Map.drawstaticblock(mapscreenbmp, 0, 0);
				}
				
				//not the first row or last column of screens
				if((Map.getCurrScr()>15)&&((Map.getCurrScr()&0x0F)<15) && !NoScreenPreview)
				{
					Map.drawblock(mapscreenbmp, 272, 0, Flags, 160, -1, Map.getCurrScr()-15);
				}
				else
				{
					Map.drawstaticblock(mapscreenbmp, 272, 0);
				}
				
				//not the last row or first column of screens
				if((Map.getCurrScr()<112)&&(Map.getCurrScr()&0x0F) && !NoScreenPreview)
				{
					Map.drawblock(mapscreenbmp, 0, 192, Flags, 15, -1, Map.getCurrScr()+15);
				}
				else
				{
					Map.drawstaticblock(mapscreenbmp, 0, 192);
				}
				
				//not the last row or last column of screens
				if((Map.getCurrScr()<112)&&((Map.getCurrScr()&0x0F)<15) && !NoScreenPreview)
				{
					Map.drawblock(mapscreenbmp, 272, 192, Flags, 0, -1, Map.getCurrScr()+17);
				}
				else
				{
					Map.drawstaticblock(mapscreenbmp, 272, 192);
				}
			}
		}
		
		if(showxypos_icon)
		{
			if(showxypos_color==vc(15))
				safe_rect(mapscreenbmp,showxypos_x+(showedges?16:0),showxypos_y+(showedges?16:0),showxypos_x+(showedges?16:0)+showxypos_w-1,showxypos_y+(showedges?16:0)+showxypos_h-1,showxypos_color);
			else
				rectfill(mapscreenbmp,showxypos_x+(showedges?16:0),showxypos_y+(showedges?16:0),showxypos_x+(showedges?16:0)+showxypos_w-1,showxypos_y+(showedges?16:0)+showxypos_h-1,showxypos_color);
		}
		
		if(showxypos_cursor_icon)
		{
			safe_rect(mapscreenbmp,showxypos_cursor_x+(showedges?16:0),showxypos_cursor_y+(showedges?16:0),showxypos_cursor_x+(showedges?16:0)+showxypos_w-1,showxypos_cursor_y+(showedges?16:0)+showxypos_h-1,showxypos_cursor_color);
		}
		
		if(ShowSquares)
		{
			if(Map.CurrScr()->stairx || Map.CurrScr()->stairy)
			{
				int32_t x1 = Map.CurrScr()->stairx+(showedges?16:0);
				int32_t y1 = Map.CurrScr()->stairy+(showedges?16:0);
				safe_rect(mapscreenbmp,x1,y1,x1+15,y1+15,vc(14));
			}
			
			if(Map.CurrScr()->warparrivalx || Map.CurrScr()->warparrivaly)
			{
				int32_t x1 = Map.CurrScr()->warparrivalx +(showedges?16:0);
				int32_t y1 = Map.CurrScr()->warparrivaly +(showedges?16:0);
				safe_rect(mapscreenbmp,x1,y1,x1+15,y1+15,vc(10));
			}
			
			for(int32_t i=0; i<4; i++) if(Map.CurrScr()->warpreturnx[i] || Map.CurrScr()->warpreturny[i])
				{
					int32_t x1 = Map.CurrScr()->warpreturnx[i]+(showedges?16:0);
					int32_t y1 = Map.CurrScr()->warpreturny[i]+(showedges?16:0);
					int32_t clr = vc(9);
					
					if(FlashWarpSquare==i)
					{
						if(!FlashWarpClk)
							FlashWarpSquare=-1;
						else if(!(--FlashWarpClk%3))
							clr = vc(15);
					}
					
					safe_rect(mapscreenbmp,x1,y1,x1+15,y1+15,clr);
				}
				
			/*
				  for (int32_t i=0; i<4; i++) for (int32_t j=0; j<9; i++)
				  {
					int32_t x1 = stx[i][j]+(showedges?16:0);
					int32_t y1 = sty[i][j]+(showedges?16:0);
					rect(mapscreenbmp,x1,y1,x1+15,y1+15,vc(15));
				  }
			*/
			
		}
		
		if(ShowFFCs)
		{
			for(int32_t i=MAXFFCS-1; i>=0; i--)
			{
				ffcdata& ff = Map.CurrScr()->ffcs[i];
				if(ff.getData() !=0 && (CurrentLayer<2 || (ff.flags&ffOVERLAY)))
				{
					auto x = ff.x+(showedges?16:0);
					auto y = ff.y+(showedges?16:0);
					safe_rect(mapscreenbmp, x+0, y+0, x+ff.txsz*16-1, y+ff.tysz*16-1, vc(12));
				}
			}
		}
		
		if(!(Flags&cDEBUG) && pixeldb==1)
		{
			for(int32_t j=168; j<176; j++)
			{
				for(int32_t i=0; i<256; i++)
				{
					if(((i^j)&1)==0)
					{
						putpixel(mapscreenbmp,(showedges?16:0)+i,
							(showedges?16:0)+j,vc(blackout_color));
					}
				}
			}
		}
		
		if(mapscreensize==1)
		{
			blit(mapscreenbmp,menu1,0,0,mapscreen_x,mapscreen_y,mapscreenbmp->w,mapscreenbmp->h);
		}
		else
		{
			stretch_blit(mapscreenbmp,menu1,0,0,mapscreenbmp->w,mapscreenbmp->h,mapscreen_x,mapscreen_y,int32_t(mapscreensize*mapscreenbmp->w),int32_t(mapscreensize*mapscreenbmp->h));
		}
		
		if(showedges)
		{
			//top preview
			for(int32_t j=0; j<int32_t(16*mapscreensize); j++)
			{
				for(int32_t i=0; i<288*mapscreensize; i++)
				{
					if(((i^j)&1)==0)
					{
						putpixel(menu1,mapscreen_x+i,mapscreen_y+j,vc(0));
					}
				}
			}
			
			//bottom preview
			for(int32_t j=int32_t(192*mapscreensize); j<int32_t(208*mapscreensize); j++)
			{
				for(int32_t i=0; i<288*mapscreensize; i++)
				{
					if(((i^j)&1)==0)
					{
						putpixel(menu1,mapscreen_x+i,mapscreen_y+j,vc(0));
					}
				}
			}
			
			//left preview
			for(int32_t j=int32_t(16*mapscreensize); j<int32_t(192*mapscreensize); j++)
			{
				for(int32_t i=0; i<16*mapscreensize; i++)
				{
					if(((i^j)&1)==0)
					{
						putpixel(menu1,mapscreen_x+i,mapscreen_y+j,vc(0));
					}
				}
				
			}
			
			//right preview
			for(int32_t j=int32_t(16*mapscreensize); j<int32_t(192*mapscreensize); j++)
			{
				for(int32_t i=int32_t(272*mapscreensize); i<int32_t(288*mapscreensize); i++)
				{
					if(((i^j)&1)==0)
					{
						putpixel(menu1,mapscreen_x+i,mapscreen_y+j,vc(0));
					}
				}
			}
		}
		
		if(!(Flags&cDEBUG) && pixeldb==2)
		{
			for(int32_t j=int32_t(168*mapscreensize); j<int32_t(176*mapscreensize); j++)
			{
				for(int32_t i=0; i<int32_t(256*mapscreensize); i++)
				{
				
					if(((i^j)&1)==0)
					{
						putpixel(menu1,int32_t(mapscreen_x+(showedges?(16*mapscreensize):0)+i),
								 int32_t(mapscreen_y+(showedges?(16*mapscreensize):0)+j),vc(blackout_color));
					}
				}
			}
		}
		
		if(Map.isDark())
		{
			if((Flags&cNEWDARK) && get_bit(quest_rules, qr_NEW_DARKROOM))
			{
				BITMAP* tmpDark = create_bitmap_ex(8,16*16,16*11);
				BITMAP* tmpDarkTrans = create_bitmap_ex(8,16*16,16*11);
				BITMAP* tmpbuf = create_bitmap_ex(8,
					mapscreensize*(256+(showedges?32:0)),
					mapscreensize*(176+(showedges?32:0)));
				BITMAP* tmpbuf2 = create_bitmap_ex(8,
					mapscreensize*(256+(showedges?32:0)),
					mapscreensize*(176+(showedges?32:0)));
				int32_t darkCol = zinit.darkcol;
				switch(darkCol) //special cases
				{
					case BLACK:
						darkCol = vc(0);
						break;
					case WHITE:
						darkCol = vc(15);
						break;
				}
				clear_to_color(tmpDark, darkCol);
				clear_to_color(tmpDarkTrans, darkCol);
				clear_bitmap(tmpbuf);
				clear_bitmap(tmpbuf2);
				//Handle torch combos
				color_map = &trans_table2;
				Map.draw_darkness(tmpDark, tmpDarkTrans);
				//
				mapscr* tmp = Map.CurrScr();
				if(tmp->flags9 & fDARK_DITHER)
				{
					ditherblit(tmpDark, tmpDark, 0, zinit.dither_type, zinit.dither_arg);
					ditherblit(tmpDarkTrans, tmpDarkTrans, 0, zinit.dither_type, zinit.dither_arg);
				}
				
				if(mapscreensize == 1)
				{
					blit(tmpDark, tmpbuf, 0, 0, (showedges?16:0), (showedges?16:0), 16*16, 16*11);
					blit(tmpDarkTrans, tmpbuf2, 0, 0, (showedges?16:0), (showedges?16:0), 16*16, 16*11);
				}
				else
				{
					stretch_blit(tmpDark, tmpbuf, 0, 0, 16*16, 16*11,
						(showedges?16:0)*mapscreensize, (showedges?16:0)*mapscreensize,
						(16*16)*mapscreensize, (16*11)*mapscreensize);
					stretch_blit(tmpDarkTrans, tmpbuf2, 0, 0, 16*16, 16*11,
						(showedges?16:0)*mapscreensize, (showedges?16:0)*mapscreensize,
						(16*16)*mapscreensize, (16*11)*mapscreensize);
				}
				
				if(tmp->flags9 & fDARK_TRANS)
				{
					draw_trans_sprite(menu1, tmpbuf, mapscreen_x, mapscreen_y);
				}
				else
				{
					masked_blit(tmpbuf,menu1,0,0,mapscreen_x,mapscreen_y,tmpbuf->w,tmpbuf->h);
				}
				draw_trans_sprite(menu1, tmpbuf2, mapscreen_x, mapscreen_y);
				color_map = &trans_table;
				//
				destroy_bitmap(tmpDark);
				destroy_bitmap(tmpDarkTrans);
				destroy_bitmap(tmpbuf);
				destroy_bitmap(tmpbuf2);
			}
			else if(!(Flags&cNODARK))
			{
				for(int32_t j=0; j<80*mapscreensize; j++)
				{
					for(int32_t i=0; i<(80*mapscreensize)-j; i++)
					{
						if(((i^j)&1)==0)
						{
							putpixel(menu1,int32_t(mapscreen_x+(showedges?(16*mapscreensize):0))+i,
									 int32_t(mapscreen_y+(showedges?(16*mapscreensize):0)+j),vc(blackout_color));
						}
					}
				}
			}
		}
		
		double startx=mapscreen_x+(showedges?(16*mapscreensize):0);
		double starty=mapscreen_y+(showedges?(16*mapscreensize):0);
		int32_t startxint=mapscreen_x+(showedges?int32_t(16*mapscreensize):0);
		int32_t startyint=mapscreen_y+(showedges?int32_t(16*mapscreensize):0);
		bool inrect = isinRect(gui_mouse_x(),gui_mouse_y(),startxint,startyint,int32_t(startx+(256*mapscreensize)-1),int32_t(starty+(176*mapscreensize)-1));
		
		if(!(flags&rNOCURSOR) && ((ComboBrush && !ComboBrushPause)||draw_mode==dm_alias) && inrect && draw_mode != dm_cpool)
		{
			arrowcursor = false;
			int32_t mgridscale=16*mapscreensize;
			set_mouse_sprite(mouse_bmp[MOUSE_BMP_BLANK][0]);
			int32_t mx=(gui_mouse_x()-(showedges?mgridscale:0))/mgridscale*mgridscale;
			int32_t my=(gui_mouse_y()-16-(showedges?mgridscale:0))/mgridscale*mgridscale;
			clear_bitmap(brushscreen);
			int32_t tempbw=BrushWidth;
			int32_t tempbh=BrushHeight;
			
			if(draw_mode==dm_alias)
			{
				BrushWidth = combo_aliases[combo_apos].width+1;
				BrushHeight = combo_aliases[combo_apos].height+1;
			}
			
			if((FloatBrush)&&(draw_mode!=dm_alias))
			{
				if(is_large)
				{
					stretch_blit(brushbmp, brushscreen, 0, 0, BrushWidth*16, BrushHeight*16, mx+(showedges?mgridscale:0)-(SHADOW_DEPTH*mapscreensize), my+(showedges?mgridscale:0)-(SHADOW_DEPTH*mapscreensize), BrushWidth*mgridscale, BrushHeight*mgridscale);
				}
				else
				{
					blit(brushbmp, brushscreen, 0, 0, mx+(showedges?mgridscale:0)-SHADOW_DEPTH, my+(showedges?mgridscale:0)-SHADOW_DEPTH, BrushWidth*mgridscale, BrushHeight*mgridscale);
				}
				
				//shadow
				for(int32_t i=0; i<SHADOW_DEPTH*mapscreensize; i++)
				{
					for(int32_t j=0; j<BrushHeight*mgridscale; j++)
					{
						if((((i^j)&1)==1) && (my+j)<12*mgridscale)
						{
							putpixel(brushscreen,mx+(showedges?mgridscale:0)+i+(BrushWidth*mgridscale)-(SHADOW_DEPTH*mapscreensize),my+(showedges?mgridscale:0)+j,vc(0));
						}
					}
				}
				
				for(int32_t i=0; i<BrushWidth*mgridscale; i++)
				{
					for(int32_t j=0; j<SHADOW_DEPTH*mapscreensize; j++)
					{
						if((((i^j)&1)==1) && (mx+i)<16*mgridscale)
						{
							putpixel(brushscreen,mx+(showedges?mgridscale:0)+i,my+(showedges?mgridscale:0)+j+(BrushHeight*mgridscale)-(SHADOW_DEPTH*mapscreensize),vc(0));
						}
					}
				}
			}
			else
			{
				if(draw_mode!=dm_alias)
				{
					if(is_large)
					{
						stretch_blit(brushbmp, brushscreen, 0, 0, BrushWidth*16, BrushHeight*16, mx+(showedges?mgridscale:0), my+(showedges?mgridscale:0), BrushWidth*mgridscale, BrushHeight*mgridscale);
					}
					else
					{
						blit(brushbmp, brushscreen, 0, 0, mx+(showedges?mgridscale:0), my+(showedges?mgridscale:0), BrushWidth*mgridscale, BrushHeight*mgridscale);
					}
				}
				else
				{
					combo_alias *combo = &combo_aliases[combo_apos];
					
					if(is_large)
					{
						switch(alias_origin)
						{
							case 0:
								stretch_blit(brushbmp, brushscreen, 0,                                                                   0,                                                                     BrushWidth*16, BrushHeight*16, mx+(showedges?mgridscale:0),                                       my+(showedges?mgridscale:0),                                        BrushWidth*mgridscale, BrushHeight*mgridscale);
								break;
								
							case 1:
								stretch_blit(brushbmp, brushscreen, (mx<combo->width*mgridscale)?((combo->width)*16)-mx/mapscreensize:0, 0,                                                                     BrushWidth*16, BrushHeight*16, zc_max((mx-(combo->width)*mgridscale),0)+(showedges?mgridscale:0), my+(showedges?mgridscale:0),                                        BrushWidth*mgridscale, BrushHeight*mgridscale);
								break;
								
							case 2:
								stretch_blit(brushbmp, brushscreen, 0, (my<combo->height*mgridscale)?((combo->height)*16)-my/mapscreensize:0, BrushWidth*16, BrushHeight*16, mx+(showedges?mgridscale:0),                                       zc_max((my-(combo->height)*mgridscale),0)+(showedges?mgridscale:0), BrushWidth*mgridscale, BrushHeight*mgridscale);
								break;
								
							case 3:
								stretch_blit(brushbmp, brushscreen, (mx<combo->width*mgridscale)?((combo->width)*16)-mx/mapscreensize:0, (my<combo->height*mgridscale)?((combo->height)*16)-my/mapscreensize:0, BrushWidth*16, BrushHeight*16, zc_max((mx-(combo->width)*mgridscale),0)+(showedges?mgridscale:0), zc_max((my-(combo->height)*mgridscale),0)+(showedges?mgridscale:0), BrushWidth*mgridscale, BrushHeight*mgridscale);
								break;
						}
					}
					else
					{
						switch(alias_origin)
						{
							case 0:
								blit(brushbmp, brushscreen, 0,                                             0,                                               mx+(showedges?mgridscale:0),                               my+(showedges?mgridscale:0),                                BrushWidth*mgridscale, BrushHeight*mgridscale);
								break;
								
							case 1:
								blit(brushbmp, brushscreen, (mx<combo->width*16)?((combo->width)*16)-mx:0, 0,                                               zc_max((mx-(combo->width)*16),0)+(showedges?mgridscale:0), my+(showedges?mgridscale:0),                                BrushWidth*mgridscale, BrushHeight*mgridscale);
								break;
								
							case 2:
								blit(brushbmp, brushscreen, 0, (my<combo->height*16)?((combo->height)*16)-my:0, mx+(showedges?mgridscale:0),                               zc_max((my-(combo->height)*16),0)+(showedges?mgridscale:0), BrushWidth*mgridscale, BrushHeight*mgridscale);
								break;
								
							case 3:
								blit(brushbmp, brushscreen, (mx<combo->width*16)?((combo->width)*16)-mx:0, (my<combo->height*16)?((combo->height)*16)-my:0, zc_max((mx-(combo->width)*16),0)+(showedges?mgridscale:0), zc_max((my-(combo->height)*16),0)+(showedges?mgridscale:0), BrushWidth*mgridscale, BrushHeight*mgridscale);
								break;
						}
					}
				}
			}
			
			masked_blit(brushscreen, menu1, 0, 0, 0, 16, (16+(showedges?2:0))*mgridscale, (11+(showedges?2:0))*mgridscale);
			BrushWidth=tempbw;
			BrushHeight=tempbh;
		}
		else
		{
			if(!arrowcursor)
			{
				set_mouse_sprite(mouse_bmp[MOUSE_BMP_NORMAL][0]);
				arrowcursor = true;
			}
		}
		
		if(ShowGrid)
		{
			int32_t w=16;
			int32_t h=11;
			
			if(showedges)
			{
				w=18;
				h=13;
			}
			
			for(int32_t x=16; x<w*16; x+=16)
			{
				_allegro_vline(menu1, (x*mapscreensize)+mapscreen_x, mapscreen_y, mapscreen_y+(h*16*mapscreensize)-1, vc(GridColor));
			}
			
			for(int32_t y=16; y<h*16; y+=16)
			{
				_allegro_hline(menu1, mapscreen_x, (y*mapscreensize)+mapscreen_y, mapscreen_x+(w*16*mapscreensize)-1, vc(GridColor));
			}
		}
		
		// Map tabs
		if(is_large)
		{
			FONT* tfont = font;
			font = get_custom_font(CFONT_GUI);
			
			map_page[current_mappage].map=Map.getCurrMap();
			map_page[current_mappage].screen=Map.getCurrScr();
			
			for(int32_t btn=0; btn<mappage_count; ++btn)
			{
				char tbuf[15];
				sprintf(tbuf, "%d:%02X", map_page[btn].map+1, map_page[btn].screen);
				draw_layer_button(menu1,map_page_bar[btn].x, map_page_bar[btn].y, map_page_bar[btn].w, map_page_bar[btn].h,tbuf,(btn==current_mappage?D_SELECTED:0));
			}
			
			font=tfont;
		}
	}
	
	if((flags&rCOMBOS) || (draw_mode == dm_cpool && (flags&rFAVORITES)))
	{
		if(is_large)
		{
			auto real_h = combolist_window.h;
			if(draw_mode==dm_cpool)
				real_h = (favorites_window.y-combolist_window.y)+favorites_window.h;
			jwin_draw_frame(menu1,combolist_window.x,combolist_window.y,combolist_window.w,real_h, FR_WIN);
			rectfill(menu1,combolist_window.x+2,combolist_window.y+2,combolist_window.x+combolist_window.w-3,combolist_window.y+real_h-3,jwin_pal[jcBOX]);
			
			//Scrollers
			for(int32_t c = 0; c < num_combo_cols; ++c)
			{
				auto& pos = combolistscrollers[c];
				jwin_draw_frame(menu1,pos.x,pos.y,pos.w,pos.h,FR_ETCHED);
				
				for(int32_t i=0; i<3; i++)
				{
					_allegro_hline(menu1,pos.x+5-i,pos.y+4+i, pos.x+5+i, vc(0));
				}
				
				jwin_draw_frame(menu1,pos.x+pos.w,pos.y,pos.w,pos.h,FR_ETCHED);
				
				for(int32_t i=0; i<3; i++)
				{
					_allegro_hline(menu1,pos.x+pos.w+5-i,pos.y+6-i, pos.x+pos.w+5+i, vc(0));
				}
			}
		}
		if(draw_mode==dm_alias)
		{
			if(is_large)
			{
				for(int32_t c = 0; c < num_combo_cols; ++c)
				{
					auto& pos = comboaliaslist[c];
					jwin_draw_frame(menu1,pos.x-2,pos.y-2,(pos.w*pos.xscale)+4,(pos.h*pos.yscale)+4,FR_DEEP);
					
					if(MouseScroll)
					{
						jwin_draw_frame(menu1,pos.x-2,pos.y-10,(pos.w*pos.xscale)+4,6,FR_DEEP);
						rectfill(menu1,pos.x,pos.y-8,pos.x+(pos.w*pos.xscale)-1,pos.y-7,jwin_pal[jcBOXFG]);
					}
				}
				
                auto& prev = comboalias_preview;
				jwin_draw_frame(menu1, prev.x-2, prev.y-2, prev.w+4, prev.h+4,FR_DEEP);
				if(MouseScroll)
				{
					jwin_draw_frame(menu1,prev.x-2,prev.y+prev.h+4,prev.w+4,6,FR_DEEP);
					rectfill(menu1,prev.x,prev.y+prev.h+6,prev.x+prev.w-1,prev.y+prev.h+7,jwin_pal[jcBOXFG]);
				}
			}
			
			BITMAP *prv = create_bitmap_ex(8,64,64);
			clear_bitmap(prv);
			int32_t scalefactor = 1;
			
			for(int32_t j=0; j<num_combo_cols; ++j)
			{
				for(int32_t i=0; i<(comboaliaslist[j].w*comboaliaslist[j].h); i++)
				{
					draw_combo_alias_thumbnail(menu1, &combo_aliases[combo_alistpos[j]+i],
						(i%comboaliaslist[j].w)*comboaliaslist[j].xscale+comboaliaslist[j].x,
						(i/comboaliaslist[j].w)*comboaliaslist[j].yscale+comboaliaslist[j].y,
						comboaliaslist[j].xscale/16);
				}
				
				if((combo_aliases[combo_apos].width>7)||(combo_aliases[combo_apos].height>7))
				{
					scalefactor=4;
				}
				else if((combo_aliases[combo_apos].width>3)||(combo_aliases[combo_apos].height>3))
				{
					scalefactor=2;
				}
				
				if(j==current_comboalist)
				{
					stretch_blit(brushbmp, prv, 0,0,scalefactor*64,zc_min(scalefactor*64,176),0,0,64,scalefactor==4?44:64);
					blit(prv,menu1,0,0,comboalias_preview.x,comboalias_preview.y,comboalias_preview.w,comboalias_preview.h);
				}
				
				int32_t rect_pos=combo_apos-combo_alistpos[current_comboalist];
				
				if((rect_pos>=0)&&(rect_pos<(combo_alistpos[current_comboalist]+(comboaliaslist[current_comboalist].w*comboaliaslist[current_comboalist].h))))
					safe_rect(menu1,
					(rect_pos&(comboaliaslist[current_comboalist].w-1))*comboaliaslist[current_comboalist].xscale+comboaliaslist[current_comboalist].x,
					(rect_pos/comboaliaslist[current_comboalist].w)*comboaliaslist[current_comboalist].yscale+comboaliaslist[current_comboalist].y,
					((rect_pos&(comboaliaslist[current_comboalist].w-1))*comboaliaslist[current_comboalist].xscale+comboaliaslist[current_comboalist].x)+comboaliaslist[current_comboalist].xscale-1,
					((rect_pos/comboaliaslist[current_comboalist].w)*comboaliaslist[current_comboalist].yscale+comboaliaslist[current_comboalist].y)+comboaliaslist[current_comboalist].yscale-1,
					255);
			}
			
			destroy_bitmap(prv);
		}
		else if(draw_mode==dm_cpool)
		{
			if(is_large) //frames and stuff?
			{
				for(int32_t c = 0; c < num_combo_cols; ++c)
				{
					auto& pos = comboaliaslist[c];
					jwin_draw_frame(menu1,pos.x-2,pos.y-2,(pos.w*comboaliaslist[c].xscale)+4,(pos.h*comboaliaslist[c].yscale)+4,FR_DEEP);
					
					if(MouseScroll)
					{
						jwin_draw_frame(menu1,pos.x-2,pos.y-10,(pos.w<<4)+4,6,FR_DEEP);
						rectfill(menu1,pos.x,pos.y-8,pos.x+(pos.w<<4)-1,pos.y-7,jwin_pal[jcBOXFG]);
					}
				}
				if(MouseScroll)
					rectfill(menu1,combopool_preview.x,combopool_preview.y+combopool_preview.h+6,combopool_preview.x+combopool_preview.w-1,combopool_preview.y+combopool_preview.h+7,jwin_pal[jcBOXFG]);
			}
			else
			{
				auto sx = comboaliaslist[0].x, sy = comboaliaslist[0].y;
				auto sw = (comboaliaslist[0].w*comboaliaslist[0].xscale),
					 sh = (combopool_preview.y-comboaliaslist[0].y)+combopool_preview.h;
				rectfill(menu1,sx,sy,sx+sw-1,sy+sh-1,jwin_pal[jcBOX]);
				jwin_draw_frame(menu1,sx,sy,sw,sh,FR_DEEP);
			}
			
			for(int32_t j=0; j<num_combo_cols; ++j) //the actual panes
			{
				for(int32_t i=0; i<(comboaliaslist[j].w*comboaliaslist[j].h); i++)
				{
					int32_t cid=-1; int8_t cs=CSet;
					combo_pool const& cp = combo_pools[combo_pool_listpos[j]+i];
					
					auto& list = comboaliaslist[j];
					if(cp.get_w(cid,cs,0) && !combobuf[cid].tile)
					{
						cid = -1; //no tile to draw
					}
					auto cx = (i%list.w)*list.xscale+list.x;
					auto cy = (i/list.w)*list.yscale+list.y;
					put_combo(menu1,cx,cy,cid,cs,Flags&(cFLAGS|cWALK),0,list.xscale/16);
				}
			}
			int32_t rect_pos=combo_pool_pos-combo_pool_listpos[current_cpoollist];
			
			if((rect_pos>=0)&&(rect_pos<(combo_pool_listpos[current_cpoollist]+(comboaliaslist[current_cpoollist].w*comboaliaslist[current_cpoollist].h))))
				safe_rect(menu1,
				(rect_pos&(comboaliaslist[current_cpoollist].w-1))*comboaliaslist[current_cpoollist].xscale+comboaliaslist[current_cpoollist].x,
				(rect_pos/comboaliaslist[current_cpoollist].w)*comboaliaslist[current_cpoollist].yscale+comboaliaslist[current_cpoollist].y,
				((rect_pos&(comboaliaslist[current_cpoollist].w-1))*comboaliaslist[current_cpoollist].xscale+comboaliaslist[current_cpoollist].x)+comboaliaslist[current_cpoollist].xscale-1,
				((rect_pos/comboaliaslist[current_cpoollist].w)*comboaliaslist[current_cpoollist].yscale+comboaliaslist[current_cpoollist].y)+comboaliaslist[current_cpoollist].yscale-1,
				255);
			
			//Handle Preview
			combo_pool const& cpool = combo_pools[combo_pool_pos];
			
			int32_t cid; int8_t cs;
			size_t total = weighted_cpool ? cpool.getTotalWeight() : cpool.combos.size();
			size_t ind = 0;
			size_t indw = combopool_preview.w/16;
			size_t indh = combopool_preview.h/16;
			size_t rows = total ? vbound(total/indw,1,indh) : 0;
			size_t real_height = rows*16;
			
			cpool_prev_visible = rows > 0;
			if(rows)
			{
				jwin_draw_frame(menu1,combopool_preview.x-2,combopool_preview.y-2,
					combopool_preview.w+4,real_height+4,FR_DEEP);
				rectfill(menu1,combopool_preview.x,combopool_preview.y,
					combopool_preview.x+combopool_preview.w-1,
					combopool_preview.y+real_height-1,vc(0));
				draw_text_button(menu1,combopool_prevbtn.x,combopool_prevbtn.y,
					combopool_prevbtn.w,combopool_prevbtn.h,
					weighted_cpool ? "Weighted" : "Unweighted",vc(1),vc(14),0,true);
				if(!is_compact && is_large)
					textprintf_ex(menu1,font,combopool_prevbtn.x+combopool_prevbtn.w+5,
						combopool_prevbtn.y,jwin_pal[jcBOXFG],-1,"Preview");
				for(auto y = 0; y < real_height; y += 16)
				{
					for(auto x = 0; x < combopool_preview.w; x += 16, ++ind)
					{
						auto nx = combopool_preview.x+x, ny = combopool_preview.y+y;
						if(ind < total)
						{
							cs = CSet;
							if(weighted_cpool
								? cpool.get_w(cid,cs,ind)
								: cpool.get_ind(cid,cs,ind))
							{
								put_combo(menu1,nx,ny,cid,cs,Flags&(cFLAGS|cWALK),0);
								continue;
							}
						}
						//No combo to display
						xout(menu1, nx, ny, nx+15, ny+15, vc(15));
					}
				}
			}
		}
		else
		{
			if(is_large)
			{
				for(int32_t c = 0; c < num_combo_cols; ++c)
				{
					auto& pos = combolist[c];
					jwin_draw_frame(menu1,pos.x-2,pos.y-2,(pos.w*pos.xscale)+4,(pos.h*pos.yscale)+4,FR_DEEP);
					
					if(MouseScroll)
					{
						jwin_draw_frame(menu1,pos.x-2,pos.y-10,(pos.w<<4)+4,6,FR_DEEP);
						rectfill(menu1,pos.x,pos.y-8,pos.x+(pos.w<<4)-1,pos.y-7,jwin_pal[jcBOXFG]);
						
						jwin_draw_frame(menu1,pos.x-2,pos.y+(pos.h<<4)+4,(pos.w<<4)+4,6,FR_DEEP);
						rectfill(menu1,pos.x,pos.y+(pos.h<<4)+6,pos.x+(pos.w<<4)-1,pos.y+(pos.h<<4)+7,jwin_pal[jcBOXFG]);
					}
				}
			}
			
			int32_t drawmap, drawscr;
			drawmap=Map.CurrScr()->layermap[CurrentLayer-1]-1;
			drawscr=Map.CurrScr()->layerscreen[CurrentLayer-1];
			
			for(int32_t j=0; j<num_combo_cols; ++j)
			{
				for(int32_t i=0; i<(combolist[j].w*combolist[j].h); i++)
				{
					put_combo(menu1,(i%combolist[j].w)*combolist[j].xscale+combolist[j].x,
						(i/combolist[j].w)*combolist[j].yscale+combolist[j].y,
						i+First[j],CSet,Flags&(cFLAGS|cWALK),0,combolist[j].xscale/16);
				}
			}
			
			int32_t rect_pos=Combo-First[current_combolist];
			
			if((rect_pos>=0)&&(rect_pos<(combo_pool_listpos[current_combolist]+(combolist[current_combolist].w*combolist[current_combolist].h))))
				safe_rect(menu1,
				(rect_pos&(combolist[current_combolist].w-1))*combolist[current_combolist].xscale+combolist[current_combolist].x,
				(rect_pos/combolist[current_combolist].w)*combolist[current_combolist].yscale+combolist[current_combolist].y,
				((rect_pos&(combolist[current_combolist].w-1))*combolist[current_combolist].xscale+combolist[current_combolist].x)+combolist[current_combolist].xscale-1,
				((rect_pos/combolist[current_combolist].w)*combolist[current_combolist].yscale+combolist[current_combolist].y)+combolist[current_combolist].yscale-1,
				255);
		}
	}
	
	if(flags&rCOMBO)
	{
		int32_t drawmap, drawscr;
		drawmap=Map.CurrScr()->layermap[CurrentLayer-1]-1;
		drawscr=Map.CurrScr()->layerscreen[CurrentLayer-1];
		
		// Combo preview
		int32_t cid = Combo; int8_t cs = CSet;
		if(draw_mode == dm_alias)
		{
			cid = combo_aliases[combo_apos].combos[0];
			cs = wrap(combo_aliases[combo_apos].csets[0]+alias_cset_mod, 0, 11);
		}
		else if(draw_mode == dm_cpool)
		{
			combo_pool const& cpool = combo_pools[combo_pool_pos];
			cid = 0;
			cpool.get_w(cid,cs,0);
		}
		if(is_large)
		{
			static BITMAP *combo_preview_bmp=create_bitmap_ex(8,32,32);
			static BITMAP *cycle_preview_bmp=create_bitmap_ex(8,32,32);
			// Combo
			put_combo(combo_preview_bmp,0,0,cid,cs,Flags&(cFLAGS|cWALK),0);
			jwin_draw_frame(menu1,combo_preview.x-2,combo_preview.y-2,combo_preview.w+4,combo_preview.h+4, FR_DEEP);
			stretch_blit(combo_preview_bmp, menu1, 0, 0, 16, 16, combo_preview.x, combo_preview.y, combo_preview.w, combo_preview.h);
			
			if(draw_mode == dm_cpool)
			{
				char buf[17];
				sprintf(buf,"Pool: %d",combo_pool_pos);
				textprintf_ex(menu1,pfont,combo_preview.x-text_length(pfont,buf)-8,combo_preview.y+2,jwin_pal[jcBOXFG],jwin_pal[jcBOX],"%s",buf);
			}
			else if(draw_mode != dm_alias)
			{
				char buf[256];
				int32_t offs = is_compact ? 4 : 8;
				sprintf(buf,"Combo: %d",Combo);
				textprintf_ex(menu1,pfont,combo_preview.x-text_length(pfont,buf)-offs,combo_preview.y+2,jwin_pal[jcBOXFG],jwin_pal[jcBOX],"%s",buf);
				sprintf(buf,"CSet: %d",CSet);
				textprintf_ex(menu1,pfont,combo_preview.x-text_length(pfont,buf)-offs,combo_preview.y+11,jwin_pal[jcBOXFG],jwin_pal[jcBOX],"%s",buf);
				strcpy(buf,combo_class_buf[combobuf[Combo].type].name);
				
				int32_t x = combo_preview.x-offs;
				auto ind = strlen(buf)-1;
				if(x - text_length(pfont, buf) <= combolist_window.x)
				{
					auto dotlen = text_length(pfont, "..");
					x -= dotlen;
					while(x - text_length(pfont, buf) <= combolist_window.x)
					{
						if(ind < 0) break;
						buf[ind--] = '\0';
					}
					while(ind >= 0 && buf[ind] == ' ')
						buf[ind--] = 0; //trim spaces
					x -= text_length(pfont, buf);
					strcat(buf, "..");
				}
				else x -= text_length(pfont, buf);
				
				textprintf_ex(menu1,pfont,x,combo_preview.y+20,jwin_pal[jcBOXFG],jwin_pal[jcBOX],"%s",buf);
			}
			
			// Cycle
			if(!is_compact)
			{
				int32_t NextCombo=combobuf[Combo].nextcombo;
				int32_t NextCSet=(combobuf[Combo].animflags & AF_CYCLENOCSET) ? CSet : combobuf[Combo].nextcset;
				bool normal_dm = draw_mode != dm_alias && draw_mode != dm_cpool;
				jwin_draw_frame(menu1,combo_preview.x+int32_t(combo_preview.w*1.5)-2,combo_preview.y-2,combo_preview.w+4,combo_preview.h+4, FR_DEEP);
				if(NextCombo>0 && normal_dm)
				{
					put_combo(cycle_preview_bmp,0,0,NextCombo,NextCSet,Flags&(cFLAGS|cWALK),0);
					
					if(Flags&cWALK) put_walkflags(cycle_preview_bmp,0,0,NextCombo,0);
					
					if(Flags&cFLAGS) put_flags(cycle_preview_bmp,0,0,NextCombo,0,cFLAGS,0);
					
					stretch_blit(cycle_preview_bmp, menu1, 0, 0, 16, 16, combo_preview.x+int32_t(combo_preview.w*1.5), combo_preview.y, combo_preview.w, combo_preview.h);
				}
				else
				{
					if(InvalidStatic)
					{
						for(int32_t dy=0; dy<32; dy++)
						{
							for(int32_t dx=0; dx<32; dx++)
							{
								menu1->line[dy+combo_preview.y][dx+combo_preview.x+int32_t(combo_preview.w*1.5)]=vc((((zc_oldrand()%100)/50)?0:8)+(((zc_oldrand()%100)/50)?0:7));
							}
						}
					}
					else
					{
						rectfill(menu1, combo_preview.x+int32_t(combo_preview.w*1.5),combo_preview.y, combo_preview.x+int32_t(combo_preview.w*2.5),combo_preview.y+combo_preview.h,vc(0));
						safe_rect(menu1, combo_preview.x+int32_t(combo_preview.w*1.5),combo_preview.y, combo_preview.x+int32_t(combo_preview.w*2.5),combo_preview.y+combo_preview.h,vc(15));
						line(menu1, combo_preview.x+int32_t(combo_preview.w*1.5),combo_preview.y, combo_preview.x+int32_t(combo_preview.w*2.5),combo_preview.y+combo_preview.h,vc(15));
						line(menu1, combo_preview.x+int32_t(combo_preview.w*1.5),combo_preview.y+combo_preview.h, combo_preview.x+int32_t(combo_preview.w*2.5),combo_preview.y,vc(15));
					}
				}
				
				if(normal_dm)
				{
				
					textprintf_ex(menu1,pfont,combo_preview.x+int32_t(combo_preview.w*2.5)+6,combo_preview.y+2,jwin_pal[jcBOXFG],jwin_pal[jcBOX],"Cycle: %d",NextCombo);
					textprintf_ex(menu1,pfont,combo_preview.x+int32_t(combo_preview.w*2.5)+6,combo_preview.y+11,jwin_pal[jcBOXFG],jwin_pal[jcBOX],"CSet: %d",NextCSet);
					char buf[17];
					int32_t offs = 8;
					strncpy(buf,combo_class_buf[combobuf[NextCombo].type].name,16);
					
					if(strlen(combo_class_buf[combobuf[NextCombo].type].name) > 15)
					{
						buf[15]='.';
						buf[14]='.';
						offs = 5;
					}
					
					buf[16]='\0';
					textprintf_ex(menu1,pfont,combo_preview.x+int32_t(combo_preview.w*2.5)+6,combo_preview.y+20,jwin_pal[jcBOXFG],jwin_pal[jcBOX],"%s",buf);
				}
			}
			
			FONT* oldfont = font;
			font = lfont_l;
			bool merged = is_compact ? compact_merged_combopane : large_merged_combopane;
			draw_text_button(menu1,combo_merge_btn.x,combo_merge_btn.y,combo_merge_btn.w,combo_merge_btn.h,merged ? "<|>" : ">|<",vc(1),vc(14),0,true);
			font = oldfont;
		}
		else
		{
			put_combo(menu1,combo_preview.x,combo_preview.y,cid,cs,Flags&(cFLAGS|cWALK),0);
		}
	}
	
	if(flags&rMENU)
	{
		drawpanel(is_large?-1:menutype);
		set_clip_rect(menu1,0,0,zq_screen_w-1,zq_screen_h-1);
	}
	
	if(flags&rFAVORITES)
	{
		if(is_large && draw_mode!=dm_cpool)
		{
			jwin_draw_frame(menu1,favorites_window.x,favorites_window.y,favorites_window.w,favorites_window.h, FR_WIN);
			rectfill(menu1,favorites_window.x+2,favorites_window.y+2,favorites_window.x+favorites_window.w-3,favorites_window.y+favorites_window.h-3,jwin_pal[jcBOX]);
			jwin_draw_frame(menu1,favorites_list.x-2,favorites_list.y-2,(favorites_list.w<<4)+4,(favorites_list.h<<4)+4, FR_DEEP);
			rectfill(menu1,favorites_list.x,favorites_list.y,favorites_list.x+(favorites_list.w<<4)-1,favorites_list.y+(favorites_list.h<<4)-1,jwin_pal[jcBOXFG]);
			
			jwin_draw_frame(menu1,favorites_x.x,favorites_x.y,favorites_x.w,favorites_x.h,FR_ETCHED);
			const auto szval = 2;
			line(menu1, favorites_x.x+szval, favorites_x.y+szval, favorites_x.x+(10-szval), favorites_x.y+(10-szval),jwin_pal[jcBOXFG]);
			line(menu1, favorites_x.x+szval, favorites_x.y+(10-szval), favorites_x.x+(10-szval), favorites_x.y+szval,jwin_pal[jcBOXFG]);
			textprintf_ex(menu1,font,favorites_list.x-2,favorites_list.y-11,jwin_pal[jcBOXFG],-1,draw_mode == dm_alias ? "Favorite Aliases" : "Favorite Combos");
			if(draw_mode==dm_alias)
			{
				for(int32_t col=0; col<favorites_list.w; ++col)
				{
					for(int32_t row=0; row<favorites_list.h; ++row)
					{
						auto i = (row*FAVORITECOMBO_PER_ROW)+col;
						if(i >= MAXFAVORITECOMBOALIASES)
						{
							for(int32_t dy=0; dy<16; dy++)
							{
								for(int32_t dx=0; dx<16; dx++)
								{
									menu1->line[(row)*16+favorites_list.y+dy][(col)*16+favorites_list.x+dx]=vc((((zc_oldrand()%100)/50)?0:8)+(((zc_oldrand()%100)/50)?0:7));
								}
							}
						}
						else if(favorite_comboaliases[i]==-1)
						{
							if(InvalidStatic)
							{
								for(int32_t dy=0; dy<16; dy++)
								{
									for(int32_t dx=0; dx<16; dx++)
									{
										menu1->line[(row)*16+favorites_list.y+dy][(col)*16+favorites_list.x+dx]=vc((((zc_oldrand()%100)/50)?0:8)+(((zc_oldrand()%100)/50)?0:7));
									}
								}
							}
							else
							{
								xout(menu1, (col)*16+favorites_list.x, (row)*16+favorites_list.y, (col)*16+favorites_list.x+15, (row)*16+favorites_list.y+15, vc(15), vc(0));
							}
						}
						else
						{
							draw_combo_alias_thumbnail(menu1, &combo_aliases[favorite_comboaliases[i]], (col)*16+favorites_list.x,(row)*16+favorites_list.y,1);
						}
					}
				}
			}
			else
			{
				for(int32_t col=0; col<favorites_list.w; ++col)
				{
					for(int32_t row=0; row<favorites_list.h; ++row)
					{
						auto i = (row*FAVORITECOMBO_PER_ROW)+col;
						if(i >= MAXFAVORITECOMBOS)
						{
							for(int32_t dy=0; dy<16; dy++)
							{
								for(int32_t dx=0; dx<16; dx++)
								{
									menu1->line[(row)*16+favorites_list.y+dy][(col)*16+favorites_list.x+dx]=vc((((zc_oldrand()%100)/50)?0:8)+(((zc_oldrand()%100)/50)?0:7));
								}
							}
						}
						else if(favorite_combos[i]==-1)
						{
							if(InvalidStatic)
							{
								for(int32_t dy=0; dy<16; dy++)
								{
									for(int32_t dx=0; dx<16; dx++)
									{
										menu1->line[(row)*16+favorites_list.y+dy][(col)*16+favorites_list.x+dx]=vc((((zc_oldrand()%100)/50)?0:8)+(((zc_oldrand()%100)/50)?0:7));
									}
								}
							}
							else
							{
								xout(menu1, (col)*16+favorites_list.x, (row)*16+favorites_list.y, (col)*16+favorites_list.x+15, (row)*16+favorites_list.y+15, vc(15), vc(0));
							}
						}
						else
						{
							put_combo(menu1,(col)*16+favorites_list.x,(row)*16+favorites_list.y,favorite_combos[i],CSet,Flags&(cFLAGS|cWALK),0);
						}
					}
				}
			}
		}
	}
	
	if(flags&rCOMMANDS)
	{
		if(is_large)
		{
			jwin_draw_frame(menu1,commands_window.x,commands_window.y,commands_window.w,commands_window.h, FR_WIN);
			rectfill(menu1,commands_window.x+2,commands_window.y+2,commands_window.x+commands_window.w-3,commands_window.y+commands_window.h-3,jwin_pal[jcBOX]);
			jwin_draw_frame(menu1,commands_list.x-2,commands_list.y-2,(commands_list.w*commands_list.xscale)+4,(commands_list.h*commands_list.yscale)+4, FR_DEEP);
			rectfill(menu1,commands_list.x,commands_list.y,commands_list.x+(commands_list.w*commands_list.xscale)-1,commands_list.y+(commands_list.h*commands_list.yscale)-1,jwin_pal[jcBOXFG]);
			//textprintf_ex(menu1,font,commands_list.x-2,commands_list.y-14,jwin_pal[jcBOXFG],-1,"Favorite Commands");
			FONT *tfont=font;
			font=get_custom_font(CFONT_FAVCMD);
			
			for(int32_t cmd=0; cmd<(commands_list.w*commands_list.h); ++cmd)
			{
				draw_layer_button(menu1,
					(cmd%commands_list.w)*commands_list.xscale+commands_list.x,
					(cmd/commands_list.w)*commands_list.yscale+commands_list.y,
					commands_list.xscale,
					commands_list.yscale,
					(favorite_commands[cmd]==cmdCatchall&&strcmp(catchall_string[Map.CurrScr()->room]," "))?catchall_string[Map.CurrScr()->room]:commands[favorite_commands[cmd]].name,
					(isFavCmdSelected(favorite_commands[cmd])?D_SELECTED:0) | commands[favorite_commands[cmd]].flags);
			}
			
			font=tfont;
		}
	}
	
	if(is_large) // Layer panels
	{
		FONT* tfont = font;
		font = get_custom_font(CFONT_GUI);
		jwin_draw_frame(menu1,layer_panel.x,layer_panel.y,layer_panel.w,layer_panel.h,FR_DEEP);
		rectfill(menu1,layer_panel.x,layer_panel.y,layer_panel.x+layer_panel.w-1,layer_panel.y+layer_panel.h-1,jwin_pal[jcBOX]);
		
		for(int32_t i=0; i<=6; ++i)
		{
			char tbuf[15];
			
			if(i>0 && Map.CurrScr()->layermap[i-1])
			{
				if(is_compact)
					sprintf(tbuf, "%s%d %d:%02X", (i==2 && Map.CurrScr()->flags7&fLAYER2BG) || (i==3 && Map.CurrScr()->flags7&fLAYER3BG) ? "-":"", i, Map.CurrScr()->layermap[i-1], Map.CurrScr()->layerscreen[i-1]);
				else sprintf(tbuf, "%s%d (%d:%02X)", (i==2 && Map.CurrScr()->flags7&fLAYER2BG) || (i==3 && Map.CurrScr()->flags7&fLAYER3BG) ? "-":"", i, Map.CurrScr()->layermap[i-1], Map.CurrScr()->layerscreen[i-1]);
			}
			else
			{
				sprintf(tbuf, "%s%d", (i==2 && Map.CurrScr()->flags7&fLAYER2BG) || (i==3 && Map.CurrScr()->flags7&fLAYER3BG) ? "-":"", i);
			}
			
			int32_t spacing_offs = is_compact ? 2 : 10;
			int32_t rx = (i * (layerpanel_buttonwidth+spacing_offs+layerpanel_checkbox_wid)) + layer_panel.x+(is_compact?2:6);
			int32_t ry = layer_panel.y;
			auto cbyofs = (layerpanel_buttonheight-layerpanel_checkbox_hei)/2;
			draw_layer_button(menu1, rx, ry, layerpanel_buttonwidth, layerpanel_buttonheight, tbuf, CurrentLayer==i? D_SELECTED : (!Map.CurrScr()->layermap[i-1] && i>0) ? D_DISABLED : 0);
			draw_checkbox(menu1,rx+layerpanel_buttonwidth+1,ry+cbyofs,layerpanel_checkbox_wid,layerpanel_checkbox_hei,vc(1),vc(14), LayerMaskInt[i]!=0);
		}
		
		font=tfont;
	}
	
	// } //if(true)
	if(zq_showpal)
	{
		for(int32_t i=0; i<256; i++)
		{
			rectfill(menu1,((i&15)<<2)+256,((i>>4)<<2)+176,((i&15)<<2)+259,((i>>4)<<2)+179,i);
		}
	}
	
	if(ShowFPS)
	{
		FONT* fpsfont = is_large ? lfont_l : font;
		textprintf_shadowed_ex(menu1,fpsfont,0,prv_mode?32:16,vc(15),vc(0),-1,"FPS:%-3d",lastfps);
	}
	
	if(prv_mode)
	{
		textout_shadowed_ex(menu1,sfont,"Preview Mode",0,16,vc(15),vc(0),-1);
		
		if(prv_twon)
		{
			textprintf_shadowed_ex(menu1,sfont,0,24,vc(15),vc(0),-1,"T Warp=%d tics", Map.get_prvtime());
		}
		
		do_previewtext();
		
	}
	
	if(ShowFFScripts && !prv_mode)
	{
		FONT* ffcfont = is_large ? lfont_l : font;
		int ff_fonth = text_height(ffcfont);
		int32_t ypos = mapscreen_y+(ShowFPS ? ff_fonth+1 : 0);
		size_t maxwid = mapscreen_x+(mapscreensize*mapscreenbmp->w);
		BITMAP* tempbmp = create_bitmap_ex(8,maxwid,ff_fonth);
		word c = Map.CurrScr()->numFFC();
		for(word i=0; i< c; i++)
		{
			if(ypos+ff_fonth-1 > (is_large ? map_page_bar[0].y : 180))
				break;
			if(Map.CurrScr()->ffcs[i].script && Map.CurrScr()->ffcs[i].getData())
			{
				clear_bitmap(tempbmp);
				textout_shadowed_ex(tempbmp,ffcfont, ffcmap[Map.CurrScr()->ffcs[i].script-1].scriptname.substr(0,300).c_str(),2,0,vc(showxypos_ffc==i ? 14 : 15),vc(0),-1);
				masked_blit(tempbmp,menu1,0,0,0,ypos,tempbmp->w, tempbmp->h);
				ypos+=ff_fonth+1;
			}
		}
		destroy_bitmap(tempbmp);
	}
	
	// Show Errors & Details
	//This includes the presence of: Screen State Carryover, Timed Warp, Maze Path, the 'Sideview Gravity', 'Invisible Player',
	//'Save Screen', 'Continue Here' and 'Treat As..' Screen Flags,
	// the String, every Room Type and Catch All, and all four Tile and Side Warps.
	if(is_large && !prv_mode && ShowInfo)
	{
		int32_t i=0;
		char buf[2048];
		
		// Start with general information
		if(Map.CurrScr()->flags3&fINVISHERO)
		{
			sprintf(buf,"Invisible Player");
			show_screen_error(buf,i++,vc(15));
		}
		
		if(Map.getLayerTargetMap() > 0)
		{
			Map.setlayertarget(); //Now the text does not carry over when changing maps, but shifting back, it does not **re-appear** until you change screens.
			//It was also required to set some updates in onDecMap and onIncMap. #
			//This fixes Screen Info not displaying properly when changing maps. -Z 
			//Needed to refresh the screen info. -Z ( 26th March, 2019 )
			int32_t m = Map.getLayerTargetMultiple();
			sprintf(buf,"Used as a layer by screen %d:%02X",Map.getLayerTargetMap(),Map.getLayerTargetScr());
			char buf2[24];
			
			if(m>0)
			{
				sprintf(buf2," and %d other%s",m,m>1?"s":"");
				strcat(buf,buf2);
			}
			
			show_screen_error(buf,i++,vc(15));
		}
		
		if(Map.CurrScr()->nextmap)
		{
			sprintf(buf,"Screen State carries over to %d:%02X",Map.CurrScr()->nextmap,Map.CurrScr()->nextscr);
			show_screen_error(buf,i++,vc(15));
		}
		
		if(Map.CurrScr()->timedwarptics)
		{
			sprintf(buf,"%s%sTimed Warp: %s",(Map.CurrScr()->flags4&fTIMEDDIRECT)?"Direct ":"",(Map.CurrScr()->flags5&fRANDOMTIMEDWARP)?"Random ":"",ticksstr(Map.CurrScr()->timedwarptics));
			show_screen_error(buf,i++,vc(15));
		}
		
		if(Map.CurrScr()->flags&fMAZE)
		{
			sprintf(buf,"Maze Path: %s (Exit %s)",pathstr(Map.CurrScr()->path),dirstr[Map.CurrScr()->exitdir]);
			show_screen_error(buf,i++,vc(15));
		}
		
		bool continuescreen = false, savecombo = false;
		
		if(Map.CurrScr()->flags4&fAUTOSAVE)
		{
			sprintf(buf,"Automatic Save%s Screen", (Map.CurrScr()->flags6&fCONTINUEHERE) ? "-Continue":"");
			show_screen_error(buf,i++,vc(15));
			continuescreen = ((Map.CurrScr()->flags6&fCONTINUEHERE)!=0);
			savecombo = true;
		}
		else if(Map.CurrScr()->flags6&fCONTINUEHERE)
		{
			sprintf(buf,"Continue Screen");
			show_screen_error(buf,i++,vc(15));
			continuescreen = true;
		}
		
		if(isSideViewGravity())
		{
			sprintf(buf,"Sideview Gravity");
			show_screen_error(buf,i++,vc(15));
		}
		
		if(Map.CurrScr()->flags6 & (fCAVEROOM|fDUNGEONROOM))
		{
			sprintf(buf,"Treat As %s%s Screen", (Map.CurrScr()->flags6&fCAVEROOM) ? "Interior":"NES Dungeon",
					(Map.CurrScr()->flags6 & (fCAVEROOM|fDUNGEONROOM)) == (fCAVEROOM|fDUNGEONROOM) ? " or NES Dungeon":"");
			show_screen_error(buf,i++,vc(15));
		}
		
		if(Map.CurrScr()->oceansfx != 0)
		{
			sprintf(buf,"Ambient Sound: %s",sfx_string[Map.CurrScr()->oceansfx]);
			show_screen_error(buf,i++,vc(15));
		}
		
		if(Map.CurrScr()->bosssfx != 0)
		{
			sprintf(buf,"Boss Roar Sound: %s",sfx_string[Map.CurrScr()->bosssfx]);
			show_screen_error(buf,i++,vc(15));
		}
		
		if(Map.CurrScr()->str)
		{
			strncpy(buf,MsgString(Map.CurrScr()->str, true, false),72);
			buf[72] = '\0';
			char shortbuf[72];
			strip_extra_spaces(buf);
			shorten_string(shortbuf, buf, lfont_l, 72, 280);
			sprintf(buf,"String %s",shortbuf);
			show_screen_error(buf,i++,vc(15));
		}
		
		if((Map.CurrScr()->flags&fWHISTLE) || (Map.CurrScr()->flags7&fWHISTLEWATER))
		{
			sprintf(buf,"Whistle ->%s%s%s",(Map.CurrScr()->flags&fWHISTLE)?" Stairs":"",
				    (Map.CurrScr()->flags&fWHISTLE && Map.CurrScr()->flags7&fWHISTLEWATER)?", ":"",
			        (Map.CurrScr()->flags7&fWHISTLEWATER)?"Dry Lake":"");
			show_screen_error(buf,i++,vc(15));
		}
		
		switch(Map.CurrScr()->room)
		{
			case rSP_ITEM:
				sprintf(buf,"Special Item is %s",item_string[Map.CurrScr()->catchall]);
				show_screen_error(buf,i++, vc(15));
				break;
				
			case rINFO:
			{
				int32_t shop = Map.CurrScr()->catchall;
				sprintf(buf,"Pay For Info: -%d, -%d, -%d",
						misc.info[shop].price[0],misc.info[shop].price[1],misc.info[shop].price[2]);
				show_screen_error(buf,i++, vc(15));
			}
			break;
			
			case rMONEY:
				sprintf(buf,"Secret Money: %d Rupees",Map.CurrScr()->catchall);
				show_screen_error(buf,i++, vc(15));
				break;
				
			case rGAMBLE:
				show_screen_error("Gamble Room",i++, vc(15));
				break;
				
			case rREPAIR:
				sprintf(buf,"Door Repair: -%d Rupees",Map.CurrScr()->catchall);
				show_screen_error(buf,i++, vc(15));
				break;
				
			case rRP_HC:
				sprintf(buf,"Take %s or %s", item_string[iRPotion], item_string[iHeartC]);
				show_screen_error(buf,i++, vc(15));
				break;
				
			case rGRUMBLE:
				show_screen_error("Feed the Goriya",i++, vc(15));
				break;
				
			case rTRIFORCE:
				show_screen_error("Triforce Check",i++, vc(15));
				break;
				
			case rP_SHOP:
			case rSHOP:
			{
				int32_t shop = Map.CurrScr()->catchall;
				sprintf(buf,"%sShop: ",
						Map.CurrScr()->room==rP_SHOP ? "Potion ":"");
						
				for(int32_t j=0; j<3; j++) if(misc.shop[shop].item[j]>0)  // Print the 3 items and prices
				{
					strcat(buf,item_string[misc.shop[shop].item[j]]);
					strcat(buf,":");
					char pricebuf[8];
					sprintf(pricebuf,"%d",misc.shop[shop].price[j]);
					strcat(buf,pricebuf);
					
					if(j<2 && misc.shop[shop].item[j+1]>0) strcat(buf,", ");
				}
					
				show_screen_error(buf,i++, vc(15));
			}
			break;
			
			case rBOTTLESHOP:
			{
				int32_t shop = Map.CurrScr()->catchall;
				sprintf(buf,"Bottle Shop: ");
						
				for(int32_t j=0; j<3; j++) if(misc.bottle_shop_types[shop].fill[j]>0)  // Print the 3 fills and prices
				{
					strcat(buf,misc.bottle_types[misc.bottle_shop_types[shop].fill[j]-1].name);
					strcat(buf,":");
					char pricebuf[8];
					sprintf(pricebuf,"%d",misc.bottle_shop_types[shop].price[j]);
					strcat(buf,pricebuf);
					
					if(j<2 && misc.bottle_shop_types[shop].fill[j+1]>0) strcat(buf,", ");
				}
					
				show_screen_error(buf,i++, vc(15));
			}
			break;
			
			case rTAKEONE:
			{
				int32_t shop = Map.CurrScr()->catchall;
				sprintf(buf,"Take Only One: %s%s%s%s%s",
						misc.shop[shop].item[0]<1?"":item_string[misc.shop[shop].item[0]],misc.shop[shop].item[0]>0?", ":"",
						misc.shop[shop].item[1]<1?"":item_string[misc.shop[shop].item[1]],(misc.shop[shop].item[1]>0&&misc.shop[shop].item[2]>0)?", ":"",
						misc.shop[shop].item[2]<1?"":item_string[misc.shop[shop].item[2]]);
				show_screen_error(buf,i++, vc(15));
			}
			break;
			
			case rBOMBS:
				sprintf(buf,"More Bombs: -%d Rupees",Map.CurrScr()->catchall);
				show_screen_error(buf,i++, vc(15));
				break;
				
			case rARROWS:
				sprintf(buf,"More Arrows: -%d Rupees",Map.CurrScr()->catchall);
				show_screen_error(buf,i++, vc(15));
				break;
				
			case rSWINDLE:
				sprintf(buf,"Leave Life or %d Rupees",Map.CurrScr()->catchall);
				show_screen_error(buf,i++, vc(15));
				break;
				
			case r10RUPIES:
				show_screen_error("10 Rupees",i++, vc(15));
				break;
				
			case rGANON:
				show_screen_error("Ganon Room",i++, vc(15));
				break;
				
			case rZELDA:
				show_screen_error("Zelda Room",i++, vc(15));
				break;
				
			case rMUPGRADE:
				show_screen_error("1/2 Magic Upgrade",i++, vc(15));
				break;
				
			case rLEARNSLASH:
				show_screen_error("Learn Slash",i++, vc(15));
				break;
				
			case rWARP:
				sprintf(buf,"3-Stair Warp: Warp Ring %d",Map.CurrScr()->catchall);
				show_screen_error(buf,i++, vc(15));
				break;
		}
		
		bool undercombo = false, warpa = false, warpb = false, warpc = false, warpd = false, warpr = false;
		
		word maxffc = Map.CurrScr()->numFFC();
		for(int32_t c=0; c<176+128+1+maxffc; ++c)
		{
			// Checks both combos, secret combos, undercombos and FFCs
			//Fixme:
			int32_t ctype =
				combobuf[vbound(
					(c>=305 ? Map.CurrScr()->ffcs[c-305].getData() :
					 c>=304 ? Map.CurrScr()->undercombo :
					 c>=176 ? Map.CurrScr()->secretcombo[c-176] :
					 !Map.CurrScr()->valid ? 0 : // Sanity check: does room combo data exist?
					 Map.CurrScr()->data[c]
					), 0, MAXCOMBOS-1)].type;
							 
			if(!undercombo && integrityBoolUnderCombo(Map.CurrScr(),ctype))
			{
				undercombo = true;
				show_screen_error("Under Combo is combo 0",i++, vc(7));
			}
			
			// Tile Warp types
			switch(ctype)
			{
				case cSAVE:
				case cSAVE2:
					if(!savecombo)
					{
						savecombo = true;
						
						if(integrityBoolSaveCombo(Map.CurrScr(),ctype))
							show_screen_error("Save Screen",i++, vc(15));
						else
							show_screen_error("Save-Continue Screen",i++, vc(15));
					}
					
					break;
					
				case cSTAIRR:
				case cPITR:
				case cSWARPR:
					if(!warpr && (Map.CurrScr()->tilewarptype[0]==wtCAVE || Map.CurrScr()->tilewarptype[1]==wtCAVE ||
								  Map.CurrScr()->tilewarptype[2]==wtCAVE || Map.CurrScr()->tilewarptype[3]==wtCAVE))
					{
						warpr = true;
						show_screen_error("Random Tile Warp contains Cave/Item Cellar",i++, vc(7));
					}
					
					break;
					
				case cCAVED:
				case cPITD:
				case cSTAIRD:
				case cCAVE2D:
				case cSWIMWARPD:
				case cDIVEWARPD:
				case cSWARPD:
					if(!warpd)
					{
						warpd = true;
						tile_warp_notification(3,buf);
						show_screen_error(buf,i++, vc(15));
					}
					
					break;
					
				case cCAVEC:
				case cPITC:
				case cSTAIRC:
				case cCAVE2C:
				case cSWIMWARPC:
				case cDIVEWARPC:
				case cSWARPC:
					if(!warpc)
					{
						warpc = true;
						tile_warp_notification(2,buf);
						show_screen_error(buf,i++, vc(15));
					}
					
					break;
					
				case cCAVEB:
				case cPITB:
				case cSTAIRB:
				case cCAVE2B:
				case cSWIMWARPB:
				case cDIVEWARPB:
				case cSWARPB:
					if(!warpb)
					{
						warpb = true;
						tile_warp_notification(1,buf);
						show_screen_error(buf,i++, vc(15));
					}
					
					break;
					
				case cCAVE:
				case cPIT:
				case cSTAIR:
				case cCAVE2:
				case cSWIMWARP:
				case cDIVEWARP:
				case cSWARPA:
					if(!warpa)
					{
						warpa = true;
						tile_warp_notification(0,buf);
						show_screen_error(buf,i++, vc(15));
					}
					
					break;
			}
		}
		
		int32_t sidewarpnotify = 0;
		
		if(Map.CurrScr()->flags2&wfUP)
		{
			side_warp_notification(Map.CurrScr()->sidewarpindex&3,0,buf);
			show_screen_error(buf,i++, vc(15));
			sidewarpnotify|=(1<<(Map.CurrScr()->sidewarpindex&3));
		}
		
		if(Map.CurrScr()->flags2&wfDOWN)
		{
			side_warp_notification((Map.CurrScr()->sidewarpindex>>2)&3,1,buf);
			show_screen_error(buf,i++, vc(15));
			sidewarpnotify|=(1<<((Map.CurrScr()->sidewarpindex>>2)&3));
		}
		
		if(Map.CurrScr()->flags2&wfLEFT)
		{
			side_warp_notification((Map.CurrScr()->sidewarpindex>>4)&3,2,buf);
			show_screen_error(buf,i++, vc(15));
			sidewarpnotify|=(1<<((Map.CurrScr()->sidewarpindex>>4)&3));
		}
		
		if(Map.CurrScr()->flags2&wfRIGHT)
		{
			side_warp_notification((Map.CurrScr()->sidewarpindex>>6)&3,3,buf);
			show_screen_error(buf,i++, vc(15));
			sidewarpnotify|=(1<<((Map.CurrScr()->sidewarpindex>>6)&3));
		}
		
		if(!(sidewarpnotify&1) && Map.CurrScr()->timedwarptics)
		{
			side_warp_notification(0,4,buf); // Timed Warp
			show_screen_error(buf,i++, vc(15));
		}
		
		// Now for errors
		if((Map.CurrScr()->flags4&fSAVEROOM) && !savecombo) show_screen_error("Save Point->Continue Here, but no Save Point combo?",i++, vc(14));
		
		if(integrityBoolEnemiesItem(Map.CurrScr())) show_screen_error("Enemies->Item, but no enemies",i++, vc(7));
		
		if(integrityBoolEnemiesSecret(Map.CurrScr())) show_screen_error("Enemies->Secret, but no enemies",i++, vc(7));
		
		if(integrityBoolStringNoGuy(Map.CurrScr())) show_screen_error("String, but Guy is (none)",i++, vc(14));
		
		if(integrityBoolGuyNoString(Map.CurrScr())) show_screen_error("Non-Fairy Guy, but String is (none)",i++, vc(14));
		
		if(integrityBoolRoomNoGuy(Map.CurrScr())) show_screen_error("Guy is (none)",i++, vc(14));
		
		if(integrityBoolRoomNoString(Map.CurrScr())) show_screen_error("String is (none)",i++, vc(14));
		
		if(integrityBoolRoomNoGuyNoString(Map.CurrScr())) show_screen_error("Guy and String are (none)",i++, vc(14));
	}
	
	if(!is_large)
	{
		if(draw_mode!=dm_normal)
		{
			textout_shadowed_right_ex(menu1,sfont,dm_names[draw_mode],mapscreen_x+((16+(showedges?1:0))*16*mapscreensize)-1,mapscreen_y+((showedges?1:0)*16*mapscreensize),vc(15),vc(0),-1);
		}
	}
	
	if((tooltip_timer>=tooltip_maxtimer)&&(tooltip_box.x>=0&&tooltip_box.y>=0))
	{
		auto& rec = tooltip_highlight;
		if(TooltipsHighlight && rec.x >= 0)
		{
			safe_rect(menu1, rec.x, rec.y, rec.x+rec.w-1, rec.y+rec.h-1, 0xED);
			safe_rect(menu1, rec.x+1, rec.y+1, rec.x+rec.w-2, rec.y+rec.h-2, 0xED);
		}
		masked_blit(tooltipbmp, menu1, 0, 0, tooltip_box.x, tooltip_box.y, tooltip_box.w, tooltip_box.h);
	}
	
//  textprintf_ex(menu1,font,16, 200,vc(15),-1,"%d %d %d %d %d",tooltip_timer,tooltip_box.x,tooltip_box.y,tooltip_box.w,tooltip_box.h);

	scare_mouse();
	
	if(flags&rCLEAR)
	{
		//Draw the whole gui
		blit(menu1,screen,0,0,0,0,zq_screen_w,zq_screen_h);
	}
	else
	{
		blit(menu1,screen,0,16,0,16,zq_screen_w,zq_screen_h-16);
		blit(menu1,screen,combolist_window.x-64,0,combolist_window.x-64,0,combolist_window.w+64,16);
		
		if(flags&rCOMBO)
		{
			blit(menu1,screen,combo_preview.x,combo_preview.y,combo_preview.x,combo_preview.y,combo_preview.w,combo_preview.h);
		}
	}
	
	//Draw the Main Menu
	jwin_menu_proc(MSG_START, &dialogs[0], 0);
	if(is_large)
	{
		rectfill(screen,mainbar.x,mainbar.y,mainbar.x+mainbar.w-1,mainbar.y+mainbar.h-1,jwin_pal[jcBOX]);
		jwin_draw_frame(screen,mainbar.x,mainbar.y,mainbar.w,mainbar.h,FR_WIN);
		
		FONT* oldfont = font;
		font = get_custom_font(CFONT_GUI);
		
		//Drawmode button
		draw_text_button(menu1,drawmode_btn.x,drawmode_btn.y,drawmode_btn.w,drawmode_btn.h,dm_names[draw_mode],vc(1),vc(14),0,true);
		//Compact button
		draw_text_button(menu1,compactbtn.x, compactbtn.y, compactbtn.w, compactbtn.h, is_compact ? "< Expand" : "> Compact", vc(1),vc(14),0,true);
		
		font = oldfont;
	}
	
	jwin_menu_proc(MSG_DRAW, &dialogs[0], 0);
	
	ComboBrushPause=0;
	
	unscare_mouse();
	SCRFIX();
	update_hw_screen();
}

void select_scr()
{
    if(Map.getCurrMap()>=Map.getMapCount())
        return;
        
    int32_t tempcb=ComboBrush;
    ComboBrush=0;
    
    //scooby
    while(gui_mouse_b())
    {
        /*
            int32_t x=gui_mouse_x();
            if(x>minimap.x+(minimap.w-6)*BMM)   x=minimap.x+3+(minimap.w-6)*BMM;
            if(x<minimap.x+3)   x=minimap.x+3;
            int32_t y=gui_mouse_y();
            if(y>minimap.y+9+3+(minimap.h-6)*BMM) y=minimap.y+9+3+(minimap.h-6)*BMM;
            if(y<minimap.y+9+3) y=minimap.y+9+3;
            int32_t s=(((y-(minimap.y+9+3))/(3*BMM))<<4)+((x-(minimap.x+3))/(3*BMM));
        */
        
        int32_t x=gui_mouse_x();
        int32_t y=gui_mouse_y();
        int32_t s=(vbound(((y-(minimap.y+9+3))/(3*BMM)),0,8)  <<4)+ vbound(((x-(minimap.x+3))/(3*BMM)),0,15);
        
        if(s>=MAPSCRS)
            s-=16;
            
        if(s!=Map.getCurrScr())
        {
            Map.setCurrScr(s);
            //      vsync();
            //      refresh(rALL);
        }
        
        do_animations();
        refresh(rALL);
    }
    
    ComboBrush=tempcb;
}

void clear_cpool()
{
	for(int32_t i=0; i<MAXFAVORITECOMBOS; ++i)
	{
		pool_combos[i].clear();
	}
	pool_dirty = true;
}

bool select_favorite()
{
	if(draw_mode == dm_cpool) return false;
    int32_t tempcb=ComboBrush;
    ComboBrush=0;
    bool valid=false;
    
    while(gui_mouse_b())
    {
        valid=false;
        int32_t x=gui_mouse_x();
        
        if(x<favorites_list.x) x=favorites_list.x;
        
        if(x>favorites_list.x+(favorites_list.w*16)-1) x=favorites_list.x+(favorites_list.w*16)-1;
        
        int32_t y=gui_mouse_y();
        
        if(y<favorites_list.y) y=favorites_list.y;
        
        if(y>favorites_list.y+(favorites_list.h*16)-1) y=favorites_list.y+(favorites_list.h*16)-1;
        
        int32_t tempc=(((y-favorites_list.y)>>4)*FAVORITECOMBO_PER_ROW)+((x-favorites_list.x)>>4);
        
		if(tempc >= ((draw_mode==dm_alias) ? MAXFAVORITECOMBOALIASES : MAXFAVORITECOMBOS))
		{
			//Nothing, invalid
		}
		else if(draw_mode==dm_alias)
        {
            if(favorite_comboaliases[tempc]!=-1)
            {
                combo_apos=favorite_comboaliases[tempc];
                valid=true;
            }
        }
        else
        {
			if(favorite_combos[tempc]!=-1)
            {
                Combo=favorite_combos[tempc];
                valid=true;
            }
        }
        
        do_animations();
        refresh(rALL);
    }
    
    ComboBrush=tempcb;
    return valid;
}

void select_combo(int32_t clist)
{
    current_combolist=clist;
    int32_t tempcb=ComboBrush;
    ComboBrush=0;
    
	auto& curlist = combolist[current_combolist];
    while(gui_mouse_b())
    {
        int32_t x=gui_mouse_x();
        
        if(x<curlist.x)
			x=curlist.x;
        
        if(x>curlist.x+(curlist.w*curlist.xscale)-1)
			x=curlist.x+(curlist.w*curlist.xscale)-1;
        
        int32_t y=gui_mouse_y();
        
        if(y<curlist.y)
			y=curlist.y;
        
        if(y>curlist.y+(curlist.h*curlist.yscale)-1)
			y=curlist.y+(curlist.h*curlist.yscale)-1;
        
        Combo=(((y-curlist.y)/curlist.yscale)*curlist.w)+((x-curlist.x)/curlist.xscale)+First[current_combolist];
        do_animations();
        refresh(rALL);
    }
    
    ComboBrush=tempcb;
}

void select_comboa(int32_t clist)
{
    current_comboalist=clist;
    int32_t tempcb=ComboBrush;
    ComboBrush=0;
    alias_cset_mod=0;
    
	auto& curlist = comboaliaslist[current_comboalist];
    while(gui_mouse_b())
    {
        int32_t x=gui_mouse_x();
        
        if(x<curlist.x)
			x=curlist.x;
        
        if(x>curlist.x+(curlist.w*curlist.xscale)-1)
			x=curlist.x+(curlist.w*curlist.xscale)-1;
        
        int32_t y=gui_mouse_y();
        
        if(y<curlist.y)
			y=curlist.y;
        
        if(y>curlist.y+(curlist.h*curlist.yscale)-1)
			y=curlist.y+(curlist.h*curlist.yscale)-1;
        
        combo_apos=(((y-curlist.y)/curlist.yscale)*curlist.w)+((x-curlist.x)/curlist.xscale)+combo_alistpos[current_comboalist];
        do_animations();
        refresh(rALL);
    }
    
    ComboBrush=tempcb;
}

void select_combop(int32_t clist)
{
    current_cpoollist=clist;
    int32_t tempcb=ComboBrush;
    ComboBrush=0;
    
	auto& curlist = comboaliaslist[current_cpoollist];
    while(gui_mouse_b())
    {
        int32_t x=gui_mouse_x();
        
        if(x<curlist.x) x=curlist.x;
        
        if(x>curlist.x+(curlist.w*curlist.xscale)-1)
			x=curlist.x+(curlist.w*curlist.xscale)-1;
        
        int32_t y=gui_mouse_y();
        
        if(y<curlist.y) y=curlist.y;
        
        if(y>curlist.y+(curlist.h*curlist.yscale)-1)
			y=curlist.y+(curlist.h*curlist.yscale)-1;
        
        combo_pool_pos=(((y-curlist.y)/curlist.yscale)*curlist.w)+((x-curlist.x)/curlist.xscale)+combo_pool_listpos[current_cpoollist];
        do_animations();
        refresh(rALL);
    }
    
    ComboBrush=tempcb;
}

void update_combobrush()
{
    clear_bitmap(brushbmp);
    
    if(draw_mode==dm_alias)
    {
        //int32_t count=(combo_aliases[combo_apos].width+1)*(combo_aliases[combo_apos].height+1)*(comboa_lmasktotal(combo_aliases[combo_apos].layermask));
        for(int32_t z=0; z<=comboa_lmasktotal(combo_aliases[combo_apos].layermask); z++)
        {
            for(int32_t y=0; y<=combo_aliases[combo_apos].height; y++)
            {
                for(int32_t x=0; x<=combo_aliases[combo_apos].width; x++)
                {
                    int32_t position = ((y*(combo_aliases[combo_apos].width+1))+x)+((combo_aliases[combo_apos].width+1)*(combo_aliases[combo_apos].height+1)*z);
                    
                    if(combo_aliases[combo_apos].combos[position])
                    {
                        if(z==0)
                        {
                            putcombo(brushbmp,x<<4,y<<4,combo_aliases[combo_apos].combos[position],wrap(combo_aliases[combo_apos].csets[position]+alias_cset_mod, 0, 11));
                        }
                        else
                        {
                            overcombo(brushbmp,x<<4,y<<4,combo_aliases[combo_apos].combos[position],wrap(combo_aliases[combo_apos].csets[position]+alias_cset_mod, 0, 11));
                        }
                    }
                }
            }
        }
        
        switch(alias_origin)
        {
        case 0:
            //if(!(combo_aliases[combo_apos].combos[0]))
            textprintf_shadowed_ex(brushbmp, sfont, 6, 6, vc(15), vc(0), -1, "x");
            break;
            
        case 1:
            //if(!(combo_aliases[combo_apos].combos[combo_aliases[combo_apos].width]))
            textprintf_shadowed_ex(brushbmp, sfont, 6+(combo_aliases[combo_apos].width*16), 6, vc(15), vc(0), -1, "x");
            break;
            
        case 2:
            //if(!(combo_aliases[combo_apos].combos[(combo_aliases[combo_apos].width+1)*combo_aliases[combo_apos].height]))
            textprintf_shadowed_ex(brushbmp, sfont, 6, 6+(combo_aliases[combo_apos].height*16), vc(15), vc(0), -1, "x");
            break;
            
        case 3:
            //if(!(combo_aliases[combo_apos].combos[(combo_aliases[combo_apos].width+1)*(combo_aliases[combo_apos].height)-1]))
            textprintf_shadowed_ex(brushbmp, sfont, 6+(combo_aliases[combo_apos].width*16), 6+(combo_aliases[combo_apos].height*16), vc(15), vc(0), -1, "x");
            break;
        }
    }
    else if(draw_mode != dm_cpool)
    {
        if(combo_cols==false)
        {
            for(int32_t i=0; i<256; i++)
            {
				if(unsigned(Combo+i) >= MAXCOMBOS) break;
                if(((i%COMBOS_PER_ROW)<BrushWidth)&&((i/COMBOS_PER_ROW)<BrushHeight))
                {
                    put_combo(brushbmp,(i%COMBOS_PER_ROW)<<4,(i/COMBOS_PER_ROW)<<4,Combo+i,CSet,Flags&(cFLAGS|cWALK),0);
                }
            }
        }
        else
        {
            int32_t c = 0;
            
            for(int32_t i=0; i<256; i++)
            {
				if(unsigned(Combo+c) >= MAXCOMBOS) break;
                if(((i%COMBOS_PER_ROW)<BrushWidth)&&((i/COMBOS_PER_ROW)<BrushHeight))
                {
                    put_combo(brushbmp,(i%COMBOS_PER_ROW)<<4,(i/COMBOS_PER_ROW)<<4,Combo+c,CSet,Flags&(cFLAGS|cWALK),0);
                }
                
                if(((Combo+c)&3)==3)
                    c+=48;
				
                ++c;
                    
                if((i%COMBOS_PER_ROW)==(COMBOS_PER_ROW-1))
                    c-=256;
            }
        }
    }
}

byte relational_source_grid[256]=
{
    0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
    16, 16, 17, 17, 18, 18, 19, 19, 16, 16, 17, 17, 18, 18, 19, 19,
    20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23,
    24, 24, 24, 24, 25, 25, 25, 25, 24, 24, 24, 24, 25, 25, 25, 25,
    26, 27, 26, 27, 26, 27, 26, 27, 28, 29, 28, 29, 28, 29, 28, 29,
    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
    31, 31, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 32, 32,
    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
    34, 35, 36, 37, 34, 35, 36, 37, 34, 35, 36, 37, 34, 35, 36, 37,
    38, 38, 39, 39, 38, 38, 39, 39, 38, 38, 39, 39, 38, 38, 39, 39,
    40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
    41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
    42, 43, 42, 43, 42, 43, 42, 43, 42, 43, 42, 43, 42, 43, 42, 43,
    44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
    45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
    46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46
};


void draw(bool justcset)
{
	combo_pool const& pool = combo_pools[combo_pool_pos];
	if(draw_mode == dm_cpool && !pool.valid())
		return;
    saved=false;
    int32_t drawmap, drawscr;
    
    if(CurrentLayer==0)
    {
        drawmap=Map.getCurrMap();
        drawscr=Map.getCurrScr();
    }
    else
    {
        drawmap=Map.CurrScr()->layermap[CurrentLayer-1]-1;
        drawscr=Map.CurrScr()->layerscreen[CurrentLayer-1];
        
        if(drawmap<0)
        {
            return;
        }
    }
    
    if(!(Map.AbsoluteScr(drawmap, drawscr)->valid&mVALID))
    {
        Map.CurrScr()->valid|=mVALID;
        Map.AbsoluteScr(drawmap, drawscr)->valid|=mVALID;
        Map.setcolor(Color);
    }
    
    refresh(rMAP+rSCRMAP);
	int32_t lastpos = -1;
	
    Map.StartListCommand();
    while(gui_mouse_b())
    {
        int32_t x=gui_mouse_x();
        int32_t y=gui_mouse_y();
        double startx=mapscreen_x+(showedges?(16*mapscreensize):0);
        double starty=mapscreen_y+(showedges?(16*mapscreensize):0);
        int32_t startxint=mapscreen_x+(showedges?int32_t(16*mapscreensize):0);
        int32_t startyint=mapscreen_y+(showedges?int32_t(16*mapscreensize):0);
        
        if(isinRect(x,y,startxint,startyint,int32_t(startx+(256*mapscreensize)-1),int32_t(starty+(176*mapscreensize)-1)))
        {
            int32_t cxstart=(x-startxint)/int32_t(16*mapscreensize);
            int32_t cystart=(y-startyint)/int32_t(16*mapscreensize);
            int32_t cstart=(cystart*16)+cxstart;
			if(cstart == lastpos)
			{
				do_animations();
				refresh(rALL);
				continue;
			}
			lastpos = cstart;
            combo_alias *combo = &combo_aliases[combo_apos];
            
            switch(draw_mode)
            {
				case dm_normal:
				{
					int32_t cc=Combo;
					
					if(!combo_cols)
					{
						bool change_combo = !(key[KEY_LSHIFT]||key[KEY_RSHIFT]) && !justcset;
						for(int32_t cy=0; cy+cystart<11&&cy<BrushHeight; cy++)
						{
							for(int32_t cx=0; cx+cxstart<16&&cx<BrushWidth; cx++)
							{
								int32_t c=cstart+(cy*16)+cx;
								Map.DoSetComboCommand(drawmap, drawscr, c, change_combo ? -1 : (cc + cx), CSet);
							}
							
							cc+=20;
						}
					}
					else
					{
						int32_t p=Combo/256;
						int32_t pc=Combo%256;
						
						for(int32_t cy=0; cy+cystart<11&&cy<BrushHeight; cy++)
						{
							for(int32_t cx=0; cx+cxstart<16&&cx<BrushWidth; cx++)
							{
								int32_t c=cstart+(cy*16)+cx;
								cc=((cx/4)*52)+(cy*4)+(cx%4)+pc;
								
								if(cc>=0&&cc<256)
								{
									cc+=(p*256);
									Map.DoSetComboCommand(drawmap, drawscr, c, justcset ? -1 : cc, CSet);
								}
							}
						}
					}
					
					update_combobrush();
				}
				break;
				case dm_cpool:
				{
					int32_t cid = Combo;
                    int8_t cs = CSet;
					pool.pick(cid,cs);
					
					if(!combo_cols)
					{
						bool change_combo = !(key[KEY_LSHIFT]||key[KEY_RSHIFT]) && !justcset;
						for(int32_t cy=0; cy+cystart<11&&cy<BrushHeight; cy++)
						{
							for(int32_t cx=0; cx+cxstart<16&&cx<BrushWidth; cx++)
							{
								int32_t c=cstart+(cy*16)+cx;
								Map.DoSetComboCommand(drawmap, drawscr, c, change_combo ? -1 : (cid + cx), cs);
							}
							
							cid+=20;
						}
					}
					else
					{
						int32_t p=cid/256;
						int32_t pc=cid%256;
						
						for(int32_t cy=0; cy+cystart<11&&cy<BrushHeight; cy++)
						{
							for(int32_t cx=0; cx+cxstart<16&&cx<BrushWidth; cx++)
							{
								int32_t c=cstart+(cy*16)+cx;
								cid=((cx/4)*52)+(cy*4)+(cx%4)+pc;
								
								if(cid>=0&&cid<256)
								{
									cid+=(p*256);
									Map.DoSetComboCommand(drawmap, drawscr, c, justcset ? -1 : cid, cs);
								}
							}
						}
					}
					
					update_combobrush();
				}
				break;
				
				case dm_relational:
				{
					int32_t c2,c3;
					int32_t cx, cy, cx2, cy2;
					cy=cstart>>4;
					cx=cstart&15;
					
					if(key[KEY_LSHIFT]||key[KEY_RSHIFT])
					{
						relational_tile_grid[(cy+rtgyo)][cx+rtgxo]=1;
						Map.DoSetComboCommand(drawmap, drawscr, cstart, Combo+47, CSet);
					}
					else
					{
						relational_tile_grid[(cy+rtgyo)][cx+rtgxo]=0;
					}
					
					for(int32_t y2=-1; y2<2; ++y2)
					{
						cy2=cy+y2;
						
						if((cy2>11)||(cy2<0))
						{
							continue;
						}
						
						for(int32_t x2=-1; x2<2; ++x2)
						{
							cx2=cx+x2;
							
							if((cx2>15)||(cx2<0))
							{
								continue;
							}
							
							c2=cstart+(y2*16)+x2;
							c3=((relational_tile_grid[((cy2-1)+rtgyo)][(cx2+1)+rtgxo]?1:0)<<0)+
							   ((relational_tile_grid[((cy2-1)+rtgyo)][(cx2-1)+rtgxo]?1:0)<<1)+
							   ((relational_tile_grid[((cy2+1)+rtgyo)][(cx2-1)+rtgxo]?1:0)<<2)+
							   ((relational_tile_grid[((cy2+1)+rtgyo)][(cx2+1)+rtgxo]?1:0)<<3)+
							   ((relational_tile_grid[((cy2)+rtgyo)][(cx2+1)+rtgxo]?1:0)<<4)+
							   ((relational_tile_grid[((cy2-1)+rtgyo)][(cx2)+rtgxo]?1:0)<<5)+
							   ((relational_tile_grid[((cy2)+rtgyo)][(cx2-1)+rtgxo]?1:0)<<6)+
							   ((relational_tile_grid[((cy2+1)+rtgyo)][(cx2)+rtgxo]?1:0)<<7);
							   
							if(relational_tile_grid[((c2>>4)+rtgyo)][(c2&15)+rtgxo]==0)
							{
								Map.DoSetComboCommand(drawmap, drawscr, c2, Combo+relational_source_grid[c3], CSet);
							}
						}
					}
				}
				break;
				
				case dm_dungeon:
				{
					int32_t c2,c3,c4;
					int32_t cx, cy, cx2, cy2;
					cy=cstart>>4;
					cx=cstart&15;
					
					if(key[KEY_LSHIFT]||key[KEY_RSHIFT])
					{
						relational_tile_grid[(cy+rtgyo)][cx+rtgxo]=0;
						
						for(int32_t y2=-1; y2<2; ++y2)
						{
							cy2=cy+y2;
							
							if((cy2>11)||(cy2<0))
							{
								continue;
							}
							
							for(int32_t x2=-1; x2<2; ++x2)
							{
								cx2=cx+x2;
								
								if((cx2>15)||(cx2<0))
								{
									continue;
								}
								
								if(relational_tile_grid[(cy2+rtgyo)][cx2+rtgxo]!=0)
								{
									relational_tile_grid[(cy2+rtgyo)][cx2+rtgxo]=1;
								};
							}
						}
						
						Map.DoSetComboCommand(drawmap, drawscr, cstart, Combo, CSet);
					}
					else
					{
						relational_tile_grid[(cy+rtgyo)][cx+rtgxo]=2;
						
						for(int32_t y2=-1; y2<2; ++y2)
						{
							cy2=cy+y2;
							
							if((cy2>11)||(cy2<0))
							{
								continue;
							}
							
							for(int32_t x2=-1; x2<2; ++x2)
							{
								cx2=cx+x2;
								
								if((cx2>15)||(cx2<0))
								{
									continue;
								}
								
								if(relational_tile_grid[(cy2+rtgyo)][cx2+rtgxo]==0)
								{
									relational_tile_grid[(cy2+rtgyo)][cx2+rtgxo]=1;
								};
							}
						}
						
						Map.DoSetComboCommand(drawmap, drawscr, cstart, Combo+48+47, CSet);
					}
					
					for(int32_t y2=0; y2<11; ++y2)
					{
						for(int32_t x2=0; x2<16; ++x2)
						{
							c2=(y2*16)+x2;
							c4=relational_tile_grid[((y2)+rtgyo)][(x2)+rtgxo];
							c3=(((relational_tile_grid[((y2-1)+rtgyo)][(x2+1)+rtgxo]>c4)?1:0)<<0)+
							   (((relational_tile_grid[((y2-1)+rtgyo)][(x2-1)+rtgxo]>c4)?1:0)<<1)+
							   (((relational_tile_grid[((y2+1)+rtgyo)][(x2-1)+rtgxo]>c4)?1:0)<<2)+
							   (((relational_tile_grid[((y2+1)+rtgyo)][(x2+1)+rtgxo]>c4)?1:0)<<3)+
							   (((relational_tile_grid[((y2)+rtgyo)][(x2+1)+rtgxo]>c4)?1:0)<<4)+
							   (((relational_tile_grid[((y2-1)+rtgyo)][(x2)+rtgxo]>c4)?1:0)<<5)+
							   (((relational_tile_grid[((y2)+rtgyo)][(x2-1)+rtgxo]>c4)?1:0)<<6)+
							   (((relational_tile_grid[((y2+1)+rtgyo)][(x2)+rtgxo]>c4)?1:0)<<7);
							   
							if(relational_tile_grid[(y2+rtgyo)][x2+rtgxo]<2)
							{
								Map.DoSetComboCommand(drawmap, drawscr, c2, Combo+relational_source_grid[c3]+(48*c4), CSet);
							}
						}
					}
				}
				break;
				
				case dm_alias:
					if(!combo->layermask)
					{
						int32_t ox=0, oy=0;
						
						switch(alias_origin)
						{
						case 0:
							ox=0;
							oy=0;
							break;
							
						case 1:
							ox=(combo->width);
							oy=0;
							break;
							
						case 2:
							ox=0;
							oy=(combo->height);
							break;
							
						case 3:
							ox=(combo->width);
							oy=(combo->height);
							break;
						}
						
						for(int32_t cy=0; cy-oy+cystart<11&&cy<=combo->height; cy++)
						{
							for(int32_t cx=0; cx-ox+cxstart<16&&cx<=combo->width; cx++)
							{
								if((cx+cxstart-ox>=0)&&(cy+cystart-oy>=0))
								{
									int32_t c=cstart+((cy-oy)*16)+cx-ox;
									int32_t p=(cy*(combo->width+1))+cx;
									
									if(combo->combos[p])
									{
										Map.DoSetComboCommand(drawmap, drawscr, c, combo->combos[p], wrap(combo->csets[p]+alias_cset_mod, 0, 11));
									}
								}
							}
						}
					}
					else
					{
						int32_t amap=0, ascr=0;
						int32_t lcheck = 1;
						int32_t laypos = 0;
						int32_t ox=0, oy=0;
						
						switch(alias_origin)
						{
						case 0:
							ox=0;
							oy=0;
							break;
							
						case 1:
							ox=(combo->width);
							oy=0;
							break;
							
						case 2:
							ox=0;
							oy=(combo->height);
							break;
							
						case 3:
							ox=(combo->width);
							oy=(combo->height);
							break;
						}
						
						for(int32_t cz=0; cz<7; cz++, lcheck<<=1)
						{
							if(!cz)
							{
								amap = Map.getCurrMap();
								ascr = Map.getCurrScr();
							}
							else
							{
								if(cz==1) lcheck>>=1;
								
								if(combo->layermask&lcheck)
								{
									amap = Map.CurrScr()->layermap[cz-1]-1;
									ascr = Map.CurrScr()->layerscreen[cz-1];
									laypos++;
								}
							}
							
							for(int32_t cy=0; cy-oy+cystart<11&&cy<=combo->height; cy++)
							{
								for(int32_t cx=0; cx-ox+cxstart<16&&cx<=combo->width; cx++)
								{
									if((!cz)||/*(Map.CurrScr()->layermap[cz>0?cz-1:0])*/amap>=0)
									{
										if((cz==0)||(combo->layermask&lcheck))
										{
											if((cx+cxstart-ox>=0)&&(cy+cystart-oy>=0))
											{
												int32_t c=cstart+((cy-oy)*16)+cx-ox;
												int32_t p=((cy*(combo->width+1))+cx)+((combo->width+1)*(combo->height+1)*laypos);
												
												if((combo->combos[p])&&(amap>=0))
												{
													Map.DoSetComboCommand(amap, ascr, c, combo->combos[p], wrap(combo->csets[p]+alias_cset_mod, 0, 11));
												}
											}
										}
									}
								}
							}
						}
					}
					
					break;
            }
        }
        
#ifdef __EMSCRIPTEN__
		// TODO: fix this!
		// For some reason this loop (even if a rest(1) is added) prevents the
		// mouse thread from consuming events (or maybe it prevents SDL on the main
		// thread from creating mouse events?). Breaking after a single iteration prevents
		// this from locking up.
		// This drawing code functions similarly like this, except click-and-drag
		// will create multiple separate single edits in the undo history, rather than
		// combining all of them.
		break;
#else
		do_animations();
		refresh(rALL);
#endif
    }

    Map.FinishListCommand();
}

void replace(int32_t c)
{
	int32_t cid = Combo;
    int8_t cs = CSet;
	combo_pool const& pool = combo_pools[combo_pool_pos];
	if(draw_mode == dm_cpool && !pool.valid())
		return;
	
    saved=false;
    int32_t drawmap, drawscr;
    
    if(CurrentLayer==0)
    {
        drawmap=Map.getCurrMap();
        drawscr=Map.getCurrScr();
    }
    else
    {
        drawmap=Map.CurrScr()->layermap[CurrentLayer-1]-1;
        drawscr=Map.CurrScr()->layerscreen[CurrentLayer-1];
        
        if(drawmap<0)
        {
            return;
        }
    }
    
    int32_t targetcombo = Map.AbsoluteScr(drawmap, drawscr)->data[c];
    int32_t targetcset  = Map.AbsoluteScr(drawmap, drawscr)->cset[c];
    
    Map.StartListCommand();
    if(key[KEY_LSHIFT] || key[KEY_RSHIFT])
    {
        for(int32_t i=0; i<176; i++)
        {
            if((Map.AbsoluteScr(drawmap, drawscr)->cset[i])==targetcset)
            {
				if(draw_mode == dm_cpool)
					pool.pick(cid,cs);
                Map.DoSetComboCommand(drawmap, drawscr, i, -1, cs);
            }
        }
    }
    else
    {
        for(int32_t i=0; i<176; i++)
        {
            if(((Map.AbsoluteScr(drawmap, drawscr)->data[i])==targetcombo) &&
                    ((Map.AbsoluteScr(drawmap, drawscr)->cset[i])==targetcset))
            {
				if(draw_mode == dm_cpool)
					pool.pick(cid,cs);
                Map.DoSetComboCommand(drawmap, drawscr, i, cid, cs);
            }
        }
    }
    Map.FinishListCommand();
    
    refresh(rMAP);
}

void draw_block(int32_t start,int32_t w,int32_t h)
{
	int32_t cid = Combo;
    int8_t cs = CSet;
	if(draw_mode == dm_cpool)
	{
		combo_pool const& pool = combo_pools[combo_pool_pos];
		if(!pool.pick(cid,cs)) return;
	}
    saved=false;
    int32_t drawmap, drawscr;
    
    if(CurrentLayer==0)
    {
        drawmap=Map.getCurrMap();
        drawscr=Map.getCurrScr();
    }
    else
    {
        drawmap=Map.CurrScr()->layermap[CurrentLayer-1]-1;
        drawscr=Map.CurrScr()->layerscreen[CurrentLayer-1];
        
        if(drawmap<0)
        {
            return;
        }
    }
    
    if(!(Map.AbsoluteScr(drawmap, drawscr)->valid&mVALID))
    {
        Map.CurrScr()->valid|=mVALID;
        Map.AbsoluteScr(drawmap, drawscr)->valid|=mVALID;
        Map.setcolor(Color);
    }
    
    Map.StartListCommand();
    for(int32_t y=0; y<h && (y<<4)+start < 176; y++)
        for(int32_t x=0; x<w && (start&15)+x < 16; x++)
        {
            Map.DoSetComboCommand(drawmap, drawscr, start+(y<<4)+x, cid+(y*4)+x, cs);
        }
    
    Map.FinishListCommand();
    refresh(rMAP+rSCRMAP);
}

static void fill(int32_t map, int32_t screen_index, mapscr* fillscr, int32_t targetcombo, int32_t targetcset, int32_t sx, int32_t sy, int32_t dir, int32_t diagonal, bool only_cset)
{
    if(!only_cset)
    {
        if((fillscr->data[((sy<<4)+sx)])!=targetcombo)
            return;
    }
    
    if((fillscr->cset[((sy<<4)+sx)])!=targetcset)
        return;
    
	int32_t cid = Combo;
    int8_t cs = CSet;
	if(draw_mode == dm_cpool)
	{
		combo_pool const& pool = combo_pools[combo_pool_pos];
		if(!pool.pick(cid,cs)) return;
	}
    
    Map.DoSetComboCommand(map, screen_index, (sy<<4)+sx, only_cset ? -1 : cid, cs);
    
    if((sy>0) && (dir!=down))                                 // && ((Map.CurrScr()->data[(((sy-1)<<4)+sx)]&0x7FF)==target))
        fill(map, screen_index, fillscr, targetcombo, targetcset, sx, sy-1, up, diagonal, only_cset);
        
    if((sy<10) && (dir!=up))                                  // && ((Map.CurrScr()->data[(((sy+1)<<4)+sx)]&0x7FF)==target))
        fill(map, screen_index, fillscr, targetcombo, targetcset, sx, sy+1, down, diagonal, only_cset);
        
    if((sx>0) && (dir!=right))                                // && ((Map.CurrScr()->data[((sy<<4)+sx-1)]&0x7FF)==target))
        fill(map, screen_index, fillscr, targetcombo, targetcset, sx-1, sy, left, diagonal, only_cset);
        
    if((sx<15) && (dir!=left))                                // && ((Map.CurrScr()->data[((sy<<4)+sx+1)]&0x7FF)==target))
        fill(map, screen_index, fillscr, targetcombo, targetcset, sx+1, sy, right, diagonal, only_cset);
        
    if(diagonal==1)
    {
        if((sy>0) && (sx>0) && (dir!=r_down))                   // && ((Map.CurrScr()->data[(((sy-1)<<4)+sx-1)]&0x7FF)==target))
            fill(map, screen_index, fillscr, targetcombo, targetcset, sx-1, sy-1, l_up, diagonal, only_cset);
            
        if((sy<10) && (sx<15) && (dir!=l_up))                   // && ((Map.CurrScr()->data[(((sy+1)<<4)+sx+1)]&0x7FF)==target))
            fill(map, screen_index, fillscr, targetcombo, targetcset, sx+1, sy+1, r_down, diagonal, only_cset);
            
        if((sx>0) && (sy<10) && (dir!=r_up))                    // && ((Map.CurrScr()->data[(((sy+1)<<4)+sx-1)]&0x7FF)==target))
            fill(map, screen_index, fillscr, targetcombo, targetcset, sx-1, sy+1, l_down, diagonal, only_cset);
            
        if((sx<15) && (sy>0) && (dir!=l_down))                  // && ((Map.CurrScr()->data[(((sy-1)<<4)+sx+1)]&0x7FF)==target))
            fill(map, screen_index, fillscr, targetcombo, targetcset, sx+1, sy-1, r_up, diagonal, only_cset);
    }
}

static void fill_flag(int32_t map, int32_t screen_index, mapscr* fillscr, int32_t targetflag, int32_t sx, int32_t sy, int32_t dir, int32_t diagonal)
{
	if((fillscr->sflag[((sy<<4)+sx)])!=targetflag)
		return;
	
    Map.DoSetFlagCommand(map, screen_index, (sy<<4)+sx, Flag);
	
	if((sy>0) && (dir!=down))
		fill_flag(map, screen_index, fillscr, targetflag, sx, sy-1, up, diagonal);
		
	if((sy<10) && (dir!=up))
		fill_flag(map, screen_index, fillscr, targetflag, sx, sy+1, down, diagonal);
		
	if((sx>0) && (dir!=right))
		fill_flag(map, screen_index, fillscr, targetflag, sx-1, sy, left, diagonal);
		
	if((sx<15) && (dir!=left))
		fill_flag(map, screen_index, fillscr, targetflag, sx+1, sy, right, diagonal);
		
	if(diagonal==1)
	{
		if((sy>0) && (sx>0) && (dir!=r_down))
			fill_flag(map, screen_index, fillscr, targetflag, sx-1, sy-1, l_up, diagonal);
			
		if((sy<10) && (sx<15) && (dir!=l_up))
			fill_flag(map, screen_index, fillscr, targetflag, sx+1, sy+1, r_down, diagonal);
			
		if((sx>0) && (sy<10) && (dir!=r_up))
			fill_flag(map, screen_index, fillscr, targetflag, sx-1, sy+1, l_down, diagonal);
			
		if((sx<15) && (sy>0) && (dir!=l_down))
			fill_flag(map, screen_index, fillscr, targetflag, sx+1, sy-1, r_up, diagonal);
	}
	
}

static void fill2(mapscr* fillscr, int32_t targetcombo, int32_t targetcset, int32_t sx, int32_t sy, int32_t dir, int32_t diagonal, bool only_cset)
{
    if(!only_cset)
    {
        if((fillscr->data[((sy<<4)+sx)])==targetcombo)
            return;
    }
    
    if((fillscr->cset[((sy<<4)+sx)])==targetcset)
        return;
    
	int32_t cid = Combo;
    int8_t cs = CSet;
	if(draw_mode == dm_cpool)
	{
		combo_pool const& pool = combo_pools[combo_pool_pos];
		if(!pool.pick(cid,cs)) return;
	}
	
    Map.DoSetComboCommand(Map.getCurrMap(), Map.getCurrScr(), (sy<<4)+sx, only_cset ? -1 : cid, cs);
    
    if((sy>0) && (dir!=down))                                 // && ((Map.CurrScr()->data[(((sy-1)<<4)+sx)]&0x7FF)!=target))
        fill2(fillscr, targetcombo, targetcset, sx, sy-1, up, diagonal, only_cset);
        
    if((sy<10) && (dir!=up))                                  // && ((Map.CurrScr()->data[(((sy+1)<<4)+sx)]&0x7FF)!=target))
        fill2(fillscr, targetcombo, targetcset, sx, sy+1, down, diagonal, only_cset);
        
    if((sx>0) && (dir!=right))                                // && ((Map.CurrScr()->data[((sy<<4)+sx-1)]&0x7FF)!=target))
        fill2(fillscr, targetcombo, targetcset, sx-1, sy, left, diagonal, only_cset);
        
    if((sx<15) && (dir!=left))                                // && ((Map.CurrScr()->data[((sy<<4)+sx+1)]&0x7FF)!=target))
        fill2(fillscr, targetcombo, targetcset, sx+1, sy, right, diagonal, only_cset);
        
    if(diagonal==1)
    {
        if((sy>0) && (sx>0) && (dir!=r_down))                   // && ((Map.CurrScr()->data[(((sy-1)<<4)+sx-1)]&0x7FF)!=target))
            fill2(fillscr, targetcombo, targetcset, sx-1, sy-1, l_up, diagonal, only_cset);
            
        if((sy<10) && (sx<15) && (dir!=l_up))                   // && ((Map.CurrScr()->data[(((sy+1)<<4)+sx+1)]&0x7FF)!=target))
            fill2(fillscr, targetcombo, targetcset, sx+1, sy+1, r_down, diagonal, only_cset);
            
        if((sx>0) && (sy<10) && (dir!=r_up))                    // && ((Map.CurrScr()->data[(((sy+1)<<4)+sx-1)]&0x7FF)!=target))
            fill2(fillscr, targetcombo, targetcset, sx-1, sy+1, l_down, diagonal, only_cset);
            
        if((sx<15) && (sy>0) && (dir!=l_down))                  // && ((Map.CurrScr()->data[(((sy-1)<<4)+sx+1)]&0x7FF)!=target))
            fill2(fillscr, targetcombo, targetcset, sx+1, sy-1, r_up, diagonal, only_cset);
    }
}


/**************************/
/*****     Mouse      *****/
/**************************/

void doxypos(byte &px2,byte &py2,int32_t color,int32_t mask)
{
    doxypos(px2,py2,color,mask,false,0,0,16,16);
}

void doxypos(byte &px2,byte &py2,int32_t color,int32_t mask, bool immediately, int32_t cursoroffx, int32_t cursoroffy, int32_t iconw, int32_t iconh)
{
    int32_t tempcb=ComboBrush;
    ComboBrush=0;
    scare_mouse();
    set_mouse_sprite(mouse_bmp[MOUSE_BMP_POINT_BOX][0]);
    unscare_mouse();
    
    int32_t oldpx=px2, oldpy=py2;
    double startx=mapscreen_x+(showedges?(16*mapscreensize):0);
    double starty=mapscreen_y+(showedges?(16*mapscreensize):0);
    int32_t startxint=mapscreen_x+(showedges?int32_t(16*mapscreensize):0);
    int32_t startyint=mapscreen_y+(showedges?int32_t(16*mapscreensize):0);
    showxypos_x=px2;
    showxypos_y=py2;
    showxypos_w=iconw;
    showxypos_h=iconh;
    showxypos_color=vc(color);
    showxypos_icon=!showxypos_dummy;
    bool canedit=false;
    bool done=false;
    
    while(!done && (!(gui_mouse_b()&2) || immediately))
    {
        int32_t x=gui_mouse_x();
        int32_t y=gui_mouse_y();
        
        if(!gui_mouse_b() || immediately)
        {
            canedit=true;
        }
        
        if(canedit && gui_mouse_b()==1 && isinRect(x,y,startxint,startyint,int32_t(startx+(256*mapscreensize)-1),int32_t(starty+(176*mapscreensize)-1)))
        {
            scare_mouse();
            set_mouse_range(startxint,startyint,int32_t(startxint+(256*mapscreensize)-1),int32_t(startyint+(176*mapscreensize)-1));
            
            while(gui_mouse_b()==1)
            {
                x=int32_t((gui_mouse_x()-(showedges?int32_t(16*mapscreensize):0))/mapscreensize)-cursoroffx;
                y=int32_t((gui_mouse_y()-16-(showedges?int32_t(16*mapscreensize):0))/mapscreensize)-cursoroffy;
                showxypos_cursor_icon=true;
				showxypos_cursor_color = showxypos_color;
                showxypos_cursor_x=x&mask;
                showxypos_cursor_y=y&mask;
                do_animations();
                refresh(rALL | rNOCURSOR);
                int32_t xpos[2], ypos[2];
				int32_t x1,y1,x2,y2;
                
				char b1[200] = {0};
				char b2[200] = {0};
				if(showxypos_dummy)
					strcpy(b1, "DUMMY MEASURING");
				else sprintf(b1, "%d %d",oldpx,oldpy);
				sprintf(b2, "%d %d (%d %d)",x,y,showxypos_cursor_x,showxypos_cursor_y);
				
				int len[2] = {text_length(font,b1),text_length(font,b2)};
				
                if(is_compact)
				{
					xpos[0] = 4;
					ypos[0] = layer_panel.y - 21;
					xpos[1] = xpos[0];
					ypos[1] = ypos[0]+10;
				}
				else if(is_large)
                {
                    xpos[0] = 450;
                    ypos[0] = 405;
					xpos[1] = xpos[0];
					ypos[1] = ypos[0]+10;
                }
                else
                {
                    xpos[0] = 700;
                    ypos[0] = 500;
					xpos[1] = xpos[0];
					ypos[1] = ypos[0]+10;
                }
				
				x1 = xpos[0];
				y1 = ypos[0];
				x2 = xpos[0];
				y2 = ypos[0];
				for(auto q = 0; q < 2; ++q)
				{
					if(xpos[q] < x1)
						x1 = xpos[q];
					if(ypos[q] < y1)
						y1 = ypos[q];
					if(ypos[q] > y2)
						y2 = ypos[q];
					if(xpos[q] + len[q] > x2)
						x2 = xpos[q] + len[q];
				}
				x1 -= 4;
				y1 -= 2;
				y2 += text_height(font)+2;
				
				auto minx = zc_min(xpos[0],xpos[1]);
				auto miny = zc_min(ypos[0],ypos[1]);
				rectfill(screen,x1,y1,x2,y2,vc(0));
                textprintf_ex(screen,font,xpos[0],ypos[0],vc(15),vc(0),"%s",b1);
                textprintf_ex(screen,font,xpos[1],ypos[1],vc(15),vc(0),"%s",b2);
            }
            
            if(gui_mouse_b()==0)
            {
                px2=byte(vbound(x,0,255)&mask);
                py2=byte(vbound(y,0,255)&mask);
            }
            
            set_mouse_range(0,0,zq_screen_w-1,zq_screen_h-1);
            unscare_mouse();
            done=true;
        }
        
        if(keypressed())
        {
            switch(readkey()>>8)
            {
            case KEY_ESC:
            case KEY_ENTER:
                goto finished;
            }
        }
        
        do_animations();
        refresh(rALL | rNOCURSOR);
    }
    
finished:
    set_mouse_sprite(mouse_bmp[MOUSE_BMP_NORMAL][0]);
    refresh(rMAP+rMENU);
    
    while(gui_mouse_b())
    {
        /* do nothing */
        rest(1);
    }
    
    showxypos_x=-1000;
    showxypos_y=-1000;
    showxypos_color=-1000;
    showxypos_ffc=-1000;
    showxypos_icon=false;
    showxypos_cursor_x=-1000;
    showxypos_cursor_y=-1000;
    showxypos_cursor_icon=false;
	showxypos_cursor_color=-1000;
	showxypos_dummy=false;
    
    if(px2!=oldpx||py2!=oldpy)
    {
        saved=false;
    }
    
    ComboBrush=tempcb;
}

void doflags()
{
	set_mouse_sprite(mouse_bmp[MOUSE_BMP_FLAG][0]);
	int32_t of=Flags;
	Flags=cFLAGS;
	refresh(rMAP | rNOCURSOR);
	
	bool canedit=false;
	bool didShift = false;
	int32_t tFlag = Flag;
	while(!(gui_mouse_b()&2))
	{
		int32_t x=gui_mouse_x();
		int32_t y=gui_mouse_y();
		double startx=mapscreen_x+(showedges?(16*mapscreensize):0);
		double starty=mapscreen_y+(showedges?(16*mapscreensize):0);
		int32_t startxint=mapscreen_x+(showedges?int32_t(16*mapscreensize):0);
		int32_t startyint=mapscreen_y+(showedges?int32_t(16*mapscreensize):0);
		int32_t cx=(x-startxint)/int32_t(16*mapscreensize);
		int32_t cy=(y-startyint)/int32_t(16*mapscreensize);
		int32_t c=(cy*16)+cx;
		
		if(!gui_mouse_b())
			canedit=true;
        bool shift = key[KEY_LSHIFT] || key[KEY_RSHIFT];
		if(didShift != shift)
		{
			didShift = shift;
			if(shift)
			{
				setFlagColor(0);
				set_mouse_sprite(mouse_bmp[MOUSE_BMP_FLAG][0]);
			}
			else
			{
				setFlagColor();
				set_mouse_sprite(mouse_bmp[MOUSE_BMP_FLAG][0]);
			}
		}
		if(canedit && gui_mouse_b()==1 && isinRect(x,y,startxint,startyint,int32_t(startx+(256*mapscreensize)-1),int32_t(starty+(176*mapscreensize)-1)))
		{
			mapscr* cur_scr = (CurrentLayer
				? &(TheMaps[(Map.CurrScr()->layermap[CurrentLayer-1]-1)*MAPSCRS
					+(Map.CurrScr()->layerscreen[CurrentLayer-1])])
				: Map.CurrScr());
			if(key[KEY_ALT]||key[KEY_ALTGR])
			{
				Flag = cur_scr->sflag[c];
				setFlagColor();
				set_mouse_sprite(mouse_bmp[MOUSE_BMP_FLAG][0]);
			}
			else
			{
				saved=false;
				int32_t tflag = Flag;
				if(shift)
					Flag = mfNONE;
				if(CurrentLayer!=0)
				{
					// Notify if they are using a flag that doesn't work on this layer.
					if(!skipLayerWarning && ((Flag >= mfTRAP_H && Flag < mfPUSHD) || (Flag == mfFAIRY) || (Flag == mfMAGICFAIRY)
							|| (Flag == mfALLFAIRY) || (Flag == mfRAFT) || (Flag == mfRAFT_BRANCH)
							|| (Flag == mfDIVE_ITEM) || (Flag == mfARMOS_SECRET) || (Flag == mfNOENEMY)
							|| (Flag == mfZELDA)))
					{
						InfoDialog("Notice","You are currently working on layer "
							+to_string(CurrentLayer)
							+". This combo flag does not function on layers above '0'.").show();
					}
					if(!skipLayerWarning && CurrentLayer > 2 &&
						((Flag == mfBLOCKHOLE) || (Flag >= mfPUSHD && Flag < mfNOBLOCKS)
						|| (Flag == mfPUSHUD) || (Flag == mfPUSH4)))
					{
						InfoDialog("Notice","You are currently working on layer "
							+to_string(CurrentLayer)
							+". This combo flag does not function on layers above '2'.").show();
					}
				}
				if(key[KEY_LCONTROL]||key[KEY_RCONTROL])
				{
					switch(fill_type)
					{
						case 0:
							flood_flag();
							break;
							
						case 1:
						case 3:
							fill_4_flag();
							break;
							
						case 2:
						case 4:
							fill_8_flag();
							break;
					}
				}
				else cur_scr->sflag[c] = Flag;
				Flag = tflag;
			}
			
			refresh(rMAP | rNOCURSOR);
		}
		
		if(mouse_z)
		{
			for(int32_t i=0; i<abs(mouse_z); ++i)
			{
				if(mouse_z>0)
				{
					onIncreaseFlag();
				}
				else
				{
					onDecreaseFlag();
				}
			}
			
			position_mouse_z(0);
			set_mouse_sprite(mouse_bmp[MOUSE_BMP_FLAG][0]);
		}
		
		if(keypressed())
		{
			switch(readkey()>>8)
			{
			case KEY_ESC:
			case KEY_ENTER:
				goto finished;
				
			case KEY_ASTERISK:
			case KEY_CLOSEBRACE:
				onIncreaseFlag();
				break;
				
			case KEY_SLASH_PAD:
			case KEY_OPENBRACE:
				onDecreaseFlag();
				break;
				
			case KEY_UP:
				onUp();
				break;
				
			case KEY_DOWN:
				onDown();
				break;
				
			case KEY_LEFT:
				onLeft();
				break;
				
			case KEY_RIGHT:
				onRight();
				break;
				
			case KEY_PGUP:
				onPgUp();
				break;
				
			case KEY_PGDN:
				onPgDn();
				break;
				
			case KEY_COMMA:
				onDecMap();
				break;
				
			case KEY_STOP:
				onIncMap();
				break;
			}
			
			// The cursor could've been overwritten by the Combo Brush?
			set_mouse_sprite(mouse_bmp[MOUSE_BMP_FLAG][0]);
		}
		
		if(shift && theFlagColor)
		{
			setFlagColor(0);
			set_mouse_sprite(mouse_bmp[MOUSE_BMP_FLAG][0]);
		}
		
		do_animations();
		refresh(rALL | rNOCURSOR);
	}
	
finished:
	Flags=of;
	set_mouse_sprite(mouse_bmp[MOUSE_BMP_NORMAL][0]);
	refresh(rMAP+rMENU);
	
	while(gui_mouse_b())
	{
		/* do nothing */
        rest(1);
	}
}

// Drag FFCs around
void moveffc(int32_t i, int32_t cx, int32_t cy)
{
    int32_t ffx = vbound(int32_t(Map.CurrScr()->ffcs[i].x.getFloat()),0,240);
    int32_t ffy = vbound(int32_t(Map.CurrScr()->ffcs[i].y.getFloat()),0,160);
	int32_t offx = ffx, offy = ffy;
    showxypos_ffc = i;
    doxypos((byte&)ffx,(byte&)ffy,15,0xFF,true,cx-ffx,cy-ffy,(Map.CurrScr()->ffTileWidth(i)*16),(Map.CurrScr()->ffTileHeight(i)*16));
    if(ffx > 240) ffx = 240;
    if(ffy > 160) ffy = 160;
    if((ffx != offx) || (ffy != offy))
    {
        Map.CurrScr()->ffcs[i].x = ffx;
        Map.CurrScr()->ffcs[i].y = ffy;
        saved = false;
    }
}

void set_brush_width(int32_t width);
void set_brush_height(int32_t height);

int32_t set_brush_width_1()
{
    set_brush_width(1);
    return D_O_K;
}
int32_t set_brush_width_2()
{
    set_brush_width(2);
    return D_O_K;
}
int32_t set_brush_width_3()
{
    set_brush_width(3);
    return D_O_K;
}
int32_t set_brush_width_4()
{
    set_brush_width(4);
    return D_O_K;
}
int32_t set_brush_width_5()
{
    set_brush_width(5);
    return D_O_K;
}
int32_t set_brush_width_6()
{
    set_brush_width(6);
    return D_O_K;
}
int32_t set_brush_width_7()
{
    set_brush_width(7);
    return D_O_K;
}
int32_t set_brush_width_8()
{
    set_brush_width(8);
    return D_O_K;
}
int32_t set_brush_width_9()
{
    set_brush_width(9);
    return D_O_K;
}
int32_t set_brush_width_10()
{
    set_brush_width(10);
    return D_O_K;
}
int32_t set_brush_width_11()
{
    set_brush_width(11);
    return D_O_K;
}
int32_t set_brush_width_12()
{
    set_brush_width(12);
    return D_O_K;
}
int32_t set_brush_width_13()
{
    set_brush_width(13);
    return D_O_K;
}
int32_t set_brush_width_14()
{
    set_brush_width(14);
    return D_O_K;
}
int32_t set_brush_width_15()
{
    set_brush_width(15);
    return D_O_K;
}
int32_t set_brush_width_16()
{
    set_brush_width(16);
    return D_O_K;
}

int32_t set_brush_height_1()
{
    set_brush_height(1);
    return D_O_K;
}
int32_t set_brush_height_2()
{
    set_brush_height(2);
    return D_O_K;
}
int32_t set_brush_height_3()
{
    set_brush_height(3);
    return D_O_K;
}
int32_t set_brush_height_4()
{
    set_brush_height(4);
    return D_O_K;
}
int32_t set_brush_height_5()
{
    set_brush_height(5);
    return D_O_K;
}
int32_t set_brush_height_6()
{
    set_brush_height(6);
    return D_O_K;
}
int32_t set_brush_height_7()
{
    set_brush_height(7);
    return D_O_K;
}
int32_t set_brush_height_8()
{
    set_brush_height(8);
    return D_O_K;
}
int32_t set_brush_height_9()
{
    set_brush_height(9);
    return D_O_K;
}
int32_t set_brush_height_10()
{
    set_brush_height(10);
    return D_O_K;
}
int32_t set_brush_height_11()
{
    set_brush_height(11);
    return D_O_K;
}

static MENU brush_width_menu[] =
{
    { (char *)"1",          set_brush_width_1,    NULL, 0, NULL },
    { (char *)"2",          set_brush_width_2,    NULL, 0, NULL },
    { (char *)"3",          set_brush_width_3,    NULL, 0, NULL },
    { (char *)"4",          set_brush_width_4,    NULL, 0, NULL },
    { (char *)"5",          set_brush_width_5,    NULL, 0, NULL },
    { (char *)"6",          set_brush_width_6,    NULL, 0, NULL },
    { (char *)"7",          set_brush_width_7,    NULL, 0, NULL },
    { (char *)"8",          set_brush_width_8,    NULL, 0, NULL },
    { (char *)"9",          set_brush_width_9,    NULL, 0, NULL },
    { (char *)"10",         set_brush_width_10,   NULL, 0, NULL },
    { (char *)"11",         set_brush_width_11,   NULL, 0, NULL },
    { (char *)"12",         set_brush_width_12,   NULL, 0, NULL },
    { (char *)"13",         set_brush_width_13,   NULL, 0, NULL },
    { (char *)"14",         set_brush_width_14,   NULL, 0, NULL },
    { (char *)"15",         set_brush_width_15,   NULL, 0, NULL },
    { (char *)"16",         set_brush_width_16,   NULL, 0, NULL },
    { NULL,                 NULL,                 NULL, 0, NULL }
};

static MENU brush_height_menu[] =
{

    { (char *)"1",          set_brush_height_1,   NULL, 0, NULL },
    { (char *)"2",          set_brush_height_2,   NULL, 0, NULL },
    { (char *)"3",          set_brush_height_3,   NULL, 0, NULL },
    { (char *)"4",          set_brush_height_4,   NULL, 0, NULL },
    { (char *)"5",          set_brush_height_5,   NULL, 0, NULL },
    { (char *)"6",          set_brush_height_6,   NULL, 0, NULL },
    { (char *)"7",          set_brush_height_7,   NULL, 0, NULL },
    { (char *)"8",          set_brush_height_8,   NULL, 0, NULL },
    { (char *)"9",          set_brush_height_9,   NULL, 0, NULL },
    { (char *)"10",         set_brush_height_10,  NULL, 0, NULL },
    { (char *)"11",         set_brush_height_11,  NULL, 0, NULL },
    { NULL,                 NULL,                 NULL, 0, NULL }
};

int32_t set_flood();
int32_t set_fill_4();
int32_t set_fill_8();
int32_t set_fill2_4();
int32_t set_fill2_8();

void flood()
{
    int32_t drawmap, drawscr;
    
    if(CurrentLayer==0)
    {
        drawmap=Map.getCurrMap();
        drawscr=Map.getCurrScr();
    }
    else
    {
        drawmap=Map.CurrScr()->layermap[CurrentLayer-1]-1;
        drawscr=Map.CurrScr()->layerscreen[CurrentLayer-1];
        
        if(drawmap<0)
        {
            return;
        }
    }
    
    saved=false;
    
    if(!(Map.AbsoluteScr(drawmap, drawscr)->valid&mVALID))
    {
        Map.CurrScr()->valid|=mVALID;
        Map.AbsoluteScr(drawmap, drawscr)->valid|=mVALID;
        Map.setcolor(Color);
    }
    
    bool include_combos = !(key[KEY_LSHIFT]||key[KEY_RSHIFT]);
    Map.StartListCommand();

    for(int32_t i=0; i<176; i++)
    {
        Map.DoSetComboCommand(drawmap, drawscr, i, include_combos ? Combo : -1, CSet);
    }
    
    Map.FinishListCommand();
    refresh(rMAP+rSCRMAP);
}
void flood_flag()
{
    int32_t drawmap, drawscr;
    
    if(CurrentLayer==0)
    {
        drawmap=Map.getCurrMap();
        drawscr=Map.getCurrScr();
    }
    else
    {
        drawmap=Map.CurrScr()->layermap[CurrentLayer-1]-1;
        drawscr=Map.CurrScr()->layerscreen[CurrentLayer-1];
        
        if(drawmap<0)
        {
            return;
        }
    }
    
    saved=false;
    
    if(!(Map.AbsoluteScr(drawmap, drawscr)->valid&mVALID))
    {
        Map.CurrScr()->valid|=mVALID;
        Map.AbsoluteScr(drawmap, drawscr)->valid|=mVALID;
        Map.setcolor(Color);
    }
    
    Map.StartListCommand();
    for(int32_t i=0; i<176; i++)
    {
        Map.DoSetFlagCommand(drawmap, drawscr, i, Flag);
    }
    Map.FinishListCommand();
    
    refresh(rMAP+rSCRMAP);
}

void fill_4()
{
    int32_t drawmap, drawscr;
    
    if(CurrentLayer==0)
    {
        drawmap=Map.getCurrMap();
        drawscr=Map.getCurrScr();
    }
    else
    {
        drawmap=Map.CurrScr()->layermap[CurrentLayer-1]-1;
        drawscr=Map.CurrScr()->layerscreen[CurrentLayer-1];
        
        if(drawmap<0)
        {
            return;
        }
    }
    
    int32_t x=gui_mouse_x()-mapscreen_x-(showedges?(16*mapscreensize):0);
    int32_t y=gui_mouse_y()-mapscreen_y-(showedges?(16*mapscreensize):0);
    int32_t by= (y>>4)/(mapscreensize);
    int32_t bx= (x>>4)/(mapscreensize);
    
    if(draw_mode == dm_cpool
		|| (Map.AbsoluteScr(drawmap,drawscr)->cset[(by<<4)+bx]!=CSet ||
            (Map.AbsoluteScr(drawmap,drawscr)->data[(by<<4)+bx]!=Combo &&
             !(key[KEY_LSHIFT]||key[KEY_RSHIFT]))))
    {
        saved=false;
        
        if(!(Map.AbsoluteScr(drawmap, drawscr)->valid&mVALID))
        {
            Map.CurrScr()->valid|=mVALID;
            Map.AbsoluteScr(drawmap, drawscr)->valid|=mVALID;
            Map.setcolor(Color);
        }
        
        Map.StartListCommand();
        fill(drawmap, drawscr, Map.AbsoluteScr(drawmap, drawscr),
             (Map.AbsoluteScr(drawmap, drawscr)->data[(by<<4)+bx]),
             (Map.AbsoluteScr(drawmap, drawscr)->cset[(by<<4)+bx]), bx, by, 255, 0, (key[KEY_LSHIFT]||key[KEY_RSHIFT]));
        Map.FinishListCommand();
        refresh(rMAP+rSCRMAP);
    }
}
void fill_4_flag()
{
    int32_t drawmap, drawscr;
    
    if(CurrentLayer==0)
    {
        drawmap=Map.getCurrMap();
        drawscr=Map.getCurrScr();
    }
    else
    {
        drawmap=Map.CurrScr()->layermap[CurrentLayer-1]-1;
        drawscr=Map.CurrScr()->layerscreen[CurrentLayer-1];
        
        if(drawmap<0)
        {
            return;
        }
    }
    
    int32_t x=gui_mouse_x()-mapscreen_x-(showedges?(16*mapscreensize):0);
    int32_t y=gui_mouse_y()-mapscreen_y-(showedges?(16*mapscreensize):0);
    int32_t by= (y>>4)/(mapscreensize);
    int32_t bx= (x>>4)/(mapscreensize);
    
    if(Map.AbsoluteScr(drawmap,drawscr)->sflag[(by<<4)+bx] != Flag)
    {
        saved=false;
        
        if(!(Map.AbsoluteScr(drawmap, drawscr)->valid&mVALID))
        {
            Map.CurrScr()->valid|=mVALID;
            Map.AbsoluteScr(drawmap, drawscr)->valid|=mVALID;
            Map.setcolor(Color);
        }
        
        Map.StartListCommand();
		fill_flag(drawmap, drawscr, Map.AbsoluteScr(drawmap, drawscr),
             (Map.AbsoluteScr(drawmap, drawscr)->sflag[(by<<4)+bx]),
             bx, by, 255, 0);
        Map.FinishListCommand();
        refresh(rMAP+rSCRMAP);
    }
}
void fill_8()
{
    int32_t drawmap, drawscr;
    
    if(CurrentLayer==0)
    {
        drawmap=Map.getCurrMap();
        drawscr=Map.getCurrScr();
    }
    else
    {
        drawmap=Map.CurrScr()->layermap[CurrentLayer-1]-1;
        drawscr=Map.CurrScr()->layerscreen[CurrentLayer-1];
        
        if(drawmap<0)
        {
            return;
        }
    }
    
    int32_t x=gui_mouse_x()-mapscreen_x-(showedges?(16*mapscreensize):0);
    int32_t y=gui_mouse_y()-mapscreen_y-(showedges?(16*mapscreensize):0);
    int32_t by= (y>>4)/(mapscreensize);
    int32_t bx= (x>>4)/(mapscreensize);
    
    if(draw_mode == dm_cpool
		|| (Map.AbsoluteScr(drawmap,drawscr)->cset[(by<<4)+bx]!=CSet ||
            (Map.AbsoluteScr(drawmap,drawscr)->data[(by<<4)+bx]!=Combo &&
             !(key[KEY_LSHIFT]||key[KEY_RSHIFT]))))
    {
        saved=false;
        
        if(!(Map.AbsoluteScr(drawmap, drawscr)->valid&mVALID))
        {
            Map.CurrScr()->valid|=mVALID;
            Map.AbsoluteScr(drawmap, drawscr)->valid|=mVALID;
            Map.setcolor(Color);
        }
        
        Map.StartListCommand();
        fill(drawmap, drawscr, Map.AbsoluteScr(drawmap, drawscr),
             (Map.AbsoluteScr(drawmap, drawscr)->data[(by<<4)+bx]),
             (Map.AbsoluteScr(drawmap, drawscr)->cset[(by<<4)+bx]), bx, by, 255, 1, (key[KEY_LSHIFT]||key[KEY_RSHIFT]));
        Map.FinishListCommand();
        refresh(rMAP+rSCRMAP);
    }
}
void fill_8_flag()
{
    int32_t drawmap, drawscr;
    
    if(CurrentLayer==0)
    {
        drawmap=Map.getCurrMap();
        drawscr=Map.getCurrScr();
    }
    else
    {
        drawmap=Map.CurrScr()->layermap[CurrentLayer-1]-1;
        drawscr=Map.CurrScr()->layerscreen[CurrentLayer-1];
        
        if(drawmap<0)
        {
            return;
        }
    }
    
    int32_t x=gui_mouse_x()-mapscreen_x-(showedges?(16*mapscreensize):0);
    int32_t y=gui_mouse_y()-mapscreen_y-(showedges?(16*mapscreensize):0);
    int32_t by= (y>>4)/(mapscreensize);
    int32_t bx= (x>>4)/(mapscreensize);
    
    if(Map.AbsoluteScr(drawmap,drawscr)->sflag[(by<<4)+bx]!=Flag)
    {
        saved=false;
        
        if(!(Map.AbsoluteScr(drawmap, drawscr)->valid&mVALID))
        {
            Map.CurrScr()->valid|=mVALID;
            Map.AbsoluteScr(drawmap, drawscr)->valid|=mVALID;
            Map.setcolor(Color);
        }
        
        Map.StartListCommand();
        fill_flag(drawmap, drawscr, Map.AbsoluteScr(drawmap, drawscr),
             (Map.AbsoluteScr(drawmap, drawscr)->sflag[(by<<4)+bx]),
             bx, by, 255, 1);
        Map.FinishListCommand();
        refresh(rMAP+rSCRMAP);
    }
}

void fill2_4()
{
    int32_t drawmap, drawscr;
    
    if(CurrentLayer==0)
    {
        drawmap=Map.getCurrMap();
        drawscr=Map.getCurrScr();
    }
    
    else
    {
        drawmap=Map.CurrScr()->layermap[CurrentLayer-1]-1;
        drawscr=Map.CurrScr()->layerscreen[CurrentLayer-1];
        
        if(drawmap<0)
        {
            return;
        }
    }
    
    int32_t x=gui_mouse_x()-mapscreen_x-(showedges?(16*mapscreensize):0);
    int32_t y=gui_mouse_y()-mapscreen_y-(showedges?(16*mapscreensize):0);;
    int32_t by= (((y&0xF0))>>4)/(mapscreensize);
    int32_t bx= (x>>4)/(mapscreensize);
    
    saved=false;
    
    if(!(Map.AbsoluteScr(drawmap, drawscr)->valid&mVALID))
    {
        Map.CurrScr()->valid|=mVALID;
        Map.AbsoluteScr(drawmap, drawscr)->valid|=mVALID;
        Map.setcolor(Color);
    }
    
    Map.StartListCommand();
    fill2(Map.AbsoluteScr(drawmap, drawscr), Combo, CSet, bx, by, 255, 0, (key[KEY_LSHIFT]||key[KEY_RSHIFT]));
    Map.FinishListCommand();
    refresh(rMAP+rSCRMAP);
}

void fill2_8()
{
    int32_t drawmap, drawscr;
    
    if(CurrentLayer==0)
    {
        drawmap=Map.getCurrMap();
        drawscr=Map.getCurrScr();
    }
    else
    {
        drawmap=Map.CurrScr()->layermap[CurrentLayer-1]-1;
        drawscr=Map.CurrScr()->layerscreen[CurrentLayer-1];
        
        if(drawmap<0)
        {
            return;
        }
    }
    
    int32_t x=gui_mouse_x()-mapscreen_x-(showedges?(16*mapscreensize):0);
    int32_t y=gui_mouse_y()-mapscreen_y-(showedges?(16*mapscreensize):0);;
    int32_t by= (((y&0xF0))>>4)/(mapscreensize);
    int32_t bx= (x>>4)/(mapscreensize);
    
    saved=false;
    
    if(!(Map.AbsoluteScr(drawmap, drawscr)->valid&mVALID))
    {
        Map.CurrScr()->valid|=mVALID;
        Map.AbsoluteScr(drawmap, drawscr)->valid|=mVALID;
        Map.setcolor(Color);
    }
    
    Map.StartListCommand();
    fill2(Map.AbsoluteScr(drawmap, drawscr), Combo, CSet, bx, by, 255, 1, (key[KEY_LSHIFT]||key[KEY_RSHIFT]));
    Map.FinishListCommand();
    refresh(rMAP+rSCRMAP);
}

static MENU fill_menu[] =
{
    { (char *)"Flood",                   set_flood,   NULL, 0, NULL },
    { (char *)"Fill (4-way)",            set_fill_4,  NULL, 0, NULL },
    { (char *)"Fill (8-way)",            set_fill_8,  NULL, 0, NULL },
    { (char *)"Fill2 (4-way)",           set_fill2_4, NULL, 0, NULL },
    { (char *)"Fill2 (8-way)",           set_fill2_8, NULL, 0, NULL },
    { NULL,                              NULL,        NULL, 0, NULL }
};

int32_t set_flood()
{
    for(int32_t x=0; x<5; x++)
    {
        fill_menu[x].flags=0;
    }
    
    fill_menu[0].flags=D_SELECTED;
    fill_type=0;
    return D_O_K;
}

int32_t set_fill_4()
{
    for(int32_t x=0; x<5; x++)
    {
        fill_menu[x].flags=0;
    }
    
    fill_menu[1].flags=D_SELECTED;
    fill_type=1;
    return D_O_K;
}

int32_t set_fill_8()
{
    for(int32_t x=0; x<5; x++)
    {
        fill_menu[x].flags=0;
    }
    
    fill_menu[2].flags=D_SELECTED;
    fill_type=2;
    return D_O_K;
}

int32_t set_fill2_4()
{
    for(int32_t x=0; x<5; x++)
    {
        fill_menu[x].flags=0;
    }
    
    fill_menu[3].flags=D_SELECTED;
    fill_type=3;
    return D_O_K;
}

int32_t set_fill2_8()
{
    for(int32_t x=0; x<5; x++)
    {
        fill_menu[x].flags=0;
    }
    
    fill_menu[4].flags=D_SELECTED;
    fill_type=4;
    return D_O_K;
}

int32_t draw_block_1_2()
{
    draw_block(mousecomboposition,1,2);
    return D_O_K;
}

int32_t draw_block_2_1()
{
    draw_block(mousecomboposition,2,1);
    return D_O_K;
}

int32_t draw_block_2_2()
{
    draw_block(mousecomboposition,2,2);
    return D_O_K;
}

int32_t draw_block_2_3()
{
    draw_block(mousecomboposition,2,3);
    return D_O_K;
}

int32_t draw_block_3_2()
{
    draw_block(mousecomboposition,3,2);
    return D_O_K;
}

int32_t draw_block_3_3()
{
    draw_block(mousecomboposition,3,3);
    return D_O_K;
}

int32_t draw_block_4_2()
{
    draw_block(mousecomboposition,4,2);
    return D_O_K;
}

int32_t draw_block_4_4()
{
    draw_block(mousecomboposition,4,4);
    return D_O_K;
}

static MENU draw_block_menu[] =
{
    { (char *)"1x2",                     draw_block_1_2,  NULL,    0, NULL },
    { (char *)"2x1",                     draw_block_2_1,  NULL,    0, NULL },
    { (char *)"2x2",                     draw_block_2_2,  NULL,    0, NULL },
    { (char *)"2x3",                     draw_block_2_3,  NULL,    0, NULL },
    { (char *)"3x2",                     draw_block_3_2,  NULL,    0, NULL },
    { (char *)"3x3",                     draw_block_3_3,  NULL,    0, NULL },
    { (char *)"4x2",                     draw_block_4_2,  NULL,    0, NULL },
    { (char *)"4x4",                     draw_block_4_4,  NULL,    0, NULL },
    { NULL,                              NULL,            NULL,    0, NULL }
};

static MENU paste_screen_menu[] =
{
    { (char *)"Paste All",                     onPasteAll,  NULL,    0, NULL },
    { (char *)"Paste to All",                     onPasteToAll,  NULL,    0, NULL },
    { (char *)"Paste All to All",                     onPasteAllToAll,  NULL,    0, NULL },
    { NULL,                              NULL,            NULL,    0, NULL }
};

 void onRCSelectCombo(int32_t c)
 {
	    int32_t drawmap, drawscr;
	    
	    if(CurrentLayer==0)
	    {
		drawmap=Map.getCurrMap();
		drawscr=Map.getCurrScr();
	    }
	    else
	    {
		drawmap=Map.CurrScr()->layermap[CurrentLayer-1]-1;
		drawscr=Map.CurrScr()->layerscreen[CurrentLayer-1];
		
		if(drawmap<0)
		{
		    return;
		}
	    }
	    
	   Combo=Map.AbsoluteScr(drawmap, drawscr)->data[c];
}

 void onRCScrollToombo(int32_t c)
 {
	    int32_t drawmap, drawscr;
	    
	    if(CurrentLayer==0)
	    {
		drawmap=Map.getCurrMap();
		drawscr=Map.getCurrScr();
	    }
	    else
	    {
		drawmap=Map.CurrScr()->layermap[CurrentLayer-1]-1;
		drawscr=Map.CurrScr()->layerscreen[CurrentLayer-1];
		
		if(drawmap<0)
		{
		    return;
		}
	    }
	    
	    
		First[current_combolist]=vbound((Map.AbsoluteScr(drawmap, drawscr)->data[c]/combolist[0].w*combolist[0].w)-(combolist[0].w*combolist[0].h/2),0,MAXCOMBOS-(combolist[0].w*combolist[0].h));
	    
}

static MENU rc_menu_combo[] =
{
       { (char *)"Select Combo",            NULL,  NULL,              0, NULL },
    { (char *)"Scroll to Combo",         NULL,  NULL,              0, NULL },
    { (char *)"Edit Combo",              NULL,  NULL,              0, NULL },
    { (char *)"Replace All",             NULL,  NULL,              0, NULL },
    { (char *)"Draw Block",		       NULL,  draw_block_menu,	0, NULL },
    { (char *)"Set Brush Width\t ",      NULL,  brush_width_menu,  0, NULL },
    { (char *)"Set Brush Height\t ",     NULL,  brush_height_menu, 0, NULL },
    { (char *)"Set Fill Type\t ",        NULL,  fill_menu,         0, NULL },
    { NULL,                              NULL,            NULL,    0, NULL }
};

static MENU rc_menu_screen[] =
{
{ (char *)"Copy Screen",                        onCopy,  NULL,              0, NULL },
    { (char *)"Paste Screen",                        onPaste,  NULL,              0, NULL },
    { (char *)"Paste...",                        NULL,  paste_screen_menu,              0, NULL },
    { (char *)"Adv. Paste",                        NULL,  paste_menu,              0, NULL },
    { (char *)"Paste Special",                        NULL,  paste_item_menu,              0, NULL },
    { NULL,                              NULL,            NULL,    0, NULL }
};


static MENU draw_rc_menu[] =
{
    { (char *)"Select Combo",            NULL,  NULL,              0, NULL },
    { (char *)"Scroll to Combo",         NULL,  NULL,              0, NULL },
    { (char *)"Edit Combo",              NULL,  NULL,              0, NULL },
    { (char *)"",                        NULL,  NULL,              0, NULL },
    { (char *)"Replace All",             NULL,  NULL,              0, NULL },
    { (char *)"Draw Block",		       NULL,  draw_block_menu,	0, NULL },
    { (char *)"Set Brush Width\t ",      NULL,  brush_width_menu,  0, NULL },
    { (char *)"Set Brush Height\t ",     NULL,  brush_height_menu, 0, NULL },
    { (char *)"Set Fill Type\t ",        NULL,  fill_menu,         0, NULL },
    { (char *)"",                        NULL,  NULL,              0, NULL },
    { (char *)"Follow Tile Warp",        NULL,  NULL,              0, NULL },
    { (char *)"Edit Tile Warp",          NULL,  NULL,              0, NULL },
    { (char *)"",                        NULL,  NULL,              0, NULL },
    { (char *)"Place + Edit FFC 1",      NULL,  NULL,              0, NULL },
    { (char *)"Paste FFC as FFC 1",      NULL,  NULL,              0, NULL },
    { (char *)"",                        NULL,  NULL,              0, NULL },
    { (char *)"Screen",                        NULL,  rc_menu_screen,              0, NULL },
    
    { NULL,                              NULL,  NULL,              0, NULL }
};

static MENU draw_ffc_rc_menu[] =
{
    { (char *)"Copy FFC",            NULL,  NULL,              0, NULL },
    { (char *)"Paste FFC data",           NULL,  NULL,              0, NULL },
    { (char *)"Edit FFC",            NULL,  NULL,              0, NULL },
    { (char *)"Clear FFC",           NULL,  NULL,              0, NULL },
    { (char *)"Snap to Grid",           NULL,  NULL,              0, NULL },
    { NULL,                          NULL,  NULL,              0, NULL }
};

static MENU combosel_rc_menu[] =
{
    { (char *)"Edit Combo",         NULL,  NULL, 0, NULL },
    { (char *)"Open Combo Page",    NULL,  NULL, 0, NULL },
    { (char *)"Open Tile Page",     NULL,  NULL, 0, NULL },
    { (char *)"Combo Locations",    NULL,  NULL, 0, NULL },
    { (char *)"",                   NULL,  NULL, 0, NULL },
    { (char *)"Scroll to Page...",      NULL,  NULL, 0, NULL },
    { NULL,                         NULL,  NULL, 0, NULL }
};

static MENU fav_rc_menu[] =
{
    { (char *)"Scroll to Combo  ",       NULL,  NULL, 0, NULL },
    { (char *)"Edit Combo  ",            NULL,  NULL, 0, NULL },
    { (char *)"Remove Combo  ",          NULL,  NULL, 0, NULL },
    { (char *)"",                        NULL,  NULL, 0, NULL },
    { (char *)"Open Combo Page  ",       NULL,  NULL, 0, NULL },
    { (char *)"Open Tile Page  ",        NULL,  NULL, 0, NULL },
    { NULL,                              NULL,  NULL, 0, NULL }
};

void set_brush_width(int32_t width)
{
    for(int32_t x=0; x<16; x++)
    {
        brush_width_menu[x].flags=0;
    }
    
    BrushWidth=width;
    brush_width_menu[width-1].flags=D_SELECTED;
    refresh(rALL);
}

void set_brush_height(int32_t height)
{
    for(int32_t x=0; x<11; x++)
    {
        brush_height_menu[x].flags=0;
    }
    
    BrushHeight=height;
    brush_height_menu[height-1].flags=D_SELECTED;
    refresh(rALL);
}

void restore_mouse()
{
    ComboBrushPause=1;
    scare_mouse();
    set_mouse_sprite(mouse_bmp[MOUSE_BMP_NORMAL][0]);
    unscare_mouse();
}

static int32_t comboa_cnt=0;
static int32_t combop_cnt=0;
static int32_t layer_cnt=0;

static DIALOG clist_dlg[] =
{
    // (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp)
    { jwin_win_proc,     60-12,   40,   200+24,  148,  vc(14),  vc(1),  0,       D_EXIT,          0,             0,       NULL, NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { jwin_abclist_proc,       72-12-4,   60+4,   176+24+8,  92+3,   jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,       D_EXIT,     0,             0,       NULL, NULL, NULL },
    { jwin_button_proc,     90,   163,  61,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "OK", NULL, NULL },
    { jwin_button_proc,     170,  163,  61,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};


command_struct bic[cmdMAX];
int32_t bic_cnt=-1;

void build_bic_list()
{
    int32_t start=bic_cnt=0;
    
    for(int32_t i=start; i<cmdMAX; i++)
    {
        if(commands[i].name[0]!=' ')
        {
            bic[bic_cnt].s = (char *)commands[i].name;
            bic[bic_cnt].i = i;
            ++bic_cnt;
        }
    }
    
    for(int32_t i=start; i<bic_cnt; i++)
    {
        for(int32_t j=i+1; j<bic_cnt; j++)
        {
            if(stricmp(bic[i].s,bic[j].s)>0 && strcmp(bic[j].s,""))
            {
                zc_swap(bic[i],bic[j]);
            }
        }
    }
}

const char *commandlist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = bic_cnt;
        return NULL;
    }
    
    return bic[index].s;
}

int32_t select_command(const char *prompt,int32_t cmd)
{
	FONT* tfont = font;
    if(bic_cnt==-1)
        build_bic_list();
        
    int32_t index=0;
    
    for(int32_t j=0; j<bic_cnt; j++)
    {
        if(bic[j].i == cmd)
        {
            index=j;
        }
    }
    
    clist_dlg[0].dp=(void *)prompt;
    clist_dlg[0].dp2=lfont;
    clist_dlg[2].d1=index;
    static ListData command_list(commandlist, &font);
    clist_dlg[2].dp=(void *) &command_list;
    
    if(is_large)
        large_dialog(clist_dlg);
        
    int32_t ret=zc_popup_dialog(clist_dlg,2);
	font = tfont;
    
    if(ret==0||ret==4)
    {
        position_mouse_z(0);
        return -1;
    }
    
    index = clist_dlg[2].d1;
    position_mouse_z(0);
    return bic[index].i;
}


int32_t onCommand(int32_t cmd)
{
    restore_mouse();
    build_bic_list();
    int32_t ret=select_command("Select Command",cmd);
    refresh(rALL);
    
    if(ret>=0)
    {
        saved=false;
    }
    else if(ret == -1)
    {
        return cmd;
    }
    
    return ret;
}

static char paste_ffc_menu_text[21];
static char paste_ffc_menu_text2[21];
static char follow_warp_menu_text[21];
static char follow_warp_menu_text2[21];

void domouse()
{
	static bool mouse_down = false;
	static int32_t scrolldelay = 0;
	int32_t x=gui_mouse_x();
	int32_t y=gui_mouse_y();
	double startx=mapscreen_x+(showedges?(16*mapscreensize):0);
	double starty=mapscreen_y+(showedges?(16*mapscreensize):0);
	int32_t startxint=mapscreen_x+(showedges?int32_t(16*mapscreensize):0);
	int32_t startyint=mapscreen_y+(showedges?int32_t(16*mapscreensize):0);
	int32_t cx=(x-startxint)/int32_t(16*mapscreensize);
	int32_t cy=(y-startyint)/int32_t(16*mapscreensize);
	int32_t c=(cy*16)+cx;
	mousecomboposition=c;
	
	int32_t redraw=0;
	
	update_combobrush();
	//  put_combo(brushbmp,0,0,Combo,CSet,0,0);
	
	if(!isinRect(x,y,tooltip_trigger.x,tooltip_trigger.y,tooltip_trigger.x+tooltip_trigger.w-1,tooltip_trigger.y+tooltip_trigger.h-1))
	{
		clear_tooltip();
	}
	
	// For some reason, this causes an invisible cursor in a windowed ZQuest...
	/*if(!isinRect(x,y,startxint,startyint,int32_t(startx+(256*mapscreensize)-1),int32_t(starty+(176*mapscreensize)-1)))
	{
	  restore_mouse();
	}*/
	
	++scrolldelay;
	
	if(MouseScroll &&
		(
			((x>=combolist[0].x) && (x<combolist[0].x+(16*combolist[0].w)))||
			((x>=combolist[1].x) && (x<combolist[1].x+(16*combolist[1].w)))||
			((x>=combolist[2].x) && (x<combolist[2].x+(16*combolist[2].w)))
		) && (key[KEY_LSHIFT] || key[KEY_RSHIFT] || (scrolldelay&3)==0))
	{
	
		int32_t test_list=0;
		
		for(test_list=0; test_list<3; ++test_list)
		{
			if((x>=combolist[test_list].x) && (x<combolist[test_list].x+(16*combolist[test_list].w)))
			{
				break;
			}
		}
		
		if(test_list<3)
		{
			if(y>=combolist[test_list].y-mouse_scroll_h && y<=combolist[test_list].y && First[test_list])
			{
				if((key[KEY_ZC_LCONTROL] || key[KEY_ZC_RCONTROL])&&(key[KEY_ALT] || key[KEY_ALTGR]))
				{
					First[test_list]=0;
				}
				else if(key[KEY_ZC_LCONTROL] || key[KEY_ZC_RCONTROL])
				{
					First[test_list]-=zc_min(First[test_list],256);
				}
				else if(key[KEY_ALT] || key[KEY_ALTGR])
				{
					First[test_list]-=zc_min(First[test_list],(combolist[test_list].w*combolist[test_list].h));
				}
				else
				{
					First[test_list]-=zc_min(First[test_list],combolist[test_list].w);
				}
				
				redraw|=rCOMBOS;
			}
			
			if(y>=combolist[test_list].y+(combolist[test_list].h*16)-1 && y<combolist[test_list].y+(combolist[test_list].h*16)+mouse_scroll_h-1 && First[test_list]<(MAXCOMBOS-(combolist[test_list].w*combolist[test_list].h)))
			{
				int32_t offset = combolist[test_list].w*combolist[test_list].h;
				
				if((key[KEY_ZC_LCONTROL] || key[KEY_ZC_RCONTROL])&&(key[KEY_ALT] || key[KEY_ALTGR]))
				{
					First[test_list]=MAXCOMBOS-offset;
				}
				else if(key[KEY_ZC_LCONTROL] || key[KEY_ZC_RCONTROL])
				{
					First[test_list] = zc_min(MAXCOMBOS-offset, First[test_list]+256);
				}
				else if(key[KEY_ALT] || key[KEY_ALTGR])
				{
					First[test_list] = zc_min(MAXCOMBOS-offset, First[test_list]+ offset);
				}
				else
				{
					First[test_list] = zc_min(MAXCOMBOS - offset, First[test_list] + combolist[test_list].w);
				}
				
				redraw|=rCOMBOS;
			}
		}
	}
	
//-------------
//tooltip stuff
//-------------
	if(isinRect(x,y,startxint,startyint,int32_t(startx+(256*mapscreensize)-1),int32_t(starty+(176*mapscreensize)-1)))
	{
		bool did_ffttip = false;
		for(int32_t i=MAXFFCS-1; i>=0; i--)
			if(Map.CurrScr()->ffcs[i].getData() !=0 && (CurrentLayer<2 || (Map.CurrScr()->ffcs[i].flags&ffOVERLAY)))
			{
				int32_t ffx = Map.CurrScr()->ffcs[i].x.getInt();
				int32_t ffy = Map.CurrScr()->ffcs[i].y.getInt();
				int32_t ffw = Map.CurrScr()->ffTileWidth(i)*16;
				int32_t ffh = Map.CurrScr()->ffTileHeight(i)*16;
				int32_t cx2 = (x-startxint)/mapscreensize;
				int32_t cy2 = (y-startyint)/mapscreensize;
				
				if(cx2 >= ffx && cx2 < ffx+ffw && cy2 >= ffy && cy2 < ffy+ffh)
				{
					// FFC tooltip
					if(tooltip_current_ffc != i)
					{
						clear_tooltip();
					}
					
					tooltip_current_ffc = i;
					char msg[1024] = {0};
					auto& ff = Map.CurrScr()->ffcs[i];
					sprintf(msg,"FFC: %d Combo: %d\nCSet: %d Type: %s\nScript: %s",
							i+1, ff.getData(),ff.getData(),
							combo_class_buf[combobuf[ff.getData()].type].name,
							(ff.script<=0 ? "(None)" : ffcmap[ff.script-1].scriptname.substr(0,400).c_str()));
					update_tooltip(x, y, startxint+(ffx*mapscreensize), startyint+(ffy*mapscreensize), ffw*mapscreensize, ffh*mapscreensize, msg);
					did_ffttip = true;
					break;
				}
			}
		if(!did_ffttip)
		{
			int32_t drawmap;
			int32_t drawscr;
			
			if(CurrentLayer==0)
			{
				drawmap=Map.getCurrMap();
				drawscr=Map.getCurrScr();
			}
			else
			{
				drawmap=Map.CurrScr()->layermap[CurrentLayer-1]-1;
				drawscr=Map.CurrScr()->layerscreen[CurrentLayer-1];
				
				if(drawmap<0)
				{
				}
			}
			
			if(tooltip_current_combo != c)
			{
				clear_tooltip();
			}
			
			tooltip_current_combo = c;
			char msg[512] = {0};
			sprintf(msg,"Pos: %d Combo: %d\nCSet: %d Flags: %d, %d\nCombo type: %s",
					c, Map.AbsoluteScr(drawmap, drawscr)->data[c],
					Map.AbsoluteScr(drawmap, drawscr)->cset[c], Map.CurrScr()->sflag[c],combobuf[Map.CurrScr()->data[c]].flag,
					combo_class_buf[combobuf[(Map.AbsoluteScr(drawmap, drawscr)->data[c])].type].name);
			update_tooltip(x, y, startxint+(cx*16*mapscreensize), startyint+(cy*16*mapscreensize), 16*mapscreensize, 16*mapscreensize, msg);
		}
	}
	
	if(is_large)
	{
		size_and_pos* squares[4] = {&itemsqr_pos,&stairsqr_pos,&warparrival_pos,&flagsqr_pos};
		for(int32_t j=0; j<4; j++)
		{
			auto& square = *squares[j];
			if(square.rect(x,y))
			{
				char msg[160];
				sprintf(msg,
						j==0 ? "Item Location" :
						j==1 ? "Stairs Secret\nTriggered when a Trigger Push Block is pushed." :
						j==2 ? "Arrival Square\nPlayer's location when they begin/resume the game." :
						"Combo Flags");
				update_tooltip(x,y,square,msg);
			}
		}
		
		// Warp Returns
		for(int32_t j=0; j<4; j++)
		{
			size_and_pos& wret = warpret_pos[j];
			if(wret.rect(x,y))
			{
				char msg[160];
				sprintf(msg,"Warp Return Square %c\nPlayer's destination after warping to this screen.",(char)('A'+j));
				update_tooltip(x,y,wret,msg);
			}
		}
		
		// Enemies
		if(enemy_prev_pos.rect(x,y))
		{
			char msg[160];
			sprintf(msg,"Enemies that appear on this screen.");
			update_tooltip(x,y,enemy_prev_pos,msg);
		}
		
		for(int32_t cmd=0; cmd<(commands_list.w*commands_list.h); ++cmd)
		{
			int32_t check_x=(cmd%commands_list.w)*commands_list.xscale+commands_list.x;
			int32_t check_y=(cmd/commands_list.w)*commands_list.yscale+commands_list.y;
			
			if(isinRect(x,y,check_x,check_y,check_x+commands_list.xscale-1,check_y+commands_list.yscale-1))
			{
				FONT *tfont=font;
				font=get_custom_font(CFONT_FAVCMD);
				
				char msg[160];
				sprintf(msg,"Fav Command %d\n%s", cmd, commands[favorite_commands[cmd]].name);
				
				update_tooltip(x,y,check_x,check_y,commands_list.xscale,commands_list.yscale,msg);
				
				font=tfont;
			}
		}
	}
	
	if(draw_mode==dm_alias)
	{
		for(int32_t j=0; j<num_combo_cols; ++j)
		{
			auto& sqr = comboaliaslist[j];
			if(isinRect(x,y,sqr.x,sqr.y,sqr.x+(sqr.w*sqr.xscale)-1,sqr.y+(sqr.h*sqr.yscale)-1))
			{
				int32_t cc=((x-sqr.x)/sqr.xscale);
				int32_t cr=((y-sqr.y)/sqr.yscale);
				int32_t c2=(cr*sqr.w)+cc+combo_alistpos[j];
				char msg[80];
				sprintf(msg, "Combo alias %d", c2);
				update_tooltip(x,y,sqr.x+(cc*sqr.xscale),sqr.y+(cr*sqr.yscale),sqr.xscale,sqr.yscale, msg);
			}
		}
	}
	else if(draw_mode==dm_cpool)
	{
		for(int32_t j=0; j<num_combo_cols; ++j)
		{
			auto& sqr = comboaliaslist[j];
			if(isinRect(x,y,sqr.x,sqr.y,sqr.x+(sqr.w*sqr.xscale)-1,sqr.y+(sqr.h*sqr.yscale)-1))
			{
				int32_t cc=((x-sqr.x)/sqr.xscale);
				int32_t cr=((y-sqr.y)/sqr.yscale);
				int32_t c2=(cr*sqr.w)+cc+combo_pool_listpos[j];
				char msg[80];
				sprintf(msg, "Combo Pool %d", c2);
				update_tooltip(x,y,sqr.x+(cc*sqr.xscale),sqr.y+(cr*sqr.yscale),sqr.xscale,sqr.yscale, msg);
			}
		}
		if(cpool_prev_visible
			&& isinRect(x,y,combopool_prevbtn.x,combopool_prevbtn.y,
				combopool_prevbtn.x+combopool_prevbtn.w-1,
				combopool_prevbtn.y+combopool_prevbtn.h-1))
		{
			if(do_layer_button_reset(combopool_prevbtn.x,combopool_prevbtn.y,
				combopool_prevbtn.w,combopool_prevbtn.h,
				weighted_cpool ? "Weighted" : "Unweighted",0,true))
			{
				weighted_cpool = !weighted_cpool;
			}
		}
	}
	else
	{
		for(int32_t j=0; j<num_combo_cols; ++j)
		{
			auto& sqr = combolist[j];
			if(isinRect(x,y,sqr.x,sqr.y,sqr.x+(sqr.w*sqr.xscale)-1,sqr.y+(sqr.h*sqr.yscale)-1))
			{
				int32_t cc=((x-sqr.x)/sqr.xscale);
				int32_t cr=((y-sqr.y)/sqr.yscale);
				int32_t c2=(cr*sqr.w)+cc+First[j];
				char msg[160];
				
				if(combobuf[c2].flag != 0)
					sprintf(msg, "Combo %d: %s\nInherent flag:%s", c2, combo_class_buf[combobuf[c2].type].name, flag_string[combobuf[c2].flag]);
				else
					sprintf(msg, "Combo %d: %s", c2, combo_class_buf[combobuf[c2].type].name);
					
				update_tooltip(x,y,sqr.x+(cc*sqr.xscale),sqr.y+(cr*sqr.yscale),sqr.xscale,sqr.yscale, msg);
			}
		}
	}
	
	// Mouse clicking stuff
	if(gui_mouse_b()==0)
	{
		mouse_down = false;
		canfill=true;
	}
	else if(gui_mouse_b()&1)
	{
		//on the map screen
		if(isinRect(x,y,startxint,startyint,int32_t(startx+(256*mapscreensize)-1),int32_t(starty+(176*mapscreensize)-1)))
		{
			int32_t cx2 = (x-startxint)/mapscreensize;
			int32_t cy2 = (y-startyint)/mapscreensize;
			
			// Move items
			if(Map.CurrScr()->hasitem)
			{
				int32_t ix = Map.CurrScr()->itemx;
				int32_t iy = Map.CurrScr()->itemy;
				
				if(cx2 >= ix && cx2 < ix+16 && cy2 >= iy && cy2 < iy+16)
					doxypos(Map.CurrScr()->itemx,Map.CurrScr()->itemy,11,0xF8,true,0,0,16,16);
			}
			
			// Move FFCs
			for(int32_t i=MAXFFCS-1; i>=0; i--)
				if(Map.CurrScr()->ffcs[i].getData() !=0 && (CurrentLayer<2 || (Map.CurrScr()->ffcs[i].flags&ffOVERLAY)))
				{
					int32_t ffx = int32_t(Map.CurrScr()->ffcs[i].x.getFloat());
					int32_t ffy = int32_t(Map.CurrScr()->ffcs[i].y.getFloat());
					
					if(cx2 >= ffx && cx2 < ffx+(Map.CurrScr()->ffTileWidth(i)*16) && cy2 >= ffy && cy2 < ffy+(Map.CurrScr()->ffTileHeight(i)*16))
					{
						moveffc(i,cx2,cy2);
						break;
					}
				}
			
			if(key[KEY_ALT]||key[KEY_ALTGR])
			{
				int32_t drawmap, drawscr;
				if(CurrentLayer==0)
				{
					drawmap=Map.getCurrMap();
					drawscr=Map.getCurrScr();
				}
				else
				{
					drawmap=Map.CurrScr()->layermap[CurrentLayer-1]-1;
					drawscr=Map.CurrScr()->layerscreen[CurrentLayer-1];
				}
				if(drawmap<0)
					return;
				Combo=Map.AbsoluteScr(drawmap, drawscr)->data[c];
				if(key[KEY_LSHIFT]||key[KEY_RSHIFT])
					CSet=Map.AbsoluteScr(drawmap, drawscr)->cset[c];
				if(key[KEY_ZC_LCONTROL] || key[KEY_ZC_RCONTROL])
					First[current_combolist]=vbound(
					  (Map.AbsoluteScr(drawmap, drawscr)->data[c]/combolist[0].w*combolist[0].w)-(combolist[0].w*combolist[0].h/2),
					  0,
					  MAXCOMBOS-(combolist[0].w*combolist[0].h));
			}
			else if(key[KEY_ZC_LCONTROL] || key[KEY_ZC_RCONTROL])
			{
				if(canfill)
				{
					switch(fill_type)
					{
					case 0:
						flood();
						break;
						
					case 1:
						fill_4();
						break;
						
					case 2:
						fill_8();
						break;
						
					case 3:
						fill2_4();
						break;
						
					case 4:
						fill2_8();
						break;
					}
					
					canfill=false;
				}
			}
			else draw(key[KEY_LSHIFT] || key[KEY_RSHIFT]);
		}
		
		//on the map tabs
		if(is_large)
		{
			FONT* tfont = font;
			font = get_custom_font(CFONT_GUI);
			for(int32_t btn=0; btn<mappage_count; ++btn)
			{
				char tbuf[15];
				sprintf(tbuf, "%d:%02X", map_page[btn].map+1, map_page[btn].screen);
				
				if(isinRect(x,y,map_page_bar[btn].x,map_page_bar[btn].y,map_page_bar[btn].x+map_page_bar[btn].w-1,map_page_bar[btn].y+map_page_bar[btn].h-1))
				{
					if(do_layer_button_reset(map_page_bar[btn].x,map_page_bar[btn].y,map_page_bar[btn].w,map_page_bar[btn].h,tbuf,(btn==current_mappage?D_SELECTED:0)))
					{
						draw_layer_button(screen, map_page_bar[btn].x,map_page_bar[btn].y,map_page_bar[btn].w,map_page_bar[btn].h,tbuf,D_SELECTED);
						map_page[current_mappage].map=Map.getCurrMap();
						map_page[current_mappage].screen=Map.getCurrScr();
						current_mappage=btn;
						Map.setCurrMap(map_page[current_mappage].map);
						Map.setCurrScr(map_page[current_mappage].screen);
						rebuild_trans_table(); //Woo
					}
				}
			}
			font=tfont;
		}
		
		//on the drawing mode button
		if(is_large)
		{
			FONT* tfont = font;
			font = get_custom_font(CFONT_GUI);
			
			if(isinRect(x,y,drawmode_btn.x,drawmode_btn.y,drawmode_btn.x+drawmode_btn.w-1,drawmode_btn.y+drawmode_btn.h-1))
			{
				if(do_text_button(drawmode_btn.x,drawmode_btn.y,drawmode_btn.w,drawmode_btn.h,dm_names[draw_mode],vc(1),vc(14),true))
					onDrawingMode();
			}
			
			if(isinRect(x,y,compactbtn.x,compactbtn.y,compactbtn.x+compactbtn.w-1,compactbtn.y+compactbtn.h-1) && !mouse_down)
			{
				if(do_text_button(compactbtn.x, compactbtn.y, compactbtn.w, compactbtn.h, is_compact ? "< Expand" : "> Compact", vc(1),vc(14),true));
					toggle_is_compact();
			}
			
			font = lfont_l;
			if(combo_merge_btn.rect(x,y))
			{
				bool merged = is_compact ? compact_merged_combopane : large_merged_combopane;
				if(do_text_button(combo_merge_btn.x,combo_merge_btn.y,combo_merge_btn.w,combo_merge_btn.h,merged ? "<|>" : ">|<",vc(1),vc(14),true))
				{
					toggle_merged_mode();
				}
			}
			font=tfont;
		}
		
		//on the minimap
		if(isinRect(x,y,minimap.x+3,minimap.y+12,minimap.x+minimap.w-5,minimap.y+minimap.h-4))
		{
			select_scr();
		}
		
		if(is_large)
		{
			bool do_dummyxy = false;
			bool dummymode = key[KEY_LSHIFT] || key[KEY_RSHIFT];
			
			if(itemsqr_pos.rect(x,y))
			{
				if(dummymode) do_dummyxy = true;
				else
				{
					onItem();
					
					if(Map.CurrScr()->hasitem)
						doxypos(Map.CurrScr()->itemx,Map.CurrScr()->itemy,11,0xF8);
				}
			}
			
			if(stairsqr_pos.rect(x,y))
			{
				if(dummymode) do_dummyxy = true;
				else
				{
					doxypos(Map.CurrScr()->stairx,Map.CurrScr()->stairy,14,0xF0);
				}
			}
			
			if(warparrival_pos.rect(x,y))
			{
				if(dummymode) do_dummyxy = true;
				else
				{
					if(get_bit(quest_rules,qr_NOARRIVALPOINT))
					{
						if(!zc_get_config("zquest","dsa_warparrival",0))
						{
							AlertDialog("Arrival Square",
								"The arrival square cannot be used unless the QR 'Use Warp Return "
								"Points Only' under 'Quest->Options->Combos' is disabled."
								"\nGenerally, this square only exists for compatibility purposes, and is not used"
								" in creating new quests.",
								[&](bool ret,bool dsa)
								{
									if(dsa)
									{
										zc_set_config("zquest","dsa_warparrival",1);
									}
								},
								"OK","",
								0,false, //timeout - none
								true //"Don't show this again"
							).show();
						}
					}
					else doxypos(Map.CurrScr()->warparrivalx,Map.CurrScr()->warparrivaly,10,0xF8);
				}
			}
			
			if(flagsqr_pos.rect(x,y))
			{
				if(dummymode) do_dummyxy = true;
				else
				{
					onFlags();
				}
			}
			
			for(auto q = 0; q < 4; ++q)
			{
				if(warpret_pos[q].rect(x,y))
				{
					if(dummymode) do_dummyxy = true;
					else
					{
						doxypos(Map.CurrScr()->warpreturnx[q],Map.CurrScr()->warpreturny[q],9,0xF8);
					}
				}
			}
			
			if(enemy_prev_pos.rect(x,y))
			{
				if(dummymode) do_dummyxy = true;
				else
				{
					onEnemies();
				}
			}
			
			if(do_dummyxy)
			{
				byte x = 0, y = 0;
				showxypos_dummy = true;
				doxypos(x,y,13,0xF8);
			}
		}
		else
		{
			if(menutype==m_coords)
			{
				if(isinRect(x,y,panel[0].x+16,panel[0].y+6,panel[0].x+16+15,panel[0].y+6+15))
				{
					onItem();
					
					if(Map.CurrScr()->hasitem)
						doxypos(Map.CurrScr()->itemx,Map.CurrScr()->itemy,11,0xF8);
				}
				
				if(isinRect(x,y,panel[0].x+48,panel[0].y+6,panel[0].x+48+15,panel[0].y+6+15))
				{
					doxypos(Map.CurrScr()->stairx,Map.CurrScr()->stairy,14,0xF0);
				}
				
				if(isinRect(x,y,panel[0].x+80,panel[0].y+6,panel[0].x+80+15,panel[0].y+6+15))
				{
					if(get_bit(quest_rules,qr_NOARRIVALPOINT))
						jwin_alert("Obsolete Square","The arrival square is obsolete if you use the",
								   "'Use Warp Return Points Only' quest rule. It is included",
								   "only for backwards-compatibility purposes.","O&K",NULL,'k',0,lfont);
								   
					doxypos(Map.CurrScr()->warparrivalx,Map.CurrScr()->warparrivaly,10,0xF8);
				}
				
				if(isinRect(x,y,panel[0].x+112,panel[0].y+6,panel[0].x+112+15,panel[0].y+6+15))
				{
					onFlags();
				}
			}
			
			if(menutype==m_coords2)
			{
				if(isinRect(x,y,panel[7].x+16,panel[7].y+6,panel[7].x+16+15,panel[7].y+6+15))
				{
					doxypos(Map.CurrScr()->warpreturnx[0],Map.CurrScr()->warpreturny[0],9,0xF8);
				}
				
				if(isinRect(x,y,panel[7].x+48,panel[7].y+6,panel[7].x+48+15,panel[7].y+6+15))
				{
					doxypos(Map.CurrScr()->warpreturnx[1],Map.CurrScr()->warpreturny[1],9,0xF8);
				}
				
				if(isinRect(x,y,panel[7].x+80,panel[7].y+6,panel[7].x+80+15,panel[7].y+6+15))
				{
					doxypos(Map.CurrScr()->warpreturnx[2],Map.CurrScr()->warpreturny[2],9,0xF8);
				}
				
				if(isinRect(x,y,panel[7].x+112,panel[7].y+6,panel[7].x+112+15,panel[7].y+6+15))
				{
					doxypos(Map.CurrScr()->warpreturnx[3],Map.CurrScr()->warpreturny[3],9,0xF8);
				}
			}
			else if(menutype==m_layers)
			{
				if(isinRect(x, y, panel[6].x+9,panel[6].y+20,panel[6].x+9+layerpanel_checkbox_wid-1,panel[6].y+20+layerpanel_checkbox_hei-1))
				{
					do_checkbox(menu1,panel[6].x+9-3,panel[6].y+20,layerpanel_checkbox_wid,layerpanel_checkbox_hei,vc(1),vc(14), LayerMaskInt[0]);
				}
				
				if(isinRect(x, y, panel[6].x+34,panel[6].y+20,panel[6].x+34+layerpanel_checkbox_wid-1,panel[6].y+20+layerpanel_checkbox_hei-1))
				{
					do_checkbox(menu1,panel[6].x+34-3,panel[6].y+20,layerpanel_checkbox_wid,layerpanel_checkbox_hei,vc(1),vc(14), LayerMaskInt[1]);
				}
				
				if(isinRect(x, y, panel[6].x+59,panel[6].y+20,panel[6].x+59+layerpanel_checkbox_wid-1,panel[6].y+20+layerpanel_checkbox_hei-1))
				{
					do_checkbox(menu1,panel[6].x+59-3,panel[6].y+20,layerpanel_checkbox_wid,layerpanel_checkbox_hei,vc(1),vc(14), LayerMaskInt[2]);
				}
				
				if(isinRect(x, y, panel[6].x+84,panel[6].y+20,panel[6].x+84+layerpanel_checkbox_wid-1,panel[6].y+20+layerpanel_checkbox_hei-1))
				{
					do_checkbox(menu1,panel[6].x+84-3,panel[6].y+20,layerpanel_checkbox_wid,layerpanel_checkbox_hei,vc(1),vc(14), LayerMaskInt[3]);
				}
				
				if(isinRect(x, y, panel[6].x+109,panel[6].y+20,panel[6].x+109+layerpanel_checkbox_wid-1,panel[6].y+20+layerpanel_checkbox_hei-1))
				{
					do_checkbox(menu1,panel[6].x+109-3,panel[6].y+20,layerpanel_checkbox_wid,layerpanel_checkbox_hei,vc(1),vc(14), LayerMaskInt[4]);
				}
				
				if(isinRect(x, y, panel[6].x+134,panel[6].y+20,panel[6].x+134+layerpanel_checkbox_wid-1,panel[6].y+20+layerpanel_checkbox_hei-1))
				{
					do_checkbox(menu1,panel[6].x+134-3,panel[6].y+20,layerpanel_checkbox_wid,layerpanel_checkbox_hei,vc(1),vc(14), LayerMaskInt[5]);
				}
				
				if(isinRect(x, y, panel[6].x+159,panel[6].y+20,panel[6].x+159+layerpanel_checkbox_wid-1,panel[6].y+20+layerpanel_checkbox_hei-1))
				{
					do_checkbox(menu1,panel[6].x+159-3,panel[6].y+20,layerpanel_checkbox_wid,layerpanel_checkbox_hei,vc(1),vc(14), LayerMaskInt[6]);
				}
				
				if(isinRect(x, y, panel[6].x+9,panel[6].y+30, panel[6].x+9+(6*25)+8,panel[6].y+30+8))
				{
					do_layerradio(menu1,panel[6].x+9,panel[6].y+30,vc(1),vc(14), CurrentLayer);
				}
				
				redraw|=rMENU;
			}
		}
	
		// Little arrows that scroll combos
		// Up and Down Arrows for Combo Alias Banks
		if(draw_mode==dm_alias)
		{
			for(int32_t j=0; j<num_combo_cols; ++j)
			{
				int32_t temp_x1=combolistscrollers[j].x;
				int32_t temp_y1=combolistscrollers[j].y;
				int32_t temp_x2=combolistscrollers[j].x+combolistscrollers[j].w-1;
				int32_t temp_y2=combolistscrollers[j].y+combolistscrollers[j].h-2;
				
				int32_t temp_x3=combolistscrollers[j].x;
				int32_t temp_y3=combolistscrollers[j].y+combolistscrollers[j].h-1;
				int32_t temp_x4=combolistscrollers[j].x+combolistscrollers[j].w-1;
				int32_t temp_y4=combolistscrollers[j].y+combolistscrollers[j].h*2-3;
				
				if(is_large)
				{
					temp_x1=combolistscrollers[j].x;
					temp_y1=combolistscrollers[j].y;
					temp_x2=combolistscrollers[j].x+combolistscrollers[j].w-1;
					temp_y2=combolistscrollers[j].y+combolistscrollers[j].h-1;
					
					temp_x3=combolistscrollers[j].x+combolistscrollers[j].w;
					temp_y3=combolistscrollers[j].y;
					temp_x4=combolistscrollers[j].x+combolistscrollers[j].w*2-1;
					temp_y4=combolistscrollers[j].y+combolistscrollers[j].h-1;
				}
				
				if(isinRect(x,y,temp_x3,temp_y3,temp_x4,temp_y4) && (combo_alistpos[j]<(MAXCOMBOALIASES-(comboaliaslist[0].w*comboaliaslist[0].h))) && !mouse_down)
				{
					combo_alistpos[j]=zc_min((MAXCOMBOALIASES-(comboaliaslist[0].w*comboaliaslist[0].h)),combo_alistpos[j]+(comboaliaslist[0].w*comboaliaslist[0].h));
					refresh(rCOMBOS);
				}
				else if(isinRect(x,y,temp_x1,temp_y1,temp_x2,temp_y2) && (combo_alistpos[j]>0) && !mouse_down)
				{
					combo_alistpos[j]-=zc_min(combo_alistpos[j],(comboaliaslist[0].w*comboaliaslist[0].h));
					refresh(rCOMBOS);
				}
				else if(isinRect(x,y,comboaliaslist[j].x,comboaliaslist[j].y,comboaliaslist[j].x+(comboaliaslist[j].w*comboaliaslist[j].xscale)-1,comboaliaslist[j].y+(comboaliaslist[j].h*comboaliaslist[j].yscale)-1))
				{
					select_comboa(j);
				}
			}
		}
		else if(draw_mode==dm_cpool) // Up and Down Arrows for Combo Pool Banks
		{
			for(int32_t j=0; j<num_combo_cols; ++j)
			{
				int32_t temp_x1=combolistscrollers[j].x;
				int32_t temp_y1=combolistscrollers[j].y;
				int32_t temp_x2=combolistscrollers[j].x+combolistscrollers[j].w-1;
				int32_t temp_y2=combolistscrollers[j].y+combolistscrollers[j].h-2;
				
				int32_t temp_x3=combolistscrollers[j].x;
				int32_t temp_y3=combolistscrollers[j].y+combolistscrollers[j].h-1;
				int32_t temp_x4=combolistscrollers[j].x+combolistscrollers[j].w-1;
				int32_t temp_y4=combolistscrollers[j].y+combolistscrollers[j].h*2-3;
				
				if(is_large)
				{
					temp_x1=combolistscrollers[j].x;
					temp_y1=combolistscrollers[j].y;
					temp_x2=combolistscrollers[j].x+combolistscrollers[j].w-1;
					temp_y2=combolistscrollers[j].y+combolistscrollers[j].h-1;
					
					temp_x3=combolistscrollers[j].x+combolistscrollers[j].w;
					temp_y3=combolistscrollers[j].y;
					temp_x4=combolistscrollers[j].x+combolistscrollers[j].w*2-1;
					temp_y4=combolistscrollers[j].y+combolistscrollers[j].h-1;
				}
				
				if(isinRect(x,y,temp_x3,temp_y3,temp_x4,temp_y4) && (combo_pool_listpos[j]<(MAXCOMBOPOOLS-(comboaliaslist[0].w*comboaliaslist[0].h))) && !mouse_down)
				{
					combo_pool_listpos[j]=zc_min((MAXCOMBOPOOLS-(comboaliaslist[0].w*comboaliaslist[0].h)),combo_pool_listpos[j]+(comboaliaslist[0].w*comboaliaslist[0].h));
					refresh(rCOMBOS);
				}
				else if(isinRect(x,y,temp_x1,temp_y1,temp_x2,temp_y2) && (combo_pool_listpos[j]>0) && !mouse_down)
				{
					combo_pool_listpos[j]-=zc_min(combo_pool_listpos[j],(comboaliaslist[0].w*comboaliaslist[0].h));
					refresh(rCOMBOS);
				}
				else if(isinRect(x,y,comboaliaslist[j].x,comboaliaslist[j].y,comboaliaslist[j].x+(comboaliaslist[j].w*comboaliaslist[j].xscale)-1,comboaliaslist[j].y+(comboaliaslist[j].h*comboaliaslist[j].yscale)-1))
				{
					select_combop(j);
				}
			}
		}
		else // Up and Down Arrows for Combo Banks
		{
			for(int32_t j=0; j<num_combo_cols; ++j)
			{
				int32_t temp_x1=combolistscrollers[j].x;
				int32_t temp_y1=combolistscrollers[j].y;
				int32_t temp_x2=combolistscrollers[j].x+combolistscrollers[j].w-1;
				int32_t temp_y2=combolistscrollers[j].y+combolistscrollers[j].h-2;
				
				int32_t temp_x3=combolistscrollers[j].x;
				int32_t temp_y3=combolistscrollers[j].y+combolistscrollers[j].h-1;
				int32_t temp_x4=combolistscrollers[j].x+combolistscrollers[j].w-1;
				int32_t temp_y4=combolistscrollers[j].y+combolistscrollers[j].h*2-3;
				
				if(is_large)
				{
					temp_x1=combolistscrollers[j].x;
					temp_y1=combolistscrollers[j].y;
					temp_x2=combolistscrollers[j].x+combolistscrollers[j].w-1;
					temp_y2=combolistscrollers[j].y+combolistscrollers[j].h-1;
					
					temp_x3=combolistscrollers[j].x+combolistscrollers[j].w;
					temp_y3=combolistscrollers[j].y;
					temp_x4=combolistscrollers[j].x+combolistscrollers[j].w*2-1;
					temp_y4=combolistscrollers[j].y+combolistscrollers[j].h-1;
				}
				
				if(isinRect(x,y,temp_x1,temp_y1,temp_x2,temp_y2) && First[j]>0 && !mouse_down)
				{
					if(key[KEY_ZC_LCONTROL] || key[KEY_ZC_RCONTROL])
					{
						First[j]-=zc_min(First[j],256);
					}
					else
					{
						First[j]-=zc_min(First[j],(combolist[0].w*combolist[0].h));
					}
					
					redraw|=rCOMBOS;
				}
				else if(isinRect(x,y,temp_x3,temp_y3,temp_x4,temp_y4) && First[j]<(MAXCOMBOS-(combolist[0].w*combolist[0].h)) && !mouse_down)
				{
					if(key[KEY_ZC_LCONTROL] || key[KEY_ZC_RCONTROL])
					{
						First[j]+=zc_min((MAXCOMBOS-256)-First[j],256);
					}
					else
					{
						First[j]+=zc_min((MAXCOMBOS-(combolist[0].w*combolist[0].h))-First[j],(combolist[0].w*combolist[0].h));
					}
					
					redraw|=rCOMBOS;
				}
				else if(isinRect(x,y,combolist[j].x,combolist[j].y,combolist[j].x+(combolist[j].w*combolist[j].xscale)-1,combolist[j].y+(combolist[j].h*combolist[j].yscale)-1))
				{
					select_combo(j);
				}
			}
			
			if ( !is_large )
			{
				if((isinRect(x,y,panel[0].x+panel[0].w-28,panel[0].y+32,panel[0].x+panel[0].w-28+24,panel[0].y+32+5) && menutype==m_block && !mouse_down) ||
					(isinRect(x,y,panel[6].x+panel[6].w-28,panel[6].y+36,panel[6].x+panel[6].w-28+24,panel[6].y+36+5) && menutype==m_layers && !mouse_down))
				{
					CSet=wrap(CSet+1,0,11);
					refresh(rCOMBOS+rMENU+rCOMBO);
				}
				
				if(isinRect(x,y,panel[0].x+panel[0].w-32,panel[0].y+39,panel[0].x+panel[0].w-32+28,panel[0].y+39+5) && menutype==m_block && !mouse_down)
				{
					bool validlayer=false;
					
					while(!validlayer)
					{
						CurrentLayer=wrap(CurrentLayer+1,0,6);
						
						if((CurrentLayer==0)||(Map.CurrScr()->layermap[CurrentLayer-1]))
						{
							validlayer=true;
						}
					}
					
					refresh(rMENU);
				}
			}
		}
		
		//on the favorites list
		if(isinRect(x,y,favorites_x.x,favorites_x.y,favorites_x.x+favorites_x.w-1,favorites_list.y+favorites_x.h-1))
		{
			switch(draw_mode)
			{
				case dm_cpool: break;
				case dm_alias:
					AlertDialog("Clear Favorite Aliases",
						"Are you sure you want to clear all favorite aliases?",
						[&](bool ret,bool)
						{
							if(ret)
							{
								for(auto q = 0; q < MAXFAVORITECOMBOALIASES; ++q)
								{
									favorite_comboaliases[q] = -1;
								}
								saved = false;
								refresh(rFAVORITES);
							}
						}).show();
					break;
				default:
					AlertDialog("Clear Favorite Combos",
						"Are you sure you want to clear all favorite combos?",
						[&](bool ret,bool)
						{
							if(ret)
							{
								for(auto q = 0; q < MAXFAVORITECOMBOS; ++q)
								{
									favorite_combos[q] = -1;
								}
								saved = false;
								refresh(rFAVORITES);
							}
						}).show();
					break;
			}
		}
		if(draw_mode != dm_cpool && isinRect(x,y,favorites_list.x,favorites_list.y,favorites_list.x+(favorites_list.w*16)-1,favorites_list.y+(favorites_list.h*16)-1))
		{
			int32_t row=vbound(((y-favorites_list.y)>>4),0,favorites_list.h-1);
			int32_t col=vbound(((x-favorites_list.x)>>4),0,favorites_list.w-1);
			int32_t f=(row*FAVORITECOMBO_PER_ROW)+col;
			int32_t* fav = favorite_combos;
			bool dmcond;
			if(draw_mode==dm_alias) dmcond = favorite_comboaliases[f] < 0;
			else dmcond = favorite_combos[f] < 0;
			if(key[KEY_LSHIFT] || key[KEY_RSHIFT] || dmcond)
			{
				int32_t tempcb=ComboBrush;
				ComboBrush=0;
				
				while(gui_mouse_b())
				{
					x=gui_mouse_x();
					y=gui_mouse_y();
					
					if(draw_mode == dm_alias)
					{
						if(favorite_comboaliases[f]!=combo_apos)
						{
							favorite_comboaliases[f]=combo_apos;
							saved=false;
						}
					}
					else
					{
						if(favorite_combos[f]!=Combo)
						{
							favorite_combos[f]=Combo;
							saved=false;
						}
					}
					
					do_animations();
					refresh(rALL | rFAVORITES);
				}
				
				ComboBrush=tempcb;
			}
			else if(key[KEY_ZC_LCONTROL] || key[KEY_ZC_RCONTROL])
			{
				int32_t tempcb=ComboBrush;
				ComboBrush=0;
				
				while(gui_mouse_b())
				{
					x=gui_mouse_x();
					y=gui_mouse_y();
					
					if(draw_mode == dm_alias)
					{
						if(favorite_comboaliases[f]!=-1)
						{
							favorite_comboaliases[f]=-1;
							saved=false;
						}
					}
					else
					{
						if(favorite_combos[f]!=-1)
						{
							favorite_combos[f]=-1;
							saved=false;
						}
					}
					
					do_animations();
					refresh(rALL | rFAVORITES);
				}
				
				ComboBrush=tempcb;
			}
			else if(key[KEY_ALT] || key[KEY_ALTGR])
			{
				if(select_favorite())
				{
					switch(draw_mode)
					{
						case dm_alias:
						case dm_cpool:
							break;
						default:
							First[current_combolist]=vbound((Combo/combolist[0].w*combolist[0].w)-(combolist[0].w*combolist[0].h/2),0,MAXCOMBOS-(combolist[0].w*combolist[0].h));
					}
				}
			}
			else
			{
				select_favorite();
			}
		}
		
		//on the commands buttons
		if(is_large)
		{
			for(int32_t cmd=0; cmd<(commands_list.w*commands_list.h); ++cmd)
			{
				int32_t check_x=(cmd%commands_list.w)*commands_list.xscale+commands_list.x;
				int32_t check_y=(cmd/commands_list.w)*commands_list.yscale+commands_list.y;
				bool shift=(key[KEY_LSHIFT] || key[KEY_RSHIFT]);
				bool ctrl=(key[KEY_ZC_LCONTROL] || key[KEY_ZC_RCONTROL]);
				
				if(isinRect(x,y,check_x,check_y,check_x+commands_list.xscale,check_y+commands_list.yscale)&&(commands[favorite_commands[cmd]].flags!=D_DISABLED||(shift||ctrl)))
				{
					FONT *tfont=font;
					font=get_custom_font(CFONT_FAVCMD);
					
					if(do_layer_button_reset(check_x,
						check_y,
						commands_list.xscale,
						commands_list.yscale,
						favorite_commands[cmd]==cmdCatchall&&strcmp(catchall_string[Map.CurrScr()->room]," ")
							? catchall_string[Map.CurrScr()->room]
							: commands[favorite_commands[cmd]].name,
						isFavCmdSelected(favorite_commands[cmd])?D_SELECTED:0,
						true))
					{
						font=tfont;
						if(ctrl)
						{
							write_fav_command(cmd,0);
						}
						else if(shift || favorite_commands[cmd]==0)
						{
							write_fav_command(cmd,onCommand(favorite_commands[cmd]));
						}
						else
						{
							int32_t (*pfun)();
							pfun=commands[favorite_commands[cmd]].command;
							pfun();
						}
					}
					
					font=tfont;
				}
			}
		}
		
		// On the layer panel
		if(is_large)
		{
			FONT* tfont = font;
			font = get_custom_font(CFONT_GUI);
			for(int32_t i=0; i<=6; ++i)
			{
				int32_t spacing_offs = is_compact ? 5 : 10;
				int32_t rx = (i * (layerpanel_buttonwidth+spacing_offs+layerpanel_checkbox_wid)) + layer_panel.x+(is_compact?2:6);
				int32_t ry = layer_panel.y;
				
				if((i==0 || Map.CurrScr()->layermap[i-1]) && isinRect(x,y,rx,ry,rx+layerpanel_buttonwidth-1,ry+layerpanel_buttonheight-1))
				{
					char tbuf[15];
					
					if(i!=0 && Map.CurrScr()->layermap[i-1])
					{
						if(is_compact)
						{
							sprintf(tbuf, "%s%d %d:%02X",
								(i==2 && Map.CurrScr()->flags7&fLAYER2BG) || (i==3 && Map.CurrScr()->flags7&fLAYER3BG) ? "-":"",
								i, Map.CurrScr()->layermap[i-1], Map.CurrScr()->layerscreen[i-1]);
						}
						else
						{
							sprintf(tbuf, "%s%d (%d:%02X)",
								(i==2 && Map.CurrScr()->flags7&fLAYER2BG) || (i==3 && Map.CurrScr()->flags7&fLAYER3BG) ? "-":"",
								i, Map.CurrScr()->layermap[i-1], Map.CurrScr()->layerscreen[i-1]);
						}
					}
					else
					{
						sprintf(tbuf, "%d", i);
					}
					
					if(do_text_button(rx, ry, layerpanel_buttonwidth, layerpanel_buttonheight, tbuf,vc(1),vc(14),true))
					{
						CurrentLayer = i;
					}
				}
				
				auto cbyofs = (layerpanel_buttonheight-layerpanel_checkbox_hei)/2;
				if(isinRect(x,y,rx+layerpanel_buttonwidth+1,ry+cbyofs,rx+layerpanel_buttonwidth+1+layerpanel_checkbox_wid-1,ry+2+layerpanel_checkbox_hei-1))
					do_checkbox(menu1,rx+layerpanel_buttonwidth+1,ry+cbyofs,layerpanel_checkbox_wid,layerpanel_checkbox_hei,vc(1),vc(14), LayerMaskInt[i]);
			}
			font=tfont;
		}
		
		mouse_down = true;
	}
	else if(gui_mouse_b()&2)
	{
		//on the drawing mode button
		if(is_large)
		{
			if(isinRect(x,y,drawmode_btn.x,drawmode_btn.y,drawmode_btn.x+drawmode_btn.w-1,drawmode_btn.y+drawmode_btn.h-1))
			{
				popup_menu(drawing_mode_menu,x,y);
			}
		}
		
		if(isinRect(x,y,startxint,startyint, int32_t(startx+(256*mapscreensize)-1), int32_t(starty+(176*mapscreensize)-1)))
		{
			ComboBrushPause=1;
			refresh(rMAP);
			restore_mouse();
			ComboBrushPause=0;
			
			bool clickedffc = false;
			uint32_t earliestfreeffc = MAXFFCS;
			
			// FFC right-click menu
			// This loop also serves to find the free ffc with the smallest slot number.
			for(int32_t i=MAXFFCS-1; i>=0; i--)
			{
				auto data = Map.CurrScr()->ffcs[i].getData();
				if(data==0)
				{
					if(i < earliestfreeffc)
						earliestfreeffc = i;
					continue;
				}
				
				if(clickedffc || !(Map.CurrScr()->valid&mVALID))
					continue;
					
				if(data!=0 && (CurrentLayer<2 || (Map.CurrScr()->ffcs[i].flags&ffOVERLAY)))
				{
					int32_t ffx = int32_t(Map.CurrScr()->ffcs[i].x.getFloat());
					int32_t ffy = int32_t(Map.CurrScr()->ffcs[i].y.getFloat());
					int32_t cx2 = (x-startxint)/mapscreensize;
					int32_t cy2 = (y-startyint)/mapscreensize;
					
					if(cx2 >= ffx && cx2 < ffx+(Map.CurrScr()->ffTileWidth(i)*16) && cy2 >= ffy && cy2 < ffy+(Map.CurrScr()->ffTileHeight(i)*16))
					{
						draw_ffc_rc_menu[1].flags = (Map.getCopyFFC()>-1) ? 0 : D_DISABLED;
						
						int32_t m = popup_menu(draw_ffc_rc_menu,x,y);
						
						switch(m)
						{
							case 0:
								Map.CopyFFC(i);
								break;
							
							case 1: // Paste Copied FFC
							{
								if(jwin_alert("Confirm Paste","Really replace the FFC with","the data of the copied FFC?",NULL,"&Yes","&No",'y','n',lfont)==1)
								{
									Map.DoPasteScreenCommand(PasteCommandType::ScreenOneFFC, i);
									saved=false;
								}
							}
							break;
							
							case 2:
								call_ffc_dialog(i);
								break;
							
							case 3:
								if(jwin_alert("Confirm Clear","Really clear this Freeform Combo?",NULL,NULL,"&Yes","&No",'y','n',lfont)==1)
								{
									Map.CurrScr()->ffcs[i].setData(0);
									Map.CurrScr()->ffcCountMarkDirty();
									Map.CurrScr()->ffcs[i].cset = 0;
									Map.CurrScr()->ffcs[i].x = 0;
									Map.CurrScr()->ffcs[i].y = 0;
									Map.CurrScr()->ffcs[i].vx = 0;
									Map.CurrScr()->ffcs[i].vy = 0;
									Map.CurrScr()->ffcs[i].ax = 0;
									Map.CurrScr()->ffcs[i].ay = 0;
									Map.CurrScr()->ffcs[i].flags = 0;
									Map.CurrScr()->ffcs[i].script = 0;
									Map.CurrScr()->ffcs[i].link = 0;
									Map.CurrScr()->ffcs[i].delay = 0;
									Map.CurrScr()->ffcs[i].hxsz = 16;
									Map.CurrScr()->ffcs[i].hysz = 16;
									Map.CurrScr()->ffcs[i].txsz = 1;
									Map.CurrScr()->ffcs[i].tysz = 1;
									
									for(int32_t j=0; j<8; j++)
										Map.CurrScr()->ffcs[i].initd[j] = 0;
										
									for(int32_t j=0; j<2; j++)
										Map.CurrScr()->ffcs[i].inita[j] = 10000;
										
									saved = false;
								}
								break;
							
							case 4: //snap to grid
							{
								int32_t oldffx = Map.CurrScr()->ffcs[i].x.getInt();
								int32_t oldffy = Map.CurrScr()->ffcs[i].y.getInt();
								int32_t pos = COMBOPOS(oldffx,oldffy);
								int32_t newffy = COMBOY(pos);
								int32_t newffx = COMBOX(pos);
								Map.CurrScr()->ffcs[i].x = newffx;
								Map.CurrScr()->ffcs[i].y = newffy;
								saved = false;
								break;
							}
						}
						
						clickedffc = true;
						break;
					}
				}
				
			}
			
			// Combo right-click menu
			if(!clickedffc)
			{
				// FFC-specific options
				if(earliestfreeffc < MAXFFCS)
				{
					sprintf(paste_ffc_menu_text, "Place + Edit FFC %d",earliestfreeffc+1);
					sprintf(paste_ffc_menu_text2,"Paste FFC as FFC %d",earliestfreeffc+1);
					draw_rc_menu[13].text = paste_ffc_menu_text;
					draw_rc_menu[13].flags = 0;
					
					if(Map.getCopyFFC()>-1)
					{
						draw_rc_menu[14].text = paste_ffc_menu_text2;
						draw_rc_menu[14].flags = 0;
					}
					else draw_rc_menu[14].flags = D_DISABLED;
				}
				else
				{
					draw_rc_menu[13].text = (char*)"Place + Edit FFC";
					draw_rc_menu[14].text = (char*)"Paste FFC";
					draw_rc_menu[14].flags = draw_rc_menu[13].flags = D_DISABLED;
				}
				
				int32_t warpindex = Map.warpindex(Map.AbsoluteScr(Map.getCurrMap(), Map.getCurrScr())->data[c]);
				
				if(warpindex > -1)
				{
					sprintf(follow_warp_menu_text, "Follow Tile Warp %c",warpindex==4 ? 'R' : 'A'+warpindex);
					sprintf(follow_warp_menu_text2,"Edit Tile Warp %c",warpindex==4 ? 'R' : 'A'+warpindex);
					draw_rc_menu[10].text = follow_warp_menu_text;
					draw_rc_menu[11].text = follow_warp_menu_text2;
					draw_rc_menu[10].flags = draw_rc_menu[11].flags = 0;
				}
				else
				{
					draw_rc_menu[10].text = (char*)"Follow Tile Warp";
					draw_rc_menu[11].text = (char*)"Edit Tile Warp";
					draw_rc_menu[11].flags = draw_rc_menu[10].flags = D_DISABLED;
				}
				
				int32_t m = popup_menu(draw_rc_menu,x,y); //Contextual Menu: Can get config here to decide which dialogue to use. -Z
				
				switch(m)
				{
					case 0:
					case 1:
					{
						int32_t drawmap, drawscr;
						
						if(CurrentLayer==0)
						{
							drawmap=Map.getCurrMap();
							drawscr=Map.getCurrScr();
						}
						else
						{
							drawmap=Map.CurrScr()->layermap[CurrentLayer-1]-1;
							drawscr=Map.CurrScr()->layerscreen[CurrentLayer-1];
							
							if(drawmap<0)
							{
								return;
							}
						}
						
						if(m==0)
						{
							Combo=Map.AbsoluteScr(drawmap, drawscr)->data[c];
						}
						
						if(m==1||(key[KEY_LSHIFT]||key[KEY_RSHIFT]))
						{
							First[current_combolist]=vbound((Map.AbsoluteScr(drawmap, drawscr)->data[c]/combolist[0].w*combolist[0].w)-(combolist[0].w*combolist[0].h/2),0,MAXCOMBOS-(combolist[0].w*combolist[0].h));
						}
					}
					break;
					
					case 2:
					{
						int32_t drawmap, drawscr;
						
						if(CurrentLayer==0)
						{
						
							drawmap=Map.getCurrMap();
							drawscr=Map.getCurrScr();
						}
						else
						{
							drawmap=Map.CurrScr()->layermap[CurrentLayer-1]-1;
							drawscr=Map.CurrScr()->layerscreen[CurrentLayer-1];
							
							if(drawmap<0)
							{
								return;
							}
						}
						
						edit_combo(Map.AbsoluteScr(drawmap, drawscr)->data[c],true,Map.AbsoluteScr(drawmap, drawscr)->cset[c]);
					}
					break;
					
					case 4:
						replace(c);
						break;
						
					case 10: // Follow Tile Warp
					{
						if(warpindex>=4)
						{
							jwin_alert("Random Tile Warp","This is a random tile warp combo, so it chooses","randomly between the screen's four Tile Warps.",NULL,"O&K",NULL,'k',0,lfont);
							warpindex=zc_oldrand()&3;
						}
						
						int32_t tm = Map.getCurrMap();
						int32_t ts = Map.getCurrScr();
						int32_t wt = Map.CurrScr()->tilewarptype[warpindex];
						
						if(wt==wtCAVE || wt==wtNOWARP)
						{
							char buf[56];
							sprintf(buf,"This screen's Tile Warp %c is set to %s,",'A'+warpindex,warptype_string[wt]);
							jwin_alert(warptype_string[wt],buf,"so it doesn't lead to another screen.",NULL,"O&K",NULL,'k',0,lfont);
							break;
							break;
						}
						
						Map.dowarp(0,warpindex);
						
						if(ts!=Map.getCurrScr() || tm!=Map.getCurrMap())
						{
							FlashWarpSquare = (TheMaps[tm*MAPSCRS+ts].warpreturnc>>(warpindex*2))&3;
							FlashWarpClk = 32;
						}
						
						break;
					}
					
					case 11: // Edit Tile Warp
					{
						if(warpindex>=4)
						{
							jwin_alert("Random Tile Warp","This is a random tile warp combo, so it chooses","randomly between the screen's four Tile Warps.",NULL,"O&K",NULL,'k',0,lfont);
							warpindex=0;
						}
						
						if(warpindex > -1 && warpindex < 4)
							onTileWarpIndex(warpindex);
							
						break;
					}
					
					case 13:
					{
						ffdata tempdat;
						tempdat.x = (((x-startxint)&(~0x000F))/mapscreensize)*10000;
						tempdat.y = (((y-startyint)&(~0x000F))/mapscreensize)*10000;
						tempdat.data = Combo;
						tempdat.cset = CSet;
						call_ffc_dialog(earliestfreeffc, tempdat);
					}
					break;
					
					case 14:
					{
						Map.CurrScr()->ffcs[earliestfreeffc].x = (((x-startxint)&(~0x000F))/mapscreensize);
						Map.CurrScr()->ffcs[earliestfreeffc].y = (((y-startyint)&(~0x000F))/mapscreensize);
						Map.DoPasteScreenCommand(PasteCommandType::ScreenOneFFC, earliestfreeffc);
					}
					break;
					
					default:
						break;
				}
			}
		}
		
		for(int32_t j=0; j<num_combo_cols; ++j)
		{
			if(draw_mode == dm_alias)
			{
				if(isinRect(x,y,comboaliaslist[j].x,comboaliaslist[j].y,comboaliaslist[j].x+(comboaliaslist[j].w*comboaliaslist[j].xscale)-1,comboaliaslist[j].y+(comboaliaslist[j].h*comboaliaslist[j].yscale)-1))
				{
					select_comboa(j);
					
					if(isinRect(gui_mouse_x(),gui_mouse_y(),comboaliaslist[j].x,comboaliaslist[j].y,comboaliaslist[j].x+(comboaliaslist[j].w*comboaliaslist[j].xscale)-1,comboaliaslist[j].y+(comboaliaslist[j].h*comboaliaslist[j].yscale)-1))
					{
						comboa_cnt = combo_apos;
						onEditComboAlias();
						redraw|=rALL;
					}
				}
			}
			else if(draw_mode == dm_cpool)
			{
				if(isinRect(x,y,comboaliaslist[j].x,comboaliaslist[j].y,comboaliaslist[j].x+(comboaliaslist[j].w*comboaliaslist[j].xscale)-1,comboaliaslist[j].y+(comboaliaslist[j].h*comboaliaslist[j].yscale)-1))
				{
					select_combop(j);
					
					if(isinRect(gui_mouse_x(),gui_mouse_y(),comboaliaslist[j].x,comboaliaslist[j].y,comboaliaslist[j].x+(comboaliaslist[j].w*comboaliaslist[j].xscale)-1,comboaliaslist[j].y+(comboaliaslist[j].h*comboaliaslist[j].yscale)-1))
					{
						onEditComboPool();
						redraw|=rALL;
					}
				}
			}
			else
			{
				if(isinRect(x,y,combolist[j].x,combolist[j].y,combolist[j].x+(combolist[j].w*combolist[j].xscale)-1,combolist[j].y+(combolist[j].h*combolist[j].yscale)-1))
				{
					select_combo(j);
					
					if(isinRect(gui_mouse_x(),gui_mouse_y(),combolist[j].x,combolist[j].y,combolist[j].x+(combolist[j].w*combolist[j].xscale)-1,combolist[j].y+(combolist[j].h*combolist[j].yscale)-1))
					{
						int32_t m = popup_menu(combosel_rc_menu,x,y);
						
						switch(m)
						{
						case 0:
							reset_combo_animations();
							reset_combo_animations2();
							edit_combo(Combo,true,CSet);
							setup_combo_animations();
							setup_combo_animations2();
							redraw|=rALL;
							break;
							
						case 1:
							combo_screen(Combo>>8,Combo);
							redraw|=rALL;
							break;
							
						case 2:
						{
							int32_t t = combobuf[Combo].tile;
							int32_t f = 0;
							select_tile(t,f,0,CSet,true);
							redraw|=rALL;
							break;
						}
						
						case 3:
							onComboLocationReport();
							break;
							
						case 5:
						{
							onGotoPage();
							redraw|=rALL;
							break;
						}
						break;
						}
					}
				}
			}
		}
		
		// Right click main panel
		if(is_large)
		{
			if(itemsqr_pos.rect(x,y))
			{
				onItem();
			}
		}
		else
		{
			if(menutype==m_coords)
			{
				if(isinRect(x,y,panel[0].x+16,panel[0].y+6,panel[0].x+16+15,panel[0].y+6+15))
				{
					onItem();
				}
			}
		}
		
		if(is_large)
		{
			for(int32_t cmd=0; cmd<(commands_list.w*commands_list.h); ++cmd)
			{
				int32_t check_x=(cmd%commands_list.w)*commands_list.xscale+commands_list.x;
				int32_t check_y=(cmd/commands_list.w)*commands_list.yscale+commands_list.y;
				
				if(isinRect(x,y,check_x,check_y,check_x+commands_list.xscale,check_y+commands_list.yscale))
				{
					FONT *tfont=font;
					font=pfont;
					
					if(do_layer_button_reset(check_x,
						check_y,
						commands_list.xscale,
						commands_list.yscale,
						favorite_commands[cmd]==cmdCatchall&&strcmp(catchall_string[Map.CurrScr()->room]," ")
							? catchall_string[Map.CurrScr()->room]
							: commands[favorite_commands[cmd]].name,
						isFavCmdSelected(favorite_commands[cmd])?D_SELECTED:0,
						true))
					{
						write_fav_command(cmd,onCommand(favorite_commands[cmd]));
					}
					
					font=tfont;
				}
			}
			
			if(isinRect(x,y,favorites_list.x,favorites_list.y,favorites_list.x+(favorites_list.w*16)-1,favorites_list.y+(favorites_list.h*16)-1))
			{
				bool valid=select_favorite();
				
				if(valid)
				{
					if(isinRect(gui_mouse_x(),gui_mouse_y(),favorites_list.x,favorites_list.y,favorites_list.x+(favorites_list.w*16)-1,favorites_list.y+(favorites_list.h*16)-1))
					{
						SETFLAG(fav_rc_menu[4].flags, D_DISABLED, draw_mode == dm_alias);
						SETFLAG(fav_rc_menu[5].flags, D_DISABLED, draw_mode == dm_alias);
						int32_t m = popup_menu(fav_rc_menu,x,y);
						int32_t row=vbound(((y-favorites_list.y)>>4),0,favorites_list.h-1);
						int32_t col=vbound(((x-favorites_list.x)>>4),0,favorites_list.w-1);
						int32_t f=(row*FAVORITECOMBO_PER_ROW)+col;
						
						switch(m)
						{
							case 0:
								First[current_combolist]=vbound((Combo/combolist[0].w*combolist[0].w)-(combolist[0].w*combolist[0].h/2),0,MAXCOMBOS-(combolist[0].w*combolist[0].h));
								break;
								
							case 1:
								if(draw_mode != dm_alias)
								{
									reset_combo_animations();
									reset_combo_animations2();
									edit_combo(Combo,true,CSet);
									setup_combo_animations();
									setup_combo_animations2();
								}
								else
								{
									comboa_cnt = combo_apos;
									onEditComboAlias();
								}
								
								redraw|=rALL;
								break;
								
							case 2:
								if(draw_mode == dm_alias)
								{
									favorite_comboaliases[f]=-1;
									saved = false;
								}
								else
								{
									favorite_combos[f]=-1;
									saved = false;
								}
								
								break;
							case 4:
								combo_screen(Combo>>8,Combo);
								redraw|=rALL;
								break;
							case 5:
							{
								int32_t t = combobuf[Combo].tile;
								int32_t f = 0;
								select_tile(t,f,0,CSet,true);
								redraw|=rALL;
								break;
							}
						}
					}
				}
			}
		}
		else
		{
			if((isinRect(x,y,panel[0].x+panel[0].w-28,panel[0].y+32,panel[0].x+panel[0].w-28+24,panel[0].y+32+5) && menutype==m_block && !mouse_down) ||
			   (isinRect(x,y,panel[6].x+panel[6].w-28,panel[6].y+36,panel[6].x+panel[6].w-28+24,panel[6].y+36+5) && menutype==m_layers && !mouse_down))
			{
				CSet=wrap(CSet-1,0,11);
				refresh(rCOMBOS+rMENU+rCOMBO);
			}
			
			if(isinRect(x,y,panel[0].x+panel[0].w-32,panel[0].y+39,panel[0].x+panel[0].w-32+28,panel[0].y+39+5) && menutype==m_block && !mouse_down)
			{
				bool validlayer=false;
				
				while(!validlayer)
				{
					CurrentLayer=wrap(CurrentLayer-1,0,6);
					
					if((CurrentLayer==0)||(Map.CurrScr()->layermap[CurrentLayer-1]))
					{
						validlayer=true;
					}
				}
				
				refresh(rMENU);
			}
		}
		
		mouse_down = true;
	}
	else if(gui_mouse_b()&4)  //not sure what to do here yet
	{
	}
	
	if(mouse_z!=0)
	{
		int32_t z=0;
		
		for(int32_t j=0; j<num_combo_cols; ++j)
		{
			z=abs(mouse_z);
			
			if(key[KEY_ALT]||key[KEY_ALTGR])
			{
				z*=combolist[j].h;
			}
			
			
			if(draw_mode == dm_alias)
			{
				if(isinRect(x,y,comboaliaslist[j].x,comboaliaslist[j].y,comboaliaslist[j].x+(comboaliaslist[j].w*comboaliaslist[j].xscale)-1,comboaliaslist[j].y+(comboaliaslist[j].h*comboaliaslist[j].yscale)-1))
				{
					if(mouse_z<0)  //scroll down
					{
						combo_alistpos[current_comboalist] = zc_min(MAXCOMBOALIASES - comboaliaslist[j].w*comboaliaslist[j].h,
															 combo_alistpos[current_comboalist]+comboaliaslist[j].w*z);
						redraw|=rALL;
					}
					else //scroll up
					{
						if(combo_alistpos[current_comboalist]>0)
						{
							combo_alistpos[current_comboalist]-=zc_min(combo_alistpos[current_comboalist],comboaliaslist[j].w*z);
							//          refresh(rCOMBOS);
							redraw|=rALL;
						}
					}
				}
			}
			else if(draw_mode == dm_cpool)
			{
				if(isinRect(x,y,comboaliaslist[j].x,comboaliaslist[j].y,comboaliaslist[j].x+(comboaliaslist[j].w*comboaliaslist[j].xscale)-1,comboaliaslist[j].y+(comboaliaslist[j].h*comboaliaslist[j].yscale)-1))
				{
					if(mouse_z<0)  //scroll down
					{
						combo_pool_listpos[current_cpoollist] = zc_min(MAXCOMBOPOOLS - comboaliaslist[j].w*comboaliaslist[j].h,
															 combo_pool_listpos[current_cpoollist]+comboaliaslist[j].w*z);
						redraw|=rALL;
					}
					else //scroll up
					{
						if(combo_pool_listpos[current_cpoollist]>0)
						{
							combo_pool_listpos[current_cpoollist]-=zc_min(combo_pool_listpos[current_cpoollist],comboaliaslist[j].w*z);
							//          refresh(rCOMBOS);
							redraw|=rALL;
						}
					}
				}
			}
			else
			{
				if(isinRect(x,y,combolist[j].x,combolist[j].y,combolist[j].x+(combolist[j].w*comboaliaslist[j].xscale)-1,combolist[j].y+(combolist[j].h*comboaliaslist[j].yscale)-1))
				{
					if(mouse_z<0)  //scroll down
					{
						First[current_combolist] = zc_min(MAXCOMBOS-combolist[j].w*combolist[j].h,
														  First[current_combolist] + combolist[j].w*z);
						redraw|=rALL;
					}
					else //scroll up
					{
						if(First[current_combolist]>0)
						{
							First[current_combolist]-=zc_min(First[current_combolist],combolist[j].w*z);
							//          refresh(rCOMBOS);
							redraw|=rALL;
						}
					}
				}
			}
		}
		
		z=abs(mouse_z);
		
		if((!is_large && isinRect(x,y,minimap.x,minimap.y+8,minimap.x+63,minimap.y+8+35)) ||
		   (is_large && isinRect(x,y,minimap.x,minimap.y+8,minimap.x+145,minimap.y+8+85)))
		{
			for(int32_t i=0; i<z; ++i)
			{
				if(mouse_z>0) onIncMap();
				else onDecMap();
			}
		}
		
		if(isinRect(x,y,panel[0].x,panel[0].y,panel[0].x+191,panel[0].y+47) && !is_large)
		{
			for(int32_t i=0; i<z; ++i)
			{
				if(mouse_z>0)
				{
					onPgUp();
				}
				else
				{
					onPgDn();
				}
			}
		}
		
		position_mouse_z(0);
	}
}

int32_t d_viewpal_proc(int32_t msg, DIALOG *d, int32_t c)
{
	int32_t ret = d_bitmap_proc(msg, d, c);
	char* buf = (char*)d->dp2; //buffer to store the color code in
	DIALOG* d2 = (DIALOG*)d->dp3; //DIALOG* to update the text proc
	if(!buf)
		return ret;
	switch(msg)
	{
		case MSG_IDLE:
		case MSG_GOTMOUSE:
		case MSG_LOSTMOUSE:
			break;
		default:
			return ret;
	}
	char t[16];
	memcpy(t, buf, 16);
	int32_t x = gui_mouse_x() - d->x;
	int32_t y = gui_mouse_y() - d->y;
	if(msg != MSG_LOSTMOUSE && isinRect(x, y, 0, 0, d->w-1, d->h-1))
	{
		float palscale = is_large ? 1.5 : 1;
		for(int32_t i = 0; i<256; ++i)
			if(isinRect(x,y,(int32_t)(((i&31)<<3)*palscale),(int32_t)(((i&0xE0)>>2)*palscale), (int32_t)((((i&31)<<3)+7)*palscale),(int32_t)((((i&0xE0)>>2)+7)*palscale)))
			{
				sprintf(buf, "0x%02X (%03d)     ", i, i); //Extra spaces to increase drawn width, so it draws the blank area
				break;
			}
	}
	else memset(buf, ' ', 15);
	if(strcmp(buf, t) && d2 && d2->proc == jwin_text_proc && d2->dp == d->dp2)
		object_message(d2, MSG_DRAW, 0);
	return ret;
}

static DIALOG showpal_dlg[] =
{
	/* (dialog proc)     (x)     (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp) */
	{ jwin_win_proc,     24,      68,  272,  119,  vc(14),  vc(1),      0,    D_EXIT,        0,             0, (void *) "View Palette",        NULL,  NULL },
	{ jwin_frame_proc,   30,   76+16,  260,   68,       0,      0,      0,         0,  FR_DEEP,             0, NULL,                           NULL,  NULL },
	{ d_viewpal_proc,    32,   76+18,  256,   64,       0,      0,      0,         0,        0,             0, NULL,                           NULL,  NULL },
	{ jwin_text_proc,  32+8,76+18+66,   20,    8,  vc(11),  vc(1),      0,         0,        0,             0, NULL,                           NULL,  NULL },
	{ jwin_button_proc, 130,  144+18,   61,   21,  vc(14),  vc(1),     27,    D_EXIT,        0,             0, (void *) "OK",                  NULL,  NULL },
	{ d_timer_proc,       0,       0,    0,    0,       0,      0,      0,         0,        0,             0, NULL,                           NULL,  NULL },
	{ NULL,               0,       0,    0,    0,       0,      0,      0,         0,        0,             0, NULL,                           NULL,  NULL }
};

int32_t onShowPal()
{
	float palscale = is_large ? 1.5 : 1;
	
	BITMAP *palbmp = create_bitmap_ex(8,(int32_t)(256*palscale),(int32_t)(64*palscale));
	
	if(!palbmp)
		return D_O_K;
	clear_to_color(palbmp,jwin_pal[jcBOX]); //If not cleared, random static appears between swatches! -E
	showpal_dlg[0].dp2=lfont;
	
	for(int32_t i=0; i<256; i++)
		rectfill(palbmp,(int32_t)(((i&31)<<3)*palscale),(int32_t)(((i&0xE0)>>2)*palscale), (int32_t)((((i&31)<<3)+7)*palscale),(int32_t)((((i&0xE0)>>2)+7)*palscale),i);
	showpal_dlg[2].dp=(void *)palbmp;
	char buf[16] = {0};
	showpal_dlg[2].dp2=(void *)buf;
	showpal_dlg[2].dp3=(void *)&(showpal_dlg[3]);
	showpal_dlg[3].dp=(void *)buf;
	showpal_dlg[3].dp2=(void *)deffont;
	
	if(is_large)
		large_dialog(showpal_dlg);
	zc_popup_dialog(showpal_dlg,2);
	destroy_bitmap(palbmp);
	return D_O_K;
}

static DIALOG csetfix_dlg[] =
{
    /* (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp) */
    { jwin_win_proc,        72,   80,   176+1,  96+1,   vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "CSet Fix", NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { jwin_radio_proc,      104+22,  108,  80+1,   8+1,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Full Screen", NULL, NULL },
    { jwin_radio_proc,      104+22,  118+2,  80+1,   8+1,    vc(14),  vc(1),  0,       D_SELECTED, 0,             0, (void *) "Dungeon Floor", NULL, NULL },
    { d_dummy_proc,         120,  128,  80+1,   8+1,    vc(14),  vc(1),  0,       0,          1,             0,       NULL, NULL, NULL },
    { jwin_check_proc,      104+22,  128+4,  80+1,   8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "All Layers", NULL, NULL },
    { jwin_button_proc,     90,   152,  61,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "OK", NULL, NULL },
    { jwin_button_proc,     170,  152,  61,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

int32_t onCSetFix()
{
    restore_mouse();
    csetfix_dlg[0].dp2=lfont;
    int32_t s=2,x2=14,y2=9;
    
    if(is_large)
        large_dialog(csetfix_dlg);
        
    if(zc_popup_dialog(csetfix_dlg,-1)==6)
    {
        if(csetfix_dlg[2].flags&D_SELECTED)
        {
            s=0;
            x2=16;
            y2=11;
        }
        
        if(csetfix_dlg[5].flags&D_SELECTED)
        {
            /*
              int32_t drawmap, drawscr;
              if (CurrentLayer==0)
              {
              drawmap=Map.getCurrMap();
              drawscr=Map.getCurrScr();
              }
              else
              {
              drawmap=Map.CurrScr()->layermap[CurrentLayer-1]-1;
              drawscr=Map.CurrScr()->layerscreen[CurrentLayer-1];
              if (drawmap<0)
              {
              return;
              }
              }
            
              saved=false;
              Map.Ugo();
            
              if(!(Map.AbsoluteScr(drawmap, drawscr)->valid&mVALID))
              {
              Map.CurrScr()->valid|=mVALID;
              Map.AbsoluteScr(drawmap, drawscr)->valid|=mVALID;
              Map.setcolor(Color);
              }
              for(int32_t i=0; i<176; i++)
              {
              Map.AbsoluteScr(drawmap, drawscr)->data[i]=Combo;
              Map.AbsoluteScr(drawmap, drawscr)->cset[i]=CSet;
              }
              refresh(rMAP+rSCRMAP);
              */
        }
        
        Map.StartListCommand();
        for(int32_t y=s; y<y2; y++)
        {
            for(int32_t x=s; x<x2; x++)
            {
                Map.DoSetComboCommand(Map.getCurrMap(), Map.getCurrScr(), (y<<4)+x, -1, CSet);
            }
        }
        Map.FinishListCommand();
        
        refresh(rMAP);
        saved = false;
    }
    
    return D_O_K;
}
static bool doAllSolidWater()
{
	for(int32_t i=0; i < MAXCOMBOS; ++i)
	{
		if(combo_class_buf[combobuf[i].type].water!=0)
		{
			combobuf[i].walk |= 0x0F; //Solid
		}
	}
	return true;
}
static bool doNoSolidWater()
{
	for(int32_t i=0; i < MAXCOMBOS; ++i)
	{
		if(combo_class_buf[combobuf[i].type].water!=0)
		{
			combobuf[i].walk &= ~0x0F; //Non-solid
		}
	}
	return true;
}
int32_t onWaterSolidity()
{
	AlertFuncDialog("Water Conversion",
		"Forcibly set the solidity of all 'Liquid' combos in the quest?",
		3, 2, //3 buttons, where buttons[2] is focused
		"Solid", doAllSolidWater,
		"Non-Solid", doNoSolidWater,
		"Cancel", NULL
	).show();
    return D_O_K;
}

static bool doAllEffectSquare()
{
	for(int32_t i=0; i < MAXCOMBOS; ++i)
	{
		combobuf[i].walk |= 0xF0; //Effect
	}
	return true;
}
static bool doBlankEffectSquare()
{
	for(int32_t i=0; i < MAXCOMBOS; ++i)
	{
		if(combobuf[i].is_blank(true))
		{
			combobuf[i].walk |= 0xF0; //Effect
		}
	}
	return true;
}

int32_t onEffectFix()
{
	AlertFuncDialog("Effect Square Conversion",
		"Forcibly fill the green effect square of all combos in the quest?",
		3, 2, //3 buttons, where buttons[2] is focused
		"All", doAllEffectSquare,
		"Blank Only", doBlankEffectSquare,
		"Cancel", NULL
	).show();
    return D_O_K;
}

byte* getPalPointer(int32_t pal, int32_t cset)
{
	if (pal < 0) return colordata + CSET(cset)*3;
	byte* ret = colordata + CSET(pal*pdLEVEL+poLEVEL)*3;
	switch(cset)
	{
		case 2: case 3: case 4:
			return ret + CSET(cset-2)*3;
		case 9:
			return ret + CSET(3)*3;
		case 1:
			return ret + CSET(13)*3;
		case 5:
			return ret + CSET(14)*3;
		case 7:
			return ret + CSET(15)*3;
		case 8:
			return ret + CSET(16)*3;
	}
	return NULL;
}

void copyCSet(int32_t destpal, int32_t destcset, int32_t srcpal, int32_t srccset)
{
	byte* dest = getPalPointer(destpal, destcset);
	byte* src = getPalPointer(srcpal, srccset);
	if (dest && src)
	{
		memcpy(dest, src, 16*3);
	}
}

void setColorPalette(int32_t flags, int32_t lowpal, int32_t highpal)
{
	for (auto q = lowpal; q <= highpal; ++q)
	{
		for (auto c = 0; c < 12; ++c)
		{
			if (!(flags&(1<<c))) continue;
			copyCSet(q, c, -1, c);
		}
	}
}

void setPitDamage(int32_t flags, int32_t lowcombo, int32_t highcombo, int32_t damage)
{
	for(int32_t i=lowcombo; i < highcombo; ++i)
	{
		if((combobuf[i].type == cPITFALL && (flags & (1<<0)))
		|| (combobuf[i].type == cWATER && !(combobuf[i].usrflags & (1<<0)) && (flags & (1<<1)))
		|| (combobuf[i].type == cWATER && (combobuf[i].usrflags & (1<<0)) && (flags & (1<<2))))
		{
			if ((combobuf[i].type != cPITFALL || (flags & (1<<9)) || !(combobuf[i].usrflags & (1<<0)))
			&& ((flags & (1<<8)) || combobuf[i].attributes[0] == 0))
				combobuf[i].attributes[0] = damage*10000; 
		}
	}
}

static DIALOG template_dlg[] =
{
    /* (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp) */
    { jwin_win_proc, 72,   80,   176+1,  116+1,   vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "NES Dungeon Template", NULL, NULL },
    { d_comboframe_proc,   178,  122+3,  20,  20,   0,       0,      0,       0,             FR_DEEP,       0,       NULL, NULL, NULL },
    { d_combo_proc,      180,  124+3,  16,   16,   0,       0,      0,       0,          0,             0,       NULL, NULL, NULL },
    //  { d_bitmap_proc,     180,  104,  16,   16,   0,       0,      0,       0,          0,             0,       NULL, NULL, NULL },
    { jwin_radio_proc,      104+33,  128+3,  64+1,   8+1,    vc(14),  vc(1),  0,       D_SELECTED, 0,             0, (void *) "Floor:", NULL, NULL },
    { jwin_radio_proc,      104+33,  148+3,  64+1,   8+1,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "No Floor", NULL, NULL },
    { jwin_button_proc,     90,   172,  61,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "OK", NULL, NULL },
    { jwin_button_proc,     170,  172,  61,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { jwin_text_proc,       104,  102,    16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "This copies the contents of",        NULL,   NULL },
    { jwin_text_proc,       104,  112,    16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "screen 83 of the current map.",    NULL,   NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

int32_t onTemplate()
{
    static bool donethis=false;
    
    if(!donethis||!(key[KEY_LSHIFT]||key[KEY_RSHIFT]))
    {
        template_dlg[2].d1=Combo;
        template_dlg[2].fg=CSet;
        donethis=true;
    }
    
    restore_mouse();
    
    if(Map.getCurrScr()==TEMPLATE)
        return D_O_K;
        
    //  BITMAP *floor_bmp = create_bitmap_ex(8,16,16);
    //  if(!floor_bmp) return D_O_K;
    template_dlg[0].dp2=lfont;
    //  put_combo(floor_bmp,0,0,Combo,CSet,0,0);
    //  template_dlg[2].dp=floor_bmp;
    
    if(is_large)
        large_dialog(template_dlg);
        
    if(zc_popup_dialog(template_dlg,-1)==5)
    {
        saved=false;
        Map.DoTemplateCommand((template_dlg[3].flags==D_SELECTED) ? template_dlg[2].d1 : -1, template_dlg[2].fg, Map.getCurrScr());
        refresh(rMAP+rSCRMAP);
    }
    
    //  destroy_bitmap(floor_bmp);
    return D_O_K;
}

static DIALOG cpage_dlg[] =
{
    /* (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp) */
    { jwin_win_proc, 72,   20,   176+1,  212+1,  vc(14),  vc(1),  0,       0,          0,             0,       NULL, NULL, NULL },
    { d_ctext2_proc,      160,  28,     0,  8,    vc(15),  vc(1),  0,       0,          0,             0, (void *) "Combo Page", NULL, NULL },
    { jwin_button_proc,     90,   182,  61,   21,   vc(14),  vc(1),  's',     D_EXIT,     0,             0, (void *) "&Set", NULL, NULL },
    { jwin_button_proc,     170,  182,  61,   21,   vc(14),  vc(1),  'c',     D_EXIT,     0,             0, (void *) "&Cancel", NULL, NULL },
    { jwin_button_proc,     90,   210,  61,   21,   vc(14),  vc(1),  'a',     D_EXIT,     0,             0, (void *) "Set &All", NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,       0,      0,       0,          KEY_F1,        0, (void *) onHelp, NULL, NULL },
    // 6
    { jwin_radio_proc,       76,  44,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "0"  , NULL, NULL },
    { jwin_radio_proc,       76,  52,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "1"  , NULL, NULL },
    { jwin_radio_proc,       76,  60,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "2"  , NULL, NULL },
    { jwin_radio_proc,       76,  68,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "3"  , NULL, NULL },
    { jwin_radio_proc,       76,  76,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "4"  , NULL, NULL },
    { jwin_radio_proc,       76,  84,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "5"  , NULL, NULL },
    { jwin_radio_proc,       76,  92,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "6"  , NULL, NULL },
    { jwin_radio_proc,       76, 100,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "7"  , NULL, NULL },
    { jwin_radio_proc,       76, 108,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "8"  , NULL, NULL },
    { jwin_radio_proc,       76, 116,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "9"  , NULL, NULL },
    { jwin_radio_proc,       76, 124,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "10" , NULL, NULL },
    { jwin_radio_proc,       76, 132,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "11" , NULL, NULL },
    { jwin_radio_proc,       76, 140,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "12" , NULL, NULL },
    { jwin_radio_proc,       76, 148,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "13" , NULL, NULL },
    { jwin_radio_proc,       76, 156,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "14" , NULL, NULL },
    { jwin_radio_proc,       76, 164,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "15" , NULL, NULL },
    { jwin_radio_proc,      120,  44,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "16" , NULL, NULL },
    { jwin_radio_proc,      120,  52,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "17" , NULL, NULL },
    { jwin_radio_proc,      120,  60,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "18" , NULL, NULL },
    { jwin_radio_proc,      120,  68,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "19" , NULL, NULL },
    { jwin_radio_proc,      120,  76,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "20" , NULL, NULL },
    { jwin_radio_proc,      120,  84,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "21" , NULL, NULL },
    { jwin_radio_proc,      120,  92,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "22" , NULL, NULL },
    { jwin_radio_proc,      120, 100,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "23" , NULL, NULL },
    { jwin_radio_proc,      120, 108,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "24" , NULL, NULL },
    { jwin_radio_proc,      120, 116,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "25" , NULL, NULL },
    { jwin_radio_proc,      120, 124,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "26" , NULL, NULL },
    { jwin_radio_proc,      120, 132,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "27" , NULL, NULL },
    { jwin_radio_proc,      120, 140,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "28" , NULL, NULL },
    { jwin_radio_proc,      120, 148,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "29" , NULL, NULL },
    { jwin_radio_proc,      120, 156,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "30" , NULL, NULL },
    { jwin_radio_proc,      120, 164,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "31" , NULL, NULL },
    { jwin_radio_proc,      164,  44,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "32" , NULL, NULL },
    { jwin_radio_proc,      164,  52,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "33" , NULL, NULL },
    { jwin_radio_proc,      164,  60,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "34" , NULL, NULL },
    { jwin_radio_proc,      164,  68,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "35" , NULL, NULL },
    { jwin_radio_proc,      164,  76,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "36" , NULL, NULL },
    { jwin_radio_proc,      164,  84,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "37" , NULL, NULL },
    { jwin_radio_proc,      164,  92,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "38" , NULL, NULL },
    { jwin_radio_proc,      164, 100,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "39" , NULL, NULL },
    { jwin_radio_proc,      164, 108,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "40" , NULL, NULL },
    { jwin_radio_proc,      164, 116,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "41" , NULL, NULL },
    { jwin_radio_proc,      164, 124,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "42" , NULL, NULL },
    { jwin_radio_proc,      164, 132,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "43" , NULL, NULL },
    { jwin_radio_proc,      164, 140,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "44" , NULL, NULL },
    { jwin_radio_proc,      164, 148,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "45" , NULL, NULL },
    { jwin_radio_proc,      164, 156,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "46" , NULL, NULL },
    { jwin_radio_proc,      164, 164,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "47" , NULL, NULL },
    { jwin_radio_proc,      208,  44,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "48" , NULL, NULL },
    { jwin_radio_proc,      208,  52,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "49" , NULL, NULL },
    { jwin_radio_proc,      208,  60,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "50" , NULL, NULL },
    { jwin_radio_proc,      208,  68,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "51" , NULL, NULL },
    { jwin_radio_proc,      208,  76,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "52" , NULL, NULL },
    { jwin_radio_proc,      208,  84,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "53" , NULL, NULL },
    { jwin_radio_proc,      208,  92,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "54" , NULL, NULL },
    { jwin_radio_proc,      208, 100,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "55" , NULL, NULL },
    { jwin_radio_proc,      208, 108,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "56" , NULL, NULL },
    { jwin_radio_proc,      208, 116,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "57" , NULL, NULL },
    { jwin_radio_proc,      208, 124,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "58" , NULL, NULL },
    { jwin_radio_proc,      208, 132,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "59" , NULL, NULL },
    { jwin_radio_proc,      208, 140,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "60" , NULL, NULL },
    { jwin_radio_proc,      208, 148,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "61" , NULL, NULL },
    { jwin_radio_proc,      208, 156,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "62" , NULL, NULL },
    { jwin_radio_proc,      208, 164,   33,   9,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "63" , NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

int32_t onComboPage()
{
    for(int32_t i=0; i<64; i++)
        cpage_dlg[i+6].flags = Map.CurrScr()->old_cpage==i?D_SELECTED:0;
        
    int32_t ret = zc_popup_dialog(cpage_dlg,3);
    
    int32_t p = 0;
    
    for(int32_t i=0; i<64; i++)
    
        if(cpage_dlg[i+6].flags==D_SELECTED)
            p=i;
            
    if(ret==2)
    {
        saved=false;
        Map.CurrScr()->old_cpage = p;
    }
    
    if(ret==4 && jwin_alert("Confirm Overwrite","Set all combo pages","on this map?",NULL,"&Yes","&No",'y','n',lfont)==1)
    {
        saved=false;
        
        for(int32_t i=0; i<=TEMPLATE; i++)
            Map.Scr(i)->old_cpage = p;
    }
    
    refresh(rALL);
    return D_O_K;
}

int32_t d_sel_scombo_proc(int32_t msg, DIALOG *d, int32_t c)
{
    //these are here to bypass compiler warnings about unused arguments
    c=c;
    
    switch(msg)
    {
    case MSG_CLICK:
        while(gui_mouse_b())
        {
            int32_t x = zc_min(zc_max(gui_mouse_x() - d->x,0)>>4, 15);
            int32_t y = zc_min(zc_max(gui_mouse_y() - d->y,0)&0xF0, 160);
            
            if(x+y != d->d1)
            {
                d->d1 = x+y;
                custom_vsync();
                scare_mouse();
                d_sel_scombo_proc(MSG_DRAW,d,0);
                unscare_mouse();
            }
        }
        
        break;
        
    case MSG_DRAW:
    {
        blit((BITMAP*)(d->dp),screen,0,0,d->x,d->y,d->w,d->h);
        int32_t x = d->x + (((d->d1)&15)<<4);
        int32_t y = d->y + ((d->d1)&0xF0);
        rect(screen,x,y,x+15,y+15,vc(15));
    }
    break;
    }
    
    return D_O_K;
}

/*
static DIALOG sel_scombo_dlg[] =
{
  // (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp)
  { jwin_win_proc, 24,   16,   272+1,  216+1,  vc(14),  vc(1),  0,       0,          0,             0,       NULL, NULL, NULL },
  { d_sel_scombo_proc, 32,   24,   256,  176,  0,       0,      0,       0,          0,             0,       NULL, NULL, NULL },
  { jwin_button_proc,     90,   208,  61,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0,       (void *) "OK", NULL, NULL },
  { jwin_button_proc,     170,  208,  61,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0,       (void *) "Cancel", NULL, NULL },
  { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
  { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

void select_scombo(int32_t &pos)
{
  go();
  Map.draw_template2(screen2,0,0);
  sel_scombo_dlg[1].dp = screen2;
  sel_scombo_dlg[1].d1 = pos;

  while (gui_mouse_b()) {
    //nothing
  }

  if(zc_do_dialog(sel_scombo_dlg,3)==2)
    pos = sel_scombo_dlg[1].d1;

  comeback();
}
*/

static DIALOG cflag_dlg[] =
{
    // (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp)
    { jwin_win_proc,     60-12,   40,   200+24,  148,  vc(14),  vc(1),  0,       D_EXIT,          0,             0,       NULL, NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { jwin_abclist_proc,       72-12-4,   60+4,   176+24+8,  92+3,   jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,       D_EXIT,     0,             0,       NULL, NULL, NULL },
    { jwin_button_proc,     70,   163,  51,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "OK", NULL, NULL },
    { jwin_button_proc,     190,  163,  51,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { jwin_button_proc,     130,  163,  51,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Help", NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};


void questrev_help()
{
	jwin_alert("Help","The revision number of your quest.",NULL,NULL,"O&K",NULL,'k',16,lfont);
}

void questminrev_help()
{
	jwin_alert("Help","If a player's saved game was from a revision less than the minimum", "revision, they have to restart from the beginning.", "This is useful if you make major changes to your quest.","O&K",NULL,'k',16,lfont);
}

int32_t select_cflag(const char *prompt,int32_t flag)
{
    cflag_dlg[0].dp=(void *)prompt;
    cflag_dlg[0].dp2=lfont;
    GUI::ListData ld = GUI::ZCListData::mapflag(numericalFlags, true);
	ListData select_cflag_list = ld.getJWin(&font);
    int32_t index = ld.findIndex(flag);
	cflag_dlg[2].d1=index;
	cflag_dlg[2].dp=(void *) &select_cflag_list;
    
    if(is_large)
        large_dialog(cflag_dlg);
        
    int32_t ret;
    
    do
    {
        ret=zc_popup_dialog(cflag_dlg,2);
        
        if(ret==5)
        {
            cflag_help(ld.getValue(cflag_dlg[2].d1));
        }
    }
    while(ret==5);
    
    if(ret==0||ret==4)
    {
        position_mouse_z(0);
        return -1;
    }
    
    return ld.getValue(cflag_dlg[2].d1);
}

int32_t select_flag(int32_t &f)
{
    int32_t ret=select_cflag("Flag Type",f);
    
    if(ret>=0)
    {
        f=ret;
        return true;
    }
    
    return false;
}

int32_t d_scombo_proc(int32_t msg,DIALOG *d,int32_t c)
{
    //these are here to bypass compiler warnings about unused arguments
    c=c;
    
    switch(msg)
    {
    case MSG_CLICK:
    {
        int32_t c2=d->d1;
        int32_t cs=d->fg;
        int32_t f=d->d2;
        
        if(d->bg==1 || (key[KEY_ZC_LCONTROL] || key[KEY_ZC_RCONTROL]))
        {
            while(gui_mouse_b())
            {
                /* do nothing */
                rest(1);
            }
            
            if(select_flag(f))
            {
                d->d2=f;
                
            }
        }
        else if(key[KEY_LSHIFT])
        {
            if(gui_mouse_b()&1)
            {
                d->d1++;
                
                if(d->d1>=MAXCOMBOS) d->d1=0;
            }
            else if(gui_mouse_b()&2)
            {
                d->d1--;
                
                if(d->d1<0) d->d1=MAXCOMBOS-1;
            }
        }
        else if(key[KEY_RSHIFT])
        {
            if(gui_mouse_b()&1)
            {
                d->fg++;
                
                if(d->fg>11) d->fg=0;
            }
            else if(gui_mouse_b()&2)
            {
                d->fg--;
                
                if(d->fg<0) d->fg=11;
            }
        }
        else if(key[KEY_ALT])
        {
            if(gui_mouse_b()&1)
            {
                d->d1 = Combo;
                d->fg = CSet;
            }
        }
        else
        {
            if(select_combo_2(c2, cs))
            {
                d->d1=c2;
                d->fg=cs;
            }
        }
        
        return D_REDRAW;
    }
    break;
    
    case MSG_DRAW:
        if(is_large)
        {
            d->w = 32;
            d->h = 32;
        }
        
        BITMAP *buf = create_bitmap_ex(8,16,16);
        BITMAP *bigbmp = create_bitmap_ex(8,d->w,d->h);
        
        if(buf && bigbmp)
        {
            clear_bitmap(buf);
            
			if(d->bg) //flags only
			{
				put_flag(buf,0,0,d->d2);
			}
            else if(d->d1)
            {
                putcombo(buf,0,0,d->d1,d->fg);
                
                if(Flags&cFLAGS)
                    put_flags(buf,0,0,d->d1,d->fg,cFLAGS,d->d2);
            }
            
            stretch_blit(buf, bigbmp, 0,0, 16, 16, 0, 0, d->w, d->h);
            destroy_bitmap(buf);
            blit(bigbmp,screen,0,0,d->x-is_large,d->y-is_large,d->w,d->h);
            destroy_bitmap(bigbmp);
        }
        
        
        /*BITMAP *buf = create_bitmap_ex(8,16,16);
        if(buf)
        {
          clear_bitmap(buf);
          if(d->d1)
            putcombo(buf,0,0,d->d1,d->fg);
        
          blit(buf,screen,0,0,d->x,d->y,d->w,d->h);
          destroy_bitmap(buf);
        }*/
        break;
    }
    
    return D_O_K;
}

/*int32_t d_scombo2_proc(int32_t msg, DIALOG *d, int32_t c)
{
  //these are here to bypass compiler warnings about unused arguments
  c=c;

  switch(msg)
  {
    case MSG_CLICK:
    if (key[KEY_ZC_LCONTROL] || key[KEY_ZC_RCONTROL])
    {
      select_scombo(d->d1);
    }
    else
    {
      select_scombo(d->d1);
    }
    scare_mouse();
    d_scombo_proc(MSG_DRAW,d,0);
    unscare_mouse();
    break;


    case MSG_DRAW:
    BITMAP *buf = create_bitmap_ex(8,16,16);
    if(buf)
    {
      clear_bitmap(buf);
      Map.draw_secret2(buf,d->d1);
      blit(buf,screen,0,0,d->x,d->y,16,16);
      destroy_bitmap(buf);
    }
    break;
  }

  return D_O_K;
}*/

int32_t onSecretF();

static int32_t secret_burn_list[] =
{
    // dialog control number
    4, 5, 6, 7, 48, 49, 50, 51, 92, 93, 94, 95, -1
};

static int32_t secret_arrow_list[] =
{
    // dialog control number
    8, 9, 10, 52, 53, 54, 96, 97, 98, -1
};

static int32_t secret_bomb_list[] =
{
    // dialog control number
    11, 12, 55, 56, 99, 100, -1
};

static int32_t secret_boomerang_list[] =
{
    // dialog control number
    13, 14, 15, 57, 58, 59, 101, 102, 103, -1
};

static int32_t secret_magic_list[] =
{
    // dialog control number
    16, 17, 60, 61, 104, 105, -1
};

static int32_t secret_sword_list[] =
{
    // dialog control number
    18, 19, 20, 21, 22, 23, 24, 25, 62, 63, 64, 65, 66, 67, 68, 69, 106, 107, 108, 109, 110, 111, 112, 113, -1
};

static int32_t secret_misc_list[] =
{
    // dialog control number
    26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, -1
};

static TABPANEL secret_tabs[] =
{
    // (text)
    { (char *)"Burn",       D_SELECTED,   secret_burn_list, 0, NULL },
    { (char *)"Arrow",       0,           secret_arrow_list, 0, NULL },
    { (char *)"Bomb",        0,           secret_bomb_list, 0, NULL },
    { (char *)"Boomerang",   0,           secret_boomerang_list, 0, NULL },
    { (char *)"Magic",       0,           secret_magic_list, 0, NULL },
    { (char *)"Sword",       0,           secret_sword_list, 0, NULL },
    { (char *)"Misc",        0,           secret_misc_list, 0, NULL },
    { NULL,                  0,           NULL, 0, NULL }
};

static DIALOG secret_dlg[] =
{
    // (dialog proc)            (x)     (y)     (w)     (h)     (fg)        (bg)    (key)        (flags)  (d1)         (d2)   (dp)                             (dp2)   (dp3)
    {  jwin_win_proc,             0,      0,    301,    212,    vc(14),     vc(1),      0,       D_EXIT,     0,           0,  NULL,        NULL,   NULL                },
    {  jwin_tab_proc,             6,     25,    289,    156,    0,          0,          0,       0,          0,           0, (void *) secret_tabs,            NULL, (void *)secret_dlg  },
    {  jwin_button_proc,         80,    187,     61,     21,    vc(14),     vc(1),     13,       D_EXIT,     0,           0, (void *) "OK",                   NULL,   NULL                },
    {  jwin_button_proc,        160,    187,     61,     21,    vc(14),     vc(1),     27,       D_EXIT,     0,           0, (void *) "Cancel",               NULL,   NULL                },
    // 4
    {  jwin_text_proc,           12,     53,     16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "Blue Candle",          NULL,   NULL                },
    {  jwin_text_proc,           12,     75,     16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "Red Candle",           NULL,   NULL                },
    {  jwin_text_proc,           12,     97,     16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "Wand Fire",            NULL,   NULL                },
    {  jwin_text_proc,           12,    119,     16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "Din's Fire",           NULL,   NULL                },
    //8
    {  jwin_text_proc,           12,     53,     16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "Wooden Arrow",         NULL,   NULL                },
    {  jwin_text_proc,           12,     75,     16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "Silver Arrow",         NULL,   NULL                },
    {  jwin_text_proc,           12,     97,     16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "Golden Arrow",         NULL,   NULL                },
    //11
    {  jwin_text_proc,           12,     53,     16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "Bomb",                 NULL,   NULL                },
    {  jwin_text_proc,           12,     75,     16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "Super Bomb",           NULL,   NULL                },
    //13
    {  jwin_text_proc,           12,     53,     16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "Wooden Boomerang",     NULL,   NULL                },
    {  jwin_text_proc,           12,     75,     16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "Magic Boomerang",      NULL,   NULL                },
    {  jwin_text_proc,           12,     97,     16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "Fire Boomerang",       NULL,   NULL                },
    //16
    {  jwin_text_proc,           12,     53,     16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "Wand Magic",           NULL,   NULL                },
    {  jwin_text_proc,           12,     75,     16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "Reflected Magic",      NULL,   NULL                },
    //18
    {  jwin_text_proc,           12,     53,     16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "Sword",                NULL,   NULL                },
    {  jwin_text_proc,           12,     75,     16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "White Sword",          NULL,   NULL                },
    {  jwin_text_proc,           12,     97,     16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "Magic Sword",          NULL,   NULL                },
    {  jwin_text_proc,           12,    119,     16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "Master Sword",         NULL,   NULL                },
    {  jwin_text_proc,          160,     53,     16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "Sword Beam",           NULL,   NULL                },
    {  jwin_text_proc,          160,     75,     16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "White Sword Beam",     NULL,   NULL                },
    {  jwin_text_proc,          160,     97,     16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "Magic Sword Beam",     NULL,   NULL                },
    {  jwin_text_proc,          160,    119,     16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "Master Sword Beam",    NULL,   NULL                },
    //26
    {  jwin_text_proc,           12,     53,     16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "Stairs",               NULL,   NULL                },
    {  jwin_text_proc,           12,     75,     16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "Reflected Fireball",   NULL,   NULL                },
    {  jwin_text_proc,           12,     97,     16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "Hookshot",             NULL,   NULL                },
    {  jwin_text_proc,           12,    119,     16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "Wand",                 NULL,   NULL                },
    {  jwin_text_proc,           12,    141,     16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "Hammer",               NULL,   NULL                },
    {  jwin_text_proc,           12,    163,     16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "Any Weapon",           NULL,   NULL                },
    //32
    {  jwin_ctext_proc,         235,     53,     16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "Flags 16-31",          NULL,   NULL                },
    {  jwin_text_proc,           87,     53,     16,     16,    vc(11),     vc(1),      0,       0,          0,           0, (void *) "Secrets->Next (Flag only)",           NULL,   NULL                },
    {  d_dummy_proc,              0,      0,      0,      0,    0,          0,          0,       0,          FR_DEEP,     0, (void *) "Secret Combo 03",      NULL,   NULL                },
    {  d_dummy_proc,              0,      0,      0,      0,    0,          0,          0,       0,          FR_DEEP,     0, (void *) "Secret Combo 04",      NULL,   NULL                },
    {  d_dummy_proc,              0,      0,      0,      0,    0,          0,          0,       0,          FR_DEEP,     0, (void *) "Secret Combo 05",      NULL,   NULL                },
    {  d_dummy_proc,              0,      0,      0,      0,    0,          0,          0,       0,          FR_DEEP,     0, (void *) "Secret Combo 06",      NULL,   NULL                },
    {  d_dummy_proc,              0,      0,      0,      0,    0,          0,          0,       0,          FR_DEEP,     0, (void *) "Secret Combo 07",      NULL,   NULL                },
    {  d_dummy_proc,              0,      0,      0,      0,    0,          0,          0,       0,          FR_DEEP,     0, (void *) "Secret Combo 08",      NULL,   NULL                },
    {  d_dummy_proc,              0,      0,      0,      0,    0,          0,          0,       0,          FR_DEEP,     0, (void *) "Secret Combo 09",      NULL,   NULL                },
    {  d_dummy_proc,              0,      0,      0,      0,    0,          0,          0,       0,          FR_DEEP,     0, (void *) "Secret Combo 10",      NULL,   NULL                },
    {  d_dummy_proc,              0,      0,      0,      0,    0,          0,          0,       0,          FR_DEEP,     0, (void *) "Secret Combo 11",      NULL,   NULL                },
    {  d_dummy_proc,              0,      0,      0,      0,    0,          0,          0,       0,          FR_DEEP,     0, (void *) "Secret Combo 12",      NULL,   NULL                },
    {  d_dummy_proc,              0,      0,      0,      0,    0,          0,          0,       0,          FR_DEEP,     0, (void *) "Secret Combo 13",      NULL,   NULL                },
    {  d_dummy_proc,              0,      0,      0,      0,    0,          0,          0,       0,          FR_DEEP,     0, (void *) "Secret Combo 14",      NULL,   NULL                },
    {  d_dummy_proc,              0,      0,      0,      0,    0,          0,          0,       0,          FR_DEEP,     0, (void *) "Secret Combo 15",      NULL,   NULL                },
    {  d_dummy_proc,              0,      0,      0,      0,    0,          0,          0,       0,          FR_DEEP,     0, (void *) "Secret Combo 16",      NULL,   NULL                },
    //48 (burn)
    {  jwin_frame_proc,         108,     47,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         108,     69,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         108,     91,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         108,    113,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    //52 (arrow)
    {  jwin_frame_proc,         108,     47,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         108,     69,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         108,     91,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    //55 (bomb)
    {  jwin_frame_proc,         108,     47,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         108,     69,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    //57 (boomerang)
    {  jwin_frame_proc,         108,     47,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         108,     69,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         108,     91,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    //60 (magic)
    {  jwin_frame_proc,         108,     47,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         108,     69,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    //62 (sword)
    {  jwin_frame_proc,         108,     47,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         108,     69,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         108,     91,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         108,    113,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         256,     47,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         256,     69,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         256,     91,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         256,    113,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    //70 (misc)
    {  jwin_frame_proc,          63,     47,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,          63,     69,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,          63,     91,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,          63,    113,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,          63,    135,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,          63,    157,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    //76 (16-32)
    {  jwin_frame_proc,         192,     69,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         214,     69,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         236,     69,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         258,     69,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         192,     91,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         214,     91,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         236,     91,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         258,     91,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         192,    113,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         214,    113,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         236,    113,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         258,    113,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         192,    135,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         214,    135,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         236,    135,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    {  jwin_frame_proc,         258,    135,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
    
    //92 (burn)
    {  d_scombo_proc,           110,     49,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           110,     71,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           110,     93,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           110,    115,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    //96 (arrow)
    {  d_scombo_proc,           110,     49,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           110,     71,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           110,     93,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    //99 (bomb)
    {  d_scombo_proc,           110,     49,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           110,     71,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    //101 (boomerang)
    {  d_scombo_proc,           110,     49,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           110,     71,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           110,     93,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    //104 (magic)
    {  d_scombo_proc,           110,     49,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           110,     71,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    //106 (sword)
    {  d_scombo_proc,           110,     49,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           110,     71,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           110,     93,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           110,    115,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           258,     49,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           258,     71,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           258,     93,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           258,    115,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    //114 (misc)
    {  d_scombo_proc,            65,     49,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,            65,     71,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,            65,     93,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,            65,    115,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,            65,    137,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,            65,    159,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    //120 (16-32)
    {  d_scombo_proc,           194,     71,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           216,     71,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           238,     71,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           260,     71,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           194,     93,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           216,     93,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           238,     93,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           260,     93,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           194,    115,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           216,    115,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           238,    115,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           260,    115,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           194,    137,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           216,    137,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           238,    137,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  d_scombo_proc,           260,    137,     16,     16,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    //136 Secrets->Next
    {  jwin_frame_proc,         158,     47,     20,     20,    0,          0,          0,       0,          FR_DEEP,     0,  NULL,                            NULL,   NULL                },
	{  d_scombo_proc,           160,     49,     16,     16,    0,          1,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    //138
    {  d_keyboard_proc,           0,      0,      0,      0,    0,          0,          0,       0,          KEY_F1,      0, (void *) onHelp,                 NULL,   NULL                },
    {  d_keyboard_proc,           0,      0,      0,      0,    0,          0,          'f',     0,          0,           0, (void *) onSecretF,              NULL,   NULL                },
    {  d_timer_proc,              0,      0,      0,      0,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                },
    {  NULL,                      0,      0,      0,      0,    0,          0,          0,       0,          0,           0,  NULL,                            NULL,   NULL                }
};

int32_t onSecretF()
{
    Flags^=cFLAGS;
    object_message(secret_dlg+1, MSG_DRAW, 0);
    return D_O_K;
}


int32_t onSecretCombo()
{
    secret_dlg[0].dp2=lfont;
    
    
    mapscr *s;
    
    if(CurrentLayer==0)
    {
        s=Map.CurrScr();
    }
    else
    {
        //   s=TheMaps[(Map.CurrScr()->layermap[CurrentLayer-1]-1)*MAPSCRS+(Map.CurrScr()->layerscreen[CurrentLayer-1])];
        s=Map.AbsoluteScr((Map.CurrScr()->layermap[CurrentLayer-1]-1), (Map.CurrScr()->layerscreen[CurrentLayer-1]));
    }
    
    char secretcombonumstr[27];
    sprintf(secretcombonumstr,"Secret Combos for Layer %d", CurrentLayer);
    secret_dlg[0].dp = secretcombonumstr;
    
    secret_dlg[92].d1 = s->secretcombo[sBCANDLE];
    secret_dlg[92].fg = s->secretcset[sBCANDLE];
    secret_dlg[92].d2 = s->secretflag[sBCANDLE];
    
    secret_dlg[93].d1 = s->secretcombo[sRCANDLE];
    secret_dlg[93].fg = s->secretcset[sRCANDLE];
    secret_dlg[93].d2 = s->secretflag[sRCANDLE];
    
    secret_dlg[94].d1 = s->secretcombo[sWANDFIRE];
    secret_dlg[94].fg = s->secretcset[sWANDFIRE];
    secret_dlg[94].d2 = s->secretflag[sWANDFIRE];
    
    secret_dlg[95].d1 = s->secretcombo[sDINSFIRE];
    secret_dlg[95].fg = s->secretcset[sDINSFIRE];
    secret_dlg[95].d2 = s->secretflag[sDINSFIRE];
    
    secret_dlg[96].d1 = s->secretcombo[sARROW];
    secret_dlg[96].fg = s->secretcset[sARROW];
    secret_dlg[96].d2 = s->secretflag[sARROW];
    
    secret_dlg[97].d1 = s->secretcombo[sSARROW];
    secret_dlg[97].fg = s->secretcset[sSARROW];
    secret_dlg[97].d2 = s->secretflag[sSARROW];
    
    secret_dlg[98].d1 = s->secretcombo[sGARROW];
    secret_dlg[98].fg = s->secretcset[sGARROW];
    secret_dlg[98].d2 = s->secretflag[sGARROW];
    
    secret_dlg[99].d1 = s->secretcombo[sBOMB];
    secret_dlg[99].fg = s->secretcset[sBOMB];
    secret_dlg[99].d2 = s->secretflag[sBOMB];
    
    secret_dlg[100].d1 = s->secretcombo[sSBOMB];
    secret_dlg[100].fg = s->secretcset[sSBOMB];
    secret_dlg[100].d2 = s->secretflag[sSBOMB];
    
    for(int32_t i=0; i<3; i++)
    {
        secret_dlg[101+i].d1 = s->secretcombo[sBRANG+i];
        secret_dlg[101+i].fg = s->secretcset[sBRANG+i];
        secret_dlg[101+i].d2 = s->secretflag[sBRANG+i];
    }
    
    for(int32_t i=0; i<2; i++)
    {
        secret_dlg[104+i].d1 = s->secretcombo[sWANDMAGIC+i];
        secret_dlg[104+i].fg = s->secretcset[sWANDMAGIC+i];
        secret_dlg[104+i].d2 = s->secretflag[sWANDMAGIC+i];
    }
    
    for(int32_t i=0; i<8; i++)
    {
        secret_dlg[106+i].d1 = s->secretcombo[sSWORD+i];
        secret_dlg[106+i].fg = s->secretcset[sSWORD+i];
        secret_dlg[106+i].d2 = s->secretflag[sSWORD+i];
    }
    
    secret_dlg[114].d1 = s->secretcombo[sSTAIRS];
    secret_dlg[114].fg = s->secretcset[sSTAIRS];
    secret_dlg[114].d2 = s->secretflag[sSTAIRS];
    
    secret_dlg[115].d1 = s->secretcombo[sREFFIREBALL];
    secret_dlg[115].fg = s->secretcset[sREFFIREBALL];
    secret_dlg[115].d2 = s->secretflag[sREFFIREBALL];
    
    for(int32_t i=0; i<4; i++)
    {
        secret_dlg[116+i].d1 = s->secretcombo[sHOOKSHOT+i];
        secret_dlg[116+i].fg = s->secretcset[sHOOKSHOT+i];
        secret_dlg[116+i].d2 = s->secretflag[sHOOKSHOT+i];
    }
    
    for(int32_t i=0; i<16; i++)
    {
        secret_dlg[120+i].d1 = s->secretcombo[sSECRET01+i];
        secret_dlg[120+i].fg = s->secretcset[sSECRET01+i];
        secret_dlg[120+i].d2 = s->secretflag[sSECRET01+i];
    }
	
	//Sec->Next doesn't have a combo/cset value associated
	secret_dlg[137].d1 = 0;
	secret_dlg[137].fg = 0;
	secret_dlg[137].d2 = s->secretflag[sSECNEXT];
    
    if(is_large)
    {
        large_dialog(secret_dlg,1.75);
        
		for(int32_t q = 0; secret_dlg[q].proc != NULL; ++q)
        {
			if(secret_dlg[q].proc == jwin_frame_proc)
				secret_dlg[q].w = secret_dlg[q].h = 36;
        }
    }
    
    go();
    
    if(zc_do_dialog(secret_dlg,3) == 2)
    {
        saved = false;
        s->secretcombo[sBCANDLE] = secret_dlg[92].d1;
        s->secretcset[sBCANDLE] = secret_dlg[92].fg;
        s->secretflag[sBCANDLE] = secret_dlg[92].d2;
        
        s->secretcombo[sRCANDLE] = secret_dlg[93].d1;
        s->secretcset[sRCANDLE] = secret_dlg[93].fg;
        s->secretflag[sRCANDLE] = secret_dlg[93].d2;
        
        s->secretcombo[sWANDFIRE] = secret_dlg[94].d1;
        s->secretcset[sWANDFIRE] = secret_dlg[94].fg;
        s->secretflag[sWANDFIRE] = secret_dlg[94].d2;
        
        s->secretcombo[sDINSFIRE] = secret_dlg[95].d1;
        s->secretcset[sDINSFIRE] = secret_dlg[95].fg;
        s->secretflag[sDINSFIRE] = secret_dlg[95].d2;
        
        s->secretcombo[sARROW] = secret_dlg[96].d1;
        s->secretcset[sARROW] = secret_dlg[96].fg;
        s->secretflag[sARROW] = secret_dlg[96].d2;
        
        s->secretcombo[sSARROW] = secret_dlg[97].d1;
        s->secretcset[sSARROW] = secret_dlg[97].fg;
        s->secretflag[sSARROW] = secret_dlg[97].d2;
        
        s->secretcombo[sGARROW] = secret_dlg[98].d1;
        s->secretcset[sGARROW] = secret_dlg[98].fg;
        s->secretflag[sGARROW] = secret_dlg[98].d2;
        
        s->secretcombo[sBOMB] = secret_dlg[99].d1;
        s->secretcset[sBOMB] = secret_dlg[99].fg;
        s->secretflag[sBOMB] = secret_dlg[99].d2;
        
        s->secretcombo[sSBOMB] = secret_dlg[100].d1;
        s->secretcset[sSBOMB] = secret_dlg[100].fg;
        s->secretflag[sSBOMB] = secret_dlg[100].d2;
        
        for(int32_t i=0; i<3; i++)
        {
            s->secretcombo[sBRANG+i] = secret_dlg[101+i].d1;
            s->secretcset[sBRANG+i] = secret_dlg[101+i].fg;
            s->secretflag[sBRANG+i] = secret_dlg[101+i].d2;
        }
        
        for(int32_t i=0; i<2; i++)
        {
            s->secretcombo[sWANDMAGIC+i] = secret_dlg[104+i].d1;
            s->secretcset[sWANDMAGIC+i] = secret_dlg[104+i].fg;
            s->secretflag[sWANDMAGIC+i] = secret_dlg[104+i].d2;
        }
        
        for(int32_t i=0; i<8; i++)
        {
            s->secretcombo[sSWORD+i] = secret_dlg[106+i].d1;
            s->secretcset[sSWORD+i] = secret_dlg[106+i].fg;
            s->secretflag[sSWORD+i] = secret_dlg[106+i].d2;
        }
        
        s->secretcombo[sSTAIRS] = secret_dlg[114].d1;
        s->secretcset[sSTAIRS] = secret_dlg[114].fg;
        s->secretflag[sSTAIRS] = secret_dlg[114].d2;
        
        s->secretcombo[sREFFIREBALL] = secret_dlg[115].d1;
        s->secretcset[sREFFIREBALL] = secret_dlg[115].fg;
        s->secretflag[sREFFIREBALL] = secret_dlg[115].d2;
        
        for(int32_t i=0; i<4; i++)
        {
            s->secretcombo[sHOOKSHOT+i] = secret_dlg[116+i].d1;
            s->secretcset[sHOOKSHOT+i] = secret_dlg[116+i].fg;
            s->secretflag[sHOOKSHOT+i] = secret_dlg[116+i].d2;
        }
        
        for(int32_t i=0; i<16; i++)
        {
            s->secretcombo[sSECRET01+i] = secret_dlg[120+i].d1;
            s->secretcset[sSECRET01+i] = secret_dlg[120+i].fg;
            s->secretflag[sSECRET01+i] = secret_dlg[120+i].d2;
        }
		s->secretflag[sSECNEXT] = secret_dlg[137].d2;
        
    }
    
    comeback();
    return D_O_K;
}

static DIALOG under_dlg[] =
{
    /* (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp) */
    { jwin_win_proc,     72,   60,   176+1,120+1,vc(14),  vc(1),  0,       D_EXIT,     0,             0, NULL, NULL, NULL },
    { jwin_text_proc,    115,  83,   20,   20,   vc(14),  vc(1),  0,       0,          0,             0, (void *) "Current", NULL, NULL },
    { d_comboframe_proc, 122,  92,   20,   20,   0,       0,      0,       0,          FR_DEEP,       0,       NULL, NULL, NULL },
    { d_combo_proc,      124,  94,   16,   16,   0,       0,      0,       D_NOCLICK,  0,             0,       NULL, NULL, NULL },
    { jwin_text_proc,    184,  83,   20,   20,   vc(14),  vc(1),  0,       0,          0,             0, (void *) "New", NULL, NULL },
    { d_comboframe_proc, 182,  92,   20,   20,   0,       0,      0,       0,          FR_DEEP,       0,       NULL, NULL, NULL },
    { d_combo_proc,      184,  94,   16,   16,   0,       0,      0,       0,          0,             0,       NULL, NULL, NULL },
    { jwin_button_proc,  90,   124,  61,   21,   vc(14),  vc(1),  's',     D_EXIT,     0,             0, (void *) "&Set", NULL, NULL },
    { jwin_button_proc,  170,  124,  61,   21,   vc(14),  vc(1),  'c',     D_EXIT,     0,             0, (void *) "&Cancel", NULL, NULL },
    { jwin_button_proc,  90,   152,  61,   21,   vc(14),  vc(1),  'a',     D_EXIT,     0,             0, (void *) "Set &All", NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,       0,      0,       0,          KEY_F1,        0, (void *) onHelp, NULL, NULL },
    { d_timer_proc,      0,    0,    0,    0,    0,       0,      0,       0,          0,             0,         NULL, NULL, NULL },
    { NULL,              0,    0,    0,    0,    0,       0,      0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

int32_t onUnderCombo()
{
	char titlebuf[64];
	sprintf(titlebuf, "Under Combo (Layer %d)", CurrentLayer);
	under_dlg[0].dp = titlebuf;
	under_dlg[0].dp2 = lfont;
	mapscr* scr;
	if(CurrentLayer==0)
	{
		scr=Map.CurrScr();
	}
	else
	{
		auto map=Map.CurrScr()->layermap[CurrentLayer-1]-1;
		auto screen=Map.CurrScr()->layerscreen[CurrentLayer-1];
		if(map < 0) return D_O_K;
		scr = Map.AbsoluteScr(map,screen);
	}
	
	under_dlg[3].d1=scr->undercombo;
	under_dlg[3].fg=scr->undercset;
	
	under_dlg[6].d1=Combo;
	under_dlg[6].fg=CSet;
	
	if(is_large)
	{
		large_dialog(under_dlg);
		// Doesn't place "New" and "Current" text too well
		under_dlg[1].x=342;
		under_dlg[4].x=438;
	}
	
	int32_t ret = zc_popup_dialog(under_dlg,-1);
	
	if(ret==7)
	{
		saved=false;
		scr->undercombo = under_dlg[6].d1;
		scr->undercset = under_dlg[6].fg;
	}
	
	if(ret==9 && jwin_alert("Confirm Overwrite","Set all Under Combos","on this map?",NULL,"&Yes","&No",'y','n',lfont)==1)
	{
		saved=false;
		
		for(int32_t i=0; i<128; i++)
		{
			Map.Scr(i)->undercombo = under_dlg[6].d1;
			Map.Scr(i)->undercset = under_dlg[6].fg;
		}
	}
	
	return D_O_K;
}

static DIALOG list_dlg[] =
{
    // (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp)
    { jwin_win_proc,     60-12,   40,   200+24,  148,  vc(14),  vc(1),  0,       D_EXIT,          0,             0,       NULL, NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { jwin_list_proc,       72-12-4,   60+4,   176+24+8,  92+3,   jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,       D_EXIT,     0,             0,       NULL, NULL, NULL },
    { jwin_button_proc,     90,   163,  61,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "OK", NULL, NULL },
    { jwin_button_proc,     170,  163,  61,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

void ilist_rclick_func(int32_t index, int32_t x, int32_t y);
void paste_item(int32_t index = -1);
void copy_item(int32_t index = -1);
void save_item(int32_t index = -1);
void load_item(int32_t index = -1);
DIALOG ilist_dlg[] =
{
    // (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp)
    { jwin_win_proc,     60-12,   40,   200+24+24,  148+20,  vc(14),  vc(1),  0,       D_EXIT,          0,   0,       NULL, NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,            0,       NULL, NULL, NULL },
    { d_ilist_proc,       72-12-4,   60+4,   176+24+8,  90+3,   jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG], 0, D_EXIT, 0,  0,  NULL, NULL, NULL },
    { jwin_button_proc,     90,   163+20,  61,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "Edit", NULL, NULL },
    { jwin_button_proc,     170,  163+20,  61,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Done", NULL, NULL },
    { jwin_button_proc,     220,   163+20,  61,   21,   vc(14),  vc(1),  13,     D_EXIT,     0,             0, (void *) "Edit", NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL, NULL,  NULL }
};

static DIALOG wlist_dlg[] =
{
    // (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp)
    { jwin_win_proc,     60-12,   40,   200+24+24,  156,  vc(14),  vc(1),  0,       D_EXIT,          0,             0,       NULL, NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { d_wlist_proc,       72-12-4,   60+4,   176+24+8,  92+3,   jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,       D_EXIT,     0,             0,       NULL, NULL, NULL },
    { jwin_button_proc,     90,   171,  61,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "Edit", NULL, NULL },
    { jwin_button_proc,     170,  171,  61,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Done", NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};


/*
  typedef struct item_struct {
  char *s;
  int32_t i;
  } item_struct;
  */
item_struct bii[iMax+1];
int32_t bii_cnt=-1;

void build_bii_list(bool usenone)
{
	int32_t start=bii_cnt=0;
    
    if(usenone)
    {
        bii[0].s = (char *)"(None)";
        bii[0].i = -2;
        bii_cnt=start=1;
    }
    
    for(int32_t i=0; i<iMax; i++)
    {
        bii[bii_cnt].s = item_string[i];
        bii[bii_cnt].i = i;
        ++bii_cnt;
    }
    
    for(int32_t i=start; i<bii_cnt-1; i++)
    {
        for(int32_t j=i+1; j<bii_cnt; j++)
        {
            if(stricmp(bii[i].s,bii[j].s)>0 && strcmp(bii[j].s,""))
            {
                zc_swap(bii[i],bii[j]);
            }
        }
    }
}


const char *itemlist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = bii_cnt;
        return NULL;
    }
    
    return bii[index].s;
}
const char *itemlist_num(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = bii_cnt;
        return NULL;
    }
	static char biin_buf[64+6];
	if(bii[index].i < 0)
		return bii[index].s;
    sprintf(biin_buf, "%s (%03d)", bii[index].s, bii[index].i);
    return biin_buf;
}

// disable items on dmaps stuff
int32_t DI[iMax];
int32_t nDI;

void initDI(int32_t index)
{
    int32_t j=0;
    
    for(int32_t i=0; i<iMax; i++)
    {
        int32_t index1=bii[i].i; // true index of item in dmap's DI list
        
        if(DMaps[index].disableditems[index1])
        {
            DI[j]=i;
            j++;
        }
    }
    
    nDI=j;
    
    for(int32_t i=j; i<iMax; i++) DI[j]=0;
    
    return;
}

void insertDI(int32_t id, int32_t index)
{
    int32_t trueid=bii[id].i;
    DMaps[index].disableditems[trueid] |= 1; //bit set
    initDI(index);
    return;
}

void deleteDI(int32_t id, int32_t index)
{
    int32_t i=DI[id];
    int32_t trueid=bii[i].i;
    DMaps[index].disableditems[trueid] &= (~1); // bit clear
    initDI(index);
    return;
}

const char *DIlist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = nDI;
        return NULL;
    }
    
    int32_t i=DI[index];
    return bii[i].s;
    
}

int32_t select_item(const char *prompt,int32_t item,bool is_editor,int32_t &exit_status)
{
    int32_t index=0;
    
    for(int32_t j=0; j<bii_cnt; j++)
    {
        if(bii[j].i == item)
        {
            index=j;
        }
    }
    
    ilist_dlg[0].dp=(void *)prompt;
    ilist_dlg[0].dp2=lfont;
    ilist_dlg[2].d1=index;
    ListData item_list(itemlist_num, &font);
    ilist_dlg[2].dp=(void *) &item_list;
    
    if(is_large)
        large_dialog(ilist_dlg);
        
    if(is_editor)
    {
        ilist_dlg[2].dp3 = (void *)&ilist_rclick_func;
        ilist_dlg[2].flags|=(D_USER<<1);
        ilist_dlg[3].dp = (void *)"Edit";
        ilist_dlg[4].dp = (void *)"Done";
        ilist_dlg[3].x = is_large?285:90;
        ilist_dlg[4].x = is_large?405:170;
        ilist_dlg[5].flags |= D_HIDDEN;
    }
    else
    {
        ilist_dlg[2].dp3 = NULL;
        ilist_dlg[2].flags&=~(D_USER<<1);
        ilist_dlg[3].dp = (void *)"OK";
        ilist_dlg[4].dp = (void *)"Cancel";
        ilist_dlg[3].x = is_large?260:60;
        ilist_dlg[4].x = is_large?370:135;
		if(is_large)
		{
			ilist_dlg[5].x = 480;
        }
		ilist_dlg[5].flags &= ~D_HIDDEN;
    }
    
    exit_status=zc_popup_dialog(ilist_dlg,2);
    
    if(exit_status==0||exit_status==4)
    {
        position_mouse_z(0);
        return -1;
    }
    
    index = ilist_dlg[2].d1;
    position_mouse_z(0);
    return bii[index].i;
}

weapon_struct biw[wMAX];
int32_t biw_cnt=-1;

void build_biw_list()
{
    int32_t start=biw_cnt=0;
    
    for(int32_t i=start; i<wMAX; i++)
    {
        biw[biw_cnt].s = (char *)weapon_string[i];
        biw[biw_cnt].i = i;
        ++biw_cnt;
    }
    
    for(int32_t i=start; i<biw_cnt-1; i++)
    {
        for(int32_t j=i+1; j<biw_cnt; j++)
            if(stricmp(biw[i].s,biw[j].s)>0 && strcmp(biw[j].s,""))
                zc_swap(biw[i],biw[j]);
    }
}

const char *weaponlist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = biw_cnt;
        return NULL;
    }
    
    return biw[index].s;
}
const char *weaponlist_num(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = biw_cnt;
        return NULL;
    }
	static char biwn_buf[64+6];
	if(biw[index].i < 0)
		return biw[index].s;
    sprintf(biwn_buf, "%s (%03d)", biw[index].s, biw[index].i);
    return biwn_buf;
}
int32_t writeoneweapon(PACKFILE *f, int32_t index)
{
    dword section_version=V_WEAPONS;
    dword section_cversion=CV_WEAPONS;
    int32_t zversion = ZELDA_VERSION;
    int32_t zbuild = VERSION_BUILD;
    int32_t iid = biw[index].i;
    al_trace("Writing Weapon Sprite .zwpnspr file for weapon id: %d\n", iid);
  
    //section version info
    if(!p_iputl(zversion,f))
    {
	    return 0;
    }
    if(!p_iputl(zbuild,f))
    {
	    return 0;
    }
    if(!p_iputw(section_version,f))
    {
	    return 0;
    }
    
    if(!p_iputw(section_cversion,f))
    {
	    return 0;
    }
    
    //weapon string
	
    if(!pfwrite((char *)weapon_string[iid], 64, f))
    {
        return 0;
    }
            
    if(!p_putc(wpnsbuf[iid].misc,f))
    {
        return 0;
    }
            
    if(!p_putc(wpnsbuf[iid].csets,f))
    {
        return 0;
    }
            
    if(!p_putc(wpnsbuf[iid].frames,f))
    {
        return 0;
    }
            
    if(!p_putc(wpnsbuf[iid].speed,f))
    {
        return 0;
    }
            
    if(!p_putc(wpnsbuf[iid].type,f))
    {
        return 0;
    }
	    
    if(!p_iputw(wpnsbuf[iid].script,f))
    {
        return 0;
    }
	    
    //2.55 starts here
    if(!p_iputl(wpnsbuf[iid].tile,f))
    {
        return 0;
    }

    return 1;
}


int32_t readoneweapon(PACKFILE *f, int32_t index)
{
	dword section_version = 0;
	dword section_cversion = 0;
	int32_t zversion = 0;
	int32_t zbuild = 0;
	wpndata tempwpnspr;
	memset(&tempwpnspr, 0, sizeof(wpndata));
     
   
	//char dmapstring[64]={0};
	//section version info
	if(!p_igetl(&zversion,f,true))
	{
		return 0;
	}
	if(!p_igetl(&zbuild,f,true))
	{
		return 0;
	}
	if(!p_igetw(&section_version,f,true))
	{
		return 0;
	}
	if(!p_igetw(&section_cversion,f,true))
	{
		return 0;
	}
	al_trace("readoneweapon section_version: %d\n", section_version);
	al_trace("readoneweapon section_cversion: %d\n", section_cversion);

	if ( zversion > ZELDA_VERSION )
	{
		al_trace("Cannot read .zwpnspr packfile made in ZC version (%x) in this version of ZC (%x)\n", zversion, ZELDA_VERSION);
		return 0;
	}
	
	else if ( ( section_version > V_WEAPONS ) || ( section_version == V_WEAPONS && section_cversion < CV_WEAPONS ) )
	{
		al_trace("Cannot read .zwpnspr packfile made using V_WEAPONS (%d) subversion (%d)\n", section_version, section_cversion);
		return 0;
		
	}
	else
	{
		al_trace("Reading a .zwpnspr packfile made in ZC Version: %x, Build: %d\n", zversion, zbuild);
	}
	
	char tmp_wpn_name[64];
	memset(tmp_wpn_name,0,64);
	if(!pfread(&tmp_wpn_name, 64, f,true))
	{
		return 0;
	}
	
    word oldtile = 0;
    if(section_version < 8)
	    if(!p_igetw(&oldtile,f,true))
            return 0;
            
    if(!p_getc(&tempwpnspr.misc,f,true))
    {
        return 0;
    }
            
    if(!p_getc(&tempwpnspr.csets,f,true))
    {
        return 0;
    }
            
    if(!p_getc(&tempwpnspr.frames,f,true))
    {
        return 0;
    }
            
    if(!p_getc(&tempwpnspr.speed,f,true))
    {
        return 0;
    }
    
    if(!p_getc(&tempwpnspr.type,f,true))
    {
        return 0;
    }
	
	if(!p_igetw(&tempwpnspr.script,f,true))
    {
        return 0;
    }

	//2.55 starts here
	if ( zversion >= 0x255 )
	{
		if  ( section_version >= 7 )
		{
			if(!p_igetl(&tempwpnspr.tile,f,true))
			{
				return 0;
			}
		}
	}
	if ( zversion < 0x255 ) 
	{
		tempwpnspr.tile = oldtile;
	}
	::memcpy( &(wpnsbuf[biw[index].i]),&tempwpnspr, sizeof(wpndata));
	::memcpy(weapon_string[biw[index].i], tmp_wpn_name, 64);
       
	return 1;
}


static wpndata copiedSprite;
static byte spritecopied = 0;
char temp_weapon_string[64] = {0};
static MENU wpnsprite_rclick_menu[] =
{
    { "&Copy",    NULL, NULL, 0, NULL },
    { "Paste &v", NULL, NULL, 0, NULL },
    { "&Save",    NULL, NULL, 0, NULL },
    { "&Load",    NULL, NULL, 0, NULL },
    { NULL,       NULL, NULL, 0, NULL }
};

void paste_wsprite(int32_t index = -1)
{
	if(index < 0) index = wlist_dlg[2].d1;
	if(unsigned(index)>255)
		return;
	if(!spritecopied)
		return;
	::memcpy( &(wpnsbuf[biw[index].i]),&copiedSprite, sizeof(wpndata));
	::memcpy(weapon_string[biw[index].i], temp_weapon_string, 64);
	wlist_dlg[2].flags|=D_DIRTY;
	saved=false;
}
void copy_wsprite(int32_t index = -1)
{
	if(index < 0) index = wlist_dlg[2].d1;
	if(unsigned(index)>255)
		return;
	::memcpy(&copiedSprite, &(wpnsbuf[biw[index].i]), sizeof(wpndata));
	memset(temp_weapon_string,0,64);
	::memcpy(temp_weapon_string, weapon_string[biw[index].i], 64);
	spritecopied = 1;
}
void save_wsprite(int32_t index = -1)
{
	if(index < 0) index = wlist_dlg[2].d1;
	if(unsigned(index)>255)
		return;
	if(!getname("Save ZWPNSPR(.zwpnspr)", "zwpnspr", NULL,datapath,false))
		return;
	
	PACKFILE *f=pack_fopen_password(temppath,F_WRITE, "");
	if(!f) return;
	if (!writeoneweapon(f,index))
	{
		Z_error("Could not write to .zwpnspr packfile %s\n", temppath);
		InfoDialog("ZWpnSpr Error", "Could not save the specified sprite.").show();
	}
	pack_fclose(f);
}
void load_wsprite(int32_t index = -1)
{
	if(index < 0) index = wlist_dlg[2].d1;
	if(unsigned(index)>255)
		return;
	if(!getname("Load ZWPNSPR(.zwpnspr)", "zwpnspr", NULL,datapath,false))
		return;
	PACKFILE *f=pack_fopen_password(temppath,F_READ, "");
	if(!f) return;
	
	if (!readoneweapon(f,index))
	{
		Z_error("Could not read from .zwpnspr packfile %s\n", temppath);
		InfoDialog("ZWpnSpr Error", "Could not load the specified sprite.").show();
	}
	
	pack_fclose(f);
	wlist_dlg[2].flags|=D_DIRTY;
	saved=false;
}
void wpnsprite_rclick_func(int32_t index, int32_t x, int32_t y)
{
	if(((unsigned)index)>255)
		return;
	int32_t ret=popup_menu(wpnsprite_rclick_menu, x, y);
	if(ret==0) // copy
		copy_wsprite(index);
	else if(ret==1) // paste
		paste_wsprite(index);
	else if(ret==2) // save
		save_wsprite(index);
	else if(ret==3) // load
		load_wsprite(index);
}


int32_t select_weapon(const char *prompt,int32_t weapon)
{
    if(biw_cnt==-1)
        build_biw_list();
        
    int32_t index=0;
    
    for(int32_t j=0; j<biw_cnt; j++)
    {
        if(biw[j].i == weapon)
        {
            index=j;
        }
    }
    
    wlist_dlg[0].dp=(void *)prompt;
    wlist_dlg[0].dp2=lfont;
    wlist_dlg[2].d1=index;
    ListData weapon_list(weaponlist_num, &font);
    wlist_dlg[2].dp=(void *) &weapon_list;
    wlist_dlg[2].dp3 = (void *)&wpnsprite_rclick_func;
    wlist_dlg[2].flags|=(D_USER<<1);
    
    if(is_large)
        large_dialog(wlist_dlg);
        
    int32_t ret=zc_popup_dialog(wlist_dlg,2);
    
    if(ret==0||ret==4)
    {
        position_mouse_z(0);
        return -1;
    }
    
    index = wlist_dlg[2].d1;
    position_mouse_z(0);
    return biw[index].i;
}



static MENU seldata_rclick_menu[] =
{
    { (char *)"Copy",  NULL, NULL, 0, NULL },
    { (char *)"Paste", NULL, NULL, 0, NULL },
    { NULL,            NULL, NULL, 0, NULL }
};

static int32_t seldata_copy;
static void (*seldata_paste_func)(int32_t, int32_t);

void seldata_rclick_func(int32_t index, int32_t x, int32_t y)
{
    if(seldata_copy<0)
        seldata_rclick_menu[1].flags|=D_DISABLED;
    else
        seldata_rclick_menu[1].flags&=~D_DISABLED;
    
    int32_t ret=popup_menu(seldata_rclick_menu, x, y);
    
    if(ret==0) // copy
        seldata_copy=index;
    else if(ret==1) // paste
    {
        seldata_paste_func(seldata_copy, index);
        saved=false;
    }
}

int32_t select_data(const char *prompt,int32_t index,const char *(proc)(int32_t,int32_t*), FONT *title_font, void (*copyFunc)(int32_t, int32_t))
{
    if(proc==NULL)
        return -1;
    
    list_dlg[0].dp=(void *)prompt;
    list_dlg[0].dp2=title_font;
    list_dlg[2].d1=index;
    ListData select_list(proc, &font);
    list_dlg[2].dp=(void *) &select_list;
    
    if(is_large)
        large_dialog(list_dlg);
    
    seldata_copy=-1;
    seldata_paste_func=copyFunc;
    if(copyFunc)
    {
        list_dlg[2].flags|=D_USER<<1;
        list_dlg[2].dp3=(void*)seldata_rclick_func;
    }
    else
    {
        list_dlg[2].flags&=~(D_USER<<1);
        list_dlg[2].dp3=0;
    }
    
    int32_t ret=zc_popup_dialog(list_dlg,2);
    
    if(ret==0||ret==4)
    {
        position_mouse_z(0);
        return -1;
    }
    
    return list_dlg[2].d1;
}

int32_t select_data(const char *prompt,int32_t index,const char *(proc)(int32_t,int32_t*), const char *b1, const char *b2, FONT *title_font, void (*copyFunc)(int32_t, int32_t))
{
    if(proc==NULL)
        return -1;
        
    list_dlg[0].dp=(void *)prompt;
    list_dlg[0].dp2=title_font;
    list_dlg[2].d1=index;
    ListData select_data_list(proc, &font);
    list_dlg[2].dp=(void *) &select_data_list;
    list_dlg[3].dp=(void *)b1;
    list_dlg[4].dp=(void *)b2;
    
    if(is_large)
        large_dialog(list_dlg);
    
    seldata_copy=-1;
    seldata_paste_func=copyFunc;
    if(copyFunc)
    {
        list_dlg[2].flags|=D_USER<<1;
        list_dlg[2].dp3=(void*)seldata_rclick_func;
    }
    else
    {
        list_dlg[2].flags&=~(D_USER<<1);
        list_dlg[2].dp3=0;
    }
    
    int32_t ret = zc_popup_dialog(list_dlg,2);
    list_dlg[3].dp=(void *) "OK";
    list_dlg[4].dp=(void *) "Cancel";
    
    if(ret==0||ret==4)
    {
        position_mouse_z(0);
        return -1;
    }
    
    position_mouse_z(0);
    return list_dlg[2].d1;
}

static int32_t edit_scrdata1[] = // Flags 1
{
    //6,8,10,11,12,15,18,19,21,22,24,37,57,59,60,-1
    118,45,46,57,  119,21,58,22,24,54,55,8,141,142, //Ordered as they are on the dialog
    120,6,43,47,50,  121,37,42,12,135,23,143,  -1
};

static int32_t edit_scrdata3[] = // Flags 2
{
    //38,39,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,58,61,-1
    123,15,19,41,51,  124,38,39,48,49, 125,52,53,
    126,10,59,60,  127,11,44,128,129,130,131,132,  -1
};

static int32_t edit_scrdata5[] = // Enemies
{
    7,16,17,25,36,107,108,109,110,111,112,113,20,114,115,116,144,-1
};

static int32_t edit_scrdata2[] = // Data 1
{
    31,32,33,34,35,62,63,64,65,66,67,68,69,70,71,72,73,
    74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,
    93,94,97,98,133,134,-1
};

static int32_t edit_scrdata4[] = // Data 2
{
    14,95,96,99,100,101,102,103,104,105,106,-1
};

static int32_t edit_scrdata6[] = // Timed Warp
{
    26, 27, 28,29,30,40,117,-1
};

static int32_t edit_scrdata7[] = // Screen flags 3
{
    122,18,56,136,137,138,139,140,-1
};

static TABPANEL scrdata_tabs[] =
{
    { (char *)"S.Flags 1", D_SELECTED, edit_scrdata1, 0, NULL },
    { (char *)"S.Flags 2", 0,          edit_scrdata3, 0, NULL },
    { (char *)"S.Flags 3", 0,          edit_scrdata7, 0, NULL },
    { (char *)"E.Flags",   0,          edit_scrdata5, 0, NULL },
    { (char *)"S.Data 1",  0,          edit_scrdata2, 0, NULL },
    { (char *)"S.Data 2",  0,          edit_scrdata4, 0, NULL },
    { (char *)"T.Warp",    0,          edit_scrdata6, 0, NULL },
    { NULL,                0,                   NULL, 0, NULL }
};


static char sfx_str_buf[42];

const char *sfxlist(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        bound(index,0,WAV_COUNT-1);
        sprintf(sfx_str_buf,"%d: %s",index, index ? sfx_string[index] : "(None)");
        return sfx_str_buf;
    }
    
    *list_size=WAV_COUNT;
    return NULL;
}

static char lenseffect_str_buf[30];

const char *lenseffectlist(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        bound(index,0,12);
        
        if(index==0)
        {
            sprintf(lenseffect_str_buf,"Normal");
        }
        else if(index<7)
        {
            sprintf(lenseffect_str_buf,"Hide layer %d", index);
        }
        else
        {
            sprintf(lenseffect_str_buf,"Reveal layer %d", index-6);
        }
        
        return lenseffect_str_buf;
    }
    
    *list_size=13;
    return NULL;
}

static ListData nextmap_list(nextmaplist, &font);
static ListData ns_list(nslist,&font);
static ListData screenmidi_list(screenmidilist, &font);
static ListData sfx_list(sfxlist, &font);
static ListData lenseffect_list(lenseffectlist, &font);

static DIALOG scrdata_dlg[] =
{
    /* (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp) */
    { jwin_win_proc,       4,    53-29,   304+1+5+6,  156+1+38+7+10, vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "Screen Data", NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    // 2
    { jwin_button_proc,     90,   176+37,  61,   21,   vc(14),  vc(1),  'k',     D_EXIT,     0,             0, (void *) "O&K", NULL, NULL },
    { jwin_button_proc,     170,  176+37,  61,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { d_keyboard_proc,        0,    0,    0,    0,    0,       0,      0,       0,          KEY_F1,        0, (void *) onHelp, NULL, NULL },
    { jwin_tab_proc,        7,   46,   295+15,  147+17,    vc(14),   vc(1),      0,      0,          1,             0, (void *) scrdata_tabs, NULL, (void *)scrdata_dlg },
    // 6
    { jwin_check_proc,      165,   78,   160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Block->Shutters", NULL, NULL },
    //Moved to E. Flags
    { jwin_check_proc,      165,  148,   160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Enemies->Item", NULL, NULL },
    //8
    { jwin_check_proc,      15,   178,   160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Dark Room", NULL, NULL },
    { d_dummy_proc,         160,  56-24,     0,  8,    vc(15),  vc(1),  0,       0,          0,             0,       NULL, NULL, NULL },
    //S.Flags 2  //10
    { jwin_check_proc,     165,   78,   160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Whistle->Stairs", NULL, NULL },
    { jwin_check_proc,     165,   118,   160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Toggle 'Allow Ladder'", NULL, NULL },
    //12
    { jwin_check_proc,     165,   148,   160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Use Maze Path", NULL, NULL },
    { d_dummy_proc,         160,  56-24,     0,  8,    vc(15),  vc(1),  0,       0,          0,             0,       NULL, NULL, NULL },
    //S.Data 2 //14
    { jwin_check_proc,     140,   168,   160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Play Secret SFX On Screen Entry", NULL, NULL },
    //15
    { jwin_check_proc,      15,   78,   160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Combos Affect Midair Player", NULL, NULL },
    //E.Flags //16
    { jwin_check_proc,      15,   178,   160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Traps Ignore Walkability", NULL, NULL },
    { jwin_check_proc,      165,  158,   160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Enemies->Secret", NULL, NULL },
    //18
    { jwin_check_proc,      15,   78,   160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Hold Up Item", NULL, NULL },
    //S.Flags 2
    { jwin_check_proc,      15,   88,   160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Cycle Combos On Screen Init", NULL, NULL },
    //E. Flags //20
    { jwin_check_proc,      15,   158,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "All Enemies Are Invisible", NULL, NULL },
    //21
    { jwin_check_proc,      15,   118,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Invisible Player", NULL, NULL },
    { jwin_check_proc,      15,   138,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "No Subscreen", NULL, NULL },
    //23
    { jwin_check_proc,      165,  168,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Sprites Carry Over In Warps", NULL, NULL },
    
    { jwin_check_proc,       15,  148,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "...But Don't Offset Screen", NULL, NULL },
    //E. Flags
    { jwin_check_proc,      165,  138,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Enemies Always Return", NULL, NULL },
    
    // These five now appear on the Timed Warp tab.
    { jwin_check_proc,      15,  118,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Timed Warps are Direct", NULL, NULL },
    { jwin_check_proc,      15,  128,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Secrets Disable Timed Warp", NULL, NULL },
    // 28
    { jwin_text_proc,       15,   88,  128,    8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Timed Warp Ticks:", NULL, NULL },
    { d_ticsedit_proc,      15,   98,  36,      16,    vc(12),  vc(1),  0,       0,          5,             0,       NULL, NULL, NULL },
    { jwin_text_proc,17+2+36+1, 98+4,   0,   8,    vc(11),  vc(1),  0,       0,          0,             0,       NULL, NULL, NULL },
    
    { jwin_text_proc,          15,   68,     200,    8,    vc(14),   vc(1),      0,      0,          0,             0, (void *) "Screen State Carry Over:", NULL, NULL },
    { jwin_text_proc,          15,   88,     72,    8,    vc(14),   vc(1),      0,      0,          0,             0, (void *) "Next Map:", NULL, NULL },
    { jwin_text_proc,          15,   106,     96,    8,   vc(14),   vc(1),      0,      0,          0,             0, (void *) "Next Screen:", NULL, NULL },
    { jwin_droplist_proc,      90,   84,   54,   16,   jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,       0,          1,             0, (void *) &nextmap_list, NULL, NULL },
//  { jwin_edit_proc,          90,    84,    32-6,   16,  vc(12),   vc(1),  0,       0,          3,             0,   NULL, NULL, NULL },
    { jwin_droplist_proc,      90,   102,   54,   16,   jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,       0,          1,             0, (void *) &ns_list, NULL, NULL },
// { jwin_edit_proc,       17,   114,   32-6,   16,    vc(12),  vc(1),  0,       0,          2,             0,       NULL, NULL, NULL },
    // { d_hexedit_proc,      97,   102,   24-3,   16,    vc(12),  vc(1),  0,       0,          2,             0,       NULL, NULL, NULL },
    
    //Moved to E Flags
    { jwin_check_proc,      165,  168,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Enemies->Secret is Permanent", NULL, NULL },
    
    { jwin_check_proc,     165,  128,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Auto-Warps are Direct", NULL, NULL },
    //38
    { jwin_check_proc,      15,  128,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Save Point->Continue Here", NULL, NULL },
    { jwin_check_proc,      15,  138,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Save Game On Entry", NULL, NULL },
    // This now appears on the Timed Warp tab.
    { jwin_check_proc,      15,  138,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Timed Warp Is Random (A, B, C or D)", NULL, NULL },
    //41
    { jwin_check_proc,      15,   98,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Damage Combos Ignore Boots", NULL, NULL },
    //S.Flags 1
    { jwin_check_proc,     165,  138,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Sensitive Warps are Direct", NULL, NULL },
    { jwin_check_proc,     165,   88,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Secrets are Temporary", NULL, NULL },
    //44
    { jwin_check_proc,     165,  128,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Toggle 'No Diving'", NULL, NULL },
    //S.Flags 1
    //45
    { jwin_check_proc,      15,   78,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Treat as Interior Screen", NULL, NULL },
    { jwin_check_proc,      15,   88,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Treat as NES Dungeon Screen", NULL, NULL },
    { jwin_check_proc,     165,   98,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Hit All Triggers->Perm Secret", NULL, NULL },
    //48
    { jwin_check_proc,      15,  148,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Continue Here", NULL, NULL },
    { jwin_check_proc,      15,  158,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "No Continue Here After Warp", NULL, NULL },
    //50, S.Flags 1
    { jwin_check_proc,      165, 108,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Hit All Triggers->16-31", NULL, NULL },
    //51
    { jwin_check_proc,       15, 108,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Toggle Rings Affect Combos", NULL, NULL },
    { jwin_check_proc,       15, 178,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "FF Combos Wrap Around", NULL, NULL },
    { jwin_check_proc,       15, 188,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "No FFC Carryover", NULL, NULL },
    //S.Flags 1
    //54
    { jwin_check_proc,      15,  168,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Toggle Layer 3 is Background", NULL, NULL },
    { jwin_check_proc,      15,  158,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Toggle Layer 2 is Background", NULL, NULL },
    { jwin_check_proc,      15,   88,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Item Falls From Ceiling", NULL, NULL },
    { jwin_check_proc,      15,    98,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Sideview Gravity", NULL, NULL },
    { jwin_check_proc,      15,   128,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "No Player Marker in Minimap", NULL, NULL },
    //S. Flags 2
    { jwin_check_proc,      165,   88,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Whistle->Palette Change", NULL, NULL },
    { jwin_check_proc,      165,   98,  160+1,  8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Whistle->Dry Lake", NULL, NULL },
    { d_dummy_proc,         160,  56-24,     0,  8,    vc(15),  vc(1),  0,       0,          0,             0,       NULL, NULL, NULL },
    //62
    { jwin_ctext_proc,       225,   68,  180,    8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "No Reset     /   No Carry Over", NULL, NULL },
    { jwin_ctext_proc,       225,   78,  140,    8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Secrets", NULL, NULL },
    { jwin_ctext_proc,       225,   88,  140,    8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Item", NULL, NULL },
    { jwin_ctext_proc,       225,   98,  140,    8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Special Item", NULL, NULL },
    { jwin_ctext_proc,       225,   108,  140,    8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Lock Block", NULL, NULL },
    { jwin_ctext_proc,       225,   118,  140,    8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Boss Lock Block", NULL, NULL },
    { jwin_ctext_proc,       225,   128,  140,    8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Chest", NULL, NULL },
    { jwin_ctext_proc,       225,   138,  140,    8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Locked Chest", NULL, NULL },
    { jwin_ctext_proc,       225,   148,  140,    8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Boss Locked Chest", NULL, NULL },
    { jwin_ctext_proc,       225,   168,  140,    8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Door Down(D)", NULL, NULL },
    { jwin_ctext_proc,       225,   178,  140,    8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Door Left(D)", NULL, NULL },
    { jwin_ctext_proc,       225,   188,  140,    8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Door Right(D)", NULL, NULL },
    //74
    { jwin_check_proc,      160,  78,  8+1,  8+1,       vc(14),        vc(1),              0,  0,    1,             0,       NULL, NULL, NULL },
    { jwin_check_proc,      160,  88,  8+1,  8+1,       vc(14),        vc(1),              0,  0,          1,             0,       NULL, NULL, NULL },
    { jwin_check_proc,      160,  98,  8+1,  8+1,       vc(14),        vc(1),              0,  0,          1,             0,       NULL, NULL, NULL },
    { jwin_check_proc,      160,  108,  8+1,  8+1,      vc(14),        vc(1),              0,  0,          1,             0,       NULL, NULL, NULL },
    { jwin_check_proc,      160,  118,  8+1,  8+1,      vc(14),        vc(1),              0,  0,          1,             0,       NULL, NULL, NULL },
    { jwin_check_proc,      160,  128,  8+1,  8+1,      vc(14),        vc(1),              0,  0,          1,             0,       NULL, NULL, NULL },
    { jwin_check_proc,      160,  138,  8+1,  8+1,      vc(14),        vc(1),              0,  0,          1,             0,       NULL, NULL, NULL },
    { jwin_check_proc,      160,  148,  8+1,  8+1,      vc(14),        vc(1),              0,  0,          1,             0,       NULL, NULL, NULL },
    { jwin_check_proc,      160,  168,  8+1,  8+1,      vc(14),        vc(1),              0,  0,          1,             0,       NULL, NULL, NULL },
    { jwin_check_proc,      160,  178,  8+1,  8+1,      vc(14),        vc(1),              0,  0,          1,             0,       NULL, NULL, NULL },
    { jwin_check_proc,      160,  188,  8+1,  8+1,      vc(14),        vc(1),              0,  0,          1,             0,       NULL, NULL, NULL },
    { jwin_check_proc,      280,  78,  8+1,  8+1,       vc(14),        vc(1),              0,  0,          1,             0,       NULL, NULL, NULL },
    { jwin_check_proc,      280,  88,  8+1,  8+1,       vc(14),        vc(1),              0,  0,          1,             0,       NULL, NULL, NULL },
    { jwin_check_proc,      280,  98,  8+1,  8+1,       vc(14),        vc(1),              0,  0,          1,             0,       NULL, NULL, NULL },
    { jwin_check_proc,      280,  108,  8+1,  8+1,      vc(14),        vc(1),              0,  0,  1,             0,       NULL, NULL, NULL },
    { jwin_check_proc,      280,  118,  8+1,  8+1,      vc(14),        vc(1),              0,  0,  1,             0,       NULL, NULL, NULL },
    { jwin_check_proc,      280,  128,  8+1,  8+1,      vc(14),        vc(1),              0,  0,  1,             0,       NULL, NULL, NULL },
    { jwin_check_proc,      280,  138,  8+1,  8+1,      vc(14),        vc(1),              0,  0,  1,  0,       NULL, NULL, NULL },
    { jwin_check_proc,      280,  148,  8+1,  8+1,      vc(14),        vc(1),              0,  0,  1,  0,       NULL, NULL, NULL },
    //93
    { jwin_text_proc,       17,  130,    120,   8,      vc(11),        vc(1),              0,  0,  0,  0, (void *) "Screen MIDI:", NULL, NULL },
    { jwin_droplist_proc,   17,  138,   133,   16, jwin_pal[jcTEXTFG], jwin_pal[jcTEXTBG], 0,  0,  1,  0, (void *) &screenmidi_list, NULL, NULL },
    { jwin_text_proc,       17,   68,   200,    8,      vc(14),        vc(1),              0,  0,  0,  0, (void *) "Damage Combo Sensitivity:", NULL, NULL },
    { jwin_edit_proc,      140,   66,    40,   16,      vc(12),        vc(1),              0,  0,  1,  0,       NULL, NULL, NULL },
    //97
    { jwin_ctext_proc,     225,   158,  140,     8,     vc(14),        vc(1),              0,  0,  0,  0, (void *) "Door Up(D)", NULL, NULL },
    { jwin_check_proc,     160,   158,  8+1,   8+1,     vc(14),        vc(1),              0,  0,  1,  0,       NULL, NULL, NULL },
    
    { jwin_text_proc,       17,   88,   200,     8,     vc(14),         vc(1),             0,  0,  0,  0, (void *) "Ambient Sound:", NULL, NULL },
    { jwin_droplist_proc,  140,   86,   140,    16,          0,             0,             0,  0,  3,  0, (void *) & sfx_list, NULL, NULL },
    
    { jwin_text_proc,       17,   108,   200,    8,     vc(14),         vc(1),             0,  0,  0,  0, (void *) "Boss Roar Sound:", NULL, NULL },
    { jwin_droplist_proc,  140,   106,   140,   16,         0,             0,              0,  0,  3,  0, (void *) & sfx_list, NULL, NULL },
    
    { jwin_text_proc,       17,   148,   200,    8,     vc(14),         vc(1),             0,  0,  0,  0, (void *) "Secret Sound:", NULL, NULL },
    { jwin_droplist_proc,  140,   146,   140,   16,          0,             0,             0,  0,  3,  0, (void *) & sfx_list, NULL, NULL },
    { jwin_text_proc,       17,   128,   200,    8,     vc(14),         vc(1),             0,  0,  0,  0, (void *) "Hold Up Item Sound:", NULL, NULL },
    { jwin_droplist_proc,  140,   126,   140,   16,          0,             0,             0,  0,  3,  0, (void *) & sfx_list, NULL, NULL },
    //107
    { jwin_check_proc,      15,   78,   160+1,  8+1,     vc(14),        vc(1),             0,  0,  1,  0,       NULL, NULL, NULL }, // Zora
    { jwin_check_proc,      15,   88,   160+1,  8+1,     vc(14),        vc(1),             0,  0,  1,  0,       NULL, NULL, NULL }, // Corner Traps
    { jwin_check_proc,      15,   98,   160+1,  8+1,     vc(14),        vc(1),             0,  0,  1,  0,       NULL, NULL, NULL }, // Middle Traps
    { jwin_check_proc,      15,   108,  160+1,  8+1,     vc(14),        vc(1),             0,  0,  1,  0,       NULL, NULL, NULL }, // Falling Rocks
    { jwin_check_proc,      15,   118,  160+1,  8+1,     vc(14),        vc(1),             0,  0,  1,  0,       NULL, NULL, NULL }, // Statue Fire
    { jwin_check_proc,      15,   138,  160+1,  8+1,     vc(14),        vc(1),             0,  0,  1,  0, (void *) "First Enemy Is 'Ring Leader'", NULL, NULL },
    { jwin_check_proc,      15,   148,  160+1,  8+1,     vc(14),        vc(1),             0,  0,  1,  0, (void *) "First Enemy Carries Item", NULL, NULL },
    // 'Invisible Enemies' goes between these two
    { jwin_check_proc,      15,   168,  160+1,  8+1,     vc(14),        vc(1),             0,  0,  1,  0, (void *) "Dungeon Boss (Don't Return)", NULL, NULL },
    { jwin_text_proc,       15,   68,     200,    8,     vc(14),        vc(1),             0,  0,  0,  0, (void *) "Environmental Enemies:", NULL, NULL },
    { jwin_text_proc,       15,   128,    200,    8,     vc(14),        vc(1),             0,  0,  0,  0, (void *) "Enemy Flags:", NULL, NULL },
    { jwin_text_proc,       15,   68,     200,    8,     vc(14),        vc(1),             0,  0,  0,  0, (void *) "Timed Warp: After a given time, Side Warp A is triggered.", NULL, NULL },
    //118
    { jwin_text_proc,       15,   68,     120,    8,     vc(11),        vc(1),             0,  0,  0,  0, (void *) "Room Type", NULL, NULL },
    { jwin_text_proc,       15,  108,     120,    8,     vc(11),        vc(1),             0,  0,  0,  0, (void *) "View", NULL, NULL },
    { jwin_text_proc,      165,   68,     120,    8,     vc(11),        vc(1),             0,  0,  0,  0, (void *) "Secrets", NULL, NULL },
    { jwin_text_proc,      165,  118,     120,    8,     vc(11),        vc(1),             0,  0,  0,  0, (void *) "Warp", NULL, NULL },
    { jwin_text_proc,       15,   68,     120,    8,     vc(11),        vc(1),             0,  0,  0,  0, (void *) "Items", NULL, NULL },
    { jwin_text_proc,       15,   68,     120,    8,     vc(11),        vc(1),             0,  0,  0,  0, (void *) "Combos", NULL, NULL },
    { jwin_text_proc,       15,  118,     120,    8,     vc(11),        vc(1),             0,  0,  0,  0, (void *) "Save", NULL, NULL },
    { jwin_text_proc,       15,  168,     120,    8,     vc(11),        vc(1),             0,  0,  0,  0, (void *) "FFC", NULL, NULL },
    { jwin_text_proc,      165,   68,     120,    8,     vc(11),        vc(1),             0,  0,  0,  0, (void *) "Whistle", NULL, NULL },
    { jwin_text_proc,      165,  108,     120,    8,     vc(11),        vc(1),             0,  0,  0,  0, (void *) "Misc.", NULL, NULL },
    //128
    { jwin_check_proc,     165,  138,   160+1,  8+1,     vc(14),        vc(1),             0,  0,  1,  0, (void *) "General Use 1 (Scripts)", NULL, NULL },
    { jwin_check_proc,     165,  148,   160+1,  8+1,     vc(14),        vc(1),             0,  0,  1,  0, (void *) "General Use 2 (Scripts)", NULL, NULL },
    { jwin_check_proc,     165,  158,   160+1,  8+1,     vc(14),        vc(1),             0,  0,  1,  0, (void *) "General Use 3 (Scripts)", NULL, NULL },
    { jwin_check_proc,     165,  168,   160+1,  8+1,     vc(14),        vc(1),             0,  0,  1,  0, (void *) "General Use 4 (Scripts)", NULL, NULL },
    { jwin_check_proc,     165,  178,   160+1,  8+1,     vc(14),        vc(1),             0,  0,  1,  0, (void *) "General Use 5 (Scripts)", NULL, NULL },
    //133
    { jwin_text_proc,       17,  160,     120,    8,     vc(11),        vc(1),             0,  0,  0,  0, (void *) "Lens Effect:", NULL, NULL },
    { jwin_droplist_proc,   17,  168,     133,   16,          0,            0,             0,  0,  0,  0, (void *) & lenseffect_list, NULL, NULL },
    //135
    { jwin_check_proc,     165,  158,   160+1,  8+1,     vc(14),        vc(1),             0,  0,  1,  0, (void *) "Maze Overrides Side Warps", NULL, NULL },
    { jwin_check_proc,      15,   98,   160+1,  8+1,     vc(14),        vc(1),             0,  0,  1,  0, (void *) "Secrets->Item", NULL, NULL },
    { jwin_check_proc,      15,  108,   160+1,  8+1,    vc(14),         vc(1),             0,  0,  1,  0, (void *) "Item->Secrets", NULL, NULL },
    { jwin_check_proc,      15,  118,   160+1,  8+1,    vc(14),         vc(1),             0,  0,  1,  0, (void *) "Item->Secret is permanent", NULL, NULL },
    { jwin_check_proc,      15,  128,   160+1,  8+1,    vc(14),         vc(1),             0,  0,  1,  0, (void *) "Item always returns", NULL, NULL },
    //140
	{ jwin_check_proc,      15,  138,   160+1,  8+1,    vc(14),         vc(1),             0,  0,  1,  0, (void *) "Special Item always returns", NULL, NULL },
    { jwin_check_proc,      15,  188,   160+1,  8+1,    vc(14),         vc(1),             0,  0,  1,  0, (void *) "...Dithered Darkness", NULL, NULL },
    { jwin_check_proc,      15,  198,   160+1,  8+1,    vc(14),         vc(1),             0,  0,  1,  0, (void *) "...Transparent Darkness", NULL, NULL },
    { jwin_check_proc,      165, 178,   160+1,  8+1,    vc(14),         vc(1),             0,  0,  1,  0, (void *) "Disable Magic Mirror", NULL, NULL },
    { jwin_check_proc,      165, 178,   160+1,  8+1,    vc(14),         vc(1),             0,  0,  1,  0, (void *) "Chain 'Enemies->' triggers", NULL, NULL },
	{ NULL,                  0,    0,       0,    0,          0,            0,             0,  0,  0,  0,       NULL, NULL,  NULL }
};



const char *screenscriptdroplist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = biscreens_cnt;
        return NULL;
    }
    
    return biscreens[index].first.c_str();
}

//droplist like the dialog proc, naming scheme for this stuff is awful...
static ListData screenscript_list(screenscriptdroplist, &pfont);


#include "zq_files.h"
//to do: Make string boxes larger, and split into two tabs. 
static DIALOG screenscript_dlg[] =
{
    // (dialog proc)     (x)   (y)   (w)   (h)   (fg)                 (bg)                  (key)    (flags)     (d1)           (d2)     (dp)
    
{ jwin_win_proc,       0,   10,  310,  224,  vc(14),              vc(1),                  0,      D_EXIT,     0,             0,       (void *) "Screen Script", NULL, NULL },
    { d_timer_proc,        0,    0,    0,    0,  0,                   0,                      0,           0,     0,             0,       NULL, NULL, NULL },
    { d_dummy_proc,         5,   26,   300,  202,    vc(14),   vc(1),      0,      0,          1,             0, (void *) gamemisc_tabs,	NULL, (void *)gamemiscarray_dlg },
    {  d_dummy_proc,           240,    144,     40,      8,    vc(14),                 vc(1),                   0,    0,           0,    0,  NULL,													       NULL,   NULL                 },
    {  d_dummy_proc,           240,    144,     40,      8,    vc(14),                 vc(1),                   0,    0,           0,    0,  NULL,													       NULL,   NULL                 },
    
    //5
    { jwin_text_proc,           10,    42+2,     96,      8,    vc(14),                 vc(1),                   0,       0,           0,    0, (void *) "InitD[0]:",                      NULL,   NULL                  },
    { jwin_text_proc,           10,    42+20+2,     96,      8,    vc(14),                 vc(1),                   0,       0,           0,    0, (void *) "InitD[1]:",                      NULL,   NULL                  },
    { jwin_text_proc,           10,    42+40+2,     96,      8,    vc(14),                 vc(1),                   0,       0,           0,    0, (void *) "InitD[2]:",                      NULL,   NULL                  },
    
    
    //8
    { jwin_text_proc,           10,    42+60+2,     96,      8,    vc(14),                 vc(1),                   0,       0,           0,    0, (void *) "InitD[3]:",                      NULL,   NULL                  },
    { jwin_text_proc,           10,    42+80+2,     96,      8,    vc(14),                 vc(1),                   0,       0,           0,    0, (void *) "InitD[4]:",                      NULL,   NULL                  },
    { jwin_text_proc,           10,    42+100+2,     96,      8,    vc(14),                 vc(1),                   0,       0,           0,    0, (void *) "InitD[5]:",                      NULL,   NULL                  },
    { jwin_text_proc,           10,    42+120+2,     96,      8,    vc(14),                 vc(1),                   0,       0,           0,    0, (void *) "InitD[6]:",                      NULL,   NULL                  },
    { jwin_text_proc,           10,    42+140+2,     96,      8,    vc(14),                 vc(1),                   0,       0,           0,    0, (void *) "InitD[7]:",                      NULL,   NULL                  },
    
    //13
     { jwin_numedit_swap_zsint_proc,     60,   42,   100-12,    16, vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
     { jwin_numedit_swap_zsint_proc,     60,   42+20,   100-12,    16, vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
    { jwin_numedit_swap_zsint_proc,     60,   42+40,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
    { jwin_numedit_swap_zsint_proc,     60,   42+60,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
    { jwin_numedit_swap_zsint_proc,     60,   42+80,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
    //18
    { jwin_numedit_swap_zsint_proc,     60,   42+100,   100-12,    16, vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
    { jwin_numedit_swap_zsint_proc,     60,   42+120,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
    { jwin_numedit_swap_zsint_proc,     60,   42+140,   100-12,    16,  vc(12),   vc(1),   0,       0,          64,             0,       NULL, NULL, NULL },
    //21
    { jwin_text_proc,          112+10+20+34+1-4,    42+2,     35,      8,    vc(14),                 vc(1),                   0,       0,           0,    0, (void *) "Script:",                            NULL,   NULL                  },
    //22
    { jwin_droplist_proc,      112+10+20+34-4,    42+10,     120,      16, jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],           0,       0,           1,    0, (void *) &screenscript_list,                   NULL,   NULL 				   },
   
    { jwin_button_proc,       70,    202,     61,     21,    vc(14),                 vc(1),                  13,       D_EXIT,      0,    0, (void *) "OK",                                  NULL,   NULL                  },
    { jwin_button_proc,      170,    202,     61,     21,    vc(14),                 vc(1),                  27,       D_EXIT,      0,    0, (void *) "Cancel",                              NULL,   NULL                  },
    //25
    { jwin_check_proc,          112+10+20+34-4,    42+30,     60,      9,    vc(14),                 vc(1),                   0,       0,           1,    0, (void *) "Run On Screen Init",   NULL,   NULL                  },
	{ jwin_swapbtn_proc,  148,      42,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
    { jwin_swapbtn_proc,  148,   42+20,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
    { jwin_swapbtn_proc,  148,   42+40,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
    { jwin_swapbtn_proc,  148,   42+60,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
    //30
	{ jwin_swapbtn_proc,  148,   42+80,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
    { jwin_swapbtn_proc,  148,  42+100,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
    { jwin_swapbtn_proc,  148,  42+120,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
    { jwin_swapbtn_proc,  148,  42+140,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
    
    { NULL,                0,    0,    0,    0,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL }
};

void EditScreenScript()
{
	screenscript_dlg[0].dp2=lfont;
	char initd[8][16];
	int32_t script = 0;

	mapscr *theMap = &TheMaps[Map.getCurrMap()*MAPSCRS+Map.getCurrScr()];
	
	build_biscreens_list();
	memset(initd, 0, sizeof(initd));
	for ( int32_t q = 0; q < biscreens_cnt; q++)
	{
		if(biscreens[q].second == theMap->script -1)
		{
			script = q; //sprite script goes after this
			//al_trace("Item has sprite script: %d\n", q);
		}
		
	}
	screenscript_dlg[22].d1 = script;
	screenscript_dlg[25].flags = Map.CurrScr()->preloadscript ? D_SELECTED : 0;
	
	for ( int32_t q = 0; q < 8; q++ )
	{
		screenscript_dlg[13+q].dp = initd[q];
		screenscript_dlg[13+q].fg = theMap->screeninitd[q];
		screenscript_dlg[13+q].dp3 = &(screenscript_dlg[26+q]);
	}
	int32_t ret;
	if(is_large)
		large_dialog(screenscript_dlg);
        
	do
	{
		ret = zc_popup_dialog(screenscript_dlg,23);
		build_biscreens_list();
		theMap->script = biscreens[screenscript_dlg[22].d1].second + 1;
		
		if(screenscript_dlg[25].flags & D_SELECTED)
			theMap->preloadscript = 1;
		else 
			theMap->preloadscript = 0;
		
		for(int32_t j=0; j<8; j++)
			theMap->screeninitd[j] = screenscript_dlg[13+j].fg;
		
	}
	while(ret==22);//press OK
}

int32_t onScreenScript()
{
    EditScreenScript();
    saved=false;
    return D_O_K;
}

int32_t onScrData()
{
	restore_mouse();
	char timedstring[6];
	// char nmapstring[4];
	// char nscrstring[3];
	char csensstring[4];
	char tics_secs_str[80];
	sprintf(tics_secs_str, "=0.00 seconds");
	char zora_str[85];
	char ctraps_str[85];
	char mtraps_str[85];
	char fallrocks_str[85];
	char statues_str[94];
	
	sprintf(zora_str, "Zora");
	sprintf(ctraps_str, "Corner Traps");
	sprintf(mtraps_str, "Middle Traps");
	sprintf(fallrocks_str, "Falling Rocks");
	sprintf(statues_str, "Statues Shoot Fireballs");
	
	{
		bool foundzora = false;
		bool foundctraps = false;
		bool foundmtraps = false;
		bool foundfallrocks = false;
		bool foundstatues = false;
		
		for(int32_t i=0; i<eMAXGUYS && !(foundzora && foundctraps && foundmtraps && foundfallrocks && foundstatues); i++)
		{
			if(!foundzora && guysbuf[i].flags2 & eneflag_zora)
			{
				sprintf(zora_str, "Zora (1 x %s)", guy_string[i]);
				foundzora = true;
			}
			
			if(!foundctraps && guysbuf[i].flags2 & eneflag_trap)
			{
				sprintf(ctraps_str, "Corner Traps (4 x %s)", guy_string[i]);
				foundctraps = true;
			}
			
			if(!foundmtraps && guysbuf[i].flags2 & eneflag_trp2)
			{
				sprintf(mtraps_str, "Middle Traps (2 x %s)", guy_string[i]);
				foundmtraps = true;
			}
			
			if(!foundfallrocks && guysbuf[i].flags2 & eneflag_rock)
			{
				sprintf(fallrocks_str, "Falling Rocks (3 x %s)", guy_string[i]);
				foundfallrocks = true;
			}
			
			if(!foundstatues && guysbuf[i].flags2 & eneflag_fire)
			{
				sprintf(statues_str, "Shooting Statues (%s per combo)", guy_string[i]);
				foundstatues = true;
			}
		}
	}
	scrdata_dlg[107].dp= zora_str;
	scrdata_dlg[108].dp= ctraps_str;
	scrdata_dlg[109].dp= mtraps_str;
	scrdata_dlg[110].dp= fallrocks_str;
	scrdata_dlg[111].dp= statues_str;
	
	scrdata_dlg[0].dp2=lfont;
	sprintf(timedstring,"%d",Map.CurrScr()->timedwarptics);
	//  sprintf(nmapstring,"%d",(int32_t)Map.CurrScr()->nextmap);
	// sprintf(nscrstring,"%x",(int32_t)Map.CurrScr()->nextscr);
	sprintf(csensstring,"%d",(int32_t)Map.CurrScr()->csensitive);
	
	byte f = Map.CurrScr()->flags;
	
	for(int32_t i=0; i<8; i++)
	{
		scrdata_dlg[i+6].flags = (f&1) ? D_SELECTED : 0;
		f>>=1;
	}
	
	f = Map.CurrScr()->flags2 >> 4;
	
	for(int32_t i=0; i<4; i++)
	{
		scrdata_dlg[i+14].flags = (f&1) ? D_SELECTED : 0;
		f>>=1;
	}
	
	f = Map.CurrScr()->flags3;
	
	for(int32_t i=0; i<8; i++)
	{
		scrdata_dlg[i+18].flags = (f&1) ? D_SELECTED : 0;
		f>>=1;
	}
	
	f = Map.CurrScr()->flags4;
	scrdata_dlg[26].flags = (f&4) ? D_SELECTED : 0;
	scrdata_dlg[27].flags = (f&8) ? D_SELECTED : 0;
	scrdata_dlg[29].dp=timedstring;
	scrdata_dlg[30].dp=tics_secs_str;
	// scrdata_dlg[34].dp=nmapstring;
	scrdata_dlg[34].d1 = (Map.CurrScr()->nextmap);
	// scrdata_dlg[35].dp=nscrstring;
	scrdata_dlg[35].d1 = (Map.CurrScr()->nextscr);
	scrdata_dlg[96].dp=csensstring;
	scrdata_dlg[100].d1= (int32_t)Map.CurrScr()->oceansfx;
	scrdata_dlg[102].d1= (int32_t)Map.CurrScr()->bosssfx;
	scrdata_dlg[104].d1= (int32_t)Map.CurrScr()->secretsfx;
	scrdata_dlg[106].d1= (int32_t)Map.CurrScr()->holdupsfx;
	scrdata_dlg[36].flags = (f&16) ? D_SELECTED : 0;
	//scrdata_dlg[37].flags = (f&32) ? D_SELECTED : 0;
	scrdata_dlg[38].flags = (f&64) ? D_SELECTED : 0;
	scrdata_dlg[39].flags = (f&128) ? D_SELECTED : 0;
	f = Map.CurrScr()->flags5;
	scrdata_dlg[40].flags = (f&1) ? D_SELECTED : 0;
	scrdata_dlg[41].flags = (f&2) ? D_SELECTED : 0;
	scrdata_dlg[37].flags = (f&4) ? D_SELECTED : 0;
	scrdata_dlg[42].flags = (f&8) ? D_SELECTED : 0;
	scrdata_dlg[43].flags = (f&16) ? D_SELECTED : 0;
	scrdata_dlg[44].flags = (f&64) ? D_SELECTED : 0;
	scrdata_dlg[53].flags = (f&128) ? D_SELECTED : 0;
	f = Map.CurrScr()->flags6;
	scrdata_dlg[45].flags = (f&1) ? D_SELECTED : 0;
	scrdata_dlg[46].flags = (f&2) ? D_SELECTED : 0;
	scrdata_dlg[47].flags = (f&4) ? D_SELECTED : 0;
	scrdata_dlg[48].flags = (f&8) ? D_SELECTED : 0;
	scrdata_dlg[49].flags = (f&16) ? D_SELECTED : 0;
	scrdata_dlg[50].flags = (f&32) ? D_SELECTED : 0;
	scrdata_dlg[51].flags = (f&64) ? D_SELECTED : 0;
	scrdata_dlg[52].flags = (f&128) ? D_SELECTED : 0;
	f = Map.CurrScr()->flags7;
	scrdata_dlg[54].flags = (f&1) ? D_SELECTED : 0;
	scrdata_dlg[55].flags = (f&2) ? D_SELECTED : 0;
	scrdata_dlg[56].flags = (f&4) ? D_SELECTED : 0;
	scrdata_dlg[57].flags = (f&8) ? D_SELECTED : 0;
	scrdata_dlg[58].flags = (f&16) ? D_SELECTED : 0;
	scrdata_dlg[59].flags = (f&64) ? D_SELECTED : 0;
	scrdata_dlg[60].flags = (f&128) ? D_SELECTED : 0;
	f = Map.CurrScr()->flags8;
	scrdata_dlg[128].flags = (f&1) ? D_SELECTED : 0;
	scrdata_dlg[129].flags = (f&2) ? D_SELECTED : 0;
	scrdata_dlg[130].flags = (f&4) ? D_SELECTED : 0;
	scrdata_dlg[131].flags = (f&8) ? D_SELECTED : 0;
	scrdata_dlg[132].flags = (f&16) ? D_SELECTED : 0;
	scrdata_dlg[135].flags = (f&32) ? D_SELECTED : 0;
	scrdata_dlg[136].flags = (f&fSECRETITEM) ? D_SELECTED : 0;
	scrdata_dlg[137].flags = (f&fITEMSECRET) ? D_SELECTED : 0;
	f = Map.CurrScr()->flags9;
	scrdata_dlg[138].flags = (f&fITEMSECRETPERM) ? D_SELECTED : 0;
	scrdata_dlg[139].flags = (f&fITEMRETURN) ? D_SELECTED : 0;
	scrdata_dlg[140].flags = (f&fBELOWRETURN) ? D_SELECTED : 0;
	scrdata_dlg[141].flags = (f&fDARK_DITHER) ? D_SELECTED : 0;
	scrdata_dlg[142].flags = (f&fDARK_TRANS) ? D_SELECTED : 0;
	scrdata_dlg[143].flags = (f&fDISABLE_MIRROR) ? D_SELECTED : 0;
	scrdata_dlg[144].flags = (f&fENEMY_WAVES) ? D_SELECTED : 0;
	
	word g = Map.CurrScr()->noreset;
	scrdata_dlg[74].flags = (g&mSECRET) ? D_SELECTED : 0;
	scrdata_dlg[75].flags = (g&mITEM) ? D_SELECTED : 0;
	scrdata_dlg[76].flags = (g&mSPECIALITEM) ? D_SELECTED : 0;
	scrdata_dlg[77].flags = (g&mLOCKBLOCK) ? D_SELECTED : 0;
	scrdata_dlg[78].flags = (g&mBOSSLOCKBLOCK) ? D_SELECTED : 0;
	scrdata_dlg[79].flags = (g&mCHEST) ? D_SELECTED : 0;
	scrdata_dlg[80].flags = (g&mLOCKEDCHEST) ? D_SELECTED : 0;
	scrdata_dlg[81].flags = (g&mBOSSCHEST) ? D_SELECTED : 0;
	scrdata_dlg[82].flags = (g&mDOOR_DOWN) ? D_SELECTED : 0;
	scrdata_dlg[83].flags = (g&mDOOR_LEFT) ? D_SELECTED : 0;
	scrdata_dlg[84].flags = (g&mDOOR_RIGHT) ? D_SELECTED : 0;
	scrdata_dlg[98].flags = (g&mDOOR_UP) ? D_SELECTED : 0;
	g = Map.CurrScr()->nocarry;
	scrdata_dlg[85].flags = (g&mSECRET) ? D_SELECTED : 0;
	scrdata_dlg[86].flags = (g&mITEM) ? D_SELECTED : 0;
	scrdata_dlg[87].flags = (g&mSPECIALITEM) ? D_SELECTED : 0;
	scrdata_dlg[88].flags = (g&mLOCKBLOCK) ? D_SELECTED : 0;
	scrdata_dlg[89].flags = (g&mBOSSLOCKBLOCK) ? D_SELECTED : 0;
	scrdata_dlg[90].flags = (g&mCHEST) ? D_SELECTED : 0;
	scrdata_dlg[91].flags = (g&mLOCKEDCHEST) ? D_SELECTED : 0;
	scrdata_dlg[92].flags = (g&mBOSSCHEST) ? D_SELECTED : 0;
	
	scrdata_dlg[94].d1 = (Map.CurrScr()->screen_midi>=0)?(Map.CurrScr()->screen_midi+1):(-(Map.CurrScr()->screen_midi+1));
	scrdata_dlg[134].d1 = Map.CurrScr()->lens_layer==llNORMAL?0:(Map.CurrScr()->lens_layer&llLENSSHOWS?6:0)+(Map.CurrScr()->lens_layer&7)+1;
	
	byte h=Map.CurrScr()->enemyflags;
	
	for(int32_t i=0; i<8; i++)
	{
		scrdata_dlg[i+107].flags = (h&1)?D_SELECTED:0;
		h>>=1;
	}
	
	if(is_large)
		large_dialog(scrdata_dlg);
		
	if(zc_popup_dialog(scrdata_dlg,-1)==2)
	{
		f=0;
		
		for(int32_t i=7; i>=0; i--)
		{
			f<<=1;
			f |= scrdata_dlg[i+6].flags & D_SELECTED ? 1:0;
		}
		
		Map.CurrScr()->flags = f;
		
		f=0;
		
		for(int32_t i=3; i>=0; i--)
		{
			f<<=1;
			f |= scrdata_dlg[i+14].flags & D_SELECTED ? 1:0;
		}
		
		Map.CurrScr()->flags2 &= 0x0F;
		Map.CurrScr()->flags2 |= f<<4;
		
		f=0;
		
		for(int32_t i=7; i>=0; i--)
		{
			f<<=1;
			f |= scrdata_dlg[i+18].flags & D_SELECTED ? 1:0;
		}
		
		Map.CurrScr()->flags3 = f;
		
		f=0;
		f |= scrdata_dlg[26].flags & D_SELECTED ? 4:0;
		f |= scrdata_dlg[27].flags & D_SELECTED ? 8:0;
		f |= scrdata_dlg[36].flags & D_SELECTED ? 16:0;
		//f |= scrdata_dlg[37].flags & D_SELECTED ? 32:0;
		f |= scrdata_dlg[38].flags & D_SELECTED ? 64:0;
		f |= scrdata_dlg[39].flags & D_SELECTED ? 128:0;
		Map.CurrScr()->flags4 = f;
		
		f=0;
		f |= scrdata_dlg[40].flags & D_SELECTED ? 1:0;
		f |= scrdata_dlg[41].flags & D_SELECTED ? 2:0;
		f |= scrdata_dlg[37].flags & D_SELECTED ? 4:0;
		f |= scrdata_dlg[42].flags & D_SELECTED ? 8:0;
		f |= scrdata_dlg[43].flags & D_SELECTED ? 16:0;
		f |= scrdata_dlg[44].flags & D_SELECTED ? 64:0;
		f |= scrdata_dlg[53].flags & D_SELECTED ? 128:0;
		Map.CurrScr()->flags5 = f;
		
		f=0;
		f |= scrdata_dlg[45].flags & D_SELECTED ? 1:0;
		f |= scrdata_dlg[46].flags & D_SELECTED ? 2:0;
		f |= scrdata_dlg[47].flags & D_SELECTED ? 4:0;
		f |= scrdata_dlg[48].flags & D_SELECTED ? 8:0;
		f |= scrdata_dlg[49].flags & D_SELECTED ? 16:0;
		f |= scrdata_dlg[50].flags & D_SELECTED ? 32:0;
		f |= scrdata_dlg[51].flags & D_SELECTED ? 64:0;
		f |= scrdata_dlg[52].flags & D_SELECTED ? 128:0;
		Map.CurrScr()->flags6 = f;
		
		f=0;
		f |= scrdata_dlg[54].flags & D_SELECTED ? 1:0;
		f |= scrdata_dlg[55].flags & D_SELECTED ? 2:0;
		f |= scrdata_dlg[56].flags & D_SELECTED ? 4:0;
		f |= scrdata_dlg[57].flags & D_SELECTED ? 8:0;
		f |= scrdata_dlg[58].flags & D_SELECTED ? 16:0;
		f |= scrdata_dlg[59].flags & D_SELECTED ? 64:0;
		f |= scrdata_dlg[60].flags & D_SELECTED ? 128:0;
		Map.CurrScr()->flags7 = f;
		
		f=0;
		f |= scrdata_dlg[128].flags & D_SELECTED ? 1:0;
		f |= scrdata_dlg[129].flags & D_SELECTED ? 2:0;
		f |= scrdata_dlg[130].flags & D_SELECTED ? 4:0;
		f |= scrdata_dlg[131].flags & D_SELECTED ? 8:0;
		f |= scrdata_dlg[132].flags & D_SELECTED ? 16:0;
		f |= scrdata_dlg[135].flags & D_SELECTED ? 32:0;
		f |= scrdata_dlg[136].flags & D_SELECTED ? fSECRETITEM:0;
		f |= scrdata_dlg[137].flags & D_SELECTED ? fITEMSECRET:0;
		Map.CurrScr()->flags8 = f;

		f=0;
		f |= scrdata_dlg[138].flags & D_SELECTED ? fITEMSECRETPERM:0;
		f |= scrdata_dlg[139].flags & D_SELECTED ? fITEMRETURN:0;
		f |= scrdata_dlg[140].flags & D_SELECTED ? fBELOWRETURN:0;
		f |= scrdata_dlg[141].flags & D_SELECTED ? fDARK_DITHER:0;
		f |= scrdata_dlg[142].flags & D_SELECTED ? fDARK_TRANS:0;
		f |= scrdata_dlg[143].flags & D_SELECTED ? fDISABLE_MIRROR:0;
		f |= scrdata_dlg[144].flags & D_SELECTED ? fENEMY_WAVES:0;
		Map.CurrScr()->flags9 = f;
		
		g=0;
		g |= scrdata_dlg[74].flags & D_SELECTED ? mSECRET:0;
		g |= scrdata_dlg[75].flags & D_SELECTED ? mITEM:0;
		g |= scrdata_dlg[76].flags & D_SELECTED ? mSPECIALITEM:0;
		g |= scrdata_dlg[77].flags & D_SELECTED ? mLOCKBLOCK:0;
		g |= scrdata_dlg[78].flags & D_SELECTED ? mBOSSLOCKBLOCK:0;
		g |= scrdata_dlg[79].flags & D_SELECTED ? mCHEST:0;
		g |= scrdata_dlg[80].flags & D_SELECTED ? mLOCKEDCHEST:0;
		g |= scrdata_dlg[81].flags & D_SELECTED ? mBOSSCHEST:0;
		g |= scrdata_dlg[82].flags & D_SELECTED ? mDOOR_DOWN:0;
		g |= scrdata_dlg[83].flags & D_SELECTED ? mDOOR_LEFT:0;
		g |= scrdata_dlg[84].flags & D_SELECTED ? mDOOR_RIGHT:0;
		g |= scrdata_dlg[98].flags & D_SELECTED ? mDOOR_UP:0;
		Map.CurrScr()->noreset = g;
		
		g=0;
		g |= scrdata_dlg[85].flags & D_SELECTED ? mSECRET:0;
		g |= scrdata_dlg[86].flags & D_SELECTED ? mITEM:0;
		g |= scrdata_dlg[87].flags & D_SELECTED ? mSPECIALITEM:0;
		g |= scrdata_dlg[88].flags & D_SELECTED ? mLOCKBLOCK:0;
		g |= scrdata_dlg[89].flags & D_SELECTED ? mBOSSLOCKBLOCK:0;
		g |= scrdata_dlg[90].flags & D_SELECTED ? mCHEST:0;
		g |= scrdata_dlg[91].flags & D_SELECTED ? mLOCKEDCHEST:0;
		g |= scrdata_dlg[92].flags & D_SELECTED ? mBOSSCHEST:0;
		Map.CurrScr()->nocarry = g;
		
		Map.CurrScr()->screen_midi = (scrdata_dlg[94].d1>1)?(scrdata_dlg[94].d1-1):(-(scrdata_dlg[94].d1+1));
		Map.CurrScr()->lens_layer = scrdata_dlg[134].d1==0?0:(scrdata_dlg[134].d1>=7?(llLENSSHOWS|(scrdata_dlg[134].d1-7)):(llLENSHIDES|(scrdata_dlg[134].d1-1)));
		Map.CurrScr()->nextmap = scrdata_dlg[34].d1;
		Map.CurrScr()->nextscr = scrdata_dlg[35].d1;
		
		refresh(rMAP+rSCRMAP+rMENU);
		Map.CurrScr()->timedwarptics=atoi(timedstring);
		Map.CurrScr()->csensitive=(atoi(csensstring)<=8?zc_max(1,atoi(csensstring)):Map.CurrScr()->csensitive);
		Map.CurrScr()->oceansfx=scrdata_dlg[100].d1;
		Map.CurrScr()->bosssfx=scrdata_dlg[102].d1;
		Map.CurrScr()->secretsfx=scrdata_dlg[104].d1;
		Map.CurrScr()->holdupsfx=scrdata_dlg[106].d1;
		
		h=0;
		
		for(int32_t i=7; i>=0; i--)
		{
			h<<=1;
			h |= scrdata_dlg[107+i].flags & D_SELECTED ? 1:0;
		}
		
		Map.CurrScr()->enemyflags=h;
		
		saved=false;
	}
	
	return D_O_K;
}

const char *nslist(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        bound(index,0,MAXSCREENS);
        sprintf(ns_string, " %02X", index);
        return ns_string;
    }
    
    *list_size=MAXSCREENS;
    return NULL;
}

const char *roomslist(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        if(index>=MAXROOMTYPES)
            index=MAXROOMTYPES-1;
            
        return roomtype_string[index];
    }
    
    *list_size=MAXROOMTYPES;
    return NULL;
}

static char number_str_buf[MIDI_TRACK_BUFFER_SIZE];
int32_t number_list_size=1;
bool number_list_zero=false;

const char *numberlist(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        bound(index,0,number_list_size-1);
        sprintf(number_str_buf,"%d",index+(number_list_zero?0:1));
        return number_str_buf;
    }
    
    *list_size=number_list_size;
    return NULL;
}

static char dmap_str_buf[37];
int32_t dmap_list_size=MAXDMAPS;
bool dmap_list_zero=true;

const char *dmaplist(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        bound(index,0,dmap_list_size-1);
        sprintf(dmap_str_buf,"%3d-%s",index+(dmap_list_zero?0:1), DMaps[index].name);
        return dmap_str_buf;
    }
    
    *list_size=dmap_list_size;
    return NULL;
}

char *hexnumlist(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        bound(index,0,number_list_size-1);
        sprintf(number_str_buf,"%X",index+(number_list_zero?0:1));
        return number_str_buf;
    }
    
    *list_size=number_list_size;
    return NULL;
}

const char *maplist(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        bound(index,0,MAXMAPS2-1);
        sprintf(number_str_buf,"%d",index+1);
        return number_str_buf;
    }
    
    *list_size=MAXMAPS2;
    return NULL;
}

const char *gotomaplist(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        bound(index,0,map_count-1);
        sprintf(number_str_buf,"%d",index+1);
        return number_str_buf;
    }
    
    *list_size = map_count;
    return NULL;
}

const char *nextmaplist(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        bound(index,0,map_count);
        sprintf(number_str_buf,"%3d",index);
        return number_str_buf;
    }
    
    *list_size = map_count+1;
    return NULL;
}

const char *midilist(int32_t index, int32_t *list_size)
{
    if(index>=0)
    
    {
        bound(index,0,MAXCUSTOMMIDIS_ZQ-1);
        return midi_string[index];
    }
    
    *list_size=MAXCUSTOMMIDIS_ZQ;
    return NULL;
}

const char *screenmidilist(int32_t index, int32_t *list_size)
{
    if(index>=0)
    
    {
        bound(index,0,MAXCUSTOMMIDIS_ZQ);
        return screen_midi_string[index];
    }
    
    *list_size=MAXCUSTOMMIDIS_ZQ+1;
    return NULL;
}

const char *custommidilist(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        bound(index,0,MAXCUSTOMMIDIS_ZQ-1);
        sprintf(number_str_buf,"%3d - %s",index+(number_list_zero?0:1),customtunes[index].data?customtunes[index].title:"(Empty)");
        return number_str_buf;
    }
    
    *list_size=number_list_size;
    return NULL;
}

const char *enhancedmusiclist(int32_t index, int32_t *list_size)
{
    index=index; //this is here to prevent unused parameter warnings
    list_size=list_size; //this is here to prevent unused parameter warnings
    /*if(index>=0)
    {
      bound(index,0,MAXMUSIC-1);
      sprintf(number_str_buf,"%3d - %s",index+(number_list_zero?0:1),enhancedMusic[index].filename[0]?enhancedMusic[index].title:"(Empty)" );
      return number_str_buf;
    }
    *list_size=number_list_size;*/
    return NULL;
}


const char *levelnumlist(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        bound(index,0,0xFFF);
        sprintf(number_str_buf,"%.3X - %s",index,palnames[index]);
        return number_str_buf;
    }
    
    *list_size=MAXLEVELS;
    return NULL;
}

static char shop_str_buf[40];
int32_t shop_list_size=1;

const char *shoplist(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        bound(index,0,shop_list_size-1);
        sprintf(shop_str_buf,"%3d:  %s",index,misc.shop[index].name);
        return shop_str_buf;
    }
    
    *list_size=shop_list_size;
    return NULL;
}

static char bottle_str_buf[40];
int32_t bottle_list_size=1;

const char *bottlelist(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        bound(index,0,bottle_list_size-1);
		sprintf(bottle_str_buf,"%2d:  %s",index+1,misc.bottle_types[index].name);
        return bottle_str_buf;
    }
    
    *list_size=bottle_list_size;
    return NULL;
}

static char bottleshop_str_buf[40];
int32_t bottleshop_list_size=1;

const char *bottleshoplist(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        bound(index,0,bottleshop_list_size-1);
		sprintf(bottleshop_str_buf,"%3d:  %s",index,misc.bottle_shop_types[index].name);
        return bottleshop_str_buf;
    }
    
    *list_size=bottleshop_list_size;
    return NULL;
}

static char info_str_buf[40];
int32_t info_list_size=1;

const char *infolist(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        bound(index,0,info_list_size-1);
        sprintf(info_str_buf,"%3d:  %s",index,misc.info[index].name);
        return info_str_buf;
    }
    
    *list_size=info_list_size;
    return NULL;
}

bool mapcount_will_affect_layers(word newmapcount)
{
	for(int32_t i=0; i<(newmapcount)*MAPSCRS; i++)
	{
		mapscr *layerchecker=&TheMaps[i];
		
		for(int32_t j=0; j<6; j++)
		{
			if(layerchecker->layermap[j]>(newmapcount))
			{
				return true;
			}
		}
	}
	return false;
}

void update_map_count(word newmapcount)
{
	if(map_count == newmapcount) return;
	saved = false;
	setMapCount2(newmapcount);
	//Prevent the nine 'last mapscreen' buttons from pointing to invlid locations
	//if the user reduces the mapcount. -Z ( 23rd September, 2019 )
	for ( int32_t q = 0; q < 9; q++ )
	{
		map_page[q].map = ( map_page[q].map > newmapcount-1 ) ? newmapcount-1 : map_page[q].map;
	}
	for(int32_t i=0; i<(newmapcount)*MAPSCRS; i++)
	{
		fix_layers(&TheMaps[i], false);
	}

    refresh(rMAP+rSCRMAP+rMENU);
}

int32_t onGotoMap()
{
    int32_t ret = select_data("Goto Map",Map.getCurrMap(),gotomaplist,lfont);
    
    if(ret >= 0)
    {
        int32_t m=Map.getCurrMap();
        Map.setCurrMap(ret);
        
        if(m!=Map.getCurrMap())
        {
            memset(relational_tile_grid,(draw_mode==dm_relational?1:0),(11+(rtgyo*2))*(16+(rtgxo*2)));
        }
    }
    
    refresh(rALL);
    return D_O_K;
}

int32_t onFlags()
{
    restore_mouse();
    int32_t ret=select_cflag("Select Combo Flag",Flag);
    position_mouse_z(0);
    
    if(ret>=0)
    {
        Flag=ret;
        setFlagColor();
        refresh(rMENU);
        doflags();
    }
    
    return D_O_K;
}

static DIALOG usedcombo_list_dlg[] =
{
    // (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp)
    { jwin_win_proc,     60-12,   40,   200+24,  148,  vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "Combos Used", NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { jwin_textbox_proc,       72-12,   60+4,   176+24+1,  92+4,   jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,       D_EXIT,     0,             0,      NULL, NULL, NULL },
    { jwin_button_proc,     130,   163,  61,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "OK", NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};



int32_t onUsedCombos()
{
    restore_mouse();
    usedcombo_list_dlg[0].dp2=lfont;
    
    int32_t usedcombos[7][300][2];
    char combolist_text[65536];
    char temptext[80];
    
    int32_t drawmap=Map.getCurrMap();
    int32_t drawscr=Map.getCurrScr();
    int32_t counter[7];
    
    for(int32_t layer=0; layer<7; ++layer)
    {
        counter[layer]=0;
        
        if(layer==0)
        {
            drawmap=Map.getCurrMap();
            drawscr=Map.getCurrScr();
        }
        else
        {
            if(Map.AbsoluteScr(Map.getCurrMap(), Map.getCurrScr())->layermap[layer-1]>0)
            {
                drawmap=Map.AbsoluteScr(Map.getCurrMap(), Map.getCurrScr())->layermap[layer-1]-1;
                drawscr=Map.AbsoluteScr(Map.getCurrMap(), Map.getCurrScr())->layerscreen[layer-1];
            }
            else
            {
                continue;
            }
        }
        
        usedcombos[layer][0][0]=Map.AbsoluteScr(drawmap, drawscr)->data[0];
        usedcombos[layer][0][1]=1;
        counter[layer]=1;
        
        for(int32_t i=1; i<176; ++i)
        {
            bool used=false;
            
            for(int32_t j=0; j<counter[layer]; ++j)
            {
                if(usedcombos[layer][j][0]==Map.AbsoluteScr(drawmap, drawscr)->data[i])
                {
                    ++usedcombos[layer][j][1];
                    used=true;
                    break;
                }
            }
            
            if(!used)
            {
                usedcombos[layer][counter[layer]][0]=Map.AbsoluteScr(drawmap, drawscr)->data[i];
                usedcombos[layer][counter[layer]][1]=1;
                ++counter[layer];
            }
        }
        
        for(int32_t i=0; i<counter[layer]-1; i++)
        {
            for(int32_t j=i+1; j<counter[layer]; j++)
            {
                if(usedcombos[layer][i][0]>usedcombos[layer][j][0])
                {
                    zc_swap(usedcombos[layer][i][0],usedcombos[layer][j][0]);
                    zc_swap(usedcombos[layer][i][1],usedcombos[layer][j][1]);
                }
            }
        }
    }
    
    sprintf(combolist_text, " ");
    
    for(int32_t layer=0; layer<7; ++layer)
    {
        if(counter[layer]>0)
        {
            if(layer>0)
            {
                strcat(combolist_text, "\n");
            }
            
            sprintf(temptext, "Combos on layer %d\n-----------------\n", layer);
            strcat(combolist_text, temptext);
            
            for(int32_t i=0; i<counter[layer]; i++)
            {
                if((i<counter[layer]-1) && (((usedcombos[layer][i][1]==usedcombos[layer][i+1][1]&&(usedcombos[layer][i][0]+1==usedcombos[layer][i+1][0])) && ((i==0) || ((usedcombos[layer][i][1]!=usedcombos[layer][i-1][1])||((usedcombos[layer][i][0]-1!=usedcombos[layer][i-1][0])))))))
                {
                    sprintf(temptext, "%5d ", usedcombos[layer][i][0]);
                    strcat(combolist_text, temptext);
                }
                else if(((i>0) && (((usedcombos[layer][i][1]==usedcombos[layer][i-1][1])&&((usedcombos[layer][i][0]-1==usedcombos[layer][i-1][0]))) && ((i==counter[layer]-1) || ((usedcombos[layer][i][1]!=usedcombos[layer][i+1][1])||((usedcombos[layer][i][0]+1!=usedcombos[layer][i+1][0])))))))
                {
                    sprintf(temptext, "- %5d (%3d)\n", usedcombos[layer][i][0],usedcombos[layer][i][1]);
                    strcat(combolist_text, temptext);
                }
                else if(((i==0) && ((usedcombos[layer][i][1]!=usedcombos[layer][i+1][1])||((usedcombos[layer][i][0]+1!=usedcombos[layer][i+1][0]))))||
                        ((i==counter[layer]-1) && ((usedcombos[layer][i][1]!=usedcombos[layer][i-1][1])||((usedcombos[layer][i][0]-1!=usedcombos[layer][i-1][0]))))||
                        ((i>0) && (i<counter[layer]-1) && ((usedcombos[layer][i][1]!=usedcombos[layer][i+1][1])||((usedcombos[layer][i][0]+1!=usedcombos[layer][i+1][0]))) && ((usedcombos[layer][i][1]!=usedcombos[layer][i-1][1])||((usedcombos[layer][i][0]-1!=usedcombos[layer][i-1][0])))))
                {
                    sprintf(temptext, "    %5d     (%3d)\n", usedcombos[layer][i][0],usedcombos[layer][i][1]);
                    strcat(combolist_text, temptext);
                }
            }
        }
    }
    
    strcat(combolist_text, "\n");
    usedcombo_list_dlg[2].dp=combolist_text;
    usedcombo_list_dlg[2].d2=0;
    
    if(is_large)
        large_dialog(usedcombo_list_dlg);
        
    zc_popup_dialog(usedcombo_list_dlg,2);
    position_mouse_z(0);
    return D_O_K;
}

int32_t onItem()
{
    restore_mouse();
    build_bii_list(true);
    int32_t exit_status;
    int32_t current_item=Map.CurrScr()->hasitem != 0 ? Map.CurrScr()->item : -2;
    
    do
    {
        int32_t ret=select_item("Select Item",current_item,false,exit_status);
        
        if(exit_status == 5)
        {
            if(ret>=0)  // Edit
            {
                current_item=ret;
                build_biw_list();
                edit_itemdata(ret);
            }
            else exit_status = -1;
        }
        else  if(exit_status==2 || exit_status==3)   // Double-click or OK
        {
            if(ret>=0)
            {
                saved=false;
                Map.CurrScr()->item=ret;
                Map.CurrScr()->hasitem = true;
            }
            else
            {
                saved=false;
                Map.CurrScr()->hasitem=false;
            }
        }
    }
    while(exit_status == 5);

    refresh(rMAP+rMENU);
    return D_O_K;
}

int32_t onRoom()
{
	restore_mouse();
	auto* scr = Map.CurrScr();
	RoomDialog(scr->room, scr->catchall, scr->guy, scr->str,
		[scr](int32_t r, int32_t a, int32_t g, int32_t m)
		{
			scr->room = r;
			scr->guy = g;
			scr->str = m;
			scr->catchall = a;
			saved = false;
		}
	).show();
	refresh(rMAP+rMENU);
	return D_O_K;
}

int32_t onEndString()
{
    int32_t ret=select_data("Select Ending String",misc.endstring,msgslist,lfont);
    
    if(ret>=0)
    {
        saved=false;
        misc.endstring=msglistcache[ret];
    }

    refresh(rMENU);
    return D_O_K;
}

static ListData levelnum_list(levelnumlist, &font);

static DIALOG screen_pal_dlg[] =
{
    // (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp)
    { jwin_win_proc,      60-12,   40,   200-16,  96,  vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "Select Palette", NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { jwin_droplist_proc, 72-12,   84+4,   161,  16,   jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,       0,     0,             0, (void *) &levelnum_list, NULL, NULL },
    { jwin_button_proc,   70,   111,  61,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "OK", NULL, NULL },
    { jwin_button_proc,   150,  111,  61,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { jwin_text_proc,       72-12,   60+4,  168,  8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Note: This does not affect how the", NULL, NULL },
    { jwin_text_proc,       72-12,   72+4,  168,  8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "room will be displayed in-game!", NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};
//  return list_dlg[2].d1;

int32_t onScreenPalette()
{
	if(key[KEY_ALT]||key[KEY_ALTGR])
		return D_O_K; //'Alt+F4' should not pop this up...
    restore_mouse();
    screen_pal_dlg[0].dp2=lfont;
    screen_pal_dlg[2].d1=Map.getcolor();
    
    if(is_large)
        large_dialog(screen_pal_dlg);
        
    if(zc_popup_dialog(screen_pal_dlg,2)==3)
    {
        saved=false;
        Map.setcolor(screen_pal_dlg[2].d1);
        refresh(rALL);
    }
    
    rebuild_trans_table();
    
    return D_O_K;
}

int32_t onDecScrPal()
{
	if(DisableLPalShortcuts) return D_O_K;
    restore_mouse();
    int32_t c=Map.getcolor();
    c+=511;
    c=c%512;
    Map.setcolor(c);
    refresh(rALL);
	saved = false;
    return D_O_K;
}

int32_t onIncScrPal()
{
	if(DisableLPalShortcuts) return D_O_K;
    restore_mouse();
    int32_t c=Map.getcolor();
    c+=1;
    c=c%512;
    Map.setcolor(c);
    refresh(rALL);
	saved = false;
    return D_O_K;
}

int32_t PalWrap(int32_t kX, int32_t const kLowerBound, int32_t const kUpperBound)
{
    int32_t range_size = kUpperBound - kLowerBound + 1;

    if (kX < kLowerBound)
        kX += range_size * ((kLowerBound - kX) / range_size + 1);

    return kLowerBound + (kX - kLowerBound) % range_size;
}

int32_t onDecScrPal16()
{
	if(DisableLPalShortcuts) return D_O_K;
    restore_mouse(); 
    int32_t c=Map.getcolor();
      
    c = PalWrap( ( c-0x10 ), 0, 511 );
     
    Map.setcolor(c);
    refresh(rALL);
	saved = false;
    return D_O_K;
}

int32_t onIncScrPal16()
{
	if(DisableLPalShortcuts) return D_O_K;
    restore_mouse();
    int32_t c=Map.getcolor();
      	    
    c = PalWrap( ( c+0x10 ), 0, 511 );
    Map.setcolor(c);
    refresh(rALL);
	saved = false;
    return D_O_K;
}

int32_t d_ndroplist_proc(int32_t msg,DIALOG *d,int32_t c)
{
    int32_t ret = jwin_droplist_proc(msg,d,c);
    
    // The only place this proc is used is in the info type editor.
    // If it's ever used anywhere else, this will probably need to be changed.
    // Maybe add a flag for it or something.
    int32_t msgID=msg_at_pos(d->d1);
    
    switch(msg)
    {
    case MSG_DRAW:
    case MSG_CHAR:
    case MSG_CLICK:
        scare_mouse();
        textprintf_ex(screen,font,d->x - 48,d->y + 4,jwin_pal[jcBOXFG],jwin_pal[jcBOX],"%5d",msgID);
        unscare_mouse();
    }
    
    return ret;
}

int32_t d_idroplist_proc(int32_t msg,DIALOG *d,int32_t c)
{
    int32_t ret = jwin_droplist_proc(msg,d,c);
    
    switch(msg)
    {
    case MSG_DRAW:
    case MSG_CHAR:
    case MSG_CLICK:
        scare_mouse();
        int32_t tile = bii[d->d1].i >=0 ? itemsbuf[bii[d->d1].i].tile : 0;
        int32_t cset = bii[d->d1].i >=0 ? itemsbuf[bii[d->d1].i].csets&15 : 0;
        int32_t x = d->x + d->w + 4;
        int32_t y = d->y - 2;
        int32_t w = 16;
        int32_t h = 16;
        
        if(is_large)
        {
            w = 32;
            h = 32;
            y -= 6;
        }
        
        BITMAP *buf = create_bitmap_ex(8,16,16);
        BITMAP *bigbmp = create_bitmap_ex(8,w,h);
        
        if(buf && bigbmp)
        {
            clear_bitmap(buf);
            
            if(tile)
                overtile16(buf, tile,0,0,cset,0);
                
            stretch_blit(buf, bigbmp, 0,0, 16, 16, 0, 0, w, h);
            destroy_bitmap(buf);
            jwin_draw_frame(screen,x,y,w+4,h+4,FR_DEEP);
            blit(bigbmp,screen,0,0,x+2,y+2,w,h);
            destroy_bitmap(bigbmp);
        }
        
        unscare_mouse();
    }
    
    return ret;
}

int32_t d_nidroplist_proc(int32_t msg,DIALOG *d,int32_t c)
{
    int32_t ret = d_idroplist_proc(msg,d,c);
    
    switch(msg)
    {
    case MSG_DRAW:
    case MSG_CHAR:
    case MSG_CLICK:
        scare_mouse();
        textprintf_ex(screen,font,d->x - 48,d->y + 4,jwin_pal[jcBOXFG],jwin_pal[jcBOX],"%5d",bii[d->d1].i);
        unscare_mouse();
    }
    
    return ret;
}

int32_t d_ilist_proc(int32_t msg,DIALOG *d,int32_t c)
{
	if(msg == MSG_XCHAR)
	{
		if(key_shifts & KB_CTRL_FLAG) //CTRL overrides the lister search function
		{
			int32_t ret = D_USED_CHAR;
			switch(c>>8)
			{
				case KEY_V:
					paste_item();
					break;
				case KEY_C:
					copy_item();
					break;
				case KEY_S:
					save_item();
					break;
				case KEY_L:
					load_item();
					break;
				default: ret = 0;
			}
			if(ret) return ret;
		}
	}
	int32_t ret = jwin_abclist_proc(msg,d,c);
	
	switch(msg)
	{
		case MSG_DRAW:
		case MSG_CHAR:
		case MSG_CLICK:
			scare_mouse();
			
			int32_t tile = 0;
			int32_t cset = 0;
			
			if(bii[d->d1].i >-1)
			{
				tile= itemsbuf[bii[d->d1].i].tile;
				cset= itemsbuf[bii[d->d1].i].csets&15;
			}
			
			int32_t x = d->x + d->w + 4;
			int32_t y = d->y;
			int32_t w = 16;
			int32_t h = 16;
			
			if(is_large)
			{
				w = 32;
				h = 32;
			}
			
			BITMAP *buf = create_bitmap_ex(8,16,16);
			BITMAP *bigbmp = create_bitmap_ex(8,w,h);
			
			if(buf && bigbmp)
			{
				clear_bitmap(buf);
				
				if(tile)
					overtile16(buf, tile,0,0,cset,0);
					
				stretch_blit(buf, bigbmp, 0,0, 16, 16, 0, 0, w, h);
				destroy_bitmap(buf);
				jwin_draw_frame(screen,x,y,w+4,h+4,FR_DEEP);
				blit(bigbmp,screen,0,0,x+2,y+2,w,h);
				destroy_bitmap(bigbmp);
			}
			//Item editor power display in Select Item dialogue. 
			if(bii[d->d1].i>=0)
			{
				textprintf_ex(screen,spfont,x,y+20*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"#%d  ",bii[d->d1].i);
				
				textprintf_ex(screen,spfont,x,y+32*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"Pow:    ");
				textprintf_ex(screen,spfont,x,y+38*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"Lev:    ");
				textprintf_ex(screen,spfont,x,y+44*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"Fam:    ");
				// textprintf_ex(screen,spfont,x,y+44*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"Tile:    ");
				textprintf_ex(screen,spfont,x,y+50*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"CSet:    ");
				textprintf_ex(screen,spfont,x,y+56*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"Scripts:    ");
				textprintf_ex(screen,spfont,x,y+62*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"Act:    ");
				textprintf_ex(screen,spfont,x,y+68*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"Pkp:    ");
				textprintf_ex(screen,spfont,x,y+74*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"Spr:    ");
				textprintf_ex(screen,spfont,x,y+80*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"Wpn:    ");
				char itempower[10]; char itemlvl[10]; char itmtile[16]; char itmcset[10]; char itmfam[10];
				char ascript[10];
				char pscript[10];
				char sscript[10];
				char wscript[10];
				sprintf(itempower, "%03d", itemsbuf[bii[d->d1].i].power); //Give leading zeros so that we don't have graphical corruption in the display. 
				sprintf(itemlvl, "%03d", itemsbuf[bii[d->d1].i].fam_type); //Give leading zeros so that we don't have graphical corruption in the display. 
				sprintf(itmtile, "%03d", itemsbuf[bii[d->d1].i].tile); //Give leading zeros so that we don't have graphical corruption in the display. 
				sprintf(itmcset, "%03d", itemsbuf[bii[d->d1].i].csets); //Give leading zeros so that we don't have graphical corruption in the display. 
				sprintf(itmfam, "%03d", itemsbuf[bii[d->d1].i].family); //Give leading zeros so that we don't have graphical corruption in the display. 
				sprintf(ascript, "%03d", itemsbuf[bii[d->d1].i].script); //Give leading zeros so that we don't have graphical corruption in the display. 
				sprintf(pscript, "%03d", itemsbuf[bii[d->d1].i].collect_script); //Give leading zeros so that we don't have graphical corruption in the display. 
				sprintf(sscript, "%03d", itemsbuf[bii[d->d1].i].sprite_script); //Give leading zeros so that we don't have graphical corruption in the display. 
				sprintf(wscript, "%03d", itemsbuf[bii[d->d1].i].weaponscript); //Give leading zeros so that we don't have graphical corruption in the display. 
				//textprintf_ex(screen,spfont,x+int32_t(16*(is_large?1.5:1)),y+26*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"%d",itemsbuf[bii[d->d1].i].power);
				textprintf_ex(screen,spfont,x+int32_t(16*(is_large?1.5:1)),y+32*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"%s",itempower);
				textprintf_ex(screen,spfont,x,y+26*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"T: %d  ",itemsbuf[bii[d->d1].i].tile);
				textprintf_ex(screen,spfont,x+int32_t(16*(is_large?1.5:1)),y+38*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"%s",itemlvl);
				//textprintf_ex(screen,spfont,x,y+32*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"LV: %d  ",itemsbuf[bii[d->d1].i].family_type);
				textprintf_ex(screen,spfont,x+int32_t(16*(is_large?1.5:1)),y+44*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"%s",itmfam);
				//textprintf_ex(screen,spfont,x,y+38*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"F: %d  ",itemsbuf[bii[d->d1].i].family);
				
				//textprintf_ex(screen,spfont,x+int32_t(16*(is_large?1.5:1)),y+44*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"%s",itmtile);
				textprintf_ex(screen,spfont,x+int32_t(16*(is_large?1.5:1)),y+50*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"%s",itmcset);
				//Scripts
				textprintf_ex(screen,spfont,x+int32_t(16*(is_large?1.5:1)),y+32*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"%s",itempower);
				textprintf_ex(screen,spfont,x+int32_t(16*(is_large?1.5:1)),y+62*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"%s",ascript);
				textprintf_ex(screen,spfont,x+int32_t(16*(is_large?1.5:1)),y+68*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"%s",pscript);
				textprintf_ex(screen,spfont,x+int32_t(16*(is_large?1.5:1)),y+74*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"%s",sscript);
				textprintf_ex(screen,spfont,x+int32_t(16*(is_large?1.5:1)),y+80*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"%s",wscript);
			}
			
			// Might be a bit confusing for new users
			/*textprintf_ex(screen,is_large?font:spfont,x,y+32*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"Cost:   ");
			textprintf_ex(screen,is_large?font:spfont,x+int32_t(16*(is_large?1.5:1)),y+32*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"%d",itemsbuf[bii[d->d1].i].magic);*/
			
			unscare_mouse();
	}
	
	return ret;
}

int32_t d_wlist_proc(int32_t msg,DIALOG *d,int32_t c)
{
	if(msg == MSG_XCHAR)
	{
		if(key_shifts & KB_CTRL_FLAG) //CTRL overrides the lister search function
		{
			int32_t ret = D_USED_CHAR;
			switch(c>>8)
			{
				case KEY_V:
					paste_wsprite();
					break;
				case KEY_C:
					copy_wsprite();
					break;
				case KEY_S:
					save_wsprite();
					break;
				case KEY_L:
					load_wsprite();
					break;
				default: ret = 0;
			}
			if(ret) return ret;
		}
	}
	int32_t ret = jwin_abclist_proc(msg,d,c);
	
	switch(msg)
	{
	case MSG_DRAW:
	case MSG_CHAR:
	case MSG_CLICK:
		scare_mouse();
		
		int32_t tile = 0;
		int32_t cset = 0;
		tile= wpnsbuf[biw[d->d1].i].tile;
		cset= wpnsbuf[biw[d->d1].i].csets&15;
		int32_t x = d->x + d->w + 4;
		int32_t y = d->y;
		int32_t w = 16;
		int32_t h = 16;
		float temp_scale = 1;
		
		if(is_large)
		{
			w = 32;
			h = 32;
		temp_scale = 2; // Scale up by 1.5
		}
		
		BITMAP *buf = create_bitmap_ex(8,16,16);
		BITMAP *bigbmp = create_bitmap_ex(8,w,h);
		
		if(buf && bigbmp)
		{
			clear_bitmap(buf);
			
			if(tile)
				overtile16(buf, tile,0,0,cset,0);
				
			stretch_blit(buf, bigbmp, 0,0, 16, 16, 0, 0, w, h);
			destroy_bitmap(buf);
			jwin_draw_frame(screen,x,y,w+4,h+4,FR_DEEP);
			blit(bigbmp,screen,0,0,x+2,y+2,w,h);
			destroy_bitmap(bigbmp);
		}
	
	//Display the sprite ID. 
	if (biw[d->d1].i >= 0)
	{
		textprintf_ex(screen, is_large ? font : spfont, x, y + (20 * temp_scale), jwin_pal[jcTEXTFG], jwin_pal[jcBOX], "#%d   ", biw[d->d1].i);
	}
		
		unscare_mouse();
	}
	
	return ret;
}


/**********************************/
//        Triforce Pieces         //
/**********************************/

static byte triframe_points[9*4] =
{
    0,2,2,0,  2,0,4,2,  0,2,4,2,  1,1,3,1,  2,0,2,2,
    1,1,1,2,  1,1,2,2,  3,1,3,2,  3,1,2,2
};

int32_t d_tri_frame_proc(int32_t msg,DIALOG *d,int32_t c)
{
    //these are here to bypass compiler warnings about unused arguments
    c=c;
    
    if(msg==MSG_DRAW)
    {
        int32_t x[5],y[3];
        
        x[0]=d->x;
        x[1]=d->x+(d->w>>2);
        x[2]=d->x+(d->w>>1);
        x[3]=d->x+(d->w>>1)+(d->w>>2);
        x[4]=d->x+d->w;
        y[0]=d->y;
        y[1]=d->y+(d->h>>1);
        y[2]=d->y+d->h;
        
        byte *p = triframe_points;
        
        for(int32_t i=0; i<9; i++)
        {
            line(screen,x[*p],y[*(p+1)],x[*(p+2)],y[*(p+3)],d->fg);
            p+=4;
        }
    }
    
    return D_O_K;
}

int32_t d_tri_edit_proc(int32_t msg,DIALOG *d,int32_t c)
{
    jwin_button_proc(msg,d,c);
    
    if(msg==MSG_CLICK)
    {
        int32_t v = getnumber("Piece Number",d->d1);
        scare_mouse();
        
        if(v>=0)
        {
            bound(v,1,8);
            
            if(v!=d->d1)
            {
                DIALOG *tp = d - d->d2;
                
                for(int32_t i=0; i<8; i++)
                {
                    if(tp->d1==v)
                    {
                        tp->d1 = d->d1;
                        ((char*)(tp->dp))[0] = d->d1+'0';
                        jwin_button_proc(MSG_DRAW,tp,0);
                    }
                    
                    ++tp;
                }
                
                d->d1 = v;
                ((char*)(d->dp))[0] = v+'0';
            }
        }
        
        d->flags = 0;
        jwin_button_proc(MSG_DRAW,d,0);
        unscare_mouse();
    }
    
    return D_O_K;
}

static DIALOG tp_dlg[] =
{
    /* (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp) */
    { jwin_win_proc,     56,   32,   208,  160,  vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "Triforce Pieces", NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { d_tri_frame_proc,  64,   56,   192,    96,   jwin_pal[jcBOXFG],  jwin_pal[jcBOX],  0,       0,          0,             0,       NULL, NULL, NULL },
    // 3
    { d_tri_edit_proc,   138,  82,   17,   17,   vc(14),  vc(1),  0,       0,          0,             0, (void *) "1", NULL, NULL },
    { d_tri_edit_proc,   166,  82,   17,   17,   vc(14),  vc(1),  0,       0,          0,             1, (void *) "2", NULL, NULL },
    { d_tri_edit_proc,   90,   130,  17,   17,   vc(14),  vc(1),  0,       0,          0,             2, (void *) "3", NULL, NULL },
    { d_tri_edit_proc,   214,  130,  17,   17,   vc(14),  vc(1),  0,       0,          0,             3, (void *) "4", NULL, NULL },
    // 7
    { d_tri_edit_proc,   138,  110,  17,   17,   vc(14),  vc(1),  0,       0,          0,             4, (void *) "5", NULL, NULL },
    { d_tri_edit_proc,   118,  130,  17,   17,   vc(14),  vc(1),  0,       0,          0,             5, (void *) "6", NULL, NULL },
    { d_tri_edit_proc,   166,  110,  17,   17,   vc(14),  vc(1),  0,       0,          0,             6, (void *) "7", NULL, NULL },
    { d_tri_edit_proc,   186,  130,  17,   17,   vc(14),  vc(1),  0,       0,          0,             7, (void *) "8", NULL, NULL },
    // 11
    { jwin_button_proc,     90,   166,  61,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "OK", NULL, NULL },
    { jwin_button_proc,     170,  166,  61,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

int32_t onTriPieces()
{
    tp_dlg[0].dp2=lfont;
    char temptext[8][2];
    
    for(int32_t i=0; i<8; i++)
    {
        tp_dlg[i+3].d1 = misc.triforce[i];
        //    ((char*)(tp_dlg[i+3].dp))[0] = misc.triforce[i]+'0';
        sprintf(temptext[i], "%d", misc.triforce[i]);
        tp_dlg[i+3].dp=temptext[i];
    }
    
    if(is_large)
        large_dialog(tp_dlg);
        
    if(zc_popup_dialog(tp_dlg,-1) == 11)
    {
        saved=false;
        
        for(int32_t i=0; i<8; i++)
            misc.triforce[i] = tp_dlg[i+3].d1;
    }
    
    return D_O_K;
}


/**********************************/
/***********  onDMaps  ************/
/**********************************/

int32_t d_maptile_proc(int32_t msg,DIALOG *d,int32_t c);
bool small_dmap=false;

static DIALOG dmapmaps_dlg[] =
{

    /* (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp) */
    { jwin_win_proc, 4,    18,   313,  217,  vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "Custom DMap Map Styles", NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { jwin_button_proc,     93,   208,  61,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "OK", NULL, NULL },
    { jwin_button_proc,     168,  208,  61,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { d_ctext2_proc,      160,  38,    0,   8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "Minimaps", NULL, NULL },
    { d_ctext2_proc,      112,  46,     0,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "Without Map", NULL, NULL },
    { d_ctext2_proc,      208,  46,     0,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "With Map", NULL, NULL },
    
    { d_ctext2_proc,      162,  110,    0,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "Large Maps", NULL, NULL },
    { d_ctext2_proc,      80,   118,    0,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "Without Map", NULL, NULL },
    { d_ctext2_proc,      240,  118,    0,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "With Map", NULL, NULL },
    // 5
    { d_maptile_proc,    72,   54,   80,   48,   0,       0,      0,       0,          0,             0,       NULL, NULL, NULL },
    { d_maptile_proc,    168,  54,   80,   48,   0,       0,      0,       0,          0,             0,       NULL, NULL, NULL },
    { d_maptile_proc,    8,    126,  144,  80,   0,       0,      0,       0,          0,             0,       NULL, NULL, NULL },
    { d_maptile_proc,    168,  126,  144,  80,   0,       0,      0,       0,          0,             0,       NULL, NULL, NULL },
    // 11
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

int32_t d_hexedit_proc(int32_t msg,DIALOG *d,int32_t c)
{
    return jwin_hexedit_proc(msg,d,c);
}

void drawgrid(BITMAP *dest,int32_t x,int32_t y,int32_t grid,int32_t fg,int32_t bg,int32_t div)
{
    if(div!=-1)
        rectfill(dest,x-1,y-1,x+63,y+3,div);
        
    for(int32_t dx=0; dx<64; dx+=8)
    {
        if(grid&0x80)
            rectfill(dest,x+dx,y,x+dx+6,y+2,fg);
        else if(bg!=-1)
            rectfill(dest,x+dx,y,x+dx+6,y+2,bg);
            
        grid<<=1;
    }
}

void drawovergrid(BITMAP *dest,int32_t x,int32_t y,int32_t grid,int32_t color,int32_t div)
{
    if(div!=-1)
        rectfill(dest,x-1,y-1,x+63,y+3,div);
        
    for(int32_t dx=0; dx<64; dx+=4)
    {
        rectfill(dest,x+dx,y,x+dx+2,y+2,color);
        grid<<=1;
    }
}

void drawgrid(BITMAP *dest,int32_t x,int32_t y,int32_t w, int32_t h, int32_t tw, int32_t th, int32_t *grid,int32_t fg,int32_t bg,int32_t div)
{
    //these are here to bypass compiler warnings about unused arguments
    w=w;
    tw=tw;
    th=th;
    
    rectfill(dest,x,y,x+(8*8),y+(1*4),div);
    
    for(int32_t dy=0; dy<h; dy++)
    {
        for(int32_t dx=0; dx<64; dx+=8)
        {
            if(grid[0]&0x80)
                rectfill(dest,x+dx,y,x+dx+6,y+2,fg);
            else
                rectfill(dest,x+dx,y,x+dx+6,y+2,bg);
                
            grid[0]<<=1;
        }
    }
}

void drawgrid_s(BITMAP *dest,int32_t x,int32_t y,int32_t grid,int32_t fg,int32_t bg,int32_t div)
{
    rectfill(dest,x-1,y-1,x+63,y+3,div);
    
    for(int32_t dx=0; dx<64; dx+=8)
    {
        rectfill(dest,x+dx,y,x+dx+6,y+2,bg);
        
        if(grid&0x80)
            rectfill(dest,x+dx+2,y,x+dx+4,y+2,fg);
            
        grid<<=1;
    }
}

void drawdmap(int32_t dmap)
{
    int32_t c;
    zcolors mc=misc.colors;
    
    switch((DMaps[dmap].type&dmfTYPE))
    {
    case dmDNGN:
    case dmCAVE:
        clear_bitmap(dmapbmp_small);
        
        if(DMaps[dmap].minimap_2_tile)
            ;
        // overworld_map_tile overrides the NES minimap. dungeon_map_tile does not.
        else for(int32_t y=1; y<33; y+=4)
                drawgrid(dmapbmp_small,0,y,DMaps[dmap].grid[y>>2], DMaps[dmap].flags&dmfMINIMAPCOLORFIX ? mc.cave_fg : mc.dngn_fg, -1, -1);
                
        c=DMaps[dmap].compass;
        //  rectfill(dmapbmp,(c&15)*8+3,(c>>4)*4+1,(c&15)*8+5,(c>>4)*4+3,dvc(2*4));
        rectfill(dmapbmp_small,(c&15)*8+3,(c>>4)*4+1,(c&15)*8+5,(c>>4)*4+3,vc(4));
        c=DMaps[dmap].cont;
        rectfill(dmapbmp_small,(c&15)*8+3,(c>>4)*4+1,(c&15)*8+5,(c>>4)*4+3,vc(10));
        break;
        
    case dmOVERW:
        clear_bitmap(dmapbmp_small);
        
        if(DMaps[dmap].minimap_2_tile)
            ;
        else if(!mc.overworld_map_tile)
            for(int32_t y=1; y<33; y+=4)
                drawovergrid(dmapbmp_small,1,y,DMaps[dmap].grid[y>>2],mc.overw_bg,vc(0));
                
        c=DMaps[dmap].cont;
        rectfill(dmapbmp_small,(c&15)*4+1,(c>>4)*4+1,(c&15)*4+3,(c>>4)*4+3,vc(10));
        break;
        
    case dmBSOVERW:
        clear_bitmap(dmapbmp_small);
        
        if(DMaps[dmap].minimap_2_tile)
            ;
        else if(!mc.overworld_map_tile)
            for(int32_t y=1; y<33; y+=4)
                //    drawgrid_s(dmapbmp,1,y,DMaps[dmap].grid[y>>2],dvc(2*4),dvc(2*3),dvc(3+4));
                drawgrid_s(dmapbmp_small,0,y,DMaps[dmap].grid[y>>2],mc.bs_goal,mc.bs_dk,vc(14));
                
        c=DMaps[dmap].cont;
        rectfill(dmapbmp_small,(c&15)*8+3,(c>>4)*4+1,(c&15)*8+5,(c>>4)*4+3,vc(10));
        break;
    }
}

void drawdmap_screen(int32_t x, int32_t y, int32_t w, int32_t h, int32_t dmap)
{
    BITMAP *tempbmp = create_bitmap_ex(8,w,h);
    clear_to_color(tempbmp, vc(0));
    zcolors mc=misc.colors;
    
//  rectfill(tempbmp,x,y,x+w-1,y+h-1,vc(0));

    if(DMaps[dmap].minimap_2_tile)
    {
        draw_block(tempbmp,0,0,DMaps[dmap].minimap_2_tile,DMaps[dmap].minimap_2_cset,5,3);
    }
    else if(((DMaps[dmap].type&dmfTYPE)==dmDNGN || (DMaps[dmap].type&dmfTYPE)==dmCAVE) && mc.dungeon_map_tile)
    {
        draw_block(tempbmp,0,0,mc.dungeon_map_tile,mc.dungeon_map_cset,5,3);
    }
    else if(((DMaps[dmap].type&dmfTYPE)==dmOVERW || (DMaps[dmap].type&dmfTYPE)==dmBSOVERW) && mc.overworld_map_tile)
    {
        draw_block(tempbmp,0,0,mc.overworld_map_tile,mc.overworld_map_cset,5,3);
    }
    
    masked_blit(dmapbmp_small,tempbmp,0,0,8,7,65,33);
    
    blit(tempbmp,screen,0,0,x,y,w,h);
    destroy_bitmap(tempbmp);
    
}

int32_t d_dmaplist_proc(int32_t msg,DIALOG *d,int32_t c)
{
    if(msg==MSG_DRAW)
    {
        int32_t dmap = d->d1;
        int32_t xy[6] = {44,92,128,100,128,110};
        //int32_t *xy = (int32_t*)(d->dp3);
        float temp_scale = 1;
        
        if(is_large)
        {
            temp_scale = 1.5; // Scale up by 1.5
        }
        
        drawdmap(dmap);
        
        if(xy[0]>-1000&&xy[1]>-1000)
        {
            int32_t x = d->x+int32_t((xy[0]-2)*temp_scale);
            int32_t y = d->y+int32_t((xy[1]-2)*temp_scale);
//      int32_t w = is_large ? 84 : 71;
//      int32_t h = is_large ? 52 : 39;
            int32_t w = 84;
            int32_t h = 52;
            jwin_draw_frame(screen,x,y,w,h,FR_DEEP);
            drawdmap_screen(x+2,y+2,w-4,h-4,dmap);
        }
        
        if(xy[2]>-1000&&xy[3]>-1000)
        {
            textprintf_ex(screen,is_large ? lfont_l : font,d->x+int32_t((xy[2])*temp_scale),d->y+int32_t((xy[3])*temp_scale),jwin_pal[jcBOXFG],jwin_pal[jcBOX],"Map: %-3d",DMaps[d->d1].map+1);
        }
        
        if(xy[4]>-1000&&xy[5]>-1000)
        {
            textprintf_ex(screen,is_large ? lfont_l : font,d->x+int32_t((xy[4])*temp_scale),d->y+int32_t((xy[5])*temp_scale),jwin_pal[jcBOXFG],jwin_pal[jcBOX],"Level: %-3d",DMaps[d->d1].level);
        }
    }
    
    return jwin_list_proc(msg,d,c);
}

int32_t d_dropdmaplist_proc(int32_t msg,DIALOG *d,int32_t c)
{
    if(msg==MSG_DRAW)
    {
        int32_t dmap = d->d1;
        int32_t *xy = (int32_t*)(d->dp3);
        float temp_scale = 1;
        
        if(is_large)
        {
            temp_scale = 1.5; // Scale up by 1.5
        }
        
        drawdmap(dmap);
        
        if(xy[0]>-1000&&xy[1]>-1000)
        {
            int32_t x = d->x+int32_t((xy[0]-2)*temp_scale);
            int32_t y = d->y+int32_t((xy[1]-2)*temp_scale);
//      int32_t w = is_large ? 84 : 71;
//      int32_t h = is_large ? 52 : 39;
            int32_t w = 84;
            int32_t h = 52;
            jwin_draw_frame(screen,x,y,w,h,FR_DEEP);
            drawdmap_screen(x+2,y+2,w-4,h-4,dmap);
        }
        
        if(xy[2]>-1000&&xy[3]>-1000)
        {
            textprintf_ex(screen,is_large ? lfont_l : font,d->x+int32_t((xy[2])*temp_scale),d->y+int32_t((xy[3])*temp_scale),jwin_pal[jcBOXFG],jwin_pal[jcBOX],"Map: %-3d",DMaps[d->d1].map+1);
        }
        
        if(xy[4]>-1000&&xy[5]>-1000)
        {
            textprintf_ex(screen,is_large ? lfont_l : font,d->x+int32_t((xy[4])*temp_scale),d->y+int32_t((xy[5])*temp_scale),jwin_pal[jcBOXFG],jwin_pal[jcBOX],"Level: %-3d",DMaps[d->d1].level);
        }
    }
    
    return jwin_droplist_proc(msg,d,c);
}

int32_t d_dropdmaptypelist_proc(int32_t msg,DIALOG *d,int32_t c)
{
    int32_t d1 = d->d1;
    int32_t ret = jwin_droplist_proc(msg,d,c);
    
    if(msg==MSG_DRAW || d->d1!=d1)
    {
        scare_mouse();
        small_dmap=(d->d1!=dmOVERW);
        object_message(d-3, MSG_DRAW, 0);
        (d-2)->flags&=~D_DISABLED;
        (d-2)->flags|=small_dmap?0:D_DISABLED;
        object_message(d-2, MSG_DRAW, 0);
        (d+35)->d1=small_dmap;
        object_message(d+35, MSG_DRAW, 0);
        unscare_mouse();
    }
    
    return ret;
}

int32_t d_grid_proc(int32_t msg,DIALOG *d,int32_t)
{
    int32_t frame_thickness=int32_t(2*(is_large?1.5:1));
    int32_t button_thickness=2;
    int32_t header_width=int32_t(4*(is_large?1.5:1));
    int32_t header_height=int32_t(6*(is_large?1.5:1));
    int32_t cols=d->d1?8:16;
int32_t col_width=(is_large ? d->d1 ? 22:11:(d->d1?14:7));
    int32_t l=(is_large?10:7);
    
    switch(msg)
    {
    case MSG_DRAW:
    {
        BITMAP *tempbmp = create_bitmap_ex(8,screen->w,screen->h);
        clear_bitmap(tempbmp);
        int32_t x=d->x;
        int32_t y=d->y;
        int32_t j=0, k=0;
        rectfill(tempbmp,x,y,x+d->w-1,y+header_height-1,jwin_pal[jcBOX]);
        
        for(j=0; j<8; ++j)
        {
            textprintf_ex(tempbmp,is_large?nfont:spfont,x,y+header_height+frame_thickness+1+(j*l),jwin_pal[jcBOXFG],jwin_pal[jcBOX],"%d",j);
        }
        
        for(j=0; j<cols; ++j)
        {
            textprintf_ex(tempbmp,is_large?nfont:spfont,x+header_width+frame_thickness+((col_width+1)/2)-(header_width/2)+(j*col_width),y,jwin_pal[jcBOXFG],jwin_pal[jcBOX],"%X",j);
        }
        
        jwin_draw_frame(tempbmp, x+header_width+is_large, y+header_height+is_large, (is_large?180:116), (is_large?84:60), FR_DEEP);
        
        for(j=0; j<8; ++j)
        {
            for(k=0; k<cols; ++k)
            {
                jwin_draw_frame(tempbmp, x+header_width+(k*col_width)+frame_thickness, y+header_height+(j*l)+frame_thickness, col_width, l, get_bit((byte *)d->dp,8*j+k)||!d->d1?FR_MEDDARK:FR_BOX);
                rectfill(tempbmp, x+header_width+(k*col_width)+frame_thickness+button_thickness, y+header_height+(j*l)+frame_thickness+button_thickness,
                         x+header_width+(k*col_width)+frame_thickness+col_width-button_thickness-1, y+header_height+(j*l)+frame_thickness+l-button_thickness-1, get_bit((byte *)d->dp,8*j+k)&&d->d1?jwin_pal[jcBOXFG]:jwin_pal[jcBOX]);
            }
        }
        
        masked_blit(tempbmp,screen,0,0,0,0,screen->w,screen->h);
        destroy_bitmap(tempbmp);
    }
    break;
    
    case MSG_LPRESS:
    {
        int32_t xx = -1;
        int32_t yy = -1;
        int32_t set = -1; // Set or unset
        
        while(gui_mouse_b())  // Drag across to select multiple
        {
            int32_t x=(gui_mouse_x()-(d->x)-frame_thickness-header_width)/col_width;
            int32_t y=(gui_mouse_y()-(d->y)-frame_thickness-header_height)/l;
            
            if(xx != x || yy != y)
            {
                xx = x;
                yy = y;
                
                if(y>=0 && y<8 && x>=0 && x<cols)
                {
                    if(key[KEY_ALT]||key[KEY_ALTGR])
                    {
                        sprintf((char*)((d+2)->dp),"%d%X",y,x);
                        object_message((d+2), MSG_DRAW, 0);
                    }
                    
                    if(key[KEY_ZC_LCONTROL]||key[KEY_ZC_RCONTROL])
                    {
                        sprintf((char*)((d+4)->dp),"%d%X",y,x);
                        object_message((d+4), MSG_DRAW, 0);
                    }
                    
                    if(!(key[KEY_ALT]||key[KEY_ALTGR]||key[KEY_ZC_LCONTROL]||key[KEY_ZC_RCONTROL]))
                    {
                        if(set==-1)
                            set = !get_bit((byte *)d->dp,8*y+x);
                            
                        set_bit((byte *)d->dp,8*y+x,set);
                    }
                }
            }
            
            scare_mouse();
            object_message(d, MSG_DRAW, 0);
            unscare_mouse();
            custom_vsync();
        }
    }
    break;
    }
    
    return D_O_K;
}

void drawxmap(int32_t themap,int32_t xoff,bool large)
{
    int32_t cols=(large?8:16);
int32_t col_width=(is_large ? large ? 22:11:(large?14:7));
    int32_t dot_width=int32_t((large?4:3)*(is_large?1.5:1));
    int32_t dot_offset=int32_t((large?5:2)*(is_large?1.5:1));
    int32_t l = is_large?10:7;
    clear_to_color(dmapbmp_large,jwin_pal[jcBOX]);
    
    for(int32_t y=0; y<8; y++)
    {
        for(int32_t x=0; x<cols; x++)
        {
            if(!large||(x+xoff>=0 && x+xoff<=15))
            {
                mapscr *scr = &TheMaps[themap*MAPSCRS + y*16+x+(large?xoff:0)];
                rectfill(dmapbmp_large,x*col_width,y*l,x*col_width+col_width-1,(y*l)+l-1,scr->valid&mVALID ? lc1((scr->color)&15) : 0);
                
                if(scr->valid&mVALID && ((scr->color)&15)>0)
                {
                    rectfill(dmapbmp_large,x*col_width+dot_offset,y*l+2+is_large,x*col_width+dot_offset+dot_width-1,y*l+4+is_large*2,lc2((scr->color)&15));
                }
            }
        }
    }
}

int32_t d_xmaplist_proc(int32_t msg,DIALOG *d,int32_t c)
{
    int32_t d1 = d->d1;
    int32_t ret = jwin_droplist_proc(msg,d,c);
    
    if(msg==MSG_DRAW || d->d1!=d1)
    {
        scare_mouse();
        int32_t *xy = (int32_t*)(d->dp3);
        xy[0]=d->d1;
        drawxmap(xy[0],xy[1],small_dmap);
        
        if(xy[2]||xy[3])
        {
            int32_t frame_thickness=int32_t(2*(is_large?1.5:1));
            int32_t header_width=int32_t(4*(is_large?1.5:1));
            int32_t header_height=int32_t(6*(is_large?1.5:1));
            int32_t cols=small_dmap?8:16;
int32_t col_width=(is_large ? small_dmap ? 22:11:(small_dmap?14:7));
            int32_t x=d->x+xy[2];
            int32_t y=d->y+xy[3];
            int32_t j=0;
            rectfill(screen,x,y-header_height-frame_thickness-is_large,int32_t(x+116*(is_large?1.5:1)-1),y-1,jwin_pal[jcBOX]);
            
            for(j=0; j<8; ++j)
            {
                textprintf_ex(screen,is_large?nfont:spfont,x-header_width-frame_thickness,y+1+(j*(is_large?10:7)),jwin_pal[jcBOXFG],jwin_pal[jcBOX],"%d",j);
            }
            
            for(j=0; j<cols; ++j)
            {
                textprintf_ex(screen,is_large?nfont:spfont,x+((col_width+1)/2)-(header_width/2)+(j*col_width),y-header_height-frame_thickness,jwin_pal[jcBOXFG],jwin_pal[jcBOX],"%X",j);
            }
            
            jwin_draw_frame(screen, (x-frame_thickness)+is_large, (y-frame_thickness)+is_large, is_large?180:116, is_large?84:60, FR_DEEP);
            blit(dmapbmp_large,screen,0,0,x,y,dmapbmp_large->w,dmapbmp_large->h);
        }
        
        //slider is disabled if
        (d+1)->flags&=~D_DISABLED;
        (d+1)->flags|=small_dmap?0:D_DISABLED;
        object_message(d+1, MSG_DRAW, 0);
        unscare_mouse();
    }
    
    return ret;
}

int32_t xmapspecs[4] = {0,0,2,26};

int32_t onXslider(void *dp3,int32_t d2)
{
    int32_t *x=(int32_t *)dp3;
    int32_t *y=x+1;
    xmapspecs[1]=d2-7;
    bound(xmapspecs[1],-7,15);
    drawxmap(xmapspecs[0],xmapspecs[1],small_dmap);
    scare_mouse();
    blit(dmapbmp_large,screen,0,0,(*x)+xmapspecs[2],(*y)+xmapspecs[3],dmapbmp_large->w,dmapbmp_large->h);
    unscare_mouse();
    return D_O_K;
}

const char *dmaptype_str[dmMAX] = { "NES Dungeon","Overworld","Interior","BS-Overworld" };

const char *typelist(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        bound(index,0,dmMAX-1);
        return dmaptype_str[index];
    }
    
    *list_size=dmMAX;
    return NULL;
}

bool edit_ins_mode=true;

void put_title_str(char *s,int32_t x,int32_t y,int32_t fg,int32_t bg,int32_t pos,int32_t lines,int32_t cpl)
{
    int32_t i=0;
    
    // text_mode(bg);
    for(int32_t dy=0; dy<lines; dy++)
        for(int32_t dx=0; dx<cpl; dx++)
        {
            if(edit_ins_mode)
            {
                textprintf_ex(screen,zfont,x+(dx<<3),y+(dy<<3),fg,bg,"%c",*(s+i));
            }
            else
            {
                //     text_mode(i==pos?vc(15):bg);
                
                textprintf_ex(screen,zfont,x+(dx<<3),y+(dy<<3),i==pos?bg:fg,i==pos?vc(15):bg,"%c",*(s+i));
            }
            
            ++i;
        }
        
    if(edit_ins_mode&&pos>-1)
    {
        //   text_mode(-1);
        textprintf_ex(screen,zfont,x+((pos%cpl)<<3),y+((pos/cpl)<<3),vc(15),-1,"_");
    }
}

int32_t d_title_edit_proc(int32_t msg,DIALOG *d,int32_t c)
{
    char *s=(char*)(d->dp);
    
    switch(msg)
    {
    case MSG_WANTFOCUS:
        return D_WANTFOCUS;
        
    case MSG_CLICK:
        d->d2=((gui_mouse_x()-d->x)>>3)+((gui_mouse_y()-d->y)>>3)*10;
        bound(d->d2,0,19);
        scare_mouse();
        put_title_str(s,d->x,d->y,jwin_pal[jcTEXTBG],jwin_pal[jcTEXTFG],d->d2,2,10);
        unscare_mouse();
        
        while(gui_mouse_b())
        {
            /* do nothing */
            rest(1);
        }
        
        break;
        
    case MSG_DRAW:
        if(!(d->flags & D_GOTFOCUS))
        {
            d->d2=-1;
        }
        
        put_title_str(s,d->x,d->y,jwin_pal[jcTEXTBG],jwin_pal[jcTEXTFG],d->d2,2,10);
        break;
        
    case MSG_CHAR:
        bool used=false;
        int32_t k=c>>8;
        
        switch(k)
        {
        case KEY_INSERT:
            edit_ins_mode=!edit_ins_mode;
            used=true;
            break;
            
        case KEY_HOME:
            d->d2-=d->d2%10;
            used=true;
            break;
            
        case KEY_END:
            d->d2-=d->d2%10;
            d->d2+=9;
            used=true;
            break;
            
        case KEY_UP:
            if(d->d2>=10) d->d2-=10;
            
            used=true;
            break;
            
        case KEY_DOWN:
            if(d->d2<10) d->d2+=10;
            
            used=true;
            break;
            
        case KEY_LEFT:
            if(d->d2>0) --d->d2;
            
            used=true;
            break;
            
        case KEY_RIGHT:
            if(d->d2<19) ++d->d2;
            
            used=true;
            break;
            
        case KEY_BACKSPACE:
            if(d->d2>0)
                --d->d2;
                
        case KEY_DEL:
            strcpy(s+d->d2,s+d->d2+1);
            s[19]=' ';
            s[20]=0;
            used=true;
            break;
            
        default:
            if(isprint(c&255))
            {
                if(edit_ins_mode)
                {
                    for(int32_t i=19; i>d->d2; i--)
                        s[i]=s[i-1];
                }
                
                s[d->d2]=c&255;
                
                if(d->d2<19)
                    ++d->d2;
                    
                used=true;
            }
        }
        
        scare_mouse();
        put_title_str(s,d->x,d->y,jwin_pal[jcTEXTBG],jwin_pal[jcTEXTFG],d->d2,2,10);
        unscare_mouse();
        return used?D_USED_CHAR:D_O_K;
    }
    
    return D_O_K;
}

void put_intro_str(char *s,int32_t x,int32_t y,int32_t fg,int32_t bg,int32_t pos)
{
    int32_t i=0;
    
    // text_mode(bg);
    for(int32_t dy=0; dy<3; dy++)
        for(int32_t dx=0; dx<24; dx++)
        {
            if(edit_ins_mode)
            {
                textprintf_ex(screen,zfont,x+(dx<<3),y+(dy<<3),fg,bg,"%c",*(s+i));
            }
            else
            {
                //     text_mode(i==pos?vc(15):bg);
                textprintf_ex(screen,zfont,x+(dx<<3),y+(dy<<3),i==pos?bg:fg,i==pos?vc(15):bg,"%c",*(s+i));
            }
            
            ++i;
        }
        
    if(edit_ins_mode&&pos>-1)
    {
        //   text_mode(-1);
        textprintf_ex(screen,zfont,x+((pos%24)<<3),y+((pos/24)<<3),vc(15),-1,"_");
    }
}

int32_t d_intro_edit_proc(int32_t msg,DIALOG *d,int32_t c)
{
    char *s=(char*)(d->dp);
    
    switch(msg)
    {
    case MSG_WANTFOCUS:
        return D_WANTFOCUS;
        
    case MSG_CLICK:
        d->d2=((gui_mouse_x()-d->x)>>3)+((gui_mouse_y()-d->y)>>3)*24;
        bound(d->d2,0,71);
        scare_mouse();
        put_intro_str(s,d->x,d->y,jwin_pal[jcTEXTBG],jwin_pal[jcTEXTFG],d->d2);
        unscare_mouse();
        
        while(gui_mouse_b())
        {
            /* do nothing */
            rest(1);
        }
        
        break;
        
    case MSG_DRAW:
    
        if(!(d->flags & D_GOTFOCUS))
        {
            d->d2=-1;
            
        }
        
        put_intro_str(s,d->x,d->y,jwin_pal[jcTEXTBG],jwin_pal[jcTEXTFG],d->d2);
        break;
        
    case MSG_CHAR:
        bool used=false;
        int32_t k=c>>8;
        
        switch(k)
        {
        case KEY_INSERT:
            edit_ins_mode=!edit_ins_mode;
            used=true;
            break;
            
        case KEY_HOME:
            d->d2-=d->d2%24;
            used=true;
            break;
            
        case KEY_END:
            d->d2-=d->d2%24;
            d->d2+=23;
            used=true;
            break;
            
        case KEY_UP:
            if(d->d2>=24) d->d2-=24;
            
            used=true;
            break;
            
        case KEY_DOWN:
            if(d->d2<48) d->d2+=24;
            
            used=true;
            break;
            
        case KEY_LEFT:
            if(d->d2>0) --d->d2;
            
            used=true;
            break;
            
        case KEY_RIGHT:
            if(d->d2<71) ++d->d2;
            
            used=true;
            break;
            
        case KEY_BACKSPACE:
            if(d->d2>0)
                --d->d2;
                
        case KEY_DEL:
            strcpy(s+d->d2,s+d->d2+1);
            s[71]=' ';
            s[72]=0;
            used=true;
            break;
            
        default:
            if(isprint(c&255))
            {
                if(edit_ins_mode)
                {
                    for(int32_t i=71; i>d->d2; i--)
                        s[i]=s[i-1];
                }
                
                s[d->d2]=c&255;
                
                if(d->d2<71)
                    ++d->d2;
                    
                used=true;
            }
        }
        
        scare_mouse();
        put_intro_str(s,d->x,d->y,jwin_pal[jcTEXTBG],jwin_pal[jcTEXTFG],d->d2);
        unscare_mouse();
        return used?D_USED_CHAR:D_O_K;
    }
    
    return D_O_K;
}

char dmap_title[21];
char dmap_name[21];
char dmap_intro[73];


static int32_t editdmap_mechanics_list[] =
{
    // dialog control number
    19, 20, 21, 22, 23, 24, 25, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 213, 214, -1
};

/*
static int32_t editdmap_continue_list[] =
{
  120,-1
};
*/

static int32_t editdmap_appearance_list[] =
{
    // dialog control number
    64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, -1
};

static int32_t editdmap_music_list[] =
{
    // dialog control number
    82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, -1
};

static int32_t editdmap_subscreenmaps_list[] =
{
    // dialog control number
    6, -1
};

static int32_t editdmap_disableitems_list[] =
{
    // dialog control number
    100,101,102,103,104,105,-1
};

static int32_t editdmap_flags_list[] =
{
    110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,127,128,129,168,211,212,-1
};

static int32_t editdmap_script_active[] =
{
    // dialog control number
	130,131,132,133,134,135,136,137,//InitD Labels
	138,139,140,141,142,143,144,145,//InitD Values
	146,147, //TextProc & Dropdown
	187,188,189,190,191,192,193,194,//Swapbtns
	-1
};

static int32_t editdmap_script_subsc[] =
{
    // dialog control number
	148,149,150,151,152,153,154,155,//InitD Labels
	156,157,158,159,160,161,162,163,//InitD Values
	164,165,166,167, //TextProcs & Dropdowns
	195,196,197,198,199,200,201,202,//Swapbtns
	-1
};

static int32_t editdmap_script_onmap[] =
{
    // dialog control number
	169,170,171,172,173,174,175,176,//InitD Labels
	177,178,179,180,181,182,183,184,//InitD Values
	185,186, //TextProcs & Dropdowns
	203,204,205,206,207,208,209,210,//Swapbtns
	-1
};

static int32_t editdmap_scripts_list[] =
{
    // dialog control number
	28, -1
};

static TABPANEL editdmap_tabs[] =
{
    // (text)
    { (char *)"Mechanics",      D_SELECTED,  editdmap_mechanics_list,      0,  NULL },
    { (char *)"Appearance",     0,           editdmap_appearance_list,     0,  NULL },
    { (char *)"Music",          0,           editdmap_music_list,          0,  NULL },
    { (char *)"Maps",           0,           editdmap_subscreenmaps_list,  0,  NULL },
    { (char *)"Flags",          0,           editdmap_flags_list,          0,  NULL },
    { (char *)"Disable",        0, 		   editdmap_disableitems_list,   0,  NULL },
    { (char *)"Scripts",        0, 		   editdmap_scripts_list,   0,  NULL },
    { NULL,                     0,           NULL,                         0,  NULL }
};

static int32_t editdmapmap_before_list[] =
{
    // dialog control number
    7, 8, 9, 10, 11, 12, -1
};

static int32_t editdmapmap_after_list[] =
{
    // dialog control number
    13, 14, 15, 16, 17, 18, 26, 27, -1
};

static TABPANEL editdmapmap_tabs[] =
{
    // (text)
    { (char *)"Without Map",  D_SELECTED,  editdmapmap_before_list, 0, NULL },
    { (char *)"With Map",     0,           editdmapmap_after_list, 0, NULL },
    { NULL,                   0,           NULL, 0, NULL }
};

static TABPANEL editdmap_script_tabs[] =
{
    // (text)
    { (char *)"Active",  D_SELECTED,  editdmap_script_active, 0, NULL },
    { (char *)"Subscreen",     0,           editdmap_script_subsc, 0, NULL },
    { (char *)"Map",     0,           editdmap_script_onmap, 0, NULL },
    { NULL,                   0,           NULL, 0, NULL }
};

int32_t dmap_tracks=0;
static char dmap_track_number_str_buf[MIDI_TRACK_BUFFER_SIZE] = {0};
const char *dmaptracknumlist(int32_t index, int32_t *list_size)
{
	//memset(dmap_track_number_str_buf,0,50);
    if(index>=0)
    {
        bound(index,0,255);
        sprintf(dmap_track_number_str_buf,"%02d",index+1);
        return dmap_track_number_str_buf;
    }
    
    *list_size=dmap_tracks;
    return NULL;
}

extern const char *subscreenlist_a(int32_t index, int32_t *list_size);
extern const char *subscreenlist_b(int32_t index, int32_t *list_size);

static ListData subscreen_list_a(subscreenlist_a, &font);
static ListData subscreen_list_b(subscreenlist_b, &font);
static ListData midi_list(midilist, &font);
static ListData dmaptracknum_list(dmaptracknumlist, &font);
static ListData type_list(typelist, &font);
static ListData gotomap_list(gotomaplist, &font);


const char *dmapscriptdroplist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = bidmaps_cnt;
        return NULL;
    }
    
    return bidmaps[index].first.c_str();
}


//droplist like the dialog proc, naming scheme for this stuff is awful...
static ListData dmapscript_list(dmapscriptdroplist, &pfont);


static DIALOG editdmap_dlg[] =
{
    // (dialog proc)                (x)     (y)     (w)     (h)     (fg)                    (bg)                 (key)     (flags)   (d1)           (d2)   (dp)                                                   (dp2)                 (dp3)
    {  jwin_win_proc,                 0,      0,    320,    256,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    D_EXIT,      0,             0, (void *) "DMap Editor",                                NULL,                 NULL                  },
    {  jwin_button_proc,             89,    228,     61,     21,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],        13,    D_EXIT,      0,             0, (void *) "OK",                                         NULL,                 NULL                  },
    {  jwin_button_proc,            164,    228,     61,     21,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],        27,    D_EXIT,      0,             0, (void *) "Cancel",                                     NULL,                 NULL                  },
    {  jwin_text_proc,               10,     29,     48,      8,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           0,             0, (void *) "Name: ",                                     NULL,                 NULL                  },
    {  jwin_edit_proc,               40,     25,    168,     16,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,          20,             0,  NULL,                                                  NULL,                 NULL                  },
    //5
    {  jwin_tab_proc,                 6,     45,    310,    180,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           0,             0, (void *) editdmap_tabs,                                NULL, (void *)editdmap_dlg  },
    {  jwin_tab_proc,                 8,     62,    306,    159,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           0,             0, (void *) editdmapmap_tabs,                             NULL, (void *)editdmap_dlg  },
    {  jwin_ctext_proc,              67,     87,      0,      8,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           0,             0, (void *) "Minimap",                                    NULL,                 NULL                  },
    {  jwin_frame_proc,              31,     95,     84,     52,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           FR_DEEP,       0,  NULL,                                                  NULL,                 NULL                  },
    {  d_maptile_proc,               33,     97,     80,     48,    0,                      0,                       0,    0,           0,             0,  NULL, (void*)0,             NULL                  },
    //10
    {  jwin_ctext_proc,             207,     87,      0,      8,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           0,             0, (void *) "Large",                                      NULL,                 NULL                  },
    {  jwin_frame_proc,             133,     95,    148,     84,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           FR_DEEP,       0,  NULL,                                                  NULL,                 NULL                  },
    {  d_maptile_proc,              135,     97,    144,     80,    0,                      0,                       0,    0,           0,             0,  NULL, (void*)0,             NULL                  },
    {  jwin_ctext_proc,              67,     87,      0,      8,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           0,             0, (void *) "Minimap",                                    NULL,                 NULL                  },
    {  jwin_frame_proc,              31,     95,     84,     52,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           FR_DEEP,       0,  NULL,                                                  NULL,                 NULL                  },
    //15
    {  d_maptile_proc,               33,     97,     80,     48,    0,                      0,                       0,    0,           0,             0,  NULL, (void*)0,             NULL                  },
    {  jwin_ctext_proc,             207,     87,      0,      8,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           0,             0, (void *) "Large",                                      NULL,                 NULL                  },
    {  jwin_frame_proc,             133,     95,    148,     84,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           FR_DEEP,       0,  NULL,                                                  NULL,                 NULL                  },
    {  d_maptile_proc,              135,     97,    144,     80,    0,                      0,                       0,    0,           0,             0,  NULL, (void*)0,             NULL                  },
    {  jwin_text_proc,               12,     69,     48,      8,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           0,             0, (void *) "Map:",                                       NULL,                 NULL                  },
    //20
    {  d_xmaplist_proc,              36,     65,     54,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,    0,           1,             0, (void *) &gotomap_list,                                NULL,                 xmapspecs             },
    {  jwin_slider_proc,             38,    151,    111,     10,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,          22,             0,  NULL, (void *) onXslider,   NULL                  },
    {  jwin_text_proc,              103,     69,     64,      8,    vc(14),                 vc(1),                   0,    0,           0,             0, (void *) "Type: ",                                     NULL,                 NULL                  },
    {  d_dropdmaptypelist_proc,     132,     65,     99,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,    0,           1,             0, (void *) &type_list,                                   NULL,                 NULL                  },
    {  jwin_text_proc,              243,     69,     48,      8,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           0,             0, (void *) "Level:",                                     NULL,                 NULL                  },
    //25
    {  jwin_edit_proc,              274,     65,     26,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,    0,           3,             0,  NULL,                                                  NULL,                 NULL                  },
    {  jwin_text_proc,              28,    150,     70,      8,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           0,             0, (void *) "Setting this tile disables",                                NULL,                 NULL                  },
    {  jwin_text_proc,              28,    158,     70,      8,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           0,             0, (void *) "the classic NES minimap.",                                NULL,                 NULL                  },
    {  jwin_tab_proc,                8,     62,    306,    159,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           0,             0, (void *) editdmap_script_tabs,                             NULL, (void *)editdmap_dlg  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    //30
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    //35
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    //40
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    //45
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    //50
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    //55
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_grid_proc,                 162,     83,    124,     66,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  jwin_text_proc,              162,    155,     48,      8,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           0,             0, (void *) "Compass: 0x",                                NULL,                 NULL                  },
    //60
    {  jwin_edit_proc,              218,    151,     21,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,    0,           2,             0,  NULL,                                                  NULL,                 NULL                  },
    {  jwin_text_proc,              162,    173,     48,      8,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           0,             0, (void *) "Continue: 0x",                               NULL,                 NULL                  },
    {  jwin_edit_proc,              218,    169,     21,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,    0,           2,             0,  NULL,                                                  NULL,                 NULL                  },
    {  jwin_check_proc,              76,    173,    113,      9,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           1,             0, (void *) "Continue here",                              NULL,                 NULL                  },
    {  jwin_text_proc,               12,     69,     48,      8,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           0,             0, (void *) "Color:",                                     NULL,                 NULL                  },
    //65
    {  jwin_droplist_proc,           42,     65,    161,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,    0,           1,             0, (void *) &levelnum_list,                               NULL,                 NULL                  },
    {  jwin_ctext_proc,              55,     85,      0,      8,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           0,             0, (void *) "DMap Title",                                 NULL,                 NULL                  },
    {  jwin_frame_proc,              13,     93,     84,     20,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           FR_DEEP,       0,  NULL,                                                  NULL,                 NULL                  },
    {  d_title_edit_proc,            15,     95,     80,     16,    jwin_pal[jcTEXTBG],     jwin_pal[jcTEXTFG],      0,    0,           0,             0, (void *) dmap_title,                                   NULL,                 NULL                  },
    {  jwin_ctext_proc,             201,     85,      0,      8,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           0,             0, (void *) "DMap Intro",                                 NULL,                 NULL                  },
    //70
    {  jwin_frame_proc,             103,     93,    196,     28,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           FR_DEEP,       0,  NULL,                                                  NULL,                 NULL                  },
    {  d_intro_edit_proc,           105,     95,    192,     24,    jwin_pal[jcTEXTBG],     jwin_pal[jcTEXTFG],      0,    0,           0,             0, (void *) dmap_intro,                                   NULL,                 NULL                  },
    {  jwin_frame_proc,              12,    127,    223,     44,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           FR_ETCHED,     0,  NULL,                                                  NULL,                 NULL                  },
    {  jwin_text_proc,               20,    124,     48,      8,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           0,             0, (void *) " Subscreens ",                               NULL,                 NULL                  },
    {  jwin_text_proc,               16,    137,     48,      8,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           0,             0, (void *) "Active:",                                    NULL,                 NULL                  },
    //75
    {  jwin_droplist_proc,           57,    133,    174,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,    0,           1,             0, (void *) &subscreen_list_a,                            NULL,                 NULL                  },
    {  jwin_text_proc,               16,    155,     48,      8,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           0,             0, (void *) "Passive:",                                   NULL,                 NULL                  },
    {  jwin_droplist_proc,           57,    151,    174,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,    0,           1,             0, (void *) &subscreen_list_b,                            NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    //80
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  jwin_text_proc,               12,     69,     48,      8,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           0,             0, (void *) "Midi:",                                      NULL,                 NULL                  },
    {  jwin_droplist_proc,           35,     65,    153,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,    0,           1,             0, (void *) &midi_list,                                   NULL,                 NULL                  },
    {  jwin_frame_proc,              12,     86,    176,     68,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           FR_ETCHED,     0,  NULL,                                                  NULL,                 NULL                  },
    //85
    {  jwin_text_proc,               20,     83,     48,      8,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           0,             0, (void *) " Enhanced Music ",                           NULL,                 NULL                  },
    {  jwin_frame_proc,              16,     92,    168,     16,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           FR_DEEP,       0,  NULL,                                                  NULL,                 NULL                  },
    {  jwin_text_proc,               19,     96,    162,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  jwin_text_proc,               16,    114,     48,      8,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           0,             0, (void *) "Track:",                                     NULL,                 NULL                  },
    {  jwin_droplist_proc,           50,    110,    134,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,    0,           1,             0, (void *) &dmaptracknum_list,                           NULL,                 NULL                  },
    //90
    {  jwin_button_proc,             31,    129,     61,     21,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],        13,    D_EXIT,      0,             0, (void *) "Load",                                       NULL,                 NULL                  },
    {  jwin_button_proc,            108,    129,     61,     21,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],        13,    D_EXIT,      0,             0, (void *) "Clear",                                      NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    //95
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    //100
    {  jwin_text_proc,               12,     69,     48,      8,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           0,             0, (void *) "Disabled Items:",                            NULL,                 NULL                  },
    {  jwin_abclist_proc,            12,     81,    120,    104,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,    D_EXIT,      0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  jwin_abclist_proc,           177,     81,    120,    104,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,    D_EXIT,      0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  jwin_text_proc,              177,     69,     48,      8,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           0,             0, (void *) "All Items:",                                 NULL,                 NULL                  },
    {  jwin_button_proc,            146,    105,     20,     20,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],        13,    D_EXIT,      0,             0, (void *) "->",                                         NULL,                 NULL                  },
    //105
    {  jwin_button_proc,            146,    145,     20,     20,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],        13,    D_EXIT,      0,             0, (void *) "<-",                                         NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    {  d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    //110
    {  jwin_check_proc,              12,     65,    113,      9,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           1,             0, (void *) "Use Caves Instead Of Item Cellars",          NULL,                 NULL                  },
    {  jwin_check_proc,              12,     75,    113,      9,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           1,             0, (void *) "Allow 3-Stair Warp Rooms",                   NULL,                 NULL                  },
    {  jwin_check_proc,              12,     85,    113,      9,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           1,             0, (void *) "Allow Whistle Whirlwinds",                   NULL,                 NULL                  },
    {  jwin_check_proc,              12,    105,    113,      9,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           1,             0, (void *) "Special Rooms And Guys Are In Caves Only",   NULL,                 NULL                  },
    {  jwin_check_proc,              12,    115,    113,      9,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           1,             0, (void *) "Don't Display Compass Marker In Minimap",    NULL,                 NULL                  },
    {  jwin_check_proc,              12,    125,    113,      9,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           1,             0, (void *) "Underwater Wave Effect",                     NULL,                 NULL                  },
    {  jwin_check_proc,              12,     95,    113,      9,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           1,             0, (void *) "Whistle Whirlwind Returns Player To Start",    NULL,                 NULL                  },
    {  jwin_check_proc,              12,    135,    113,      9,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           1,             0, (void *) "Always Display Intro String",                NULL,                 NULL                  },
    {  jwin_check_proc,              12,    145,    113,      9,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           1,             0, (void *) "View Overworld Map By Pressing 'Map'",       NULL,                 NULL                  },
    {  jwin_check_proc,              12,    155,    113,      9,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           1,             0, (void *) "...But Only Show Screens Marked In Minimap",      NULL,                 NULL                  },
    {  jwin_check_proc,              12,    165,    113,      9,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           1,             0, (void *) "Use Minimap Foreground Color 2",      NULL,                 NULL                  },
    //121
    {  jwin_check_proc,             230,     65,    113,      9,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           1,             0, (void *) "Script 1",        					   NULL,                 NULL                  },
    {  jwin_check_proc,             230,     75,    113,      9,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           1,             0, (void *) "Script 2",        					   NULL,                 NULL                  },
    {  jwin_check_proc,             230,     85,    113,      9,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           1,             0, (void *) "Script 3",        					   NULL,                 NULL                  },
    {  jwin_check_proc,             230,     95,    113,      9,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           1,             0, (void *) "Script 4",        					   NULL,                 NULL                  },
    {  jwin_check_proc,             230,    105,    113,      9,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           1,             0, (void *) "Script 5",        					   NULL,                 NULL                  },
    {  d_timer_proc,                  0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  },
    
    //127
    {  jwin_check_proc,              230,    115,    113,      9,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           1,             0, (void *) "Sideview",      NULL,                 NULL                  },
    {  jwin_check_proc,              12,    185,    113,      9,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           1,             0, (void *) "Layer 3 is Background on All Screens",      NULL,                 NULL                  },
    {  jwin_check_proc,              12,    195,    113,      9,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           1,             0, (void *) "Layer 2 is Background on All Screens",      NULL,                 NULL                  },
    //130
    /*
     { jwin_text_proc,       6+10,   29+20,   24,    36,   0,        0,       0,       0,          0,             0, (void *) "D0:", NULL, NULL },
    { jwin_text_proc,       6+10,   47+20,   24,    36,   0,        0,       0,       0,          0,             0, (void *) "D1:", NULL, NULL },
    { jwin_text_proc,       6+10,   65+20,   24,    36,   0,        0,       0,       0,          0,             0, (void *) "D2:", NULL, NULL },
    { jwin_text_proc,       6+10,   83+20,   24,    36,   0,        0,       0,       0,          0,             0, (void *) "D3:", NULL, NULL },
    { jwin_text_proc,       6+10,  101+20,   24,    36,   0,        0,       0,       0,          0,             0, (void *) "D4:", NULL, NULL },
    { jwin_text_proc,       6+10,  119+20,   24,    36,   0,        0,       0,       0,          0,             0, (void *) "D5:", NULL, NULL },
    { jwin_text_proc,       6+10,  137+20,   24,    36,   0,        0,       0,       0,          0,             0, (void *) "D6:", NULL, NULL },
    { jwin_text_proc,       6+10,  155+20,   24,    12,   0,        0,       0,       0,          0,             0, (void *) "D7:", NULL, NULL },
   */
    //130
    // If I make it possible to edit these, too, they'd be here. -Z
    {  jwin_edit_proc,         6+10-4-2,     10+29+20+3+1+16,    90,     16,    vc(12),                 vc(1),                   0,    0,          63,    0,  NULL,                                                           NULL,   NULL                 },
    {  jwin_edit_proc,         6+10-4-2,     10+47+20+3+1+16,    90,     16,    vc(12),                 vc(1),                   0,    0,          63,    0,  NULL,                                                           NULL,   NULL                 },
    {  jwin_edit_proc,         6+10-4-2,     10+65+20+3+1+16,    90,     16,    vc(12),                 vc(1),                   0,    0,          63,    0,  NULL,                                                           NULL,   NULL                 },
    {  jwin_edit_proc,         6+10-4-2,     10+83+20+3+1+16,    90,     16,    vc(12),                 vc(1),                   0,    0,          63,    0,  NULL,                                                           NULL,   NULL                 },
    {  jwin_edit_proc,         6+10-4-2,     10+101+20+3+1+16,    90,     16,    vc(12),                 vc(1),                   0,    0,          63,    0,  NULL,                                                           NULL,   NULL                 },
    {  jwin_edit_proc,         6+10-4-2,     10+119+20+3+1+16,    90,     16,    vc(12),                 vc(1),                   0,    0,          63,    0,  NULL,                                                           NULL,   NULL                 },
    {  jwin_edit_proc,         6+10-4-2,     10+137+20+3+1+16,    90,     16,    vc(12),                 vc(1),                   0,    0,          63,    0,  NULL,                                                           NULL,   NULL                 },
    {  jwin_edit_proc,         6+10-4-2,     10+155+20+3+1+16,    90,     16,    vc(12),                 vc(1),                   0,    0,          63,    0,  NULL,                                                           NULL,   NULL                 },
    
    //138
    { jwin_numedit_swap_zsint_proc,      (90-24)+34+10-4-2,   10+29+20+3+1+16,   72-16,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
    { jwin_numedit_swap_zsint_proc,      (90-24)+34+10-4-2,   10+47+20+3+1+16,   72-16,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
    { jwin_numedit_swap_zsint_proc,      (90-24)+34+10-4-2,   10+65+20+3+1+16,   72-16,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
    { jwin_numedit_swap_zsint_proc,      (90-24)+34+10-4-2,   10+83+20+3+1+16,   72-16,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
    { jwin_numedit_swap_zsint_proc,      (90-24)+34+10-4-2,   10+101+20+3+1+16,   72-16,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
    { jwin_numedit_swap_zsint_proc,      (90-24)+34+10-4-2,  10+119+20+3+1+16,   72-16,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
    { jwin_numedit_swap_zsint_proc,      (90-24)+34+10-4-2,  10+137+20+3+1+16,   72-16,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
    { jwin_numedit_swap_zsint_proc,      (90-24)+34+10-4-2,  10+155+20+3+1+16,   72-16,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
    //146
    { jwin_text_proc,           112+10+20+34+1-4-4-3-2+14,  10+29+12+7+3+1+16,     35,      8,    vc(14),                 vc(1),                   0,       0,           0,    0, (void *) "Script:",                      NULL,   NULL                  },
    { jwin_droplist_proc,       112+10+20+34-4-4-3-2+14,  10+29+20+7+3+1+16,     136,      16, jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],           0,       0,           1,    0, (void *) &dmapscript_list,                   NULL,   NULL 				   },
    //148
    {  jwin_edit_proc,         6+10-4-2,     10+29+20+3+1+16,    90,     16,    vc(12),                 vc(1),                   0,    0,          63,    0,  NULL,                                                           NULL,   NULL                 },
    {  jwin_edit_proc,         6+10-4-2,     10+47+20+3+1+16,    90,     16,    vc(12),                 vc(1),                   0,    0,          63,    0,  NULL,                                                           NULL,   NULL                 },
    {  jwin_edit_proc,         6+10-4-2,     10+65+20+3+1+16,    90,     16,    vc(12),                 vc(1),                   0,    0,          63,    0,  NULL,                                                           NULL,   NULL                 },
    {  jwin_edit_proc,         6+10-4-2,     10+83+20+3+1+16,    90,     16,    vc(12),                 vc(1),                   0,    0,          63,    0,  NULL,                                                           NULL,   NULL                 },
    {  jwin_edit_proc,         6+10-4-2,     10+101+20+3+1+16,    90,     16,    vc(12),                 vc(1),                   0,    0,          63,    0,  NULL,                                                           NULL,   NULL                 },
    {  jwin_edit_proc,         6+10-4-2,     10+119+20+3+1+16,    90,     16,    vc(12),                 vc(1),                   0,    0,          63,    0,  NULL,                                                           NULL,   NULL                 },
    {  jwin_edit_proc,         6+10-4-2,     10+137+20+3+1+16,    90,     16,    vc(12),                 vc(1),                   0,    0,          63,    0,  NULL,                                                           NULL,   NULL                 },
    {  jwin_edit_proc,         6+10-4-2,     10+155+20+3+1+16,    90,     16,    vc(12),                 vc(1),                   0,    0,          63,    0,  NULL,                                                           NULL,   NULL                 },
    //156
    { jwin_numedit_swap_zsint_proc,      (90-24)+34+10-4-2,   10+29+20+3+1+16,   72-16,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
    { jwin_numedit_swap_zsint_proc,      (90-24)+34+10-4-2,   10+47+20+3+1+16,   72-16,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
    { jwin_numedit_swap_zsint_proc,      (90-24)+34+10-4-2,   10+65+20+3+1+16,   72-16,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
    { jwin_numedit_swap_zsint_proc,      (90-24)+34+10-4-2,   10+83+20+3+1+16,   72-16,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
    { jwin_numedit_swap_zsint_proc,      (90-24)+34+10-4-2,   10+101+20+3+1+16,   72-16,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
    { jwin_numedit_swap_zsint_proc,      (90-24)+34+10-4-2,  10+119+20+3+1+16,   72-16,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
    { jwin_numedit_swap_zsint_proc,      (90-24)+34+10-4-2,  10+137+20+3+1+16,   72-16,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
    { jwin_numedit_swap_zsint_proc,      (90-24)+34+10-4-2,  10+155+20+3+1+16,   72-16,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
    //164
    { jwin_text_proc,           112+10+20+34+1-4-4-3-2+14,  10+29+12+7+3+1+16,     35,      8,    vc(14),                 vc(1),                   0,       0,           0,    0, (void *) "Active Subscreen Script:",                      NULL,   NULL                  },
    { jwin_droplist_proc,       112+10+20+34-4-4-3-2+14,  10+29+20+7+3+1+16,     136,      16, jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],           0,       0,           1,    0, (void *) &dmapscript_list,                   NULL,   NULL 				   },
    //166
    { jwin_text_proc,           112+10+20+34+1-4-4-3-2+14,  10+29+12+7+3+1+28+16,     35,      8,    vc(14),                 vc(1),                   0,       0,           0,    0, (void *) "Passive Subscreen Script:",                      NULL,   NULL                  },
    { jwin_droplist_proc,       112+10+20+34-4-4-3-2+14,  10+29+20+7+3+1+28+16,     136,      16, jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],           0,       0,           1,    0, (void *) &dmapscript_list,                   NULL,   NULL 				   },
    
    //168
    {  jwin_check_proc,              12,    175,    113,      9,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           1,             0, (void *) "Use Enemy List for Cellar Enemies",      NULL,                 NULL                  },
    
	//169
    {  jwin_edit_proc,         6+10-4-2,     10+29+20+3+1+16,    90,     16,    vc(12),                 vc(1),                   0,    0,          63,    0,  NULL,                                                           NULL,   NULL                 },
    {  jwin_edit_proc,         6+10-4-2,     10+47+20+3+1+16,    90,     16,    vc(12),                 vc(1),                   0,    0,          63,    0,  NULL,                                                           NULL,   NULL                 },
    {  jwin_edit_proc,         6+10-4-2,     10+65+20+3+1+16,    90,     16,    vc(12),                 vc(1),                   0,    0,          63,    0,  NULL,                                                           NULL,   NULL                 },
    {  jwin_edit_proc,         6+10-4-2,     10+83+20+3+1+16,    90,     16,    vc(12),                 vc(1),                   0,    0,          63,    0,  NULL,                                                           NULL,   NULL                 },
    {  jwin_edit_proc,         6+10-4-2,     10+101+20+3+1+16,    90,     16,    vc(12),                 vc(1),                   0,    0,          63,    0,  NULL,                                                           NULL,   NULL                 },
    {  jwin_edit_proc,         6+10-4-2,     10+119+20+3+1+16,    90,     16,    vc(12),                 vc(1),                   0,    0,          63,    0,  NULL,                                                           NULL,   NULL                 },
    {  jwin_edit_proc,         6+10-4-2,     10+137+20+3+1+16,    90,     16,    vc(12),                 vc(1),                   0,    0,          63,    0,  NULL,                                                           NULL,   NULL                 },
    {  jwin_edit_proc,         6+10-4-2,     10+155+20+3+1+16,    90,     16,    vc(12),                 vc(1),                   0,    0,          63,    0,  NULL,                                                           NULL,   NULL                 },
    //177
    { jwin_numedit_swap_zsint_proc,      (90-24)+34+10-4-2,   10+29+20+3+1+16,   72-16,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
    { jwin_numedit_swap_zsint_proc,      (90-24)+34+10-4-2,   10+47+20+3+1+16,   72-16,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
    { jwin_numedit_swap_zsint_proc,      (90-24)+34+10-4-2,   10+65+20+3+1+16,   72-16,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
    { jwin_numedit_swap_zsint_proc,      (90-24)+34+10-4-2,   10+83+20+3+1+16,   72-16,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
    { jwin_numedit_swap_zsint_proc,      (90-24)+34+10-4-2,   10+101+20+3+1+16,   72-16,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
    { jwin_numedit_swap_zsint_proc,      (90-24)+34+10-4-2,  10+119+20+3+1+16,   72-16,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
    { jwin_numedit_swap_zsint_proc,      (90-24)+34+10-4-2,  10+137+20+3+1+16,   72-16,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
    { jwin_numedit_swap_zsint_proc,      (90-24)+34+10-4-2,  10+155+20+3+1+16,   72-16,    16,   vc(12),   vc(1),   0,       0,          12,             0,       NULL, NULL, NULL },
    //185
    { jwin_text_proc,           112+10+20+34+1-4-4-3-2+14,  10+29+12+7+3+1+16,     35,      8,    vc(14),                 vc(1),                   0,       0,           0,    0, (void *) "OnMap Script:",                      NULL,   NULL                  },
    { jwin_droplist_proc,       112+10+20+34-4-4-3-2+14,  10+29+20+7+3+1+16,     136,      16, jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],           0,       0,           1,    0, (void *) &dmapscript_list,                   NULL,   NULL 				   },
	//187 (for 138+)
	{ jwin_swapbtn_proc,  158,      79,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,  158,      97,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,  158,     115,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,  158,     133,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,  158,     151,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,  158,     169,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,  158,     187,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,  158,     205,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
    //195 (for 156+)
	{ jwin_swapbtn_proc,  158,      79,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,  158,      97,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,  158,     115,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,  158,     133,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,  158,     151,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,  158,     169,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,  158,     187,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,  158,     205,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
    //203 (for 177+)
	{ jwin_swapbtn_proc,  158,      79,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,  158,      97,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,  158,     115,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,  158,     133,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,  158,     151,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,  158,     169,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,  158,     187,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
	{ jwin_swapbtn_proc,  158,     205,   16,    16,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL },
    //211
	{  jwin_check_proc,              12,    205,    113,      9,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           1,             0, (void *) "Become Bunny with no Pearl",      NULL,                 NULL                  },
	{  jwin_check_proc,              12,    215,    113,      9,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           1,             0, (void *) "Mirror Continues instead of Warping",      NULL,                 NULL                  },
    {  jwin_text_proc,              162,    191,     48,      8,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,    0,           0,             0, (void *) "Mirror DMap:",                               NULL,                 NULL                  },
    {  jwin_edit_proc,              218,    187,     21,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,    0,           2,             0,  NULL,                                                  NULL,                 NULL                  },
	
    {  NULL,                          0,      0,      0,      0,    0,                      0,                       0,    0,           0,             0,  NULL,                                                  NULL,                 NULL                  }
};

void editdmap(int32_t index)
{
	//DMapEditorLastMaptileUsed = 0;
	char levelstr[7], compassstr[7], contstr[7], mirrordmapstr[7], tmusicstr[56], dmapnumstr[60];
	char *tmfname;
	byte gridstring[8];
	static int32_t xy[2];
	
	char initdvals[8][13]; //script
	char subinitdvals[8][13]; //script
	char onmapinitdvals[8][13]; //script
	char initd_labels[8][65];
	char sub_initd_labels[8][65];
	char onmap_initd_labels[8][65];
	
	for ( int32_t q = 0; q < 8; q++ )
	{
		strcpy(initd_labels[q], DMaps[index].initD_label[q]);
		strcpy(sub_initd_labels[q], DMaps[index].sub_initD_label[q]);
		strcpy(onmap_initd_labels[q], DMaps[index].onmap_initD_label[q]);
		if ( initd_labels[q][0] == 0 ) sprintf(initd_labels[q],"InitD[%d]",q);
		if ( sub_initd_labels[q][0] == 0 ) sprintf(sub_initd_labels[q],"InitD[%d]",q);
		if ( onmap_initd_labels[q][0] == 0 ) sprintf(onmap_initd_labels[q],"InitD[%d]",q);
		editdmap_dlg[130+q].dp = initd_labels[q];
		editdmap_dlg[148+q].dp = sub_initd_labels[q];
		editdmap_dlg[169+q].dp = onmap_initd_labels[q];
	}
	
	
	
	sprintf(levelstr,"%d",DMaps[index].level);
	sprintf(dmapnumstr,"Edit DMap (%d)",index);
	sprintf(compassstr,"%02X",DMaps[index].compass);
	sprintf(contstr,"%02X",DMaps[index].cont);
	sprintf(mirrordmapstr,"%d",DMaps[index].mirrorDMap);
	sprintf(dmap_title,"%s",DMaps[index].title);
	sprintf(dmap_name,"%s",DMaps[index].name);
	sprintf(dmap_intro,"%s",DMaps[index].intro);
	sprintf(tmusicstr,"%s",DMaps[index].tmusic);
	
	//dmap script
	build_bidmaps_list(); //dmap scripts lister
	
	for(int32_t j = 0; j < bidmaps_cnt; j++)
	{
		if(bidmaps[j].second == DMaps[index].script -1)
		{
			editdmap_dlg[147].d1 = j; 
		}
		if(bidmaps[j].second == DMaps[index].active_sub_script -1)
		{
			editdmap_dlg[165].d1 = j; 
		}
		if(bidmaps[j].second == DMaps[index].passive_sub_script -1)
		{
			editdmap_dlg[167].d1 = j; 
		}
		if(bidmaps[j].second == DMaps[index].onmap_script -1)
		{
			editdmap_dlg[186].d1 = j; 
		}
	}
	
	for ( int32_t q = 0; q < 8; q++ )
	{
		editdmap_dlg[138+q].dp = initdvals[q];
		editdmap_dlg[156+q].dp = subinitdvals[q];
		editdmap_dlg[177+q].dp = onmapinitdvals[q];
		editdmap_dlg[138+q].fg = DMaps[index].initD[q];
		editdmap_dlg[156+q].fg = DMaps[index].sub_initD[q];
		editdmap_dlg[177+q].fg = DMaps[index].onmap_initD[q];
		editdmap_dlg[138+q].dp3 = &(editdmap_dlg[187+q]);
		editdmap_dlg[156+q].dp3 = &(editdmap_dlg[195+q]);
		editdmap_dlg[177+q].dp3 = &(editdmap_dlg[203+q]);
	}
	
	editdmap_dlg[0].dp=dmapnumstr;
	editdmap_dlg[0].dp2=lfont;
	editdmap_dlg[4].dp=dmap_name;
	editdmap_dlg[9].d1 = DMaps[index].minimap_1_tile;
	editdmap_dlg[9].fg = DMaps[index].minimap_1_cset;
	editdmap_dlg[12].d1 = DMaps[index].largemap_1_tile;
	editdmap_dlg[12].fg = DMaps[index].largemap_1_cset;
	editdmap_dlg[15].d1 = DMaps[index].minimap_2_tile;
	editdmap_dlg[15].fg = DMaps[index].minimap_2_cset;
	editdmap_dlg[18].d1 = DMaps[index].largemap_2_tile;
	editdmap_dlg[18].fg = DMaps[index].largemap_2_cset;
	editdmap_dlg[20].d1=(DMaps[index].map>(map_count-1))?0:DMaps[index].map;
	xy[0]=editdmap_dlg[20].x;
	xy[1]=editdmap_dlg[20].y;
	editdmap_dlg[21].dp3=xy;
	xmapspecs[1]=DMaps[index].xoff;
	editdmap_dlg[21].d2=DMaps[index].xoff+7;
	editdmap_dlg[23].d1=(DMaps[index].type&dmfTYPE);
	editdmap_dlg[25].dp=levelstr;
	
	editdmap_dlg[26].dp2=is_large?nfont:spfont;
	editdmap_dlg[27].dp2=is_large?nfont:spfont;
	
	for(int32_t i=0; i<8; i++)
	{
		for(int32_t j=0; j<8; j++)
		{
			set_bit(gridstring,8*i+j,get_bit((byte *)(DMaps[index].grid+i),7-j));
		}
	}
	
	editdmap_dlg[58].dp=gridstring;
	editdmap_dlg[60].dp=compassstr;
	editdmap_dlg[62].dp=contstr;
	editdmap_dlg[214].dp=mirrordmapstr;
	editdmap_dlg[63].flags = (DMaps[index].type&dmfCONTINUE) ? D_SELECTED : 0;
	editdmap_dlg[65].d1=DMaps[index].color;
	editdmap_dlg[75].d1=DMaps[index].active_subscreen;
	editdmap_dlg[77].d1=DMaps[index].passive_subscreen;
	editdmap_dlg[83].d1=DMaps[index].midi;
	editdmap_dlg[87].dp=tmusicstr;
	dmap_tracks=0;
	ZCMUSIC *tempdmapzcmusic = (ZCMUSIC*)zcmusic_load_file(tmusicstr);
	
	// Failed to load - try the quest directory
	if(tempdmapzcmusic==NULL)
	{
		char musicpath[256];
		replace_filename(musicpath, filepath, tmusicstr, 256);
		tempdmapzcmusic = (ZCMUSIC*)zcmusic_load_file(musicpath);
	}
	
	if(tempdmapzcmusic!=NULL)
	{
		dmap_tracks=zcmusic_get_tracks(tempdmapzcmusic);
		dmap_tracks=(dmap_tracks<2)?0:dmap_tracks;
	}
	
	zcmusic_unload_file(tempdmapzcmusic);
	editdmap_dlg[89].flags=(dmap_tracks<2)?D_DISABLED:0;
	editdmap_dlg[89].d1=vbound(DMaps[index].tmusictrack,0,dmap_tracks > 0 ? dmap_tracks-1 : 0);
	
	build_bii_list(false);
	initDI(index);
	ListData DI_list(DIlist, &font);
	ListData item_list(itemlist_num, &font);
	editdmap_dlg[101].dp = (void*)&DI_list;
	editdmap_dlg[101].d1 = 0;
	editdmap_dlg[102].dp = (void*)&item_list;
	editdmap_dlg[102].d1 = 0;
	
	editdmap_dlg[110].flags = (DMaps[index].flags& dmfCAVES)? D_SELECTED : 0;
	editdmap_dlg[111].flags = (DMaps[index].flags& dmf3STAIR)? D_SELECTED : 0;
	editdmap_dlg[112].flags = (DMaps[index].flags& dmfWHIRLWIND)? D_SELECTED : 0;
	editdmap_dlg[113].flags = (DMaps[index].flags& dmfGUYCAVES)? D_SELECTED : 0;
	editdmap_dlg[114].flags = (DMaps[index].flags& dmfNOCOMPASS)? D_SELECTED : 0;
	editdmap_dlg[115].flags = (DMaps[index].flags& dmfWAVY)? D_SELECTED : 0;
	editdmap_dlg[116].flags = (DMaps[index].flags& dmfWHIRLWINDRET)? D_SELECTED : 0;
	editdmap_dlg[117].flags = (DMaps[index].flags& dmfALWAYSMSG) ? D_SELECTED : 0;
	editdmap_dlg[118].flags = (DMaps[index].flags& dmfVIEWMAP) ? D_SELECTED : 0;
	editdmap_dlg[119].flags = (DMaps[index].flags& dmfDMAPMAP) ? D_SELECTED : 0;
	editdmap_dlg[120].flags = (DMaps[index].flags& dmfMINIMAPCOLORFIX) ? D_SELECTED : 0;
	
	editdmap_dlg[121].flags = (DMaps[index].flags& dmfSCRIPT1) ? D_SELECTED : 0;
	editdmap_dlg[122].flags = (DMaps[index].flags& dmfSCRIPT2) ? D_SELECTED : 0;
	editdmap_dlg[123].flags = (DMaps[index].flags& dmfSCRIPT3) ? D_SELECTED : 0;
	editdmap_dlg[124].flags = (DMaps[index].flags& dmfSCRIPT4) ? D_SELECTED : 0;
	editdmap_dlg[125].flags = (DMaps[index].flags& dmfSCRIPT5) ? D_SELECTED : 0;
	editdmap_dlg[127].flags = (DMaps[index].sideview) ? D_SELECTED : 0;
	editdmap_dlg[128].flags = (DMaps[index].flags& dmfLAYER3BG) ? D_SELECTED : 0;
	editdmap_dlg[129].flags = (DMaps[index].flags& dmfLAYER2BG) ? D_SELECTED : 0;
	
	editdmap_dlg[168].flags = (DMaps[index].flags& dmfNEWCELLARENEMIES)? D_SELECTED : 0;
	editdmap_dlg[211].flags = (DMaps[index].flags& dmfBUNNYIFNOPEARL) ? D_SELECTED : 0;
	editdmap_dlg[212].flags = (DMaps[index].flags& dmfMIRRORCONTINUE) ? D_SELECTED : 0;
	
	if(is_large)
	{
		if(!editdmap_dlg[0].d1)
		{
			xmapspecs[2]=int32_t(xmapspecs[2]*1.5);
			xmapspecs[3]=int32_t(xmapspecs[3]*1.5);
			editdmap_dlg[7].x+=4;
			editdmap_dlg[13].x+=4;
			editdmap_dlg[26].y-=12;
			editdmap_dlg[27].y-=12;
			editdmap_dlg[59].x+=10;
			editdmap_dlg[61].x+=10;
			editdmap_dlg[213].x+=10;
		}
		
		large_dialog(editdmap_dlg);
		xy[0]=editdmap_dlg[20].x;
		xy[1]=editdmap_dlg[20].y;
		int32_t dest[6] = { 11, 17, 14, 8, 67, 70 };
		int32_t src[6] = { 12, 12, 9, 9, 68, 71 };
		
		for(int32_t i=0; i<6; i++)
		{
			editdmap_dlg[dest[i]].w = editdmap_dlg[src[i]].w+4;
			editdmap_dlg[dest[i]].h = editdmap_dlg[src[i]].h+4;
			editdmap_dlg[dest[i]].x = editdmap_dlg[src[i]].x-2;
			editdmap_dlg[dest[i]].y = editdmap_dlg[src[i]].y-2;
		}
	}
	
	int32_t ret=-1;
	
	while(ret!=0&&ret!=1&&ret!=2)
	{
		ret=zc_popup_dialog(editdmap_dlg,-1);
		
		switch(ret)
		{
		case 90:											  //grab a filename for tracker music
		{
			if(getname("Load DMap Music",(char*)zcmusic_types,NULL,tmusicpath,false))
			{
				strcpy(tmusicpath,temppath);
				tmfname=get_filename(tmusicpath);
				
				if(strlen(tmfname)>55)
				{
					jwin_alert("Error","Filename too long","(>55 characters",NULL,"O&K",NULL,'k',0,lfont);
					temppath[0]=0;
				}
				else
				{
					sprintf(tmusicstr,"%s",tmfname);
					editdmap_dlg[87].dp=tmusicstr;
					dmap_tracks=0;
					tempdmapzcmusic = zcmusic_load_for_quest(tmusicstr, filepath);
					
					if(tempdmapzcmusic!=NULL)
					{
						dmap_tracks=zcmusic_get_tracks(tempdmapzcmusic);
						dmap_tracks=(dmap_tracks<2)?0:dmap_tracks;
					}
					
					zcmusic_unload_file(tempdmapzcmusic);
					editdmap_dlg[89].flags=(dmap_tracks<2)?D_DISABLED:0;
					editdmap_dlg[89].d1=0;
				}
			}
		}
		break;
		
		case 91:											  //clear tracker music
			memset(tmusicstr, 0, 56);
			editdmap_dlg[89].flags=D_DISABLED;
			editdmap_dlg[89].d1=0;
			break;
			
		case 104: 											// item disable "->"
			deleteDI(editdmap_dlg[101].d1, index);
			break;
			
		case 105: 											// item disable "<-"
		{
			// 101 is the disabled list, 102 the item list
			insertDI(editdmap_dlg[102].d1, index);
		}
		break;
		}
	}
	
	if(ret==1)
	{
		saved=false;
		sprintf(DMaps[index].name,"%s",dmap_name);
		DMaps[index].minimap_1_tile = editdmap_dlg[9].d1;
		DMaps[index].minimap_1_cset = editdmap_dlg[9].fg;
		DMaps[index].largemap_1_tile = editdmap_dlg[12].d1;
		DMaps[index].largemap_1_cset = editdmap_dlg[12].fg;
		DMaps[index].minimap_2_tile = editdmap_dlg[15].d1;
		DMaps[index].minimap_2_cset = editdmap_dlg[15].fg;
		DMaps[index].largemap_2_tile = editdmap_dlg[18].d1;
		DMaps[index].largemap_2_cset = editdmap_dlg[18].fg;
		DMaps[index].map = (editdmap_dlg[20].d1>(map_count-1))?0:editdmap_dlg[20].d1;
		DMaps[index].xoff = xmapspecs[1];
		DMaps[index].type=editdmap_dlg[23].d1|((editdmap_dlg[63].flags & D_SELECTED)?dmfCONTINUE:0);
		
		if((DMaps[index].type & dmfTYPE) == dmOVERW)
			DMaps[index].xoff = 0;
			
		DMaps[index].level=vbound(atoi(levelstr),0,MAXLEVELS-1);
		
		for(int32_t i=0; i<8; i++)
		{
			for(int32_t j=0; j<8; j++)
			{
				set_bit((byte *)(DMaps[index].grid+i),7-j,get_bit(gridstring,8*i+j));
			}
		}
		
		DMaps[index].compass = zc_xtoi(compassstr);
		DMaps[index].cont = vbound(zc_xtoi(contstr), -DMaps[index].xoff, 0x7F-DMaps[index].xoff);
		DMaps[index].mirrorDMap = vbound(atoi(mirrordmapstr), -1, 511);
		DMaps[index].color = editdmap_dlg[65].d1;
		DMaps[index].active_subscreen=editdmap_dlg[75].d1;
		DMaps[index].passive_subscreen=editdmap_dlg[77].d1;
		DMaps[index].midi = editdmap_dlg[83].d1;
		sprintf(DMaps[index].tmusic, "%s", tmusicstr);
		sprintf(DMaps[index].title,"%s",dmap_title);
		sprintf(DMaps[index].intro,"%s",dmap_intro);
		DMaps[index].tmusictrack = editdmap_dlg[89].d1;
		
		int32_t f=0;
		f |= editdmap_dlg[110].flags & D_SELECTED ? dmfCAVES:0;
		f |= editdmap_dlg[111].flags & D_SELECTED ? dmf3STAIR:0;
		f |= editdmap_dlg[112].flags & D_SELECTED ? dmfWHIRLWIND:0;
		f |= editdmap_dlg[113].flags & D_SELECTED ? dmfGUYCAVES:0;
		f |= editdmap_dlg[114].flags & D_SELECTED ? dmfNOCOMPASS:0;
		f |= editdmap_dlg[115].flags & D_SELECTED ? dmfWAVY:0;
		f |= editdmap_dlg[116].flags & D_SELECTED ? dmfWHIRLWINDRET:0;
		f |= editdmap_dlg[117].flags & D_SELECTED ? dmfALWAYSMSG:0;
		f |= editdmap_dlg[118].flags & D_SELECTED ? dmfVIEWMAP:0;
		f |= editdmap_dlg[119].flags & D_SELECTED ? dmfDMAPMAP:0;
		f |= editdmap_dlg[120].flags & D_SELECTED ? dmfMINIMAPCOLORFIX:0;
		
		f |= editdmap_dlg[121].flags & D_SELECTED ? dmfSCRIPT1:0;
		f |= editdmap_dlg[122].flags & D_SELECTED ? dmfSCRIPT2:0;
		f |= editdmap_dlg[123].flags & D_SELECTED ? dmfSCRIPT3:0;
		f |= editdmap_dlg[124].flags & D_SELECTED ? dmfSCRIPT4:0;
		f |= editdmap_dlg[125].flags & D_SELECTED ? dmfSCRIPT5:0;
		f |= editdmap_dlg[128].flags & D_SELECTED ? dmfLAYER3BG:0;
		f |= editdmap_dlg[129].flags & D_SELECTED ? dmfLAYER2BG:0;
		f |= editdmap_dlg[168].flags & D_SELECTED ? dmfNEWCELLARENEMIES:0;
		f |= editdmap_dlg[211].flags & D_SELECTED ? dmfBUNNYIFNOPEARL:0;
		f |= editdmap_dlg[212].flags & D_SELECTED ? dmfMIRRORCONTINUE:0;
		DMaps[index].flags = f;
	
		DMaps[index].sideview = editdmap_dlg[127].flags & D_SELECTED ? 1:0;
		DMaps[index].script = bidmaps[editdmap_dlg[147].d1].second + 1;
		DMaps[index].active_sub_script = bidmaps[editdmap_dlg[165].d1].second + 1;
		DMaps[index].passive_sub_script = bidmaps[editdmap_dlg[167].d1].second + 1;
		DMaps[index].onmap_script = bidmaps[editdmap_dlg[186].d1].second + 1;
		
		//for ( int32_t q = 0; q < 8; ++q )
		//{
		//	strcpy(initd_labels[q], editdmap_dlg[130+q].dp);
		//}
		
		for ( int32_t q = 0; q < 8; q++ )
		{
			DMaps[index].initD[q] = editdmap_dlg[138+q].fg;
			DMaps[index].sub_initD[q] = editdmap_dlg[156+q].fg;
			DMaps[index].onmap_initD[q] = editdmap_dlg[177+q].fg;
			////initd_labels
			sprintf(DMaps[index].initD_label[q],"%s",initd_labels[q]);
			sprintf(DMaps[index].sub_initD_label[q],"%s",sub_initd_labels[q]);
			sprintf(DMaps[index].onmap_initD_label[q],"%s",onmap_initd_labels[q]);
			//strcpy(DMaps[index].initD_label[q], initd_labels[q]);
			//vbound(atoi(initdvals[q])*10000,-2147483647, 2147483647);
		}
	}
}

//int32_t selectdmapxy[6] = {90,142,164,150,164,160};
int32_t selectdmapxy[6] = {44,92,128,100,128,110};

static ListData dmap_list(dmaplist, &font);

static DIALOG selectdmap_dlg[] =
{
    /* (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp) */
    { jwin_win_proc,   72-44,   56-30,   176+88+1,  120+74+1,  vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "Select DMap", NULL, NULL },
    { d_timer_proc,        0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { d_dmaplist_proc,    46,   50,   64+72+88+1,   60+24+1+2,   jwin_pal[jcTEXTFG], jwin_pal[jcTEXTBG],  0,       D_EXIT,     0,             0, (void *) &dmap_list, NULL, selectdmapxy },
    { jwin_button_proc,   90,   152+44,  61,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "Edit", NULL, NULL },
    { jwin_button_proc,  170,  152+44,  61,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Done", NULL, NULL },
    { d_keyboard_proc,     0,    0,    0,    0,    0,       0,      0,       0,          0,             KEY_DEL, (void *) close_dlg, NULL, NULL },
    { d_keyboard_proc,     0,    0,    0,    0,    0,       0,      0,       0,          0,             KEY_C, (void*)close_dlg, NULL, NULL },
    { d_keyboard_proc,     0,    0,    0,    0,    0,       0,      0,       0,          0,             KEY_V, (void*)close_dlg, NULL, NULL },
    { NULL,                0,    0,    0,    0,    0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

static dmap copiedDMap;
static byte dmapcopied = 0;

int32_t writesomedmaps(PACKFILE *f, int32_t first, int32_t last, int32_t max)
{
    
    dword section_version=V_DMAPS;
    dword section_cversion=CV_DMAPS;
	int32_t zversion = ZELDA_VERSION;
	int32_t zbuild = VERSION_BUILD;
	
	if(!p_iputl(V_ZDMAP,f))
	{
		return 0;
	}
  
    //section version info
	if(!p_iputl(zversion,f))
	{
		return 0;
	}
	if(!p_iputl(zbuild,f))
	{
		return 0;
	}
	if(!p_iputw(section_version,f))
	{
		new_return(2);
	}
    
	if(!p_iputw(section_cversion,f))
	{
		new_return(3);
	}
	//max possible at this time
	if(!p_iputl(max,f))
	{
		new_return(4);
	}
	//first id written
	if(!p_iputl(first,f))
	{
		new_return(5);
	}
	//last id written
	if(!p_iputl(last,f))
	{
		new_return(6);
	}
	int32_t count = last-first;
	//number written
	if(!p_iputl(count,f))
	{
		new_return(7);
	}
	
   
        for ( int32_t i = first; i <= last; ++i )
	{
		if ( i > max ) break;
	
            if(!p_putc(DMaps[i].map,f))
            {
                new_return(8);
            }
            
            if(!p_iputw(DMaps[i].level,f))
            {
                new_return(9);
            }
            
            if(!p_putc(DMaps[i].xoff,f))
            {
                new_return(10);
            }
            
            if(!p_putc(DMaps[i].compass,f))
            {
                new_return(11);
            }
            
            if(!p_iputw(DMaps[i].color,f))
            {
                new_return(12);
            }
            
            if(!p_putc(DMaps[i].midi,f))
            {
                new_return(13);
            }
            
            if(!p_putc(DMaps[i].cont,f))
            {
                new_return(14);
            }
            
            if(!p_putc(DMaps[i].type,f))
            {
                new_return(15);
            }
            
            for(int32_t j=0; j<8; j++)
            {
                if(!p_putc(DMaps[i].grid[j],f))
                {
                    new_return(16);
                }
            }
            
            //16
            if(!pfwrite(&DMaps[i].name,sizeof(DMaps[0].name),f))
            {
                new_return(17);
            }
            
            if(!pfwrite(&DMaps[i].title,sizeof(DMaps[0].title),f))
            {
                new_return(18);
            }
            
            if(!pfwrite(&DMaps[i].intro,sizeof(DMaps[0].intro),f))
            {
                new_return(19);
            }
            
            if(!p_iputl(DMaps[i].minimap_1_tile,f))
            {
                new_return(20);
            }
            
            if(!p_putc(DMaps[i].minimap_1_cset,f))
            {
                new_return(21);
            }
            
            if(!p_iputl(DMaps[i].minimap_2_tile,f))
            {
                new_return(22);
            }
            
            if(!p_putc(DMaps[i].minimap_2_cset,f))
            {
                new_return(23);
            }
            
            if(!p_iputl(DMaps[i].largemap_1_tile,f))
            {
                new_return(24);
            }
            
            if(!p_putc(DMaps[i].largemap_1_cset,f))
            {
                new_return(25);
            }
            
            if(!p_iputl(DMaps[i].largemap_2_tile,f))
            {
                new_return(26);
            }
            
            if(!p_putc(DMaps[i].largemap_2_cset,f))
            {
                new_return(27);
            }
            
            if(!pfwrite(&DMaps[i].tmusic,sizeof(DMaps[0].tmusic),f))
            {
                new_return(28);
            }
            
            if(!p_putc(DMaps[i].tmusictrack,f))
            {
                new_return(29);
            }
            
            if(!p_putc(DMaps[i].active_subscreen,f))
            {
                new_return(30);
            }
            
            if(!p_putc(DMaps[i].passive_subscreen,f))
            {
                new_return(31);
            }
            
            byte disabled[32];
            memset(disabled,0,32);
            
            for(int32_t j=0; j<MAXITEMS; j++)
            {
                if(DMaps[i].disableditems[j])
                {
                    disabled[j/8] |= (1 << (j%8));
                }
            }
            
            if(!pfwrite(disabled,32,f))
            {
                new_return(32);
            }
            
            if(!p_iputl(DMaps[i].flags,f))
            {
                new_return(33);
            }
	    if(!p_putc(DMaps[i].sideview,f))
            {
                new_return(30);
            }
	    if(!p_iputw(DMaps[i].script,f))
            {
                new_return(31);
            }
	    for ( int32_t q = 0; q < 8; q++ )
	    {
		if(!p_iputl(DMaps[i].initD[q],f))
	        {
			new_return(32);
		}
		    
	    }
	    for ( int32_t q = 0; q < 8; q++ )
	    {
		    for ( int32_t w = 0; w < 65; w++ )
		    {
			if (!p_putc(DMaps[i].initD_label[q][w],f))
			{
				new_return(33);
			}
		}
	    }
		if(!p_iputw(DMaps[i].active_sub_script,f))
		{
			new_return(34);
		}
		if(!p_iputw(DMaps[i].passive_sub_script,f))
		{
			new_return(35);
		}
		for(int32_t q = 0; q < 8; ++q)
		{
			if(!p_iputl(DMaps[i].sub_initD[q],f))
			{
				new_return(36);
			}
		}
		for(int32_t q = 0; q < 8; ++q)
		{
			for(int32_t w = 0; w < 65; ++w)
			{
				if(!p_putc(DMaps[i].sub_initD_label[q][w],f))
				{
					new_return(37);
				}
			}
		}
		if(!p_iputw(DMaps[i].onmap_script,f))
		{
			new_return(35);
		}
		for(int32_t q = 0; q < 8; ++q)
		{
			if(!p_iputl(DMaps[i].onmap_initD[q],f))
			{
				new_return(36);
			}
		}
		for(int32_t q = 0; q < 8; ++q)
		{
			for(int32_t w = 0; w < 65; ++w)
			{
				if(!p_putc(DMaps[i].onmap_initD_label[q][w],f))
				{
					new_return(37);
				}
			}
		}
	}

	return 1;
}


int32_t readsomedmaps(PACKFILE *f)
{
	dword section_version = 0;
	dword section_cversion = 0;
	int32_t zversion = 0;
	int32_t zbuild = 0;
	dmap tempdmap;
	memset(&tempdmap, 0, sizeof(dmap));
	
	int32_t first = 0, last = 0, max = 0, count = 0;
	int32_t datatype_version = 0;
   
	//char dmapstring[64]={0};
	//section version info
	if(!p_igetl(&datatype_version,f,true))
	{
		return 0;
	}
	if ( datatype_version < 0 )
	{
		if(!p_igetl(&zversion,f,true))
		{
			return 0;
		}
	}
	else
	{
		zversion = datatype_version;
	}
	if(!p_igetl(&zbuild,f,true))
	{
		return 0;
	}
	
	if(!p_igetw(&section_version,f,true))
	{
		return 0;
	}
    
	if(!p_igetw(&section_cversion,f,true))
	{
		return 0;
	}
	if ( datatype_version < 0 )
	{
		if(!p_igetl(&max,f,true))
		{
			return 0;
		}
		if(!p_igetl(&first,f,true))
		{
			return 0;
		}
		if(!p_igetl(&last,f,true))
		{
			return 0;
		}
		if(!p_igetl(&count,f,true))
		{
			return 0;
		} 
	}
	else
	{
		first = 0;
		last = 0;
		count = 1;
		max = 255;
	}
	
	
	
	
	al_trace("readsomedmaps section_version: %d\n", section_version);
	al_trace("readsomedmaps section_cversion: %d\n", section_cversion);
    
	if ( zversion > ZELDA_VERSION )
	{
		al_trace("Cannot read .zdmap packfile made in ZC version (%x) in this version of ZC (%x)\n", zversion, ZELDA_VERSION);
		return 0;
	}
	else if (( section_version > V_DMAPS ) || ( section_version == V_DMAPS && section_cversion > CV_DMAPS ) ) 
	{
		al_trace("Cannot read .zdmap packfile made using V_DMAPS (%d) subversion (%d)\n", section_version, section_cversion);
		return 0;
	}
	else
	{
		al_trace("Reading a .zdmap packfile made in ZC Version: %x, Build: %d\n", zversion, zbuild);
	}
	//if(!pfread(&dmapstring, 64, f,true))
	//{
	//	return 0;
	//}
    
    
   
		for ( int32_t i = first; i <= last; ++i )
		{
		    if(!p_getc(&tempdmap.map,f,true))
		    {
			return 0;
		    }
		    
		    if(!p_igetw(&tempdmap.level,f,true))
		    {
			return 0;
		    }
		    
		    if(!p_getc(&tempdmap.xoff,f,true))
		    {
			return 0;
		    }
		    
		    if(!p_getc(&tempdmap.compass,f,true))
		    {
			return 0;
		    }
		    
		    if(!p_igetw(&tempdmap.color,f,true))
		    {
			return 0;
		    }
		    
		    if(!p_getc(&tempdmap.midi,f,true))
		    {
			return 0;
		    }
		    
		    if(!p_getc(&tempdmap.cont,f,true))
		    {
			return 0;
		    }
		    
		    if(!p_getc(&tempdmap.type,f,true))
		    {
			return 0;
		    }
		    
		    for(int32_t j=0; j<8; j++)
		    {
			if(!p_getc(&tempdmap.grid[j],f,true))
			{
			    return 0;
			}
		    }
		    
		    //16
		    if(!pfread(&tempdmap.name,sizeof(DMaps[0].name),f,true))
		    {
			return 0;
		    }
		    
		    if(!pfread(&tempdmap.title,sizeof(DMaps[0].title),f,true))
		    {
			return 0;
		    }
		    
		    if(!pfread(&tempdmap.intro,sizeof(DMaps[0].intro),f,true))
		    {
			return 0;
		    }
		    
		    if(!p_igetl(&tempdmap.minimap_1_tile,f,true))
		    {
			return 0;
		    }
		    
		    if(!p_getc(&tempdmap.minimap_1_cset,f,true))
		    {
			return 0;
		    }
		    
		    if(!p_igetl(&tempdmap.minimap_2_tile,f,true))
		    {
			return 0;
		    }
		    
		    if(!p_getc(&tempdmap.minimap_2_cset,f,true))
		    {
			return 0;
		    }
		    
		    if(!p_igetl(&tempdmap.largemap_1_tile,f,true))
		    {
			return 0;
		    }
		    
		    if(!p_getc(&tempdmap.largemap_1_cset,f,true))
		    {
			return 0;
		    }
		    
		    if(!p_igetl(&tempdmap.largemap_2_tile,f,true))
		    {
			return 0;
		    }
		    
		    if(!p_getc(&tempdmap.largemap_2_cset,f,true))
		    {
			return 0;
		    }
		    
		    if(!pfread(&tempdmap.tmusic,sizeof(DMaps[0].tmusic),f,true))
		    {
			return 0;
		    }
		    
		    if(!p_getc(&tempdmap.tmusictrack,f,true))
		    {
			return 0;
		    }
		    
		    if(!p_getc(&tempdmap.active_subscreen,f,true))
		    {
			return 0;
		    }
		    
		    if(!p_getc(&tempdmap.passive_subscreen,f,true))
		    {
			return 0;
		    }
		    
		    byte disabled[32];
		    memset(disabled,0,32);
		    
		    if(!pfread(&disabled, 32, f, true)) return 0;
		    
		    for(int32_t j=0; j<MAXITEMS; j++)
		    {
			if(disabled[j/8] & (1 << (j%8))) tempdmap.disableditems[j]=1;
			else tempdmap.disableditems[j]=0;
		    }
		    
		    
		    if(!p_igetl(&tempdmap.flags,f,true))
		    {
			return 0;
		    }
			if ( zversion >= 0x255 )
			{
				if  ( section_version >= 14 )
				{
				    //2.55 starts here
				    if(!p_getc(&tempdmap.sideview,f,true))
				    {
					return 0;
				    }
				    if(!p_igetw(&tempdmap.script,f,true))
				    {
					return 0;
				    }
				    for ( int32_t q = 0; q < 8; q++ )
				    {
					if(!p_igetl(&tempdmap.initD[q],f,true))
					{
						return 0;
				    }
					    
				    }
				    for ( int32_t q = 0; q < 8; q++ )
				    {
					    for ( int32_t w = 0; w < 65; w++ )
					    {
						if (!p_getc(&tempdmap.initD_label[q][w],f,true))
						{
							return 0;
						}
					}
				    }
					if(!p_igetw(&tempdmap.active_sub_script,f,true))
					{
						return 0;
					}
					if(!p_igetw(&tempdmap.passive_sub_script,f,true))
					{
						return 0;
					}
					for(int32_t q = 0; q < 8; ++q)
					{
						if(!p_igetl(&tempdmap.sub_initD[q],f,true))
						{
							return 0;
						}
					}	
					for(int32_t q = 0; q < 8; ++q)
					{
						for(int32_t w = 0; w < 65; ++w)
						{
							if(!p_getc(&tempdmap.sub_initD_label[q][w],f,true))
							{
								return 0;
							}
						}
					}
					if(!p_igetw(&tempdmap.onmap_script,f,true))
					{
						return 0;
					}
					for(int32_t q = 0; q < 8; ++q)
					{
						if(!p_igetl(&tempdmap.onmap_initD[q],f,true))
						{
							return 0;
						}
					}	
					for(int32_t q = 0; q < 8; ++q)
					{
						for(int32_t w = 0; w < 65; ++w)
						{
							if(!p_getc(&tempdmap.onmap_initD_label[q][w],f,true))
							{
								return 0;
							}
						}
					}
				}
			}
		::memcpy(&DMaps[i], &tempdmap, sizeof(dmap));
	    }
       
	return 1;
}



int32_t writeonedmap(PACKFILE *f, int32_t i)
{
    
    dword section_version=V_DMAPS;
    dword section_cversion=CV_DMAPS;
	int32_t zversion = ZELDA_VERSION;
	int32_t zbuild = VERSION_BUILD;
	
  
    //section version info
	if(!p_iputl(V_ZDMAP,f))
	{
		return 0;
	}
	if(!p_iputl(zversion,f))
	{
		return 0;
	}
	if(!p_iputl(zbuild,f))
	{
		return 0;
	}
	if(!p_iputw(section_version,f))
	{
		new_return(2);
	}
    
	if(!p_iputw(section_cversion,f))
	{
		new_return(3);
	}
    
   
        
            if(!p_putc(DMaps[i].map,f))
            {
                new_return(6);
            }
            
            if(!p_iputw(DMaps[i].level,f))
            {
                new_return(7);
            }
            
            if(!p_putc(DMaps[i].xoff,f))
            {
                new_return(8);
            }
            
            if(!p_putc(DMaps[i].compass,f))
            {
                new_return(9);
            }
            
            if(!p_iputw(DMaps[i].color,f))
            {
                new_return(10);
            }
            
            if(!p_putc(DMaps[i].midi,f))
            {
                new_return(11);
            }
            
            if(!p_putc(DMaps[i].cont,f))
            {
                new_return(12);
            }
            
            if(!p_putc(DMaps[i].type,f))
            {
                new_return(13);
            }
            
            for(int32_t j=0; j<8; j++)
            {
                if(!p_putc(DMaps[i].grid[j],f))
                {
                    new_return(14);
                }
            }
            
            //16
            if(!pfwrite(&DMaps[i].name,sizeof(DMaps[0].name),f))
            {
                new_return(15);
            }
            
            if(!pfwrite(&DMaps[i].title,sizeof(DMaps[0].title),f))
            {
                new_return(16);
            }
            
            if(!pfwrite(&DMaps[i].intro,sizeof(DMaps[0].intro),f))
            {
                new_return(17);
            }
            
            if(!p_iputl(DMaps[i].minimap_1_tile,f))
            {
                new_return(18);
            }
            
            if(!p_putc(DMaps[i].minimap_1_cset,f))
            {
                new_return(19);
            }
            
            if(!p_iputl(DMaps[i].minimap_2_tile,f))
            {
                new_return(20);
            }
            
            if(!p_putc(DMaps[i].minimap_2_cset,f))
            {
                new_return(21);
            }
            
            if(!p_iputl(DMaps[i].largemap_1_tile,f))
            {
                new_return(22);
            }
            
            if(!p_putc(DMaps[i].largemap_1_cset,f))
            {
                new_return(23);
            }
            
            if(!p_iputl(DMaps[i].largemap_2_tile,f))
            {
                new_return(24);
            }
            
            if(!p_putc(DMaps[i].largemap_2_cset,f))
            {
                new_return(25);
            }
            
            if(!pfwrite(&DMaps[i].tmusic,sizeof(DMaps[0].tmusic),f))
            {
                new_return(26);
            }
            
            if(!p_putc(DMaps[i].tmusictrack,f))
            {
                new_return(25);
            }
            
            if(!p_putc(DMaps[i].active_subscreen,f))
            {
                new_return(26);
            }
            
            if(!p_putc(DMaps[i].passive_subscreen,f))
            {
                new_return(27);
            }
            
            byte disabled[32];
            memset(disabled,0,32);
            
            for(int32_t j=0; j<MAXITEMS; j++)
            {
                if(DMaps[i].disableditems[j])
                {
                    disabled[j/8] |= (1 << (j%8));
                }
            }
            
            if(!pfwrite(disabled,32,f))
            {
                new_return(28);
            }
            
            if(!p_iputl(DMaps[i].flags,f))
            {
                new_return(29);
            }
	    if(!p_putc(DMaps[i].sideview,f))
            {
                new_return(30);
            }
	    if(!p_iputw(DMaps[i].script,f))
            {
                new_return(31);
            }
	    for ( int32_t q = 0; q < 8; q++ )
	    {
		if(!p_iputl(DMaps[i].initD[q],f))
	        {
			new_return(32);
		}
		    
	    }
	    for ( int32_t q = 0; q < 8; q++ )
	    {
		    for ( int32_t w = 0; w < 65; w++ )
		    {
			if (!p_putc(DMaps[i].initD_label[q][w],f))
			{
				new_return(33);
			}
		}
	    }
		if(!p_iputw(DMaps[i].active_sub_script,f))
		{
			new_return(34);
		}
		if(!p_iputw(DMaps[i].passive_sub_script,f))
		{
			new_return(35);
		}
		for(int32_t q = 0; q < 8; ++q)
		{
			if(!p_iputl(DMaps[i].sub_initD[q],f))
			{
				new_return(36);
			}
		}
		for(int32_t q = 0; q < 8; ++q)
		{
			for(int32_t w = 0; w < 65; ++w)
			{
				if(!p_putc(DMaps[i].sub_initD_label[q][w],f))
				{
					new_return(37);
				}
			}
		}
		if(!p_iputw(DMaps[i].onmap_script,f))
		{
			new_return(35);
		}
		for(int32_t q = 0; q < 8; ++q)
		{
			if(!p_iputl(DMaps[i].onmap_initD[q],f))
			{
				new_return(36);
			}
		}
		for(int32_t q = 0; q < 8; ++q)
		{
			for(int32_t w = 0; w < 65; ++w)
			{
				if(!p_putc(DMaps[i].onmap_initD_label[q][w],f))
				{
					new_return(37);
				}
			}
		}
	    

	return 1;
}


int32_t readonedmap(PACKFILE *f, int32_t index)
{
	dword section_version = 0;
	dword section_cversion = 0;
	int32_t zversion = 0;
	int32_t zbuild = 0;
	dmap tempdmap;
	memset(&tempdmap, 0, sizeof(dmap));
	int32_t datatype_version = 0;
	int32_t first = 0;
	int32_t last = 0;
	int32_t max = 0;
	int32_t count = 0;
   
	//char dmapstring[64]={0};
	//section version info
	if(!p_igetl(&datatype_version,f,true))
	{
		return 0;
	}
	if ( datatype_version < 0 )
	{
		if(!p_igetl(&zversion,f,true))
		{
			return 0;
		}
	}
	else
	{
		zversion = datatype_version;
	}
	if(!p_igetl(&zbuild,f,true))
	{
		return 0;
	}
	
	if(!p_igetw(&section_version,f,true))
	{
		return 0;
	}
    
	if(!p_igetw(&section_cversion,f,true))
	{
		return 0;
	}
	al_trace("readonedmap section_version: %d\n", section_version);
	al_trace("readonedmap section_cversion: %d\n", section_cversion);
    
	
	if ( datatype_version < 0 )
	{
		if(!p_igetl(&max,f,true))
		{
			return 0;
		}
		if(!p_igetl(&first,f,true))
		{
			return 0;
		}
		if(!p_igetl(&last,f,true))
		{
			return 0;
		}
		if(!p_igetl(&count,f,true))
		{
			return 0;
		}
	}
	if ( zversion > ZELDA_VERSION )
	{
		al_trace("Cannot read .zdmap packfile made in ZC version (%x) in this version of ZC (%x)\n", zversion, ZELDA_VERSION);
		return 0;
	}
	else if (( section_version > V_DMAPS ) || ( section_version == V_DMAPS && section_cversion > CV_DMAPS ) ) 
	{
		al_trace("Cannot read .zdmap packfile made using V_DMAPS (%d) subversion (%d)\n", section_version, section_cversion);
		return 0;
	}
	else
	{
		al_trace("Reading a .zdmap packfile made in ZC Version: %x, Build: %d\n", zversion, zbuild);
	}
	//if(!pfread(&dmapstring, 64, f,true))
	//{
	//	return 0;
	//}
    
    
   
        
            if(!p_getc(&tempdmap.map,f,true))
            {
                return 0;
            }
            
            if(!p_igetw(&tempdmap.level,f,true))
            {
                return 0;
            }
            
            if(!p_getc(&tempdmap.xoff,f,true))
            {
                return 0;
            }
            
            if(!p_getc(&tempdmap.compass,f,true))
            {
                return 0;
            }
            
            if(!p_igetw(&tempdmap.color,f,true))
            {
                return 0;
            }
            
            if(!p_getc(&tempdmap.midi,f,true))
            {
                return 0;
            }
            
            if(!p_getc(&tempdmap.cont,f,true))
            {
                return 0;
            }
            
            if(!p_getc(&tempdmap.type,f,true))
            {
                return 0;
            }
            
            for(int32_t j=0; j<8; j++)
            {
                if(!p_getc(&tempdmap.grid[j],f,true))
                {
                    return 0;
		}
            }
            
            //16
            if(!pfread(&tempdmap.name,sizeof(DMaps[0].name),f,true))
            {
                return 0;
            }
            
            if(!pfread(&tempdmap.title,sizeof(DMaps[0].title),f,true))
            {
                return 0;
            }
            
            if(!pfread(&tempdmap.intro,sizeof(DMaps[0].intro),f,true))
            {
                return 0;
            }
            
            if(!p_igetl(&tempdmap.minimap_1_tile,f,true))
            {
                return 0;
            }
            
            if(!p_getc(&tempdmap.minimap_1_cset,f,true))
            {
                return 0;
            }
            
            if(!p_igetl(&tempdmap.minimap_2_tile,f,true))
            {
                return 0;
            }
            
            if(!p_getc(&tempdmap.minimap_2_cset,f,true))
            {
                return 0;
            }
            
            if(!p_igetl(&tempdmap.largemap_1_tile,f,true))
            {
                return 0;
            }
            
            if(!p_getc(&tempdmap.largemap_1_cset,f,true))
            {
                return 0;
            }
            
            if(!p_igetl(&tempdmap.largemap_2_tile,f,true))
            {
                return 0;
            }
            
            if(!p_getc(&tempdmap.largemap_2_cset,f,true))
            {
                return 0;
            }
            
            if(!pfread(&tempdmap.tmusic,sizeof(DMaps[0].tmusic),f,true))
            {
                return 0;
            }
            
            if(!p_getc(&tempdmap.tmusictrack,f,true))
            {
                return 0;
            }
            
            if(!p_getc(&tempdmap.active_subscreen,f,true))
            {
                return 0;
            }
            
            if(!p_getc(&tempdmap.passive_subscreen,f,true))
            {
                return 0;
            }
            
            byte disabled[32];
	    memset(disabled,0,32);
            
            if(!pfread(&disabled, 32, f, true)) return 0;
            
            for(int32_t j=0; j<MAXITEMS; j++)
            {
                if(disabled[j/8] & (1 << (j%8))) tempdmap.disableditems[j]=1;
                else tempdmap.disableditems[j]=0;
            }
	    
            
            if(!p_igetl(&tempdmap.flags,f,true))
            {
                return 0;
            }
		if ( zversion >= 0x255 )
		{
			if  ( section_version >= 14 )
			{
			    //2.55 starts here
			    if(!p_getc(&tempdmap.sideview,f,true))
			    {
				return 0;
			    }
			    if(!p_igetw(&tempdmap.script,f,true))
			    {
				return 0;
			    }
			    for ( int32_t q = 0; q < 8; q++ )
			    {
				if(!p_igetl(&tempdmap.initD[q],f,true))
				{
					return 0;
			    }
				    
			    }
			    for ( int32_t q = 0; q < 8; q++ )
			    {
				    for ( int32_t w = 0; w < 65; w++ )
				    {
					if (!p_getc(&tempdmap.initD_label[q][w],f,true))
					{
						return 0;
					}
				}
			    }
				if(!p_igetw(&tempdmap.active_sub_script,f,true))
				{
					return 0;
				}
				if(!p_igetw(&tempdmap.passive_sub_script,f,true))
				{
					return 0;
				}
				for(int32_t q = 0; q < 8; ++q)
				{
					if(!p_igetl(&tempdmap.sub_initD[q],f,true))
					{
						return 0;
					}
				}	
				for(int32_t q = 0; q < 8; ++q)
				{
					for(int32_t w = 0; w < 65; ++w)
					{
						if(!p_getc(&tempdmap.sub_initD_label[q][w],f,true))
						{
							return 0;
						}
					}
				}
				if(!p_igetw(&tempdmap.onmap_script,f,true))
				{
					return 0;
				}
				for(int32_t q = 0; q < 8; ++q)
				{
					if(!p_igetl(&tempdmap.onmap_initD[q],f,true))
					{
						return 0;
					}
				}	
				for(int32_t q = 0; q < 8; ++q)
				{
					for(int32_t w = 0; w < 65; ++w)
					{
						if(!p_getc(&tempdmap.onmap_initD_label[q][w],f,true))
						{
							return 0;
						}
					}
				}
			}
		}
	::memcpy(&DMaps[index], &tempdmap, sizeof(dmap));
       
	return 1;
}

static MENU dmap_rclick_menu[] =
{
    { (char *)"Copy",  NULL, NULL, 0, NULL },
    { (char *)"Paste", NULL, NULL, 0, NULL },
    { (char *)"Save", NULL, NULL, 0, NULL },
    { (char *)"Load", NULL, NULL, 0, NULL },
    { NULL,            NULL, NULL, 0, NULL }
};

void dmap_rclick_func(int32_t index, int32_t x, int32_t y)
{
    if(((unsigned)index)>MAXDMAPS)
        return;
    
    if(!dmapcopied)
        dmap_rclick_menu[1].flags|=D_DISABLED;
    else
        dmap_rclick_menu[1].flags&=~D_DISABLED;
    
    int32_t ret=popup_menu(dmap_rclick_menu, x, y);
    
    if(ret==0) // copy
    {
	::memcpy(&copiedDMap, &DMaps[index], sizeof(dmap));
	dmapcopied = 1;
    }
    else if(ret==1) // paste
    {
	::memcpy(&DMaps[index], &copiedDMap, sizeof(dmap));
        selectdmap_dlg[2].flags|=D_DIRTY;
        saved=false;
    }
    else if(ret==2) // save
    {
	if(!getname("Save DMAP(.zdmap)", "zdmap", NULL,datapath,false))
                return;
	
	PACKFILE *f=pack_fopen_password(temppath,F_WRITE, "");
	if(!f) return;
	/*if (!writeoneitem(f,iid))
	{
		al_trace("Could not write to .znpc packfile %s\n", temppath);
	}
	*/
	writesomedmaps(f,index, index, MAXDMAPS);
	pack_fclose(f);
     
        
    }
	else if(ret==3) // load
	{

		if(!getname("Load DMAP(.zdmap)", "zdmap", NULL,datapath,false))
					return;
		PACKFILE *f=pack_fopen_password(temppath,F_READ, "");
		if(!f) return;
		
		if (!readonedmap(f,index))
		{
			al_trace("Could not read from .zdmap packfile %s\n", temppath);
			jwin_alert("ZDMAP File: Error","Could not load the specified DMap.",NULL,NULL,"O&K",NULL,'k',0,lfont);
		}
		
		pack_fclose(f);
		//itemsbuf[bie[index].i]=itemsbuf[copiedItem];
		selectdmap_dlg[2].flags|=D_DIRTY; //Causes the dialogie list to refresh, updating the item name.
		saved=false;
	}
}


int32_t onDmaps()
{
    int32_t ret;
    char buf[40];
    dmapcopied = 0;
    dmap_list_size=MAXDMAPS;
    number_list_zero=true;
    selectdmap_dlg[0].dp2=lfont;
    selectdmap_dlg[2].dp3 = (void *)&dmap_rclick_func;
    selectdmap_dlg[2].flags|=(D_USER<<1);
    
    if(is_large)
        large_dialog(selectdmap_dlg);
    
    
    
    ret=zc_popup_dialog(selectdmap_dlg,2);
    dmap* pSelectedDmap = 0;
    
    
    
    while(ret!=4&&ret!=0)
    {
        int32_t d=selectdmap_dlg[2].d1;
        
        if(ret==6) //copy
		{
			pSelectedDmap = &DMaps[d];
		}
		else if(ret==7 && pSelectedDmap != 0 ) //paste
		{
			if( pSelectedDmap != &DMaps[d] )
			{
				::memcpy(&DMaps[d], pSelectedDmap, sizeof(dmap));
				saved=false;
			}
		}
        else if(ret==5)
        {
            sprintf(buf,"Delete DMap %d?",d);
            
            if(jwin_alert("Confirm Delete",buf,NULL,NULL,"&Yes","&No",'y','n',lfont)==1)
            {
                reset_dmap(d);
                saved=false;
            }
        }
        else
        {
            editdmap(d);
        }
        
        ret=zc_popup_dialog(selectdmap_dlg,2);
    }
    
    return D_O_K;
}

/*******************************/
/**********  onMidis  **********/
/*******************************/

static DIALOG editmidi_dlg[] =
{
    /* (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp) */
    { jwin_win_proc,     24,   20,   273,  189,  vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "MIDI Specs", NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    // 2
    { jwin_text_proc,       56,   94-16,   48,   8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "MIDI:", NULL, NULL },
    { jwin_text_proc,       104,  94-16,   48,   8,    vc(11),  vc(1),  0,       0,          0,             0,       NULL, NULL, NULL },
    { jwin_text_proc,       56,   114,  48,   8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Name:", NULL, NULL },
    { jwin_edit_proc,       104,  114-4,  160,  16,   vc(12),  vc(1),  0,       0,          35,            0,       NULL, NULL, NULL },
    { jwin_text_proc,       56,   124-4+12,  56,   8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Volume:", NULL, NULL },
    { jwin_edit_proc,       120,  124-4+12-4,  32,   16,   vc(12),  vc(1),  0,       0,          3,             0,       NULL, NULL, NULL },
    // 8
    { jwin_check_proc,      176,  124+12-4,  80+1,   8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Loop", NULL, NULL },
    // 9
    { jwin_button_proc,     50,   72-24,   57,   21,   vc(14),  vc(1),  'l',     D_EXIT,     0,             0, (void *) "&Load", NULL, NULL },
    { jwin_button_proc,     116,  72-24,   33,   21,   vc(14),  vc(1),  0,       D_EXIT,     0,             0, (void *) "\x8D", NULL, NULL },
    { jwin_button_proc,     156,  72-24,   33,   21,   vc(14),  vc(1),  0,       D_EXIT,     0,             0, (void *) "\x8B", NULL, NULL },
    { jwin_button_proc,     196,  72-24,   33,   21,   vc(14),  vc(1),  0,       D_EXIT,     0,             0, (void *) "\x8B\x8B", NULL, NULL },
    { jwin_button_proc,     236,  72-24,   33,   21,   vc(14),  vc(1),  0,       D_EXIT,     0,             0, (void *) "\x8B\x8B\x8B", NULL, NULL },
    // 14
    { jwin_text_proc,       56,   134+4+12,  48,   8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Start:", NULL, NULL },
    { jwin_edit_proc,       112,  134+12,  32,   16,   vc(12),  vc(1),  0,       0,          5,             0,       NULL, NULL, NULL },
    { jwin_text_proc,       176,  134+12+4,  56,   8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Loop Start:", NULL, NULL },
    { jwin_edit_proc,       240,  134+12,  40,   16,   vc(12),  vc(1),  0,       0,          5,             0,       NULL, NULL, NULL },
    { jwin_text_proc,       176,  144+12+12,  48,   8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Loop End:", NULL, NULL },
    { jwin_edit_proc,       240,  144+12+12-4,  40,   16,   vc(12),  vc(1),  0,       0,          5,             0,       NULL, NULL, NULL },
    // 20
    { jwin_text_proc,       176,  94-16,   48,   8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Position:", NULL, NULL },
    { jwin_text_proc,       217,  94-16,   32,   8,    vc(11),  vc(1),  0,       0,          0,             0,       NULL, NULL, NULL },
    { jwin_text_proc,       176,  104-8,  48,   8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Length:", NULL, NULL },
    { jwin_text_proc,       216,  104-8,  32,   8,    vc(11),  vc(1),  0,       0,          0,             0,       NULL, NULL, NULL },
    { jwin_text_proc,       56,   104-8,  48,   8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Time:", NULL, NULL },
    { jwin_text_proc,       104,  104-8,  32,   8,    vc(11),  vc(1),  0,       0,          0,             0,       NULL, NULL, NULL },
    // 26
    { jwin_check_proc,      56,   144+12+12,  80+1,   8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Disable Saving", NULL, NULL },
    { jwin_button_proc,     90,   160+12+12,  61,   21,   vc(14),  vc(1),  'k',     D_EXIT,     0,             0, (void *) "O&K", NULL, NULL },
    { jwin_button_proc,     170,  160+12+12,  61,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_F1,   0, (void *) onHelp, NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};


void edit_tune(int32_t i)
{
    // TO DO : adapt for non-midi formats
    int32_t ret,loop,volume;
    byte flags;
    int32_t start,loop_start,loop_end;
    
    char title[36];
    char volume_str[8];
    char start_str[16];
    char loop_start_str[16];
    char loop_end_str[16];
    char len_str[16];
    char pos_str[16];
//  char format_str[8];
//  int32_t format;

    void *data = customtunes[i].data;
    
    if(customtunes[i].format == MFORMAT_MIDI) get_midi_info((MIDI*) data,&Midi_Info);
    
    volume = customtunes[i].volume;
    loop = customtunes[i].loop;
    flags = customtunes[i].flags;
    start = customtunes[i].start;
    loop_start = customtunes[i].loop_start;
    loop_end = customtunes[i].loop_end;
    
    strcpy(title,customtunes[i].title);
    
    editmidi_dlg[0].dp2=lfont;
    
    if(is_large)
    {
        large_dialog(editmidi_dlg);
        editmidi_dlg[13].dp2 = font;
        editmidi_dlg[12].dp2 = font;
        editmidi_dlg[11].dp2 = font;
        editmidi_dlg[10].dp2 = font;
    }
    
    do
    {
        sprintf(volume_str,"%d",volume);
        sprintf(start_str,"%d",start);
        sprintf(loop_start_str,"%d",loop_start);
        sprintf(loop_end_str,"%d",loop_end);
        sprintf(len_str,"%d",Midi_Info.len_beats);
        sprintf(pos_str,"%ld",midi_pos);
        
        editmidi_dlg[3].dp = data?(void *) "Loaded":(void *) "Empty";
        editmidi_dlg[5].dp = title;
        editmidi_dlg[7].dp = volume_str;
        editmidi_dlg[8].flags = loop?D_SELECTED:0;
        editmidi_dlg[10].flags =
            editmidi_dlg[11].flags =
                editmidi_dlg[12].flags =
                    editmidi_dlg[13].flags = (data==NULL)?D_DISABLED:D_EXIT;
        editmidi_dlg[15].dp = start_str;
        editmidi_dlg[17].dp = loop_start_str;
        editmidi_dlg[19].dp = loop_end_str;
        editmidi_dlg[21].dp = pos_str;
        editmidi_dlg[23].dp = len_str;
        editmidi_dlg[25].dp = timestr(Midi_Info.len_sec);
        editmidi_dlg[26].flags = (flags&tfDISABLESAVE)?D_SELECTED:0;
        
        DIALOG_PLAYER *p = init_dialog(editmidi_dlg,-1);
        
        while(update_dialog(p))
        {
            custom_vsync();
            scare_mouse();
            //      text_mode(vc(1));
            textprintf_ex(screen,is_large? lfont_l : font,editmidi_dlg[0].x+int32_t(193*(is_large?1.5:1)),editmidi_dlg[0].y+int32_t(58*(is_large?1.5:1)),jwin_pal[jcBOXFG],jwin_pal[jcBOX],"%-5ld",midi_pos);
            unscare_mouse();
        }
        
        ret = shutdown_dialog(p);
        
        loop = editmidi_dlg[8].flags?1:0;
        volume = vbound(atoi(volume_str),0,255); // Allegro can't play louder than 255.
        
        start = vbound(atol(start_str),0,zc_max(Midi_Info.len_beats-4,0));
        loop_start = vbound(atol(loop_start_str),-1,zc_max(Midi_Info.len_beats-4,-1));
        loop_end = vbound(atol(loop_end_str),-1,Midi_Info.len_beats);
        
        if(loop_end>0)
        {
            loop_end = vbound(loop_end,zc_max(loop_start+4,start+4),Midi_Info.len_beats);
        }
        
        flags = 0;
        flags |= editmidi_dlg[26].flags&D_SELECTED?tfDISABLESAVE:0;
        
        switch(ret)
        {
        case 9:
            if(getname("Load tune","mid;nsf",NULL,temppath,true))
            {
                zc_stop_midi();
                
                if(data!=NULL && data!=customtunes[i].data)
                {
                    destroy_midi((MIDI*)data);
                }

                packfile_password("");

                if((data=load_midi(temppath))==NULL)
                {
                    jwin_alert("Error","Error loading tune:",temppath,NULL,"Dang",NULL,13,27,lfont);
                }
                else
                {
                    char *t = get_filename(temppath);
                    int32_t j;
                    
                    for(j=0; j<35 && t[j]!=0 && t[j]!='.'; j++)
                    {
                        title[j]=t[j];
                    }
                    
                    title[j]=0;
                }
                
                get_midi_info((MIDI*)data,&Midi_Info);
            }
            
            break;
            
        case 10:
            zc_stop_midi();
            break;
            
        case 12:
            if(midi_pos>0)
            {
                int32_t pos=midi_pos;
                zc_stop_midi();
                midi_loop_start = -1;
                midi_loop_end = -1;
                zc_play_midi((MIDI*)data,loop);
                zc_set_volume(-1,volume);
                midi_loop_start = loop_start;
                midi_loop_end = loop_end;
                
                if(midi_loop_end<=0)
                {
                    pos = zc_min(pos+16,Midi_Info.len_beats);
                }
                else
                {
                    pos = zc_min(pos+16,midi_loop_end);
                }
                
                if(pos>0)
                {
                    zc_midi_seek(pos);
                }
                
                break;
            }
            
            // else play it...
            
        case 13:
            if(midi_pos>0)
            {
                int32_t pos=midi_pos;
                zc_stop_midi();
                midi_loop_end = -1;
                midi_loop_start = -1;
                zc_play_midi((MIDI*)data,loop);
                zc_set_volume(-1,volume);
                midi_loop_end = loop_end;
                midi_loop_start = loop_start;
                
                if(midi_loop_end<0)
                {
                    pos = zc_min(pos+64,Midi_Info.len_beats);
                }
                
                else
                {
                    pos = zc_min(pos+64,midi_loop_end);
                }
                
                if(pos>0)
                {
                    zc_midi_seek(pos);
                }
                
                break;
            }
            
            // else play it...
            
        case 11:
        {
            int32_t pos=midi_pos;
            zc_stop_midi();
            midi_loop_start = -1;
            midi_loop_end = -1;
            zc_play_midi((MIDI*)data,loop);
            zc_set_volume(-1,volume);
            zc_midi_seek(pos<0?start:pos);
            midi_loop_start = loop_start;
            midi_loop_end = loop_end;
        }
        break;
        }
    }
    while(ret<26&&ret!=0);
    
    zc_stop_midi();
    
    if(ret==27)
    {
        strcpy(customtunes[i].title,title);
        customtunes[i].volume = volume;
        customtunes[i].loop = loop;
        customtunes[i].start = start;
        customtunes[i].loop_start = loop_start;
        customtunes[i].loop_end = loop_end;
        customtunes[i].format = MFORMAT_MIDI;
        customtunes[i].flags = flags;
        
        if(data!=customtunes[i].data)
        {
            if(customtunes[i].data)
                destroy_midi((MIDI*)customtunes[i].data);
                
            customtunes[i].data = data;
        }
        
        saved=false;
    }
    
    if((ret==28||ret==0) && data!=customtunes[i].data)
    {
        if(data)
        {
            destroy_midi((MIDI*)data);
        }
    }
}

int32_t d_midilist_proc(int32_t msg,DIALOG *d,int32_t c)
{
    if(msg==MSG_DRAW)
    {
        int32_t i = d->d1;
        int32_t x = d->x+d->w+8;
        int32_t y = d->y+4;
        
        textout_right_ex(screen,font,"Volume:",x+51,y+8+5,jwin_pal[jcBOXFG],jwin_pal[jcBOX]);
        textout_right_ex(screen,font,"Loop:",x+51,y+16+5,jwin_pal[jcBOXFG],jwin_pal[jcBOX]);
        textout_right_ex(screen,font,"Start:",x+51,y+24+5,jwin_pal[jcBOXFG],jwin_pal[jcBOX]);
        textout_right_ex(screen,font,"Loop Start:",x+51,y+32+5,jwin_pal[jcBOXFG],jwin_pal[jcBOX]);
        textout_right_ex(screen,font,"Loop End:",x+51,y+40+5,jwin_pal[jcBOXFG],jwin_pal[jcBOX]);
        
        textprintf_ex(screen,font,x+56,y+8+5,jwin_pal[jcBOXFG],jwin_pal[jcBOX],"%-3d",customtunes[i].volume);
        textprintf_ex(screen,font,x+56,y+16+5,jwin_pal[jcBOXFG],jwin_pal[jcBOX],"%s",customtunes[i].loop?"On ":"Off");
        textprintf_ex(screen,font,x+56,y+24+5,jwin_pal[jcBOXFG],jwin_pal[jcBOX],"%-5d",customtunes[i].start);
        textprintf_ex(screen,font,x+56,y+32+5,jwin_pal[jcBOXFG],jwin_pal[jcBOX],"%-5d",customtunes[i].loop_start);
        textprintf_ex(screen,font,x+56,y+40+5,jwin_pal[jcBOXFG],jwin_pal[jcBOX],"%-5d",customtunes[i].loop_end);
    }
    
    return jwin_list_proc(msg,d,c);
}

//static ListData custommidi_list(custommidilist, is_large ? &sfont3 : &font);
static ListData custommidi_list(custommidilist, is_large ? &lfont_l : &font);

static DIALOG selectmidi_dlg[] =
{
    /* (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp) */
    { jwin_win_proc,     24,   20,   273,  189,  vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "Select music", NULL, NULL },
    { d_dummy_proc,      160,  56,     0,  8,    vc(15),  vc(1),  0,       0,          0,             0,       NULL, NULL, NULL },
    { d_midilist_proc,   31,   44,   164, (1+16)*8,   jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,       D_EXIT,     0,             0, (void *) &custommidi_list, NULL, NULL },
    // { jwin_droplist_proc, 72-12,   60+4,   161,  16,   jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,       0,     0,             0, (void *) &tracknum_list, NULL, NULL },
    // { jwin_droplist_proc, 72-12,   60+4,   161,  16,   jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,       0,     0,             0, (void *) &custommidi_list, NULL, NULL },
    
    { jwin_button_proc,     90,   160+12+12,  61,   21,   vc(14),  vc(1),  13,     D_EXIT,     0,             0, (void *) "Edit", NULL, NULL },
    { jwin_button_proc,     170,  160+12+12,  61,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Done", NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,       0,      0,       0,          0,             KEY_DEL, (void *) close_dlg, NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

int32_t onMidis()
{
    stopMusic();
    int32_t ret;
    char buf[MIDI_TRACK_BUFFER_SIZE];
    number_list_size=MAXCUSTOMTUNES;
    number_list_zero=false;
    strcpy(temppath,midipath);
    selectmidi_dlg[0].dp2=lfont;
    
    
    if(is_large)
        large_dialog(selectmidi_dlg);
        
    selectmidi_dlg[2].dp2 = 0;
    
    go();
    ret=zc_do_dialog(selectmidi_dlg,2);
    
    while(ret!=4&&ret!=0)
    {
        int32_t d=selectmidi_dlg[2].d1;
        
        if(ret==5)
        {
            sprintf(buf,"Delete music %d?",d+1);
            
            if(jwin_alert("Confirm Delete",buf,NULL,NULL,"&Yes","&No",'y','n',lfont)==1)
            {
                customtunes[d].reset(); // reset_midi(customMIDIs+d);
                saved=false;
            }
        }
        else
        {
            edit_tune(d);
        }
        
        ret=zc_do_dialog(selectmidi_dlg,2);
    }
    
    comeback();
    return D_O_K;
}

/*******************************/
/******  onEnhancedMusic  ******/
/*******************************/

static DIALOG editmusic_dlg[] =
{
    /* (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp) */
    { jwin_win_proc,     24,   20,   273,  189,  vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "Music Specs", NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    // 2
    { jwin_text_proc,       56,   94-16,   48,   8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Music:", NULL, NULL },
    { jwin_text_proc,       104,  94-16,   48,   8,    vc(11),  vc(1),  0,       0,          0,             0,       NULL, NULL, NULL },
    { jwin_text_proc,       56,   114,  48,   8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Name:", NULL, NULL },
    { jwin_edit_proc,       104,  114-4,  160,  16,   vc(12),  vc(1),  0,       0,          19,            0,       NULL, NULL, NULL },
    { jwin_text_proc,       56,   124-4+12,  56,   8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Volume:", NULL, NULL },
    { jwin_edit_proc,       120,  124-4+12-4,  32,   16,   vc(12),  vc(1),  0,       0,          3,             0,       NULL, NULL, NULL },
    // 8
    { jwin_check_proc,      176,  124+12-4,  80+1,   8+1,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Loop", NULL, NULL },
    // 9
    { jwin_button_proc,     50,   72-24,   57,   21,   vc(14),  vc(1),  'l',     D_EXIT,     0,             0, (void *) "&Load", NULL, NULL },
    { jwin_button_proc,     116,  72-24,   33,   21,   vc(14),  vc(1),  0,       D_EXIT,     0,             0, (void *) "\x8D", NULL, NULL },
    { jwin_button_proc,     156,  72-24,   33,   21,   vc(14),  vc(1),  0,       D_EXIT,     0,             0, (void *) "\x8B", NULL, NULL },
    { jwin_button_proc,     196,  72-24,   33,   21,   vc(14),  vc(1),  0,       D_EXIT,     0,             0, (void *) "\x8B\x8B", NULL, NULL },
    { jwin_button_proc,     236,  72-24,   33,   21,   vc(14),  vc(1),  0,       D_EXIT,     0,             0, (void *) "\x8B\x8B\x8B", NULL, NULL },
    // 14
    { jwin_text_proc,       56,   134+4+12,  48,   8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Start:", NULL, NULL },
    { jwin_edit_proc,       112,  134+12,  32,   16,   vc(12),  vc(1),  0,       0,          5,             0,       NULL, NULL, NULL },
    { jwin_text_proc,       176,  134+12+4,  56,   8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Loop Start:", NULL, NULL },
    { jwin_edit_proc,       240,  134+12,  40,   16,   vc(12),  vc(1),  0,       0,          5,             0,       NULL, NULL, NULL },
    { jwin_text_proc,       176,  144+12+12,  48,   8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Loop End:", NULL, NULL },
    { jwin_edit_proc,       240,  144+12+12-4,  40,   16,   vc(12),  vc(1),  0,       0,          5,             0,       NULL, NULL, NULL },
    // 20
    { jwin_text_proc,       176,  94-16,   48,   8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Position:", NULL, NULL },
    { jwin_text_proc,       217,  94-16,   32,   8,    vc(11),  vc(1),  0,       0,          0,             0,       NULL, NULL, NULL },
    { jwin_text_proc,       176,  104-8,  48,   8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Length:", NULL, NULL },
    { jwin_text_proc,       216,  104-8,  32,   8,    vc(11),  vc(1),  0,       0,          0,             0,       NULL, NULL, NULL },
    { jwin_text_proc,       56,   104-8,  48,   8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Time:", NULL, NULL },
    { jwin_text_proc,       104,  104-8,  32,   8,    vc(11),  vc(1),  0,       0,          0,             0,       NULL, NULL, NULL },
    // 26
    { jwin_button_proc,     90,   160+12+12,  61,   21,   vc(14),  vc(1),  'k',     D_EXIT,     0,             0, (void *) "O&K", NULL, NULL },
    { jwin_button_proc,     170,  160+12+12,  61,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_F1,   0, (void *) onHelp, NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

int32_t d_musiclist_proc(int32_t msg,DIALOG *d,int32_t c)
{
    return jwin_list_proc(msg,d,c);
}

static ListData enhancedmusic_list(enhancedmusiclist, &font);

static DIALOG selectmusic_dlg[] =
{
    /* (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp) */
    { jwin_win_proc,     24,   20,   273,  189,  vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "Select Enhanced Music", NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { d_musiclist_proc,   31,   44,   164, (1+16)*8,   jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,       D_EXIT,     0,             0, (void *) &enhancedmusic_list, NULL, NULL },
    { jwin_button_proc,     90,   160+12+12,  61,   21,   vc(14),  vc(1),  13,     D_EXIT,     0,             0, (void *) "Edit", NULL, NULL },
    { jwin_button_proc,     170,  160+12+12,  61,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Done", NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,       0,      0,       0,          0,             KEY_DEL, (void *) close_dlg, NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

int32_t onEnhancedMusic()
{
    // to be taken out - the custom music can all be found in one place
    /*stopMusic();
    int32_t ret;
    char buf[40];
    number_list_size=MAXCUSTOMMIDIS;
    number_list_zero=false;
    strcpy(temppath,midipath);
    selectmusic_dlg[0].dp2=lfont;
    go();
    ret=zc_do_dialog(selectmusic_dlg,2);
    while(ret!=4&&ret!=0)
    {
      int32_t d=selectmusic_dlg[2].d1;
      if(ret==5)
      {
        sprintf(buf,"Delete MIDI %d?",d+1);
        if(jwin_alert("Confirm Delete",buf,NULL,NULL,"&Yes","&No",'y','n',lfont)==1)
        {
          reset_midi(customMIDIs+d);
          saved=false;
        }
      }
      else
      {
        edit_midi(d);
      }
      ret=zc_do_dialog(selectmusic_dlg,2);
    }
    comeback();
    */
    return D_O_K;
}

/*******************************/
/**********  onWarp  ***********/
/*******************************/

const char *warptypelist(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        if(index>=MAXWARPTYPES)
            index=MAXWARPTYPES-1;
            
        return warptype_string[index];
    }
    
    *list_size=MAXWARPTYPES;
    //  *list_size=6;
    return NULL;
}

const char *warpeffectlist(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        if(index>=MAXWARPEFFECTS)
            index=MAXWARPEFFECTS-1;
            
        return warpeffect_string[index];
    }
    
    *list_size=MAXWARPEFFECTS;
    return NULL;
}

//int32_t warpdmapxy[6] = {188,131,188,111,188,120};
//int32_t warpdmapxy[6] = {188-68,131-93,188-68,111-93,188-68,120-93};
int32_t warpdmapxy[6] = {150,38,150,18,150,27};
//int32_t warpdmapxy[6] = {2,25,0,17,36,17};

static int32_t warp1_list[] =
{
    2,3,4,5,6,7,8,9,10,11,12,13,53,54,63,67,-1
};

static int32_t warp2_list[] =
{
    17,18,19,20,21,22,23,24,25,26,27,28,55,56,64,68,-1
};

static int32_t warp3_list[] =
{
    29,30,31,32,33,34,35,36,37,38,39,40,57,58,65,69,-1
};

static int32_t warp4_list[] =
{
    41,42,43,44,45,46,47,48,49,50,51,52,59,60,66,70,-1
};

static TABPANEL warp_tabs[] =
{
    // (text)
    { (char *)"A",     D_SELECTED, warp1_list, 0, NULL },
    { (char *)"B",     0,          warp2_list, 0, NULL },
    { (char *)"C",     0,          warp3_list, 0, NULL },
    { (char *)"D",     0,          warp4_list, 0, NULL },
    { NULL,            0,          NULL,       0, NULL }
};


static int32_t warpring_warp1_list[] =
{
    2,3,4,5,6,7,8,9,10,11,12,13,53,54,63,67,-1
};

static int32_t warpring_warp2_list[] =
{
    17,18,19,20,21,22,23,24,25,26,27,28,55,56,64,68,-1
};

static int32_t warpring_warp3_list[] =
{
    29,30,31,32,33,34,35,36,37,38,39,40,57,58,65,69,-1
};

static int32_t warpring_warp4_list[] =
{
    41,42,43,44,45,46,47,48,49,50,51,52,59,60,66,70,-1
};
static TABPANEL warpring_warp_tabs[] =
{
    // (text)
    { (char *)"A",     D_SELECTED, warpring_warp1_list, 0, NULL },
    { (char *)"B",     0,          warpring_warp2_list, 0, NULL },
    { (char *)"C",     0,          warpring_warp3_list, 0, NULL },
    { (char *)"D",     0,          warpring_warp4_list, 0, NULL },
    { NULL,            0,          NULL,       0, NULL }
};

int32_t onTileWarpIndex(int32_t index)
{
    int32_t i=-1;
    
    while(warp_tabs[++i].text != NULL)
        warp_tabs[i].flags = (i==index ? D_SELECTED : 0);
        
    onTileWarp();
    return D_O_K;
}

static char warpr_buf[10];
const char *warprlist(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        bound(index,0,3);
        sprintf(warpr_buf,"%c",index+0x41);
        return warpr_buf;
    }
    
    *list_size=4;
    return NULL;
}

int32_t d_wflag_proc(int32_t msg,DIALOG *d,int32_t c);

static ListData warp_dlg_list(warptypelist, &font);
static ListData warp_ret_list(warprlist, &font);

int32_t d_warpdestscrsel_proc(int32_t msg,DIALOG *d,int32_t)
{
    DIALOG *td=(DIALOG *)d->dp3;
    
    if(msg==MSG_CLICK)
    {
        bool is_overworld=((DMaps[td[d->d1].d1].type&dmfTYPE)==dmOVERW);
        int32_t x_clip  = is_overworld?0x0F:0x07;
        int32_t x_scale = is_overworld?2:3;
        
        while(gui_mouse_b())
        {
            int32_t x = zc_min(zc_max(gui_mouse_x() - d->x,0)>>x_scale, x_clip);
            int32_t y = zc_min((zc_max(gui_mouse_y() - d->y,0)<<2)&0xF0, 0x70);
//      if(x+y != d->d1)
            {
                custom_vsync();
                scare_mouse();
                sprintf((char *)td[d->d1+1].dp, "%02X", y+x);
                object_message(&td[d->d1+1], MSG_DRAW, 0);
                unscare_mouse();
            }
        }
    }
    
    return D_O_K;
}

static DIALOG warp_dlg[] =
{
    /* (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp) */
    { jwin_win_proc,             0,      0,    302,    188,    vc(14),                 vc(1),                   0,       D_EXIT,     0,             0,  NULL,                          NULL,   NULL              },
    { jwin_tab_proc,             6,     24,    290,    135,    vc(14),                 vc(1),                   0,       0,          1,             0, (void *) warp_tabs,            NULL, (void *)warp_dlg  },
    { jwin_text_proc,           61,     55,     40,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Type:",              NULL,   NULL              },
    { jwin_text_proc,           29,     73,     40,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "DMap:",              NULL,   NULL              },
    { jwin_text_proc,           28,     91,     64,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Screen:",         NULL,   NULL              },
    { jwin_text_proc,          146,     91,     64,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Triggers:",          NULL,   NULL              },
    { jwin_frame_proc,         164,    109,     30,     30,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,       0,          FR_ETCHED,     0,  NULL,                          NULL,   NULL              },
    // 7
    { jwin_droplist_proc,       91,     51,    193,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,       0,          0,             0, (void *) &warp_dlg_list,       NULL,   NULL              },
    { d_dropdmaplist_proc,      59,     69,    225,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,       0,          0,             0, (void *) &dmap_list,           NULL,   warpdmapxy        },
    { jwin_hexedit_proc,        77,     87,     24,     16,    vc(12),                 vc(1),                   0,       0,          2,             0,  NULL,                          NULL,   NULL              },
    // 10
    { d_wflag_proc,            170,    106,     18,      8,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    { d_wflag_proc,            170,    134,     18,      8,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    { d_wflag_proc,            161,    115,      8,     18,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    { d_wflag_proc,            189,    115,      8,     18,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    // 14
    { jwin_button_proc,         61,    163,     41,     21,    vc(14),                 vc(1),                   'k',     D_EXIT,     0,             0, (void *) "O&K",                NULL,   NULL              },
    { jwin_button_proc,        121,    163,     41,     21,    vc(14),                 vc(1),                   'g',     D_EXIT,     0,             0, (void *) "&Go",                NULL,   NULL              },
    { jwin_button_proc,        181,    163,     61,     21,    vc(14),                 vc(1),                  27,       D_EXIT,     0,             0, (void *) "Cancel",             NULL,   NULL              },
    // 17
    { jwin_text_proc,           61,     55,     40,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Type:",              NULL,   NULL              },
    { jwin_text_proc,           29,     73,     40,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "DMap:",              NULL,   NULL              },
    { jwin_text_proc,           28,     91,     64,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Screen:",         NULL,   NULL              },
    { jwin_text_proc,          146,     91,     64,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Triggers:",          NULL,   NULL              },
    { jwin_frame_proc,         164,    109,     30,     30,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,       0,          FR_ETCHED,     0,  NULL,                          NULL,   NULL              },
    // 22
    { jwin_droplist_proc,       91,     51,    193,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,       0,          0,             0, (void *) &warp_dlg_list,       NULL,   NULL              },
    { d_dropdmaplist_proc,      59,     69,    225,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,       0,          0,             0, (void *) &dmap_list,           NULL,   warpdmapxy        },
    { jwin_hexedit_proc,        77,     87,     24,     16,    vc(12),                 vc(1),                   0,       0,          2,             0,  NULL,                          NULL,   NULL              },
    // 25
    { d_wflag_proc,            170,    106,     18,      8,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    { d_wflag_proc,            170,    134,     18,      8,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    { d_wflag_proc,            161,    115,      8,     18,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    { d_wflag_proc,            189,    115,      8,     18,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    // 29
    { jwin_text_proc,           61,     55,     40,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Type:",              NULL,   NULL              },
    { jwin_text_proc,           29,     73,     40,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "DMap:",              NULL,   NULL              },
    { jwin_text_proc,           28,     91,     64,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Screen:",         NULL,   NULL              },
    { jwin_text_proc,          146,     91,     64,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Triggers:",          NULL,   NULL              },
    { jwin_frame_proc,         164,    109,     30,     30,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,       0,          FR_ETCHED,     0,  NULL,                          NULL,   NULL              },
    // 34
    { jwin_droplist_proc,       91,     51,    193,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,       0,          0,             0, (void *) &warp_dlg_list,       NULL,   NULL              },
    { d_dropdmaplist_proc,      59,     69,    225,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,       0,          0,             0, (void *) &dmap_list,           NULL,   warpdmapxy        },
    { jwin_hexedit_proc,        77,     87,     24,     16,    vc(12),                 vc(1),                   0,       0,          2,             0,  NULL,                          NULL,   NULL              },
    // 37
    { d_wflag_proc,            170,    106,     18,      8,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    { d_wflag_proc,            170,    134,     18,      8,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    { d_wflag_proc,            161,    115,      8,     18,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    { d_wflag_proc,            189,    115,      8,     18,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    //41
    { jwin_text_proc,           61,     55,     40,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Type:",              NULL,   NULL              },
    { jwin_text_proc,           29,     73,     40,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "DMap:",              NULL,   NULL              },
    { jwin_text_proc,           28,     91,     64,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Screen:",         NULL,   NULL              },
    { jwin_text_proc,          146,     91,     64,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Triggers:",          NULL,   NULL              },
    { jwin_frame_proc,         164,    109,     30,     30,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,       0,          FR_ETCHED,     0,  NULL,                          NULL,   NULL              },
    // 46
    { jwin_droplist_proc,       91,     51,    193,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,       0,          0,             0, (void *) &warp_dlg_list,       NULL,   NULL              },
    { d_dropdmaplist_proc,      59,     69,    225,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,       0,          0,             0, (void *) &dmap_list,           NULL,   warpdmapxy        },
    { jwin_hexedit_proc,        77,     87,     24,     16,    vc(12),                 vc(1),                   0,       0,          2,             0,  NULL,                          NULL,   NULL              },
    // 49
    { d_wflag_proc,            170,    106,     18,      8,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    { d_wflag_proc,            170,    134,     18,      8,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    { d_wflag_proc,            161,    115,      8,     18,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    { d_wflag_proc,            189,    115,      8,     18,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    { jwin_text_proc,           29,    123,    100,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Use Warp Return:",   NULL,   NULL              },
    { jwin_droplist_proc,       74,    133,     50,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,       0,          0,             0, (void *) &warp_ret_list,       NULL,   NULL              },
    { jwin_text_proc,           29,    123,    100,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Use Warp Return:",   NULL,   NULL              },
    { jwin_droplist_proc,       74,    133,     50,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,       0,          0,             0, (void *) &warp_ret_list,       NULL,   NULL              },
    { jwin_text_proc,           29,    123,    100,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Use Warp Return:",   NULL,   NULL              },
    { jwin_droplist_proc,       74,    133,     50,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,       0,          0,             0, (void *) &warp_ret_list,       NULL,   NULL              },
    { jwin_text_proc,           29,    123,    100,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Use Warp Return:",   NULL,   NULL              },
    { jwin_droplist_proc,       74,    133,     50,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,       0,          0,             0, (void *) &warp_ret_list,       NULL,   NULL              },
    { d_keyboard_proc,           0,      0,      0,      0,    0,                      0,                       0,       0,          KEY_F1,        0, (void *) onHelp,               NULL,   NULL              },
    { d_timer_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    // 63
    { jwin_check_proc,        29,   107,    129,      9,    vc(14),                 vc(1),                   0,       0,          1,             0, (void *) "Combos Carry Over",            NULL,   NULL              },
    { jwin_check_proc,        29,   107,    129,      9,    vc(14),                 vc(1),                   0,       0,          1,             0, (void *) "Combos Carry Over",            NULL,   NULL              },
    { jwin_check_proc,        29,   107,    129,      9,    vc(14),                 vc(1),                   0,       0,          1,             0, (void *) "Combos Carry Over",            NULL,   NULL              },
    { jwin_check_proc,        29,   107,    129,      9,    vc(14),                 vc(1),                   0,       0,          1,             0, (void *) "Combos Carry Over",            NULL,   NULL              },
    // 67
    { d_warpdestscrsel_proc,   217,    114,     64,     32,    0,                      0,                       0,       0,          8,             0,  NULL,                          NULL, (void *)warp_dlg  },
    { d_warpdestscrsel_proc,   217,    114,     64,     32,    0,                      0,                       0,       0,         23,             0,  NULL,                          NULL, (void *)warp_dlg  },
    { d_warpdestscrsel_proc,   217,    114,     64,     32,    0,                      0,                       0,       0,         35,             0,  NULL,                          NULL, (void *)warp_dlg  },
    { d_warpdestscrsel_proc,   217,    114,     64,     32,    0,                      0,                       0,       0,         47,             0,  NULL,                          NULL, (void *)warp_dlg  },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { NULL,                      0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              }
};





static DIALOG warpring_warp_dlg[] =
{
    /* (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp) */
    { jwin_win_proc,             0,      0,    302,    188,    vc(14),                 vc(1),                   0,       D_EXIT,     0,             0,  NULL,                          NULL,   NULL              },
    { jwin_tab_proc,             6,     24,    290,    135,    vc(14),                 vc(1),                   0,       0,          1,             0, (void *) warpring_warp_tabs,            NULL, (void *)warpring_warp_dlg  },
    { jwin_text_proc,           61,     55,     40,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Type:",              NULL,   NULL              },
    { jwin_text_proc,           29,     73,     40,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "DMap:",              NULL,   NULL              },
    { jwin_text_proc,           28,     91,     64,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Screen:",         NULL,   NULL              },
    { jwin_text_proc,          146,     91,     64,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Triggers:",          NULL,   NULL              },
    { jwin_frame_proc,         164,    109,     30,     30,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,       0,          FR_ETCHED,     0,  NULL,                          NULL,   NULL              },
    // 7
    { jwin_droplist_proc,       91,     51,    193,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,       0,          0,             0, (void *) &warp_dlg_list,       NULL,   NULL              },
    { d_dropdmaplist_proc,      59,     69,    225,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,       0,          0,             0, (void *) &dmap_list,           NULL,   warpdmapxy        },
    { jwin_hexedit_proc,        77,     87,     24,     16,    vc(12),                 vc(1),                   0,       0,          2,             0,  NULL,                          NULL,   NULL              },
    // 10
    { d_wflag_proc,            170,    106,     18,      8,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    { d_wflag_proc,            170,    134,     18,      8,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    { d_wflag_proc,            161,    115,      8,     18,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    { d_wflag_proc,            189,    115,      8,     18,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    // 14
    { jwin_button_proc,         61,    163,     41,     21,    vc(14),                 vc(1),                   'k',     D_EXIT,     0,             0, (void *) "O&K",                NULL,   NULL              },
    { jwin_button_proc,        121,    163,     41,     21,    vc(14),                 vc(1),                   'g',     D_EXIT,     0,             0, (void *) "&Go",                NULL,   NULL              },
    { jwin_button_proc,        181,    163,     61,     21,    vc(14),                 vc(1),                  27,       D_EXIT,     0,             0, (void *) "Cancel",             NULL,   NULL              },
    // 17
    { jwin_text_proc,           61,     55,     40,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Type:",              NULL,   NULL              },
    { jwin_text_proc,           29,     73,     40,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "DMap:",              NULL,   NULL              },
    { jwin_text_proc,           28,     91,     64,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Screen:",         NULL,   NULL              },
    { jwin_text_proc,          146,     91,     64,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Triggers:",          NULL,   NULL              },
    { jwin_frame_proc,         164,    109,     30,     30,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,       0,          FR_ETCHED,     0,  NULL,                          NULL,   NULL              },
    // 22
    { jwin_droplist_proc,       91,     51,    193,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,       0,          0,             0, (void *) &warp_dlg_list,       NULL,   NULL              },
    { d_dropdmaplist_proc,      59,     69,    225,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,       0,          0,             0, (void *) &dmap_list,           NULL,   warpdmapxy        },
    { jwin_hexedit_proc,        77,     87,     24,     16,    vc(12),                 vc(1),                   0,       0,          2,             0,  NULL,                          NULL,   NULL              },
    // 25
    { d_wflag_proc,            170,    106,     18,      8,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    { d_wflag_proc,            170,    134,     18,      8,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    { d_wflag_proc,            161,    115,      8,     18,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    { d_wflag_proc,            189,    115,      8,     18,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    // 29
    { jwin_text_proc,           61,     55,     40,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Type:",              NULL,   NULL              },
    { jwin_text_proc,           29,     73,     40,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "DMap:",              NULL,   NULL              },
    { jwin_text_proc,           28,     91,     64,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Screen:",         NULL,   NULL              },
    { jwin_text_proc,          146,     91,     64,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Triggers:",          NULL,   NULL              },
    { jwin_frame_proc,         164,    109,     30,     30,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,       0,          FR_ETCHED,     0,  NULL,                          NULL,   NULL              },
    // 34
    { jwin_droplist_proc,       91,     51,    193,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,       0,          0,             0, (void *) &warp_dlg_list,       NULL,   NULL              },
    { d_dropdmaplist_proc,      59,     69,    225,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,       0,          0,             0, (void *) &dmap_list,           NULL,   warpdmapxy        },
    { jwin_hexedit_proc,        77,     87,     24,     16,    vc(12),                 vc(1),                   0,       0,          2,             0,  NULL,                          NULL,   NULL              },
    // 37
    { d_wflag_proc,            170,    106,     18,      8,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    { d_wflag_proc,            170,    134,     18,      8,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    { d_wflag_proc,            161,    115,      8,     18,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    { d_wflag_proc,            189,    115,      8,     18,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    //41
    { jwin_text_proc,           61,     55,     40,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Type:",              NULL,   NULL              },
    { jwin_text_proc,           29,     73,     40,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "DMap:",              NULL,   NULL              },
    { jwin_text_proc,           28,     91,     64,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Screen:",         NULL,   NULL              },
    { jwin_text_proc,          146,     91,     64,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Triggers:",          NULL,   NULL              },
    { jwin_frame_proc,         164,    109,     30,     30,    jwin_pal[jcBOXFG],      jwin_pal[jcBOX],         0,       0,          FR_ETCHED,     0,  NULL,                          NULL,   NULL              },
    // 46
    { jwin_droplist_proc,       91,     51,    193,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,       0,          0,             0, (void *) &warp_dlg_list,       NULL,   NULL              },
    { d_dropdmaplist_proc,      59,     69,    225,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,       0,          0,             0, (void *) &dmap_list,           NULL,   warpdmapxy        },
    { jwin_hexedit_proc,        77,     87,     24,     16,    vc(12),                 vc(1),                   0,       0,          2,             0,  NULL,                          NULL,   NULL              },
    // 49
    { d_wflag_proc,            170,    106,     18,      8,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    { d_wflag_proc,            170,    134,     18,      8,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    { d_wflag_proc,            161,    115,      8,     18,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    { d_wflag_proc,            189,    115,      8,     18,    vc(4),                  vc(0),                   0,       0,          1,             0,  NULL,                          NULL,   NULL              },
    { jwin_text_proc,           29,    123,    100,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Use Warp Return:",   NULL,   NULL              },
    { jwin_droplist_proc,       74,    133,     50,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,       0,          0,             0, (void *) &warp_ret_list,       NULL,   NULL              },
    { jwin_text_proc,           29,    123,    100,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Use Warp Return:",   NULL,   NULL              },
    { jwin_droplist_proc,       74,    133,     50,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,       0,          0,             0, (void *) &warp_ret_list,       NULL,   NULL              },
    { jwin_text_proc,           29,    123,    100,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Use Warp Return:",   NULL,   NULL              },
    { jwin_droplist_proc,       74,    133,     50,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,       0,          0,             0, (void *) &warp_ret_list,       NULL,   NULL              },
    { jwin_text_proc,           29,    123,    100,      8,    vc(14),                 vc(1),                   0,       0,          0,             0, (void *) "Use Warp Return:",   NULL,   NULL              },
    { jwin_droplist_proc,       74,    133,     50,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,       0,          0,             0, (void *) &warp_ret_list,       NULL,   NULL              },
    { d_keyboard_proc,           0,      0,      0,      0,    0,                      0,                       0,       0,          KEY_F1,        0, (void *) onHelp,               NULL,   NULL              },
    { d_timer_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    // 63
    { jwin_check_proc,        29,   107,    129,      9,    vc(14),                 vc(1),                   0,       0,          1,             0, (void *) "Combos Carry Over",            NULL,   NULL              },
    { jwin_check_proc,        29,   107,    129,      9,    vc(14),                 vc(1),                   0,       0,          1,             0, (void *) "Combos Carry Over",            NULL,   NULL              },
    { jwin_check_proc,        29,   107,    129,      9,    vc(14),                 vc(1),                   0,       0,          1,             0, (void *) "Combos Carry Over",            NULL,   NULL              },
    { jwin_check_proc,        29,   107,    129,      9,    vc(14),                 vc(1),                   0,       0,          1,             0, (void *) "Combos Carry Over",            NULL,   NULL              },
    // 67
    { d_warpdestscrsel_proc,   217,    114,     64,     32,    0,                      0,                       0,       0,          8,             0,  NULL,                          NULL, (void *)warpring_warp_dlg  },
    { d_warpdestscrsel_proc,   217,    114,     64,     32,    0,                      0,                       0,       0,         23,             0,  NULL,                          NULL, (void *)warpring_warp_dlg  },
    { d_warpdestscrsel_proc,   217,    114,     64,     32,    0,                      0,                       0,       0,         35,             0,  NULL,                          NULL, (void *)warpring_warp_dlg  },
    { d_warpdestscrsel_proc,   217,    114,     64,     32,    0,                      0,                       0,       0,         47,             0,  NULL,                          NULL, (void *)warpring_warp_dlg  },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { d_dummy_proc,              0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              },
    { NULL,                      0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                          NULL,   NULL              }
};

// Side warp flag procedure
int32_t d_wflag_proc(int32_t msg,DIALOG *d,int32_t c)
{
    //these are here to bypass compiler warnings about unused arguments
    c=c;
    
    switch(msg)
    {
    case MSG_DRAW:
    {
        int32_t c2=(d->flags&D_SELECTED)?d->fg:d->bg;
        
        /*if(!(d->d2&0x80))
          {
          c=d->bg;
          }*/
        if(d->d1==1)
        {
            jwin_draw_frame(screen,d->x,d->y,d->w,d->h, FR_DEEP);
            rectfill(screen,d->x+2, d->y+2, d->x+d->w-3, d->y+d->h-3,c2);
            
            if(d->flags&D_SELECTED)
            {
                int32_t e=d->d2&3;
                
                if(d->w>d->h)
                    textprintf_centre_ex(screen,is_large ? lfont_l : font, d->x+(d->w/2),d->y,jwin_pal[jcBOXFG],-1,"%c",e+0x41);
                else
                    textprintf_centre_ex(screen,is_large ? lfont_l : font, d->x+(d->w/2),d->y+(d->h/2)-4,jwin_pal[jcBOXFG],-1,"%c",e+0x41);
            }
            
        }
        else
        {
            rectfill(screen,d->x, d->y, d->x+d->w-1, d->y+d->h-1,c2);
        }
    }
    break;
    
    case MSG_CLICK:
    {
		if(d->flags & D_DISABLED)
			return D_O_K;
        if(d->d1==1)
        {
            if(!(d->flags&D_SELECTED))
            {
                d->flags|=D_SELECTED;
                d->d2&=0x80;
                int32_t g;
                
                if(d==&warp_dlg[10]||d==&warp_dlg[25]||d==&warp_dlg[37]||d==&warp_dlg[49]) g=0;
                else if(d==&warp_dlg[11]||d==&warp_dlg[26]||d==&warp_dlg[38]||d==&warp_dlg[50]) g=1;
                else if(d==&warp_dlg[12]||d==&warp_dlg[27]||d==&warp_dlg[39]||d==&warp_dlg[51]) g=2;
                else g=3;
                
                warp_dlg[10+g].flags = d->flags;
                warp_dlg[10+g].d2 = d->d2;
                warp_dlg[25+g].flags = d->flags;
                warp_dlg[25+g].d2 = d->d2;
                warp_dlg[37+g].flags = d->flags;
                warp_dlg[37+g].d2 = d->d2;
                warp_dlg[49+g].flags = d->flags;
                warp_dlg[49+g].d2 = d->d2;
            }
            else
            {
                if((d->d2&3)==3)
                {
                    d->flags^=D_SELECTED;
                    d->d2&=0x80;
                    int32_t g;
                    
                    if(d==&warp_dlg[10]||d==&warp_dlg[25]||d==&warp_dlg[37]||d==&warp_dlg[49]) g=0;
                    else if(d==&warp_dlg[11]||d==&warp_dlg[26]||d==&warp_dlg[38]||d==&warp_dlg[50]) g=1;
                    else if(d==&warp_dlg[12]||d==&warp_dlg[27]||d==&warp_dlg[39]||d==&warp_dlg[51]) g=2;
                    else g=3;
                    
                    warp_dlg[10+g].flags = d->flags;
                    warp_dlg[10+g].d2 = d->d2;
                    warp_dlg[25+g].flags = d->flags;
                    warp_dlg[25+g].d2 = d->d2;
                    warp_dlg[37+g].flags = d->flags;
                    warp_dlg[37+g].d2 = d->d2;
                    warp_dlg[49+g].flags = d->flags;
                    warp_dlg[49+g].d2 = d->d2;
                }
                else
                {
                    int32_t f=d->d2&3;
                    d->d2&=0x80;
                    f++;
                    d->d2|=f;
                    int32_t g;
                    
                    if(d==&warp_dlg[10]||d==&warp_dlg[25]||d==&warp_dlg[37]||d==&warp_dlg[49]) g=0;
                    else if(d==&warp_dlg[11]||d==&warp_dlg[26]||d==&warp_dlg[38]||d==&warp_dlg[50]) g=1;
                    else if(d==&warp_dlg[12]||d==&warp_dlg[27]||d==&warp_dlg[39]||d==&warp_dlg[51]) g=2;
                    else g=3;
                    
                    warp_dlg[10+g].flags = d->flags;
                    warp_dlg[10+g].d2 = d->d2;
                    warp_dlg[25+g].flags = d->flags;
                    warp_dlg[25+g].d2 = d->d2;
                    warp_dlg[37+g].flags = d->flags;
                    warp_dlg[37+g].d2 = d->d2;
                    warp_dlg[49+g].flags = d->flags;
                    warp_dlg[49+g].d2 = d->d2;
                }
            }
        }
        else
        {
            d->flags^=D_SELECTED;
        }
        
        int32_t c2=(d->flags&D_SELECTED)?d->fg:d->bg;
        scare_mouse();
        
        if(d->d1==1)
        {
            jwin_draw_frame(screen,d->x,d->y,d->w,d->h, FR_DEEP);
            rectfill(screen,d->x+2, d->y+2, d->x+d->w-3, d->y+d->h-3,c2);
            
            if(d->flags&D_SELECTED)
            {
                int32_t e=d->d2&3;
                
                if(d->w>d->h)
                    textprintf_centre_ex(screen,is_large? lfont_l: font,d->x+(d->w/2),d->y,jwin_pal[jcBOXFG],-1,"%c",e+0x41);
                else
                    textprintf_centre_ex(screen,is_large? lfont_l: font,d->x+(d->w/2),d->y+(d->h/2)-4,jwin_pal[jcBOXFG],-1,"%c",e+0x41);
            }
        }
        else
        {
            rectfill(screen,d->x, d->y, d->x+d->w-1, d->y+d->h-1,c2);
        }
        
        unscare_mouse();
        
        while(gui_mouse_b())
        {
            /* do nothing */
            rest(1);
        }
    }
    break;
    }
    
    return D_O_K;
}

#if 0
static int32_t north_side_warp_list[] =
{
    // dialog control number
    15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, -1
};

static int32_t south_side_warp_list[] =
{
    // dialog control number
    80, -1
};

static int32_t west_side_warp_list[] =
{
    // dialog control number
    80, -1
};

static int32_t east_side_warp_list[] =
{
    // dialog control number
    80, -1
};

static int32_t wind_warp_1_list[] =
{
    // dialog control number
    80, -1
};

static int32_t wind_warp_2_list[] =
{
    // dialog control number
    80, -1
};

static int32_t wind_warp_3_list[] =
{
    // dialog control number
    80, -1
};

static int32_t wind_warp_4_list[] =
{
    // dialog control number
    80, -1
};

static int32_t wind_warp_5_list[] =
{
    // dialog control number
    80, -1
};

static int32_t wind_warp_6_list[] =
{
    // dialog control number
    80, -1
};

static int32_t wind_warp_7_list[] =
{
    // dialog control number
    80, -1
};

static int32_t wind_warp_8_list[] =
{
    // dialog control number
    80, -1
};

static int32_t wind_warp_9_list[] =
{
    // dialog control number
    80, -1
};


static int32_t tile_warp_list[] =
{
    // dialog control number
    80, -1
};

static int32_t side_warp_list[] =
{
    // dialog control number
    6, -1
};

static int32_t item_warp_list[] =
{
    // dialog control number
    80, -1
};

static int32_t wind_warp_list[] =
{
    // dialog control number
    7, -1
};

static int32_t special_warp_list[] =
{
    // dialog control number
    80, -1
};

static int32_t timed_warp_list[] =
{
    // dialog control number
    80, -1
};


#endif

int32_t d_dmapscrsel_proc(int32_t msg,DIALOG *d,int32_t c)
{
    //these are here to bypass compiler warnings about unused arguments
    c=c;
    
    int32_t ret = D_O_K;
    
    switch(msg)
    {
    case MSG_CLICK:
        sprintf((char*)((d+2)->dp),"%X%X",vbound((gui_mouse_y()-d->y)/4,0,7),vbound((gui_mouse_x()-d->x)/(((DMaps[(d-1)->d1].type&dmfTYPE)==1)?4:8),0,(((DMaps[(d-1)->d1].type&dmfTYPE)==1)?15:7)));
        object_message(d+2, MSG_DRAW, 0);
        break;
    }
    
    return ret;
}

int32_t warpdestsel_x=-1;
int32_t warpdestsel_y=-1;
int32_t warpdestmap=-1;
int32_t warpdestscr=-1;

int32_t d_warpdestsel_proc(int32_t msg,DIALOG *d,int32_t c)
{
    //these are here to bypass compiler warnings about unused arguments
    c=c;
    
    int32_t ret=D_O_K;
    static BITMAP *bmp=create_bitmap_ex(8,256,176);
    static bool inrect=false;
    static bool mousedown=false;
    
    switch(msg)
    {
    case MSG_START:
        loadlvlpal(Map.AbsoluteScr(warpdestmap,warpdestscr)->color);
        rebuild_trans_table();
        break;
        
    case MSG_DRAW:
    {
        scare_mouse();
        jwin_draw_frame(screen, d->x, d->y, d->w, d->h, FR_DEEP);
        
        if(AnimationOn||CycleOn)
        {
            if(AnimationOn)
            {
                animate_combos();
            }
            
            if(CycleOn)
            {
                cycle_palette();
            }
        }
        
        animate_coords();
        Map.draw(bmp, 0, 0, 0, warpdestmap, warpdestscr);
        blit(icon_bmp[ICON_BMP_WARPDEST][coord_frame], bmp, 0, 0, Map.AbsoluteScr(warpdestmap,warpdestscr)->warparrivalx, Map.AbsoluteScr(warpdestmap,warpdestscr)->warparrivaly, 16, 16);
        int32_t px2=((gui_mouse_x()-d->x-2)&0xF8);
        int32_t py2=((gui_mouse_y()-d->y-2)&0xF8);
        
        if(isinRect(gui_mouse_x(), gui_mouse_y(), d->x+2,d->y+2,d->x+256+1,d->y+176+1))
        {
            if(gui_mouse_b())
            {
                if(!mousedown||!inrect)
                {
                    set_mouse_sprite(mouse_bmp[MOUSE_BMP_BLANK][0]);
                    set_mouse_range(d->x+2, d->y+2, d->x+256+1, d->y+176+1);
                }
                
                rect(bmp, px2, py2, px2+15, py2+15, vc(15));
                warpdestsel_x=px2;
                warpdestsel_y=py2;
                mousedown=true;
            }
            else
            {
                if(mousedown||!inrect)
                {
                    set_mouse_range(0,0,zq_screen_w-1,zq_screen_h-1);
                    set_mouse_sprite(mouse_bmp[MOUSE_BMP_POINT_BOX][0]);
                }
                
                mousedown=false;
            }
            
            inrect=true;
        }
        else
        {
            set_mouse_sprite(mouse_bmp[MOUSE_BMP_NORMAL][0]);
            inrect=false;
        }
        
        blit(bmp, screen, 0, 0, d->x+2, d->y+2, 256, 176);
        unscare_mouse();
    }
    break;
    
    case MSG_VSYNC:
        d->flags|=D_DIRTY;
        break;
        
    case MSG_END:
        loadlvlpal(Map.CurrScr()->color);
        rebuild_trans_table();
        break;
    }
    
    return ret;
}

#if 0
static DIALOG warpdestsel_dlg[] =
{
    /* (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp) */
    { jwin_win_proc,                 0,      0,    297,    234,    vc(14),                 vc(1),                   0,       D_EXIT,      0,             0, (void *) "Select Warp Destination",    NULL,    NULL       },
    { jwin_button_proc,              6,    207,     61,     21,    vc(0),                  vc(11),                 13,       D_EXIT,      0,             0, (void *) "OK",                         NULL,    NULL       },
    { jwin_button_proc,             70,    207,     93,     21,    vc(0),                  vc(11),                  0,       D_EXIT,      0,             0, (void *) "Use Warp Square",            NULL,    NULL       },
    { jwin_button_proc,            166,    207,     61,     21,    vc(0),                  vc(11),                  0,       D_EXIT,      0,             0, (void *) "Use Origin",                 NULL,    NULL       },
    { jwin_button_proc,            230,    207,     61,     21,    vc(0),                  vc(11),                 27,       D_EXIT,      0,             0, (void *) "Cancel",                     NULL,    NULL       },
    { d_keyboard_proc,               0,      0,      0,      0,    0,                      0,                       0,       0,           KEY_F1,        0, (void *) onHelp,                       NULL,    NULL       },
    { d_warpdestsel_proc,           19,     23,    260,    180,    0,                      0,                       0,       0,           0,             0,   NULL,                                  NULL,    NULL       },
    { d_vsync_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,           0,             0,   NULL,                                  NULL,    NULL       },
    { d_timer_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,           0,             0,   NULL,                                  NULL,    NULL       },
    { NULL,                          0,      0,      0,      0,    0,                      0,                       0,       0,           0,             0,   NULL,                                  NULL,    NULL       }
};

int32_t d_warpbutton_proc(int32_t msg,DIALOG *d,int32_t c)
{
    int32_t ret=jwin_button_proc(msg,d,c);
    
    if(ret==D_EXIT)
    {
        warpdestsel_dlg[0].dp2=lfont;
        warpdestmap=DMaps[(d-4)->d1].map;
        warpdestscr=DMaps[(d-4)->d1].xoff+xtoi((char*)((d-1)->dp));
        ret=zc_popup_dialog(warpdestsel_dlg,-1);
        
        switch(ret)
        {
        case 1:
            d->d1=warpdestsel_x;
            d->d2=warpdestsel_y;
            sprintf((char *)d->dp, "at: %dx%d", warpdestsel_x, warpdestsel_y);
            break;
            
        case 2:
            d->d1=-1;
            d->d2=-1;
            sprintf((char *)d->dp, "at: warp square");
            break;
            
        case 3:
            d->d1=-2;
            d->d2=-2;
            sprintf((char *)d->dp, "at: origin");
            break;
            
        default:
            break;
        }
        
        d->flags|=D_DIRTY;
    }
    
    return ret?D_O_K:D_O_K;
}
#endif

int32_t jwin_minibutton_proc(int32_t msg,DIALOG *d,int32_t c)
{
    switch(msg)
    {
    case MSG_DRAW:
        jwin_draw_text_button(screen, d->x, d->y, d->w, d->h, (char*)d->dp, d->flags, false);
        return D_O_K;
        break;
    }
    
    return jwin_button_proc(msg,d,c);
}

int32_t d_triggerbutton_proc(int32_t msg,DIALOG *d,int32_t c)
{
    static BITMAP *dummy=create_bitmap_ex(8, 1, 1);
    
    switch(msg)
    {
    case MSG_START:
        d->w=gui_textout_ln(dummy, font, (uint8_t *)d->dp, 0, 0, jwin_pal[jcMEDDARK], -1, 0)+4;
        d->h=text_height(font)+5;
        break;
        
    case MSG_GOTFOCUS:
        d->flags&=~D_GOTFOCUS;
        break;
        
    }
    
    return jwin_minibutton_proc(msg,d,c);
}

int32_t d_alltriggerbutton_proc(int32_t msg,DIALOG *d,int32_t c)
{
    DIALOG *temp_d;
    int32_t ret=d_triggerbutton_proc(msg,d,c);
    
    switch(msg)
    {
    case MSG_CLICK:
        temp_d=d-1;
        
        while(temp_d->proc==d_triggerbutton_proc)
        {
            temp_d->flags&=~D_SELECTED;
            temp_d->flags|=D_DIRTY;
            
            if(d->flags&D_SELECTED)
            {
                temp_d->flags|=D_SELECTED;
            }
            
            --temp_d;
        }
        
        break;
    }
    
    return ret;
}

int32_t d_ticsedit_proc(int32_t msg,DIALOG *d,int32_t c)
{
    int32_t ret = jwin_edit_proc(msg,d,c);
    
    if(msg==MSG_DRAW)
    {
        scare_mouse();
        int32_t tics=vbound(atoi((char*)d->dp),0,65535);
        sprintf((char*)(d+1)->dp,"%s %s",ticksstr(tics),tics==0?"(No Timed Warp)":"               ");
        object_message(d+1,MSG_DRAW,c);
        unscare_mouse();
    }
    
    return ret;
}

static ListData warp_effect_list(warpeffectlist,&font);

#if 0
static DIALOG warp_dlg2[] =
{
    /* (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp) */
    { jwin_win_proc,                 0,      0,    320,    240,    vc(14),                 vc(1),                   0,       D_EXIT,     0,             0, (void *) "Edit Warps",        NULL,   NULL              },
    { jwin_button_proc,             70,    215,     41,     21,    vc(14),                 vc(1),                   'k',     D_EXIT,     0,             0, (void *) "O&K",               NULL,   NULL              },
    { jwin_button_proc,            130,    215,     41,     21,    vc(14),                 vc(1),                   'g',     D_EXIT,     0,             0, (void *) "&Go",               NULL,   NULL              },
    { jwin_button_proc,            190,    215,     61,     21,    vc(14),                 vc(1),                  27,       D_EXIT,     0,             0, (void *) "Cancel",            NULL,   NULL              },
    { d_keyboard_proc,               0,      0,      0,      0,    0,                      0,                       0,       0,          KEY_F1,        0, (void *) onHelp,              NULL,   NULL              },
    //5
    { jwin_tab_proc,                 6,     25,    308,    184,    0,                      0,                       0,       0,          0,             0, (void *) warp_tabs,           NULL, (void *)warp_dlg  },
    { jwin_tab_proc,                10,     45,    300,    159,    0,                      0,                       0,       0,          0,             0, (void *) side_warp_tabs,      NULL, (void *)warp_dlg  },
    { jwin_tab_proc,                10,     45,    300,    159,    0,                      0,                       0,       0,          0,             0, (void *) wind_warp_tabs,      NULL, (void *)warp_dlg  },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    //10
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    //15
    { jwin_text_proc,               14,     69,      0,      8,    vc(11),                 vc(1),                   0,       0,          0,             0, (void *) "Type:",             NULL,   NULL              },
    { jwin_text_proc,               14,     87,      0,      8,    vc(11),                 vc(1),                   0,       0,          0,             0, (void *) "DMap:",             NULL,   NULL              },
    { jwin_droplist_proc,           43,     65,    111,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,       0,          0,             0, (void *) &warp_dlg_list,      NULL,   NULL              },
    { d_dropdmaplist_proc,          43,     83,    222,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,       0,          0,             0, (void *) &dmap_list,          NULL,   warpdmapxy        },
    { d_dmapscrsel_proc,            45,    108,     65,     33,    vc(14),                 vc(5),                   0,       0,          1,             0,  NULL,                         NULL,   NULL              },
    //20
    { jwin_text_proc,              116,    110,      0,      8,    vc(11),                 vc(1),                   0,       0,          0,             0, (void *) "Screen:",        NULL,   NULL              },
    { jwin_edit_proc,              166,    106,     21,     16,    vc(11),                 vc(1),                   0,       0,          2,             0,  NULL,                         NULL,   NULL              },
    { d_warpbutton_proc,           191,    104,     90,     21,    vc(14),                 vc(1),                   0,       D_EXIT,    -1,            -1,  NULL,                         NULL,   NULL              },
    { jwin_check_proc,             116,    121,    129,      9,    vc(14),                 vc(1),                   0,       0,          1,             0, (void *) "Enabled",           NULL,   NULL              },
    { jwin_check_proc,             116,    132,    129,      9,    vc(14),                 vc(1),                   0,       0,          1,             0, (void *) "Full Screen",       NULL,   NULL              },
    //25
    { jwin_text_proc,               14,    149,      0,      8,    vc(11),                 vc(1),                   0,       0,          0,             0, (void *) "Out Effect:",       NULL,   NULL              },
    { jwin_text_proc,               14,    167,      0,      8,    vc(11),                 vc(1),                   0,       0,          0,             0, (void *) "In Effect:",        NULL,   NULL              },
    { jwin_droplist_proc,           68,    145,    137,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,       0,          0,             0, (void *) &warp_effect_list,   NULL,   NULL              },
    { jwin_droplist_proc,           68,    163,    137,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,       0,          0,             0, (void *) &warp_effect_list,   NULL,   NULL              },
    { jwin_text_proc,               14,    185,      0,      8,    vc(11),                 vc(1),                   0,       0,          0,             0, (void *) "Tics:",             NULL,   NULL              },
    //30
    { d_ticsedit_proc,              40,    181,     36,     16,    vc(11),                 vc(1),                   0,       0,          5,             0,  NULL,                         NULL,   NULL              },
    { jwin_text_proc,               77,    185,      0,      8,    vc(11),                 vc(1),                   0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { jwin_frame_proc,             211,    132,     95,     64,    0,                      0,                       0,       0,          FR_ETCHED,     0,  NULL,                         NULL,   NULL              },
    { jwin_text_proc,              215,    129,     40,      8,    vc(0),                  vc(11),                  0,       0,          0,             0, (void *) " Triggers ",        NULL,   NULL              },
    { d_triggerbutton_proc,        215,    139,    129,      9,    vc(14),                 vc(1),                   0,       0,          1,             0, (void *) "Up",                NULL,   NULL              },
    //35
    { d_triggerbutton_proc,        229,    139,    129,      9,    vc(14),                 vc(1),                   0,       0,          1,             0, (void *) "Down",              NULL,   NULL              },
    { d_triggerbutton_proc,        254,    139,    129,      9,    vc(14),                 vc(1),                   0,       0,          1,             0, (void *) "Left",              NULL,   NULL              },
    { d_triggerbutton_proc,        277,    139,    129,      9,    vc(14),                 vc(1),                   0,       0,          1,             0, (void *) "Right",             NULL,   NULL              },
    { d_triggerbutton_proc,        221,    152,    129,      9,    vc(14),                 vc(1),                   0,       0,          1,             0, (void *) "A",                 NULL,   NULL              },
    { d_triggerbutton_proc,        230,    152,    129,      9,    vc(14),                 vc(1),                   0,       0,          1,             0, (void *) "B",                 NULL,   NULL              },
    //40
    { d_triggerbutton_proc,        239,    152,    129,      9,    vc(14),                 vc(1),                   0,       0,          1,             0, (void *) "X",                 NULL,   NULL              },
    { d_triggerbutton_proc,        249,    152,    129,      9,    vc(14),                 vc(1),                   0,       0,          1,             0, (void *) "Y",                 NULL,   NULL              },
    { d_triggerbutton_proc,        259,    152,    129,      9,    vc(14),                 vc(1),                   0,       0,          1,             0, (void *) "L",                 NULL,   NULL              },
    { d_triggerbutton_proc,        268,    152,    129,      9,    vc(14),                 vc(1),                   0,       0,          1,             0, (void *) "R",                 NULL,   NULL              },
    { d_triggerbutton_proc,        277,    152,    129,      9,    vc(14),                 vc(1),                   0,       0,          1,             0, (void *) "Map",               NULL,   NULL              },
    //45
    { d_triggerbutton_proc,        230,    165,    129,      9,    vc(14),                 vc(1),                   0,       0,          1,             0, (void *) "Select",            NULL,   NULL              },
    { d_triggerbutton_proc,        260,    165,    129,      9,    vc(14),                 vc(1),                   0,       0,          1,             0, (void *) "Start",             NULL,   NULL              },
    { d_alltriggerbutton_proc,     252,    179,    129,      9,    vc(14),                 vc(1),                   0,       0,          1,             0, (void *) "All",               NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { d_dummy_proc,                  0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              },
    { NULL,                          0,      0,      0,      0,    0,                      0,                       0,       0,          0,             0,  NULL,                         NULL,   NULL              }
};
#endif

int32_t onTileWarp()
{
    int32_t tempx5=warp_dlg[5].x;
    int32_t tempx6=warp_dlg[6].x;
    int32_t tempx10=warp_dlg[10].x;
    int32_t tempx11=warp_dlg[11].x;
    int32_t tempx12=warp_dlg[12].x;
    int32_t tempx13=warp_dlg[13].x;
    
    int32_t tempx20=warp_dlg[20].x;
    int32_t tempx21=warp_dlg[21].x;
    int32_t tempx25=warp_dlg[25].x;
    int32_t tempx26=warp_dlg[26].x;
    int32_t tempx27=warp_dlg[27].x;
    int32_t tempx28=warp_dlg[28].x;
    
    int32_t tempx32=warp_dlg[32].x;
    int32_t tempx33=warp_dlg[33].x;
    int32_t tempx37=warp_dlg[37].x;
    int32_t tempx38=warp_dlg[38].x;
    int32_t tempx39=warp_dlg[39].x;
    int32_t tempx40=warp_dlg[40].x;
    
    int32_t tempx44=warp_dlg[44].x;
    int32_t tempx45=warp_dlg[45].x;
    int32_t tempx49=warp_dlg[49].x;
    int32_t tempx50=warp_dlg[50].x;
    int32_t tempx51=warp_dlg[51].x;
    int32_t tempx52=warp_dlg[52].x;
    restore_mouse();
    warp_dlg[0].dp=(void *) "Tile Warp";
    warp_dlg[0].dp2=lfont;
    warp_dlg[5].x = screen->w + 10;
    warp_dlg[6].x = screen->w + 10;
    warp_dlg[10].x = screen->w + 10;
    warp_dlg[11].x = screen->w + 10;
    warp_dlg[12].x = screen->w + 10;
    warp_dlg[13].x = screen->w + 10;
    warp_dlg[20].x = screen->w + 10;
    warp_dlg[21].x = screen->w + 10;
    warp_dlg[25].x = screen->w + 10;
    warp_dlg[26].x = screen->w + 10;
    warp_dlg[27].x = screen->w + 10;
    warp_dlg[28].x = screen->w + 10;
    warp_dlg[32].x = screen->w + 10;
    warp_dlg[33].x = screen->w + 10;
    warp_dlg[37].x = screen->w + 10;
    warp_dlg[38].x = screen->w + 10;
    warp_dlg[39].x = screen->w + 10;
    warp_dlg[40].x = screen->w + 10;
    warp_dlg[44].x = screen->w + 10;
    warp_dlg[45].x = screen->w + 10;
    warp_dlg[49].x = screen->w + 10;
    warp_dlg[50].x = screen->w + 10;
    warp_dlg[51].x = screen->w + 10;
    warp_dlg[52].x = screen->w + 10;
    
    for(int32_t i=0; i<4; i++)
    {
        warp_dlg[10+i].d2 = 0;
        warp_dlg[25+i].d2 = 0;
        warp_dlg[37+i].d2 = 0;
        warp_dlg[49+i].d2 = 0;
    }
    
    char buf[10];
    char buf2[10];
    char buf3[10];
    char buf4[10];
    sprintf(buf,"%02X",Map.CurrScr()->tilewarpscr[0]);
    warp_dlg[7].d1=Map.CurrScr()->tilewarptype[0];
    warp_dlg[8].d1=Map.CurrScr()->tilewarpdmap[0];
    warp_dlg[9].dp=buf;
    
    sprintf(buf2,"%02X",Map.CurrScr()->tilewarpscr[1]);
    warp_dlg[22].d1=Map.CurrScr()->tilewarptype[1];
    warp_dlg[23].d1=Map.CurrScr()->tilewarpdmap[1];
    warp_dlg[24].dp=buf2;
    
    sprintf(buf3,"%02X",Map.CurrScr()->tilewarpscr[2]);
    warp_dlg[34].d1=Map.CurrScr()->tilewarptype[2];
    warp_dlg[35].d1=Map.CurrScr()->tilewarpdmap[2];
    warp_dlg[36].dp=buf3;
    
    sprintf(buf4,"%02X",Map.CurrScr()->tilewarpscr[3]);
    warp_dlg[46].d1=Map.CurrScr()->tilewarptype[3];
    warp_dlg[47].d1=Map.CurrScr()->tilewarpdmap[3];
    warp_dlg[48].dp=buf4;
    
    warp_dlg[63].flags = get_bit(&Map.CurrScr()->tilewarpoverlayflags,0)?D_SELECTED:0;
    warp_dlg[64].flags = get_bit(&Map.CurrScr()->tilewarpoverlayflags,1)?D_SELECTED:0;
    warp_dlg[65].flags = get_bit(&Map.CurrScr()->tilewarpoverlayflags,2)?D_SELECTED:0;
    warp_dlg[66].flags = get_bit(&Map.CurrScr()->tilewarpoverlayflags,3)?D_SELECTED:0;
    
    word j=Map.CurrScr()->warpreturnc;
    warp_dlg[54].d1=(j&3);
    warp_dlg[56].d1=((j>>2)&3);
    warp_dlg[58].d1=((j>>4)&3);
    warp_dlg[60].d1=((j>>6)&3);
    warp_dlg[2].fg=vc(14);
    warp_dlg[17].fg=vc(14);
    warp_dlg[29].fg=vc(14);
    warp_dlg[41].fg=vc(14);
    //warp_dlg[5].fg=vc(7);
    //for(int32_t i=0; i<4; i++)
    //warp_dlg[10+i].d2 = 0;
    dmap_list_size=MAXDMAPS;
    dmap_list_zero=true;
    
    if(is_large)
    {
        large_dialog(warp_dlg);
        
        if(warp_dlg[0].d1<2)
        {
            warp_dlg[0].d1=2;
            warp_dlg[6].x += 2;
            warp_dlg[10].w -= 8;
            warp_dlg[10].y -= 4;
            warp_dlg[11].w -= 8;
            warp_dlg[11].y -= 2;
            warp_dlg[12].h -= 8;
            warp_dlg[12].x -= 2;
            warp_dlg[12].y -= 2;
            warp_dlg[13].h -= 8;
            warp_dlg[13].x += 1;
            warp_dlg[13].y -= 2;
            
            warp_dlg[21].x += 2;
            warp_dlg[25].w -= 8;
            warp_dlg[25].y -= 4;
            warp_dlg[26].w -= 8;
            warp_dlg[26].y -= 2;
            warp_dlg[27].h -= 8;
            warp_dlg[27].x -= 2;
            warp_dlg[27].y -= 2;
            warp_dlg[28].h -= 8;
            warp_dlg[28].x += 1;
            warp_dlg[28].y -= 2;
            
            warp_dlg[33].x += 2;
            warp_dlg[37].w -= 8;
            warp_dlg[37].y -= 4;
            warp_dlg[38].w -= 8;
            warp_dlg[38].y -= 2;
            warp_dlg[39].h -= 8;
            warp_dlg[39].x -= 2;
            warp_dlg[39].y -= 2;
            warp_dlg[40].h -= 8;
            warp_dlg[40].x += 1;
            warp_dlg[40].y -= 2;
            
            warp_dlg[45].x += 2;
            warp_dlg[49].w -= 8;
            warp_dlg[49].y -= 4;
            warp_dlg[50].w -= 8;
            warp_dlg[50].y -= 2;
            warp_dlg[51].h -= 8;
            warp_dlg[51].x -= 2;
            warp_dlg[51].y -= 2;
            warp_dlg[52].h -= 8;
            warp_dlg[52].x += 1;
            warp_dlg[52].y -= 2;
        }
        
        for(int32_t i=0; i<4; i++)
        {
            warp_dlg[i+67].x=493;
            warp_dlg[i+67].y=329;
            warp_dlg[i+67].w=64;
            warp_dlg[i+67].h=32;
        }
    }
    
    int32_t ret=zc_popup_dialog(warp_dlg,-1);
    
    if(ret==14 || ret==15)
    {
        saved=false;
        Map.CurrScr()->tilewarpscr[0] = zc_xtoi(buf);
        Map.CurrScr()->tilewarptype[0] = warp_dlg[7].d1;
        Map.CurrScr()->tilewarpdmap[0] = warp_dlg[8].d1;
        Map.CurrScr()->tilewarpscr[1] = zc_xtoi(buf2);
        Map.CurrScr()->tilewarptype[1] = warp_dlg[22].d1;
        Map.CurrScr()->tilewarpdmap[1] = warp_dlg[23].d1;
        Map.CurrScr()->tilewarpscr[2] = zc_xtoi(buf3);
        Map.CurrScr()->tilewarptype[2] = warp_dlg[34].d1;
        Map.CurrScr()->tilewarpdmap[2] = warp_dlg[35].d1;
        Map.CurrScr()->tilewarpscr[3] = zc_xtoi(buf4);
        Map.CurrScr()->tilewarptype[3] = warp_dlg[46].d1;
        Map.CurrScr()->tilewarpdmap[3] = warp_dlg[47].d1;
        
        Map.CurrScr()->tilewarpoverlayflags=0;
        set_bit(&Map.CurrScr()->tilewarpoverlayflags,0,(warp_dlg[63].flags & D_SELECTED)?1:0);
        set_bit(&Map.CurrScr()->tilewarpoverlayflags,1,(warp_dlg[64].flags & D_SELECTED)?1:0);
        set_bit(&Map.CurrScr()->tilewarpoverlayflags,2,(warp_dlg[65].flags & D_SELECTED)?1:0);
        set_bit(&Map.CurrScr()->tilewarpoverlayflags,3,(warp_dlg[66].flags & D_SELECTED)?1:0);
        
        j=Map.CurrScr()->warpreturnc&0xFF00;
        word newWarpReturns=0;
        newWarpReturns|=warp_dlg[60].d1;
        newWarpReturns<<=2;
        newWarpReturns|=warp_dlg[58].d1;
        newWarpReturns<<=2;
        newWarpReturns|=warp_dlg[56].d1;
        newWarpReturns<<=2;
        newWarpReturns|=warp_dlg[54].d1;
        j|=newWarpReturns;
        Map.CurrScr()->warpreturnc = j;
        refresh(rMENU);
        
    }
    
    if(ret==15)
    {
        int32_t index=0;
        
        if(warp_tabs[0].flags & D_SELECTED) index = 0;
        
        if(warp_tabs[1].flags & D_SELECTED) index = 1;
        
        if(warp_tabs[2].flags & D_SELECTED) index = 2;
        
        if(warp_tabs[3].flags & D_SELECTED) index = 3;
        
        FlashWarpSquare = -1;
        int32_t tm = Map.getCurrMap();
        int32_t ts = Map.getCurrScr();
        int32_t thistype = Map.CurrScr()->tilewarptype[index];
        Map.dowarp(0,index);
        
        if((ts!=Map.getCurrScr() || tm!=Map.getCurrMap()) && thistype != wtCAVE && thistype != wtSCROLL)
        {
            FlashWarpSquare = (TheMaps[tm*MAPSCRS+ts].warpreturnc>>(index*2))&3;
            FlashWarpClk = 32;
        }
        
        refresh(rALL);
    }
    
    warp_dlg[5].x = tempx5;
    warp_dlg[6].x = tempx6;
    warp_dlg[10].x = tempx10;
    warp_dlg[11].x = tempx11;
    warp_dlg[12].x = tempx12;
    warp_dlg[13].x = tempx13;
    
    warp_dlg[20].x = tempx20;
    warp_dlg[21].x = tempx21;
    warp_dlg[25].x = tempx25;
    warp_dlg[26].x = tempx26;
    warp_dlg[27].x = tempx27;
    warp_dlg[28].x = tempx28;
    
    warp_dlg[32].x = tempx32;
    warp_dlg[33].x = tempx33;
    warp_dlg[37].x = tempx37;
    warp_dlg[38].x = tempx38;
    warp_dlg[39].x = tempx39;
    warp_dlg[40].x = tempx40;
    
    warp_dlg[44].x = tempx44;
    warp_dlg[45].x = tempx45;
    warp_dlg[49].x = tempx49;
    warp_dlg[50].x = tempx50;
    warp_dlg[51].x = tempx51;
    warp_dlg[52].x = tempx52;
    
    for(int32_t i=0; i<4; i++)
    {
        warp_dlg[10+i].d2 = 0x80;
        warp_dlg[25+i].d2 = 0x80;
        warp_dlg[37+i].d2 = 0x80;
        warp_dlg[49+i].d2 = 0x80;
    }
    
    return D_O_K;
}

int32_t onSideWarp()
{
    restore_mouse();
    warp_dlg[0].dp=(void *) "Side Warp";
    warp_dlg[0].dp2=lfont;
    warp_dlg[7].flags = 0;
    warp_dlg[22].flags = 0;
    warp_dlg[34].flags = 0;
    warp_dlg[46].flags = 0;
    
    char buf[10];
    char buf2[10];
    char buf3[10];
    char buf4[10];
    sprintf(buf,"%02X",Map.CurrScr()->sidewarpscr[0]);
    warp_dlg[7].d1=Map.CurrScr()->sidewarptype[0];
    warp_dlg[8].d1=Map.CurrScr()->sidewarpdmap[0];
    warp_dlg[9].dp=buf;
    
    sprintf(buf2,"%02X",Map.CurrScr()->sidewarpscr[1]);
    warp_dlg[22].d1=Map.CurrScr()->sidewarptype[1];
    warp_dlg[23].d1=Map.CurrScr()->sidewarpdmap[1];
    warp_dlg[24].dp=buf2;
    
    sprintf(buf3,"%02X",Map.CurrScr()->sidewarpscr[2]);
    warp_dlg[34].d1=Map.CurrScr()->sidewarptype[2];
    warp_dlg[35].d1=Map.CurrScr()->sidewarpdmap[2];
    warp_dlg[36].dp=buf3;
    
    sprintf(buf4,"%02X",Map.CurrScr()->sidewarpscr[3]);
    warp_dlg[46].d1=Map.CurrScr()->sidewarptype[3];
    warp_dlg[47].d1=Map.CurrScr()->sidewarpdmap[3];
    warp_dlg[48].dp=buf4;
    
    warp_dlg[63].flags = get_bit(&Map.CurrScr()->sidewarpoverlayflags,0)?D_SELECTED:0;
    warp_dlg[64].flags = get_bit(&Map.CurrScr()->sidewarpoverlayflags,1)?D_SELECTED:0;
    warp_dlg[65].flags = get_bit(&Map.CurrScr()->sidewarpoverlayflags,2)?D_SELECTED:0;
    warp_dlg[66].flags = get_bit(&Map.CurrScr()->sidewarpoverlayflags,3)?D_SELECTED:0;
    
    word j=Map.CurrScr()->warpreturnc>>8;
    warp_dlg[54].d1=(j&3);
    warp_dlg[56].d1=((j>>2)&3);
    warp_dlg[58].d1=((j>>4)&3);
    warp_dlg[60].d1=((j>>6)&3);
    
    warp_dlg[2].fg=warp_dlg[5].fg=vc(14);
    warp_dlg[17].fg=warp_dlg[20].fg=vc(14);
    warp_dlg[29].fg=warp_dlg[32].fg=vc(14);
    warp_dlg[41].fg=warp_dlg[44].fg=vc(14);
    byte f=Map.CurrScr()->flags2;
    byte h=Map.CurrScr()->sidewarpindex;
    byte g=f&240;
    
    for(int32_t i=0; i<4; i++)
    {
        warp_dlg[10+i].d2 = 0x80;
        warp_dlg[25+i].d2 = 0x80;
        warp_dlg[37+i].d2 = 0x80;
        warp_dlg[49+i].d2 = 0x80;
        
        if(f&1)
        {
            warp_dlg[10+i].flags = D_SELECTED ;
            warp_dlg[10+i].d2 |= h&3;
            warp_dlg[25+i].flags = D_SELECTED ;
            warp_dlg[25+i].d2 |= h&3;
            warp_dlg[37+i].flags = D_SELECTED ;
            warp_dlg[37+i].d2 |= h&3;
            warp_dlg[49+i].flags = D_SELECTED ;
            warp_dlg[49+i].d2 |= h&3;
        }
        else
        {
            warp_dlg[10+i].flags = 0;
            warp_dlg[25+i].flags = 0;
            warp_dlg[37+i].flags = 0;
            warp_dlg[49+i].flags = 0;
        }
        
        f>>=1;
        h>>=2;
    }
    
    dmap_list_size=MAXDMAPS;
    dmap_list_zero=true;
    
    if(is_large)
    {
        large_dialog(warp_dlg);
        
        if(warp_dlg[0].d1<2)
        {
            warp_dlg[0].d1=2;
            warp_dlg[6].x += 2;
            warp_dlg[10].w -= 8;
            warp_dlg[10].y -= 4;
            warp_dlg[11].w -= 8;
            warp_dlg[11].y -= 2;
            warp_dlg[12].h -= 8;
            warp_dlg[12].x -= 2;
            warp_dlg[12].y -= 2;
            warp_dlg[13].h -= 8;
            warp_dlg[13].x += 1;
            warp_dlg[13].y -= 2;
            
            warp_dlg[21].x += 2;
            warp_dlg[25].w -= 8;
            warp_dlg[25].y -= 4;
            warp_dlg[26].w -= 8;
            warp_dlg[26].y -= 2;
            warp_dlg[27].h -= 8;
            warp_dlg[27].x -= 2;
            warp_dlg[27].y -= 2;
            warp_dlg[28].h -= 8;
            warp_dlg[28].x += 1;
            warp_dlg[28].y -= 2;
            
            warp_dlg[33].x += 2;
            warp_dlg[37].w -= 8;
            warp_dlg[37].y -= 4;
            warp_dlg[38].w -= 8;
            warp_dlg[38].y -= 2;
            warp_dlg[39].h -= 8;
            warp_dlg[39].x -= 2;
            warp_dlg[39].y -= 2;
            warp_dlg[40].h -= 8;
            warp_dlg[40].x += 1;
            warp_dlg[40].y -= 2;
            
            warp_dlg[45].x += 2;
            warp_dlg[49].w -= 8;
            warp_dlg[49].y -= 4;
            warp_dlg[50].w -= 8;
            warp_dlg[50].y -= 2;
            warp_dlg[51].h -= 8;
            warp_dlg[51].x -= 2;
            warp_dlg[51].y -= 2;
            warp_dlg[52].h -= 8;
            warp_dlg[52].x += 1;
            warp_dlg[52].y -= 2;
        }
    }
    
    int32_t ret=zc_popup_dialog(warp_dlg,-1);
    
    if(ret==14 || ret==15)
    {
        saved=false;
        Map.CurrScr()->sidewarpscr[0] = zc_xtoi(buf);
        Map.CurrScr()->sidewarptype[0] = warp_dlg[7].d1;
        Map.CurrScr()->sidewarpdmap[0] = warp_dlg[8].d1;
        Map.CurrScr()->sidewarpscr[1] = zc_xtoi(buf2);
        Map.CurrScr()->sidewarptype[1] = warp_dlg[22].d1;
        Map.CurrScr()->sidewarpdmap[1] = warp_dlg[23].d1;
        Map.CurrScr()->sidewarpscr[2] = zc_xtoi(buf3);
        Map.CurrScr()->sidewarptype[2] = warp_dlg[34].d1;
        Map.CurrScr()->sidewarpdmap[2] = warp_dlg[35].d1;
        Map.CurrScr()->sidewarpscr[3] = zc_xtoi(buf4);
        Map.CurrScr()->sidewarptype[3] = warp_dlg[46].d1;
        Map.CurrScr()->sidewarpdmap[3] = warp_dlg[47].d1;
        
        Map.CurrScr()->sidewarpoverlayflags=0;
        set_bit(&Map.CurrScr()->sidewarpoverlayflags,0,(warp_dlg[63].flags & D_SELECTED)?1:0);
        set_bit(&Map.CurrScr()->sidewarpoverlayflags,1,(warp_dlg[64].flags & D_SELECTED)?1:0);
        set_bit(&Map.CurrScr()->sidewarpoverlayflags,2,(warp_dlg[65].flags & D_SELECTED)?1:0);
        set_bit(&Map.CurrScr()->sidewarpoverlayflags,3,(warp_dlg[66].flags & D_SELECTED)?1:0);
        
        f=0;
        h=0;
        
        for(int32_t i=3; i>=0; i--)
        {
            f<<=1;
            h<<=2;
            //f |= warp_dlg[49+i].flags&D_SELECTED ? 1 : 0;
            //f |= warp_dlg[37+i].flags&D_SELECTED ? 1 : 0;
            //f |= warp_dlg[25+i].flags&D_SELECTED ? 1 : 0;
            f |= warp_dlg[10+i].flags&D_SELECTED ? 1 : 0;
            int32_t t=0;
            /*if(warp_dlg[10+i].flags&D_SELECTED) t=0;
              else if(warp_dlg[25+i].flags&D_SELECTED) t=1;
              else if(warp_dlg[37+i].flags&D_SELECTED) t=2;
              else if(warp_dlg[49+i].flags&D_SELECTED) t=3;*/
            t=warp_dlg[10+i].d2&3;
            h|=t;
        }
        
        f+=g;
        Map.CurrScr()->flags2 = f;
        Map.CurrScr()->sidewarpindex = h;
        
        j=Map.CurrScr()->warpreturnc&0x00FF;
        word newWarpReturns=0;
        newWarpReturns|=warp_dlg[60].d1;
        newWarpReturns<<=2;
        newWarpReturns|=warp_dlg[58].d1;
        newWarpReturns<<=2;
        newWarpReturns|=warp_dlg[56].d1;
        newWarpReturns<<=2;
        newWarpReturns|=warp_dlg[54].d1;
        newWarpReturns<<=8;
        j|=newWarpReturns;
        Map.CurrScr()->warpreturnc = j;
        refresh(rMENU);
    }
    
    if(ret==15)
    {
        int32_t index=0;
        
        if(warp_tabs[0].flags & D_SELECTED) index = 0;
        
        if(warp_tabs[1].flags & D_SELECTED) index = 1;
        
        if(warp_tabs[2].flags & D_SELECTED) index = 2;
        
        if(warp_tabs[3].flags & D_SELECTED) index = 3;
        
        FlashWarpSquare = -1;
        int32_t tm = Map.getCurrMap();
        int32_t ts = Map.getCurrScr();
        int32_t thistype = Map.CurrScr()->sidewarptype[index];
        Map.dowarp(1,index);
        
        if((ts!=Map.getCurrScr() || tm!=Map.getCurrMap()) && thistype != wtSCROLL)
        {
            FlashWarpSquare = (TheMaps[tm*MAPSCRS+ts].warpreturnc>>(8+index*2))&3;
            FlashWarpClk = 0x20;
        }
        
        refresh(rALL);
    }
    
    return D_O_K;
}



const char *dirlist(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        if(index>3)
            index=3;
            
        return dirstr[index];
    }
    
    *list_size=4;
    return NULL;
}

static ListData path_dlg_list(dirlist, &font);

static DIALOG path_dlg[] =
{
    /* (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp) */
    { jwin_win_proc,      80,   57,   161,  164,  vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "Maze Path", NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { jwin_text_proc,       94,   106,   192,  8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "1st", NULL, NULL },
    { jwin_text_proc,       94,   124,  192,  8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "2nd", NULL, NULL },
    { jwin_text_proc,       94,   142,  192,  8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "3rd", NULL, NULL },
    { jwin_text_proc,       94,   160,  192,  8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "4th", NULL, NULL },
    { jwin_text_proc,       94,   178,  192,  8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Exit", NULL, NULL },
    { jwin_droplist_proc,   140,  102,   80+1,   16,   jwin_pal[jcTEXTFG], jwin_pal[jcTEXTBG],  0,       0,          0,             0, (void *) &path_dlg_list, NULL, NULL },
    { jwin_droplist_proc,   140,  120,   80+1,   16,   jwin_pal[jcTEXTFG], jwin_pal[jcTEXTBG],  0,       0,          0,             0, (void *) &path_dlg_list, NULL, NULL },
    { jwin_droplist_proc,   140,  138,  80+1,   16,   jwin_pal[jcTEXTFG], jwin_pal[jcTEXTBG],  0,       0,          0,             0, (void *) &path_dlg_list, NULL, NULL },
    { jwin_droplist_proc,   140,  156,  80+1,   16,   jwin_pal[jcTEXTFG], jwin_pal[jcTEXTBG],  0,       0,          0,             0, (void *) &path_dlg_list, NULL, NULL },
    { jwin_droplist_proc,   140,  174,  80+1,   16,   jwin_pal[jcTEXTFG], jwin_pal[jcTEXTBG],  0,       0,          0,             0, (void *) &path_dlg_list, NULL, NULL },
    { jwin_button_proc,     90,   194,  61,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "OK", NULL, NULL },
    { jwin_button_proc,     170,  194,  61,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_F1,   0, (void *) onHelp, NULL, NULL },
    { jwin_text_proc,       87,   82,   192,  8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "A Lost Woods-style maze screen", NULL, NULL },
    { jwin_text_proc,       87,   92,   192,  8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "with a normal and secret exit.", NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

int32_t onPath()
{
    restore_mouse();
    path_dlg[0].dp2=lfont;
    
    for(int32_t i=0; i<4; i++)
        path_dlg[i+7].d1 = Map.CurrScr()->path[i];
        
    path_dlg[11].d1 = Map.CurrScr()->exitdir;
    
    if(is_large)
        large_dialog(path_dlg);
        
    int32_t ret;
    
    do
    {
        ret=zc_popup_dialog(path_dlg,7);
        
        if(ret==12) for(int32_t i=0; i<4; i++)
            {
                if(path_dlg[i+7].d1 == path_dlg[11].d1)
                {
                    if(jwin_alert("Exit Problem","One of the path's directions is","also the normal Exit direction! Continue?",NULL,"Yes","No",'y','n',lfont)==2)
                        ret = -1;
                        
                    break;
                }
            }
    }
    while(ret == -1);
    
    if(ret==12)
    {
        saved=false;
        
        for(int32_t i=0; i<4; i++)
            Map.CurrScr()->path[i] = path_dlg[i+7].d1;
            
        Map.CurrScr()->exitdir = path_dlg[11].d1;
        
        if(!(Map.CurrScr()->flags&fMAZE))
            if(jwin_alert("Screen Flag","Turn on the 'Use Maze Path' Screen Flag?","(Go to 'Screen Data' to turn it off.)",NULL,"Yes","No",'y','n',lfont)==1)
                Map.CurrScr()->flags |= fMAZE;
    }
    
    refresh(rMAP+rMENU);
    return D_O_K;
}



static DIALOG editinfo_dlg[] =
{
    // (dialog proc)     (x)   (y)   (w)   (h)   (fg)                 (bg)                  (key)    (flags)     (d1)           (d2)     (dp)
    { jwin_win_proc,       0,   10,  208,  204,  vc(14),              vc(1),                  0,      D_EXIT,     0,             0,       NULL, NULL, NULL },
    { d_timer_proc,        0,    0,    0,    0,  0,                   0,                      0,           0,     0,             0,       NULL, NULL, NULL },
    { jwin_text_proc,     24,   60,   48,    8,  vc(7),               vc(1),                  0,           0,     0,             0, (void *) "1st", NULL, NULL },
    { jwin_text_proc,     24,  106,   48,    8,  vc(7),               vc(1),                  0,           0,     0,             0, (void *) "2nd", NULL, NULL },
    { jwin_text_proc,     24,  152,   48,    8,  vc(7),               vc(1),                  0,           0,     0,             0, (void *) "3rd", NULL, NULL },
    { jwin_text_proc,     56,   60,   88,    8,  vc(14),              vc(1),                  0,           0,     0,             0, (void *) "Price:", NULL, NULL },
    { jwin_text_proc,     56,  106,   88,    8,  vc(14),              vc(1),                  0,           0,     0,             0, (void *) "Price:", NULL, NULL },
    { jwin_text_proc,     56,  152,   88,    8,  vc(14),              vc(1),                  0,           0,     0,             0, (void *) "Price:", NULL, NULL },
    // 8
    { jwin_edit_proc,     86,   56,   32,   16,  vc(12),              vc(1),                  0,           0,     5,             0,       NULL, NULL, NULL },
    { d_ndroplist_proc,   56,   74,  137,   16,  jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],     0,           0,     0,             0,       NULL, NULL, NULL },
    { jwin_edit_proc,     86,  102,   32,   16,  vc(12),              vc(1),                  0,           0,     5,             0,       NULL, NULL, NULL },
    { d_ndroplist_proc,   56,  120,  137,   16,  jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],     0,           0,     0,             0,       NULL, NULL, NULL },
    { jwin_edit_proc,     86,  148,   32,   16,  vc(12),              vc(1),                  0,           0,     5,             0,       NULL, NULL, NULL },
    { d_ndroplist_proc,   56,  166,  137,   16,  jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],     0,           0,     0,             0,       NULL, NULL, NULL },
    { jwin_text_proc,     24,   42,   88,    8,  vc(14),              vc(1),                  0,           0,     0,             0, (void *) "Name:", NULL, NULL },
    { jwin_edit_proc,     56,   38,  137,   16,  vc(12),              vc(1),                  0,           0,    31,             0,       NULL, NULL, NULL },
    // 16
    { jwin_button_proc,   34,  188,   61,   21,  vc(14),              vc(1),                 13,      D_EXIT,     0,             0, (void *) "OK", NULL, NULL },
    { jwin_button_proc,  114,  188,   61,   21,  vc(14),              vc(1),                 27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { NULL,                0,    0,    0,    0,  0,                   0,                      0,           0,     0,             0,       NULL,                           NULL,  NULL }
};

void EditInfoType(int32_t index)
{
    char ps1[6],ps2[6],ps3[6];
    char infoname[32];
    char caption[40];
    
    int32_t str1, str2, str3;
    
    sprintf(caption,"Info Data %d",index);
    editinfo_dlg[0].dp = caption;
    editinfo_dlg[0].dp2 = lfont;
    
    sprintf(ps1,"%d",misc.info[index].price[0]);
    sprintf(ps2,"%d",misc.info[index].price[1]);
    sprintf(ps3,"%d",misc.info[index].price[2]);
    snprintf(infoname,32,"%s",misc.info[index].name);
    editinfo_dlg[8].dp  = ps1;
    editinfo_dlg[10].dp = ps2;
    editinfo_dlg[12].dp = ps3;
    editinfo_dlg[15].dp = infoname;
    str1 = misc.info[index].str[0];
    str2 = misc.info[index].str[1];
    str3 = misc.info[index].str[2];
    editinfo_dlg[9].d1  = MsgStrings[str1].listpos;
    editinfo_dlg[11].d1 = MsgStrings[str2].listpos;
    editinfo_dlg[13].d1 = MsgStrings[str3].listpos;
//  ListData msgs_list(msgslist, is_large ? &sfont3 : &font);
    ListData msgs_list(msgslist2, is_large ? &lfont_l : &font);
    editinfo_dlg[9].dp  =
        editinfo_dlg[11].dp =
            editinfo_dlg[13].dp = (void *) &msgs_list;
            
    if(is_large)
        large_dialog(editinfo_dlg);
        
    int32_t ret = zc_popup_dialog(editinfo_dlg,-1);
    
    if(ret==16)
    {
        saved=false;
        misc.info[index].price[0] = vbound(atoi(ps1), 0, 65535);
        misc.info[index].price[1] = vbound(atoi(ps2), 0, 65535);
        misc.info[index].price[2] = vbound(atoi(ps3), 0, 65535);
        snprintf(misc.info[index].name,32,"%s",infoname);
        str1 = editinfo_dlg[9].d1;
        str2 = editinfo_dlg[11].d1;
        str3 = editinfo_dlg[13].d1;
        misc.info[index].str[0] = msg_at_pos(str1);
        misc.info[index].str[1] = msg_at_pos(str2);
        misc.info[index].str[2] = msg_at_pos(str3);
        
        //move 0s to the end
        word swaptmp;
        
        if(misc.info[index].str[0] == 0)
        {
            //possibly permute the infos
            if(misc.info[index].str[1] != 0)
            {
                //swap
                swaptmp = misc.info[index].str[0];
                misc.info[index].str[0] = misc.info[index].str[1];
                misc.info[index].str[1] = swaptmp;
                swaptmp = misc.info[index].price[0];
                misc.info[index].price[0] = misc.info[index].price[1];
                misc.info[index].price[1] = swaptmp;
            }
            else if(misc.info[index].str[2] != 0)
            {
                //move info 0 to 1, 1 to 2, and 2 to 0
                swaptmp = misc.info[index].str[0];
                misc.info[index].str[0] = misc.info[index].str[2];
                misc.info[index].str[2] = misc.info[index].str[1];
                misc.info[index].str[1] = swaptmp;
                swaptmp = misc.info[index].price[0];
                misc.info[index].price[0] = misc.info[index].price[2];
                misc.info[index].price[2] = misc.info[index].price[1];
                misc.info[index].price[1] = swaptmp;
            }
        }
        
        if(misc.info[index].str[1] == 0 && misc.info[index].str[2] != 0)
            //swap
        {
            swaptmp = misc.info[index].str[1];
            misc.info[index].str[1] = misc.info[index].str[2];
            misc.info[index].str[2] = swaptmp;
            swaptmp = misc.info[index].price[1];
            misc.info[index].price[1] = misc.info[index].price[2];
            misc.info[index].price[2] = swaptmp;
        }
    }
}

int32_t onInfoTypes()
{
    info_list_size = 256;
    
    int32_t index = select_data("Info Types",0,infolist,"Edit","Done",lfont);
    
    while(index!=-1)
    {
        EditInfoType(index);
        
        index = select_data("Info Types",index,infolist,"Edit","Done",lfont);
    }
    
    return D_O_K;
}



//This dialogie is self-contained, and does not use dialogue control numbers in a separate array to generate its fields.
static DIALOG editshop_dlg[] =
{
    // (dialog proc)     (x)   (y)   (w)   (h)   (fg)                 (bg)                  (key)    (flags)     (d1)           (d2)     (dp)
    { jwin_win_proc,       0,   10,  221,  204,  vc(14),              vc(1),                  0,      D_EXIT,     0,             0,       NULL, NULL, NULL },
    { d_timer_proc,        0,    0,    0,    0,  0,                   0,                      0,           0,     0,             0,       NULL, NULL, NULL },
    { jwin_text_proc,     24,   60,   48,    8,  vc(7),               vc(1),                  0,           0,     0,             0, (void *) "1st", NULL, NULL },
    { jwin_text_proc,     24,  106,   48,    8,  vc(7),               vc(1),                  0,           0,     0,             0, (void *) "2nd", NULL, NULL },
    { jwin_text_proc,     24,  152,   48,    8,  vc(7),               vc(1),                  0,           0,     0,             0, (void *) "3rd", NULL, NULL },
    { jwin_text_proc,     56,   60,   88,    8,  vc(14),              vc(1),                  0,           0,     0,             0, (void *) "Price:", NULL, NULL },
    { jwin_text_proc,     56,  106,   88,    8,  vc(14),              vc(1),                  0,           0,     0,             0, (void *) "Price:", NULL, NULL },
    { jwin_text_proc,     56,  152,   88,    8,  vc(14),              vc(1),                  0,           0,     0,             0, (void *) "Price:", NULL, NULL },
    // 8
    { jwin_edit_proc,     86,   56,   32,   16,  vc(12),              vc(1),                  0,           0,     5,             0,       NULL, NULL, NULL },
    { d_nidroplist_proc,  56,   74,  137,   16,  jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],     0,           0,     0,             0,       NULL, NULL, NULL },
    { jwin_edit_proc,     86,  102,   32,   16,  vc(12),              vc(1),                  0,           0,     5,             0,       NULL, NULL, NULL },
    { d_nidroplist_proc,  56,  120,  137,   16,  jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],     0,           0,     0,             0,       NULL, NULL, NULL },
    { jwin_edit_proc,     86,  148,   32,   16,  vc(12),              vc(1),                  0,           0,     5,             0,       NULL, NULL, NULL },
    { d_nidroplist_proc,  56,  166,  137,   16,  jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],     0,           0,     0,             0,       NULL, NULL, NULL },
    { jwin_text_proc,     24,   42,   88,    8,  vc(14),              vc(1),                  0,           0,     0,             0, (void *) "Name:", NULL, NULL },
    { jwin_edit_proc,     56,   38,  137,   16,  vc(12),              vc(1),                  0,           0,    31,             0,       NULL, NULL, NULL },
    
    // 16
    { jwin_button_proc,   40,  188,   61,   21,  vc(14),              vc(1),                 13,      D_EXIT,     0,             0, (void *) "OK", NULL, NULL },
    { jwin_button_proc,  121,  188,   61,   21,  vc(14),              vc(1),                 27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    //18
    { jwin_text_proc,    130,   60,   88,    8,  vc(14),              vc(1),                  0,           0,     0,             0, (void *) "Info:", NULL, NULL },
    { jwin_text_proc,    130,  106,   88,    8,  vc(14),              vc(1),                  0,           0,     0,             0, (void *) "Info:", NULL, NULL },
    { jwin_text_proc,    130,  152,   88,    8,  vc(14),              vc(1),                  0,           0,     0,             0, (void *) "Info:", NULL, NULL },
    // 21
    { jwin_edit_proc,     155,   56,   32,   16,  vc(12),              vc(1),                  0,           0,     5,             0,       NULL, NULL, NULL },
    { jwin_edit_proc,     155,   102,   32,   16,  vc(12),              vc(1),                  0,           0,     5,             0,       NULL, NULL, NULL },
    { jwin_edit_proc,     155,   148,   32,   16,  vc(12),              vc(1),                  0,           0,     5,             0,       NULL, NULL, NULL },
    
    { NULL,                0,    0,    0,    0,  0,                   0,                      0,      0,          0,             0,       NULL,                           NULL,  NULL }
};

void EditShopType(int32_t index)
{

    build_bii_list(true);
    char ps1[6],ps2[6],ps3[6];
	char info1[6],info2[6],info3[6];
    char shopname[32];
    char caption[40];
    
    sprintf(caption,"Shop Data %d",index);
    editshop_dlg[0].dp = caption;
    editshop_dlg[0].dp2=lfont;
    
    sprintf(ps1,"%d",misc.shop[index].price[0]);
    sprintf(ps2,"%d",misc.shop[index].price[1]);
    sprintf(ps3,"%d",misc.shop[index].price[2]);
	
    sprintf(info1,"%d",misc.shop[index].str[0]);
    sprintf(info2,"%d",misc.shop[index].str[1]);
    sprintf(info3,"%d",misc.shop[index].str[2]);
	
    sprintf(shopname,"%s",misc.shop[index].name);
    editshop_dlg[8].dp  = ps1;
    editshop_dlg[10].dp = ps2;
    editshop_dlg[12].dp = ps3;
    editshop_dlg[15].dp = shopname;
    
    editshop_dlg[21].dp  = info1;
    editshop_dlg[22].dp = info2;
    editshop_dlg[23].dp = info3;
    
//  ListData item_list(itemlist, is_large ? &sfont3 : &font);
    ListData item_list(itemlist_num, is_large ? &lfont_l : &font);
    
    editshop_dlg[9].dp  = (void *) &item_list;
    editshop_dlg[11].dp  = (void *) &item_list;
    editshop_dlg[13].dp  = (void *) &item_list;
    
    for(int32_t i=0; i<3; ++i)
    {
        if(misc.shop[index].hasitem[i])
        {
            for(int32_t j=0; j<bii_cnt; j++)
            {
                if(bii[j].i == misc.shop[index].item[i])
                {
                    editshop_dlg[9+(i<<1)].d1  = j;
                }
            }
        }
        else
        {
            editshop_dlg[9+(i<<1)].d1 = -2;
        }
    }
    
    if(is_large)
        large_dialog(editshop_dlg);
        
    int32_t ret = zc_popup_dialog(editshop_dlg,-1);
    
    if(ret==16)
    {
        saved=false;
        misc.shop[index].price[0] = vbound(atoi(ps1), 0, 65535);
        misc.shop[index].price[1] = vbound(atoi(ps2), 0, 65535);
        misc.shop[index].price[2] = vbound(atoi(ps3), 0, 65535);
	    
	misc.shop[index].str[0] = vbound(atoi(info1), 0, 65535);
        misc.shop[index].str[1] = vbound(atoi(info2), 0, 65535);
        misc.shop[index].str[2] = vbound(atoi(info3), 0, 65535);
	    
        snprintf(misc.shop[index].name, 32, "%s",shopname);
        
        for(int32_t i=0; i<3; ++i)
        {
            if(bii[editshop_dlg[9+(i<<1)].d1].i == -2)
            {
                misc.shop[index].hasitem[i] = 0;
                misc.shop[index].item[i] = 0;
                misc.shop[index].price[i] = 0;
            }
            else
            {
                misc.shop[index].hasitem[i] = 1;
                misc.shop[index].item[i] = bii[editshop_dlg[9+(i<<1)].d1].i;
            }
        }
        
        //filter all the 0 items to the end (yeah, bubble sort; sue me)
        word swaptmp;
        
        for(int32_t j=0; j<3-1; j++)
        {
            for(int32_t k=0; k<2-j; k++)
            {
                if(misc.shop[index].hasitem[k]==0)
                {
                    swaptmp = misc.shop[index].item[k];
                    misc.shop[index].item[k] = misc.shop[index].item[k+1];
                    misc.shop[index].item[k+1] = swaptmp;
                    swaptmp = misc.shop[index].price[k];
                    misc.shop[index].price[k] = misc.shop[index].price[k+1];
                    misc.shop[index].price[k+1] = swaptmp;
                    swaptmp = misc.shop[index].hasitem[k];
                    misc.shop[index].hasitem[k] = misc.shop[index].item[k+1];
                    misc.shop[index].hasitem[k+1] = swaptmp;
                }
            }
        }
    }
}

int32_t onShopTypes()
{
    shop_list_size = 256;
    
    int32_t index = select_data("Shop Types",0,shoplist,"Edit","Done",lfont);
    
    while(index!=-1)
    {
        EditShopType(index);
        index = select_data("Shop Types",index,shoplist,"Edit","Done",lfont);
    }
    
    return D_O_K;
}

void call_bottle_dlg(int32_t index);
int32_t onBottleTypes()
{
	bottle_list_size = 64;
	int32_t index = 0;
	
	while(index > -1)
	{
		index = select_data("Bottle Types", index, bottlelist, "Edit", "Done", lfont);
		if(index > -1)
			call_bottle_dlg(index);
	}
	
	return D_O_K;
}

void call_bottleshop_dlg(int32_t index);
int32_t onBottleShopTypes()
{
	bottleshop_list_size = 256;
	int32_t index = 0;
	
	while(index > -1)
	{
		index = select_data("Bottle Shop Types", index, bottleshoplist, "Edit", "Done", lfont);
		if(index > -1)
			call_bottleshop_dlg(index);
	}
	
	return D_O_K;
}


static char item_drop_set_str_buf[70];
int32_t item_drop_set_list_size=MAXITEMDROPSETS;

const char *itemdropsetlist(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        bound(index,0,item_drop_set_list_size-1);
        sprintf(item_drop_set_str_buf,"%3d:  %s",index,item_drop_sets[index].name);
        return item_drop_set_str_buf;
    }
    
    *list_size=item_drop_set_list_size;
    return NULL;
}

int32_t d_itemdropedit_proc(int32_t msg,DIALOG *d,int32_t c);

static int32_t edititemdropset_1_list[] =
{
    // dialog control number
    10, 11, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,24,25,26,27,28, -1
};

static int32_t edititemdropset_2_list[] =
{
    // dialog control number
    12, 13, 29, 30, 31, 32, 33,34,35,36,37,38,39,40,41,42,43, -1
};

static TABPANEL edititemdropset_tabs[] =
{
    // (text)
    { (char *)" Page 1 ",       D_SELECTED,   edititemdropset_1_list,  0, NULL },
    { (char *)" Page 2 ",       0,            edititemdropset_2_list,  0, NULL },
    { NULL,                     0,            NULL,                    0, NULL }
};

static DIALOG edititemdropset_dlg[] =
{
    // (dialog proc)     (x)   (y)   (w)   (h)   (fg)                 (bg)                  (key)    (flags)     (d1)           (d2)     (dp)
    { jwin_win_proc,       0,    0,  320,  240,  vc(14),              vc(1),                  0,      D_EXIT,     0,             0,       NULL, NULL, NULL },
    { d_timer_proc,        0,    0,    0,    0,  0,                   0,                      0,           0,     0,             0,       NULL, NULL, NULL },
    
    // 2
    { jwin_button_proc,   89,  213,   61,   21,  vc(14),              vc(1),                 13,      D_EXIT,     0,             0, (void *) "OK", NULL, NULL },
    { jwin_button_proc,  169,  213,   61,   21,  vc(14),              vc(1),                 27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    
    // 4
    { jwin_text_proc,      9,   29,   88,    8,  vc(14),              vc(1),                  0,           0,     0,             0, (void *) "Name:", NULL, NULL },
    { jwin_edit_proc,     39,   25,  275,   16,  vc(12),              vc(1),                  0,           0,    32,             0,       NULL, NULL, NULL },
    { jwin_text_proc,      9,   47,   88,    8,  vc(14),              vc(1),                  0,           0,     0,             0, (void *) "Nothing Chance:", NULL, NULL },
    { d_itemdropedit_proc,     84,   43,   26,   16,  vc(12),              vc(1),                  0,           0,     5,             0,       NULL, NULL, NULL },
    
    { jwin_tab_proc,       4,   65,  312,   143, vc(0),               vc(15),                 0,           0,     0,             0, (void *) edititemdropset_tabs,                    NULL, (void *)edititemdropset_dlg },
    { jwin_text_proc,     114,   43+4,   26,   16,   vc(14),              vc(1),                  0,           0,     0,             0,       NULL, NULL, NULL },
    // 10
    { jwin_text_proc,     10,   87,   88,    8,  vc(14),              vc(1),                  0,           0,     0,             0, (void *) "Chance:", NULL, NULL },
    { jwin_text_proc,     56,   87,   88,    8,  vc(14),              vc(1),                  0,           0,     0,             0, (void *) "Item:", NULL, NULL },
    { jwin_text_proc,     10,   87,   88,    8,  vc(14),              vc(1),                  0,           0,     0,             0, (void *) "Chance:", NULL, NULL },
    { jwin_text_proc,     56,   87,   88,    8,  vc(14),              vc(1),                  0,           0,     0,             0, (void *) "Item:", NULL, NULL },
    
    // 14
    { d_itemdropedit_proc,      9,   96,   26,   16,  vc(12),              vc(1),                  0,           0,     5,             0,       NULL, NULL, NULL },
    { d_idroplist_proc,   55,   96,  233,   16,  jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],     0,           0,     0,             0,       NULL, NULL, NULL },
    { jwin_text_proc,     37,   96+4,   26,   16,  vc(14),              vc(1),                  0,           0,     0,             0,       NULL, NULL, NULL },
    { d_itemdropedit_proc,      9,  118,   26,   16,  vc(12),              vc(1),                  0,           0,     5,             0,       NULL, NULL, NULL },
    { d_idroplist_proc,   55,  118,  233,   16,  jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],     0,           0,     0,             0,       NULL, NULL, NULL },
    { jwin_text_proc,     37,  118+4,   26,   16,  vc(14),              vc(1),                  0,           0,     0,             0,       NULL, NULL, NULL },
    { d_itemdropedit_proc,      9,  140,   26,   16,  vc(12),              vc(1),                  0,           0,     5,             0,       NULL, NULL, NULL },
    { d_idroplist_proc,   55,  140,  233,   16,  jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],     0,           0,     0,             0,       NULL, NULL, NULL },
    { jwin_text_proc,     37,  140+4,   26,   16,  vc(14),              vc(1),                  0,           0,     0,             0,       NULL, NULL, NULL },
    { d_itemdropedit_proc,      9,  162,   26,   16,  vc(12),              vc(1),                  0,           0,     5,             0,       NULL, NULL, NULL },
    { d_idroplist_proc,   55,  162,  233,   16,  jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],     0,           0,     0,             0,       NULL, NULL, NULL },
    { jwin_text_proc,       37,  162+4,   26,   16,  vc(14),              vc(1),                  0,           0,     0,             0,       NULL, NULL, NULL },
    { d_itemdropedit_proc,      9,  184,   26,   16,  vc(12),              vc(1),                  0,           0,     5,             0,       NULL, NULL, NULL },
    { d_idroplist_proc,   55,  184,  233,   16,  jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],     0,           0,     0,             0,       NULL, NULL, NULL },
    { jwin_text_proc,       37,  184+4,   26,   16,  vc(14),              vc(1),                  0,           0,     0,             0,       NULL, NULL, NULL },
// 29
    { d_itemdropedit_proc,      9,   96,   26,   16,  vc(12),              vc(1),                  0,           0,     5,             0,       NULL, NULL, NULL },
    { d_idroplist_proc,   55,   96,  233,   16,  jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],     0,           0,     0,             0,       NULL, NULL, NULL },
    { jwin_text_proc,     37,   96+4,   26,   16,  vc(14),              vc(1),                  0,           0,     0,             0,       NULL, NULL, NULL },
    { d_itemdropedit_proc,      9,  118,   26,   16,  vc(12),              vc(1),                  0,           0,     5,             0,       NULL, NULL, NULL },
    { d_idroplist_proc,   55,  118,  233,   16,  jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],     0,           0,     0,             0,       NULL, NULL, NULL },
    { jwin_text_proc,      37,  118+4,   26,   16,  vc(14),              vc(1),                  0,           0,     0,             0,       NULL, NULL, NULL },
    { d_itemdropedit_proc,      9,  140,   26,   16,  vc(12),              vc(1),                  0,           0,     5,             0,       NULL, NULL, NULL },
    { d_idroplist_proc,   55,  140,  233,   16,  jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],     0,           0,     0,             0,       NULL, NULL, NULL },
    { jwin_text_proc,      37,  140+4,   26,   16,  vc(14),              vc(1),                  0,           0,     0,             0,       NULL, NULL, NULL },
    { d_itemdropedit_proc,      9,  162,   26,   16,  vc(12),              vc(1),                  0,           0,     5,             0,       NULL, NULL, NULL },
    { d_idroplist_proc,   55,  162,  233,   16,  jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],     0,           0,     0,             0,       NULL, NULL, NULL },
    { jwin_text_proc,      37,  162+4,   26,   16,  vc(14),              vc(1),                  0,           0,     0,             0,       NULL, NULL, NULL },
    { d_itemdropedit_proc,      9,  184,   26,   16,  vc(12),              vc(1),                  0,           0,     5,             0,       NULL, NULL, NULL },
    { d_idroplist_proc,   55,  184,  233,   16,  jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],     0,           0,     0,             0,       NULL, NULL, NULL },
    { jwin_text_proc,      39,  184+4,   26,   16,  vc(14),              vc(1),                  0,           0,     0,             0,       NULL, NULL, NULL },
    { NULL,                0,    0,    0,    0,  0,                   0,                      0,      0,          0,             0,       NULL, NULL,  NULL }
};

int32_t d_itemdropedit_proc(int32_t msg,DIALOG *d,int32_t c)
{
    int32_t ret = jwin_edit_proc(msg,d,c);
    
    if(msg==MSG_DRAW)
    {
        int32_t t = atoi((char*)edititemdropset_dlg[7].dp);
        
        for(int32_t i=0; i<10; ++i)
        {
            t += atoi((char*)edititemdropset_dlg[14+(i*3)].dp);
        }
        
        scare_mouse();
        {
            int32_t t2 = (int32_t)(100*atoi((char*)edititemdropset_dlg[7].dp) / zc_max(t,1));
            sprintf((char*)edititemdropset_dlg[9].dp,"%d%%%s",t2, is_large && t2 <= 11 ? " ":"");
            object_message(&edititemdropset_dlg[9],MSG_DRAW,c);
        }
        
        for(int32_t i=0; i<10; ++i)
        {
            int32_t t2 = (int32_t)(100*atoi((char*)edititemdropset_dlg[14+(i*3)].dp) / zc_max(t,1));
            sprintf((char*)edititemdropset_dlg[16+(i*3)].dp,"%d%%%s",t2, is_large && t2 <= 11 ? " ":"");
            object_message(&edititemdropset_dlg[16+(i*3)],MSG_DRAW,c);
        }
        
        unscare_mouse();
    }
    
    return ret;
}

void EditItemDropSet(int32_t index)
{
    build_bii_list(true);
    char chance[11][10];
    char itemdropsetname[64];
    char caption[40];
    char percent_str[11][5];
    
    sprintf(caption,"Item Drop Set Data %d",index);
    edititemdropset_dlg[0].dp = caption;
    edititemdropset_dlg[0].dp2=lfont;
    
    sprintf(itemdropsetname,"%s",item_drop_sets[index].name);
    edititemdropset_dlg[5].dp = itemdropsetname;
    
    sprintf(chance[0],"%d",item_drop_sets[index].chance[0]);
    edititemdropset_dlg[7].dp = chance[0];
    
    ListData item_list(itemlist_num, is_large ? &lfont_l : &font);
    sprintf(percent_str[0],"    ");
    edititemdropset_dlg[9].dp  = percent_str[0];
    
    for(int32_t i=0; i<10; ++i)
    {
        sprintf(chance[i+1],"%d",item_drop_sets[index].chance[i+1]);
        edititemdropset_dlg[14+(i*3)].dp  = chance[i+1];
        edititemdropset_dlg[15+(i*3)].dp  = (void *) &item_list;
        sprintf(percent_str[i+1],"    ");
        edititemdropset_dlg[16+(i*3)].dp  = percent_str[i+1];
        
        if(item_drop_sets[index].chance[i+1]==0)
        {
            edititemdropset_dlg[15+(i*3)].d1  = -2;
        }
        else
        {
            for(int32_t j=0; j<bii_cnt; j++)
            {
                if(bii[j].i == item_drop_sets[index].item[i])
                {
                    edititemdropset_dlg[15+(i*3)].d1  = j;
                }
            }
        }
    }
    
    if(is_large)
        large_dialog(edititemdropset_dlg);
        
    int32_t ret = zc_popup_dialog(edititemdropset_dlg,-1);
    
    if(ret==2)
    {
        saved=false;
        
        sprintf(item_drop_sets[index].name,"%s",itemdropsetname);
        
        item_drop_sets[index].chance[0]=atoi(chance[0]);
        
        for(int32_t i=0; i<10; ++i)
        {
            item_drop_sets[index].chance[i+1]=atoi(chance[i+1]);
            
            if(bii[edititemdropset_dlg[15+(i*3)].d1].i == -2)
            {
                item_drop_sets[index].chance[i+1]=0;
            }
            else
            {
                item_drop_sets[index].item[i] = bii[edititemdropset_dlg[15+(i*3)].d1].i;
            }
            
            if(item_drop_sets[index].chance[i+1]==0)
            {
                item_drop_sets[index].item[i] = 0;
            }
        }
    }
}

int32_t count_item_drop_sets()
{
    int32_t count=0;
    bool found=false;
    
    for(count=255; (count>0); --count)
    {
        for(int32_t i=0; (i<11); ++i)
        {
            if(item_drop_sets[count].chance[i]!=0)
            {
                found=true;
                break;
            }
        }
        
        if(found)
        {
            break;
        }
    }
    
    return count+1;
}

int32_t onItemDropSets()
{
    item_drop_set_list_size = MAXITEMDROPSETS;
    
    int32_t index = select_data("Item Drop Sets",0,itemdropsetlist,"Edit","Done",lfont);
    
    while(index!=-1)
    {
        EditItemDropSet(index);
        index = select_data("Item Drop Sets",index,itemdropsetlist,"Edit","Done",lfont);
    }
    
    return D_O_K;
}

/********************************/
/********* onWarpRings **********/
/********************************/

int32_t curr_ring = 0;

void EditWarpRingScr(int32_t ring,int32_t index)
{
    char caption[40],buf[10];
    restore_mouse();
    int32_t tempx5=warpring_warp_dlg[5].x;
    int32_t tempx6=warpring_warp_dlg[6].x;
    int32_t tempx10=warpring_warp_dlg[10].x;
    int32_t tempx11=warpring_warp_dlg[11].x;
    int32_t tempx12=warpring_warp_dlg[12].x;
    int32_t tempx13=warpring_warp_dlg[13].x;
    
    int32_t tempx[100];
    
    for(int32_t m=17; m<100; m++)
    {
        tempx[m-17]=warpring_warp_dlg[m].x;
        
        if(m!=67)
        {
            warpring_warp_dlg[m].x = screen->w + 10;
        }
    }
    
    warpring_warp_dlg[5].x = screen->w + 10;
    warpring_warp_dlg[6].x = screen->w + 10;
    warpring_warp_dlg[10].x = screen->w + 10;
    warpring_warp_dlg[11].x = screen->w + 10;
    warpring_warp_dlg[12].x = screen->w + 10;
    warpring_warp_dlg[13].x = screen->w + 10;
    
    for(int32_t i=0; i<4; i++)
    {
        warpring_warp_dlg[10+i].d2 = 0;
        warpring_warp_dlg[25+i].d2 = 0;
        warpring_warp_dlg[37+i].d2 = 0;
        warpring_warp_dlg[49+i].d2 = 0;
    }
    
    sprintf(caption,"Ring %d  Warp %d",ring,index+1);
    warpring_warp_dlg[0].dp = (void *)caption;
    warpring_warp_dlg[0].dp2=lfont;
    
    warpring_warp_dlg[1].dp = NULL;
    warpring_warp_dlg[1].dp3 = NULL;
    
    sprintf(buf,"%02X",misc.warp[ring].scr[index]);
    warpring_warp_dlg[8].d1=misc.warp[ring].dmap[index];
    warpring_warp_dlg[9].dp=buf;
    warpring_warp_dlg[24].dp=buf;
    warpring_warp_dlg[36].dp=buf;
    warpring_warp_dlg[48].dp=buf;
    warpring_warp_dlg[2].fg=warpring_warp_dlg[5].fg=vc(7);
    
    for(int32_t i=0; i<4; i++)
        warpring_warp_dlg[10+i].d2 = 0;
        
    dmap_list_size=MAXDMAPS;
    dmap_list_zero=true;
    
    if(is_large)
        large_dialog(warpring_warp_dlg);
        
    int32_t ret=zc_popup_dialog(warpring_warp_dlg,-1);
    
    if(ret==14 || ret==15)
    {
        saved=false;
        misc.warp[ring].dmap[index] = warpring_warp_dlg[8].d1;
        misc.warp[ring].scr[index] = zc_xtoi(buf);
    }
    
    if(ret==15)
    {
        Map.dowarp2(ring,index);
        refresh(rALL);
    }
    
    warpring_warp_dlg[5].x = tempx5;
    warpring_warp_dlg[6].x = tempx6;
    warpring_warp_dlg[10].x = tempx10;
    warpring_warp_dlg[11].x = tempx11;
    warpring_warp_dlg[12].x = tempx12;
    warpring_warp_dlg[13].x = tempx13;
    
    for(int32_t m=17; m<100; m++)
    {
        warpring_warp_dlg[m].x=tempx[m-17];
    }
    
    for(int32_t i=0; i<4; i++)
    {
        warpring_warp_dlg[10+i].d2 = 0x80;
        warpring_warp_dlg[25+i].d2 = 0x80;
        warpring_warp_dlg[37+i].d2 = 0x80;
        warpring_warp_dlg[49+i].d2 = 0x80;
    }
    
    warpring_warp_dlg[1].dp = (void *) warpring_warp_tabs;
    warpring_warp_dlg[1].dp3 = (void *)warpring_warp_dlg;
    
}

int32_t d_warplist_proc(int32_t msg,DIALOG *d,int32_t c)
{
    if(msg==MSG_DRAW)
    {
        int32_t *xy = (int32_t*)(d->dp3);
        int32_t ring = curr_ring;
        int32_t dmap = misc.warp[ring].dmap[d->d1];
        float temp_scale = 1;
        
        if(is_large)
        {
            temp_scale = 1.5; // Scale up by 1.5
        }
        
        drawdmap(dmap);
        
        if(xy[0]||xy[1])
        {
            int32_t x = d->x+int32_t((xy[0]-2)*temp_scale);
            int32_t y = d->y+int32_t((xy[1]-2)*temp_scale);
//      int32_t w = is_large ? 84 : 71;
//      int32_t h = is_large ? 52 : 39;
            int32_t w = 84;
            int32_t h = 52;
            jwin_draw_frame(screen,x,y,w,h,FR_DEEP);
            drawdmap_screen(x+2,y+2,w-4,h-4,dmap);
        }
        
        if(xy[2]||xy[3])
        {
            textprintf_ex(screen,font,d->x+int32_t(xy[2]*temp_scale),d->y+int32_t(xy[3]*temp_scale),jwin_pal[jcBOXFG],jwin_pal[jcBOX],"Map: %d ",DMaps[dmap].map+1);
        }
        
        if(xy[4]||xy[5])
        {
            textprintf_ex(screen,font,d->x+int32_t(xy[4]*temp_scale),d->y+int32_t(xy[5]*temp_scale),jwin_pal[jcBOXFG],jwin_pal[jcBOX],"Level:%2d ",DMaps[dmap].level);
        }
        
        if(xy[6]||xy[7])
        {
            textprintf_ex(screen,font,d->x+int32_t(xy[6]*temp_scale),d->y+int32_t(xy[7]*temp_scale),jwin_pal[jcBOXFG],jwin_pal[jcBOX],"Scr: 0x%02X ",misc.warp[ring].scr[d->d1]);
        }
    }
    
    return jwin_list_proc(msg,d,c);
}

int32_t d_wclist_proc(int32_t msg,DIALOG *d,int32_t c)
{
    int32_t d1 = d->d1;
    int32_t ret = jwin_droplist_proc(msg,d,c);
    misc.warp[curr_ring].size=d->d1+3;
    
    if(d->d1 != d1)
        return D_CLOSE;
        
    return ret;
}

const char *wclist(int32_t index, int32_t *list_size)
{
    static char buf[2];
    
    if(index>=0)
    {
        if(index>6)
            index=6;
            
        sprintf(buf,"%d",index+3);
        return buf;
    }
    
    *list_size=7;
    return NULL;
}

//int32_t warpringdmapxy[8] = {160,116,160,90,160,102,160,154};
int32_t warpringdmapxy[8] = {80,26,80,0,80,12,80,78};

static ListData number_list(numberlist, &font);
static ListData wc_list(wclist, &font);

static DIALOG warpring_dlg[] =
{
    // (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp)
    { jwin_win_proc,          0,      0,    193,    166,    vc(14),                 vc(1),                   0,    D_EXIT,     0,          0,  NULL,                    NULL,   NULL            },
    { d_timer_proc,           0,      0,      0,      0,    0,                      0,                       0,    0,          0,          0,  NULL,                    NULL,   NULL            },
    { jwin_text_proc,        16,     33,     48,      8,    vc(14),                 vc(1),                   0,    0,          0,          0, (void *) "Count:",       NULL,   NULL            },
    { d_wclist_proc,         72,     29,     48,     16,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,    0,          1,          0, (void *) &wc_list,       NULL,   NULL            },
    // 4
    { d_warplist_proc,       16,     50,     65,     71,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,    D_EXIT,     0,          0, (void *) &number_list,   NULL,   warpringdmapxy  },
    { jwin_button_proc,      26,    140,     61,     21,    vc(14),                 vc(1),                  13,    D_EXIT,     0,          0, (void *) "Edit",         NULL,   NULL            },
    { jwin_button_proc,     106,    140,     61,     21,    vc(14),                 vc(1),                  27,    D_EXIT,     0,          0, (void *) "Done",         NULL,   NULL            },
    { d_keyboard_proc,        0,      0,      0,      0,    0,                      0,                       0,    0,          KEY_F1,     0, (void *) onHelp,         NULL,   NULL            },
    { NULL,                   0,      0,      0,      0,    0,                      0,                       0,    0,          0,          0,  NULL,                    NULL,   NULL            }
};

int32_t select_warp()
{
    misc.warp[curr_ring].size = vbound(misc.warp[curr_ring].size,3,9);
    number_list_zero = false;
    
    int32_t ret=4;
    
    if(is_large)
        large_dialog(warpring_dlg);
        
    do
    {
        number_list_size = misc.warp[curr_ring].size;
        warpring_dlg[3].d1 = misc.warp[curr_ring].size-3;
        ret = zc_popup_dialog(warpring_dlg,ret);
    }
    while(ret==3);
    
    if(ret==6 || ret==0)
    {
        return -1;
    }
    
    return warpring_dlg[4].d1;
}

void EditWarpRing(int32_t ring)
{
    char buf[40];
    sprintf(buf,"Ring %d Warps",ring);
    warpring_dlg[0].dp = buf;
    warpring_dlg[0].dp2 = lfont;
    curr_ring = ring;
    
    int32_t index = select_warp();
    
    while(index!=-1)
    {
        EditWarpRingScr(ring,index);
        index = select_warp();
    }
}

int32_t onWarpRings()
{
    number_list_size = 9;
    number_list_zero = true;
    
    int32_t index = select_data("Warp Rings",0,numberlist,"Edit","Done",lfont);
    
    while(index!=-1)
    {
        EditWarpRing(index);
        number_list_size = 9;
        number_list_zero = true;
        index = select_data("Warp Rings",index,numberlist,"Edit","Done",lfont);
    }
    
    return D_O_K;
}

/********************************/
/********** onEnemies ***********/
/********************************/


const char *pattern_list(int32_t index, int32_t *list_size)
{

    if(index<0)
    {
        *list_size = MAXPATTERNS;
        return NULL;
    }
    
    return pattern_string[index];
}

static ListData pattern_dlg_list(pattern_list, &font);

static DIALOG pattern_dlg[] =
{
    /* (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp) */
    { jwin_win_proc, 72,   56,   176+1,  164+1,   vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "Enemy Pattern", NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { jwin_list_proc,       80,   124,   160+1,  58,   jwin_pal[jcTEXTFG],jwin_pal[jcTEXTBG],  0,       D_EXIT,     0,             0, (void *) &pattern_dlg_list, NULL, NULL },
    // 3
    { jwin_button_proc,     90,   190,  61,   21,   vc(14),  vc(1),  'k',     D_EXIT,     0,             0, (void *) "O&K", NULL, NULL },
    { jwin_button_proc,     170,  190,  61,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { jwin_text_proc,     90,  78,  61,   10,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Classic: pseudorandom locations near", NULL, NULL },
    { jwin_text_proc,     90,  88,  61,   10,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "the middle of the screen.", NULL, NULL },
    { jwin_text_proc,     90,  102,  61,   10,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Random: any available location", NULL, NULL },
    { jwin_text_proc,     90,  112,  61,   10,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "at a sufficient distance from the Player.", NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

int32_t onPattern()
{
    byte p=Map.CurrScr()->pattern;
    pattern_dlg[0].dp2 = lfont;
    pattern_dlg[2].d1  = p;
    
    if(is_large)
        large_dialog(pattern_dlg);
        
    if(zc_popup_dialog(pattern_dlg,2) < 4)
    {
        saved=false;
        Map.CurrScr()->pattern = pattern_dlg[2].d1;
    }
    
    refresh(rMENU);
    return D_O_K;
}

// Now just calls onScrData()
int32_t onEnemyFlags()
{
	int32_t i=-1;
	
	bool found = false;
	while(scrdata_tabs[++i].text != NULL)
	{
		if(!strcmp(scrdata_tabs[i].text, "E.Flags"))
		{
			found = true;
			scrdata_tabs[i].flags = D_SELECTED;
		}
		else scrdata_tabs[i].flags = 0;
	}
	if(!found) scrdata_tabs[3].flags = D_SELECTED;
	onScrData();
	return D_O_K;
}

const char *enemy_viewer(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size=10;
        
        return NULL;
    }
    
    int32_t guy=Map.CurrScr()->enemy[index];
    return guy>=eOCTO1S ? guy_string[guy] : (char *) "(None)";
}

enemy_struct bie[eMAXGUYS];
enemy_struct ce[100];
int32_t enemy_type=0,bie_cnt=-1,ce_cnt;

enemy_struct big[zqMAXGUYS];
enemy_struct cg[100];
int32_t guy_type=0,big_cnt=-1,cg_cnt;

//Uses old_max_guys[] in zq_misc.cpp to define what are visible if bool hide is set true. -Z
void build_bie_list(bool hide)
{
    bie[0].s = (char *)"(None)";
    bie[0].i = 0;
    bie_cnt=1;
    
    for(int32_t i=1; i<eMAXGUYS; i++)
    {
	if ( i >= 11 && i <= 19 ) continue; //ignore segment components
        if(i >= OLDMAXGUYS || old_guy_string[i][strlen(old_guy_string[i])-1]!=' ' || !hide)
        {
            bie[bie_cnt].s = (char *)guy_string[i];
            bie[bie_cnt].i = i;
            ++bie_cnt;
        }
    }
    
    for(int32_t i=1; i<bie_cnt-1; i++) //Start at 1 so '(None)' isn't alphabetized!
    {
        for(int32_t j=i+1; j<bie_cnt; j++)
        {
            if(strcmp(bie[i].s,bie[j].s)>0)
            {
                zc_swap(bie[i],bie[j]);
            }
        }
    }
}

void build_big_list(bool hide)
{
    //big[0].s = (char *)"(None)";
    //big[0].i = 0;
    //big_cnt=1;
    big_cnt=0;
    for(int32_t i=0; i<gDUMMY1; i++)
    {
        if(moduledata.guy_type_names[i][0]!=' ' || !hide)
        {
            big[big_cnt].s = (char *)moduledata.guy_type_names[i];
            big[big_cnt].i = i;
            ++big_cnt;
        }
    }
    
    for(int32_t i=1; i<big_cnt-1; i++) //start at 1, so that the none value is not alphabetized.
    {
        for(int32_t j=i+1; j<big_cnt; j++)
        {
            if(strcmp(big[i].s,big[j].s)>0)
            {
                zc_swap(big[i],big[j]);
            }
        }
    }
}

const char *enemylist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = enemy_type ? ce_cnt : bie_cnt;
        return NULL;
    }
    
    return enemy_type ? ce[index].s : bie[index].s;
}

const char *guylist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = guy_type ? cg_cnt : big_cnt;
        return NULL;
    }
    
    return guy_type ? cg[index].s : big[index].s;
}

void elist_rclick_func(int32_t index, int32_t x, int32_t y);
void paste_enemy(int32_t index = -1);
void copy_enemy(int32_t index = -1);
void save_enemy(int32_t index = -1);
void load_enemy(int32_t index = -1);
DIALOG elist_dlg[] =
{
    /* (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp) */
    { jwin_win_proc,     50,   40,   200+24+24,  145+20,  vc(14),  vc(1),  0,       D_EXIT,          0,             0,       NULL, NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { d_enelist_proc,    62,   68,   188,  88,   jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,       D_EXIT,     0,             0,       NULL, NULL, NULL },
    { jwin_button_proc,     90,   160+20,  61,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "Edit", NULL, NULL },
    { jwin_button_proc,     170,  160+20,  61,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Done", NULL, NULL },
    { jwin_button_proc,     220,   160+20,  61,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "Edit", NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

static DIALOG glist_dlg[] =
{
    /* (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp) */
    { jwin_win_proc,     50,   40,   220,  145,  vc(14),  vc(1),  0,       D_EXIT,          0,             0,       NULL, NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { jwin_abclist_proc,    62,   68,   196,  88,   jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,       D_EXIT,     0,             0,       NULL, NULL, NULL },
    { jwin_button_proc,     70,   160,  51,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "OK", NULL, NULL },
    { jwin_button_proc,     190,  160,  51,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { jwin_button_proc,     130,  160,  51,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Help", NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

int32_t efrontfacingtile(int32_t id)
{
    int32_t anim = get_bit(quest_rules,qr_NEWENEMYTILES)?guysbuf[id].e_anim:guysbuf[id].anim;
    int32_t usetile = 0;
    
    switch(anim)
    {
	    
    case aNONE: break;
    case aAQUA:
        if(!(get_bit(quest_rules,qr_NEWENEMYTILES) && guysbuf[id].misc1))
            break;
            
    case aWALLM:
    case aGHOMA:
        usetile=1;
        break;
        
        //Fallthrough
    case a2FRM4DIR:
    case aWALK:
        usetile=2;
        break;
        
    case aLEV:
    case a3FRM4DIR:
        usetile=3;
        break;
        
    case aLANM:
        usetile = !(get_bit(quest_rules,qr_NEWENEMYTILES))?0:4;
        break;
        
    case aNEWDONGO:
    case a4FRM8EYE:
    case aNEWWIZZ:
    case aARMOS4:
    case aNEWTEK:
    case aNEWWALLM:
    case a4FRM4DIRF:
    case a4FRM4DIR:
    case a4FRM8DIRF:
    case a4FRMPOS8DIR:
    case a4FRMPOS8DIRF:
    case a4FRMPOS4DIR:
    case a4FRMPOS4DIRF:
        usetile=4;
        break;
        
    case aDONGO:
        usetile=6;
        break;
        
    case aDONGOBS:
        usetile=24;
        break;
        
    case aNEWLEV:
        usetile=40;
        break;
        
    case aNEWZORA:
        if(guysbuf[id].family==eeZORA)
            usetile=44;
            
        break;
        
    case aGLEEOK:
        if(!get_bit(quest_rules,qr_NEWENEMYTILES))
            usetile = (guysbuf[id].s_tile - guysbuf[id].tile)+1;
        else
            usetile = (guysbuf[id].misc8);
            
        break;
    }
    
    return zc_max(get_bit(quest_rules, qr_NEWENEMYTILES) ? -guysbuf[id].e_tile
                  : -guysbuf[id].tile, usetile);
}

static ListData enemy_dlg_list(enemy_viewer, &font);

int32_t enelist_proc(int32_t msg,DIALOG *d,int32_t c,bool use_abc_list)
{
	bool is_screen_select = d->dp == &enemy_dlg_list;
    int32_t ret;
	
	if(!is_screen_select && msg == MSG_XCHAR)
	{
		if(key_shifts & KB_CTRL_FLAG) //CTRL overrides the lister search function
		{
			int32_t ret = D_USED_CHAR;
			switch(c>>8)
			{
				case KEY_V:
					paste_enemy();
					break;
				case KEY_C:
					copy_enemy();
					break;
				case KEY_S:
					save_enemy();
					break;
				case KEY_L:
					load_enemy();
					break;
				default: ret = 0;
			}
			if(ret) return ret;
		}
	}
    
    if(use_abc_list)
        ret= jwin_abclist_proc(msg,d,c);
    else
        ret= jwin_list_proc(msg,d,c);
        
    if(msg==MSG_DRAW||msg==MSG_CHAR)
    {
        int32_t id;
        
        // Conveniently hacking the Select Enemy and Screen Enemy dialogs together -L
        if(d->dp == &enemy_dlg_list)
        {
            id = Map.CurrScr()->enemy[d->d1];
        }
        else
        {
            id = bie[d->d1].i;
        }
        
        int32_t tile = get_bit(quest_rules, qr_NEWENEMYTILES) ? guysbuf[id].e_tile
                   : guysbuf[id].tile;
        int32_t cset = guysbuf[id].cset;
        int32_t x = d->x + int32_t(195 * (is_large ? 1.5:1));
        int32_t y = d->y + int32_t(2 * (is_large ? 1.5:1));
        int32_t w = 20;
        int32_t h = 20;
        
        if(is_large)
        {
            w = 36;
            h = 36;
        }
        
        BITMAP *buf = create_bitmap_ex(8,20,20);
        BITMAP *bigbmp = create_bitmap_ex(8,w,h);
        
        if(buf && bigbmp)
        {
            clear_bitmap(buf);
            
            if(tile)
                overtile16(buf, tile+efrontfacingtile(id),2,2,cset,0);
                
            stretch_blit(buf, bigbmp, 2,2, 17, 17, 2, 2,w-2, h-2);
            destroy_bitmap(buf);
            jwin_draw_frame(bigbmp,0,0,w,h,FR_DEEP);
            blit(bigbmp,screen,0,0,x,y,w,h);
            destroy_bitmap(bigbmp);
        }
        
        /*
            rectfill(screen, x, y+20*(is_large?2:1), x+int32_t(w*(is_large?1.5:1))-1, y+32*(is_large?2:1)-1, vc(4));
        */
        textprintf_ex(screen,is_large?font:spfont,x,y+20*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"#%d   ",id);
	
	textprintf_ex(screen,is_large?font:spfont,x,y+26*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"Tile: %d   ",guysbuf[id].tile);
	
	textprintf_ex(screen,is_large?font:spfont,x,y+32*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"sTil: %d   ",guysbuf[id].s_tile);
	textprintf_ex(screen,is_large?font:spfont,x,y+38*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"eTil: %d   ",guysbuf[id].e_tile);
        
        textprintf_ex(screen,is_large?font:spfont,x,y+44*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"HP: ");
        textprintf_ex(screen,is_large?font:spfont,x+int32_t(14*(is_large?1.5:1)),y+44*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"%d   ",guysbuf[id].hp);
        
        textprintf_ex(screen,is_large?font:spfont,x,y+50*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"Dmg: ");
        textprintf_ex(screen,is_large?font:spfont,x+int32_t(14*(is_large?1.5:1)),y+50*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"%d   ",guysbuf[id].dp);
	
	
	
	textprintf_ex(screen,is_large?font:spfont,x,y+56*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"Fam: %d   ",guysbuf[id].family);
	textprintf_ex(screen,is_large?font:spfont,x,y+62*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"Drop: %d   ",guysbuf[id].item_set);
	textprintf_ex(screen,is_large?font:spfont,x,y+68*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"Script: %d   ",guysbuf[id].script);
	textprintf_ex(screen,is_large?font:spfont,x,y+74*(is_large?2:1),jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"WScript: %d   ",guysbuf[id].weaponscript);
    
	
    }
    
    return ret;
}

int32_t select_enemy(const char *prompt,int32_t enemy,bool hide,bool is_editor,int32_t &exit_status)
{
    //if(bie_cnt==-1)
    {
        build_bie_list(hide);
    }
    int32_t index=0;
    
    for(int32_t j=0; j<bie_cnt; j++)
    {
        if(bie[j].i == enemy)
        {
            index=j;
        }
    }
    
    elist_dlg[0].dp=(void *)prompt;
    elist_dlg[0].dp2=lfont;
    elist_dlg[2].d1=index;
    ListData enemy_list(enemylist, &font);
    elist_dlg[2].dp=(void *) &enemy_list;
    
    if(is_large) large_dialog(elist_dlg);
    
    if(is_editor)
    {
        elist_dlg[2].dp3 = (void *)&elist_rclick_func;
        elist_dlg[2].flags|=(D_USER<<1);
        elist_dlg[3].dp = (void *)"Edit";
        elist_dlg[4].dp = (void *)"Done";
        elist_dlg[3].x = is_large?285:90;
        elist_dlg[4].x = is_large?405:170;
        elist_dlg[5].flags |= D_HIDDEN;
    }
    else
    {
        elist_dlg[2].dp3 = NULL;
        elist_dlg[2].flags&=~(D_USER<<1);
        elist_dlg[3].dp = (void *)"OK";
        elist_dlg[4].dp = (void *)"Cancel";
        elist_dlg[3].x = is_large?240:60;
        elist_dlg[4].x = is_large?350:135;
        elist_dlg[5].flags &= ~D_HIDDEN;
    }
    
    exit_status=zc_popup_dialog(elist_dlg,2);
    
    if(exit_status==0||exit_status==4)
    {
        return -1;
    }
    
    index = elist_dlg[2].d1;
    return bie[index].i;
}

int32_t select_guy(const char *prompt,int32_t guy)
{
    //  if(bie_cnt==-1)
    {
        build_big_list(true);
    }
    
    int32_t index=0;
    
    for(int32_t j=0; j<big_cnt; j++)
    {
        if(big[j].i == guy)
        {
            index=j;
        }
    }
    
    glist_dlg[0].dp=(void *)prompt;
    glist_dlg[0].dp2=lfont;
    glist_dlg[2].d1=index;
    ListData guy_list(guylist, &font);
    glist_dlg[2].dp=(void *) &guy_list;
    
    if(is_large)
        large_dialog(glist_dlg);
        
    int32_t ret;
    
    do
    {
        ret=zc_popup_dialog(glist_dlg,2);
        
        if(ret==5)
        {
            int32_t id = big[glist_dlg[2].d1].i;
            
            switch(id)
            {
            case gABEI:
                jwin_alert(old_guy_string[id],"The old man. Uses tile 84.",NULL,NULL,"O&K",NULL,'k',0,lfont);
                break;
                
            case gAMA:
                jwin_alert(old_guy_string[id],"The old woman. Uses tile 85.",NULL,NULL,"O&K",NULL,'k',0,lfont);
                break;
                
            case gDUDE:
                jwin_alert(old_guy_string[id],"The shopkeeper. Uses tile 86.",NULL,NULL,"O&K",NULL,'k',0,lfont);
                break;
                
            case gMOBLIN:
                jwin_alert(old_guy_string[id],"The generous Moblin. Uses tile 116.",NULL,NULL,"O&K",NULL,'k',0,lfont);
                break;
                
            case gGORIYA:
                jwin_alert(old_guy_string[id],"The hungry Goriya. Uses tile 132.","He isn't entirely necessary to make","use of the 'Feed the Goriya' Room Type.","O&K",NULL,'k',0,lfont);
                break;
                
            case gFIRE:
                jwin_alert(old_guy_string[id],"A sentient flame. Uses tile 65, and","flips horizontally as it animates.",NULL,"O&K",NULL,'k',0,lfont);
                break;
                
            case gFAIRY:
                jwin_alert(old_guy_string[id],"A fairy. Uses tiles 63 and 64. Even if the","DMap uses 'Special Rooms/Guys In Caves Only'","she will still appear in regular screens.","O&K",NULL,'k',0,lfont);
                break;
                
            case gZELDA:
                jwin_alert(old_guy_string[id],"The princess. Uses tiles 35 and 36.","Approaching her won't cause the game to end.","(Unless you touch a Zelda combo flag.)","O&K",NULL,'k',0,lfont);
                break;
                
            case gABEI2:
                jwin_alert(old_guy_string[id],"A different old man. Uses tile 87.",NULL,NULL,"O&K",NULL,'k',0,lfont);
                break;
                
            case gEMPTY:
                jwin_alert(old_guy_string[id],"An invisible Guy. Uses tile 259, which is","usually empty. Use it when you just want the","String to appear without a visible Guy.","O&K",NULL,'k',0,lfont);
                break;
                
            default:
                jwin_alert("Help","Select a Guy, then click","Help to find out what it is.",NULL,"O&K",NULL,'k',0,lfont);
                break;
            }
        }
    }
    while(ret==5);
    
    if(ret==0||ret==4)
    {
        return -1;
    }
    
    
    index = glist_dlg[2].d1;
    return big[index].i;
}

uint8_t check[2] = { (uint8_t)'\x81',0 };

static DIALOG enemy_dlg[] =
{
    /* (dialog proc)         (x)     (y)    (w)     (h)     (fg)                    (bg)                   (key)    (flags)      (d1)        (d2)  (dp) */
    { jwin_win_proc,          0,      0,    256,    190+10,    vc(14),                 vc(1),                   0,       D_EXIT,     0,           0, (void *) "Enemies",          NULL,   NULL  },
    { d_timer_proc,           0,      0,      0,      0,    0,                      0,                       0,       0,          0,           0,  NULL,                        NULL,   NULL  },
    { d_enelistnoabc_proc,        14,     24,    188,     97,    jwin_pal[jcTEXTFG],     jwin_pal[jcTEXTBG],      0,       D_EXIT,     0,           0, (void *) &enemy_dlg_list,    NULL,   NULL  },
    { jwin_button_proc,      12,    130+10,    109,     21,    vc(14),                 vc(1),                   'e',     D_EXIT,     0,           0, (void *) "Paste &Enemies",   NULL,   NULL  },
    { d_dummy_proc,          210,    24,     20,     20,    vc(11),                 vc(1),                   0,       0,          0,           0,  NULL,                        NULL,   NULL  },
    { jwin_button_proc,     127,    130+10,     42,     21,    vc(14),                 vc(1),                   'f',     D_EXIT,     0,           0, (void *) "&Flags",           NULL,   NULL  },
    { jwin_button_proc,     175,    130+10,     53,     21,    vc(14),                 vc(1),                   'p',     D_EXIT,     0,           0, (void *) "&Pattern",         NULL,   NULL  },
    { d_keyboard_proc,        0,      0,      0,      0,    0,                      0,                       'c',     0,          0,           0, (void *) close_dlg,          NULL,   NULL  },
    { d_keyboard_proc,        0,      0,      0,      0,    0,                      0,                       'v',     0,          0,           0, (void *) close_dlg,          NULL,   NULL  },
    { d_keyboard_proc,        0,      0,      0,      0,    0,                      0,                       0,       0,          KEY_DEL,     0, (void *) close_dlg,          NULL,   NULL  },
    // 10
    { jwin_button_proc,      50,    156+10,     61,     21,    vc(14),                 vc(1),                  'k',       D_EXIT,     0,           0, (void *) "O&K",               NULL,   NULL  },
    { jwin_button_proc,     130,    156+10,     61,     21,    vc(14),                 vc(1),                  27,       D_EXIT,     0,           0, (void *) "Cancel",           NULL,   NULL  },
    { d_keyboard_proc,        0,      0,      0,      0,    0,                      0,                      27,       0,          0,           0, (void *) close_dlg,          NULL,   NULL  },
    { jwin_text_proc,         4,    208,      8,      8,    vc(14),                 vc(1),                   0,       0,          0,           0, (void *) check,              NULL,   NULL  },
    { d_keyboard_proc,        0,      0,      0,      0,    0,                      0,                       0,       0,          KEY_F1,      0, (void *) onHelp,             NULL,   NULL  },
    { NULL,                   0,      0,      0,      0,    0,                      0,                       0,       0,          0,           0,  NULL,                        NULL,   NULL  }
};

int32_t onEnemies()
{
	word oldenemy[10];
	memcpy(oldenemy,Map.CurrScr()->enemy,10*sizeof(word));
	restore_mouse();
	char buf[26] = " ";
	int32_t ret;
	int32_t copy=-1;
	
	build_bie_list(true);
	
	enemy_dlg[0].dp2=lfont;
	
	if(Map.CanPaste())
	{
		enemy_dlg[3].flags=D_EXIT;
		sprintf(buf,"Past&e (from %d:%02X)",(Map.CopyScr()>>8)+1,Map.CopyScr()&255);
	}
	else
	{
		enemy_dlg[3].flags=D_DISABLED;
		sprintf(buf,"Past&e from screen");
	}
	
	enemy_dlg[3].dp=buf;
	enemy_dlg[2].d1=0;
	
	do
	{
		if(copy==-1)
		{
			enemy_dlg[13].y=zq_screen_h;
		}
		else
		{
			enemy_dlg[13].y=(int32_t)((copy<<3)*(is_large?1.6:1))+enemy_dlg[2].y+4;
		}
		
		if(is_large)
		{
			large_dialog(enemy_dlg);
			// Fix d_enelist_proc
			enemy_dlg[2].dp2 = 0;
			//((ListData *)enemy_dlg[2].dp)->font = &sfont3;
			((ListData *)enemy_dlg[2].dp)->font = &lfont_l;
		}
		
		ret = zc_do_dialog(enemy_dlg,2);
		
		switch(ret)
		{
		case 2:
		{
			int32_t exit_status;
			int32_t i = enemy_dlg[2].d1;
			popup_zqdialog_start();
			do
			{
				int32_t enemy = Map.CurrScr()->enemy[i];
				enemy = select_enemy("Select Enemy",enemy,true,false,exit_status);
				
				if(enemy>=0)
				{
					if(exit_status==5 && enemy > 0)
					{
						edit_enemydata(enemy);
					}
					else
					{
						saved=false;
						Map.CurrScr()->enemy[i] = enemy;
					}
				}
			}
			while(exit_status==5);
			popup_zqdialog_end();
		}
		break;
		
		case 3:
			saved=false;
            Map.DoPasteScreenCommand(PasteCommandType::ScreenEnemies);
			break;
			
		case 5:
			onEnemyFlags();
			break;
			
		case 6:
			onPattern();
			break;
			
		case 7:
			copy = enemy_dlg[2].d1;
			break;
			
		case 8:
			saved=false;
			
			if(copy>=0)
			{
				Map.CurrScr()->enemy[enemy_dlg[2].d1] = Map.CurrScr()->enemy[copy];
			}
			
			break;
			
		case 9:
			saved=false;
			Map.CurrScr()->enemy[enemy_dlg[2].d1] = 0;
			break;
			
		case 0:
		case 11: //cancel
			memcpy(Map.CurrScr()->enemy,oldenemy,10*sizeof(word));
			break;
			
		case 10: //ok
		{
			bool end = false;
			
			for(int32_t i=0; i<10; i++)
			{
				if(Map.CurrScr()->enemy[i]==0)
					end = true;
				else if(end)
				{
					if(jwin_alert("Inactive Enemies","Enemies won't appear if they're preceded"," by '(None)' in the list! Continue?",NULL,"Yes","No",'y','n',lfont)==2)
						ret=-1;
						
					break;
				}
			}
			
			break;
		}
		}
	}
	while(ret<10&&ret!=0);
	
	refresh(rALL);
	return D_O_K;
}

/*******************************/
/********** onHeader ***********/
/*******************************/

char author[65],title[65],password[32];

int32_t d_showedit_proc(int32_t msg,DIALOG *d,int32_t c)
{
    int32_t ret = jwin_edit_proc(msg,d,c);
    
    if(msg==MSG_DRAW)
    {
        scare_mouse();
        (d+1)->proc(MSG_DRAW,d+1,0);
        unscare_mouse();
    }
    
    return ret;
}

int32_t onHeader()
{
	call_header_dlg();
    return D_O_K;
}

void call_cheats_dlg();
int32_t onCheats()
{
	call_cheats_dlg();
	return D_O_K;
}

const char *subscrtype_str[ssdtMAX+1] = { "Original","New Subscreen","Revision 2","BS Zelda Original","BS Zelda Modified","BS Zelda Enhanced","BS Zelda Complete","Zelda 3","Custom" };

const char *subscrtypelist(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        bound(index,0,ssdtMAX);
        return subscrtype_str[index];
    }
    
    *list_size=ssdtMAX+1;
    return NULL;
}

static ListData subscreen_type_dlg_list(subscrtypelist, &font);

static DIALOG subscreen_type_dlg[] =
{
    /* (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp) */
    { jwin_win_proc,     83,   32,   154,  70,  vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "Subscreen Type", NULL, NULL },
    { jwin_button_proc,     89,  77,  61,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "OK", NULL, NULL },
    { jwin_button_proc,     170,  77,  61,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { jwin_droplist_proc,   107-8,  57,   106+15,  16,   jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,       0,          1,             0, (void *) &subscreen_type_dlg_list, NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

int32_t onSubscreen()
{
    int32_t tempsubscreen=zinit.subscreen;
    subscreen_type_dlg[0].dp2=lfont;
    subscreen_type_dlg[3].d1=zinit.subscreen;
    
    if(is_large)
        large_dialog(subscreen_type_dlg);
        
    int32_t ret = zc_popup_dialog(subscreen_type_dlg,2);
    
    if(ret==1)
    {
        if(subscreen_type_dlg[3].d1!=tempsubscreen)
        {
            zinit.subscreen=subscreen_type_dlg[3].d1;
            
            if(zinit.subscreen!=ssdtMAX)  //custom
            {
                if(tempsubscreen==ssdtMAX)
                {
                    if(jwin_alert("Reset Custom Subscreens","This will delete all of your custom subscreens!","Proceed?",NULL,"&OK","&Cancel",13,27,lfont)==2)
                    {
                        zinit.subscreen=ssdtMAX;
                        return D_O_K;
                    }
                }
                
                reset_subscreens();
                setupsubscreens();
            }
            
            saved=false;
        }
    }
    
    return D_O_K;
}

bool do_x_button(BITMAP *dest, int32_t x, int32_t y)
{
    bool over=false;
    
    while(gui_mouse_b())
    {
        custom_vsync();
        
        if(isinRect(gui_mouse_x(),gui_mouse_y(),x,y,x+15,y+13))
        {
            if(!over)
            {
                scare_mouse();
                draw_x_button(dest, x, y, D_SELECTED);
                unscare_mouse();
                over=true;
            }
        }
        else
        {
            if(over)
            {
                scare_mouse();
                draw_x_button(dest, x, y, 0);
                unscare_mouse();
                over=false;
            }
        }
    }
    
    return over;
}


int32_t d_dummy_proc(int32_t,DIALOG *,int32_t)
{
	return D_O_K;
}

int32_t d_maptile_proc(int32_t msg, DIALOG *d, int32_t)
{
    switch(msg)
    {
    case MSG_CLICK:
        if ( PreFillMapTilePage )
	{
		DMapEditorLastMaptileUsed = ((select_dmap_tile(d->d1,d->d2,1,d->fg,true, 0, true))-1);
		return D_REDRAW;
	}
        else
	{
		if(select_tile(d->d1,d->d2,1,d->fg,true, 0, true))
		return D_REDRAW;
	}
            
        break;
	
    case MSG_DRAW:
    {
        int32_t dw = d->w;
        int32_t dh = d->h;
        
        if(is_large && d->dp2==(void*)1)
        {
            dw /= 2;
            dh /= 2;
        }
        
        BITMAP *buf = create_bitmap_ex(8,dw,dh);
        
        if(buf)
        {
            clear_bitmap(buf);
            
            for(int32_t y=0; y<dh; y+=16)
                for(int32_t x=0; x<dw; x+=16)
                {
                    if(d->d1)
                        puttile16(buf,d->d1+(y>>4)*20+(x>>4),x,y,d->fg,0);
                }
                
            if(is_large && d->dp2==(void*)1)
                stretch_blit(buf,screen,0,0,dw,dh,d->x-is_large,d->y-is_large,dw*(is_large?2:1),dh*(is_large?2:1));
            else
                blit(buf,screen,0,0,d->x,d->y,dw,dh);
                
            destroy_bitmap(buf);
        }
    }
    }
    
    return D_O_K;
}

static int32_t last_combo=0;
static int32_t last_cset=0;
static combo_alias temp_aliases[MAXCOMBOALIASES];

static char comboa_str_buf[32];

int32_t d_comboalist_proc(int32_t msg,DIALOG *d,int32_t c)
{
    int32_t d1 = d->d1;
    int32_t ret = jwin_droplist_proc(msg,d,c);
    comboa_cnt = d->d1;
    
    if(d1!=d->d1)
    {
        set_comboaradio(temp_aliases[comboa_cnt].layermask);
        return D_REDRAW;
    }
    
    return ret;
}

const char *comboalist(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        bound(index,0,MAXCOMBOALIASES-1);
        sprintf(comboa_str_buf,"%d",index);
        return comboa_str_buf;
    }
    
    *list_size=MAXCOMBOALIASES;
    return NULL;
}

extern int32_t scheme[jcMAX];

int32_t d_comboa_proc(int32_t msg,DIALOG *d,int32_t c)
{
    //these are here to bypass compiler warnings about unused arguments
    c=c;
    
    combo_alias *combo;
    combo = &temp_aliases[comboa_cnt];
    int32_t position;
    int32_t cur_layer, temp_layer;
    int32_t lay_count=0;
    int32_t size = 1+is_large;
    
    int32_t cx1=(gui_mouse_x()-d->x-(120-(combo->width*8)));
    int32_t cy1=(gui_mouse_y()-d->y-(80-(combo->height*8)));
    int32_t cx=cx1/(16*size);
    int32_t cy=cy1/(16*size);
    
    int32_t co,cs;
    
    
    switch(msg)
    {
    case MSG_CLICK:
        Z_message("click (%d, %d) (%d, %d)\n", cx1, cy1, cx, cy);
        
        if((cx>combo->width)||(cx1<0))
            return D_O_K;
            
        if((cy>combo->height)||(cy1<0))
            return D_O_K;
            
        for(int32_t j=0; j<layer_cnt; j++)
        {
            if(combo->layermask&(1<<j))
                lay_count++;
        }
        
        position=(lay_count)*(combo->width+1)*(combo->height+1);
        position+=(cy*(combo->width+1))+cx;
        
        if(key[KEY_LSHIFT]||key[KEY_RSHIFT])
        {
            combo->combos[position] = 0;
            combo->csets[position] = 0;
            
            while(gui_mouse_b())
            {
                /* do nothing */
                rest(1);
            }
            
            return D_REDRAW;
        }
        
        co=combo->combos[position];
        cs=combo->csets[position];
        
        if((co==0)||(key[KEY_ZC_LCONTROL]))
        {
            co=last_combo;
            cs=last_cset;
        }
        
        if((select_combo_2(co,cs)))
        {
            last_combo = co;
            last_cset = cs;
            
            combo->combos[position]=co;
            combo->csets[position]=cs;
        }
        
        return D_REDRAW;
        break;
        
    case MSG_DRAW:
        BITMAP *buf = create_bitmap_ex(8,d->w,d->h);
        
        if(buf)
        {
            clear_bitmap(buf);
            
            for(int32_t z=0; z<=comboa_lmasktotal(combo->layermask); z++)
            {
                int32_t k=0;
                cur_layer=0;
                temp_layer=combo->layermask;
                
                while((temp_layer!=0)&&(k<z))
                {
                    if(temp_layer&1)
                    {
                        k++;
                    }
                    
                    cur_layer++;
                    temp_layer = temp_layer>>1;
                }
                
                for(int32_t y=0; (y<d->h)&&((y/16)<=combo->height); y+=16)
                {
                    for(int32_t x=0; (x<d->w)&&((x/16)<=combo->width); x+=16)
                    {
                        int32_t cpos = (z*(combo->width+1)*(combo->height+1))+(((y/16)*(combo->width+1))+(x/16));
                        
                        if(combo->combos[cpos])
                        {
                            if(!((d-1)->flags&D_SELECTED)||(cur_layer==layer_cnt))
                            {
                                if(z==0)
                                {
                                    puttile16(buf,combobuf[combo->combos[cpos]].tile,x,y,combo->csets[cpos],combobuf[combo->combos[cpos]].flip);
                                }
                                else
                                {
                                    overtile16(buf,combobuf[combo->combos[cpos]].tile,x,y,combo->csets[cpos],combobuf[combo->combos[cpos]].flip);
                                }
                            }
                        }
                    }
                }
            }
            
            rectfill(screen, d->x-2,d->y-2,d->x+256+2,d->y+176+2,jwin_pal[jcBOX]);
            int32_t dx = 120-(combo->width*8)+d->x;
            int32_t dy = 80-(combo->height*8)+d->y;
            stretch_blit(buf,screen,0,0,(combo->width+1)*16,(combo->height+1)*16,dx,dy,(combo->width+1)*16*size,(combo->height+1)*16*size);
            //blit(buf,screen,0,0,120-(combo->width*8)+d->x,80-(combo->height*8)+d->y,(combo->width+1)*16,(combo->height+1)*16);
            (d-11)->w = (combo->width+1)*16*size+2+(is_large?0:2);
            (d-11)->h = (combo->height+1)*16*size+2+(is_large?0:2);
            (d-11)->x = 120-(combo->width*8)+4*size+(is_large?2:0)+(d-14)->x;
            (d-11)->y = 80-(combo->height*8)+25*size+(is_large?2:0)+(d-14)->y;
            object_message((d-11),MSG_DRAW,0);
            
            destroy_bitmap(buf);
        }
        
        break;
    }
    
    return D_O_K;
}

void draw_combo_alias_thumbnail(BITMAP *dest, combo_alias *combo, int32_t x, int32_t y, int32_t size)
{
    if(!combo->combo)
    {
        int32_t cur_layer, temp_layer;
        
        int32_t cw=combo->width+1;
        int32_t ch=combo->height+1;
        int32_t dw=cw<<4;
        int32_t dh=ch<<4;
        int32_t sw=16, sh=16, sx=0, sy=0;
        
        if(cw<ch)
        {
            sw=((cw<<4)/ch);
            sx=((16-sw)>>1);
        }
        else
        {
            sh=((ch<<4)/cw);
            sy=((16-sh)>>1);
        }
        
        BITMAP *buf = create_bitmap_ex(8,dw,dh);
        BITMAP *buf2 = create_bitmap_ex(8, 16*size, 16*size);
        clear_bitmap(buf);
        clear_bitmap(buf2);
        
        if(buf&&(combo->width>0||combo->height>0||combo->combos[0]>0))
        {
            clear_bitmap(buf);
            
            for(int32_t z=0; z<=comboa_lmasktotal(combo->layermask); z++)
            {
                int32_t k=0;
                cur_layer=0;
                temp_layer=combo->layermask;
                
                while((temp_layer!=0)&&(k<z))
                {
                    if(temp_layer&1)
                    {
                        k++;
                    }
                    
                    cur_layer++;
                    temp_layer = temp_layer>>1;
                }
                
                for(int32_t y2=0; (y2<dh)&&((y2>>4)<=combo->height); y2+=16)
                {
                    for(int32_t x2=0; (x2<dw)&&((x2>>4)<=combo->width); x2+=16)
                    {
                        int32_t cpos = (z*(combo->width+1)*(combo->height+1))+(((y2/16)*(combo->width+1))+(x2/16));
                        
                        if(combo->combos[cpos])
                        {
                            if(z==0)
                            {
                                puttile16(buf,combobuf[combo->combos[cpos]].tile,x2,y2,combo->csets[cpos],combobuf[combo->combos[cpos]].flip);
                            }
                            else
                            {
                                overtile16(buf,combobuf[combo->combos[cpos]].tile,x2,y2,combo->csets[cpos],combobuf[combo->combos[cpos]].flip);
                            }
                        }
                    }
                }
            }
            
            stretch_blit(buf, buf2, 0, 0, (cw*16), (ch*16), sx*size, sy*size, sw*size, sh*size);
            blit(buf2, dest, 0, 0, x, y, 16*size, 16*size);
        }
        else
        {
            rectfill(dest,x,y,x+16*size-1,y+16*size-1,0);
            rectfill(dest,x+3*size,y+3*size,x+12*size,y+12*size,vc(4));
        }
        
        if(buf)
            destroy_bitmap(buf);
            
        if(buf2)
            destroy_bitmap(buf2);
    }
    else
    {
        if(combobuf[combo->combo].tile>0)
        {
            put_combo(dest,x, y, combo->combo, combo->cset,0,0);
        }
        else
        {
            rectfill(dest,x,y,x+16*size-1,y+16*size-1,0);
            rectfill(dest,x+3*size,y+3*size,x+12*size,y+12*size,vc(4));
        }
    }
}

int32_t d_comboat_proc(int32_t msg,DIALOG *d,int32_t)
{
    switch(msg)
    {
    case MSG_CLICK:
    {
        int32_t c2;
        int32_t cs;
        c2=temp_aliases[comboa_cnt].combo;
        cs=temp_aliases[comboa_cnt].cset;
        
        if(gui_mouse_b()&2)  //right mouse button
        {
            if(c2==0&&cs==0&&!(gui_mouse_b()&1))
            {
                return D_O_K;
            }
            
            temp_aliases[comboa_cnt].combo=0;
            temp_aliases[comboa_cnt].cset=0;
        }
        
        if(gui_mouse_b()&1)  //left mouse button
        {
            if(select_combo_2(c2, cs))
            {
                temp_aliases[comboa_cnt].combo=c2;
                temp_aliases[comboa_cnt].cset=cs;
            }
            
            return D_REDRAW;
        }
        else
        {
            return D_REDRAWME;
        }
    }
    break;
    
    case MSG_DRAW:
        draw_combo_alias_thumbnail(screen, &temp_aliases[comboa_cnt], d->x-is_large, d->y-is_large,(is_large+1));
        break;
        
    default:
        break;
    }
    
    return D_O_K;
}

int32_t d_comboa_radio_proc(int32_t msg,DIALOG *d,int32_t c);

static DIALOG orgcomboa_dlg[] =
{
    /* (dialog proc)     (x)   (y)    (w)   (h)    (fg)      (bg)     (key)    (flags)       (d1)           (d2)      (dp) */
    { jwin_win_proc,         0,    0,   200,  161,   vc(14),   vc(1),       0,     D_EXIT,       0,             0, (void *) "Organize Combo Aliases", NULL, NULL },
    { jwin_button_proc,     27,   130,  61,   21,   vc(14),  vc(1),  'k',     D_EXIT,     0,             0, (void *) "O&K", NULL, NULL },
    { jwin_button_proc,     112,  130,  61,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    
    { jwin_radio_proc,		10,	   40,	33,		9,	vc(14),	 vc(1),	  0,		0,				0,			0,	(void*) "Copy", NULL, NULL },
    { jwin_text_proc,     10,   50,   33,		9,       0,       0,      0,       0,          0,             0, (void *) "", NULL, NULL },
    // { jwin_radio_proc,		10,	   50,	33,		9,	vc(14),	 vc(1),	  0,		0,				0,			0,			(void*) "Move", NULL, NULL },
    { jwin_radio_proc,		10,	   60,	33,		9,	vc(14),	 vc(1),	  0,		0,				0,			0,	(void*) "Swap", NULL, NULL },
    /* 6 */  { jwin_edit_proc,      110,   35,   32,   16,    vc(12),  vc(1),  0,       0,          4,             0,       NULL, NULL, NULL },
    { jwin_edit_proc,      110,   55,   32,   16,    vc(12),  vc(1),  0,       0,          4,             0,       NULL, NULL, NULL },
    { jwin_text_proc,     60,   40,   80,   8,       0,       0,      0,       0,          0,             0, (void *) "Source", NULL, NULL },
    { jwin_text_proc,     60,   60,   80,   8,       0,       0,      0,       0,          0,             0, (void *) "Dest", NULL, NULL},
    { jwin_radio_proc,		10,	   80,		60,		9,	vc(14),	 vc(1),	  0,		0,				0,			0,	(void*) "Insert new (before source)", NULL, NULL },
    { jwin_radio_proc,		10,	   100,		60,		9,	vc(14),	 vc(1),	  0,		0,				0,			0,	(void*) "Delete source", NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

static DIALOG newcomboa_dlg[] =
{
    /* (dialog proc)     (x)   (y)    (w)   (h)    (fg)      (bg)     (key)    (flags)       (d1)           (d2)      (dp) */
    { jwin_win_proc,         0,    0,   200,  161,   vc(14),   vc(1),       0,     D_EXIT,       0,             0, (void *) "Combo Alias Properties", NULL, NULL },
    { jwin_button_proc,     27,   130,  61,   21,   vc(14),  vc(1),  'k',     D_EXIT,     0,             0, (void *) "O&K", NULL, NULL },
    { jwin_button_proc,     112,  130,  61,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { jwin_text_proc,     24,   34,   80,   8,       0,       0,      0,       0,          0,             0, (void *) "Alias Width", NULL, NULL },
    { jwin_text_proc,     24,   52,   80,   8,       0,       0,      0,       0,          0,             0, (void *) "Alias Height", NULL, NULL },
    { jwin_text_proc,     24,   70,   100,   8,       0,       0,      0,       0,          0,             0, (void *) "Layers to Draw On:", NULL, NULL },
    { jwin_edit_proc,      104,   30,   28-6,   16,    vc(12),  vc(1),  0,       0,          2,             0,       NULL, NULL, NULL },
    { jwin_edit_proc,      122,   48,   28-6,   16,    vc(12),  vc(1),  0,       0,          2,             0,       NULL, NULL, NULL },
    { jwin_check_proc,     24,   86,   24,   9,    vc(12),  vc(1),  0,       0,          1,             0, (void *) "1", NULL, NULL },
    { jwin_check_proc,     50,   86,   24,   9,    vc(12),  vc(1),  0,       0,          1,             0, (void *) "2", NULL, NULL },
    { jwin_check_proc,     76,   86,   24,   9,    vc(12),  vc(1),  0,       0,          1,             0, (void *) "3", NULL, NULL },
    { jwin_check_proc,     102,   86,   24,   9,    vc(12),  vc(1),  0,       0,          1,             0, (void *) "4", NULL, NULL },
    { jwin_check_proc,     128,   86,   24,   9,    vc(12),  vc(1),  0,       0,          1,             0, (void *) "5", NULL, NULL },
    { jwin_check_proc,     154,   86,   24,   9,    vc(12),  vc(1),  0,       0,          1,             0, (void *) "6", NULL, NULL },
    
    
    // { jwin_text_proc,     24,   106,   80,   8,       0,       0,      0,       0,          0,             0,       (void *) "Copy to :", NULL, NULL },
    //15
    // { jwin_edit_proc,      100,   100,   28-6,   16,    vc(12),  vc(1),  0,       0,          2,             0,       NULL, NULL, NULL },
    // { jwin_check_proc,     84,   106,   24,   9,    vc(12),  vc(1),  0,       0,          1,             0,       (void *) "", NULL, NULL },
    
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

bool swapComboAlias(int32_t source, int32_t dest)
{
    if(source==dest) return false;
    
    combo_alias *combo=&temp_aliases[source], *oldcombo=&temp_aliases[dest];
    
    byte w=oldcombo->width;
    oldcombo->width=combo->width;
    combo->width=w;
    
    byte h=oldcombo->height;
    oldcombo->height=combo->height;
    combo->height=h;
    
    byte l=oldcombo->layermask;
    oldcombo->layermask=combo->layermask;
    combo->layermask=l;
    
    word c=oldcombo->combo;
    oldcombo->combo=combo->combo;
    combo->combo=c;
    
    c=oldcombo->cset;
    oldcombo->cset=combo->cset;
    combo->cset=c;
    
    word* cp = oldcombo->combos;
    oldcombo->combos=combo->combos;
    combo->combos = cp;
    
    byte *sp = oldcombo->csets;
    oldcombo->csets=combo->csets;
    combo->csets=sp;
    
    return true;
}


bool copyComboAlias(int32_t source, int32_t dest)
{
    if(source==dest) return false;
    
    // al_trace("count is %i\n", comboa_cnt);
    // if (dest > comboa_cnt-1) return false;
    // al_trace("Copying %i to %i\n",source, dest);
    
    combo_alias *combo, *oldcombo;
    combo = &temp_aliases[source];
    oldcombo = &temp_aliases[dest];
    
    int32_t new_count=(comboa_lmasktotal(combo->layermask)+1)*(combo->width+1)*(combo->height+1);
    
    if(oldcombo->combos != NULL) delete[] oldcombo->combos;
    
    if(oldcombo->csets != NULL) delete[] oldcombo->csets;
    
    word *new_combos = new word[new_count];
    byte *new_csets = new byte[new_count];
    
    memcpy(new_combos, combo->combos, sizeof(word)*new_count);
    memcpy(new_csets, combo->csets, sizeof(byte)*new_count);
    
    oldcombo->combos=new_combos;
    oldcombo->csets=new_csets;
    
    oldcombo->width=combo->width;
    oldcombo->height=combo->height;
    oldcombo->layermask=combo->layermask;
    oldcombo->combo=combo->combo;
    oldcombo->cset=combo->cset;
    
    
    return true;
}

int32_t getcurrentcomboalias();

int32_t onOrgComboAliases()
{
	char cSrc[8];
	char cDest[8];
	sprintf(cSrc,"%d", getcurrentcomboalias());
	strcpy(cDest,cSrc);
	int32_t iSrc = 0;
	int32_t iDest = 0;
	
	//sprintf(cSrc,"0");
	//sprintf(cDest,"0");
	orgcomboa_dlg[0].dp2=lfont;
	orgcomboa_dlg[6].dp= cSrc;
	orgcomboa_dlg[7].dp= cDest;
	int32_t ret = 1;
	if(is_large)
		large_dialog(orgcomboa_dlg);
	do
	{
		iSrc = atoi((char*)orgcomboa_dlg[6].dp);
		iDest = atoi((char*)orgcomboa_dlg[7].dp);
		ret = zc_popup_dialog(orgcomboa_dlg,-1);
		
		if(ret!=1) return ret;
		
		if((atoi((char*) orgcomboa_dlg[6].dp))<0 || (atoi((char*) orgcomboa_dlg[6].dp)) > MAXCOMBOALIASES-1)
		{
			char buf[100];
			snprintf(buf, 100, "Invalid source (range 0-%d)", MAXCOMBOALIASES-1);
			buf[99]='\0';
			jwin_alert("Error",buf,NULL,NULL,"O&K",NULL,'k',0,lfont);
			ret = 1;
		}
		
		// 10,11=ins, del
		if(orgcomboa_dlg[10].flags & D_SELECTED)  //insert
		{
			for(int32_t j=MAXCOMBOALIASES-1; j>(atoi((char*) orgcomboa_dlg[6].dp)); --j)
				copyComboAlias(j-1,j);
			ret = -1;
		}
		
		if(orgcomboa_dlg[11].flags & D_SELECTED)  //delete
		{
			for(int32_t j=(atoi((char*) orgcomboa_dlg[6].dp)); j<MAXCOMBOALIASES-1; ++j)
				copyComboAlias(j+1,j);
			ret = -1;
		}
		
		if((atoi((char*) orgcomboa_dlg[6].dp)) == (atoi((char*) orgcomboa_dlg[7].dp)))
		{
			jwin_alert("Error","Source and dest can't be the same.",NULL,NULL,"O&K",NULL,'k',0,lfont);
			ret = 1;
		}
		
		if((atoi((char*) orgcomboa_dlg[7].dp)) < 0 || (atoi((char*) orgcomboa_dlg[7].dp)) > MAXCOMBOALIASES-1)
		{
			char buf[100];
			snprintf(buf, 100, "Invalid dest (range 0-%d)", MAXCOMBOALIASES-1);
			buf[99]='\0';
			
			jwin_alert("Error",buf,NULL,NULL,"O&K",NULL,'k',0,lfont);
			ret = 1;
		}
		
		if(orgcomboa_dlg[3].flags & D_SELECTED)  //copy
		{
			copyComboAlias((atoi((char*) orgcomboa_dlg[6].dp)),(atoi((char*) orgcomboa_dlg[7].dp)));
			ret = -1;
		}
		
		if(orgcomboa_dlg[5].flags & D_SELECTED)  //swap
		{
			swapComboAlias((atoi((char*) orgcomboa_dlg[6].dp)),(atoi((char*) orgcomboa_dlg[7].dp)));
			ret = -1;
		}
	}
	while(ret==1);
	return ret;
}

int32_t onNewComboAlias()
{
    combo_alias *combo;
    combo = &temp_aliases[comboa_cnt];
    
    char cwidth[5];
    char cheight[5];
    // char cp[3];
    
    word temp_combos[16*11*7];
    byte temp_csets[16*11*7];
    sprintf(cwidth, "%d", combo->width+1);
    sprintf(cheight, "%d", combo->height+1);
    int32_t old_count = (comboa_lmasktotal(combo->layermask)+1)*(combo->width+1)*(combo->height+1);
    int32_t old_width=combo->width;
    int32_t old_height=combo->height;
    int32_t oldlayer=combo->layermask;
    
    for(int32_t i=0; i<old_count; i++)
    {
        temp_csets[i] = combo->csets[i];
        temp_combos[i] = combo->combos[i];
    }
    
    newcomboa_dlg[0].dp2 = lfont;
    newcomboa_dlg[6].dp = cwidth;
    newcomboa_dlg[7].dp = cheight;
    newcomboa_dlg[8].flags = (combo->layermask&1)? D_SELECTED : 0;
    newcomboa_dlg[9].flags = (combo->layermask&2)? D_SELECTED : 0;
    newcomboa_dlg[10].flags = (combo->layermask&4)? D_SELECTED : 0;
    newcomboa_dlg[11].flags = (combo->layermask&8)? D_SELECTED : 0;
    newcomboa_dlg[12].flags = (combo->layermask&16)? D_SELECTED : 0;
    newcomboa_dlg[13].flags = (combo->layermask&32)? D_SELECTED : 0;
    
    if(is_large) large_dialog(newcomboa_dlg);
    
    int32_t ret = zc_popup_dialog(newcomboa_dlg,-1);
    
    if(ret==1)
    {
        combo->width = ((atoi(cwidth)-1)<16)?zc_max(0,(atoi(cwidth)-1)):15;
        combo->height = ((atoi(cheight)-1)<11)?zc_max(0,(atoi(cheight)-1)):10;
        combo->layermask=0;
        combo->layermask |= (newcomboa_dlg[8].flags&D_SELECTED)?1:0;
        combo->layermask |= (newcomboa_dlg[9].flags&D_SELECTED)?2:0;
        combo->layermask |= (newcomboa_dlg[10].flags&D_SELECTED)?4:0;
        combo->layermask |= (newcomboa_dlg[11].flags&D_SELECTED)?8:0;
        combo->layermask |= (newcomboa_dlg[12].flags&D_SELECTED)?16:0;
        combo->layermask |= (newcomboa_dlg[13].flags&D_SELECTED)?32:0;
        
        int32_t new_count = (comboa_lmasktotal(combo->layermask)+1)*(combo->width+1)*(combo->height+1);
        
        if(combo->combos != NULL)
        {
            delete[] combo->combos;
        }
        
        if(combo->csets != NULL)
        {
            delete[] combo->csets;
        }
        
        combo->combos = new word[new_count];
        combo->csets = new byte[new_count];
        
        int32_t j=1;
        int32_t old_size=(old_width+1)*(old_height+1);
        int32_t new_start[7] =
        {
            0,
            ((combo->width+1)*(combo->height+1)*(1)),
            ((combo->width+1)*(combo->height+1)*(2)),
            ((combo->width+1)*(combo->height+1)*(3)),
            ((combo->width+1)*(combo->height+1)*(4)),
            ((combo->width+1)*(combo->height+1)*(5)),
            ((combo->width+1)*(combo->height+1)*(6))
        };
        int32_t new_layers[6] = {0,0,0,0,0,0};
        int32_t temp_layer = combo->layermask;
        int32_t temp_old = oldlayer;
        int32_t old_layers[6] = {0,0,0,0,0,0};
        int32_t k=1;
        
        for(int32_t i=0; (i<6)&&(temp_layer!=0); j++,temp_layer>>=1,temp_old>>=1)
        {
            if(temp_layer&1)
            {
                new_layers[i] = j;
                //if(oldlayer&(1<<(j-1))) old_layers[i] = k++;
                i++;
            }
            
            if(temp_old&1)
            {
                if(temp_layer&1)
                {
                    old_layers[i-1] = k;
                }
                
                k++;
            }
        }
        
        for(int32_t i=0; i<new_count; i++)
        {
            if(i>=new_start[6])
            {
                //oldl=oldlayer>>(new_layers[5]-1);
                j=i-new_start[6];
                
                if(((j/(combo->width+1))<=old_height)&&((j%(combo->width+1))<=old_width)&&(oldlayer&(1<<(new_layers[5]-1))))
                {
                    combo->combos[i] = temp_combos[((j%(combo->width+1))+((old_width+1)*(j/(combo->width+1))))+(old_size*old_layers[5])];
                    combo->csets[i] = temp_csets[((j%(combo->width+1))+((old_width+1)*(j/(combo->width+1))))+(old_size*old_layers[5])];
                }
                else
                {
                    combo->combos[i] = 0;
                    combo->csets[i] = 0;
                }
            }
            else if(i>=new_start[5])
            {
                //oldl=oldlayer>>(new_layers[4]-1);
                j=i-new_start[5];
                
                if(((j/(combo->width+1))<=old_height)&&((j%(combo->width+1))<=old_width)&&(oldlayer&(1<<(new_layers[4]-1))))
                {
                    combo->combos[i] = temp_combos[((j%(combo->width+1))+((old_width+1)*(j/(combo->width+1))))+(old_size*old_layers[4])];
                    combo->csets[i] = temp_csets[((j%(combo->width+1))+((old_width+1)*(j/(combo->width+1))))+(old_size*old_layers[4])];
                }
                else
                {
                    combo->combos[i] = 0;
                    combo->csets[i] = 0;
                }
            }
            else if(i>=new_start[4])
            {
                //oldl=oldlayer>>(new_layers[3]-1);
                j=i-new_start[4];
                
                if(((j/(combo->width+1))<=old_height)&&((j%(combo->width+1))<=old_width)&&(oldlayer&(1<<(new_layers[3]-1))))
                {
                    combo->combos[i] = temp_combos[((j%(combo->width+1))+((old_width+1)*(j/(combo->width+1))))+(old_size*old_layers[3])];
                    combo->csets[i] = temp_csets[((j%(combo->width+1))+((old_width+1)*(j/(combo->width+1))))+(old_size*old_layers[3])];
                }
                else
                {
                    combo->combos[i] = 0;
                    combo->csets[i] = 0;
                }
            }
            else if(i>=new_start[3])
            {
                //oldl=oldlayer>>(new_layers[2]-1);
                j=i-new_start[3];
                
                if(((j/(combo->width+1))<=old_height)&&((j%(combo->width+1))<=old_width)&&(oldlayer&(1<<(new_layers[2]-1))))
                {
                    combo->combos[i] = temp_combos[((j%(combo->width+1))+((old_width+1)*(j/(combo->width+1))))+(old_size*old_layers[2])];
                    combo->csets[i] = temp_csets[((j%(combo->width+1))+((old_width+1)*(j/(combo->width+1))))+(old_size*old_layers[2])];
                }
                else
                {
                    combo->combos[i] = 0;
                    combo->csets[i] = 0;
                }
            }
            else if(i>=new_start[2])
            {
                //oldl=oldlayer>>(new_layers[1]-1);
                j=i-new_start[2];
                
                if(((j/(combo->width+1))<=old_height)&&((j%(combo->width+1))<=old_width)&&(oldlayer&(1<<(new_layers[1]-1))))
                {
                    combo->combos[i] = temp_combos[((j%(combo->width+1))+((old_width+1)*(j/(combo->width+1))))+(old_size*old_layers[1])];
                    combo->csets[i] = temp_csets[((j%(combo->width+1))+((old_width+1)*(j/(combo->width+1))))+(old_size*old_layers[1])];
                }
                else
                {
                    combo->combos[i] = 0;
                    combo->csets[i] = 0;
                }
            }
            else if(i>=new_start[1])
            {
                //oldl=oldlayer>>(new_layers[0]-1);
                j=i-new_start[1];
                
                if(((j/(combo->width+1))<=old_height)&&((j%(combo->width+1))<=old_width)&&(oldlayer&(1<<(new_layers[0]-1))))
                {
                    combo->combos[i] = temp_combos[((j%(combo->width+1))+((old_width+1)*(j/(combo->width+1))))+(old_size*old_layers[0])];
                    combo->csets[i] = temp_csets[((j%(combo->width+1))+((old_width+1)*(j/(combo->width+1))))+(old_size*old_layers[0])];
                }
                else
                {
                    combo->combos[i] = 0;
                    combo->csets[i] = 0;
                }
            }
            else if(i>=new_start[0])
            {
                if(((i/(combo->width+1))<=old_height)&&((i%(combo->width+1))<=old_width))
                {
                    combo->combos[i] = temp_combos[(i%(combo->width+1))+((old_width+1)*(i/(combo->width+1)))];
                    combo->csets[i] = temp_csets[(i%(combo->width+1))+((old_width+1)*(i/(combo->width+1)))];
                }
                else
                {
                    combo->combos[i] = 0;
                    combo->csets[i] = 0;
                }
            }
        }
        
        set_comboaradio(combo->layermask);
        // copy aliases
        /*if (newcomboa_dlg[16].flags)
        {
          copyComboAlias(getcurrentcomboalias(),atoi((char*) newcomboa_dlg[15].dp));
          al_trace("src: %i, dest: %i\n", getcurrentcomboalias(),atoi((char*) newcomboa_dlg[15].dp));
        }*/
    }
    
    return ret;
}

int32_t d_orgcomboa_proc(int32_t msg, DIALOG *d, int32_t c)
{
    //these are here to bypass compiler warnings about unused arguments
    c=c;
    
    int32_t down=0;
    int32_t selected=(d->flags&D_SELECTED)?1:0;
    int32_t last_draw;
    
    switch(msg)
    {
    
    case MSG_DRAW:
    {
        FONT *tfont=font;
        font=is_large?lfont_l:nfont;
        jwin_draw_text_button(screen, d->x, d->y, d->w, d->h, (char*)d->dp, d->flags, true);
        font=tfont;
    }
    break;
    
    case MSG_WANTFOCUS:
        return D_WANTFOCUS;
        
    case MSG_KEY:
        /* close dialog? */
        onOrgComboAliases();
        return D_REDRAW;
        
        /* or just toggle */
        /*d->flags ^= D_SELECTED;
        scare_mouse();
        object_message(d, MSG_DRAW, 0);
        unscare_mouse();
        break;*/
        
    case MSG_CLICK:
        last_draw = 0;
        
        /* track the mouse until it is released */
        while(gui_mouse_b())
        {
            down = mouse_in_rect(d->x, d->y, d->w, d->h);
            
            /* redraw? */
            if(last_draw != down)
            {
                if(down != selected)
                    d->flags |= D_SELECTED;
                else
                    d->flags &= ~D_SELECTED;
                    
                scare_mouse();
                object_message(d, MSG_DRAW, 0);
                unscare_mouse();
                last_draw = down;
            }
            
            /* let other objects continue to animate */
            broadcast_dialog_message(MSG_IDLE, 0);
        }
        
        /* redraw in normal state */
        if(down)
        {
            if(d->flags&D_EXIT)
            {
                d->flags &= ~D_SELECTED;
                scare_mouse();
                object_message(d, MSG_DRAW, 0);
                unscare_mouse();
            }
        }
        
        /* should we close the dialog? */
        if(down)
        {
            onOrgComboAliases();
            return D_REDRAW;
        }
        
        break;
    }
    
    return D_O_K;
}

int32_t d_comboabutton_proc(int32_t msg, DIALOG *d, int32_t c)
{
    //these are here to bypass compiler warnings about unused arguments
    c=c;
    
    int32_t down=0;
    int32_t selected=(d->flags&D_SELECTED)?1:0;
    int32_t last_draw;
    
    switch(msg)
    {
    
    case MSG_DRAW:
    {
        FONT *tfont=font;
        font=is_large?lfont_l:nfont;
        jwin_draw_text_button(screen, d->x, d->y, d->w, d->h, (char*)d->dp, d->flags, true);
        font=tfont;
    }
    break;
    
    case MSG_WANTFOCUS:
        return D_WANTFOCUS;
        
    case MSG_KEY:
        /* close dialog? */
        onNewComboAlias();
        return D_REDRAW;
        
        /* or just toggle */
        /*d->flags ^= D_SELECTED;
        scare_mouse();
        object_message(d, MSG_DRAW, 0);
        unscare_mouse();
        break;*/
        
    case MSG_CLICK:
        last_draw = 0;
        
        /* track the mouse until it is released */
        while(gui_mouse_b())
        {
            down = mouse_in_rect(d->x, d->y, d->w, d->h);
            
            /* redraw? */
            if(last_draw != down)
            {
                if(down != selected)
                    d->flags |= D_SELECTED;
                else
                    d->flags &= ~D_SELECTED;
                    
                scare_mouse();
                object_message(d, MSG_DRAW, 0);
                unscare_mouse();
                last_draw = down;
            }
            
            /* let other objects continue to animate */
            broadcast_dialog_message(MSG_IDLE, 0);
        }
        
        /* redraw in normal state */
        if(down)
        {
            if(d->flags&D_EXIT)
            {
                d->flags &= ~D_SELECTED;
                scare_mouse();
                object_message(d, MSG_DRAW, 0);
                unscare_mouse();
            }
        }
        
        /* should we close the dialog? */
        if(down)
        {
            onNewComboAlias();
            return D_REDRAW;
        }
        
        break;
    }
    
    return D_O_K;
}

int32_t d_comboacheck_proc(int32_t msg, DIALOG *d, int32_t c)
{
    int32_t temp = d->flags&D_SELECTED;
    int32_t ret=jwin_checkfont_proc(msg,d,c);
    
    if(temp != (d->flags&D_SELECTED))
    {
        return D_REDRAW;
    }
    
    return ret;
}

static ListData comboa_list(comboalist, &font);

static DIALOG editcomboa_dlg[] =
{
    /* (dialog proc)     (x)   (y)    (w)   (h)   (fg)      (bg)     (key)    (flags)       (d1)           (d2)      (dp) */
    { jwin_win_proc,        0,    0,  320,  240,  vc(14),   vc(1),      0,       D_EXIT,     0,             0, (void *) "Combo Alias Edit", NULL, NULL },
    { jwin_button_proc,     148,  212,  61,   21,   vc(14),  vc(1),  'k',     D_EXIT,     0,             0, (void *) "O&K", NULL, NULL },
    { jwin_button_proc,     232,  212,  61,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { jwin_frame_proc,      4+121,   28+81,   1,   1,       0,       0,      0,       0,          FR_DEEP,       0,       NULL, NULL, NULL },
    { d_comboabutton_proc,   25,  212,  81,   21,   vc(14),  vc(1),  'p',     D_EXIT,     0,             0, (void *) "&Properties", NULL, NULL },
    { d_comboalist_proc,    266,   25,   50,  16,   jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,       0,     0,             0, (void *) &comboa_list, NULL, NULL },
    { d_comboa_radio_proc,  285,   44,  30,   8+1,    vc(14),  vc(1),  0,       D_SELECTED,          0,             0, (void *) "0", NULL, NULL },
    { d_comboa_radio_proc,  285,   54,  30,   8+1,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "1", NULL, NULL },
    { d_comboa_radio_proc,  285,   64,  30,   8+1,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "2", NULL, NULL },
    { d_comboa_radio_proc,  285,   74,  30,   8+1,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "3", NULL, NULL },
    { d_comboa_radio_proc,  285,   84,   30,   8+1,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "4", NULL, NULL },
    
    { d_comboa_radio_proc,  285,   94,   30,   8+1,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "5", NULL, NULL },
    { d_comboa_radio_proc,  285,   104,  30,   8+1,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "6", NULL, NULL },
    { d_comboacheck_proc,     285,   164,   17,   9,    vc(12),  vc(1),  0,       0,          1,             0,      NULL, NULL, NULL },
    { d_comboa_proc,         6,    27,  256,  176,  0,   0,      0,       0,     0,             0,       NULL, NULL, NULL },
    { jwin_ctext_proc,     290,   176,   27,   8,   0,        0,       0,      0,        0,              0, (void *) "Only Show", NULL, NULL },
    { jwin_ctext_proc,     290,   186,   27,   8,   0,        0,       0,      0,        0,              0, (void *) "Current", NULL, NULL },
    { jwin_ctext_proc,     290,   196,   27,   8,   0,        0,       0,      0,        0,              0, (void *) "Layer", NULL, NULL },
    { jwin_ctext_proc,     290,   122,   27,   8,   0,        0,       0,      0,        0,              0, (void *) "Thumbnail", NULL, NULL },
    { jwin_frame_proc,     280,   132,   20,   20,  0,        0,      0,       0,         FR_DEEP,       0,       NULL, NULL, NULL },
    { d_comboat_proc,      282,   134,   16,   16,  0,   0,      0,       0,     0,             0,       NULL, NULL, NULL },
    
    //21
    { d_orgcomboa_proc,   106,  212,  21,   21,   vc(14),  vc(1),  'p',     D_EXIT,     0,             0, (void *) "&Org", NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

int32_t getcurrentcomboalias()
{
    return editcomboa_dlg[5].d1;
}

int32_t d_comboa_radio_proc(int32_t msg,DIALOG *d,int32_t c)
{
    int32_t temp = layer_cnt;
    int32_t ret = jwin_radiofont_proc(msg,d,c);
    
    if(editcomboa_dlg[6].flags&D_SELECTED) layer_cnt=0;
    else if(editcomboa_dlg[7].flags&D_SELECTED) layer_cnt=1;
    else if(editcomboa_dlg[8].flags&D_SELECTED) layer_cnt=2;
    else if(editcomboa_dlg[9].flags&D_SELECTED) layer_cnt=3;
    else if(editcomboa_dlg[10].flags&D_SELECTED) layer_cnt=4;
    else if(editcomboa_dlg[11].flags&D_SELECTED) layer_cnt=5;
    else if(editcomboa_dlg[12].flags&D_SELECTED) layer_cnt=6;
    
    if(temp != layer_cnt)
    {
        return D_REDRAW;
    }
    
    return ret;
}

int32_t set_comboaradio(byte layermask)
{
    if(editcomboa_dlg[7].flags&D_SELECTED) editcomboa_dlg[7].flags &= ~D_SELECTED;
    
    if(editcomboa_dlg[8].flags&D_SELECTED) editcomboa_dlg[8].flags &= ~D_SELECTED;
    
    if(editcomboa_dlg[9].flags&D_SELECTED) editcomboa_dlg[9].flags &= ~D_SELECTED;
    
    if(editcomboa_dlg[10].flags&D_SELECTED) editcomboa_dlg[10].flags &= ~D_SELECTED;
    
    if(editcomboa_dlg[11].flags&D_SELECTED) editcomboa_dlg[11].flags &= ~D_SELECTED;
    
    if(editcomboa_dlg[12].flags&D_SELECTED) editcomboa_dlg[12].flags &= ~D_SELECTED;
    
    if(!(layermask&1)) editcomboa_dlg[7].flags |= D_DISABLED;
    else editcomboa_dlg[7].flags &= ~D_DISABLED;
    
    if(!(layermask&2)) editcomboa_dlg[8].flags |= D_DISABLED;
    else editcomboa_dlg[8].flags &= ~D_DISABLED;
    
    if(!(layermask&4)) editcomboa_dlg[9].flags |= D_DISABLED;
    else editcomboa_dlg[9].flags &= ~D_DISABLED;
    
    if(!(layermask&8)) editcomboa_dlg[10].flags |= D_DISABLED;
    else editcomboa_dlg[10].flags &= ~D_DISABLED;
    
    if(!(layermask&16)) editcomboa_dlg[11].flags |= D_DISABLED;
    else editcomboa_dlg[11].flags &= ~D_DISABLED;
    
    if(!(layermask&32)) editcomboa_dlg[12].flags |= D_DISABLED;
    else editcomboa_dlg[12].flags &= ~D_DISABLED;
    
    editcomboa_dlg[6].flags |= D_SELECTED;
    layer_cnt=0;
    return 1;
}

void call_cpool_dlg(int32_t index);
int32_t onEditComboPool()
{
	call_cpool_dlg(combo_pool_pos);
	return D_O_K;
}
int32_t onEditComboAlias()
{
    reset_combo_animations();
    reset_combo_animations2();
    
    for(int32_t i=0; i<MAXCOMBOALIASES; i++)
    {
        if(temp_aliases[i].combos != NULL)
        {
            delete[] temp_aliases[i].combos;
        }
        
        if(temp_aliases[i].csets != NULL)
        {
            delete[] temp_aliases[i].csets;
        }
        
        temp_aliases[i].width=combo_aliases[i].width;
        temp_aliases[i].height=combo_aliases[i].height;
        temp_aliases[i].layermask=combo_aliases[i].layermask;
        int32_t tcount = (comboa_lmasktotal(temp_aliases[i].layermask)+1)*(temp_aliases[i].width+1)*(temp_aliases[i].height+1);
        temp_aliases[i].combos = new word[tcount];
        temp_aliases[i].csets = new byte[tcount];
        
        for(int32_t j=0; j<tcount; j++)
        {
            temp_aliases[i].combos[j] = combo_aliases[i].combos[j];
            temp_aliases[i].csets[j] = combo_aliases[i].csets[j];
        }
        
        temp_aliases[i].combo=combo_aliases[i].combo;
        temp_aliases[i].cset=combo_aliases[i].cset;
        //memcpy(temp_aliases[i].combos,combo_aliases[i].combos,sizeof(word)*tcount);
        //memcpy(temp_aliases[i].csets,combo_aliases[i].csets,sizeof(byte)*tcount);
    }
    
    editcomboa_dlg[0].dp2 = lfont;
    set_comboaradio(temp_aliases[comboa_cnt].layermask);
    editcomboa_dlg[5].d1 = comboa_cnt;
    
    if(is_large)
    {
        bool small_d1 = editcomboa_dlg[0].d1==0;
        large_dialog(editcomboa_dlg,2);
        
        if(small_d1)
        {
            for(int32_t i=6; i<=12; i++)
            {
                editcomboa_dlg[i].w=30*1.5;
                editcomboa_dlg[i].h=9*1.5;
            }
            
            editcomboa_dlg[13].w=17*1.5;
            editcomboa_dlg[13].h=9*1.5;
            editcomboa_dlg[4].w=81*1.5;
            editcomboa_dlg[4].h=21*1.5;
            editcomboa_dlg[4].dp2=lfont_l;
            editcomboa_dlg[21].w=21*1.5;
            editcomboa_dlg[21].h=21*1.5;
            editcomboa_dlg[21].dp2=lfont_l;
        }
    }
    
    int32_t ret=zc_popup_dialog(editcomboa_dlg,-1);
    
    if(ret==1)
    {
        saved=false;
        
        for(int32_t i=0; i<MAXCOMBOALIASES; i++)
        {
            if(combo_aliases[i].combos != NULL)
            {
                delete[] combo_aliases[i].combos;
            }
            
            if(combo_aliases[i].csets != NULL)
            {
                delete[] combo_aliases[i].csets;
            }
            
            combo_aliases[i].width=temp_aliases[i].width;
            combo_aliases[i].height=temp_aliases[i].height;
            combo_aliases[i].layermask=temp_aliases[i].layermask;
            int32_t tcount = (comboa_lmasktotal(combo_aliases[i].layermask)+1)*(combo_aliases[i].width+1)*(combo_aliases[i].height+1);
            combo_aliases[i].combos = new word[tcount];
            combo_aliases[i].csets = new byte[tcount];
            
            for(int32_t j=0; j<tcount; j++)
            {
                combo_aliases[i].combos[j] = temp_aliases[i].combos[j];
                combo_aliases[i].csets[j] = temp_aliases[i].csets[j];
            }
            
            combo_aliases[i].combo=temp_aliases[i].combo;
            combo_aliases[i].cset=temp_aliases[i].cset;
            //memcpy(combo_aliases[i].combos,temp_aliases[i].combos,sizeof(word)*tcount);
            //memcpy(combo_aliases[i].csets,temp_aliases[i].csets,sizeof(byte)*tcount);
        }
    }
    
    setup_combo_animations();
    setup_combo_animations2();
    return D_O_K;
}

static char ffcombo_str_buf[MAXFFCS];
static char fflink_str_buf[MAXFFCS];

BITMAP* ffcur;

const char *ffcombolist(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        bound(index,0,MAXFFCS-1);
        sprintf(ffcombo_str_buf,"%d",index+1);
        return ffcombo_str_buf;
    }
    
    *list_size=MAXFFCS;
    return NULL;
}

static ListData ffcombo_list(ffcombolist, &font);

static DIALOG ffcombo_sel_dlg[] =
{
    { jwin_win_proc,        0,    0,  200,   179,  vc(14),   vc(1),      0,       D_EXIT,     0,             0, (void *) "Choose Freeform Combo", NULL, NULL },
    { jwin_button_proc,     35,   152,   61,   21,  vc(14),   vc(1),     13,       D_EXIT,     0,             0, (void *) "Edit", NULL, NULL },
    { jwin_button_proc,    104,   152,   61,   21,  vc(14),   vc(1),     27,       D_EXIT,     0,             0, (void *) "Done", NULL, NULL },
    { d_ffcombolist_proc,  11,   24,   49,   16,   jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,       0,          1,             0, (void *) &ffcombo_list, NULL, NULL },
    { d_comboframe_proc,   68,  23,   20,   20,   0,       0,      0,       0,             FR_DEEP,       0,       NULL, NULL, NULL },
    { d_bitmap_proc,     70,  25,   16,   16,   0,       0,      0,       0,             0,             0,       NULL, NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

int32_t d_ffcombolist_proc(int32_t msg,DIALOG *d,int32_t c)
{
    int32_t ret = jwin_droplist_proc(msg,d,c);
    int32_t d1 = d->d1;
    int32_t x=ffcombo_sel_dlg[0].x;
    int32_t y=ffcombo_sel_dlg[0].y;
    FONT *tempfont=(is_large?font:spfont);
    int32_t x2=text_length(tempfont, "Move Delay:")+4;
    
    switch(msg)
    {
    case MSG_DRAW:
        if(!ffcur) return D_O_K;
        
        BITMAP *buf = create_bitmap_ex(8,16,16);
        
        if(buf)
        {
            clear_bitmap(buf);
            putcombo(buf,0,0,Map.CurrScr()->ffcs[d1].getData(),Map.CurrScr()->ffcs[d1].cset);
            stretch_blit(buf, ffcur, 0,0, 16, 16, 0, 0, ffcur->w, ffcur->h);
            destroy_bitmap(buf);
        }
        
        object_message(&ffcombo_sel_dlg[5],MSG_DRAW,0);
        
        int32_t xd = x+int32_t(68*(is_large?1.5:1));
        int32_t y2 = y+int32_t(55*(is_large?1.5:1));
        int32_t yd = is_large ? 9 : 6;
        
        rectfill(screen,xd,y2,x+196*int32_t(is_large?1.5:1),y+127*int32_t(is_large?1.5:1),jwin_pal[jcBOX]);
        
        textprintf_ex(screen,tempfont,xd,y2,jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"Combo #:");
        textprintf_ex(screen,tempfont,xd+x2,y2,jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"%d",Map.CurrScr()->ffcs[d1].getData());
        
        textprintf_ex(screen,tempfont,xd,y2+yd,jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"CSet #:");
        textprintf_ex(screen,tempfont,xd+x2,y2+yd,jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"%d",Map.CurrScr()->ffcs[d1].cset);
        
        textprintf_ex(screen,tempfont,xd,y2+yd*2,jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"X Pos:");
        textprintf_ex(screen,tempfont,xd+x2,y2+yd*2,jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"%.4f",Map.CurrScr()->ffcs[d1].x.getFloat());
        
        textprintf_ex(screen,tempfont,xd,y2+yd*3,jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"Y Pos:");
        textprintf_ex(screen,tempfont,xd+x2,y2+yd*3,jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"%.4f",Map.CurrScr()->ffcs[d1].y.getFloat());
        
        textprintf_ex(screen,tempfont,xd,y2+yd*4,jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"X Speed:");
        textprintf_ex(screen,tempfont,xd+x2,y2+yd*4,jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"%.4f",Map.CurrScr()->ffcs[d1].vx.getFloat());
        
        textprintf_ex(screen,tempfont,xd,y2+yd*5,jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"Y Speed:");
        textprintf_ex(screen,tempfont,xd+x2,y2+yd*5,jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"%.4f",Map.CurrScr()->ffcs[d1].vy.getFloat());
        
        textprintf_ex(screen,tempfont,xd,y2+yd*6,jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"X Accel:");
        textprintf_ex(screen,tempfont,xd+x2,y2+yd*6,jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"%.4f",Map.CurrScr()->ffcs[d1].ax.getFloat());
        
        textprintf_ex(screen,tempfont,xd,y2+yd*7,jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"Y Accel:");
        textprintf_ex(screen,tempfont,xd+x2,y2+yd*7,jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"%.4f",Map.CurrScr()->ffcs[d1].ay.getFloat());
        
        textprintf_ex(screen,tempfont,xd,y2+yd*8,jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"Linked To:");
        textprintf_ex(screen,tempfont,xd+x2,y2+yd*8,jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"%d",Map.CurrScr()->ffcs[d1].link);
        
        textprintf_ex(screen,tempfont,xd,y2+yd*9,jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"Move Delay:");
        textprintf_ex(screen,tempfont,xd+x2,y2+yd*9,jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"%d",Map.CurrScr()->ffcs[d1].delay);
        
        textprintf_ex(screen,tempfont,xd,y2+yd*10,jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"Combo W:");
        textprintf_ex(screen,tempfont,xd+x2,y2+yd*10,jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"%d",(Map.CurrScr()->ffEffectWidth(d1)));
        
        textprintf_ex(screen,tempfont,xd,y2+yd*11,jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"Combo H:");
        textprintf_ex(screen,tempfont,xd+x2,y2+yd*11,jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"%d",(Map.CurrScr()->ffEffectHeight(d1)));
        
        textprintf_ex(screen,tempfont,xd,y2+yd*12,jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"Tile W:");
        textprintf_ex(screen,tempfont,xd+x2,y2+yd*12,jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"%d",(Map.CurrScr()->ffTileWidth(d1)));
        
        textprintf_ex(screen,tempfont,xd,y2+yd*13,jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"Tile H:");
        textprintf_ex(screen,tempfont,xd+x2,y2+yd*13,jwin_pal[jcTEXTFG],jwin_pal[jcBOX],"%d",(Map.CurrScr()->ffTileHeight(d1)));
        
        break;
    }
    
    return ret;
}
int32_t onSelectFFCombo()
{
    ffcombo_sel_dlg[0].dp2 = lfont;
    ffcombo_sel_dlg[3].d1 = ff_combo;
    ffcur = create_bitmap_ex(8,is_large?32:16,is_large?32:16);
    
    if(!ffcur) return D_O_K;
    
    putcombo(ffcur,0,0,Map.CurrScr()->ffcs[ff_combo].getData(),Map.CurrScr()->ffcs[ff_combo].cset);
    ffcombo_sel_dlg[5].dp = ffcur;
    
    if(is_large)
    {
        bool resize = !(ffcombo_sel_dlg[0].d1);
        large_dialog(ffcombo_sel_dlg);
        
        if(resize)
        {
            ffcombo_sel_dlg[5].x--;
            ffcombo_sel_dlg[5].y--;
        }
    }
    
    int32_t ret=zc_popup_dialog(ffcombo_sel_dlg,0);
    
    while(ret==1)
    {
        ff_combo = ffcombo_sel_dlg[3].d1;
        call_ffc_dialog(ff_combo);
        ret=zc_popup_dialog(ffcombo_sel_dlg,0);
    }
    
    destroy_bitmap(ffcur);
    return D_O_K;
}

const char *globalscriptlist(int32_t index, int32_t *list_size);
static ListData globalscript_list(globalscriptlist, &font);
const char *playerscriptlist(int32_t index, int32_t *list_size);
static ListData playerscript_list(playerscriptlist, &font);

const char *ffscriptlist(int32_t index, int32_t *list_size);

static ListData ffscript_list(ffscriptlist, &font);

char *strip_decimals(char *string)
{
    int32_t len=(int32_t)strlen(string);
    char *src=(char *)malloc(len+1);
    char *tmpsrc=src;
    memcpy(src,string,len+1);
    memset(src,0,len+1);
    
    for(size_t i=0; string[i]&&i<=strlen(string); i++)
    {
        *tmpsrc=string[i];
        
        if(*tmpsrc=='.')
        {
            while(string[i+1]=='.'&&i<=strlen(string))
            {
                i++;
            }
        }
        
        tmpsrc++;
    }
    
    memcpy(string,src,len);
    free(src);
    return string;
}

// Unused??? -L 6/6/11
char *clean_numeric_string(char *string)
{
    bool found_sign=false;
    bool found_decimal=false;
    int32_t len=(int32_t)strlen(string);
    char *src=(char *)malloc(len+1);
    char *tmpsrc=src;
    memcpy(src,string,len+1);
    memset(src,0,len+1);
    
    // strip out non-numerical characters
    for(size_t i=0; string[i]&&i<=strlen(string); i++)
    {
        *tmpsrc=string[i];
        
        if(*tmpsrc!='.'&&*tmpsrc!='-'&&*tmpsrc!='+'&&!isdigit(*tmpsrc))
        {
            while(*tmpsrc!='.'&&*tmpsrc!='-'&&*tmpsrc!='+'&&!isdigit(*tmpsrc))
            {
                i++;
            }
        }
        
        tmpsrc++;
    }
    
    len=(int32_t)strlen(src);
    char *src2=(char *)malloc(len+1);
    tmpsrc=src2;
    memcpy(src,src2,len+1);
    memset(src2,0,len+1);
    
    // second purge
    for(size_t i=0; src[i]&&i<=strlen(src); i++)
    {
        *tmpsrc=src[i];
        
        if(*tmpsrc=='-'||*tmpsrc=='+')
        {
            if(found_sign||found_decimal)
            {
                while(*tmpsrc=='-'||*tmpsrc=='+')
                {
                    i++;
                }
            }
            
            found_sign=true;
        }
        
        if(*tmpsrc=='.')
        {
            if(found_decimal)
            {
                while(*tmpsrc=='.')
                {
                    i++;
                }
            }
            
            found_decimal=true;
        }
        
        tmpsrc++;
    }
    
    sprintf(string, "%s", src2);
    free(src);
    free(src2);
    return string;
}

script_struct biglobal[NUMSCRIPTGLOBAL+1]; //global script
int32_t biglobal_cnt = -1;
script_struct biffs[NUMSCRIPTFFC]; //ff script
int32_t biffs_cnt = -1;
script_struct biitems[NUMSCRIPTITEM]; //item script
int32_t biitems_cnt = -1;
script_struct binpcs[NUMSCRIPTGUYS]; //npc script
int32_t binpcs_cnt = -1;

script_struct bilweapons[NUMSCRIPTWEAPONS]; //lweapon script
int32_t bilweapons_cnt = -1;

script_struct bieweapons[NUMSCRIPTWEAPONS]; //eweapon script
int32_t bieweapons_cnt = -1;

script_struct bihero[NUMSCRIPTPLAYER]; //link script
int32_t bihero_cnt = -1;

script_struct biscreens[NUMSCRIPTSCREEN]; //screen (screendata) script
int32_t biscreens_cnt = -1;

script_struct bidmaps[NUMSCRIPTSDMAP]; //dmap (dmapdata) script
int32_t bidmaps_cnt = -1;

script_struct biditemsprites[NUMSCRIPTSITEMSPRITE]; //dmap (dmapdata) script
int32_t biitemsprites_cnt = -1;

script_struct bidcomboscripts[NUMSCRIPTSCOMBODATA]; //dmap (dmapdata) script
int32_t bidcomboscripts_cnt = -1;
//static char ffscript_str_buf[32];

void build_biglobal_list()
{
    biglobal[0].first = "(None)";
    biglobal[0].second = -1;
    biglobal_cnt = 1;
    
    for(int32_t i = 0; i < NUMSCRIPTGLOBAL; ++i)
    {
        if(globalmap[i].scriptname.length()==0)
            continue;
            
        stringstream ss;
        ss << globalmap[i].scriptname << " (" << i << ")"; // The word 'slot' preceding all of the numbers is a bit cluttersome. -L.
        biglobal[biglobal_cnt].first = ss.str();
        biglobal[biglobal_cnt].second = i;
        ++biglobal_cnt;
    }
    
    // Blank out the rest of the list
    for(int32_t i=biglobal_cnt; i<NUMSCRIPTGLOBAL; ++i)
    {
        biglobal[i].first="";
        biglobal[i].second=-1;
    }
    
    //Bubble sort! (doesn't account for gaps between scripts)
    for(int32_t i = 0; i < biglobal_cnt - 1; i++)
    {
        for(int32_t j = i + 1; j < biglobal_cnt; j++)
        {
            if(stricmp(biglobal[i].first.c_str(),biglobal[j].first.c_str()) > 0 && strcmp(biglobal[j].first.c_str(),""))
                zc_swap(biglobal[i],biglobal[j]);
        }
    }
    
    biglobal_cnt = 0;
    
    for(int32_t i = 0; i < NUMSCRIPTGLOBAL+1; ++i)
        if(biglobal[i].first.length() > 0)
            biglobal_cnt = i+1;
}

void build_biffs_list()
{
    biffs[0].first = "(None)";
    biffs[0].second = -1;
    biffs_cnt = 1;
    
    for(int32_t i = 0; i < NUMSCRIPTFFC - 1; i++)
    {
        if(ffcmap[i].scriptname.length()==0)
            continue;
            
        stringstream ss;
        ss << ffcmap[i].scriptname << " (" << i+1 << ")"; // The word 'slot' preceding all of the numbers is a bit cluttersome. -L.
        biffs[biffs_cnt].first = ss.str();
        biffs[biffs_cnt].second = i;
        biffs_cnt++;
    }
    
    // Blank out the rest of the list
    for(int32_t i=biffs_cnt; i<NUMSCRIPTFFC; i++)
    {
        biffs[i].first="";
        biffs[i].second=-1;
    }
    
    //Bubble sort! (doesn't account for gaps between scripts)
    for(int32_t i = 0; i < biffs_cnt - 1; i++)
    {
        for(int32_t j = i + 1; j < biffs_cnt; j++)
        {
            if(stricmp(biffs[i].first.c_str(),biffs[j].first.c_str()) > 0 && strcmp(biffs[j].first.c_str(),""))
                zc_swap(biffs[i],biffs[j]);
        }
    }
    
    biffs_cnt = 0;
    
    for(int32_t i = 0; i < NUMSCRIPTFFC; i++)
        if(biffs[i].first.length() > 0)
            biffs_cnt = i+1;
}

//npc scripts
void build_binpcs_list()
{
    binpcs[0].first = "(None)";
    binpcs[0].second = -1;
    binpcs_cnt = 1;
    
    for(int32_t i = 0; i < NUMSCRIPTGUYS - 1; i++)
    {
        if(npcmap[i].scriptname.length()==0)
            continue;
            
        stringstream ss;
        ss << npcmap[i].scriptname << " (" << i+1 << ")"; // The word 'slot' preceding all of the numbers is a bit cluttersome. -L.
        binpcs[binpcs_cnt].first = ss.str();
        binpcs[binpcs_cnt].second = i;
        binpcs_cnt++;
    }
    
    // Blank out the rest of the list
    for(int32_t i=binpcs_cnt; i<NUMSCRIPTGUYS; i++)
    {
        binpcs[i].first="";
        binpcs[i].second=-1;
    }
    
    //Bubble sort! (doesn't account for gaps between scripts)
    for(int32_t i = 0; i < binpcs_cnt - 1; i++)
    {
        for(int32_t j = i + 1; j < binpcs_cnt; j++)
        {
            if(stricmp(binpcs[i].first.c_str(),binpcs[j].first.c_str()) > 0 && strcmp(binpcs[j].first.c_str(),""))
                zc_swap(binpcs[i],binpcs[j]);
        }
    }
    
    binpcs_cnt = 0;
    
    for(int32_t i = 0; i < NUMSCRIPTGUYS; i++)
        if(binpcs[i].first.length() > 0)
            binpcs_cnt = i+1;
}


//lweapon scripts
void build_bilweapons_list()
{
    bilweapons[0].first = "(None)";
    bilweapons[0].second = -1;
    bilweapons_cnt = 1;
    
    for(int32_t i = 0; i < NUMSCRIPTWEAPONS - 1; i++)
    {
        if(lwpnmap[i].scriptname.length()==0)
            continue;
            
        stringstream ss;
        ss << lwpnmap[i].scriptname << " (" << i+1 << ")"; // The word 'slot' preceding all of the numbers is a bit cluttersome. -L.
        bilweapons[bilweapons_cnt].first = ss.str();
        bilweapons[bilweapons_cnt].second = i;
        bilweapons_cnt++;
    }
    
    // Blank out the rest of the list
    for(int32_t i=bilweapons_cnt; i<NUMSCRIPTWEAPONS; i++)
    {
        bilweapons[i].first="";
        bilweapons[i].second=-1;
    }
    
    //Bubble sort! (doesn't account for gaps between scripts)
    for(int32_t i = 0; i < bilweapons_cnt - 1; i++)
    {
        for(int32_t j = i + 1; j < bilweapons_cnt; j++)
        {
            if(stricmp(bilweapons[i].first.c_str(),bilweapons[j].first.c_str()) > 0 && strcmp(bilweapons[j].first.c_str(),""))
                zc_swap(bilweapons[i],bilweapons[j]);
        }
    }
    
    bilweapons_cnt = 0;
    
    for(int32_t i = 0; i < NUMSCRIPTWEAPONS; i++)
        if(bilweapons[i].first.length() > 0)
            bilweapons_cnt = i+1;
}

//eweapon scripts
void build_bieweapons_list()
{
    bieweapons[0].first = "(None)";
    bieweapons[0].second = -1;
    bieweapons_cnt = 1;
    
    for(int32_t i = 0; i < NUMSCRIPTWEAPONS - 1; i++)
    {
        if(ewpnmap[i].scriptname.length()==0)
            continue;
            
        stringstream ss;
        ss << ewpnmap[i].scriptname << " (" << i+1 << ")"; // The word 'slot' preceding all of the numbers is a bit cluttersome. -L.
        bieweapons[bieweapons_cnt].first = ss.str();
        bieweapons[bieweapons_cnt].second = i;
        bieweapons_cnt++;
    }
    
    // Blank out the rest of the list
    for(int32_t i=bieweapons_cnt; i<NUMSCRIPTWEAPONS; i++)
    {
        bieweapons[i].first="";
        bieweapons[i].second=-1;
    }
    
    //Bubble sort! (doesn't account for gaps between scripts)
    for(int32_t i = 0; i < bieweapons_cnt - 1; i++)
    {
        for(int32_t j = i + 1; j < bieweapons_cnt; j++)
        {
            if(stricmp(bieweapons[i].first.c_str(),bieweapons[j].first.c_str()) > 0 && strcmp(bieweapons[j].first.c_str(),""))
                zc_swap(bieweapons[i],bieweapons[j]);
        }
    }
    
    bieweapons_cnt = 0;
    
    for(int32_t i = 0; i < NUMSCRIPTWEAPONS; i++)
        if(bieweapons[i].first.length() > 0)
            bieweapons_cnt = i+1;
}

//player scripts
void build_bihero_list()
{
    bihero[0].first = "(None)";
    bihero[0].second = -1;
    bihero_cnt = 1;
    
    for(int32_t i = 0; i < NUMSCRIPTPLAYER - 1; i++)
    {
        if(playermap[i].scriptname.length()==0)
            continue;
            
        stringstream ss;
        ss << playermap[i].scriptname << " (" << i+1 << ")"; // The word 'slot' preceding all of the numbers is a bit cluttersome. -L.
        bihero[bihero_cnt].first = ss.str();
        bihero[bihero_cnt].second = i;
        bihero_cnt++;
    }
    
    // Blank out the rest of the list
    for(int32_t i=bihero_cnt; i<NUMSCRIPTPLAYER; i++)
    {
        bihero[i].first="";
        bihero[i].second=-1;
    }
    
    //Bubble sort! (doesn't account for gaps between scripts)
    for(int32_t i = 0; i < bihero_cnt - 1; i++)
    {
        for(int32_t j = i + 1; j < bihero_cnt; j++)
        {
            if(stricmp(bihero[i].first.c_str(),bihero[j].first.c_str()) > 0 && strcmp(bihero[j].first.c_str(),""))
                zc_swap(bihero[i],bihero[j]);
        }
    }
    
    bihero_cnt = 0;
    
    for(int32_t i = 0; i < NUMSCRIPTPLAYER; i++)
        if(bihero[i].first.length() > 0)
            bihero_cnt = i+1;
}

//dmap scripts
void build_bidmaps_list()
{
    bidmaps[0].first = "(None)";
    bidmaps[0].second = -1;
    bidmaps_cnt = 1;
    
    for(int32_t i = 0; i < NUMSCRIPTSDMAP - 1; i++)
    {
        if(dmapmap[i].scriptname.length()==0)
            continue;
            
        stringstream ss;
        ss << dmapmap[i].scriptname << " (" << i+1 << ")"; // The word 'slot' preceding all of the numbers is a bit cluttersome. -L.
        bidmaps[bidmaps_cnt].first = ss.str();
        bidmaps[bidmaps_cnt].second = i;
        bidmaps_cnt++;
    }
    
    // Blank out the rest of the list
    for(int32_t i=bidmaps_cnt; i<NUMSCRIPTSDMAP; i++)
    {
        bidmaps[i].first="";
        bidmaps[i].second=-1;
    }
    
    //Bubble sort! (doesn't account for gaps between scripts)
    for(int32_t i = 0; i < bidmaps_cnt - 1; i++)
    {
        for(int32_t j = i + 1; j < bidmaps_cnt; j++)
        {
            if(stricmp(bidmaps[i].first.c_str(),bidmaps[j].first.c_str()) > 0 && strcmp(bidmaps[j].first.c_str(),""))
                zc_swap(bidmaps[i],bidmaps[j]);
        }
    }
    
    bidmaps_cnt = 0;
    
    for(int32_t i = 0; i < NUMSCRIPTSDMAP; i++)
        if(bidmaps[i].first.length() > 0)
            bidmaps_cnt = i+1;
}

//screen scripts
void build_biscreens_list()
{
    biscreens[0].first = "(None)";
    biscreens[0].second = -1;
    biscreens_cnt = 1;
    
    for(int32_t i = 0; i < NUMSCRIPTSCREEN - 1; i++)
    {
        if(screenmap[i].scriptname.length()==0)
            continue;
            
        stringstream ss;
        ss << screenmap[i].scriptname << " (" << i+1 << ")"; // The word 'slot' preceding all of the numbers is a bit cluttersome. -L.
        biscreens[biscreens_cnt].first = ss.str();
        biscreens[biscreens_cnt].second = i;
        biscreens_cnt++;
    }
    
    // Blank out the rest of the list
    for(int32_t i=biscreens_cnt; i<NUMSCRIPTSCREEN; i++)
    {
        biscreens[i].first="";
        biscreens[i].second=-1;
    }
    
    //Bubble sort! (doesn't account for gaps between scripts)
    for(int32_t i = 0; i < biscreens_cnt - 1; i++)
    {
        for(int32_t j = i + 1; j < biscreens_cnt; j++)
        {
            if(stricmp(biscreens[i].first.c_str(),biscreens[j].first.c_str()) > 0 && strcmp(biscreens[j].first.c_str(),""))
                zc_swap(biscreens[i],biscreens[j]);
        }
    }
    
    biscreens_cnt = 0;
    
    for(int32_t i = 0; i < NUMSCRIPTSCREEN; i++)
        if(biscreens[i].first.length() > 0)
            biscreens_cnt = i+1;
}

//screen scripts
void build_biitemsprites_list()
{
    biditemsprites[0].first = "(None)";
    biditemsprites[0].second = -1;
    biitemsprites_cnt = 1;
    
    for(int32_t i = 0; i < NUMSCRIPTSITEMSPRITE - 1; i++)
    {
        if(itemspritemap[i].scriptname.length()==0)
            continue;
            
        stringstream ss;
        ss << itemspritemap[i].scriptname << " (" << i+1 << ")"; // The word 'slot' preceding all of the numbers is a bit cluttersome. -L.
        biditemsprites[biitemsprites_cnt].first = ss.str();
        biditemsprites[biitemsprites_cnt].second = i;
        biitemsprites_cnt++;
    }
    
    // Blank out the rest of the list
    for(int32_t i=biitemsprites_cnt; i<NUMSCRIPTSITEMSPRITE; i++)
    {
        biditemsprites[i].first="";
        biditemsprites[i].second=-1;
    }
    
    //Bubble sort! (doesn't account for gaps between scripts)
    for(int32_t i = 0; i < biitemsprites_cnt - 1; i++)
    {
        for(int32_t j = i + 1; j < biitemsprites_cnt; j++)
        {
            if(stricmp(biditemsprites[i].first.c_str(),biditemsprites[j].first.c_str()) > 0 && strcmp(biditemsprites[j].first.c_str(),""))
                zc_swap(biditemsprites[i],biditemsprites[j]);
        }
    }
    
    biitemsprites_cnt = 0;
    
    for(int32_t i = 0; i < NUMSCRIPTSITEMSPRITE; i++)
        if(biditemsprites[i].first.length() > 0)
            biitemsprites_cnt = i+1;
}

void build_biitems_list()
{
    biitems[0].first = "(None)";
    biitems[0].second = -1;
    biitems_cnt = 1;
    
    for(int32_t i = 0; i < NUMSCRIPTITEM - 1; i++, biitems_cnt++)
    {
        stringstream ss;
        
        if(!itemmap[i].isEmpty())
            ss << itemmap[i].scriptname << " (" << i+1 << ")";
            
        biitems[biitems_cnt].first = ss.str();
        biitems[biitems_cnt].second = i;
    }
    
    for(int32_t i = 0; i < biitems_cnt - 1; i++)
    {
        for(int32_t j = i + 1; j < biitems_cnt; j++)
        {
            if(stricmp(biitems[i].first.c_str(), biitems[j].first.c_str()) > 0 && strcmp(biitems[j].first.c_str(),""))
                zc_swap(biitems[i], biitems[j]);
        }
    }
    
    biitems_cnt = 0;
    
    for(int32_t i = 0; i < NUMSCRIPTITEM; i++)
        if(biitems[i].first.length() > 0)
            biitems_cnt = i+1;
}


//dmap scripts
void build_bidcomboscripts_list()
{
    bidcomboscripts[0].first = "(None)";
    bidcomboscripts[0].second = -1;
    bidcomboscripts_cnt = 1;
    
    for(int32_t i = 0; i < NUMSCRIPTSCOMBODATA - 1; i++)
    {
        if(comboscriptmap[i].scriptname.length()==0)
            continue;
            
        stringstream ss;
        ss << comboscriptmap[i].scriptname << " (" << i+1 << ")"; // The word 'slot' preceding all of the numbers is a bit cluttersome. -L.
        bidcomboscripts[bidcomboscripts_cnt].first = ss.str();
        bidcomboscripts[bidcomboscripts_cnt].second = i;
        bidcomboscripts_cnt++;
    }
    
    // Blank out the rest of the list
    for(int32_t i=bidcomboscripts_cnt; i<NUMSCRIPTSCOMBODATA; i++)
    {
        bidcomboscripts[i].first="";
        bidcomboscripts[i].second=-1;
    }
    
    //Bubble sort! (doesn't account for gaps between scripts)
    for(int32_t i = 0; i < bidcomboscripts_cnt - 1; i++)
    {
        for(int32_t j = i + 1; j < bidcomboscripts_cnt; j++)
        {
            if(stricmp(bidcomboscripts[i].first.c_str(),bidcomboscripts[j].first.c_str()) > 0 && strcmp(bidcomboscripts[j].first.c_str(),""))
                zc_swap(bidcomboscripts[i],bidcomboscripts[j]);
        }
    }
    
    bidcomboscripts_cnt = 0;
    
    for(int32_t i = 0; i < NUMSCRIPTSCOMBODATA; i++)
        if(bidcomboscripts[i].first.length() > 0)
            bidcomboscripts_cnt = i+1;
}


const char *globalscriptlist(int32_t index, int32_t *list_size)
{
    if(index < 0)
    {
        *list_size = biglobal_cnt;
        return NULL;
    }
    
    return biglobal[index].first.c_str();
}

const char *ffscriptlist(int32_t index, int32_t *list_size)
{
    if(index < 0)
    {
        *list_size = biffs_cnt;
        return NULL;
    }
    
    return biffs[index].first.c_str();
}

const char *playerscriptlist(int32_t index, int32_t *list_size)
{
    if(index < 0)
    {
        *list_size = bihero_cnt;
        return NULL;
    }
    
    return bihero[index].first.c_str();
}

const char *lweaponscriptlist(int32_t index, int32_t *list_size)
{
    if(index < 0)
    {
        *list_size = bilweapons_cnt;
        return NULL;
    }
    
    return bilweapons[index].first.c_str();
}

const char *npcscriptlist(int32_t index, int32_t *list_size)
{
    if(index < 0)
    {
        *list_size = binpcs_cnt;
        return NULL;
    }
    
    return binpcs[index].first.c_str();
}

static char itemscript_str_buf[32];

char *itemscriptlist(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        bound(index,0,255);
        sprintf(itemscript_str_buf,"%d: %s",index, ffcmap[index-1].scriptname.c_str());
        return itemscript_str_buf;
    }
    
    *list_size=256;
    return NULL;
}

static char ffscript_str_buf2[32];

const char *ffscriptlist2(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        char buf[20];
        bound(index,0,510);
        
        if(ffcmap[index].scriptname=="")
            strcpy(buf, "<none>");
        else
        {
            strncpy(buf, ffcmap[index].scriptname.c_str(), 19);
            buf[19]='\0';
        }
        
        sprintf(ffscript_str_buf2,"%d: %s",index+1, buf);
        return ffscript_str_buf2;
    }
    
    *list_size=511;
    return NULL;
}

static char itemscript_str_buf2[32];

const char *itemscriptlist2(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        char buf[20];
        bound(index,0,254);
        
        if(itemmap[index].scriptname=="")
            strcpy(buf, "<none>");
        else
        {
            strncpy(buf, itemmap[index].scriptname.c_str(), 19);
            buf[19]='\0';
        }
        
        sprintf(itemscript_str_buf2,"%d: %s",index+1, buf);
        return itemscript_str_buf2;
    }
    
    *list_size=255;
    return NULL;
}


static char comboscript_str_buf2[32];
const char *comboscriptlist2(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        char buf[20];
        bound(index,0,254);
        
        if(comboscriptmap[index].scriptname=="")
            strcpy(buf, "<none>");
        else
        {
            strncpy(buf, comboscriptmap[index].scriptname.c_str(), 19);
            buf[19]='\0';
        }
        
        sprintf(comboscript_str_buf2,"%d: %s",index+1, buf);
        return comboscript_str_buf2;
    }
    
    *list_size=255;
    return NULL;
}

static char gscript_str_buf2[40];

const char *gscriptlist2(int32_t index, int32_t *list_size)
{
    if(index >= 0)
    {
        bound(index,0,3);
        
        char buf[20];
        
        if(globalmap[index].scriptname == "")
            strcpy(buf, "<none>");
        else
        {
            strncpy(buf, globalmap[index].scriptname.c_str(), 19);
            buf[19]='\0';
        }
        
        switch(index)
        {
            case GLOBAL_SCRIPT_INIT:
                sprintf(gscript_str_buf2,"Initialization: %s", buf); break;
            case GLOBAL_SCRIPT_GAME:
                sprintf(gscript_str_buf2,"Active: %s", buf); break;
            case GLOBAL_SCRIPT_END:
                sprintf(gscript_str_buf2,"onExit: %s", buf); break;
            case GLOBAL_SCRIPT_ONSAVELOAD:
                sprintf(gscript_str_buf2,"onSaveLoad: %s", buf); break;
            case GLOBAL_SCRIPT_ONLAUNCH:
                sprintf(gscript_str_buf2,"onLaunch: %s", buf); break;
            case GLOBAL_SCRIPT_ONCONTGAME:
                sprintf(gscript_str_buf2,"onContGame: %s", buf); break;
            case GLOBAL_SCRIPT_F6:
                sprintf(gscript_str_buf2,"onF6Menu: %s", buf); break;
            case GLOBAL_SCRIPT_ONSAVE:
                sprintf(gscript_str_buf2,"onSave: %s", buf); break;
        }
            
        return gscript_str_buf2;
    }
    
    if(list_size != NULL)
        *list_size=4;
        
    return NULL;
}

static int32_t as_ffc_list[] = { 4, 5, 6, -1};
static int32_t as_global_list[] = { 7, 8, 9, -1}; //Why does putting 15 in here not place my message only on the global tab? ~Joe
static int32_t as_item_list[] = { 10, 11, 12, -1};
static int32_t as_npc_list[] = { 18, 19, 20, -1}; //npc scripts TAB
static int32_t as_lweapon_list[] = { 21, 22, 23, -1}; //lweapon scripts TAB
static int32_t as_eweapon_list[] = { 24, 25, 26, -1}; //eweapon scripts TAB
static int32_t as_hero_list[] = { 27, 28, 29, -1}; //player scripts TAB
static int32_t as_screen_list[] = { 30, 31, 32, -1}; //screendata scripts TAB
static int32_t as_dmap_list[] = { 33, 34, 35, -1}; //dmapdata scripts TAB
static int32_t as_itemsprite_list[] = { 36, 37, 38, -1}; //dmapdata scripts TAB
static int32_t as_comboscript_list[] = { 39, 40, 41, -1}; //combodata scripts TAB
static int32_t as_genericscript_list[] = { 45, 46, 47, -1}; //generic scripts TAB

static TABPANEL assignscript_tabs[] =
{
    // (text)
    { (char *)"FFC",     D_SELECTED,  as_ffc_list,    0, NULL },
    { (char *)"Global",	 0,         as_global_list, 0, NULL },
    { (char *)"Item",		 0,         as_item_list,   0, NULL },
    { (char *)"NPC",		 0,         as_npc_list,   0, NULL },
    { (char *)"LWeapon",		 0,         as_lweapon_list,   0, NULL },
    { (char *)"EWeapon",		 0,         as_eweapon_list,   0, NULL },
    { (char *)"Hero",		 0,         as_hero_list,   0, NULL },
    { (char *)"DMap",		 0,         as_dmap_list,   0, NULL },
    { (char *)"Screen",		 0,         as_screen_list,   0, NULL },
    { (char *)"Item Sprite",		 0,         as_itemsprite_list,   0, NULL },
    { (char *)"Combo",		 0,         as_comboscript_list,   0, NULL },
    { (char *)"Generic",		 0,         as_genericscript_list,   0, NULL },
    { NULL,                0,           NULL,         0, NULL }
};

const char *assignffclist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = (int32_t)ffcmap.size();
        return NULL;
    }
    
    return ffcmap[index].output.c_str();
}

const char *assigngloballist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = (int32_t)globalmap.size();
        return NULL;
    }
    
    return globalmap[index].output.c_str();
}

const char *assigncombolist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = (int32_t)comboscriptmap.size();
        return NULL;
    }
    
    return comboscriptmap[index].output.c_str();
}

const char *assigngenericlist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = ((int32_t)genericmap.size());
        return NULL;
    }
    
    return genericmap[index].output.c_str();
}

const char *assignitemlist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = (int32_t)itemmap.size();
        return NULL;
    }
    
    return itemmap[index].output.c_str();
}
const char *assignnpclist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = (int32_t)npcmap.size();
        return NULL;
    }
    
    return npcmap[index].output.c_str();
}

const char *assignlweaponlist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = (int32_t)lwpnmap.size();
        return NULL;
    }
    
    return lwpnmap[index].output.c_str();
}

const char *assigneweaponlist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = (int32_t)ewpnmap.size();
        return NULL;
    }
    
    return ewpnmap[index].output.c_str();
}

const char *assignplayerlist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = (int32_t)playermap.size();
        return NULL;
    }
    
    return playermap[index].output.c_str();
}

const char *assigndmaplist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = (int32_t)dmapmap.size();
        return NULL;
    }
    
    return dmapmap[index].output.c_str();
}

const char *assignscreenlist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = (int32_t)screenmap.size();
        return NULL;
    }
    
    return screenmap[index].output.c_str();
}

const char *assignitemspritelist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = (int32_t)itemspritemap.size();
        return NULL;
    }
    
    return itemspritemap[index].output.c_str();
}

const char *assignffcscriptlist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = (int32_t)asffcscripts.size();
        return NULL;
    }
    
    return asffcscripts[index].c_str();
}

const char *assignglobalscriptlist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = (int32_t)asglobalscripts.size();
        return NULL;
    }
    
    return asglobalscripts[index].c_str();
}

const char *assignitemscriptlist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = (int32_t)asitemscripts.size();
        return NULL;
    }
    
    return asitemscripts[index].c_str();
}

const char *assignnpcscriptlist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = (int32_t)asnpcscripts.size();
        return NULL;
    }
    
    return asnpcscripts[index].c_str();
}

const char *assignlweaponscriptlist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = (int32_t)aslweaponscripts.size();
        return NULL;
    }
    
    return aslweaponscripts[index].c_str();
}

const char *assigneweaponscriptlist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = (int32_t)aseweaponscripts.size();
        return NULL;
    }
    
    return aseweaponscripts[index].c_str();
}

const char *assignplayerscriptlist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = (int32_t)asplayerscripts.size();
        return NULL;
    }
    
    return asplayerscripts[index].c_str();
}

const char *assigndmapscriptlist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = (int32_t)asdmapscripts.size();
        return NULL;
    }
    
    return asdmapscripts[index].c_str();
}

const char *assignscreenscriptlist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = (int32_t)asscreenscripts.size();
        return NULL;
    }
    
    return asscreenscripts[index].c_str();
}

const char *assignitemspritescriptlist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = (int32_t)asitemspritescripts.size();
        return NULL;
    }
    
    return asitemspritescripts[index].c_str();
}

const char *assigncomboscriptlist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = (int32_t)ascomboscripts.size();
        return NULL;
    }
    
    return ascomboscripts[index].c_str();
}

const char *assigngenericscriptlist(int32_t index, int32_t *list_size)
{
    if(index<0)
    {
        *list_size = (int32_t)asgenericscripts.size();
        return NULL;
    }
    
    return asgenericscripts[index].c_str();
}

static ListData assignffc_list(assignffclist, &font);
static ListData assignffcscript_list(assignffcscriptlist, &font);
static ListData assignglobal_list(assigngloballist, &font);
static ListData assignglobalscript_list(assignglobalscriptlist, &font);
static ListData assignitem_list(assignitemlist, &font);
static ListData assignitemscript_list(assignitemscriptlist, &font);
static ListData assignnpc_list(assignnpclist, &font);
static ListData assignnpcscript_list(assignnpcscriptlist, &font);
static ListData assignlweapon_list(assignlweaponlist, &font);
static ListData assignlweaponscript_list(assignlweaponscriptlist, &font);
static ListData assigneweapon_list(assigneweaponlist, &font);
static ListData assigneweaponscript_list(assigneweaponscriptlist, &font);

static ListData assignplayer_list(assignplayerlist, &font);
static ListData assignplayerscript_list(assignplayerscriptlist, &font);

static ListData assigndmap_list(assigndmaplist, &font);
static ListData assigndmapscript_list(assigndmapscriptlist, &font);

static ListData assignscreen_list(assignscreenlist, &font);
static ListData assignscreenscript_list(assignscreenscriptlist, &font);

static ListData assignitemsprite_list(assignitemspritelist, &font);
static ListData assignitemspritescript_list(assignitemspritescriptlist, &font);

static ListData assigncombo_list(assigncombolist, &font);
static ListData assigncomboscript_list(assigncomboscriptlist, &font);

static ListData assigngeneric_list(assigngenericlist, &font);
static ListData assigngenericscript_list(assigngenericscriptlist, &font);

static DIALOG assignscript_dlg[] =
{
    //						x		y		w		h		fg		bg		key	flags	d1	d2	dp
    { jwin_win_proc,		  0,	0,		330,	236,	vc(14),	vc(1),	0,	D_EXIT,	0,	0,	(void *) "Assign Compiled Script", NULL, NULL },
    { jwin_tab_proc,		  6,	25,		330-12,	130,	0,		0,		0,	0,		0,  0,  assignscript_tabs, NULL, (void*)assignscript_dlg },
    { jwin_button_proc,	  251,	207,	61,		21,		vc(14),	vc(1),	27,	D_EXIT,	0,	0,	(void *) "Cancel", NULL, NULL },
    { jwin_button_proc,	  182,	207,	61,		21,		vc(14), vc(1),	'k',	    D_EXIT,	0,	0,	(void *) "O&K", NULL, NULL },
    { jwin_abclist_proc,    10,	45,		136,	105,	jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,0,0, 0, (void *)&assignffc_list, NULL, NULL },
    { jwin_abclist_proc,    174+10,	45,		136,	105,	jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,0,0, 0, (void *)&assignffcscript_list, NULL, NULL },
    //6
    { jwin_button_proc,	  154+5,	93,		15,		10,		vc(14),	vc(1),	0,	D_EXIT,	0,	0,	(void *) "<<", NULL, NULL },
    { jwin_abclist_proc,    10,	45,		136,	105,	jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,0,0, 0, (void *)&assignglobal_list, NULL, NULL },
    { jwin_abclist_proc,    174+10,	45,		136,	105,	jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,0,0, 0, (void *)&assignglobalscript_list, NULL, NULL },
    //9
    { jwin_button_proc,	  154+5,	93,	15,		10,		vc(14),	vc(1),	0,	D_EXIT,	0,	0,	(void *) "<<", NULL, NULL },
    { jwin_abclist_proc,    10,	45,		136,	105,	jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,0,0, 0, (void *)&assignitem_list, NULL, NULL },
    { jwin_abclist_proc,    174+10,	45,		136,	105,	jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,0,0, 0, (void *)&assignitemscript_list, NULL, NULL },
    //12
    { jwin_button_proc,	  154+5,	93,		15,		10,		vc(14),	vc(1),	0,	D_EXIT,	0,	0,	(void *) "<<", NULL, NULL },
    //13
    { jwin_check_proc,      22,  211,   90,   8,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Output ZASM code to allegro.log", NULL, NULL },
    { jwin_text_proc,       22,  178,   90,   24,    vc(14),  vc(1),  0,       0,          0,             0, NULL, NULL, NULL },
    { d_dummy_proc,       0,  0,  0,   0,    vc(14),  vc(1),  0,       0,          0,             0, NULL, NULL, NULL },
    //16
    { d_dummy_proc,       0,  0,  0,   0,    vc(14),  vc(1),  0,       0,          0,             0, NULL, NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    //npc scripts
    { jwin_abclist_proc,    10,	45,		136,	105,	jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,0,0, 0, (void *)&assignnpc_list, NULL, NULL },
    { jwin_abclist_proc,    174+10,	45,		136,	105,	jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,0,0, 0, (void *)&assignnpcscript_list, NULL, NULL },
    //20
    { jwin_button_proc,	  154+5,	93,		15,		10,		vc(14),	vc(1),	0,	D_EXIT,	0,	0,	(void *) "<<", NULL, NULL },
    //21
    { jwin_abclist_proc,    10,	45,		136,	105,	jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,0,0, 0, (void *)&assignlweapon_list, NULL, NULL },
    { jwin_abclist_proc,    174+10,	45,		136,	105,	jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,0,0, 0, (void *)&assignlweaponscript_list, NULL, NULL },
    //23
    { jwin_button_proc,	  154+5,	93,		15,		10,		vc(14),	vc(1),	0,	D_EXIT,	0,	0,	(void *) "<<", NULL, NULL },
    //24
    { jwin_abclist_proc,    10,	45,		136,	105,	jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,0,0, 0, (void *)&assigneweapon_list, NULL, NULL },
    { jwin_abclist_proc,    174+10,	45,		136,	105,	jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,0,0, 0, (void *)&assigneweaponscript_list, NULL, NULL },
    //26
    { jwin_button_proc,	  154+5,	93,		15,		10,		vc(14),	vc(1),	0,	D_EXIT,	0,	0,	(void *) "<<", NULL, NULL },
    //27
    { jwin_abclist_proc,    10,	45,		136,	105,	jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,0,0, 0, (void *)&assignplayer_list, NULL, NULL },
    { jwin_abclist_proc,    174+10,	45,		136,	105,	jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,0,0, 0, (void *)&assignplayerscript_list, NULL, NULL },
    //29
    { jwin_button_proc,	  154+5,	93,		15,		10,		vc(14),	vc(1),	0,	D_EXIT,	0,	0,	(void *) "<<", NULL, NULL },
    //30
    { jwin_abclist_proc,    10,	45,		136,	105,	jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,0,0, 0, (void *)&assignscreen_list, NULL, NULL },
    { jwin_abclist_proc,    174+10,	45,		136,	105,	jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,0,0, 0, (void *)&assignscreenscript_list, NULL, NULL },
    //32
    { jwin_button_proc,	  154+5,	93,		15,		10,		vc(14),	vc(1),	0,	D_EXIT,	0,	0,	(void *) "<<", NULL, NULL },
    //33
    { jwin_abclist_proc,    10,	45,		136,	105,	jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,0,0, 0, (void *)&assigndmap_list, NULL, NULL },
    { jwin_abclist_proc,    174+10,	45,		136,	105,	jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,0,0, 0, (void *)&assigndmapscript_list, NULL, NULL },
    //35
    { jwin_button_proc,	  154+5,	93,		15,		10,		vc(14),	vc(1),	0,	D_EXIT,	0,	0,	(void *) "<<", NULL, NULL },
    //36
    { jwin_abclist_proc,    10,	45,		136,	105,	jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,0,0, 0, (void *)&assignitemsprite_list, NULL, NULL },
    { jwin_abclist_proc,    174+10,	45,		136,	105,	jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,0,0, 0, (void *)&assignitemspritescript_list, NULL, NULL },
    //38
    { jwin_button_proc,	  154+5,	93,		15,		10,		vc(14),	vc(1),	0,	D_EXIT,	0,	0,	(void *) "<<", NULL, NULL },
    
    //39
    { jwin_abclist_proc,    10,	45,		136,	105,	jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,0,0, 0, (void *)&assigncombo_list, NULL, NULL },
    { jwin_abclist_proc,    174+10,	45,		136,	105,	jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,0,0, 0, (void *)&assigncomboscript_list, NULL, NULL },
    //41
    { jwin_button_proc,	     154+5,   93,     15,     10,     vc(14), vc(1),  0, D_EXIT, 0,  0,  (void *) "<<", NULL, NULL },
    { jwin_button_proc,      78-24,  158,     48,     16,     vc(14), vc(1),  0, D_EXIT, 0,  0,  (void *) "Script Info",  NULL, NULL },
    { jwin_button_proc,  174+78-24,  158,     48,     16,     vc(14), vc(1),  0, D_EXIT, 0,  0,  (void *) "Script Info",  NULL, NULL },
    { jwin_button_proc,   87+78-24,  158,     48,     16,     vc(14), vc(1),  0, D_EXIT, 0,  0,  (void *) "Clear",  NULL, NULL },
    //45
	{ jwin_abclist_proc,    10,	45,		136,	105,	jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,0,0, 0, (void *)&assigngeneric_list, NULL, NULL },
    { jwin_abclist_proc,    174+10,	45,		136,	105,	jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,0,0, 0, (void *)&assigngenericscript_list, NULL, NULL },
    //47
    { jwin_button_proc,	  154+5,	93,		15,		10,		vc(14),	vc(1),	0,	D_EXIT,	0,	0,	(void *) "<<", NULL, NULL },
    
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,        NULL, NULL, NULL }
    
};

int32_t txtout(BITMAP* dest, char* txt, int32_t x, int32_t y, bool disabled)
{
	if(disabled)
	{
		gui_textout_ln(dest, font, (uint8_t*)txt, x+1, y+1, palette_color[scheme[jcLIGHT]], palette_color[scheme[jcBOX]], 0);
		return gui_textout_ln(dest, font, (uint8_t*)txt, x, y, palette_color[scheme[jcMEDDARK]], -1, 0);
	}
	else
	{
		return gui_textout_ln(dest, font, (uint8_t*)txt, x, y, palette_color[scheme[jcBOXFG]], palette_color[scheme[jcBOX]], 0);
	}
}

int32_t jwin_zmeta_proc(int32_t msg, DIALOG *d, int32_t )
{
	int32_t ret = D_O_K;
    ASSERT(d);
    
	BITMAP* target = (msg==MSG_START ? NULL : screen);
    switch(msg)
    {
		case MSG_START:
		case MSG_DRAW:
		{
			FONT *oldfont = font;
			
			if(d->dp2)
			{
				font = (FONT*)d->dp2;
			}
			
			bool disabled = (d->flags & D_DISABLED) != 0;
			if(d->dp)
			{
				zasm_meta const& meta = *((zasm_meta*)d->dp);
				int32_t ind = -1;
				d->w = 0;
				if(!meta.valid())
				{
					d->w = txtout(target, "Invalid ZASM metadata found!", d->x, d->y, disabled);
					++ind;
				}
				
				int32_t t_w = 0;
				char buf[1024];
				memset(buf, 0, sizeof(buf));
				sprintf(buf, "ZASM Version: %d", meta.zasm_v);
				t_w = txtout(target, buf, d->x, d->y + ((++ind)*(text_height(font) + 3)), disabled);
				d->w = zc_max(d->w, t_w);
				memset(buf, 0, sizeof(buf));
				sprintf(buf, "Metadata Version: %d", meta.meta_v);
				t_w = txtout(target, buf, d->x, d->y + ((++ind)*(text_height(font) + 3)), disabled);
				d->w = zc_max(d->w, t_w);
				memset(buf, 0, sizeof(buf));
				sprintf(buf, "FFScript Version: %d", meta.ffscript_v);
				t_w = txtout(target, buf, d->x, d->y + ((++ind)*(text_height(font) + 3)), disabled);
				d->w = zc_max(d->w, t_w);
				memset(buf, 0, sizeof(buf));
				sprintf(buf, "Script Name: %s", meta.script_name.c_str());
				t_w = txtout(target, buf, d->x, d->y + ((++ind)*(text_height(font) + 3)), disabled);
				d->w = zc_max(d->w, t_w);
				memset(buf, 0, sizeof(buf));
				sprintf(buf, "Author: %s", meta.author.c_str());
				t_w = txtout(target, buf, d->x, d->y + ((++ind)*(text_height(font) + 3)), disabled);
				d->w = zc_max(d->w, t_w);
				memset(buf, 0, sizeof(buf));
				sprintf(buf, "Script Type: %s", get_script_name(meta.script_type).c_str());
				t_w = txtout(target, buf, d->x, d->y + ((++ind)*(text_height(font) + 3)), disabled);
				d->w = zc_max(d->w, t_w);
				for(auto q = 0; q < 4; ++q)
				{
					if(!meta.attributes[q].size())
						continue;
					memset(buf, 0, sizeof(buf));
					sprintf(buf, "Attributes[%d]: %s", q, meta.attributes[q].c_str());
					t_w = txtout(target, buf, d->x, d->y + ((++ind)*(text_height(font) + 3)), disabled);
					d->w = zc_max(d->w, t_w);
				}
				for(auto q = 0; q < 8; ++q)
				{
					if(!meta.attribytes[q].size())
						continue;
					memset(buf, 0, sizeof(buf));
					sprintf(buf, "Attribytes[%d]: %s", q, meta.attribytes[q].c_str());
					t_w = txtout(target, buf, d->x, d->y + ((++ind)*(text_height(font) + 3)), disabled);
					d->w = zc_max(d->w, t_w);
				}
				for(auto q = 0; q < 8; ++q)
				{
					if(!meta.attrishorts[q].size())
						continue;
					memset(buf, 0, sizeof(buf));
					sprintf(buf, "Attrishorts[%d]: %s", q, meta.attrishorts[q].c_str());
					t_w = txtout(target, buf, d->x, d->y + ((++ind)*(text_height(font) + 3)), disabled);
					d->w = zc_max(d->w, t_w);
				}
				bool indentrun = false;
				int32_t run_indent = txtout(NULL, "void run(", 0, 0, false);
				std::ostringstream oss;
				oss << "void run(";
				for(int32_t q = 0; q < 8; ++q)
				{
					if(!meta.run_idens[q].size() || meta.run_types[q] == ZMETA_NULL_TYPE) continue;
					if(q > 0)
						oss << ", ";
					string type_name = ZScript::getTypeName(meta.run_types[q]);
					lowerstr(type_name); //all lowercase for this output
					if(oss.str().size() > unsigned(indentrun ? 41 : 50))
					{
						memset(buf, 0, sizeof(buf));
						sprintf(buf, "%s", oss.str().c_str());
						t_w = txtout(target, buf, d->x + (indentrun ? run_indent : 0), d->y + ((++ind)*(text_height(font) + 3)), disabled) + (indentrun ? run_indent : 0);
						d->w = zc_max(d->w, t_w);
						oss.str("");
						indentrun = true;
					}
					oss << type_name.c_str() << " " << meta.run_idens[q];
				}
				oss << ");";
				memset(buf, 0, sizeof(buf));
				sprintf(buf, "%s", oss.str().c_str());
				t_w = txtout(target, buf, d->x + (indentrun ? run_indent : 0), d->y + ((++ind)*(text_height(font) + 3)), disabled) + (indentrun ? run_indent : 0);
				d->w = zc_max(d->w, t_w);
				memset(buf, 0, sizeof(buf));
				sprintf(buf, "Compiler Version: %d.%d.%d.%d", meta.compiler_v1, meta.compiler_v2, meta.compiler_v3, meta.compiler_v4);
				t_w = txtout(target, buf, d->x, d->y + ((++ind)*(text_height(font) + 3)), disabled);
				d->w = zc_max(d->w, t_w);
				memset(buf, 0, sizeof(buf));
				sprintf(buf, "Parser-generated: %s", (meta.flags & ZMETA_AUTOGEN)!=0 ? "TRUE" : "FALSE");
				t_w = txtout(target, buf, d->x, d->y + ((++ind)*(text_height(font) + 3)), disabled);
				d->w = zc_max(d->w, t_w);
				d->h = (++ind) * (text_height(font) + 3) -3;
			}
			else
			{
				d->w = txtout(target, "No ZASM metadata found!", d->x, d->y, disabled);
				d->h = text_height(font);
			}
			
			if(d->dp3) //function trigger
			{
				typedef void (*funcType)(void);
				funcType func=reinterpret_cast<funcType>(d->dp3);
				func();
			}
			
			font = oldfont;
			break;
		}
    }
    
    return ret;
}

void resize_scriptinfo_dlg();

static DIALOG scriptinfo_dlg[] =
{
	//                    x     y       w       h        fg       bg   key    flags    d1    d2    dp
	{ jwin_win_proc,      0,    0,    200,    150,    vc(14),  vc(1),    0,  D_EXIT,    0,    0,   (void *) "Script Metadata", NULL, NULL },
	{ d_dummy_proc,       6,   25, 330-12,    130,         0,      0,    0,       0,    0,    0,   assignscript_tabs, NULL, NULL },
	{ jwin_button_proc,  70,  120,     60,     20,    vc(14),  vc(1),  'k',  D_EXIT,    0,    0,   (void *) "Done", NULL, NULL },
	{ jwin_zmeta_proc,   50,   30,    100,    100,    vc(14),  vc(1),    0,       0,    0,    0,   NULL, NULL, (void*)resize_scriptinfo_dlg },
	
	{ NULL,               0,    0,      0,      0,         0,      0,    0,       0,    0,    0,   NULL, NULL, NULL }
};

void resize_scriptinfo_dlg()
{
	DIALOG *meta_proc = &scriptinfo_dlg[3], *window = &scriptinfo_dlg[0], *ok_button = &scriptinfo_dlg[2];
	int32_t bmargin = 10, hmargins = 20;
	if(is_large)
	{
		bmargin *= 1.5;
		hmargins *= 1.5;
	}
	jwin_ulalign_dialog(scriptinfo_dlg);
	window->w = hmargins*2 + meta_proc->w;
	meta_proc->x = hmargins;
	window->h = meta_proc->y + meta_proc->h + ok_button->h + bmargin*2;
	ok_button->x = (window->w/2)-(ok_button->w/2);
	ok_button->y = meta_proc->y + meta_proc->h + bmargin;
	jwin_center_dialog(scriptinfo_dlg);
}

void showScriptInfo(zasm_meta const* meta)
{
	scriptinfo_dlg[3].dp = (void*)meta;
	scriptinfo_dlg[0].dp2 = lfont;
	if(is_large)
		large_dialog(scriptinfo_dlg);
	jwin_zmeta_proc(MSG_START,&scriptinfo_dlg[3],0); //Calculate size before calling dialog
	jwin_center_dialog(scriptinfo_dlg);
	zc_popup_dialog(scriptinfo_dlg,2);
}

static int32_t compiler_tab_list_global[] =
{
	10,11,12,13,14,15,16,18,19,20,21,25,26,
	-1
};

static int32_t compiler_tab_list_quest[] =
{
    6,7,8,9,17,22,23,24,
	-1
};

static TABPANEL compiler_options_tabs[] =
{
    // (text)
    { (char *)"Global Options",  D_SELECTED,  compiler_tab_list_global, 0, NULL },
    { (char *)"Quest-Specific Options",  0,           compiler_tab_list_quest, 0, NULL },
    { NULL,         0,           NULL, 0, NULL }
};


//static char zcompiler_halttype_str_buf[32];

const char *zcompiler_haltlist(int32_t index, int32_t *list_size)
{
    if(index >= 0)
    {
        bound(index,0,1);
        
	switch(index)
        {
        case 0:
            return "Halt";
            
        case 1:
            return "Do Not Halt";
        }
	
    }
    
    *list_size = 2;
    return NULL;
}

static ListData zcompiler_halt_list(zcompiler_haltlist, &pfont);

const char *zcompiler_guardlist(int32_t index, int32_t *list_size)
{
	if(index >= 0)
	{
		bound(index,0,3);
		
		switch(index)
		{
			case 0:
				return "Disable";
			
			case 1:
				return "Enable";
			
			case 2:
				return "Error, Enable";
			
			case 3:
				return "Warn, Enable";
		}
	}
	
	*list_size = 4;
	return NULL;
}

static ListData zcompiler_header_guard_list(zcompiler_guardlist, &pfont);

const char *zcompiler_deprlist(int32_t index, int32_t *list_size)
{
	if(index >= 0)
	{
		if(index < 0 || index > 2)
			index = 1;
		
		switch(index)
		{
			case 0:
				return "Ignore";
			
			case 1:
				return "Warn";
			
			case 2:
				return "Error";
		}
	}
	
	*list_size = 3;
	return NULL;
}

static ListData zcompiler_depr_list(zcompiler_deprlist, &pfont);

char tempincludepath[MAX_INCLUDE_PATH_CHARS];
char temprunstring[21];

static DIALOG zscript_parser_dlg[] =
{
	/* (dialog proc)       (x)    (y)   (w)   (h)     (fg)      (bg)     (key)      (flags)     (d1)           (d2)     (dp) */
	{ jwin_win_proc,         0,   0,    300,  235,    vc(14),   vc(1),      0,      D_EXIT,     0,             0, (void *) "ZScript Compiler Options", NULL, NULL },
	{ d_timer_proc,          0,    0,     0,    0,    0,        0,          0,      0,          0,             0,       NULL, NULL, NULL },
	// { d_dummy_proc,         5,   23,   290,  181,    vc(14),   vc(1),      0,      0,          1,             0, NULL, NULL, (void *)zscript_parser_dlg },
	{ jwin_tab_proc,            4,     23,    252,    182,    vc(0),      vc(15),      0,    0,          0,    0, (void *) compiler_options_tabs,     NULL, (void *)zscript_parser_dlg },
	// 3
	{ jwin_button_proc,    170,  210,    61,   21,    vc(14),   vc(1),     27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
	{ jwin_button_proc,     90,  210,    61,   21,    vc(14),   vc(1),     13,      D_EXIT,     0,             0, (void *) "OK", NULL, NULL },
	{ d_keyboard_proc,       0,    0,     0,    0,         0,       0,      0,      0,          KEY_F1,        0, (void *) onHelp, NULL, NULL },
	
	// rules //6
	{ jwin_check_proc,      10, 32+10,  185,    9,    vc(14),   vc(1),      0,      0,          1,             0, (void *) "2.50 Division Truncation", NULL, NULL },
	{ jwin_check_proc,      10, 32+20,  185,    9,    vc(14),   vc(1),      0,      0,          1,             0, (void *) "Disable Tracing", NULL, NULL },
	{ jwin_check_proc,      10, 32+30,  185,    9,    vc(14),   vc(1),      0,      0,          1,             0, (void *) "Short-Circuit Boolean Operations", NULL, NULL },
	{ jwin_check_proc,      10, 32+40,  185,    9,    vc(14),   vc(1),      0,      0,          1,             0, (void *) "2.50 Value of Boolean 'true' is 0.0001", NULL, NULL },
	//10
	{ d_showedit_proc,      6+10,  122,   220,   16,    vc(12),  vc(1),  0,       0, MAX_INCLUDE_PATH_CHARS,            0,       tempincludepath, NULL, NULL },
	{ jwin_textbox_proc,    6+10,  140,   220,  60,   vc(11),  vc(1),  0,       0,          0,            0,       tempincludepath, NULL, NULL },
   
	{ jwin_text_proc,           86,     38+10,     96,      8,    vc(14),                 vc(1),                   0,       0,           0,    0, 
		(void *) ": On Error",                  NULL,   NULL                  },
	{ jwin_droplist_proc,     10,     32+10,     72,      16, jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],           0,       0,           1,    0, 
		(void *) &zcompiler_halt_list,						 NULL,   NULL 				   },
	{ jwin_text_proc,           86,     38+24,     96,      8,    vc(14),                 vc(1),                   0,       0,           0,    0, 
		(void *) ": Header Guard",                  NULL,   NULL                  },
	{ jwin_droplist_proc,     10,     32+24,     72,      16, jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],           0,       0,           1,    0, 
		(void *) &zcompiler_header_guard_list,						 NULL,   NULL 				   },
	{ jwin_text_proc,           17,     122-11,     96,      8,    vc(14),                 vc(1),                   0,       0,           0,    0, 
		(void *) "Include Paths:",                  NULL,   NULL                  },
	//17
	{ jwin_check_proc,      10, 32+50,  185,    9,    vc(14),   vc(1),      0,      0,          1,             0, (void *) "True MAX_INT sizing", NULL, NULL },
	
	{ d_dummy_proc,           86,     38+38,     96,      8,    vc(14),                 vc(1),                   0,       0,           0,    0, 
		(void *) ": Max Include Paths",                  NULL,   NULL                  },
	{ d_dummy_proc,     10,     32+38,     72,      16, jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],           0,       0,           1,    0, 
		NULL,						 NULL,   NULL 				   },
	
	//20 run function
	{ jwin_edit_proc,    16,  102-11,   50,  16,   vc(11),  vc(1),  0,       0,          64,            0,       temprunstring, NULL, NULL },
	{ jwin_text_proc,           68,     102-8,     96,      8,    vc(14),                 vc(1),                   0,       0,           0,    0, 
		(void *) "void run()' label:",                  NULL,   NULL                  },
	{ d_dummy_proc,      10, 32+60+500,  185,    9,    vc(14),   vc(1),      0,      0,          1,             0, (void *) "Inline all possible functions", NULL, NULL },
	{ jwin_check_proc,      10, 32+60,  185,    9,    vc(14),   vc(1),      0,      0,          1,             0, (void *) "Binary Operations use true 32-bit Int", NULL, NULL },
	{ jwin_check_proc,      10, 32+70,  185,    9,    vc(14),   vc(1),      0,      0,          1,             0, (void *) "Switch/case of strings is case-insensitive", NULL, NULL },
	
	//25
	{ jwin_text_proc,           86,     38+38,     96,      8,    vc(14),                 vc(1),                   0,       0,           0,    0, 
		(void *) ": On Deprecated Use",                  NULL,   NULL                  },
	{ jwin_droplist_proc,     10,     32+38,     72,      16, jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],           0,       0,           1,    0, 
		(void *) &zcompiler_depr_list,						 NULL,   NULL 				   },
	
	{ NULL,                  0,    0,     0,    0,    0,        0,          0,      0,          0,             0,       NULL, NULL, NULL }
};


static int32_t zscripparsertrules[] =
{
	qr_PARSER_250DIVISION,
	qr_PARSER_NO_LOGGING,
	qr_PARSER_SHORT_CIRCUIT,
	qr_PARSER_BOOL_TRUE_DECIMAL,
	0, //this dialogue index is used by global settings
	0, //this dialogue index is used by global settings
	0, //this dialogue index is used by global settings
	0, //this dialogue index is used by global settings
	0, //this dialogue index is used by global settings
	0, //this dialogue index is used by global settings
	0, //this dialogue index is used by global settings
	qr_PARSER_TRUE_INT_SIZE,
	0, //this dialogue index is used by global settings
	0, //this dialogue index is used by global settings
	0, //this dialogue index is used by global settings
	0, //this dialogue index is used by global settings
	qr_PARSER_FORCE_INLINE,
	qr_PARSER_BINARY_32BIT,
	qr_PARSER_STRINGSWITCH_INSENSITIVE,
	-1
};

void write_includepaths();
int32_t onZScriptCompilerSettings()
{
	if(is_large)
		large_dialog(zscript_parser_dlg);
		
	zscript_parser_dlg[0].dp2=lfont;
	
	int32_t old_cfgs[3];
	zscript_parser_dlg[13].d1 = old_cfgs[0] = zc_get_config("Compiler","NO_ERROR_HALT",0,App::zscript);
	zscript_parser_dlg[15].d1 = old_cfgs[1] = zc_get_config("Compiler","HEADER_GUARD",1,App::zscript);
	zscript_parser_dlg[26].d1 = old_cfgs[2] = zc_get_config("Compiler","WARN_DEPRECATED",0,App::zscript);
	//memset(tempincludepath,0,sizeof(tempincludepath));
	strcpy(tempincludepath,FFCore.includePathString);
	//al_trace("Include path string in editbox should be: %s\n",tempincludepath);
	zscript_parser_dlg[10].dp = tempincludepath;
	
	//run label
	strcpy(temprunstring,FFCore.scriptRunString);
	//al_trace("Include path string in editbox should be: %s\n",tempincludepath);
	zscript_parser_dlg[20].dp = temprunstring;
   
	for(int32_t i=0; zscripparsertrules[i]!=-1; i++)
	{
		//This loop ignores trying to set bits in quest_rules, if the option is on the global settings tab.
		//These settings are stored in zquest.cfg, not in the quest file. -ZoriaRPG (3rd April, 2019 )
		for ( int32_t q = 0; q < (sizeof(compiler_tab_list_global)/4); q++ ) //Only if the bit is quest-based, in quest_rules.
		{
		if ( compiler_tab_list_global[q] == i ) continue;
			
		}
		zscript_parser_dlg[i+6].flags = get_bit(quest_rules,zscripparsertrules[i]) ? D_SELECTED : 0;
	}
	
 
	
	int32_t ret = zc_popup_dialog(zscript_parser_dlg,4);
	
	if(ret==4)
	{
		saved=false;
		
		for(int32_t i=0; zscripparsertrules[i]!=-1; i++)
		{
			set_bit(quest_rules, zscripparsertrules[i], zscript_parser_dlg[i+6].flags & D_SELECTED);
		}
		memset(FFCore.includePathString,0,sizeof(FFCore.includePathString));
		strcpy(FFCore.includePathString,tempincludepath);
		if(old_cfgs[0] != zscript_parser_dlg[13].d1)
			zc_set_config("Compiler","NO_ERROR_HALT",zscript_parser_dlg[13].d1,App::zscript);
		if(old_cfgs[1] != zscript_parser_dlg[15].d1)
			zc_set_config("Compiler","HEADER_GUARD",zscript_parser_dlg[15].d1,App::zscript);
		if(old_cfgs[2] != zscript_parser_dlg[26].d1)
			zc_set_config("Compiler","WARN_DEPRECATED",zscript_parser_dlg[26].d1,App::zscript);
		memset(FFCore.scriptRunString, 0, sizeof(FFCore.scriptRunString));
		strcpy(FFCore.scriptRunString,temprunstring);
		FFCore.updateIncludePaths();
		ZQincludePaths = FFCore.includePaths;
		write_includepaths();
	}
	
	return D_O_K;
}

//editbox_data zscript_edit_data;

static DIALOG edit_zscript_dlg[] =
{
    /* (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)      (d2)      (dp) */
    { jwin_win_proc,        0,   0,   320,  240,  0,       vc(15), 0,      D_EXIT,       0,          0, (void *) "Edit ZScript", NULL, NULL },
    { jwin_frame_proc,   4,   23,   320-8,  240-27,   0,       0,      0,       0,             FR_DEEP,       0,       NULL, NULL, NULL },
    { d_editbox_proc,    6,   25,   320-12,  240-6-25,  0,       0,      0,       0/*D_SELECTED*/,          0,        0,        NULL, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,       0,      0,       0,          0,        KEY_ESC, (void *) close_dlg, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,       0,      0,       0,          0,        KEY_F12, (void *) onSnapshot, NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

void doEditZScript(int32_t bg,int32_t fg)
{
    string old = zScript;
    EditboxModel *em = new EditboxModel(zScript, new EditboxScriptView(&edit_zscript_dlg[2],get_custom_font(CFONT_TEXTBOX),fg,bg,BasicEditboxView::HSTYLE_EOTEXT), false, (char *)"zscript.txt");
    edit_zscript_dlg[0].dp2= get_custom_font(CFONT_TITLE);
    edit_zscript_dlg[2].dp = em;
    edit_zscript_dlg[2].bg = bg;
    
    zc_popup_dialog(edit_zscript_dlg,2);
    
    if(jwin_alert("ZScript Buffer","Save changes to buffer?",NULL,NULL,"Yes","No",'y','n',lfont)==2)
        zScript = old;
    else
        saved=false;
        
    delete em;
}

//{ Start type-specific import dlgs
static ListData ffscript_sel_dlg_list(ffscriptlist2, &font);
static ListData itemscript_sel_dlg_list(itemscriptlist2, &font);
static ListData comboscript_sel_dlg_list(comboscriptlist2, &font);
static ListData gscript_sel_dlg_list(gscriptlist2, &font);
static char npcscript_str_buf2[32];
const char *npcscriptlist2(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        char buf[20];
        bound(index,0,254);
        
        if(npcmap[index].scriptname=="")
            strcpy(buf, "<none>");
        else
        {
            strncpy(buf, npcmap[index].scriptname.c_str(), 19);
            buf[19]='\0';
        }
        
        sprintf(npcscript_str_buf2,"%d: %s",index+1, buf);
        return npcscript_str_buf2;
    }
    
    *list_size=(NUMSCRIPTGUYS-1);
    return NULL;
}
static ListData npcscript_sel_dlg_list(npcscriptlist2, &font);
static char lweaponscript_str_buf2[32];
const char *lweaponscriptlist2(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        char buf[20];
        bound(index,0,254);
        
        if(lwpnmap[index].scriptname=="")
            strcpy(buf, "<none>");
        else
        {
            strncpy(buf, lwpnmap[index].scriptname.c_str(), 19);
            buf[19]='\0';
        }
        
        sprintf(lweaponscript_str_buf2,"%d: %s",index+1, buf);
        return lweaponscript_str_buf2;
    }
    
    *list_size=(NUMSCRIPTWEAPONS-1);
    return NULL;
}
static ListData lweaponscript_sel_dlg_list(lweaponscriptlist2, &font);
static char eweaponscript_str_buf2[32];
const char *eweaponscriptlist2(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        char buf[20];
        bound(index,0,254);
        
        if(ewpnmap[index].scriptname=="")
            strcpy(buf, "<none>");
        else
        {
            strncpy(buf, ewpnmap[index].scriptname.c_str(), 19);
            buf[19]='\0';
        }
        
        sprintf(eweaponscript_str_buf2,"%d: %s",index+1, buf);
        return eweaponscript_str_buf2;
    }
    
    *list_size=(NUMSCRIPTWEAPONS-1);
    return NULL;
}
static ListData eweaponscript_sel_dlg_list(eweaponscriptlist2, &font);
static char playerscript_str_buf2[32];
const char *playerscriptlist2(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        char buf[20];
        bound(index,0,3);
        
        if(playermap[index].scriptname=="")
            strcpy(buf, "<none>");
        else
        {
            strncpy(buf, playermap[index].scriptname.c_str(), 19);
            buf[19]='\0';
        }
	
	if(index==0)
            sprintf(playerscript_str_buf2,"Init: %s", buf);
            
        if(index==1)
            sprintf(playerscript_str_buf2,"Active: %s", buf);
	
	if(index==2)
            sprintf(playerscript_str_buf2,"Death: %s", buf);
            
        
        //sprintf(playerscript_str_buf2,"%d: %s",index+1, buf);
        return playerscript_str_buf2;
    }
    
    *list_size=(NUMSCRIPTPLAYER-1);
    return NULL;
}
static char itemspritescript_str_buf2[32];
const char *itemspritescriptlist2(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        char buf[20];
        bound(index,0,254);
        
        if(itemspritemap[index].scriptname=="")
            strcpy(buf, "<none>");
        else
        {
            strncpy(buf, itemspritemap[index].scriptname.c_str(), 19);
            buf[19]='\0';
        }
        
        sprintf(itemspritescript_str_buf2,"%d: %s",index+1, buf);
        return itemspritescript_str_buf2;
    }
    
    *list_size=(NUMSCRIPTSITEMSPRITE-1);
    return NULL;
}
static ListData playerscript_sel_dlg_list(playerscriptlist2, &font);
static char dmapscript_str_buf2[32];
const char *dmapscriptlist2(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        char buf[20];
        bound(index,0,254);
        
        if(dmapmap[index].scriptname=="")
            strcpy(buf, "<none>");
        else
        {
            strncpy(buf, dmapmap[index].scriptname.c_str(), 19);
            buf[19]='\0';
        }
        
        sprintf(dmapscript_str_buf2,"%d: %s",index+1, buf);
        return dmapscript_str_buf2;
    }
    
    *list_size=(NUMSCRIPTSDMAP-1);
    return NULL;
}
static ListData dmapscript_sel_dlg_list(dmapscriptlist2, &font);
static ListData itemspritescript_sel_dlg_list(itemspritescriptlist2, &font);
static char screenscript_str_buf2[32];
const char *screenscriptlist2(int32_t index, int32_t *list_size)
{
    if(index>=0)
    {
        char buf[20];
        bound(index,0,254);
        
        if(screenmap[index].scriptname=="")
            strcpy(buf, "<none>");
        else
        {
            strncpy(buf, screenmap[index].scriptname.c_str(), 19);
            buf[19]='\0';
        }
        
        sprintf(screenscript_str_buf2,"%d: %s",index+1, buf);
        return screenscript_str_buf2;
    }
    
    *list_size=(NUMSCRIPTSCREEN-1);
    return NULL;
}
static ListData screenscript_sel_dlg_list(screenscriptlist2, &font);
//} End type-specific import dlgs

void clear_map_states()
{
	for(map<int32_t, script_slot_data>::iterator it = ffcmap.begin();
		it != ffcmap.end(); ++it)
	{
		(*it).second.format = SCRIPT_FORMAT_DEFAULT;
	}
	for(map<int32_t, script_slot_data>::iterator it = globalmap.begin();
		it != globalmap.end(); ++it)
	{
		(*it).second.format = SCRIPT_FORMAT_DEFAULT;
	}
	for(map<int32_t, script_slot_data>::iterator it = itemmap.begin();
		it != itemmap.end(); ++it)
	{
		(*it).second.format = SCRIPT_FORMAT_DEFAULT;
	}
	for(map<int32_t, script_slot_data>::iterator it = npcmap.begin();
		it != npcmap.end(); ++it)
	{
		(*it).second.format = SCRIPT_FORMAT_DEFAULT;
	}
	for(map<int32_t, script_slot_data>::iterator it = ewpnmap.begin();
		it != ewpnmap.end(); ++it)
	{
		(*it).second.format = SCRIPT_FORMAT_DEFAULT;
	}
	for(map<int32_t, script_slot_data>::iterator it = lwpnmap.begin();
		it != lwpnmap.end(); ++it)
	{
		(*it).second.format = SCRIPT_FORMAT_DEFAULT;
	}
	for(map<int32_t, script_slot_data>::iterator it = playermap.begin();
		it != playermap.end(); ++it)
	{
		(*it).second.format = SCRIPT_FORMAT_DEFAULT;
	}
	for(map<int32_t, script_slot_data>::iterator it = dmapmap.begin();
		it != dmapmap.end(); ++it)
	{
		(*it).second.format = SCRIPT_FORMAT_DEFAULT;
	}
	for(map<int32_t, script_slot_data>::iterator it = screenmap.begin();
		it != screenmap.end(); ++it)
	{
		(*it).second.format = SCRIPT_FORMAT_DEFAULT;
	}
	for(map<int32_t, script_slot_data>::iterator it = itemspritemap.begin();
		it != itemspritemap.end(); ++it)
	{
		(*it).second.format = SCRIPT_FORMAT_DEFAULT;
	}
	for(map<int32_t, script_slot_data>::iterator it = comboscriptmap.begin();
		it != comboscriptmap.end(); ++it)
	{
		(*it).second.format = SCRIPT_FORMAT_DEFAULT;
	}
}

void clearAssignSlotDlg()
{
	assignscript_dlg[0].dp2 = lfont;
	assignscript_dlg[4].d1 = -1;
	assignscript_dlg[5].d1 = -1;
	assignscript_dlg[7].d1 = -1;
	assignscript_dlg[8].d1 = -1;
	assignscript_dlg[10].d1 = -1;
	assignscript_dlg[11].d1 = -1;
	assignscript_dlg[13].flags = 0;
}

int32_t onSlotAssign()
{
	clearAssignSlotDlg();
	//Clear right-hand side of names
	asffcscripts.clear();
	asffcscripts.push_back("<none>");
	asglobalscripts.clear();
	asglobalscripts.push_back("<none>");
	asitemscripts.clear();
	asitemscripts.push_back("<none>");
	asnpcscripts.clear();
	asnpcscripts.push_back("<none>");
	aseweaponscripts.clear();
	aseweaponscripts.push_back("<none>");
	aslweaponscripts.clear();
	aslweaponscripts.push_back("<none>");
	asplayerscripts.clear();
	asplayerscripts.push_back("<none>");
	asdmapscripts.clear();
	asdmapscripts.push_back("<none>");
	asscreenscripts.clear();
	asscreenscripts.push_back("<none>");
	asitemspritescripts.clear();
	asitemspritescripts.push_back("<none>");
	
	ascomboscripts.clear();
	ascomboscripts.push_back("<none>");
	asgenericscripts.clear();
	asgenericscripts.push_back("<none>");
	//Declare new script vector
	map<string, disassembled_script_data> scripts;
	
	do_script_disassembly(scripts, false);
	
	do_slots(scripts);
	return D_O_K;
}

void inc_script_name(string& name)
{
	size_t pos = name.find_last_not_of("0123456789");
	pos = name.find_first_of("0123456789",pos);
	std::ostringstream oss;
	if(pos == string::npos)
	{
		oss << name << 2;
	}
	else
	{
		int32_t val = atoi(name.substr(pos).c_str());
		oss << name.substr(0,pos) << val+1;
	}
	name = oss.str();
}

void do_script_disassembly(map<string, disassembled_script_data>& scripts, bool fromCompile)
{
	clearAssignSlotDlg();
	bool skipDisassembled = fromCompile && try_recovering_missing_scripts == 0;
	for(int32_t i = 0; i < NUMSCRIPTGLOBAL; ++i)
	{
		if(scripts.find(globalmap[i].scriptname) != scripts.end())
		{
			if(scripts[globalmap[i].scriptname].first.script_type != SCRIPT_GLOBAL)
			{
				while(scripts.find(globalmap[i].scriptname) != scripts.end())
					inc_script_name(globalmap[i].scriptname);
			}
			else continue;
		}
		switch(i)
		{
			case GLOBAL_SCRIPT_INIT:
			{
				break;
			}
			default:
				if(!globalmap[i].isEmpty())
				{
					if(skipDisassembled && globalmap[i].format != SCRIPT_FORMAT_ZASM
					   && (globalscripts[i]->meta.flags & ZMETA_IMPORTED) == 0)
					{
						globalmap[i].format = SCRIPT_FORMAT_INVALID;
						continue;
					}
					if(globalscripts[i]->valid())
					{
						disassembled_script_data data = disassemble_script(globalscripts[i]);
						if((globalscripts[i]->meta.flags & ZMETA_IMPORTED))
						{
							globalmap[i].format = SCRIPT_FORMAT_ZASM;
							globalmap[i].update();
						}
						else if(fromCompile || (globalscripts[i]->meta.flags & ZMETA_DISASSEMBLED))
						{
							globalmap[i].format = SCRIPT_FORMAT_DISASSEMBLED;
							globalmap[i].update();
						}
						data.format = globalmap[i].format;
						scripts[globalmap[i].scriptname] = data;
						asglobalscripts.push_back(data.formatName(globalmap[i].scriptname));
					}
				}
		}
	}
	for(int32_t i = 0; i < NUMSCRIPTFFC-1; ++i)
	{
		if(scripts.find(ffcmap[i].scriptname) != scripts.end())
		{
			if(scripts[ffcmap[i].scriptname].first.script_type != SCRIPT_FFC)
			{
				while(scripts.find(ffcmap[i].scriptname) != scripts.end())
					inc_script_name(ffcmap[i].scriptname);
			}
			else continue;
		}
		if(!ffcmap[i].isEmpty())
		{
			if(skipDisassembled && ffcmap[i].format != SCRIPT_FORMAT_ZASM
			   && (ffscripts[i+1]->meta.flags & ZMETA_IMPORTED) == 0)
			{
				ffcmap[i].format = SCRIPT_FORMAT_INVALID;
				continue;
			}
			if(ffscripts[i+1]->valid())
			{
				disassembled_script_data data = disassemble_script(ffscripts[i+1]);
				if((ffscripts[i+1]->meta.flags & ZMETA_IMPORTED))
				{
					ffcmap[i].format = SCRIPT_FORMAT_ZASM;
					ffcmap[i].update();
				}
				else if(fromCompile || (ffscripts[i+1]->meta.flags & ZMETA_DISASSEMBLED))
				{
					ffcmap[i].format = SCRIPT_FORMAT_DISASSEMBLED;
					ffcmap[i].update();
				}
				data.format = ffcmap[i].format;
				scripts[ffcmap[i].scriptname] = data;
				asffcscripts.push_back(data.formatName(ffcmap[i].scriptname));
			}
		}
	}
	for(int32_t i = 0; i < NUMSCRIPTITEM-1; ++i)
	{
		if(scripts.find(itemmap[i].scriptname) != scripts.end())
		{
			if(scripts[itemmap[i].scriptname].first.script_type != SCRIPT_ITEM)
			{
				while(scripts.find(itemmap[i].scriptname) != scripts.end())
					inc_script_name(itemmap[i].scriptname);
			}
			else continue;
		}
		if(!itemmap[i].isEmpty())
		{
			if(skipDisassembled && itemmap[i].format != SCRIPT_FORMAT_ZASM
			   && (itemscripts[i+1]->meta.flags & ZMETA_IMPORTED) == 0)
			{
				itemmap[i].format = SCRIPT_FORMAT_INVALID;
				continue;
			}
			if(itemscripts[i+1]->valid())
			{
				disassembled_script_data data = disassemble_script(itemscripts[i+1]);
				if((itemscripts[i+1]->meta.flags & ZMETA_IMPORTED))
				{
					itemmap[i].format = SCRIPT_FORMAT_ZASM;
					itemmap[i].update();
				}
				else if(fromCompile || (itemscripts[i+1]->meta.flags & ZMETA_DISASSEMBLED))
				{
					itemmap[i].format = SCRIPT_FORMAT_DISASSEMBLED;
					itemmap[i].update();
				}
				data.format = itemmap[i].format;
				scripts[itemmap[i].scriptname] = data;
				asitemscripts.push_back(data.formatName(itemmap[i].scriptname));
			}
		}
	}
	for(int32_t i = 0; i < NUMSCRIPTGUYS-1; ++i)
	{
		if(scripts.find(npcmap[i].scriptname) != scripts.end())
		{
			if(scripts[npcmap[i].scriptname].first.script_type != SCRIPT_NPC)
			{
				while(scripts.find(npcmap[i].scriptname) != scripts.end())
					inc_script_name(npcmap[i].scriptname);
			}
			else continue;
		}
		if(!npcmap[i].isEmpty())
		{
			if(skipDisassembled && npcmap[i].format != SCRIPT_FORMAT_ZASM
			   && (guyscripts[i+1]->meta.flags & ZMETA_IMPORTED) == 0)
			{
				npcmap[i].format = SCRIPT_FORMAT_INVALID;
				continue;
			}
			if(guyscripts[i+1]->valid())
			{
				disassembled_script_data data = disassemble_script(guyscripts[i+1]);
				if((guyscripts[i+1]->meta.flags & ZMETA_IMPORTED))
				{
					npcmap[i].format = SCRIPT_FORMAT_ZASM;
					npcmap[i].update();
				}
				else if(fromCompile || (guyscripts[i+1]->meta.flags & ZMETA_DISASSEMBLED))
				{
					npcmap[i].format = SCRIPT_FORMAT_DISASSEMBLED;
					npcmap[i].update();
				}
				data.format = npcmap[i].format;
				scripts[npcmap[i].scriptname] = data;
				asnpcscripts.push_back(data.formatName(npcmap[i].scriptname));
			}
		}
	}
	for(int32_t i = 0; i < NUMSCRIPTWEAPONS-1; ++i)
	{
		if(scripts.find(lwpnmap[i].scriptname) != scripts.end())
		{
			if(scripts[lwpnmap[i].scriptname].first.script_type != SCRIPT_LWPN)
			{
				while(scripts.find(lwpnmap[i].scriptname) != scripts.end())
					inc_script_name(lwpnmap[i].scriptname);
			}
			else continue;
		}
		if(!lwpnmap[i].isEmpty())
		{
			if(skipDisassembled && lwpnmap[i].format != SCRIPT_FORMAT_ZASM
			   && (lwpnscripts[i+1]->meta.flags & ZMETA_IMPORTED) == 0)
			{
				lwpnmap[i].format = SCRIPT_FORMAT_INVALID;
				continue;
			}
			if(lwpnscripts[i+1]->valid())
			{
				disassembled_script_data data = disassemble_script(lwpnscripts[i+1]);
				if((lwpnscripts[i+1]->meta.flags & ZMETA_IMPORTED))
				{
					lwpnmap[i].format = SCRIPT_FORMAT_ZASM;
					lwpnmap[i].update();
				}
				else if(fromCompile || (lwpnscripts[i+1]->meta.flags & ZMETA_DISASSEMBLED))
				{
					lwpnmap[i].format = SCRIPT_FORMAT_DISASSEMBLED;
					lwpnmap[i].update();
				}
				data.format = lwpnmap[i].format;
				scripts[lwpnmap[i].scriptname] = data;
				aslweaponscripts.push_back(data.formatName(lwpnmap[i].scriptname));
			}
		}
	}
	for(int32_t i = 0; i < NUMSCRIPTWEAPONS-1; ++i)
	{
		if(scripts.find(ewpnmap[i].scriptname) != scripts.end())
		{
			if(scripts[ewpnmap[i].scriptname].first.script_type != SCRIPT_EWPN)
			{
				while(scripts.find(ewpnmap[i].scriptname) != scripts.end())
					inc_script_name(ewpnmap[i].scriptname);
			}
			else continue;
		}
		if(!ewpnmap[i].isEmpty())
		{
			if(skipDisassembled && ewpnmap[i].format != SCRIPT_FORMAT_ZASM
			   && (ewpnscripts[i+1]->meta.flags & ZMETA_IMPORTED) == 0)
			{
				ewpnmap[i].format = SCRIPT_FORMAT_INVALID;
				continue;
			}
			if(ewpnscripts[i+1]->valid())
			{
				disassembled_script_data data = disassemble_script(ewpnscripts[i+1]);
				if((ewpnscripts[i+1]->meta.flags & ZMETA_IMPORTED))
				{
					ewpnmap[i].format = SCRIPT_FORMAT_ZASM;
					ewpnmap[i].update();
				}
				else if(fromCompile || (ewpnscripts[i+1]->meta.flags & ZMETA_DISASSEMBLED))
				{
					ewpnmap[i].format = SCRIPT_FORMAT_DISASSEMBLED;
					ewpnmap[i].update();
				}
				data.format = ewpnmap[i].format;
				scripts[ewpnmap[i].scriptname] = data;
				aseweaponscripts.push_back(data.formatName(ewpnmap[i].scriptname));
			}
		}
	}
	for(int32_t i = 0; i < NUMSCRIPTPLAYER-1; ++i)
	{
		if(scripts.find(playermap[i].scriptname) != scripts.end())
		{
			if(scripts[playermap[i].scriptname].first.script_type != SCRIPT_PLAYER)
			{
				while(scripts.find(playermap[i].scriptname) != scripts.end())
					inc_script_name(playermap[i].scriptname);
			}
			else continue;
		}
		if(!playermap[i].isEmpty())
		{
			if(skipDisassembled && playermap[i].format != SCRIPT_FORMAT_ZASM
			   && (playerscripts[i+1]->meta.flags & ZMETA_IMPORTED) == 0)
			{
				playermap[i].format = SCRIPT_FORMAT_INVALID;
				continue;
			}
			if(playerscripts[i+1]->valid())
			{
				disassembled_script_data data = disassemble_script(playerscripts[i+1]);
				if((playerscripts[i+1]->meta.flags & ZMETA_IMPORTED))
				{
					playermap[i].format = SCRIPT_FORMAT_ZASM;
					playermap[i].update();
				}
				else if(fromCompile || (playerscripts[i+1]->meta.flags & ZMETA_DISASSEMBLED))
				{
					playermap[i].format = SCRIPT_FORMAT_DISASSEMBLED;
					playermap[i].update();
				}
				data.format = playermap[i].format;
				scripts[playermap[i].scriptname] = data;
				asplayerscripts.push_back(data.formatName(playermap[i].scriptname));
			}
		}
	}
	for(int32_t i = 0; i < NUMSCRIPTSDMAP-1; ++i)
	{
		if(scripts.find(dmapmap[i].scriptname) != scripts.end())
		{
			if(scripts[dmapmap[i].scriptname].first.script_type != SCRIPT_DMAP)
			{
				while(scripts.find(dmapmap[i].scriptname) != scripts.end())
					inc_script_name(dmapmap[i].scriptname);
			}
			else continue;
		}
		if(!dmapmap[i].isEmpty())
		{
			if(skipDisassembled && dmapmap[i].format != SCRIPT_FORMAT_ZASM
			   && (dmapscripts[i+1]->meta.flags & ZMETA_IMPORTED) == 0)
			{
				dmapmap[i].format = SCRIPT_FORMAT_INVALID;
				continue;
			}
			if(dmapscripts[i+1]->valid())
			{
				disassembled_script_data data = disassemble_script(dmapscripts[i+1]);
				if((dmapscripts[i+1]->meta.flags & ZMETA_IMPORTED))
				{
					dmapmap[i].format = SCRIPT_FORMAT_ZASM;
					dmapmap[i].update();
				}
				else if(fromCompile || (dmapscripts[i+1]->meta.flags & ZMETA_DISASSEMBLED))
				{
					dmapmap[i].format = SCRIPT_FORMAT_DISASSEMBLED;
					dmapmap[i].update();
				}
				data.format = dmapmap[i].format;
				scripts[dmapmap[i].scriptname] = data;
				asdmapscripts.push_back(data.formatName(dmapmap[i].scriptname));
			}
		}
	}
	for(int32_t i = 0; i < NUMSCRIPTSCREEN-1; ++i)
	{
		if(scripts.find(screenmap[i].scriptname) != scripts.end())
		{
			if(scripts[screenmap[i].scriptname].first.script_type != SCRIPT_SCREEN)
			{
				while(scripts.find(screenmap[i].scriptname) != scripts.end())
					inc_script_name(screenmap[i].scriptname);
			}
			else continue;
		}
		if(!screenmap[i].isEmpty())
		{
			if(skipDisassembled && screenmap[i].format != SCRIPT_FORMAT_ZASM
			   && (screenscripts[i+1]->meta.flags & ZMETA_IMPORTED) == 0)
			{
				screenmap[i].format = SCRIPT_FORMAT_INVALID;
				continue;
			}
			if(screenscripts[i+1]->valid())
			{
				disassembled_script_data data = disassemble_script(screenscripts[i+1]);
				if((screenscripts[i+1]->meta.flags & ZMETA_IMPORTED))
				{
					screenmap[i].format = SCRIPT_FORMAT_ZASM;
					screenmap[i].update();
				}
				else if(fromCompile || (screenscripts[i+1]->meta.flags & ZMETA_DISASSEMBLED))
				{
					screenmap[i].format = SCRIPT_FORMAT_DISASSEMBLED;
					screenmap[i].update();
				}
				data.format = screenmap[i].format;
				scripts[screenmap[i].scriptname] = data;
				asscreenscripts.push_back(data.formatName(screenmap[i].scriptname));
			}
		}
	}
	for(int32_t i = 0; i < NUMSCRIPTSITEMSPRITE-1; ++i)
	{
		if(scripts.find(itemspritemap[i].scriptname) != scripts.end())
		{
			if(scripts[itemspritemap[i].scriptname].first.script_type != SCRIPT_ITEMSPRITE)
			{
				while(scripts.find(itemspritemap[i].scriptname) != scripts.end())
					inc_script_name(itemspritemap[i].scriptname);
			}
			else continue;
		}
		if(!itemspritemap[i].isEmpty())
		{
			if(skipDisassembled && itemspritemap[i].format != SCRIPT_FORMAT_ZASM
			   && (itemspritescripts[i+1]->meta.flags & ZMETA_IMPORTED) == 0)
			{
				itemspritemap[i].format = SCRIPT_FORMAT_INVALID;
				continue;
			}
			if(itemspritescripts[i+1]->valid())
			{
				disassembled_script_data data = disassemble_script(itemspritescripts[i+1]);
				if((itemspritescripts[i+1]->meta.flags & ZMETA_IMPORTED))
				{
					itemspritemap[i].format = SCRIPT_FORMAT_ZASM;
					itemspritemap[i].update();
				}
				else if(fromCompile || (itemspritescripts[i+1]->meta.flags & ZMETA_DISASSEMBLED))
				{
					itemspritemap[i].format = SCRIPT_FORMAT_DISASSEMBLED;
					itemspritemap[i].update();
				}
				data.format = itemspritemap[i].format;
				scripts[itemspritemap[i].scriptname] = data;
				asitemspritescripts.push_back(data.formatName(itemspritemap[i].scriptname));
			}
		}
	}
	for(int32_t i = 0; i < NUMSCRIPTSCOMBODATA-1; ++i)
	{
		if(scripts.find(comboscriptmap[i].scriptname) != scripts.end())
		{
			if(scripts[comboscriptmap[i].scriptname].first.script_type != SCRIPT_COMBO)
			{
				while(scripts.find(comboscriptmap[i].scriptname) != scripts.end())
					inc_script_name(comboscriptmap[i].scriptname);
			}
			else continue;
		}
		if(!comboscriptmap[i].isEmpty())
		{
			if(skipDisassembled && comboscriptmap[i].format != SCRIPT_FORMAT_ZASM
			   && (comboscripts[i+1]->meta.flags & ZMETA_IMPORTED) == 0)
			{
				comboscriptmap[i].format = SCRIPT_FORMAT_INVALID;
				continue;
			}
			if(comboscripts[i+1]->valid())
			{
				disassembled_script_data data = disassemble_script(comboscripts[i+1]);
				if((comboscripts[i+1]->meta.flags & ZMETA_IMPORTED))
				{
					comboscriptmap[i].format = SCRIPT_FORMAT_ZASM;
					comboscriptmap[i].update();
				}
				else if(fromCompile || (comboscripts[i+1]->meta.flags & ZMETA_DISASSEMBLED))
				{
					comboscriptmap[i].format = SCRIPT_FORMAT_DISASSEMBLED;
					comboscriptmap[i].update();
				}
				data.format = comboscriptmap[i].format;
				scripts[comboscriptmap[i].scriptname] = data;
				ascomboscripts.push_back(data.formatName(comboscriptmap[i].scriptname));
			}
		}
	}
	for(int32_t i = 0; i < NUMSCRIPTSGENERIC-1; ++i)
	{
		if(scripts.find(genericmap[i].scriptname) != scripts.end())
		{
			if(scripts[genericmap[i].scriptname].first.script_type != SCRIPT_GENERIC)
			{
				while(scripts.find(genericmap[i].scriptname) != scripts.end())
					inc_script_name(genericmap[i].scriptname);
			}
			else continue;
		}
		if(!genericmap[i].isEmpty())
		{
			if(skipDisassembled && genericmap[i].format != SCRIPT_FORMAT_ZASM
			   && (genericscripts[i+1]->meta.flags & ZMETA_IMPORTED) == 0)
			{
				genericmap[i].format = SCRIPT_FORMAT_INVALID;
				continue;
			}
			if(genericscripts[i+1]->valid())
			{
				disassembled_script_data data = disassemble_script(genericscripts[i+1]);
				if((genericscripts[i+1]->meta.flags & ZMETA_IMPORTED))
				{
					genericmap[i].format = SCRIPT_FORMAT_ZASM;
					genericmap[i].update();
				}
				else if(fromCompile || (genericscripts[i+1]->meta.flags & ZMETA_DISASSEMBLED))
				{
					genericmap[i].format = SCRIPT_FORMAT_DISASSEMBLED;
					genericmap[i].update();
				}
				data.format = genericmap[i].format;
				scripts[genericmap[i].scriptname] = data;
				asgenericscripts.push_back(data.formatName(genericmap[i].scriptname));
			}
		}
	}
}

enum script_slot_type
{
	type_ffc, type_global, type_itemdata, type_npc, type_lweapon, type_eweapon,
	type_hero, type_dmap, type_screen, type_itemsprite, type_combo, type_generic, num_types
};
script_slot_type getType(int32_t type)
{
	switch(type)
	{
		case SCRIPT_FFC: return type_ffc;
		case SCRIPT_GLOBAL: return type_global;
		case SCRIPT_ITEM: return type_itemdata;
		case SCRIPT_NPC: return type_npc;
		case SCRIPT_LWPN: return type_lweapon;
		case SCRIPT_EWPN: return type_eweapon;
		case SCRIPT_PLAYER: return type_hero;
		case SCRIPT_DMAP:
		case SCRIPT_ACTIVESUBSCREEN:
		case SCRIPT_PASSIVESUBSCREEN:
		case SCRIPT_ONMAP:
			return type_dmap;
		case SCRIPT_GENERIC: case SCRIPT_GENERIC_FROZEN:
			return type_generic;
		case SCRIPT_SCREEN: return type_screen;
		case SCRIPT_ITEMSPRITE: return type_itemsprite;
		case SCRIPT_COMBO: return type_combo;
		default: return type_ffc; //Default
	}
}
#define SLOTMSGFLAG_MISSING		0x01
#define SLOTMSGFLAG_PRESERVED	0x02
#define SLOTMSGFLAG_IMPORTED	0x04
#define SLOTMSG_SIZE			512
bool checkSkip(int32_t format, byte flags)
{
	switch(format)
	{
		case SCRIPT_FORMAT_DEFAULT:
			return (flags != 0);
		case SCRIPT_FORMAT_INVALID:
			return ((flags & SLOTMSGFLAG_MISSING)==0);
		case SCRIPT_FORMAT_DISASSEMBLED:
			return ((flags & SLOTMSGFLAG_PRESERVED)==0);
		case SCRIPT_FORMAT_ZASM:
			return ((flags & SLOTMSGFLAG_IMPORTED)==0);
		default: return true;
	}
}
void clearAllSlots(int32_t type, byte flags = 0)
{
	bound(type,0,10);
	switch(type)
	{
		case type_ffc:
		{
			for(int32_t q = 0; q < NUMSCRIPTFFC-1; ++q)
			{
				if(checkSkip(ffcmap[q].format, flags)) continue;
				ffcmap[q].scriptname = "";
				ffcmap[q].format = SCRIPT_FORMAT_DEFAULT;
			}
			break;
		}
		case type_global:
		{
			//Start at 1 to not clear Init
			for(int32_t q = 1; q < NUMSCRIPTGLOBAL; ++q)
			{
				if(checkSkip(globalmap[q].format, flags)) continue;
				globalmap[q].scriptname = "";
				globalmap[q].format = SCRIPT_FORMAT_DEFAULT;
			}
			break;
		}
		case type_itemdata:
		{
			for(int32_t q = 0; q < NUMSCRIPTITEM-1; ++q)
			{
				if(checkSkip(itemmap[q].format, flags)) continue;
				itemmap[q].scriptname = "";
				itemmap[q].format = SCRIPT_FORMAT_DEFAULT;
			}
			break;
		}
		case type_npc:
		{
			for(int32_t q = 0; q < NUMSCRIPTGUYS-1; ++q)
			{
				if(checkSkip(npcmap[q].format, flags)) continue;
				npcmap[q].scriptname = "";
				npcmap[q].format = SCRIPT_FORMAT_DEFAULT;
			}
			break;
		}
		case type_lweapon:
		{
			for(int32_t q = 0; q < NUMSCRIPTWEAPONS-1; ++q)
			{
				if(checkSkip(lwpnmap[q].format, flags)) continue;
				lwpnmap[q].scriptname = "";
				lwpnmap[q].format = SCRIPT_FORMAT_DEFAULT;
			}
			break;
		}
		case type_eweapon:
		{
			for(int32_t q = 0; q < NUMSCRIPTWEAPONS-1; ++q)
			{
				if(checkSkip(ewpnmap[q].format, flags)) continue;
				ewpnmap[q].scriptname = "";
				ewpnmap[q].format = SCRIPT_FORMAT_DEFAULT;
			}
			break;
		}
		case type_hero:
		{
			for(int32_t q = 0; q < NUMSCRIPTPLAYER-1; ++q)
			{
				if(checkSkip(playermap[q].format, flags)) continue;
				playermap[q].scriptname = "";
				playermap[q].format = SCRIPT_FORMAT_DEFAULT;
			}
			break;
		}
		case type_dmap:
		{
			for(int32_t q = 0; q < NUMSCRIPTSDMAP-1; ++q)
			{
				if(checkSkip(dmapmap[q].format, flags)) continue;
				dmapmap[q].scriptname = "";
				dmapmap[q].format = SCRIPT_FORMAT_DEFAULT;
			}
			break;
		}
		case type_screen:
		{
			for(int32_t q = 0; q < NUMSCRIPTSCREEN-1; ++q)
			{
				if(checkSkip(screenmap[q].format, flags)) continue;
				screenmap[q].scriptname = "";
				screenmap[q].format = SCRIPT_FORMAT_DEFAULT;
			}
			break;
		}
		case type_itemsprite:
		{
			for(int32_t q = 0; q < NUMSCRIPTSITEMSPRITE-1; ++q)
			{
				if(checkSkip(itemspritemap[q].format, flags)) continue;
				itemspritemap[q].scriptname = "";
				itemspritemap[q].format = SCRIPT_FORMAT_DEFAULT;
			}
			break;
		}
		case type_combo:
		{
			for(int32_t q = 0; q < NUMSCRIPTSCOMBODATA-1; ++q)
			{
				if(checkSkip(comboscriptmap[q].format, flags)) continue;
				comboscriptmap[q].scriptname = "";
				comboscriptmap[q].format = SCRIPT_FORMAT_DEFAULT;
			}
			break;
		}
		case type_generic:
		{
			for(int32_t q = 0; q < NUMSCRIPTSGENERIC-1; ++q)
			{
				if(checkSkip(genericmap[q].format, flags)) continue;
				genericmap[q].scriptname = "";
				genericmap[q].format = SCRIPT_FORMAT_DEFAULT;
			}
			break;
		}
	}
}

void setup_scriptslot_dlg(char* buf, byte flags)
{
	//{ Set up the textbox at the bottom, and auto-resize height based on it
	int32_t prev_height = assignscript_dlg[14].h;
	memset(buf, 0, SLOTMSG_SIZE);
	//
	strcpy(buf, "Slots with matching names have been updated.\n");
	if(flags & SLOTMSGFLAG_MISSING)
		strcat(buf,"Scripts prefixed with '--' were not found, and will not function.\n");
	if(flags & SLOTMSGFLAG_PRESERVED)
		strcat(buf,	"Scripts prefixed with '++' were not found, but have been preserved.\n"
		            "    These scripts may not function correctly if they use global variables.\n");
	if(flags & SLOTMSGFLAG_IMPORTED)
		strcat(buf,"Scripts prefixed with '==' are imported ZASM scripts.\n");
	strcat(buf,"Global scripts named 'Init' will be appended to '~Init'");
	//
	assignscript_dlg[14].dp = buf;
	object_message(&assignscript_dlg[14], MSG_START, 0); //Set the width/height
	if(int32_t diff = assignscript_dlg[14].h - prev_height) //resize dlg
	{
		int32_t prev_bottom = assignscript_dlg[14].y + prev_height;
		for(int32_t q = 1; assignscript_dlg[q].proc; ++q)
		{
			if(q==14) continue; //Don't change self
			if(assignscript_dlg[q].y < prev_bottom) continue; //above proc
			assignscript_dlg[q].y += diff;
		}
		assignscript_dlg[0].h += diff;
		jwin_center_dialog(assignscript_dlg);
	}
	//}
}

byte reload_scripts(map<string, disassembled_script_data> &scripts)
{
	byte slotflags = 0;
	char temp[100];
	for(int32_t i = 0; i < NUMSCRIPTFFC-1; i++)
	{
		if(ffcmap[i].isEmpty())
			sprintf(temp, "Slot %d:", i+1);
		else
		{
			sprintf(temp, "Slot %d:", i+1);
			if(ffcmap[i].isZASM())
			{
				if(ffcmap[i].isImportedZASM()) slotflags |= SLOTMSGFLAG_IMPORTED;
				else slotflags |= SLOTMSGFLAG_PRESERVED;
			}
			else if(scripts.find(ffcmap[i].scriptname) != scripts.end())
				ffcmap[i].format = SCRIPT_FORMAT_DEFAULT;
			else // Previously loaded script not found
			{
				ffcmap[i].format = SCRIPT_FORMAT_INVALID;
				slotflags |= SLOTMSGFLAG_MISSING;
			}
		}
		ffcmap[i].slotname = temp;
		ffcmap[i].update();
	}
	for(int32_t i = 0; i < NUMSCRIPTGLOBAL; i++)
	{
		switch(i)
		{
			case GLOBAL_SCRIPT_INIT:
				globalmap[i].slotname="Init:"; break;
			case GLOBAL_SCRIPT_GAME:
				globalmap[i].slotname="Active:"; break;
			case GLOBAL_SCRIPT_END:
				globalmap[i].slotname="onExit:"; break;
			case GLOBAL_SCRIPT_ONSAVELOAD:
				globalmap[i].slotname="onSaveLoad:"; break;
			case GLOBAL_SCRIPT_ONLAUNCH:
				globalmap[i].slotname="onLaunch:"; break;
			case GLOBAL_SCRIPT_ONCONTGAME:
				globalmap[i].slotname="onContGame:"; break;
			case GLOBAL_SCRIPT_F6:
				globalmap[i].slotname="onF6Menu:"; break;
			case GLOBAL_SCRIPT_ONSAVE:
				globalmap[i].slotname="onSave:"; break;
		}
		if(!globalmap[i].isEmpty())
		{
			if(globalmap[i].isZASM())
			{
				if(globalmap[i].isImportedZASM()) slotflags |= SLOTMSGFLAG_IMPORTED;
				else slotflags |= SLOTMSGFLAG_PRESERVED;
			}
			else if(scripts.find(globalmap[i].scriptname) != scripts.end() || globalmap[i].scriptname == "~Init")
				globalmap[i].format = SCRIPT_FORMAT_DEFAULT;
			else // Unloaded
			{
				globalmap[i].format = SCRIPT_FORMAT_INVALID;
				slotflags |= SLOTMSGFLAG_MISSING;
			}
		}
		globalmap[i].update();
	}
	for(int32_t i = 0; i < NUMSCRIPTITEM-1; i++)
	{
		if(itemmap[i].isEmpty())
			sprintf(temp, "Slot %d:", i+1);
		else
		{
			sprintf(temp, "Slot %d:", i+1);
			if(itemmap[i].isZASM())
			{
				if(itemmap[i].isImportedZASM()) slotflags |= SLOTMSGFLAG_IMPORTED;
				else slotflags |= SLOTMSGFLAG_PRESERVED;
			}
			else if(scripts.find(itemmap[i].scriptname) != scripts.end())
				itemmap[i].format = SCRIPT_FORMAT_DEFAULT;
			else // Previously loaded script not found
			{
				itemmap[i].format = SCRIPT_FORMAT_INVALID;
				slotflags |= SLOTMSGFLAG_MISSING;
			}
		}
		itemmap[i].slotname = temp;
		itemmap[i].update();
	}
	for(int32_t i = 0; i < NUMSCRIPTGUYS-1; i++)
	{
		if(npcmap[i].isEmpty())
			sprintf(temp, "Slot %d:", i+1);
		else
		{
			sprintf(temp, "Slot %d:", i+1);
			if(npcmap[i].isZASM())
			{
				if(npcmap[i].isImportedZASM()) slotflags |= SLOTMSGFLAG_IMPORTED;
				else slotflags |= SLOTMSGFLAG_PRESERVED;
			}
			else if(scripts.find(npcmap[i].scriptname) != scripts.end())
				npcmap[i].format = SCRIPT_FORMAT_DEFAULT;
			else // Previously loaded script not found
			{
				npcmap[i].format = SCRIPT_FORMAT_INVALID;
				slotflags |= SLOTMSGFLAG_MISSING;
			}
		}
		npcmap[i].slotname = temp;
		npcmap[i].update();
	} 
	for(int32_t i = 0; i < NUMSCRIPTWEAPONS-1; i++)
	{
		if(ewpnmap[i].isEmpty())
			sprintf(temp, "Slot %d:", i+1);
		else
		{
			sprintf(temp, "Slot %d:", i+1);
			if(ewpnmap[i].isZASM())
			{
				if(ewpnmap[i].isImportedZASM()) slotflags |= SLOTMSGFLAG_IMPORTED;
				else slotflags |= SLOTMSGFLAG_PRESERVED;
			}
			else if(scripts.find(ewpnmap[i].scriptname) != scripts.end())
				ewpnmap[i].format = SCRIPT_FORMAT_DEFAULT;
			else // Previously loaded script not found
			{
				ewpnmap[i].format = SCRIPT_FORMAT_INVALID;
				slotflags |= SLOTMSGFLAG_MISSING;
			}
		}
		ewpnmap[i].slotname = temp;
		ewpnmap[i].update();
	}
	for(int32_t i = 0; i < NUMSCRIPTWEAPONS-1; i++)
	{
		if(lwpnmap[i].isEmpty())
			sprintf(temp, "Slot %d:", i+1);
		else
		{
			sprintf(temp, "Slot %d:", i+1);
			if(lwpnmap[i].isZASM())
			{
				if(lwpnmap[i].isImportedZASM()) slotflags |= SLOTMSGFLAG_IMPORTED;
				else slotflags |= SLOTMSGFLAG_PRESERVED;
			}
			else if(scripts.find(lwpnmap[i].scriptname) != scripts.end())
				lwpnmap[i].format = SCRIPT_FORMAT_DEFAULT;
			else // Previously loaded script not found
			{
				lwpnmap[i].format = SCRIPT_FORMAT_INVALID;
				slotflags |= SLOTMSGFLAG_MISSING;
			}
		}
		lwpnmap[i].slotname = temp;
		lwpnmap[i].update();
	}
	for(int32_t i = 0; i < NUMSCRIPTPLAYER-1; i++)
	{
		switch(i)
		{
			case 0: playermap[i].slotname="Init:"; break;
			case 1: playermap[i].slotname="Active:"; break;
			case 2: playermap[i].slotname="onDeath:"; break;
			case 3: playermap[i].slotname="onWin:"; break;
		}
		if(!playermap[i].isEmpty())
		{
			if(playermap[i].isZASM())
			{
				if(playermap[i].isImportedZASM()) slotflags |= SLOTMSGFLAG_IMPORTED;
				else slotflags |= SLOTMSGFLAG_PRESERVED;
			}
			else if(scripts.find(playermap[i].scriptname) != scripts.end())
				playermap[i].format = SCRIPT_FORMAT_DEFAULT;
			else // Unloaded
			{
				playermap[i].format = SCRIPT_FORMAT_INVALID;
				slotflags |= SLOTMSGFLAG_MISSING;
			}
		}
		playermap[i].update();
	}
	for(int32_t i = 0; i < NUMSCRIPTSCREEN-1; i++)
	{
		if(screenmap[i].isEmpty())
			sprintf(temp, "Slot %d:", i+1);
		else
		{
			sprintf(temp, "Slot %d:", i+1);
			if(screenmap[i].isZASM())
			{
				if(screenmap[i].isImportedZASM()) slotflags |= SLOTMSGFLAG_IMPORTED;
				else slotflags |= SLOTMSGFLAG_PRESERVED;
			}
			else if(scripts.find(screenmap[i].scriptname) != scripts.end())
				screenmap[i].format = SCRIPT_FORMAT_DEFAULT;
			else // Previously loaded script not found
			{
				screenmap[i].format = SCRIPT_FORMAT_INVALID;
				slotflags |= SLOTMSGFLAG_MISSING;
			}
		}
		screenmap[i].slotname = temp;
		screenmap[i].update();
	}
	for(int32_t i = 0; i < NUMSCRIPTSDMAP-1; i++)
	{
		if(dmapmap[i].isEmpty())
			sprintf(temp, "Slot %d:", i+1);
		else
		{
			sprintf(temp, "Slot %d:", i+1);
			if(dmapmap[i].isZASM())
			{
				if(dmapmap[i].isImportedZASM()) slotflags |= SLOTMSGFLAG_IMPORTED;
				else slotflags |= SLOTMSGFLAG_PRESERVED;
			}
			else if(scripts.find(dmapmap[i].scriptname) != scripts.end())
				dmapmap[i].format = SCRIPT_FORMAT_DEFAULT;
			else // Previously loaded script not found
			{
				dmapmap[i].format = SCRIPT_FORMAT_INVALID;
				slotflags |= SLOTMSGFLAG_MISSING;
			}
		}
		dmapmap[i].slotname = temp;
		dmapmap[i].update();
	}
	for(int32_t i = 0; i < NUMSCRIPTSITEMSPRITE-1; i++)
	{
		if(itemspritemap[i].isEmpty())
			sprintf(temp, "Slot %d:", i+1);
		else
		{
			sprintf(temp, "Slot %d:", i+1);
			if(itemspritemap[i].isZASM())
			{
				if(itemspritemap[i].isImportedZASM()) slotflags |= SLOTMSGFLAG_IMPORTED;
				else slotflags |= SLOTMSGFLAG_PRESERVED;
			}
			else if(scripts.find(itemspritemap[i].scriptname) != scripts.end())
				itemspritemap[i].format = SCRIPT_FORMAT_DEFAULT;
			else // Previously loaded script not found
			{
				itemspritemap[i].format = SCRIPT_FORMAT_INVALID;
				slotflags |= SLOTMSGFLAG_MISSING;
			}
		}
		itemspritemap[i].slotname = temp;
		itemspritemap[i].update();
	}
	for(int32_t i = 0; i < NUMSCRIPTSCOMBODATA-1; i++)
	{
		if(comboscriptmap[i].isEmpty())
			sprintf(temp, "Slot %d:", i+1);
		else
		{
			sprintf(temp, "Slot %d:", i+1);
			if(comboscriptmap[i].isZASM())
			{
				if(comboscriptmap[i].isImportedZASM()) slotflags |= SLOTMSGFLAG_IMPORTED;
				else slotflags |= SLOTMSGFLAG_PRESERVED;
			}
			else if(scripts.find(comboscriptmap[i].scriptname) != scripts.end())
				comboscriptmap[i].format = SCRIPT_FORMAT_DEFAULT;
			else // Previously loaded script not found
			{
				comboscriptmap[i].format = SCRIPT_FORMAT_INVALID;
				slotflags |= SLOTMSGFLAG_MISSING;
			}
		}
		comboscriptmap[i].slotname = temp;
		comboscriptmap[i].update();
	}
	for(int32_t i = 0; i < NUMSCRIPTSGENERIC-1; i++)
	{
		if(genericmap[i].isEmpty())
			sprintf(temp, "Slot %d:", i+1);
		else
		{
			sprintf(temp, "Slot %d:", i+1);
			if(genericmap[i].isZASM())
			{
				if(genericmap[i].isImportedZASM()) slotflags |= SLOTMSGFLAG_IMPORTED;
				else slotflags |= SLOTMSGFLAG_PRESERVED;
			}
			else if(scripts.find(genericmap[i].scriptname) != scripts.end())
				genericmap[i].format = SCRIPT_FORMAT_DEFAULT;
			else // Previously loaded script not found
			{
				genericmap[i].format = SCRIPT_FORMAT_INVALID;
				slotflags |= SLOTMSGFLAG_MISSING;
			}
		}
		genericmap[i].slotname = temp;
		genericmap[i].update();
	}
	return slotflags;
}

void doClearSlots(byte* flags);

extern byte compile_success_sample, compile_error_sample,
	compile_finish_sample, compile_audio_volume;
bool do_slots(map<string, disassembled_script_data> &scripts)
{
	if(is_large)
		large_dialog(assignscript_dlg);
	int32_t ret = 3;
	char slots_msg[SLOTMSG_SIZE] = {0};
	byte slotflags = reload_scripts(scripts);
	setup_scriptslot_dlg(slots_msg, slotflags);
	bool retval = false;
	
    popup_zqdialog_start();
	while(true)
	{
		slotflags = reload_scripts(scripts);
        ret = do_zqdialog(assignscript_dlg, ret);
		
		FILE* tempfile = NULL;
		switch(ret)
		{
			case 0:
			case 2:
				//Cancel
				goto exit_do_slots;
				
			case 3:
			{
			
				//OK
				bool output = (assignscript_dlg[13].flags == D_SELECTED);
				clock_t start_assign_time = clock();
				for(map<int32_t, script_slot_data >::iterator it = ffcmap.begin(); it != ffcmap.end(); it++)
				{
					if(it->second.hasScriptData())
					{
						tempfile = std::tmpfile();
						
						if(!tempfile)
						{
							jwin_alert("Error","Unable to create a temporary file in current directory!",NULL,NULL,"O&K",NULL,'k',0,lfont);
							//return false;
							goto exit_do_slots;
						}
						
						scripts[it->second.scriptname].write(tempfile, output);
						
						fseek(tempfile, 0, SEEK_SET);
						parse_script_file(&ffscripts[it->first+1],tempfile,false);
						fclose(tempfile);
						if(it->second.isDisassembled()) ffscripts[it->first+1]->meta.setFlag(ZMETA_DISASSEMBLED);
						else if(it->second.isImportedZASM()) ffscripts[it->first+1]->meta.setFlag(ZMETA_IMPORTED);
					}
					else if(ffscripts[it->first+1])
					{
						delete ffscripts[it->first+1];
						ffscripts[it->first+1] = new script_data();
					}
				}
				
				for(map<int32_t, script_slot_data >::iterator it = globalmap.begin(); it != globalmap.end(); it++)
				{
					if(it->second.hasScriptData())
					{
						tempfile = std::tmpfile();
						
						if(!tempfile)
						{
							jwin_alert("Error","Unable to create a temporary file in current directory!",NULL,NULL,"O&K",NULL,'k',0,lfont);
							//return false;
							goto exit_do_slots;
						}
						
						scripts[it->second.scriptname].write(tempfile, output);
						
						fseek(tempfile, 0, SEEK_SET);
						parse_script_file(&globalscripts[it->first],tempfile,false);
						fclose(tempfile);
						if(it->second.isDisassembled()) globalscripts[it->first]->meta.setFlag(ZMETA_DISASSEMBLED);
						else if(it->second.isImportedZASM()) globalscripts[it->first]->meta.setFlag(ZMETA_IMPORTED);
					}
					else if(globalscripts[it->first])
					{
						delete globalscripts[it->first];
						globalscripts[it->first] = new script_data();
					}
				}
				
				for(map<int32_t, script_slot_data >::iterator it = itemmap.begin(); it != itemmap.end(); it++)
				{
					if(it->second.hasScriptData())
					{
						tempfile = std::tmpfile();
						
						if(!tempfile)
						{
							jwin_alert("Error","Unable to create a temporary file in current directory!",NULL,NULL,"O&K",NULL,'k',0,lfont);
							//return false;
							goto exit_do_slots;
						}
						
						scripts[it->second.scriptname].write(tempfile, output);
						
						fseek(tempfile, 0, SEEK_SET);
						parse_script_file(&itemscripts[it->first+1],tempfile,false);
						fclose(tempfile);
						if(it->second.isDisassembled()) itemscripts[it->first+1]->meta.setFlag(ZMETA_DISASSEMBLED);
						else if(it->second.isImportedZASM()) itemscripts[it->first+1]->meta.setFlag(ZMETA_IMPORTED);
					}
					else if(itemscripts[it->first+1])
					{
						delete itemscripts[it->first+1];
						itemscripts[it->first+1] = new script_data();
					}
				}
				for(map<int32_t, script_slot_data >::iterator it = npcmap.begin(); it != npcmap.end(); it++)
				{
					if(it->second.hasScriptData())
					{
						tempfile = std::tmpfile();
						
						if(!tempfile)
						{
							jwin_alert("Error","Unable to create a temporary file in current directory!",NULL,NULL,"O&K",NULL,'k',0,lfont);
							//return false;
							goto exit_do_slots;
						}
						
						scripts[it->second.scriptname].write(tempfile, output);
						
						fseek(tempfile, 0, SEEK_SET);
						parse_script_file(&guyscripts[it->first+1],tempfile,false);
						fclose(tempfile);
						if(it->second.isDisassembled()) guyscripts[it->first+1]->meta.setFlag(ZMETA_DISASSEMBLED);
						else if(it->second.isImportedZASM()) guyscripts[it->first+1]->meta.setFlag(ZMETA_IMPORTED);
					}
					else if(guyscripts[it->first+1])
					{
						delete guyscripts[it->first+1];
						guyscripts[it->first+1] = new script_data();
					}
				}
				for(map<int32_t, script_slot_data >::iterator it = lwpnmap.begin(); it != lwpnmap.end(); it++)
				{
					if(it->second.hasScriptData())
					{
						tempfile = std::tmpfile();
						
						if(!tempfile)
						{
							jwin_alert("Error","Unable to create a temporary file in current directory!",NULL,NULL,"O&K",NULL,'k',0,lfont);
							//return false;
							goto exit_do_slots;
						}
						
						scripts[it->second.scriptname].write(tempfile, output);
						
						fseek(tempfile, 0, SEEK_SET);
						parse_script_file(&lwpnscripts[it->first+1],tempfile,false);
						fclose(tempfile);
						if(it->second.isDisassembled()) lwpnscripts[it->first+1]->meta.setFlag(ZMETA_DISASSEMBLED);
						else if(it->second.isImportedZASM()) lwpnscripts[it->first+1]->meta.setFlag(ZMETA_IMPORTED);
					}
					else if(lwpnscripts[it->first+1])
					{
						delete lwpnscripts[it->first+1];
						lwpnscripts[it->first+1] = new script_data();
					}
				}
				for(map<int32_t, script_slot_data >::iterator it = ewpnmap.begin(); it != ewpnmap.end(); it++)
				{
					if(it->second.hasScriptData())
					{
						tempfile = std::tmpfile();
						
						if(!tempfile)
						{
							jwin_alert("Error","Unable to create a temporary file in current directory!",NULL,NULL,"O&K",NULL,'k',0,lfont);
							//return false;
							goto exit_do_slots;
						}
						
						scripts[it->second.scriptname].write(tempfile, output);
						
						fseek(tempfile, 0, SEEK_SET);
						parse_script_file(&ewpnscripts[it->first+1],tempfile,false);
						fclose(tempfile);
						if(it->second.isDisassembled()) ewpnscripts[it->first+1]->meta.setFlag(ZMETA_DISASSEMBLED);
						else if(it->second.isImportedZASM()) ewpnscripts[it->first+1]->meta.setFlag(ZMETA_IMPORTED);
					}
					else if(ewpnscripts[it->first+1])
					{
						delete ewpnscripts[it->first+1];
						ewpnscripts[it->first+1] = new script_data();
					}
				}
				for(map<int32_t, script_slot_data >::iterator it = playermap.begin(); it != playermap.end(); it++)
				{
					if(it->second.hasScriptData())
					{
						tempfile = std::tmpfile();
						
						if(!tempfile)
						{
							jwin_alert("Error","Unable to create a temporary file in current directory!",NULL,NULL,"O&K",NULL,'k',0,lfont);
							//return false;
							goto exit_do_slots;
						}
						
						scripts[it->second.scriptname].write(tempfile, output);
						
						fseek(tempfile, 0, SEEK_SET);
						parse_script_file(&playerscripts[it->first+1],tempfile,false);
						fclose(tempfile);
						if(it->second.isDisassembled()) playerscripts[it->first+1]->meta.setFlag(ZMETA_DISASSEMBLED);
						else if(it->second.isImportedZASM()) playerscripts[it->first+1]->meta.setFlag(ZMETA_IMPORTED);
					}
					else if(playerscripts[it->first+1])
					{
						delete playerscripts[it->first+1];
						playerscripts[it->first+1] = new script_data();
					}
				}
				for(map<int32_t, script_slot_data >::iterator it = dmapmap.begin(); it != dmapmap.end(); it++)
				{
					if(it->second.hasScriptData())
					{
						tempfile = std::tmpfile();
						
						if(!tempfile)
						{
							jwin_alert("Error","Unable to create a temporary file in current directory!",NULL,NULL,"O&K",NULL,'k',0,lfont);
							//return false;
							goto exit_do_slots;
						}
						
						scripts[it->second.scriptname].write(tempfile, output);
						
						fseek(tempfile, 0, SEEK_SET);
						parse_script_file(&dmapscripts[it->first+1],tempfile,false);
						fclose(tempfile);
						if(it->second.isDisassembled()) dmapscripts[it->first+1]->meta.setFlag(ZMETA_DISASSEMBLED);
						else if(it->second.isImportedZASM()) dmapscripts[it->first+1]->meta.setFlag(ZMETA_IMPORTED);
					}
					else if(dmapscripts[it->first+1])
					{
						delete dmapscripts[it->first+1];
						dmapscripts[it->first+1] = new script_data();
					}
				}
				for(map<int32_t, script_slot_data >::iterator it = screenmap.begin(); it != screenmap.end(); it++)
				{
					if(it->second.hasScriptData())
					{
						tempfile = std::tmpfile();
						
						if(!tempfile)
						{
							jwin_alert("Error","Unable to create a temporary file in current directory!",NULL,NULL,"O&K",NULL,'k',0,lfont);
							//return false;
							goto exit_do_slots;
						}
						
						scripts[it->second.scriptname].write(tempfile, output);
						
						fseek(tempfile, 0, SEEK_SET);
						parse_script_file(&screenscripts[it->first+1],tempfile,false);
						fclose(tempfile);
						if(it->second.isDisassembled()) screenscripts[it->first+1]->meta.setFlag(ZMETA_DISASSEMBLED);
						else if(it->second.isImportedZASM()) screenscripts[it->first+1]->meta.setFlag(ZMETA_IMPORTED);
					}
					else if(screenscripts[it->first+1])
					{
						delete screenscripts[it->first+1];
						screenscripts[it->first+1] = new script_data();
					}
				}
				for(map<int32_t, script_slot_data >::iterator it = itemspritemap.begin(); it != itemspritemap.end(); it++)
				{
					if(it->second.hasScriptData())
					{
						tempfile = std::tmpfile();
						
						if(!tempfile)
						{
							jwin_alert("Error","Unable to create a temporary file in current directory!",NULL,NULL,"O&K",NULL,'k',0,lfont);
							//return false;
							goto exit_do_slots;
						}
						
						scripts[it->second.scriptname].write(tempfile, output);
						
						fseek(tempfile, 0, SEEK_SET);
						parse_script_file(&itemspritescripts[it->first+1],tempfile,false);
						fclose(tempfile);
						if(it->second.isDisassembled()) itemspritescripts[it->first+1]->meta.setFlag(ZMETA_DISASSEMBLED);
						else if(it->second.isImportedZASM()) itemspritescripts[it->first+1]->meta.setFlag(ZMETA_IMPORTED);
					}
					else if(itemspritescripts[it->first+1])
					{
						delete itemspritescripts[it->first+1];
						itemspritescripts[it->first+1] = new script_data();
					}
				}
				
				for(map<int32_t, script_slot_data >::iterator it = comboscriptmap.begin(); it != comboscriptmap.end(); it++)
				{
					if(it->second.hasScriptData())
					{
						tempfile = std::tmpfile();
						
						if(!tempfile)
						{
							jwin_alert("Error","Unable to create a temporary file in current directory!",NULL,NULL,"O&K",NULL,'k',0,lfont);
							//return false;
							goto exit_do_slots;
						}
						
						scripts[it->second.scriptname].write(tempfile, output);
						
						fseek(tempfile, 0, SEEK_SET);
						parse_script_file(&comboscripts[it->first+1],tempfile,false);
						fclose(tempfile);
						if(it->second.isDisassembled()) comboscripts[it->first+1]->meta.setFlag(ZMETA_DISASSEMBLED);
						else if(it->second.isImportedZASM()) comboscripts[it->first+1]->meta.setFlag(ZMETA_IMPORTED);
					}
					else if(comboscripts[it->first+1])
					{
						delete comboscripts[it->first+1];
						comboscripts[it->first+1] = new script_data();
					}
				}
				for(auto it = genericmap.begin(); it != genericmap.end(); it++)
				{
					if(it->second.hasScriptData())
					{
						tempfile = std::tmpfile();
						
						if(!tempfile)
						{
							jwin_alert("Error","Unable to create a temporary file in current directory!",NULL,NULL,"O&K",NULL,'k',0,lfont);
							//return false;
							goto exit_do_slots;
						}
						
						scripts[it->second.scriptname].write(tempfile, output);
						
						fseek(tempfile, 0, SEEK_SET);
						parse_script_file(&genericscripts[it->first+1],tempfile,false);
						fclose(tempfile);
						if(it->second.isDisassembled()) genericscripts[it->first+1]->meta.setFlag(ZMETA_DISASSEMBLED);
						else if(it->second.isImportedZASM()) genericscripts[it->first+1]->meta.setFlag(ZMETA_IMPORTED);
					}
					else if(genericscripts[it->first+1])
					{
						delete genericscripts[it->first+1];
						genericscripts[it->first+1] = new script_data();
					}
				}

				clock_t end_assign_time = clock();
				al_trace("Assign Slots took %lf seconds (%ld cycles)\n", (end_assign_time-start_assign_time)/(double)CLOCKS_PER_SEC,(long)end_assign_time-start_assign_time);
				char buf[256] = {0};
				sprintf(buf, "ZScripts successfully loaded into script slots"
					"\nAssign Slots took %lf seconds (%ld cycles)", (end_assign_time-start_assign_time)/(double)CLOCKS_PER_SEC,(long)end_assign_time-start_assign_time);
				//al_trace("Module SFX datafile is %s \n",moduledata.datafiles[sfx_dat]);
				compile_finish_sample = vbound(zc_get_config("Compiler","compile_finish_sample",34),0,255);
				compile_audio_volume = vbound(zc_get_config("Compiler","compile_audio_volume",200),0,255);
				if ( compile_finish_sample > 0 )
				{
					if(sfxdat)
					sfx_voice[compile_finish_sample]=allocate_voice((SAMPLE*)sfxdata[compile_finish_sample].dat);
					else sfx_voice[compile_finish_sample]=allocate_voice(&customsfxdata[compile_finish_sample]);
					voice_set_volume(sfx_voice[compile_finish_sample], compile_audio_volume);
					//zc_set_volume(255,-1);
					//kill_sfx();
					voice_start(sfx_voice[compile_finish_sample]);
				}
				InfoDialog("Slots Assigned",buf).show();
				if ( compile_finish_sample > 0 )
				{
					if(sfx_voice[compile_finish_sample]!=-1)
					{
						deallocate_voice(sfx_voice[compile_finish_sample]);
						sfx_voice[compile_finish_sample]=-1;
					}
				}
				build_biffs_list();
				build_biitems_list();
				retval = true;
				goto exit_do_slots;
			}
			
			case 6:
				//<<, FFC
			{
				int32_t lind = assignscript_dlg[4].d1;
				int32_t rind = assignscript_dlg[5].d1;
				
				if(lind < 0 || rind < 0)
					break;
					
				if(asffcscripts[rind] == "<none>")
				{
					ffcmap[lind].scriptname = "";
					ffcmap[lind].format = SCRIPT_FORMAT_DEFAULT;
				}
				else
				{
					ffcmap[lind].updateName(asffcscripts[rind]);
					ffcmap[lind].format = scripts[ffcmap[lind].scriptname].format;
				}
				
				break;
			}
			case 9:
				//<<, Global
			{
				int32_t lind = assignscript_dlg[7].d1;
				int32_t rind = assignscript_dlg[8].d1;
				
				if(lind < 0 || rind < 0)
					break;
					
				if(lind == 0)
				{
					jwin_alert("Error","ZScript reserves this slot.",NULL,NULL,"O&K",NULL,'k',0,lfont);
					break;
				}
				
				if(asglobalscripts[rind] == "<none>")
				{
					globalmap[lind].scriptname = "";
					globalmap[lind].format = SCRIPT_FORMAT_DEFAULT;
				}
				else
				{
					globalmap[lind].updateName(asglobalscripts[rind]);
					globalmap[lind].format = scripts[globalmap[lind].scriptname].format;
				}
				
				break;
			}				
			case 12:
				//<<, ITEM
			{
				int32_t lind = assignscript_dlg[10].d1;
				int32_t rind = assignscript_dlg[11].d1;
				
				if(lind < 0 || rind < 0)
					break;
				
				if(asitemscripts[rind] == "<none>")
				{
					itemmap[lind].scriptname = "";
					itemmap[lind].format = SCRIPT_FORMAT_DEFAULT;
				}
				else
				{
					itemmap[lind].updateName(asitemscripts[rind]);
					itemmap[lind].format = scripts[itemmap[lind].scriptname].format;
				}
				
				break;
			}
			case 20:
				//<<, NPC
			{
				int32_t lind = assignscript_dlg[18].d1;
				int32_t rind = assignscript_dlg[19].d1;
				
				if(lind < 0 || rind < 0)
					break;
				
				if(asnpcscripts[rind] == "<none>")
				{
					npcmap[lind].scriptname = "";
					npcmap[lind].format = SCRIPT_FORMAT_DEFAULT;
				}
				else
				{
					npcmap[lind].updateName(asnpcscripts[rind]);
					npcmap[lind].format = scripts[npcmap[lind].scriptname].format;
				}
				
				break;
			}
			case 23:
				//<<, LWeapon
			{
				int32_t lind = assignscript_dlg[21].d1;
				int32_t rind = assignscript_dlg[22].d1;
				
				if(lind < 0 || rind < 0)
					break;
				
				if(aslweaponscripts[rind] == "<none>")
				{
					lwpnmap[lind].scriptname = "";
					lwpnmap[lind].format = SCRIPT_FORMAT_DEFAULT;
				}
				else
				{
					lwpnmap[lind].updateName(aslweaponscripts[rind]);
					lwpnmap[lind].format = scripts[lwpnmap[lind].scriptname].format;
				}
				
				break;
			}
			case 26:
				//<<, EWeapon
			{
				int32_t lind = assignscript_dlg[24].d1;
				int32_t rind = assignscript_dlg[25].d1;
				
				if(lind < 0 || rind < 0)
					break;
					
				if(aseweaponscripts[rind] == "<none>")
				{
					ewpnmap[lind].scriptname = "";
					ewpnmap[lind].format = SCRIPT_FORMAT_DEFAULT;
				}
				else
				{
					ewpnmap[lind].updateName(aseweaponscripts[rind]);
					ewpnmap[lind].format = scripts[ewpnmap[lind].scriptname].format;
				}
				
				break;
			}
			case 29:
				//<<, Player
			{
				int32_t lind = assignscript_dlg[27].d1;
				int32_t rind = assignscript_dlg[28].d1;
				
				if(lind < 0 || rind < 0)
					break;
				
				if(asplayerscripts[rind] == "<none>")
				{
					playermap[lind].scriptname = "";
					playermap[lind].format = SCRIPT_FORMAT_DEFAULT;
				}
				else
				{
					playermap[lind].updateName(asplayerscripts[rind]);
					playermap[lind].format = scripts[playermap[lind].scriptname].format;
				}
				
				break;
			}
			case 32:
				//<<, Screendata
			{
				int32_t lind = assignscript_dlg[30].d1;
				int32_t rind = assignscript_dlg[31].d1;
				
				if(lind < 0 || rind < 0)
					break;
				
				if(asscreenscripts[rind] == "<none>")
				{
					screenmap[lind].scriptname = "";
					screenmap[lind].format = SCRIPT_FORMAT_DEFAULT;
				}
				else
				{
					screenmap[lind].updateName(asscreenscripts[rind]);
					screenmap[lind].format = scripts[screenmap[lind].scriptname].format;
				}
				
				break;
			}
			case 35:
				//<<, dmapdata
			{
				int32_t lind = assignscript_dlg[33].d1;
				int32_t rind = assignscript_dlg[34].d1;
				
				if(lind < 0 || rind < 0)
					break;
					
				if(asdmapscripts[rind] == "<none>")
				{
					dmapmap[lind].scriptname = "";
					dmapmap[lind].format = SCRIPT_FORMAT_DEFAULT;
				}
				else
				{
					dmapmap[lind].updateName(asdmapscripts[rind]);
					dmapmap[lind].format = scripts[dmapmap[lind].scriptname].format;
				}
				
				break;
			}
			case 38:
				//<<, itemsprite
			{
				int32_t lind = assignscript_dlg[36].d1;
				int32_t rind = assignscript_dlg[37].d1;
				
				if(lind < 0 || rind < 0)
					break;
					
				if(asitemspritescripts[rind] == "<none>")
				{
					itemspritemap[lind].scriptname = "";
					itemspritemap[lind].format = SCRIPT_FORMAT_DEFAULT;
				}
				else
				{
					itemspritemap[lind].updateName(asitemspritescripts[rind]);
					itemspritemap[lind].format = scripts[itemspritemap[lind].scriptname].format;
				}
				
				break;
			}
			case 41:
				//<<, comboscript
			{
				int32_t lind = assignscript_dlg[39].d1;
				int32_t rind = assignscript_dlg[40].d1;
				
				if(lind < 0 || rind < 0)
					break;
				
				if(ascomboscripts[rind] == "<none>")
				{
					comboscriptmap[lind].scriptname = "";
					comboscriptmap[lind].format = SCRIPT_FORMAT_DEFAULT;
				}
				else
				{
					comboscriptmap[lind].updateName(ascomboscripts[rind]);
					comboscriptmap[lind].format = scripts[comboscriptmap[lind].scriptname].format;
				}
				
				break;
			}
			case 47:
				//<<, generic script
			{
				int32_t lind = assignscript_dlg[45].d1;
				int32_t rind = assignscript_dlg[46].d1;
				
				if(lind < 0 || rind < 0)
					break;
				
				if(asgenericscripts[rind] == "<none>")
				{
					genericmap[lind].scriptname = "";
					genericmap[lind].format = SCRIPT_FORMAT_DEFAULT;
				}
				else
				{
					genericmap[lind].updateName(asgenericscripts[rind]);
					genericmap[lind].format = scripts[genericmap[lind].scriptname].format;
				}
				
				break;
			}
		
			case 42:
				//Script Info, information
			{
				zasm_meta* target = NULL;
				switch(get_selected_tab((TABPANEL*)assignscript_dlg[1].dp))
				{
					default:
					case 0: //FFC
					{
						int32_t id = assignscript_dlg[4].d1;
						if(id > -1 && ffcmap[id].hasScriptData())
						{
							target = &(scripts[ffcmap[id].scriptname].first);
						}
						break;
					}
					case 1: //Global
					{
						int32_t id = assignscript_dlg[7].d1;
						if(id > -1 && globalmap[id].hasScriptData())
						{
							target = &(scripts[globalmap[id].scriptname].first);
						}
						break;
					}
					case 2: //Item
					{
						int32_t id = assignscript_dlg[10].d1;
						if(id > -1 && itemmap[id].hasScriptData())
						{
							target = &(scripts[itemmap[id].scriptname].first);
						}
						break;
					}
					case 3: //npc
					{
						int32_t id = assignscript_dlg[19].d1;
						if(id > -1 && npcmap[id].hasScriptData())
						{
							target = &(scripts[npcmap[id].scriptname].first);
						}
						break;
					}
					case 4: //lweapon
					{
						int32_t id = assignscript_dlg[21].d1;
						if(id > -1 && lwpnmap[id].hasScriptData())
						{
							target = &(scripts[lwpnmap[id].scriptname].first);
						}
						break;
					}
					case 5: //eweapon
					{
						int32_t id = assignscript_dlg[24].d1;
						if(id > -1 && ewpnmap[id].hasScriptData())
						{
							target = &(scripts[ewpnmap[id].scriptname].first);
						}
						break;
					}
					case 6: //hero
					{
						int32_t id = assignscript_dlg[27].d1;
						if(id > -1 && playermap[id].hasScriptData())
						{
							target = &(scripts[playermap[id].scriptname].first);
						}
						break;
					}
					case 7: //dmap
					{
						int32_t id = assignscript_dlg[33].d1;
						if(id > -1 && dmapmap[id].hasScriptData())
						{
							target = &(scripts[dmapmap[id].scriptname].first);
						}
						break;
					}
					case 8: //screen
					{
						int32_t id = assignscript_dlg[30].d1;
						if(id > -1 && screenmap[id].hasScriptData())
						{
							target = &(scripts[screenmap[id].scriptname].first);
						}
						break;
					}
					case 9: //itemsprite
					{
						int32_t id = assignscript_dlg[36].d1;
						if(id > -1 && itemspritemap[id].hasScriptData())
						{
							target = &(scripts[itemspritemap[id].scriptname].first);
						}
						break;
					}
					case 10: //combo
					{
						int32_t id = assignscript_dlg[39].d1;
						if(id > -1 && comboscriptmap[id].hasScriptData())
						{
							target = &(scripts[comboscriptmap[id].scriptname].first);
						}
						break;
					}
					case 11: //Generic
					{
						int32_t id = assignscript_dlg[45].d1;
						if(id > -1 && genericmap[id].hasScriptData())
						{
							target = &(scripts[genericmap[id].scriptname].first);
						}
						break;
					}
				}
				if(target)
					showScriptInfo(target);
				break;
			}
		
			case 43:
				//Script Info, information
			{
				zasm_meta* target = NULL;
				switch(get_selected_tab((TABPANEL*)assignscript_dlg[1].dp))
				{
					default:
					case 0: //FFC
					{
						int32_t id = assignscript_dlg[5].d1;
						if(id < 0 || asffcscripts[id] == "<none>" || asffcscripts[id].at(0) == '-') break;
						target = &(scripts[asffcscripts[id]].first);
						break;
					}
					case 1: //Global
					{
						int32_t id = assignscript_dlg[8].d1;
						if(id < 0 || asglobalscripts[id] == "<none>" || asglobalscripts[id].at(0) == '-') break;
						target = &(scripts[asglobalscripts[id]].first);
						break;
					}
					case 2: //Item
					{
						int32_t id = assignscript_dlg[11].d1;
						if(id < 0 || asitemscripts[id] == "<none>" || asitemscripts[id].at(0) == '-') break;
						target = &(scripts[asitemscripts[id]].first);
						break;
					}
					case 3: //npc
					{
						int32_t id = assignscript_dlg[20].d1;
						if(id < 0 || asnpcscripts[id] == "<none>" || asnpcscripts[id].at(0) == '-') break;
						target = &(scripts[asnpcscripts[id]].first);
						break;
					}
					case 4: //lweapon
					{
						int32_t id = assignscript_dlg[22].d1;
						if(id < 0 || aslweaponscripts[id] == "<none>" || aslweaponscripts[id].at(0) == '-') break;
						target = &(scripts[aslweaponscripts[id]].first);
						break;
					}
					case 5: //eweapon
					{
						int32_t id = assignscript_dlg[25].d1;
						if(id < 0 || aseweaponscripts[id] == "<none>" || aseweaponscripts[id].at(0) == '-') break;
						target = &(scripts[aseweaponscripts[id]].first);
						break;
					}
					case 6: //hero
					{
						int32_t id = assignscript_dlg[28].d1;
						if(id < 0 || asplayerscripts[id] == "<none>" || asplayerscripts[id].at(0) == '-') break;
						target = &(scripts[asplayerscripts[id]].first);
						break;
					}
					case 7: //dmap
					{
						int32_t id = assignscript_dlg[34].d1;
						if(id < 0 || asdmapscripts[id] == "<none>" || asdmapscripts[id].at(0) == '-') break;
						target = &(scripts[asdmapscripts[id]].first);
						break;
					}
					case 8: //screen
					{
						int32_t id = assignscript_dlg[31].d1;
						if(id < 0 || asscreenscripts[id] == "<none>" || asscreenscripts[id].at(0) == '-') break;
						target = &(scripts[asscreenscripts[id]].first);
						break;
					}
					case 9: //itemsprite
					{
						int32_t id = assignscript_dlg[37].d1;
						if(id < 0 || asitemspritescripts[id] == "<none>" || asitemspritescripts[id].at(0) == '-') break;
						target = &(scripts[asitemspritescripts[id]].first);
						break;
					}
					case 10: //combo
					{
						int32_t id = assignscript_dlg[40].d1;
						if(id < 0 || ascomboscripts[id] == "<none>" || ascomboscripts[id].at(0) == '-') break;
						target = &(scripts[ascomboscripts[id]].first);
						break;
					}
					case 11: //generic
					{
						int32_t id = assignscript_dlg[46].d1;
						if(id < 0 || asgenericscripts[id] == "<none>" || asgenericscripts[id].at(0) == '-') break;
						target = &(scripts[asgenericscripts[id]].first);
						break;
					}
				}
				if(target)
					showScriptInfo(target);
				break;
			}
			
			case 44:
				//Clear, clear slots of current type- after a confirmation.
			{
				doClearSlots(&slotflags);
				break;
			}
		}
	}

exit_do_slots:
    popup_zqdialog_end();
	return retval;
}

static char slottype_str_buf[32];

const char *slottype_list(int32_t index, int32_t *list_size)
{
	if(index >= 0)
	{
		bound(index,0,num_types-1);
        
		switch(index)
		{
			case type_ffc:
				strcpy(slottype_str_buf, "FFC");
				break;
			case type_global:
				strcpy(slottype_str_buf, "Global");
				break;
			case type_itemdata:
				strcpy(slottype_str_buf, "Item");
				break;
			case type_npc:
				strcpy(slottype_str_buf, "NPC");
				break;
			case type_lweapon:
				strcpy(slottype_str_buf, "LWeapon");
				break;
			case type_eweapon:
				strcpy(slottype_str_buf, "EWeapon");
				break;
			case type_hero:
				strcpy(slottype_str_buf, "Hero");
				break;
			case type_dmap:
				strcpy(slottype_str_buf, "DMap");
				break;
			case type_screen:
				strcpy(slottype_str_buf, "Screen");
				break;
			case type_itemsprite:
				strcpy(slottype_str_buf, "ItemSprite");
				break;
			case type_combo:
				strcpy(slottype_str_buf, "Combo");
				break;
			case type_generic:
				strcpy(slottype_str_buf, "Generic");
				break;
		}
        
        return slottype_str_buf;
	}
	*list_size = 11;
	return NULL;
}
static ListData slottype_sel_list(slottype_list, &font);

static DIALOG clearslots_dlg[] =
{
    { jwin_win_proc,        0,       0,       200,  159,    vc(14),             vc(1),              0,   D_EXIT,     0,  0, (void *) "Clear Slots", NULL, NULL },
    { jwin_button_proc,     35,      132,     61,   21,     vc(14),             vc(1),              13,  D_EXIT,     0,  0, (void *) "Confirm", NULL, NULL },
    { jwin_button_proc,     104,     132,     61,   21,     vc(14),             vc(1),              27,  D_EXIT,     0,  0, (void *) "Cancel", NULL, NULL },
    { jwin_droplist_proc,   50,      28+16,   70,   16,     jwin_pal[jcTEXTFG], jwin_pal[jcTEXTBG], 0,   0,          0,  0, (void *) &slottype_sel_list, NULL, NULL },
	{ jwin_radio_proc,      40,      34+00,   81,   9,      vc(14),             vc(1),              0,   D_SELECTED, 0,  0, (void *) "Clear Script Type:", NULL, NULL },
	{ jwin_radio_proc,      40,      34+32,   81,   9,      vc(14),             vc(1),              0,   0,          0,  0, (void *) "Clear Missing (--) Slots", NULL, NULL },
	{ jwin_radio_proc,      40,      34+48,   81,   9,      vc(14),             vc(1),              0,   0,          0,  0, (void *) "Clear Preserved (++) Slots", NULL, NULL },
	{ jwin_radio_proc,      40,      34+64,   81,   9,      vc(14),             vc(1),              0,   0,          0,  0, (void *) "Clear Imported (==) Slots", NULL, NULL },
	{ jwin_radio_proc,      40,      34+80,   81,   9,      vc(14),             vc(1),              0,   0,          0,  0, (void *) "Clear All", NULL, NULL },
    { d_timer_proc,         0,       0,       0,    0,      0,                  0,                  0,   0,          0,  0, NULL, NULL, NULL },
    { NULL,                 0,       0,       0,    0,      0,                  0,                  0,   0,          0,  0, NULL, NULL, NULL }
};

void doClearSlots(byte* flags)
{
	//{ Setup
	clearslots_dlg[0].dp2=lfont;
	clearslots_dlg[3].d1 = get_selected_tab((TABPANEL*)assignscript_dlg[1].dp); //Default to current tab's type
	clearslots_dlg[4].flags |= D_SELECTED;
	clearslots_dlg[5].flags &= ~D_SELECTED;
	clearslots_dlg[6].flags &= ~D_SELECTED;
	clearslots_dlg[7].flags &= ~D_SELECTED;
	clearslots_dlg[8].flags &= ~D_SELECTED;
	if(((*flags) & SLOTMSGFLAG_MISSING) == 0)
		clearslots_dlg[5].flags |= D_DISABLED;
	else
		clearslots_dlg[5].flags &= ~D_DISABLED;
	if(((*flags) & SLOTMSGFLAG_PRESERVED) == 0)
		clearslots_dlg[6].flags |= D_DISABLED;
	else
		clearslots_dlg[6].flags &= ~D_DISABLED;
	if(((*flags) & SLOTMSGFLAG_IMPORTED) == 0)
		clearslots_dlg[7].flags |= D_DISABLED;
	else
		clearslots_dlg[7].flags &= ~D_DISABLED;
	//}
	
	if(is_large)
		large_dialog(clearslots_dlg);
	
	if(zc_popup_dialog(clearslots_dlg,2)==1)
	{
		int32_t q = 3;
		while((clearslots_dlg[++q].flags & D_SELECTED) == 0);
		switch(q)
		{
			case 4: //Clear type
			{
				clearAllSlots(clearslots_dlg[3].d1);
				break;
			}
			case 5: //Clear Missing
			{
				for(int32_t q = 0; q <= 10; ++q)
					clearAllSlots(q,SLOTMSGFLAG_MISSING);
				break;
			}
			case 6: //Clear Preserved
			{
				for(int32_t q = 0; q <= 10; ++q)
					clearAllSlots(q,SLOTMSGFLAG_PRESERVED);
				break;
			}
			case 7: //Clear Imported ZASM
			{
				for(int32_t q = 0; q <= 10; ++q)
					clearAllSlots(q,SLOTMSGFLAG_IMPORTED);
				break;
			}
			case 8: //Clear ALL
			{
				for(int32_t q = 0; q <= 10; ++q)
					clearAllSlots(q);
				break;
			}
		}
	}
}

static DIALOG exportzasm_dlg[] =
{
    { jwin_win_proc,        0,       0,       200,  159,    vc(14),             vc(1),              0,   D_EXIT,     0,  0, (void *) "Export ZASM", NULL, NULL },
    { jwin_button_proc,     35,      132,     61,   21,     vc(14),             vc(1),              13,  D_EXIT,     0,  0, (void *) "Confirm", NULL, NULL },
    { jwin_button_proc,     104,     132,     61,   21,     vc(14),             vc(1),              27,  D_EXIT,     0,  0, (void *) "Cancel", NULL, NULL },
    { jwin_droplist_proc,   50,      28+16,   100,  16,     jwin_pal[jcTEXTFG], jwin_pal[jcTEXTBG], 0,   D_EXIT,     0,  0, (void *) &slottype_sel_list, NULL, NULL },
    { jwin_droplist_proc,   50,      28+48,   100,  16,     jwin_pal[jcTEXTFG], jwin_pal[jcTEXTBG], 0,   0,          0,  0, NULL, NULL, NULL },
    { jwin_text_proc,       50,      28+8,    16,   8,      vc(11),             vc(1),              0,   0,          0,  0, (void *) "Script Type:", NULL, NULL },
    { jwin_text_proc,       50,      28+40,   16,   8,      vc(11),             vc(1),              0,   0,          0,  0, (void *) "Script Slot:", NULL, NULL },
    { NULL,                 0,       0,       0,    0,      0,                  0,                  0,   0,          0,  0, NULL, NULL, NULL }
};

static DIALOG importzasm_dlg[] =
{
    { jwin_win_proc,        0,       0,       200,  159,    vc(14),             vc(1),              0,   D_EXIT,     0,  0, (void *) "Import ZASM", NULL, NULL },
    { jwin_button_proc,     35,      132,     61,   21,     vc(14),             vc(1),              13,  D_EXIT,     0,  0, (void *) "Confirm", NULL, NULL },
    { jwin_button_proc,     104,     132,     61,   21,     vc(14),             vc(1),              27,  D_EXIT,     0,  0, (void *) "Cancel", NULL, NULL },
    { jwin_droplist_proc,   50,      28+16,   100,  16,     jwin_pal[jcTEXTFG], jwin_pal[jcTEXTBG], 0,   D_EXIT,     0,  0, (void *) &slottype_sel_list, NULL, NULL },
    { jwin_droplist_proc,   50,      28+48,   100,  16,     jwin_pal[jcTEXTFG], jwin_pal[jcTEXTBG], 0,   0,          0,  0, NULL, NULL, NULL },
    // 5
	{ jwin_text_proc,       50,      28+8,    16,   8,      vc(11),             vc(1),              0,   0,          0,  0, (void *) "Script Type:", NULL, NULL },
    { jwin_text_proc,       50,      28+40,   16,   8,      vc(11),             vc(1),              0,   0,          0,  0, (void *) "Script Slot:", NULL, NULL },
    { jwin_text_proc,       50,      28+72,   16,   8,      vc(11),             vc(1),              0,   0,          0,  0, (void *) "Script Name:", NULL, NULL },
	{ jwin_edit_proc,       50,      28+80,   100,  16,     jwin_pal[jcTEXTFG], jwin_pal[jcTEXTBG], 0,   0,          19, 0, NULL, NULL, NULL },
	
    { NULL,                 0,       0,       0,    0,      0,                  0,                  0,   0,          0,  0, NULL, NULL, NULL }
};
extern ListData itemscript_list;
extern ListData itemspritescript_list;
extern ListData lweaponscript_list;
extern ListData npcscript_list;
extern ListData eweaponscript_list;
extern ListData comboscript_list;

static EXT_LIST zasm_extlist[] =
{
	{ (char *)"ZASM Files (*.zasm)",                        (char *)"zasm"                                     },
	{ NULL,                                                  NULL                                              }
};

int32_t onExportZASM()
{
	exportzasm_dlg[0].dp2 = lfont;
	exportzasm_dlg[3].d1 = type_ffc;
	exportzasm_dlg[4].dp = (void*)&ffscript_list;
	exportzasm_dlg[4].d1 = 0;
	//{ Build script lists
	build_biffs_list();
	build_biglobal_list();
	build_biitems_list();
	build_binpcs_list();
	build_bilweapons_list();
	build_bieweapons_list();
	build_bihero_list();
	build_bidmaps_list();
	build_biscreens_list();
	build_biitemsprites_list();
	build_bidcomboscripts_list();
	//}
	int32_t indx = 1;
	script_data const* scriptChoice = NULL;
	
	while(!scriptChoice)
	{
		if(is_large)
			large_dialog(exportzasm_dlg);
		indx = zc_popup_dialog(exportzasm_dlg, indx);
		switch(indx)
		{
			case 1: //confirm; exit dlg
			{
				//{ Find script choice
				int32_t scriptInd = -1;
				switch(exportzasm_dlg[3].d1)
				{
					case type_ffc:
						scriptInd = biffs[exportzasm_dlg[4].d1].second;
						break;
					case type_global:
						scriptInd = biglobal[exportzasm_dlg[4].d1].second;
						break;
					case type_itemdata:
						scriptInd = biitems[exportzasm_dlg[4].d1].second;
						break;
					case type_npc:
						scriptInd = binpcs[exportzasm_dlg[4].d1].second;
						break;
					case type_lweapon:
						scriptInd = bilweapons[exportzasm_dlg[4].d1].second;
						break;
					case type_eweapon:
						scriptInd = bieweapons[exportzasm_dlg[4].d1].second;
						break;
					case type_hero:
						scriptInd = bihero[exportzasm_dlg[4].d1].second;
						break;
					case type_dmap:
						scriptInd = bidmaps[exportzasm_dlg[4].d1].second;
						break;
					case type_screen:
						scriptInd = biscreens[exportzasm_dlg[4].d1].second;
						break;
					case type_itemsprite:
						scriptInd = biditemsprites[exportzasm_dlg[4].d1].second;
						break;
					case type_combo:
						scriptInd = bidcomboscripts[exportzasm_dlg[4].d1].second;
						break;
				}
				if(scriptInd < 0) break; //Invalid; likely '(None)'
				switch(exportzasm_dlg[3].d1)
				{
					case type_ffc:
						scriptChoice = ffscripts[scriptInd];
						break;
					case type_global:
						scriptChoice = globalscripts[scriptInd];
						break;
					case type_itemdata:
						scriptChoice = itemscripts[scriptInd];
						break;
					case type_npc:
						scriptChoice = guyscripts[scriptInd];
						break;
					case type_lweapon:
						scriptChoice = lwpnscripts[scriptInd];
						break;
					case type_eweapon:
						scriptChoice = ewpnscripts[scriptInd];
						break;
					case type_hero:
						scriptChoice = playerscripts[scriptInd];
						break;
					case type_dmap:
						scriptChoice = dmapscripts[scriptInd];
						break;
					case type_screen:
						scriptChoice = screenscripts[scriptInd];
						break;
					case type_itemsprite:
						scriptChoice = itemspritescripts[scriptInd];
						break;
					case type_combo:
						scriptChoice = comboscripts[scriptInd];
						break;
				}
				//}
				//{ Find export file
				if(!getname("Export Script (.zasm)","zasm",zasm_extlist,datapath,false))
				{
					scriptChoice = NULL;
					break;
				}
				replace_extension(temppath, temppath, "zasm", 2047);
				
				if(exists(temppath))
				{
					if(jwin_alert("Confirm Overwrite",temppath,"already exists.","Write over existing file?","&Yes","&No",'y','n',lfont)==2)
					{
						scriptChoice = NULL;
						break;
					}
				}
				
				FILE* zasm_output = fopen(temppath, "w");
				if(zasm_output == NULL)
				{
					jwin_alert("Error","Cannot create specified file!",NULL,NULL,"O&K",NULL,'k',0,lfont);
					scriptChoice = NULL;
					break;
				}
				//}
				write_script(zasm_output, scriptChoice);
				fclose(zasm_output);
				break;
			}
			case 0: case 2: //Cancel/X; quit dlg
				return D_O_K;
			case 3: //Type select
			{
				switch(exportzasm_dlg[3].d1)
				{
					default: //Shouldn't occur, but to be safe
					case type_ffc:
						exportzasm_dlg[4].dp = (void*)&ffscript_list;
						break;
					case type_global:
						exportzasm_dlg[4].dp = (void*)&globalscript_list;
						break;
					case type_itemdata:
						exportzasm_dlg[4].dp = (void*)&itemscript_list;
						break;
					case type_npc:
						exportzasm_dlg[4].dp = (void*)&npcscript_list;
						break;
					case type_lweapon:
						exportzasm_dlg[4].dp = (void*)&lweaponscript_list;
						break;
					case type_eweapon:
						exportzasm_dlg[4].dp = (void*)&eweaponscript_list;
						break;
					case type_hero:
						exportzasm_dlg[4].dp = (void*)&playerscript_list;
						break;
					case type_dmap:
						exportzasm_dlg[4].dp = (void*)&dmapscript_list;
						break;
					case type_screen:
						exportzasm_dlg[4].dp = (void*)&screenscript_list;
						break;
					case type_itemsprite:
						exportzasm_dlg[4].dp = (void*)&itemspritescript_list;
						break;
					case type_combo:
						exportzasm_dlg[4].dp = (void*)&comboscript_list;
						break;
				}
				exportzasm_dlg[4].d1 = 0;
				break;
			}
		}
	}
	return D_O_K;
}

int32_t onImportZASM()
{
	importzasm_dlg[0].dp2 = lfont;
	importzasm_dlg[4].dp = (void*)&ffscript_list;
	if(!getname("Import Script (.zasm)","zasm",zasm_extlist,datapath,false))
	{
		return D_O_K;
	}
	FILE* zasm_import_file = fopen(temppath, "r");
	if(zasm_import_file == NULL)
	{
		jwin_alert("Error","Cannot open specified file!",NULL,NULL,"O&K",NULL,'k',0,lfont);
		return D_O_K;
	}
	script_data *temp_slot = new script_data();
	if(parse_script_file(&temp_slot, zasm_import_file, false) == D_CLOSE)
	{
		fclose(zasm_import_file);
		jwin_alert("Error","Failed to parse specified file!",NULL,NULL,"O&K",NULL,'k',0,lfont);
		delete temp_slot;
		return D_O_K;
	}
	fclose(zasm_import_file);

    std::string namebuf;
	if(temp_slot->meta.valid()) //Found metadata
	{
		importzasm_dlg[3].d1 = getType(temp_slot->meta.script_type);
		namebuf = temp_slot->meta.script_name;
		switch(importzasm_dlg[3].d1)
		{
			default: //Shouldn't occur, but to be safe
			case type_ffc:
				importzasm_dlg[4].dp = (void*)&ffscript_sel_dlg_list;
				break;
			case type_global:
				importzasm_dlg[4].dp = (void*)&gscript_sel_dlg_list;
				break;
			case type_itemdata:
				importzasm_dlg[4].dp = (void*)&itemscript_sel_dlg_list;
				break;
			case type_npc:
				importzasm_dlg[4].dp = (void*)&npcscript_sel_dlg_list;
				break;
			case type_lweapon:
				importzasm_dlg[4].dp = (void*)&lweaponscript_sel_dlg_list;
				break;
			case type_eweapon:
				importzasm_dlg[4].dp = (void*)&eweaponscript_sel_dlg_list;
				break;
			case type_hero:
				importzasm_dlg[4].dp = (void*)&playerscript_sel_dlg_list;
				break;
			case type_dmap:
				importzasm_dlg[4].dp = (void*)&dmapscript_sel_dlg_list;
				break;
			case type_screen:
				importzasm_dlg[4].dp = (void*)&screenscript_sel_dlg_list;
				break;
			case type_itemsprite:
				importzasm_dlg[4].dp = (void*)&itemspritescript_sel_dlg_list;
				break;
			case type_combo:
				importzasm_dlg[4].dp = (void*)&comboscript_sel_dlg_list;
				break;
		}
		importzasm_dlg[4].d1 = 0;
	}
	else
	{
		importzasm_dlg[3].d1 = 0;
		importzasm_dlg[4].dp = (void*)&ffscript_list;
		importzasm_dlg[4].d1 = 0;
	}
	importzasm_dlg[8].dp = (void*)namebuf.c_str();
	bool confirmed = false;
	int32_t indx = 1;
	while(!confirmed)
	{
		if(is_large)
			large_dialog(importzasm_dlg);
		indx = zc_popup_dialog(importzasm_dlg, indx);
		switch(indx)
		{
			case 1: //confirm; exit dlg
			{
				if(!namebuf[0]) break; //No name?
				script_data **slot = NULL;
				script_slot_data *map = NULL;
				//{ Find script choice
				int32_t scriptInd = importzasm_dlg[4].d1;
				switch(importzasm_dlg[3].d1)
				{
					case type_ffc:
						slot = &ffscripts[scriptInd];
						map = &ffcmap[scriptInd];
						break;
					case type_global:
						slot = &globalscripts[scriptInd];
						map = &globalmap[scriptInd];
						break;
					case type_itemdata:
						slot = &itemscripts[scriptInd];
						map = &itemmap[scriptInd];
						break;
					case type_npc:
						slot = &guyscripts[scriptInd];
						map = &npcmap[scriptInd];
						break;
					case type_lweapon:
						slot = &lwpnscripts[scriptInd];
						map = &lwpnmap[scriptInd];
						break;
					case type_eweapon:
						slot = &ewpnscripts[scriptInd];
						map = &ewpnmap[scriptInd];
						break;
					case type_hero:
						slot = &playerscripts[scriptInd];
						map = &playermap[scriptInd];
						break;
					case type_dmap:
						slot = &dmapscripts[scriptInd];
						map = &dmapmap[scriptInd];
						break;
					case type_screen:
						slot = &screenscripts[scriptInd];
						map = &screenmap[scriptInd];
						break;
					case type_itemsprite:
						slot = &itemspritescripts[scriptInd];
						map = &itemspritemap[scriptInd];
						break;
					case type_combo:
						slot = &comboscripts[scriptInd];
						map = &comboscriptmap[scriptInd];
						break;
					case type_generic:
						slot = &genericscripts[scriptInd];
						map = &genericmap[scriptInd];
						break;
				}
				//}
				if(!slot) break; //Not found?
				temp_slot->transfer(**slot);
				map->format = SCRIPT_FORMAT_ZASM;
				map->updateName(namebuf);
				confirmed = true;
				break;
			}
			case 0: case 2: //Close dlg
			{
				delete temp_slot;
				return D_O_K;
			}
			case 3: //Type select
			{
				switch(importzasm_dlg[3].d1)
				{
					default: //Shouldn't occur, but to be safe
					case type_ffc:
						importzasm_dlg[4].dp = (void*)&ffscript_sel_dlg_list;
						break;
					case type_global:
						importzasm_dlg[4].dp = (void*)&gscript_sel_dlg_list;
						break;
					case type_itemdata:
						importzasm_dlg[4].dp = (void*)&itemscript_sel_dlg_list;
						break;
					case type_npc:
						importzasm_dlg[4].dp = (void*)&npcscript_sel_dlg_list;
						break;
					case type_lweapon:
						importzasm_dlg[4].dp = (void*)&lweaponscript_sel_dlg_list;
						break;
					case type_eweapon:
						importzasm_dlg[4].dp = (void*)&eweaponscript_sel_dlg_list;
						break;
					case type_hero:
						importzasm_dlg[4].dp = (void*)&playerscript_sel_dlg_list;
						break;
					case type_dmap:
						importzasm_dlg[4].dp = (void*)&dmapscript_sel_dlg_list;
						break;
					case type_screen:
						importzasm_dlg[4].dp = (void*)&screenscript_sel_dlg_list;
						break;
					case type_itemsprite:
						importzasm_dlg[4].dp = (void*)&itemspritescript_sel_dlg_list;
						break;
					case type_combo:
						importzasm_dlg[4].dp = (void*)&comboscript_sel_dlg_list;
						break;
				}
				importzasm_dlg[4].d1 = 0;
				break;
			}
		}
	}
	delete temp_slot;
	return D_O_K;
}

void center_zscript_dialogs()
{
    jwin_center_dialog(zscript_parser_dlg);
    jwin_center_dialog(exportzasm_dlg);
    jwin_center_dialog(importzasm_dlg);
    jwin_center_dialog(clearslots_dlg);
}

//The Dialogue that loads a ZMOD Module File
int32_t load_zmod_module_file()
{
	
    if(!getname("Load Module (.zmod)","zmod",NULL,datapath,false))
        return D_O_K;
    
    FILE *tempmodule = fopen(temppath,"r");
            
            if(tempmodule == NULL)
            {
                jwin_alert("Error","Cannot open specified file!",NULL,NULL,"O&K",NULL,'k',0,lfont);
                return -1;
            }
	    
	    
	    //Set the module path:
	    memset(moduledata.module_name, 0, sizeof(moduledata.module_name));
	    strcpy(moduledata.module_name, temppath);
	    al_trace("New Module Path is: %s \n", moduledata.module_name);
	    zc_set_config("ZCMODULE","current_module",moduledata.module_name);
	    zcm.init(true); //Load the module values.
	    build_biic_list();
	    build_bief_list();
	    build_biea_list(); 
	    build_biew_list();
	    return D_O_K;
}

static DIALOG sfxlist_dlg[] =
{
    // (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp)
    { jwin_win_proc,     60-12,   40,   200+24,  148,  vc(14),  vc(1),  0,       D_EXIT,          0,             0,       NULL, NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { jwin_abclist_proc,       72-12-4,   60+4,   176+24+8,  92+3,   jwin_pal[jcTEXTFG],  jwin_pal[jcTEXTBG],  0,       D_EXIT,     0,             0,       NULL, NULL, NULL },
    { jwin_button_proc,     90,   163,  61,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "Edit", NULL, NULL },
    { jwin_button_proc,     170,  163,  61,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Done", NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

int32_t select_sfx(const char *prompt,int32_t index)
{
    sfxlist_dlg[0].dp=(void *)prompt;
    sfxlist_dlg[0].dp2=lfont;
    sfxlist_dlg[2].d1=index;
    sfxlist_dlg[2].dp=(void *) & sfx_list;
    
    if(is_large)
        large_dialog(sfxlist_dlg);
        
    int32_t ret=zc_popup_dialog(sfxlist_dlg,2);
    
    if(ret==0||ret==4)
    {
        position_mouse_z(0);
        return -1;
    }
    
    index = sfxlist_dlg[2].d1;
    position_mouse_z(0);
    return index;
}

static DIALOG sfx_edit_dlg[] =
{
    { jwin_win_proc,           0,     0,  200,   159,  vc(14),              vc(1),                 0,       D_EXIT,     0,             0, (void *) "SFX", NULL, NULL },
    { jwin_button_proc,       35,   132,   61,    21,  vc(14),              vc(1),                13,       D_EXIT,     0,             0, (void *) "OK", NULL, NULL },
    { jwin_button_proc,      104,   132,   61,    21,  vc(14),              vc(1),                27,       D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { jwin_button_proc,       35,    78,   61,    21,  vc(14),              vc(1),                 0,       D_EXIT,     0,             0, (void *) "Load", NULL, NULL },
    { jwin_button_proc,       35,   105,   61,    21,  vc(14),              vc(1),                 0,       D_EXIT,     0,             0, (void *) "Play", NULL, NULL },
    { jwin_button_proc,      104,   105,   61,    21,  vc(14),              vc(1),                 0,       D_EXIT,     0,             0, (void *) "Stop", NULL, NULL },
    { jwin_button_proc,      104,    78,   61,    21,  vc(14),              vc(1),                 0,       D_EXIT,     0,             0, (void *) "Default", NULL, NULL },
    { jwin_edit_proc,     36,    25,   154,    16,  vc(12),  vc(1),    0,       0,         36,             0,       NULL, NULL, NULL },
    { jwin_text_proc,     8,    30,     16,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "Name:", NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { jwin_button_proc,      70,    51,   61,    21,  vc(14),              vc(1),                 0,       D_EXIT,     0,             0, (void *) "Save", NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

/*****************/
/*****  SFX  *****/
/*****************/

// array of voices, one for each sfx sample in the data file
// 0+ = voice #
// -1 = voice not allocated
int32_t sfx_voice[WAV_COUNT];

void Z_init_sound()
{
    for(int32_t i=0; i<WAV_COUNT; i++)
        sfx_voice[i]=-1;
        
//  master_volume(digi_volume,midi_volume);
}

// returns number of voices currently allocated
int32_t sfx_count()
{
    int32_t c=0;
    
    for(int32_t i=0; i<WAV_COUNT; i++)
        if(sfx_voice[i]!=-1)
            ++c;
            
    return c;
}

// clean up finished samples
void sfx_cleanup()
{
    for(int32_t i=0; i<WAV_COUNT; i++)
        if(sfx_voice[i]!=-1 && voice_get_position(sfx_voice[i])<0)
        {
            deallocate_voice(sfx_voice[i]);
            sfx_voice[i]=-1;
        }
}

// allocates a voice for the sample "wav_index" (index into zelda.dat)
// if a voice is already allocated (and/or playing), then it just returns true
// Returns true:  voice is allocated
//         false: unsuccessful
SAMPLE templist[WAV_COUNT];

bool sfx_init(int32_t index)
{
    // check index
    if(index<1 || index>=WAV_COUNT)
        return false;
        
    if(sfx_voice[index]==-1)
    {
        sfx_voice[index]=allocate_voice(&templist[index]);
    }
    
    return sfx_voice[index] != -1;
}

// plays an sfx sample
void sfx(int32_t index,int32_t pan,bool loop,bool restart)
{
    if(!sfx_init(index))
        return;
        
    voice_set_playmode(sfx_voice[index],loop?PLAYMODE_LOOP:PLAYMODE_PLAY);
    voice_set_pan(sfx_voice[index],pan);
    
    int32_t pos = voice_get_position(sfx_voice[index]);
    
    if(restart) voice_set_position(sfx_voice[index],0);
    
    if(pos<=0)
        voice_start(sfx_voice[index]);
}

// start it (in loop mode) if it's not already playing,
// otherwise just leave it in its current position
void cont_sfx(int32_t index)
{
    if(!sfx_init(index))
        return;
        
    if(voice_get_position(sfx_voice[index])<=0)
    {
        voice_set_position(sfx_voice[index],0);
        voice_set_playmode(sfx_voice[index],PLAYMODE_LOOP);
        voice_start(sfx_voice[index]);
    }
}

// adjust parameters while playing
void adjust_sfx(int32_t index,int32_t pan,bool loop)
{
    if(index<0 || index>=WAV_COUNT || sfx_voice[index]==-1)
        return;
        
    voice_set_playmode(sfx_voice[index],loop?PLAYMODE_LOOP:PLAYMODE_PLAY);
    voice_set_pan(sfx_voice[index],pan);
}

// pauses a voice
void pause_sfx(int32_t index)
{
    if(index>=0 && index<WAV_COUNT && sfx_voice[index]!=-1)
        voice_stop(sfx_voice[index]);
}

// resumes a voice
void resume_sfx(int32_t index)
{
    if(index>=0 && index<WAV_COUNT && sfx_voice[index]!=-1)
        voice_start(sfx_voice[index]);
}

// pauses all active voices
void pause_all_sfx()
{
    for(int32_t i=0; i<WAV_COUNT; i++)
        if(sfx_voice[i]!=-1)
            voice_stop(sfx_voice[i]);
}

// resumes all paused voices
void resume_all_sfx()
{
    for(int32_t i=0; i<WAV_COUNT; i++)
        if(sfx_voice[i]!=-1)
            voice_start(sfx_voice[i]);
}

// stops an sfx and deallocates the voice
void stop_sfx(int32_t index)
{
    if(index<0 || index>=WAV_COUNT)
        return;
        
    if(sfx_voice[index]!=-1)
    {
        deallocate_voice(sfx_voice[index]);
        sfx_voice[index]=-1;
    }
}

void kill_sfx()
{
    for(int32_t i=0; i<WAV_COUNT; i++)
        if(sfx_voice[i]!=-1)
        {
            deallocate_voice(sfx_voice[i]);
            sfx_voice[i]=-1;
        }
}

int32_t pan(int32_t x)
{
	return 128;
	/*switch(pan_style)
	{
		case 0: return 128;
		case 1: return vbound((x>>1)+68,0,255);
		case 2: return vbound(((x*3)>>2)+36,0,255);
	}
	return vbound(x,0,255);*/
}


void change_sfx(SAMPLE *sfx1, SAMPLE *sfx2)
{
    sfx1->bits = sfx2->bits;
    sfx1->stereo = sfx2->stereo;
    sfx1->freq = sfx2->freq;
    sfx1->priority = sfx2->priority;
    sfx1->len = sfx2->len;
    sfx1->loop_start = sfx2->loop_start;
    sfx1->loop_end = sfx2->loop_end;
    sfx1->param = sfx2->param;
    
    if(sfx1->data != NULL)
    {
        free(sfx1->data);
    }
    
    if(sfx2->data == NULL)
        sfx1->data = NULL;
    else
    {
        // When quests are saved and loaded, data is written in words.
        // If the last byte is dropped, it'll cause the sound to end with
        // a click. It could simply be extended and padded with 0, but
        // that causes compatibility issues... So we'll cut off
        // the last byte and decrease the length.
        
        int32_t len = (sfx1->bits==8?1:2)*(sfx1->stereo == 0 ? 1 : 2)*sfx1->len;
        
        while(len%sizeof(word))
        {
            // sizeof(word) should be 2, so this doesn't really need
            // to be a loop, but what the heck.
            sfx1->len--;
            len = (sfx1->bits==8?1:2)*(sfx1->stereo == 0 ? 1 : 2)*sfx1->len;
        }
        
        sfx1->data = malloc(len);
        memcpy(sfx1->data, sfx2->data, len);
    }
}

bool confirmBox(const char *m1, const char *m2, const char *m3)
{
	if(!m3)
	{
		if(!m2) m2 = "Are you sure?";
		else m3 = "Are you sure?";
	}
	return jwin_alert("Confirmation", m1, m2, m3, "Yes", "No", 'y', 'n', lfont) == 1;
}

int32_t onSelectSFX()
{
    int32_t index = select_sfx("Select SFX",0);
    
    while(index >= 0)
    {
        if(index)
            onEditSFX(index);
            
        index = select_sfx("Select SFX",index);
    }
    
    refresh(rMAP+rCOMBOS);
    return D_O_K;
}

bool saveWAV(int32_t slot, const char *filename)
{
    if (slot < 1 || slot >= 511 )
        return false;

    if (customsfxdata[slot].data == NULL)
	return false;
    
    std::ofstream ofs(filename, std::ios::binary);
    if (!ofs)
        return false;
    ofs.write("RIFF",4);
    uint32_t samplerate = customsfxdata[slot].freq;
    uint16_t channels = customsfxdata[slot].stereo ? 2 : 1;
    uint32_t datalen = customsfxdata[slot].len*channels*customsfxdata[slot].bits / 8;
    uint32_t size = 36 + datalen;
    ofs.write((char *)&size, 4);
    ofs.write("WAVE", 4);
    ofs.write("fmt ", 4);
    uint32_t fmtlen = 16;
    ofs.write((char *)&fmtlen, 4);
    uint16_t type = 1;
    ofs.write((char *)&type, 2);
    ofs.write((char *)&channels, 2);
    ofs.write((char *)&samplerate, 4);
    uint32_t bytespersec = samplerate*channels*customsfxdata[slot].bits / 8; 
    ofs.write((char *)&bytespersec, 4);
    uint16_t blockalign = channels*customsfxdata[slot].bits / 8;
    ofs.write((char *)&blockalign, 2);
    uint16_t bitspersample = customsfxdata[slot].bits;
    ofs.write((char *)&bitspersample, 2);
    ofs.write("data", 4);
    ofs.write((char *)&datalen, 4);
    if (bitspersample == 8)
    {
        for (int32_t i = 0; i < (int32_t)customsfxdata[slot].len*channels; i++)
        {
            char data = ((char *)customsfxdata[slot].data)[i];
            data ^= 0x80;
            ofs.write(&data, 1);
        }
    }
    else if (bitspersample == 16)
    {
        for (int32_t i = 0; i < (int32_t)customsfxdata[slot].len*channels; i++)
        {
            uint16_t data = ((uint16_t *)customsfxdata[slot].data)[i];
            data ^= 0x8000;
            ofs.write((char *)&data, 2);
        }
    }
    else
        return false;
    return !!ofs;
} 

int32_t onEditSFX(int32_t index)
{
	kill_sfx();
	zc_stop_midi();
	zc_set_volume(255,-1);
	int32_t ret;
	sfx_edit_dlg[0].dp2=lfont;
	uint8_t tempflag;
	tempflag = get_bit(customsfxflag,index-1);
	change_sfx(&templist[index], &customsfxdata[index]);
	
	char sfxnumstr[50];
	sprintf(sfxnumstr,"SFX %d: %s", index, sfx_string[index]);
	sfx_edit_dlg[0].dp = sfxnumstr;
	
	char name[36];
	strcpy(name,sfx_string[index]);
	sfx_edit_dlg[7].dp = name;
	
	if(is_large)
		large_dialog(sfx_edit_dlg);
		
	do
	{
		ret=zc_popup_dialog(sfx_edit_dlg,1);
		
		switch(ret)
		{
			case 1:
				saved= false;
				kill_sfx();
				change_sfx(&customsfxdata[index],&templist[index]);
				set_bit(customsfxflag,index-1,tempflag);
				strcpy(sfx_string[index], name);
				
			case 2:
			case 0:
				// Fall Through
				kill_sfx();
				
				for(int32_t i=1; i<WAV_COUNT; i++)
				{
					if(templist[i].data != NULL)
					{
						free(templist[i].data);
						templist[i].data = NULL;
					}
				}
				
				break;
				
			case 3:
				if(getname("Open .WAV file", "wav", NULL,temppath, true))
				{
					SAMPLE * temp_sample;
					
					if((temp_sample = load_wav(temppath))==NULL)
					{
						jwin_alert("Error","Could not open file",temppath,NULL,"OK",NULL,13,27,lfont);
					}
					else
					{
						char sfxtitle[36];
						char *t = get_filename(temppath);
						int32_t j;
						
						for(j=0; j<35 && t[j]!=0 && t[j]!='.'; j++)
						{
							sfxtitle[j]=t[j];
						}
						
						sfxtitle[j]=0;
						strcpy(name,sfxtitle);
						kill_sfx();
						change_sfx(&templist[index], temp_sample);
						destroy_sample(temp_sample);
						tempflag = 1;
					}
				}
				
				break;
				
			case 4:
			{
				kill_sfx();
				
				if(templist[index].data != NULL)
				{
					sfx(index, 128, false,true);
				}
			}
			break;
			
			case 5:
				kill_sfx();
				break;
				
			case 6:
				kill_sfx();
				
				if(index < WAV_COUNT)
				{
					SAMPLE *temp_sample = (SAMPLE *)sfxdata[zc_min(index,Z35)].dat;
					change_sfx(&templist[index], temp_sample);
					tempflag = 1; //now count as custom sfx
					sprintf(name,"s%03d", index);
					
					if(index <Z35)
					{
						strcpy(name, old_sfx_string[index-1]);
					}
				}
				
				break;
				
			
			case 10:
			{
				temppath[0]=0;//memset(temppath, 0, sizeof(temppath));
				char tempname[36];
				strcpy(tempname,sfx_string[index]);
				//change spaces to dashes for f/s safety
				for ( int32_t q = 0; q < 36; ++q )
				{
					if(tempname[q] == 32 || tempname[q] == 47 || tempname[q] == 92 ) //SPACE, Bslash, Fslash
						tempname[q] = 45; //becomes hyphen
				}
				
				tempname[35] = 0;
				
				strcpy(temppath,tempname);
				
				//zprint2("temppath is: %s\n", temppath);
				//zprint2("tempname is: %s\n", tempname);
				//save
				if(templist[index].data != NULL)
				{
					if (getname("Save .WAV file", "wav", NULL, temppath, true))
					{
						if(!saveWAV(index, temppath))
						{
							jwin_alert("Error!", "Could not write file", temppath, NULL, "OK", NULL, 13, 27, lfont);
						}
						else 
						{
							jwin_alert("Success!", "Saved WAV file", temppath, NULL, "OK", NULL, 13, 27, lfont);
						}
					}
				}
				else 
				{
					jwin_alert("Error!", "Cannot save an enpty slot!", NULL, NULL, "OK", NULL, 13, 27, lfont);
				}		
				break;
			}
		}
	}
	while(ret>2);
	
	return D_O_K;
}


static DIALOG mapstyles_dlg[] =
{
    /* (dialog proc)     (x)   (y)    (w)   (h)   (fg)      (bg)     (key)    (flags)       (d1)           (d2)      (dp) */
    { jwin_win_proc,        0,    0,  307,  186,  vc(14),   vc(1),      0,       D_EXIT,     0,             0, (void *) "Map Styles", NULL, NULL },
    { jwin_ctext_proc,     24,   34,   36,   36,       0,       0,      0,       0,          0,             0, (void *) "Frame", NULL, NULL },       //frame
    { jwin_ctext_proc,     68,   26,   20,   20,       0,       0,      0,       0,          0,             0, (void *) "Triforce", NULL, NULL },       //triforce fragment
    { jwin_ctext_proc,     68,   34,   20,   20,       0,       0,      0,       0,          0,             0, (void *) "Fragment", NULL, NULL },       //triforce fragment
    { jwin_ctext_proc,    152,   26,  100,   52,       0,       0,      0,       0,          0,             0, (void *) "Triforce Frame", NULL, NULL },       //triforce frame
    { jwin_ctext_proc,    152,   34,  100,   52,       0,       0,      0,       0,          0,             0, (void *) "(Normal or Double Sized)", NULL, NULL },       //triforce frame
    { jwin_ctext_proc,    260,   34,   84,   52,       0,       0,      0,       0,          0,             0, (void *) "Overworld Map", NULL, NULL },       //overworld map
    { jwin_ctext_proc,     24,   82,   20,   20,       0,       0,      0,       0,          0,             0, (void *) "Heart", NULL, NULL },       //heart container piece
    { jwin_ctext_proc,     24,   90,   20,   20,       0,       0,      0,       0,          0,             0, (void *) "Container", NULL, NULL },       //heart container piece
    { jwin_ctext_proc,     24,   98,   20,   20,       0,       0,      0,       0,          0,             0, (void *) "Piece", NULL, NULL },       //heart container piece
    { jwin_ctext_proc,    260,   98,   84,   52,       0,       0,      0,       0,          0,             0, (void *) "Dungeon Map", NULL, NULL },       //dungeon map
    // 11
    { jwin_frame_proc,      6,   42,   36,   36,       0,       0,      0,       0,          FR_DEEP,       0,       NULL, NULL, NULL },             //frame
    //  { jwin_frame_proc,     50,   42,   36,   52,       0,       0,      0,       0,          FR_DEEP,       0,       NULL, NULL, NULL }, //bs triforce fragment
    { jwin_frame_proc,     58,   42,   20,   20,       0,       0,      0,       0,          FR_DEEP,       0,       NULL, NULL, NULL },             //normal triforce fragment
    //  { jwin_frame_proc,     94,   42,  116,  116,       0,       0,      0,       0,          FR_DEEP,       0,       NULL, NULL, NULL }, //bs triforce frame
    { jwin_frame_proc,    102,   42,  100,   52,       0,       0,      0,       0,          FR_DEEP,       0,       NULL, NULL, NULL },             //normaltriforce frame
    { jwin_frame_proc,    218,   42,   84,   52,       0,       0,      0,       0,          FR_DEEP,       0,       NULL, NULL, NULL },             //overworld map
    { jwin_frame_proc,     14,  106,   20,   20,       0,       0,      0,       0,          FR_DEEP,       0,       NULL, NULL, NULL },             //heart container piece
    { jwin_frame_proc,    218,  106,   84,   52,       0,       0,      0,       0,          FR_DEEP,       0,       NULL, NULL, NULL },             //dungeon map
    // 17
    { d_maptile_proc,       8,   44,   32,   32,       0,       0,      0,       0,          0,             0,       NULL, (void*)1, NULL },             //frame
    //  { d_maptile_proc,      52,   44,   32,   48,       0,       0,      0,       0,          0,             0,       NULL, NULL, NULL }, //bs triforce fragment
    { d_maptile_proc,      60,   44,   16,   16,       0,       0,      0,       0,          0,             0,       NULL, (void*)1, NULL },             //normal triforce fragment
    //  { d_maptile_proc,      96,   44,  112,  112,       0,       0,      0,       0,          0,             0,       NULL, NULL, NULL }, //bs triforce frame
    { d_maptile_proc,     104,   44,   96,   48,       0,       0,      0,       0,          0,             0,       NULL, (void*)1, NULL },             //normal triforce frame
    { d_maptile_proc,     220,   44,   80,   48,       0,       0,      0,       0,          0,             0,       NULL, (void*)1, NULL },             //overworld map
    { d_maptile_proc,      16,  108,   16,   16,       0,       0,      0,       0,          0,             0,       NULL, (void*)1, NULL },             //heart container piece
    { d_maptile_proc,     220,  108,   80,   48,       0,       0,      0,       0,          0,             0,       NULL, (void*)1, NULL },             //dungeon map
    // 23
    { jwin_button_proc,    83,  162,   61,   21,  vc(14),   vc(1),     13,       D_EXIT,     0,             0, (void *) "OK", NULL, NULL },
    { jwin_button_proc,   163,  162,   61,   21,  vc(14),   vc(1),     27,       D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

int32_t onMapStyles()
{
    if(mapstyles_dlg[0].d1<1)
    {
        mapstyles_dlg[12].x=mapstyles_dlg[0].x+50;
        mapstyles_dlg[12].w=36;
        mapstyles_dlg[12].h=52;
        mapstyles_dlg[13].x=mapstyles_dlg[0].x+94;
        mapstyles_dlg[13].w=116;
        mapstyles_dlg[13].h=116;
        mapstyles_dlg[18].x=mapstyles_dlg[12].x+2;
        mapstyles_dlg[18].w=mapstyles_dlg[12].w-4;
        mapstyles_dlg[18].h=mapstyles_dlg[12].h-4;
        mapstyles_dlg[19].x=mapstyles_dlg[13].x+2;
        mapstyles_dlg[19].w=mapstyles_dlg[13].w-4;
        mapstyles_dlg[19].h=mapstyles_dlg[13].h-4;
    }
    
    mapstyles_dlg[0].dp2 = lfont;
    //al_trace("onMapStyles() read blueframe_tile as: %d\n", misc.colors.blueframe_tile);
    mapstyles_dlg[17].d1  = misc.colors.blueframe_tile;
    mapstyles_dlg[17].fg  = misc.colors.blueframe_cset;
    //al_trace("onMapStyles() read triforce_tile as: %d\n", misc.colors.triforce_tile);
    mapstyles_dlg[18].d1  = misc.colors.triforce_tile;
    mapstyles_dlg[18].fg  = misc.colors.triforce_cset;
    //al_trace("onMapStyles() read triframe_tile as: %d\n", misc.colors.triframe_tile);
    mapstyles_dlg[19].d1  = misc.colors.triframe_tile;
    mapstyles_dlg[19].fg  = misc.colors.triframe_cset;
    //al_trace("onMapStyles() read overworld_map_tile as: %d\n", misc.colors.overworld_map_tile);
    mapstyles_dlg[20].d1  = misc.colors.overworld_map_tile;
    mapstyles_dlg[20].fg  = misc.colors.overworld_map_cset;
     //al_trace("onMapStyles() read HCpieces_tile as: %d\n", misc.colors.HCpieces_tile);
    mapstyles_dlg[21].d1 = misc.colors.HCpieces_tile;
    mapstyles_dlg[21].fg = misc.colors.HCpieces_cset;
    //al_trace("onMapStyles() read dungeon_map_tile as: %d\n", misc.colors.dungeon_map_tile);
    mapstyles_dlg[22].d1  = misc.colors.dungeon_map_tile;
    mapstyles_dlg[22].fg  = misc.colors.dungeon_map_cset;
    
    if(is_large)
        large_dialog(mapstyles_dlg,2);
        
    go();
    int32_t ret = zc_do_dialog(mapstyles_dlg,-1);
    comeback();
    
    if(ret==23)
    {
        misc.colors.blueframe_tile     = mapstyles_dlg[17].d1;
        misc.colors.blueframe_cset     = mapstyles_dlg[17].fg;
        misc.colors.triforce_tile      = mapstyles_dlg[18].d1;
        misc.colors.triforce_cset      = mapstyles_dlg[18].fg;
        misc.colors.triframe_tile      = mapstyles_dlg[19].d1;
        misc.colors.triframe_cset      = mapstyles_dlg[19].fg;
        misc.colors.overworld_map_tile = mapstyles_dlg[20].d1;
        misc.colors.overworld_map_cset = mapstyles_dlg[20].fg;
        misc.colors.HCpieces_tile      = mapstyles_dlg[21].d1;
        misc.colors.HCpieces_cset      = mapstyles_dlg[21].fg;
        misc.colors.dungeon_map_tile   = mapstyles_dlg[22].d1;
        misc.colors.dungeon_map_cset   = mapstyles_dlg[22].fg;
        saved=false;
    }
    
    return D_O_K;
}

int32_t d_misccolors_old_proc(int32_t msg,DIALOG *d,int32_t c)
{
    //these are here to bypass compiler warnings about unused arguments
    c=c;
    
    if(msg==MSG_DRAW)
    {
        textout_ex(screen,font,"0123456789ABCDEF",d->x+8,d->y,d->fg,d->bg);
        textout_ex(screen,font,"0",d->x,d->y+8,d->fg,d->bg);
        textout_ex(screen,font,"1",d->x,d->y+16,d->fg,d->bg);
        textout_ex(screen,font,"5",d->x,d->y+24,d->fg,d->bg);
        
        for(int32_t i=0; i<32; i++)
        {
            int32_t px2 = d->x+((i&15)<<3)+8;
            int32_t py2 = d->y+((i>>4)<<3)+8;
            rectfill(screen,px2,py2,px2+7,py2+7,i);
        }
        
        for(int32_t i=0; i<16; i++)
        {
            int32_t px2 = d->x+(i<<3)+8;
            rectfill(screen,px2,d->y+24,px2+7,d->y+31,i+80);
        }
    }
    
    return D_O_K;
}

int32_t hexclicked=-1;

int32_t d_misccolors_hexedit_proc(int32_t msg,DIALOG *d,int32_t c)
{
    switch(msg)
    {
    case MSG_GOTFOCUS:
        hexclicked=((int32_t)(size_t)(d->dp3))+20;
        break;
        
    case MSG_LOSTFOCUS:
        hexclicked=-1;
        break;
    }
    
    return d_hexedit_proc(msg,d,c);
}


int32_t d_misccolors_proc(int32_t msg,DIALOG *d,int32_t c);

static int32_t misccolor1_list[] =
{
    // dialog control number
    4, 5, 6, 7, 8, 20, 21, 22, 23, 24, 36, 37, 38, 39, 40, -1
};

static int32_t misccolor2_list[] =
{
    // dialog control number
    9, 10, 11, 12, 13, 25, 26, 27, 28, 29, 41, 42, 43, 44, 45, -1
};

static int32_t misccolor3_list[] =
{
    // dialog control number
    14, 15, 16, 17, 18, 30, 31, 32, 33, 34, 46, 47, 48, 49, 50, -1
};

static int32_t misccolor4_list[] =
{
    19, 35, 51, 54, 55, 56, -1
};

static TABPANEL misccolor_tabs[] =
{
    // (text)
    { (char *)"1",  D_SELECTED,  misccolor1_list, 0, NULL },
    { (char *)"2",  0,           misccolor2_list, 0, NULL },
    { (char *)"3",  0,           misccolor3_list, 0, NULL },
    { (char *)"4",  0,           misccolor4_list, 0, NULL },
    { NULL,         0,           NULL, 0, NULL }
};

int32_t d_misccolors_tab_proc(int32_t msg,DIALOG *d,int32_t c);

static DIALOG misccolors_dlg[] =
{
    // (dialog proc)        (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp)
    { jwin_win_proc,        2,   21,    316,  197-23,  vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "Misc Colors", NULL, NULL },
    //  { jwin_frame_proc,      98-84+1+2,   52+8-6+4,   132,  100,  vc(15),  vc(1),  0,       0,          FR_DEEP,             0,       NULL, NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { d_misccolors_proc,    92-84+1+2,   44+8-6+4,   128+8,  96+8,   vc(9),   vc(1),  0,       0,          0,             0,       NULL, NULL, NULL },
    //3
    { d_misccolors_tab_proc,  150+14-2+10-15,   60-14,  150-10+15,  144-20-10,    jwin_pal[jcBOXFG],  jwin_pal[jcBOX],      0,      0,          0,             0, (void *) misccolor_tabs, NULL, (void *)misccolors_dlg },
    //4
    { jwin_text_proc,       215-25-12-15,    76-4,     0,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "Text:", NULL, NULL },
    { jwin_text_proc,       215-25-12-15,    94-4,     0,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "Caption:", NULL, NULL },
    { jwin_text_proc,       215-25-12-15,    112-4,    0,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "Overworld Minmap:", NULL, NULL },
    { jwin_text_proc,       215-25-12-15,    130-4,    0,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "Minimap Background:", NULL, NULL },
    { jwin_text_proc,       215-25-12-15,    148-4,    0,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "Minimap Foreground 1:", NULL, NULL },
    { jwin_text_proc,       215-25-12-15,   76-4,      0,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "Minimap Foreground 2:", NULL, NULL },
    { jwin_text_proc,       215-25-12-15,   94-4,      0,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "BS Minimap Dark:", NULL, NULL },
    { jwin_text_proc,       215-25-12-15,   112-4,     0,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "BS Minimap Goal:", NULL, NULL },
    { jwin_text_proc,       215-25-12-15,   130-4,     0,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "Compass Mark (Light):", NULL, NULL },
    { jwin_text_proc,       215-25-12-15,   148-4,     0,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "Compass Mark (Dark):", NULL, NULL },
    { jwin_text_proc,       215-25-12-15,   76-4,      0,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "Subscreen Background:", NULL, NULL },
    { jwin_text_proc,       215-25-12-15,   94-4,      0,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "Subscreen Shadow:", NULL, NULL },
    { jwin_text_proc,       215-25-12-15,   112-4,     0,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "Triforce Frame:", NULL, NULL },
    { jwin_text_proc,       215-25-12-15,   130-4,     0,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "Big Map Background:", NULL, NULL },
    { jwin_text_proc,       215-25-12-15,   148-4,     0,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "Big Map Foreground:", NULL, NULL },
    { jwin_text_proc,       215-25-12-15,   76-4,      0,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "Player's Position:", NULL, NULL },
    
    //20
    { d_misccolors_hexedit_proc,       294-25+14+2,   76-8,    21,   16,    vc(11),  vc(1),  0,       0,          2,             0,       NULL, NULL, (void *)0, },
    { d_misccolors_hexedit_proc,       294-25+14+2,   94-8,    21,   16,    vc(11),  vc(1),  0,       0,          2,             0,       NULL, NULL, (void *)1, },
    { d_misccolors_hexedit_proc,       294-25+14+2,   112-8,   21,   16,    vc(11),  vc(1),  0,       0,          2,             0,       NULL, NULL, (void *)2, },
    { d_misccolors_hexedit_proc,       294-25+14+2,   130-8,   21,   16,    vc(11),  vc(1),  0,       0,          2,             0,       NULL, NULL, (void *)3, },
    { d_misccolors_hexedit_proc,       294-25+14+2,   148-8,   21,   16,    vc(11),  vc(1),  0,       0,          2,             0,       NULL, NULL, (void *)4, },
    { d_misccolors_hexedit_proc,       294-25+14+2,   76-8,    21,   16,    vc(11),  vc(1),  0,       0,          2,             0,       NULL, NULL, (void *)5, },
    { d_misccolors_hexedit_proc,       294-25+14+2,   94-8,    21,   16,    vc(11),  vc(1),  0,       0,          2,             0,       NULL, NULL, (void *)6, },
    { d_misccolors_hexedit_proc,       294-25+14+2,   112-8,   21,   16,    vc(11),  vc(1),  0,       0,          2,             0,       NULL, NULL, (void *)7, },
    { d_misccolors_hexedit_proc,       294-25+14+2,   130-8,   21,   16,    vc(11),  vc(1),  0,       0,          2,             0,       NULL, NULL, (void *)8, },
    { d_misccolors_hexedit_proc,       294-25+14+2,   148-8,   21,   16,    vc(11),  vc(1),  0,       0,          2,             0,       NULL, NULL, (void *)9, },
    { d_misccolors_hexedit_proc,       294-25+14+2,   76-8,    21,   16,    vc(11),  vc(1),  0,       0,          2,             0,       NULL, NULL, (void *)10, },
    { d_misccolors_hexedit_proc,       294-25+14+2,   94-8,    21,   16,    vc(11),  vc(1),  0,       0,          2,             0,       NULL, NULL, (void *)11, },
    { d_misccolors_hexedit_proc,       294-25+14+2,   112-8,   21,   16,    vc(11),  vc(1),  0,       0,          2,             0,       NULL, NULL, (void *)12, },
    { d_misccolors_hexedit_proc,       294-25+14+2,   130-8,   21,   16,    vc(11),  vc(1),  0,       0,          2,             0,       NULL, NULL, (void *)13, },
    { d_misccolors_hexedit_proc,       294-25+14+2,   148-8,   21,   16,    vc(11),  vc(1),  0,       0,          2,             0,       NULL, NULL, (void *)14, },
    { d_misccolors_hexedit_proc,       294-25+14+2,   76-8,    21,   16,    vc(11),  vc(1),  0,       0,          2,             0,       NULL, NULL, (void *)15, },
    
    //36
    { jwin_text_proc,       283-25+14+2,    76-4,     0,    8,    vc(11),  vc(1),  0,       0,          2,             0, (void *) "0x", NULL, NULL },
    { jwin_text_proc,       283-25+14+2,    94-4,     0,    8,    vc(11),  vc(1),  0,       0,          2,             0, (void *) "0x", NULL, NULL },
    { jwin_text_proc,       283-25+14+2,    112-4,    0,    8,    vc(11),  vc(1),  0,       0,          2,             0, (void *) "0x", NULL, NULL },
    { jwin_text_proc,       283-25+14+2,    130-4,    0,    8,    vc(11),  vc(1),  0,       0,          2,             0, (void *) "0x", NULL, NULL },
    { jwin_text_proc,       283-25+14+2,    148-4,    0,    8,    vc(11),  vc(1),  0,       0,          2,             0, (void *) "0x", NULL, NULL },
    { jwin_text_proc,       283-25+14+2,   76-4,     0,    8,    vc(11),  vc(1),  0,       0,          2,             0, (void *) "0x", NULL, NULL },
    { jwin_text_proc,       283-25+14+2,   94-4,     0,    8,    vc(11),  vc(1),  0,       0,          2,             0, (void *) "0x", NULL, NULL },
    { jwin_text_proc,       283-25+14+2,   112-4,    0,    8,    vc(11),  vc(1),  0,       0,          2,             0, (void *) "0x", NULL, NULL },
    { jwin_text_proc,       283-25+14+2,   130-4,    0,    8,    vc(11),  vc(1),  0,       0,          2,             0, (void *) "0x", NULL, NULL },
    { jwin_text_proc,       283-25+14+2,   148-4,    0,    8,    vc(11),  vc(1),  0,       0,          2,             0, (void *) "0x", NULL, NULL },
    { jwin_text_proc,       283-25+14+2,   76-4,     0,    8,    vc(11),  vc(1),  0,       0,          2,             0, (void *) "0x", NULL, NULL },
    { jwin_text_proc,       283-25+14+2,   94-4,     0,    8,    vc(11),  vc(1),  0,       0,          2,             0, (void *) "0x", NULL, NULL },
    { jwin_text_proc,       283-25+14+2,   112-4,    0,    8,    vc(11),  vc(1),  0,       0,          2,             0, (void *) "0x", NULL, NULL },
    { jwin_text_proc,       283-25+14+2,   130-4,    0,    8,    vc(11),  vc(1),  0,       0,          2,             0, (void *) "0x", NULL, NULL },
    { jwin_text_proc,       283-25+14+2,   148-4,    0,    8,    vc(11),  vc(1),  0,       0,          2,             0, (void *) "0x", NULL, NULL },
    { jwin_text_proc,       283-25+14+2,   76-4,     0,    8,    vc(11),  vc(1),  0,       0,          2,             0, (void *) "0x", NULL, NULL },
    
    //52
    { jwin_button_proc,     90,   190-20,  61,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "OK", NULL, NULL },
    { jwin_button_proc,     170,  190-20,  61,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { jwin_text_proc,       215-25-12-15,   94-4,      0,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "Message Text:", NULL, NULL },
    { d_misccolors_hexedit_proc,       294-25+14+2,   94-8,    21,   16,    vc(11),  vc(1),  0,       0,          2,             0,       NULL, NULL, (void *)35, },
    { jwin_text_proc,		  283-25+14+2,   94-4,    0,    8,    vc(11),  vc(1),  0,       0,          2,             0, (void *) "0x", NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

int32_t d_misccolors_tab_proc(int32_t msg,DIALOG *d,int32_t c)
{

    switch(msg)
    {
    case MSG_WANTFOCUS:
        return D_WANTFOCUS;
        break;
    }
    
    return jwin_tab_proc(msg,d,c);
}


int32_t d_misccolors_proc(int32_t msg,DIALOG *d,int32_t c)
{
    //these are here to bypass compiler warnings about unused arguments
    c=c;
    int32_t mul=8;
    
    if(is_large)
        mul=(int32_t)(mul*1.5);
        
    switch(msg)
    {
    case MSG_CLICK:
        if(hexclicked!=-1)
        {
            int32_t color_col=vbound(((gui_mouse_x()-d->x-8)/mul),0,15);
            int32_t color_row=vbound(((gui_mouse_y()-d->y-10)/mul),0,11);
            sprintf((char*)misccolors_dlg[hexclicked].dp,"%X%X",color_row,color_col);
            object_message(misccolors_dlg+hexclicked,MSG_DRAW,0);
        }
        
        break;
        
    case MSG_DRAW:
        for(int32_t i=0; i<10; i++)
        {
            textprintf_centre_ex(screen,font,d->x+8+4+(i*mul),d->y,jwin_pal[jcBOXFG],jwin_pal[jcBOX], "%d", i);
        }
        
        for(int32_t i=0; i<6; i++)
        {
            textprintf_centre_ex(screen,font,d->x+8+4+((10+i)*mul),d->y,jwin_pal[jcBOXFG],jwin_pal[jcBOX], "%c", i+'A');
        }
        
        for(int32_t i=0; i<10; i++)
        {
            textprintf_right_ex(screen,font,d->x+6,d->y+(i*mul)+10,jwin_pal[jcBOXFG],jwin_pal[jcBOX], "%d", i);
        }
        
        for(int32_t i=0; i<2; i++)
        {
            textprintf_right_ex(screen,font,d->x+6,d->y+((i+10)*mul)+10,jwin_pal[jcBOXFG],jwin_pal[jcBOX], "%c", i+'A');
        }
        
        jwin_draw_frame(screen,d->x+6,d->y+8,int32_t(132*(is_large?1.5:1))-(1+is_large),int32_t(100*(is_large?1.5:1))-(1+is_large),FR_DEEP);
        
        for(int32_t i=0; i<192; i++)
        {
            int32_t px2 = d->x+int32_t(((i&15)<<3)*(is_large?1.5 : 1))+8;
            int32_t py2 = d->y+int32_t(((i>>4)<<3)*(is_large?1.5 : 1))+8+2;
            rectfill(screen,px2,py2,px2+(mul-1),py2+(mul-1),i);
        }
        
        break;
    }
    
    return D_O_K;
}


int32_t onMiscColors()
{
    char buf[17][3];
    byte *si = &(misc.colors.text);
    misccolors_dlg[0].dp2=lfont;
    
    for(int32_t i=0; i<16; i++)
    {
        sprintf(buf[i],"%02X",*(si++));
        sprintf(buf[16], "%02X", misc.colors.msgtext);
        misccolors_dlg[i+20].dp = buf[i];
        misccolors_dlg[55].dp = buf[16];
    }
    
    if(is_large)
        large_dialog(misccolors_dlg);
        
    if(zc_popup_dialog(misccolors_dlg,0)==52)
    {
        saved=false;
        si = &(misc.colors.text);
        
        for(int32_t i=0; i<16; i++)
        {
            *si = zc_xtoi(buf[i]);
            ++si;
        }
        
        misc.colors.msgtext = zc_xtoi(buf[16]);
    }
    
    return D_O_K;
}

// ****  Palette cycling  ****

static int32_t palclk[3];
static int32_t palpos[3];

void reset_pal_cycling()
{
    for(int32_t i=0; i<3; i++)
        palclk[i]=palpos[i]=0;
}

void cycle_palette()
{
    if(!get_bit(quest_rules,qr_FADE))
        return;
        
    int32_t level = Map.CurrScr()->color;
    bool refreshpal = false;
    
    for(int32_t i=0; i<3; i++)
    {
        palcycle c = misc.cycles[level][i];
        
        if(c.count&0xF0)
        {
            if(++palclk[i] >= c.speed)
            {
                palclk[i]=0;
                
                if(++palpos[i] >= (c.count>>4))
                    palpos[i]=0;
                    
                byte *si = colordata + CSET(level*pdLEVEL+poFADE1+1+palpos[i])*3;
                
                si += (c.first&15)*3;
                
                for(int32_t col=c.first&15; col<=(c.count&15); col++)
                {
                    RAMpal[CSET(c.first>>4)+col] = _RGB(si);
                    si+=3;
                }
                
                refreshpal = true;
            }
        }
    }
    
    if(refreshpal)
    {
        rebuild_trans_table();
        set_palette_range(RAMpal,0,192,false);
    }
}


/********************/
/******  Help  ******/
/********************/

static DIALOG help_dlg[] =
{
    /* (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)      (d2)      (dp) */
//  { jwin_textbox_proc,    4,   2+21,   320-8,  240-6-21,  0,       0,      0,       0,          0,        0,        NULL, NULL, NULL },
    { jwin_win_proc,        0,   0,   320,  240,  0,       vc(15), 0,      D_EXIT,       0,          0, (void *) "ZQuest Help", NULL, NULL },
    { jwin_frame_proc,   4,   23,   320-8,  240-27,   0,       0,      0,       0,             FR_DEEP,       0,       NULL, NULL, NULL },
    { d_editbox_proc,    6,   25,   320-8-4,  240-27-4,  0,       0,      0,       0/*D_SELECTED*/,          0,        0,       NULL, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,       0,      0,       0,          0,        KEY_ESC, (void *) close_dlg, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,       0,      0,       0,          0,        KEY_F12, (void *) onSnapshot, NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

void doHelp(int32_t bg,int32_t fg)
{
    help_dlg[0].dp2= get_custom_font(CFONT_TITLE);
    help_dlg[2].dp = new EditboxModel(helpstr, new EditboxWordWrapView(&help_dlg[2],get_custom_font(CFONT_TEXTBOX),fg,bg,BasicEditboxView::HSTYLE_EOTEXT),true);
    help_dlg[2].bg = bg;
    zc_popup_dialog(help_dlg,2);
    delete(EditboxModel*)(help_dlg[2].dp);
}

int32_t onHelp()
{
    restore_mouse();
    doHelp(vc(15),vc(0));
    return D_O_K;
}

static DIALOG shieldblockhelp_dlg[] =
{
    /* (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)      (d2)      (dp) */
//  { jwin_textbox_proc,    4,   2+21,   320-8,  240-6-21,  0,       0,      0,       0,          0,        0,        NULL, NULL, NULL },
    { jwin_win_proc,        0,   0,   320,  240,  0,       vc(15), 0,      D_EXIT,       0,          0, (void *) "Shield Block Flags Help", NULL, NULL },
    { jwin_frame_proc,   4,   23,   320-8,  240-27,   0,       0,      0,       0,             FR_DEEP,       0,       NULL, NULL, NULL },
    { d_editbox_proc,    6,   25,   320-8-4,  240-27-4,  0,       0,      0,       0/*D_SELECTED*/,          0,        0,       NULL, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,       0,      0,       0,          0,        KEY_ESC, (void *) close_dlg, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,       0,      0,       0,          0,        KEY_F12, (void *) onSnapshot, NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

void doshieldblockhelp(int32_t bg,int32_t fg)
{
    shieldblockhelp_dlg[0].dp2= get_custom_font(CFONT_TITLE);
    shieldblockhelp_dlg[2].dp = new EditboxModel(shieldblockhelpstr, new EditboxWordWrapView(&shieldblockhelp_dlg[2],get_custom_font(CFONT_TEXTBOX),fg,bg,BasicEditboxView::HSTYLE_EOTEXT),true);
    shieldblockhelp_dlg[2].bg = bg;
    zc_popup_dialog(shieldblockhelp_dlg,2);
    delete(EditboxModel*)(shieldblockhelp_dlg[2].dp);
}

int32_t onshieldblockhelp()
{
    restore_mouse();
    doshieldblockhelp(vc(15),vc(0));
    return D_O_K;
}

static DIALOG zscripthelp_dlg[] =
{
    /* (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)      (d2)      (dp) */
//  { jwin_textbox_proc,    4,   2+21,   320-8,  240-6-21,  0,       0,      0,       0,          0,        0,        NULL, NULL, NULL },
    { jwin_win_proc,        0,   0,   320,  240,  0,       vc(15), 0,      D_EXIT,       0,          0, (void *) "ZScript Help", NULL, NULL },
    { jwin_frame_proc,   4,   23,   320-8,  240-27,   0,       0,      0,       0,             FR_DEEP,       0,       NULL, NULL, NULL },
    { d_editbox_proc,    6,   25,   320-8-4,  240-27-4,  0,       0,      0,       0/*D_SELECTED*/,          0,        0,       NULL, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,       0,      0,       0,          0,        KEY_ESC, (void *) close_dlg, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,       0,      0,       0,          0,        KEY_F12, (void *) onSnapshot, NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

void dozscripthelp(int32_t bg,int32_t fg)
{
    zscripthelp_dlg[0].dp2= get_custom_font(CFONT_TITLE);
    zscripthelp_dlg[2].dp = new EditboxModel(zscripthelpstr, new EditboxWordWrapView(&zscripthelp_dlg[2],get_custom_font(CFONT_TEXTBOX),fg,bg,BasicEditboxView::HSTYLE_EOTEXT),true);
    zscripthelp_dlg[2].bg = bg;
    zc_popup_dialog(zscripthelp_dlg,2);
    delete(EditboxModel*)(zscripthelp_dlg[2].dp);
}

int32_t onZScripthelp()
{
    restore_mouse();
    dozscripthelp(vc(15),vc(0));
    return D_O_K;
}

static DIALOG Zstringshelp_dlg[] =
{
    /* (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)      (d2)      (dp) */
//  { jwin_textbox_proc,    4,   2+21,   320-8,  240-6-21,  0,       0,      0,       0,          0,        0,        NULL, NULL, NULL },
    { jwin_win_proc,        0,   0,   320,  240,  0,       vc(15), 0,      D_EXIT,       0,          0, (void *) "Zstrings Help", NULL, NULL },
    { jwin_frame_proc,   4,   23,   320-8,  240-27,   0,       0,      0,       0,             FR_DEEP,       0,       NULL, NULL, NULL },
    { d_editbox_proc,    6,   25,   320-8-4,  240-27-4,  0,       0,      0,       0/*D_SELECTED*/,          0,        0,       NULL, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,       0,      0,       0,          0,        KEY_ESC, (void *) close_dlg, NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,       0,      0,       0,          0,        KEY_F12, (void *) onSnapshot, NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

void doZstringshelp(int32_t bg,int32_t fg)
{
    Zstringshelp_dlg[0].dp2= get_custom_font(CFONT_TITLE);
    Zstringshelp_dlg[2].dp = new EditboxModel(zstringshelpstr, new EditboxWordWrapView(&Zstringshelp_dlg[2],get_custom_font(CFONT_TEXTBOX),fg,bg,BasicEditboxView::HSTYLE_EOTEXT),true);
    Zstringshelp_dlg[2].bg = bg;
    zc_popup_dialog(Zstringshelp_dlg,2);
    delete(EditboxModel*)(Zstringshelp_dlg[2].dp);
}

int32_t onZstringshelp()
{
    restore_mouse();
    doZstringshelp(vc(15),vc(0));
    return D_O_K;
}

static DIALOG layerdata_dlg[] =
{
    /* (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp) */
    { jwin_win_proc,     16-12,   20+32,   288+1+24,  200+1-32-16,  vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "Layer Data", NULL, NULL },
    { jwin_button_proc,     170,  180,  61,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { jwin_button_proc,     90,   180,  61,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "OK", NULL, NULL },
    // 3
    { jwin_rtext_proc,       72,   88,    40,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "Map:", NULL, NULL },
    { jwin_rtext_proc,       72,   88+18,    48,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "Screen:", NULL, NULL },
    { jwin_rtext_proc,       72,   88+36,    56,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "Transparent:", NULL, NULL },
    { jwin_ctext_proc,       89,  76,   8,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "1", NULL, NULL },
    { jwin_ctext_proc,       89+40,  76,   8,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "2", NULL, NULL },
    { jwin_ctext_proc,       89+80,  76,   8,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "3", NULL, NULL },
    { jwin_ctext_proc,       89+120,  76,   8,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "4", NULL, NULL },
    { jwin_ctext_proc,       89+160,  76,   8,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "5", NULL, NULL },
    { jwin_ctext_proc,       89+200,  76,   8,  8,    vc(11),  vc(1),  0,       0,          0,             0, (void *) "6", NULL, NULL },
    
    //12
    { jwin_edit_proc,      76,   76+8,   32-6,   16,    vc(12),  vc(1),  0,       0,          3,             0,       NULL, NULL, NULL },
    { d_hexedit_proc,      76,   76+18+8,   24-3,   16,    vc(12),  vc(1),  0,       0,          2,             0,       NULL, NULL, NULL },
    { jwin_check_proc,     76,   76+40+8,   17,   9,    vc(12),  vc(1),  0,       0,          1,             0,       NULL, NULL, NULL },
    
    { jwin_edit_proc,      76+40,   76+8,   32-6,   16,    vc(12),  vc(1),  0,       0,          3,             0,       NULL, NULL, NULL },
    { d_hexedit_proc,      76+40,   76+18+8,   24-3,   16,    vc(12),  vc(1),  0,       0,          2,             0,       NULL, NULL, NULL },
    { jwin_check_proc,     76+40,  76+40+8,   17,   9,    vc(12),  vc(1),  0,       0,          1,             0,       NULL, NULL, NULL },
    
    { jwin_edit_proc,      76+80,   76+8,   32-6,   16,    vc(12),  vc(1),  0,       0,          3,             0,       NULL, NULL, NULL },
    { d_hexedit_proc,      76+80,   76+18+8,   24-3,   16,    vc(12),  vc(1),  0,       0,          2,             0,       NULL, NULL, NULL },
    { jwin_check_proc,     76+80,  76+40+8,   17,   9,    vc(12),  vc(1),  0,       0,          1,             0,       NULL, NULL, NULL },
    
    { jwin_edit_proc,      76+120,   76+8,   32-6,   16,    vc(12),  vc(1),  0,       0,          3,             0,       NULL, NULL, NULL },
    { d_hexedit_proc,      76+120,   76+18+8,   24-3,   16,    vc(12),  vc(1),  0,       0,          2,             0,       NULL, NULL, NULL },
    { jwin_check_proc,     76+120,  76+40+8,   17,   9,    vc(12),  vc(1),  0,       0,          1,             0,       NULL, NULL, NULL },
    
    { jwin_edit_proc,      76+160,   76+8,   32-6,   16,    vc(12),  vc(1),  0,       0,          3,             0,       NULL, NULL, NULL },
    { d_hexedit_proc,      76+160,   76+18+8,   24-3,   16,    vc(12),  vc(1),  0,       0,          2,             0,       NULL, NULL, NULL },
    { jwin_check_proc,     76+160,  76+40+8,   17,   9,    vc(12),  vc(1),  0,       0,          1,             0,       NULL, NULL, NULL },
    
    { jwin_edit_proc,      76+200,   76+8,   32-6,   16,    vc(12),  vc(1),  0,       0,          3,             0,       NULL, NULL, NULL },
    { d_hexedit_proc,      76+200,   76+18+8,   24-3,   16,    vc(12),  vc(1),  0,       0,          2,             0,       NULL, NULL, NULL },
    { jwin_check_proc,     76+200,  76+40+8,   17,   9,    vc(12),  vc(1),  0,       0,          1,             0,       NULL, NULL, NULL },
    
    //30
    { jwin_button_proc,     76,  76+40+18+8,  30,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Auto", NULL, NULL },
    { jwin_button_proc,     76+40,  76+40+18+8,  30,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Auto", NULL, NULL },
    { jwin_button_proc,     76+80,  76+40+18+8,  30,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Auto", NULL, NULL },
    { jwin_button_proc,     76+120,  76+40+18+8,  30,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Auto", NULL, NULL },
    { jwin_button_proc,     76+160,  76+40+18+8,  30,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Auto", NULL, NULL },
    { jwin_button_proc,     76+200,  76+40+18+8,  30,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Auto", NULL, NULL },
    
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
    
};

int32_t edit_layers(mapscr* tempscr)
{
    char buf[6][2][8];
    layerdata_dlg[0].dp2 = lfont;
    
    for(int32_t x=0; x<6; x++)
    {
        sprintf(buf[x][0],"%d",tempscr->layermap[x]);
        sprintf(buf[x][1],"%02X",tempscr->layerscreen[x]);
    }
    
    for(int32_t x=0; x<6; x++)
    {
        for(int32_t y=0; y<2; y++)
        {
            layerdata_dlg[(x*3)+y+12].dp = buf[x][y];
        }
    }
    
    for(int32_t x=0; x<6; x++)
    {
        layerdata_dlg[(x*3)+2+12].flags = (tempscr->layeropacity[x]<255) ? D_SELECTED : 0;
    }
    
    if(is_large)
        large_dialog(layerdata_dlg);
        
    int32_t ret=zc_popup_dialog(layerdata_dlg,0);
    
    if(ret>=2)
    {
        for(int32_t x=0; x<6; x++)
        {
        
            tempscr->layermap[x]=atoi(buf[x][0]);
            
            if(tempscr->layermap[x]>map_count)
            {
                tempscr->layermap[x]=0;
            }
            
            tempscr->layerscreen[x]=zc_xtoi(buf[x][1]);
            
            if(zc_xtoi(buf[x][1])>=MAPSCRS)
            {
                tempscr->layerscreen[x]=0;
            }
            
            //      tempscr->layeropacity[x]=layerdata_dlg[(x*9)+8+19].flags & D_SELECTED ? 128:255;
            tempscr->layeropacity[x]=layerdata_dlg[(x*3)+2+12].flags & D_SELECTED ? 128:255;
        }
        
        //  } else if (ret>72&&ret<79) {
        //    return (ret-72);
    }
    
    return ret;
}

static DIALOG autolayer_dlg[] =
{
    /* (dialog proc)     (x)   (y)   (w)   (h)   (fg)     (bg)    (key)    (flags)     (d1)           (d2)     (dp) */
    { jwin_win_proc,        64,   32+48,   192+1,  184+1-64-28,  vc(14),  vc(1),  0,       D_EXIT,          0,             0, (void *) "Autolayer Setup", NULL, NULL },
    { jwin_text_proc,       76,   56+48,   136,   8,    vc(14),  vc(1),  0,       0,          0,             0, (void *) "Map for layer ?: ", NULL, NULL },
    { jwin_edit_proc,       212,  56+48,   32,   16,    vc(12),  vc(1),  0,       0,          3,             0,       NULL, NULL, NULL },
    { jwin_check_proc,      76,   56+18+48,   153,   8,    vc(14),  vc(1),  0,       0,          1,             0, (void *) "Overwrite current", NULL, NULL },
    
    //5
    { jwin_button_proc,     90,   188-40,  61,   21,   vc(14),  vc(1),  13,      D_EXIT,     0,             0, (void *) "OK", NULL, NULL },
    { jwin_button_proc,     170,  188-40,  61,   21,   vc(14),  vc(1),  27,      D_EXIT,     0,             0, (void *) "Cancel", NULL, NULL },
    { d_keyboard_proc,   0,    0,    0,    0,    0,    0,    0,       0,       KEY_F1,   0, (void *) onHelp, NULL, NULL },
    { d_timer_proc,         0,    0,     0,    0,    0,       0,       0,       0,          0,          0,         NULL, NULL, NULL },
    { NULL,                 0,    0,    0,    0,   0,       0,       0,       0,          0,             0,       NULL,                           NULL,  NULL }
};

void autolayer(mapscr* tempscr, int32_t layer, int32_t al[6][3])
{
    char tbuf[80],mlayer[80];
    autolayer_dlg[0].dp2=lfont;
    sprintf(tbuf, "Map for layer %d: ", layer+1);
    autolayer_dlg[1].dp=tbuf;
    sprintf(mlayer, "%d", tempscr->layermap[layer]);
    autolayer_dlg[2].dp=mlayer;
    
    if(is_large)
        large_dialog(autolayer_dlg);
        
    int32_t ret=zc_popup_dialog(autolayer_dlg,0);
    
    if(ret==4)
    {
        int32_t lmap=vbound(atoi(mlayer),0,Map.getMapCount());
        al[layer][0]=lmap;
        tempscr->layermap[layer]=lmap;
        tempscr->layerscreen[layer]=Map.getCurrScr();
        al[layer][1]=autolayer_dlg[3].flags & D_SELECTED?1:0;
        al[layer][2]=1;
    }
}

int32_t findblankcombo()
{
    for(int32_t i=0; i<MAXCOMBOS; i++)
    {
    
        if(!combobuf[i].flip&&!(combobuf[i].walk&0xF)&&!combobuf[i].type&&
                !combobuf[i].csets&&!combobuf[i].frames&&!combobuf[i].speed&&
                !combobuf[i].nextcombo&&!combobuf[i].nextcset&&
                blank_tile_table[combobuf[i].tile])
        {
            return i;
        }
    }
    
    return 0;
}

int32_t onLayers()
{
    mapscr tempscr=*Map.CurrScr();
    int32_t blankcombo=findblankcombo();
    int32_t al[6][3];                                             //autolayer[layer][0=map, 1=overwrite current][go]
    
    for(int32_t i=0; i<6; i++)
    {
        al[i][0]=tempscr.layermap[i];
        al[i][1]=0;
        al[i][2]=0;
    }
    
    int32_t ret;
    
    do
    {
        ret=edit_layers(&tempscr);
        
        if(ret>2)                                               //autolayer button
        {
            autolayer(&tempscr, ret-30, al);
        }
    }
    while(ret>2);                                             //autolayer button
    
    if(ret==2)                                                //OK
    {
        saved=false;
        TheMaps[Map.getCurrMap()*MAPSCRS+Map.getCurrScr()]=tempscr;
        
        for(int32_t i=0; i<6; i++)
        {
            int32_t tm=tempscr.layermap[i]-1;
            
            if(tm!=al[i][0]-1)
            {
                al[i][2]=0;
            }
            
            int32_t ts=tempscr.layerscreen[i];
            
            if(tm>0)
            {
                if(!(TheMaps[tm*MAPSCRS+ts].valid&mVALID))
                {
                    TheMaps[tm*MAPSCRS+ts].valid=mVALID+mVERSION;
                    
                    for(int32_t k=0; k<176; k++)
                    {
                        TheMaps[tm*MAPSCRS+ts].data[k]=blankcombo;
                    }
                }
            }
            
            if(al[i][2]>0)
            {
                for(int32_t j=0; j<128; j++)
                {
                    if((TheMaps[Map.getCurrMap()*MAPSCRS+j].layermap[i]==0) || (al[i][1]))
                    {
                        if(TheMaps[Map.getCurrMap()*MAPSCRS+j].layermap[i]==0)
                        {
                        }
                        
                        if((TheMaps[Map.getCurrMap()*MAPSCRS+j].layermap[i]==0) && (al[i][1]))
                        {
                        }
                        
                        if(al[i][1])
                        {
                        }
                        
                        TheMaps[Map.getCurrMap()*MAPSCRS+j].layermap[i]=al[i][0];
                        TheMaps[Map.getCurrMap()*MAPSCRS+j].layerscreen[i]=al[i][0]?j:0;
                        
                        if(al[i][0])
                        {
                            if(!(TheMaps[(al[i][0]-1)*MAPSCRS+j].valid&mVALID))
                            {
                                TheMaps[(al[i][0]-1)*MAPSCRS+j].valid=mVALID+mVERSION;
                                
                                for(int32_t k=0; k<176; k++)
                                {
                                    TheMaps[(al[i][0]-1)*MAPSCRS+j].data[k]=blankcombo;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    // Check that the working layer wasn't just disabled
    if(CurrentLayer>0 && tempscr.layermap[CurrentLayer-1]==0)
    {
        CurrentLayer=0;
    }
    
    return D_O_K;
}


char *itoa(int32_t i)
{
    static char itoaret[500];
    sprintf(itoaret, "%d", i);
    return itoaret;
}

void fps_callback()
{
    lastfps=framecnt;
    framecnt=0;
}

END_OF_FUNCTION(fps_callback)

//uint32_t col_diff[3*128];
/*
  void bestfit_init(void)
  {
  int32_t i;

  for (i=1; i<64; i++)

  {
  int32_t k = i * i;
  col_diff[0  +i] = col_diff[0  +128-i] = k * (59 * 59);
  col_diff[128+i] = col_diff[128+128-i] = k * (30 * 30);
  col_diff[256+i] = col_diff[256+128-i] = k * (11 * 11);
  }
  }
  */
void create_rgb_table2(RGB_MAP *table, AL_CONST PALETTE pal, void (*callback)(int32_t pos))
{
#define UNUSED 65535
#define LAST 65532

    /* macro add adds to single linked list */
#define add(i)    (next[(i)] == UNUSED ? (next[(i)] = LAST, \
                                          (first != LAST ? (next[last] = (i)) : (first = (i))), \
                                          (last = (i))) : 0)
    
    /* same but w/o checking for first element */
#define add1(i)   (next[(i)] == UNUSED ? (next[(i)] = LAST, \
                                          next[last] = (i), \
                                          (last = (i))) : 0)
    /* calculates distance between two colors */
#define dist(a1, a2, a3, b1, b2, b3) \
          (col_diff[ ((a2) - (b2)) & 0x7F] + \
           (col_diff + 128)[((a1) - (b1)) & 0x7F] + \
           (col_diff + 256)[((a3) - (b3)) & 0x7F])
    
    /* converts r,g,b to position in array and back */
#define pos(r, g, b) \
          (((r) / 2) * 32 * 32 + ((g) / 2) * 32 + ((b) / 2))
    
#define depos(pal, r, g, b) \
          ((b) = ((pal) & 31) * 2, \
           (g) = (((pal) >> 5) & 31) * 2, \
           (r) = (((pal) >> 10) & 31) * 2)
    
    /* is current color better than pal1? */
#define better(r1, g1, b1, pal1) \
          (((int32_t)dist((r1), (g1), (b1), \
                      (pal1).r, (pal1).g, (pal1).b)) > (int32_t)dist2)
    
    /* checking of position */
#define dopos(rp, gp, bp, ts) \
          if ((rp > -1 || r > 0) && (rp < 1 || r < 61) && \
              (gp > -1 || g > 0) && (gp < 1 || g < 61) && \
              (bp > -1 || b > 0) && (bp < 1 || b < 61)) \
        {                     \
          i = first + rp * 32 * 32 + gp * 32 + bp; \
          if (!data[i])       \
          {                   \
            data[i] = val;    \
            add1(i);          \
          }                   \
          else if ((ts) && (data[i] != val)) \
            {                 \
              dist2 = (rp ? (col_diff+128)[(r+2*rp-pal[val].r) & 0x7F] : r2) + \
                (gp ? (col_diff    )[(g+2*gp-pal[val].g) & 0x7F] : g2) + \
                (bp ? (col_diff+256)[(b+2*bp-pal[val].b) & 0x7F] : b2); \
              if (better((r+2*rp), (g+2*gp), (b+2*bp), pal[data[i]])) \
              {               \
                data[i] = val; \
                add1(i);      \
              }               \
            }                 \
        }
    
    int32_t i, curr, r, g, b, val, dist2;
    uint32_t r2, g2, b2;
    uint16_t next[32*32*32];
    uint8_t *data;
    int32_t first = LAST;
    int32_t last = LAST;
    int32_t count = 0;
    int32_t cbcount = 0;
    
#define AVERAGE_COUNT   18000
    
    if(col_diff[1] == 0)
        bestfit_init();
        
    memset(next, 255, sizeof(next));
    memset(table->data, 0, sizeof(char)*32*32*32);
    
    
    data = (uint8_t *)table->data;
    
    /* add starting seeds for floodfill */
    for(i=1; i<PAL_SIZE; i++)
    {
        curr = pos(pal[i].r, pal[i].g, pal[i].b);
        
        if(next[curr] == UNUSED)
        {
            data[curr] = i;
            add(curr);
        }
    }
    
    /* main floodfill: two versions of loop for faster growing in blue axis */
    //   while (first != LAST) {
    while(first < LAST)
    {
        depos(first, r, g, b);
        
        /* calculate distance of current color */
        val = data[first];
        r2 = (col_diff+128)[((pal[val].r)-(r)) & 0x7F];
        g2 = (col_diff)[((pal[val].g)-(g)) & 0x7F];
        b2 = (col_diff+256)[((pal[val].b)-(b)) & 0x7F];
        
        /* try to grow to all directions */
#ifdef _MSC_VER
#pragma warning(disable:4127)
#endif
        dopos(0, 0, 1, 1);
        dopos(0, 0,-1, 1);
        dopos(1, 0, 0, 1);
        dopos(-1, 0, 0, 1);
        dopos(0, 1, 0, 1);
        dopos(0,-1, 0, 1);
#ifdef _MSC_VER
#pragma warning(default:4127)
#endif
        
        /* faster growing of blue direction */
        if((b > 0) && (data[first-1] == val))
        {
            b -= 2;
            first--;
            b2 = (col_diff+256)[((pal[val].b)-(b)) & 0x7F];
            
#ifdef _MSC_VER
#pragma warning(disable:4127)
#endif
            dopos(-1, 0, 0, 0);
            dopos(1, 0, 0, 0);
            dopos(0,-1, 0, 0);
            dopos(0, 1, 0, 0);
#ifdef _MSC_VER
#pragma warning(default:4127)
#endif
            
            first++;
        }
        
        /* get next from list */
        i = first;
        first = next[first];
        next[i] = UNUSED;
        
        /* second version of loop */
        //      if (first != LAST) {
        if(first < LAST)
        {
        
            depos(first, r, g, b);
            
            val = data[first];
            r2 = (col_diff+128)[((pal[val].r)-(r)) & 0x7F];
            g2 = (col_diff)[((pal[val].g)-(g)) & 0x7F];
            b2 = (col_diff+256)[((pal[val].b)-(b)) & 0x7F];
            
#ifdef _MSC_VER
#pragma warning(disable:4127)
#endif
            dopos(0, 0, 1, 1);
            dopos(0, 0,-1, 1);
            dopos(1, 0, 0, 1);
            dopos(-1, 0, 0, 1);
            dopos(0, 1, 0, 1);
            dopos(0,-1, 0, 1);
#ifdef _MSC_VER
#pragma warning(default:4127)
#endif
            
            if((b < 61) && (data[first + 1] == val))
            {
                b += 2;
                first++;
                b2 = (col_diff+256)[((pal[val].b)-(b)) & 0x7f];
#ifdef _MSC_VER
#pragma warning(disable:4127)
#endif
                dopos(-1, 0, 0, 0);
                dopos(1, 0, 0, 0);
                dopos(0,-1, 0, 0);
                dopos(0, 1, 0, 0);
#ifdef _MSC_VER
#pragma warning(default:4127)
#endif
                
                first--;
            }
            
            i = first;
            first = next[first];
            next[i] = UNUSED;
        }
        
        count++;
        
        if(count == (cbcount+1)*AVERAGE_COUNT/256)
        {
            if(cbcount < 256)
            {
                if(callback)
                    callback(cbcount);
                    
                cbcount++;
            }
        }
        
    }
    
    /* only the transparent (pink) color can be mapped to index 0 */
    if((pal[0].r == 63) && (pal[0].g == 0) && (pal[0].b == 63))
        table->data[31][0][31] = 0;
        
    if(callback)
        while(cbcount < 256)
            callback(cbcount++);
}

void rebuild_trans_table()
{
    create_rgb_table2(&zq_rgb_table, RAMpal, NULL);
    create_zc_trans_table(&trans_table, RAMpal, 128, 128, 128);
    memcpy(&trans_table2, &trans_table, sizeof(COLOR_MAP));
    
    for(int32_t q=0; q<PAL_SIZE; q++)
    {
        trans_table2.data[0][q] = q;
        trans_table2.data[q][q] = q;
    }
}

int32_t isFullScreen()
{
    return !is_windowed_mode();
}

void hit_close_button()
{
    close_button_quit=true;
    return;
}

/********************/
/******  MAIN  ******/
/********************/

/*
  enum { jcBOX, jcLIGHT, jcMEDLT, jcMEDDARK, jcDARK, jcBOXFG,
  jcTITLEL, jcTITLER, jcTITLEFG, jcTEXTBG, jcTEXTFG, jcSELBG, jcSELFG,
  jcMAX };

  enum { light gray, white, off-white, gray, dark gray, black,
  jcTITLEL, jcTITLER, jcTITLEFG, jcTEXTBG, jcTEXTFG, jcSELBG, jcSELFG,
  jcMAX };
  */

extern bool dirty_screen;

/*
  static int32_t jwin_pal[jcMAX] =
  {
  vc(11),vc(15),vc(4),vc(7),vc(6),vc(0),
  192,223,vc(14),vc(15),vc(0),vc(1),vc(14)
  };
  */
void custom_vsync()
{
    ++framecnt;
    
    if(prv_mode)
    {
        if(Map.get_prvtime())
        {
            Map.set_prvtime(Map.get_prvtime()-1);
            
            if(!Map.get_prvtime())
            {
                prv_warp=1;
            }
        }
    }
    
    while(!myvsync) rest(1);
    
	update_hw_screen();
    
    myvsync=0;
    
    if(Vsync)
    {
        //vsync();
    }
}

void switch_out()
{
	zcmusic_pause(zcmusic, ZCM_PAUSE);
	zc_midi_pause();
}

void switch_in()
{
	if(quit)
		return;
	
	/*
	if (!is_large) 
	{
		dialogs[0].dp = (void *) the_menu;
	}
	else dialogs[0].dp = (void *) the_menu_large;
	*/
	//dialogs[0].dp2 = z3font;
	//jwin_menu_proc(MSG_DRAW, &dialogs[0], 0);
	
	zcmusic_pause(zcmusic, ZCM_RESUME);
	zc_midi_resume();
}

void Z_eventlog(const char *format,...)
{
    format=format; //to prevent a compiler warning
}

int32_t get_currdmap()
{
    return zinit.start_dmap;
}

int32_t get_dlevel()
{
    return DMaps[zinit.start_dmap].level;
}

int32_t get_currscr()
{
    return Map.getCurrScr();
}

int32_t get_currmap()
{
    return Map.getCurrMap();
}

int32_t get_homescr()
{
    return DMaps[zinit.start_dmap].cont;
}

int32_t current_item(int32_t item_type)
{
    //TODO remove as special case?? -DD
    if(item_type==itype_shield)
    {
        return 2;
    }
    
    //find lowest item of that class
    int32_t lowestid = -1;
    int32_t ret = 0;
    
    for(int32_t i=0; i<MAXITEMS; i++)
    {
        if(itemsbuf[i].family == item_type && (lowestid==-1 || itemsbuf[i].fam_type < ret))
        {
            lowestid = i;
            ret = itemsbuf[i].fam_type;
        }
    }
    
    return ret;
}

int32_t current_item_power(int32_t itemtype)
{
    itemtype=itemtype;
    return 1;
}

int32_t current_item_id(int32_t itemtype, bool checkmagic, bool smart_jinx)
{
    checkmagic=checkmagic;
    
    for(int32_t i=0; i<MAXITEMS; i++)
    {
        if(itemsbuf[i].family==itemtype)
            return i;
    }
    
    return -1;
}


bool can_use_item(int32_t item_type, int32_t item)
{
    //these are here to bypass compiler warnings about unused arguments
    item_type=item_type;
    item=item;
    
    return true;
}

bool has_item(int32_t item_type, int32_t it)
{
    //these are here to bypass compiler warnings about unused arguments
    item_type=item_type;
    it=it;
    
    return true;
}

int32_t get_bmaps(int32_t si)
{
    //these are here to bypass compiler warnings about unused arguments
    si=si;
    
    return 255;
}

bool no_subscreen()
{
    return false;
}

int32_t Awpn=0, Bwpn=0, Bpos=0, Xwpn = 0, Ywpn = 0;
sprite_list  guys, items, Ewpns, Lwpns, Sitems, chainlinks, decorations;
int32_t exittimer = 10000, exittimer2 = 100;

int32_t main(int32_t argc,char **argv)
{
#if (defined(_DEBUG) && defined(_MSC_VER))
#if (VLD_FORCE_ENABLE == 0)
	//::InitCrtDebug();
#endif // (VLD_FORCE_ENABLE == 0)
#endif // (defined(_DEBUG) && defined(_MSC_VER))

	common_main_setup(App::zquest, argc, argv);
	set_should_zprint_cb([]() {
		return get_bit(quest_rules,qr_SCRIPTERRLOG) || DEVLEVEL > 0;
	});

	Z_title("%s, v.%s %s",ZQ_EDITOR_NAME, ZQ_EDITOR_V, ALPHA_VER_STR);

	//InitCrtDebug();
	
	// Before anything else, let's register our custom trace handler:
	register_trace_handler(zc_trace_handler);
	
	/*
		// Initialize SDL
		if ( SDL_Init(SDL_INIT_VIDEO) < 0 ) {
			fprintf(stderr, "Couldn't initialize SDL: %s\n",SDL_GetError());
			return(1);
		}
	
		// Initialize the display
		int32_t w=LARGE_W, h=LARGE_H;
		int32_t desired_bpp=8;
		Uint32 video_flags=SDL_HWSURFACE|SDL_HWPALETTE;
		sdl_screen = SDL_SetVideoMode(w, h, desired_bpp, video_flags);
		if ( sdl_screen == NULL ) {
			fprintf(stderr, "Couldn't set %dx%dx%d video mode: %s\n",
						w, h, desired_bpp, SDL_GetError());
			exit(1);
		}
	
		// Set the window manager title bar
		SDL_WM_SetCaption("SDL test window", "testwin");
	*/
	
	//FFScript::init();
	memrequested+=sizeof(zctune)*MAXCUSTOMMIDIS_ZQ;
	Z_message("Allocating tunes buffer (%s)... ", byte_conversion2(sizeof(zctune)*MAXCUSTOMMIDIS_ZQ,memrequested,-1,-1));
	customtunes = (zctune*)malloc(sizeof(class zctune)*MAXCUSTOMMIDIS_ZQ);
	memset(customtunes, 0, sizeof(class zctune)*MAXCUSTOMMIDIS_ZQ);
	
	/*
	FFCore.ZScriptConsole
				(
				
				CConsoleLoggerEx::COLOR_RED |CConsoleLoggerEx::COLOR_INTENSITY | 
				CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"%s, v.%s Alpha %d",ZQ_EDITOR_NAME, ZQ_EDITOR_V, V_ZC_ALPHA
				);*/
	
	if(!customtunes)
	{

	/*FFCore.ZScriptConsole
	(
		CConsoleLoggerEx::COLOR_RED |CConsoleLoggerEx::COLOR_INTENSITY | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"ZQuest Creator I/O Error: %s\n", 
			"Failed to load custom music files."
	);
		*/

		Z_error_fatal("Error");
		quit_game();
	}
	
	Z_message("OK\n");									  // Allocating MIDI buffer...
	
	/*memrequested+=sizeof(emusic)*MAXMUSIC;
	Z_message("Allocating Enhanced Music buffer (%s)... ", byte_conversion2(sizeof(emusic)*MAXMUSIC,memrequested,-1,-1));
	enhancedMusic = (emusic*)malloc(sizeof(emusic)*MAXMUSIC);
	if(!enhancedMusic)
	{
	  Z_error_fatal("Error");
	}
	Z_message("OK\n");									  // Allocating Enhanced Music buffer...
	*/
	if(!get_qst_buffers())
	{

	/*FFCore.ZScriptConsole
	(
		CConsoleLoggerEx::COLOR_RED |CConsoleLoggerEx::COLOR_INTENSITY | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"ZQuest Creator I/O Error: %s\n", 
		"Failed to load quest buffers."
	);*/
		

		Z_error_fatal("Error");
		quit_game();
	}
	
	memrequested+=sizeof(newcombo)*MAXCOMBOS;
	Z_message("Allocating combo undo buffer (%s)... ", byte_conversion2(sizeof(newcombo)*MAXCOMBOS,memrequested,-1,-1));
	undocombobuf = (newcombo*)malloc(sizeof(newcombo)*MAXCOMBOS);
	
	if(!undocombobuf)
	{

	/*FFCore.ZScriptConsole
	(
		CConsoleLoggerEx::COLOR_RED |CConsoleLoggerEx::COLOR_INTENSITY | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"ZQuest Creator I/O Error: %s\n", 
		"No memory for combo undo buffer!"
	);*/

		Z_error_fatal("Error: no memory for combo undo buffer!");
		quit_game();
	}
	
	Z_message("OK\n");									  // Allocating combo undo buffer...
	
	memrequested+=(NEWMAXTILES*sizeof(tiledata));
	Z_message("Allocating new tile undo buffer (%s)... ", byte_conversion2(NEWMAXTILES*sizeof(tiledata),memrequested,-1,-1));
	
	if((newundotilebuf=(tiledata*)malloc(NEWMAXTILES*sizeof(tiledata)))==NULL)
	{
		Z_error_fatal("Error: no memory for tile undo buffer!");
		quit_game();
	}
	
	memset(newundotilebuf, 0, NEWMAXTILES*sizeof(tiledata));
	Z_message("OK\n");										// Allocating new tile buffer...
	
	Z_message("Resetting new tile buffer...");
	newtilebuf = (tiledata*)malloc(NEWMAXTILES*sizeof(tiledata));
	
	for(int32_t j=0; j<NEWMAXTILES; j++)
		newtilebuf[j].data=NULL;
		
	Z_message("OK\n");
	
	memrequested+=(2048*5);
	Z_message("Allocating file path buffers (%s)... ", byte_conversion2(2048*7,memrequested,-1,-1));
	filepath=(char*)malloc(2048);
	temppath=(char*)malloc(2048);
	datapath=(char*)malloc(2048);
	midipath=(char*)malloc(2048);
	imagepath=(char*)malloc(2048);
	tmusicpath=(char*)malloc(2048);
	last_timed_save=(char*)malloc(2048);
	
	if(!filepath || !datapath || !temppath || !imagepath || !midipath || !tmusicpath || !last_timed_save)
	{

	/*FFCore.ZScriptConsole
	(
		CConsoleLoggerEx::COLOR_RED |CConsoleLoggerEx::COLOR_INTENSITY | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"ZQuest Creator I/O Error: %s\n", 
		"No memory for file paths!"
	);
		*/

		Z_error_fatal("Error: no memory for file paths!");
		quit_game();
	}
	
	Z_message("OK\n");									  // Allocating file path buffers...
	
	zc_srand(time(0));
	
	
	set_uformat(U_ASCII);

	Z_message("Initializing Allegro... ");
	if(!al_init())
	{
		Z_error_fatal("Failed Init!");
		quit_game();
	}
	if(allegro_init() != 0)
	{
		Z_error_fatal("Failed Init!");
		quit_game();
	}

	// Merge old a4 config into a5 system config.
	ALLEGRO_CONFIG *tempcfg = al_load_config_file(get_config_file_name());
	if (tempcfg) {
		al_merge_config_into(al_get_system_config(), tempcfg);
		al_destroy_config(tempcfg);
	}

	three_finger_flag=false;
	if(!al_init_image_addon())
	{
		Z_error_fatal("Failed al_init_image_addon");
		quit_game();
	}

	al5img_init();
	register_png_file_type();

	if(!al_install_audio())
	{
		// We can continue even with no audio.
		Z_error("Failed al_install_audio");
	}

	if(!al_init_acodec_addon())
	{
		Z_error("Failed al_init_acodec_addon");
	}

	all_disable_threaded_display();

#ifdef __EMSCRIPTEN__
	em_mark_initializing_status();
	em_init_fs();
#endif

#ifndef __EMSCRIPTEN__
	if(zc_get_config("zquest","open_debug_console",0) || DEVLEVEL)
		initConsole();
#endif

	if(install_timer() < 0)
	{
		Z_error_fatal(allegro_error);
		quit_game();
	}
	
	if(install_keyboard() < 0)
	{
		Z_error_fatal(allegro_error);
		quit_game();
	}
	
	if(install_mouse() < 0)
	{
		Z_error_fatal(allegro_error);
		quit_game();
	}
	
	LOCK_VARIABLE(lastfps);
	
	LOCK_VARIABLE(framecnt);
	LOCK_FUNCTION(fps_callback);
	
	if(install_int_ex(fps_callback,SECS_TO_TIMER(1)))
	{
		Z_error_fatal("couldn't allocate timer");
		quit_game();
	}
	
	
	LOCK_VARIABLE(dclick_status);
	LOCK_VARIABLE(dclick_time);
	lock_dclick_function();
	install_int(dclick_check, 20);
	
	set_gfx_mode(GFX_TEXT,80,50,0,0);
	
	Z_message("OK\n");									  // Initializing Allegro...
	
	//Initialise MODULES
	//We'll read the data files from them, in the future, so this MUST occur here!
	zcm.init(true);
	
	Z_message("Loading data files:\n");
	
	resolve_password(datapwd);
	packfile_password(datapwd);
	
	
	sprintf(fontsdat_sig,"Fonts.Dat %s Build %d",VerStr(FONTSDAT_VERSION), FONTSDAT_BUILD);
	
	Z_message("Fonts.Dat...");
	
	if((fontsdata=load_datafile(moduledata.datafiles[fonts_dat]))==NULL)
	{

	FFCore.ZScriptConsole
	(
		CConsoleLoggerEx::COLOR_RED |CConsoleLoggerEx::COLOR_INTENSITY | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"ZQuest Creator I/O Error: \n%s\n", 
		"Failed to load fonts datafile!\nZQuest Creator cannot run without this file,\nand is now exiting.\n"
	);

		Z_error_fatal("failed");
		quit_game();
	}
	
	if(strncmp((char*)fontsdata[0].dat,fontsdat_sig,24))
	{

	FFCore.ZScriptConsole
	(
		CConsoleLoggerEx::COLOR_RED |CConsoleLoggerEx::COLOR_INTENSITY | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"ZQuest Creator I/O Error:\nIncompatible version of fonts.dat.\nZQuest Creator cannot run without this file,\nand is now exiting.\nPlease upgrade to %s Build %d",VerStr(FONTSDAT_VERSION), FONTSDAT_BUILD);
		Z_error_fatal("\nIncompatible version of fonts.dat.\nPlease upgrade to %s Build %d",VerStr(FONTSDAT_VERSION), FONTSDAT_BUILD
	);

		quit_game();
	}
	
	Z_message("OK\n");
	
	Z_message("ZQuest.Dat...");
	
	if((zcdata=load_datafile(moduledata.datafiles[zquest_dat]))==NULL)
	{

	FFCore.ZScriptConsole
	(
		CConsoleLoggerEx::COLOR_RED |CConsoleLoggerEx::COLOR_INTENSITY | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"ZQuest Creator I/O Error: \n%s\n", 
		"Failed to load ZQ Creator datafile!\nZQuest Creator cannot run without this file,\nand is now exiting.\n"
	);

		Z_error_fatal("failed");
		quit_game();
	}
	
	datafile_str=moduledata.datafiles[zquest_dat];
	Z_message("OK\n");
	
	strcpy(qstdat_str,moduledata.datafiles[qst_dat]);
	strcat(qstdat_str,"#_SIGNATURE");
	//al_trace("qstdat_str is: %s\n", qstdat_str);
	
	sprintf(qstdat_sig,"QST.Dat %s Build %d",VerStr(QSTDAT_VERSION), QSTDAT_BUILD);
	
	Z_message("QST.Dat...");
	
	//PACKFILE *f=pack_fopen_password("qst.dat#_SIGNATURE", F_READ_PACKED, datapwd);
	//PACKFILE *f=pack_fopen_password("classic_qst.dat#_SIGNATURE", F_READ_PACKED, datapwd);
	PACKFILE *f=pack_fopen_password(qstdat_str, F_READ_PACKED, datapwd);
	
	if(!f)
	{

	FFCore.ZScriptConsole
	(
		CConsoleLoggerEx::COLOR_RED |CConsoleLoggerEx::COLOR_INTENSITY | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"ZQuest Creator I/O Error: \n%s\n", 
		"Failed to load quest datafile!\nZQuest Creator cannot run without this file,\nand is now exiting.\n"
	);

		Z_error_fatal("failed");
		quit_game();
	}
	
	char qstdat_read_sig[52];
	memset(qstdat_read_sig, 0, 52);
	int32_t pos=0;
	
	while(!pack_feof(f))
	{
		if(!p_getc(&(qstdat_read_sig[pos++]),f,true))
		{
			pack_fclose(f);
			Z_error_fatal("failed");
			quit_game();
		}
	}
	
	pack_fclose(f);
	
	if(strncmp(qstdat_read_sig,qstdat_sig,22))
	{

	FFCore.ZScriptConsole
	(
		CConsoleLoggerEx::COLOR_RED |CConsoleLoggerEx::COLOR_INTENSITY | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"ZQuest Creator I/O Error:\nIncompatible version of qst.dat.\nZQuest Creator cannot run without this file,\nand is now exiting.\nPlease upgrade to %s Build %d",VerStr(QSTDAT_VERSION), QSTDAT_BUILD);	
	
		Z_error_fatal("\nIncompatible version of qst.dat.\nPlease upgrade to %s Build %d",VerStr(QSTDAT_VERSION), QSTDAT_BUILD
	);

		quit_game();
	}
	
	Z_message("OK\n");
	
	
	//setPackfilePassword(NULL);
	packfile_password("");
	
	sprintf(sfxdat_sig,"SFX.Dat %s Build %d",VerStr(SFXDAT_VERSION), SFXDAT_BUILD);
	
	Z_message("SFX.Dat...");
	
	if((sfxdata=load_datafile(moduledata.datafiles[sfx_dat]))==NULL)
	{

	FFCore.ZScriptConsole
	(
		CConsoleLoggerEx::COLOR_RED |CConsoleLoggerEx::COLOR_INTENSITY | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"ZQuest Creator I/O Error: \n%s\n", 
		"Failed to load SFX datafile!\nZQuest Creator cannot run without this file,\nand is now exiting.\n"
	);

		Z_error_fatal("failed %s", allegro_error);
		quit_game();
	}
	
	if(strncmp((char*)sfxdata[0].dat,sfxdat_sig,22) || sfxdata[Z35].type != DAT_ID('S', 'A', 'M', 'P'))
	{

	FFCore.ZScriptConsole
	(
		CConsoleLoggerEx::COLOR_RED |CConsoleLoggerEx::COLOR_INTENSITY | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"ZQuest Creator I/O Error:\nIncompatible version of sfx.dat.\nZQuest Creator cannot run without this file,\nand is now exiting.\nPlease upgrade to %s Build %d",VerStr(SFXDAT_VERSION), SFXDAT_BUILD);
		quit_game();
		Z_error_fatal("\nIncompatible version of sfx.dat.\nPlease upgrade to %s Build %d",VerStr(SFXDAT_VERSION), SFXDAT_BUILD
	);

		quit_game();
	}
	
	Z_message("OK\n");
	
	initFonts();
	
	for(int32_t i=0; i<MAXCUSTOMTUNES; i++)
	{
		customtunes[i].data=NULL;
		midi_string[i+4]=customtunes[i].title;
	}
	
	for(int32_t i=0; i<MAXCUSTOMTUNES; i++)
	{
		customtunes[i].data=NULL;
		screen_midi_string[i+5]=customtunes[i].title;
	}
	
	for(int32_t i=0; i<4; i++)
	{
		for(int32_t j=0; j<MAXSUBSCREENITEMS; j++)
		{
			memset(&custom_subscreen[i].objects[j],0,sizeof(subscreen_object));
		}
	}
	
	int32_t helpsize = file_size_ex_password("docs/zquest.txt","");
	
	if(helpsize==0)
	{
	helpsize = file_size_ex_password("zquest.txt","");
	if(helpsize==0)
	{
		Z_error_fatal("Error: zquest.txt not found.");
		quit_game();
	}
	}
	
	helpbuf = (char*)malloc(helpsize<65536?65536:helpsize*2+1);
	
	if(!helpbuf)
	{
		FFCore.ZScriptConsole
		(
			CConsoleLoggerEx::COLOR_RED |CConsoleLoggerEx::COLOR_INTENSITY | 
				CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"ZQuest Creator Memory Error: \n%s\n", 
			"Failed to allocate EWditor Help buffer!\nZQuest Creator cannot run without this allocation,\nand is now exiting.\n"
		);

		Z_error_fatal("Error allocating help buffer.");
		quit_game();
	}
	
	//if(!readfile("zquest.txt",helpbuf,helpsize))
	FILE *hb = fopen("docs/zquest.txt", "r");
	
	if(!hb)
	{
	hb = fopen("zquest.txt", "r");
	if(!hb)
	{

		FFCore.ZScriptConsole
		(
			CConsoleLoggerEx::COLOR_RED |CConsoleLoggerEx::COLOR_INTENSITY | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"ZQuest Creator I/O Error: \n%s\n", 
			"Failed to read zquest.txt!\nZQuest Creator cannot run without this file,\nand is now exiting.\n"
		);

		Z_error_fatal("Error loading zquest.txt.");
		quit_game();
	}
	}
	
	char c = fgetc(hb);
	int32_t index=0;
	
	while(!feof(hb))
	{
		helpbuf[index] = c;
		index++;
		c = fgetc(hb);
	}
	
	fclose(hb);
	
	helpbuf[helpsize]=0;
	helpstr = helpbuf;
	Z_message("Found zquest.txt\n");									  // loading data files...
	
	int32_t shieldblockhelpsize = file_size_ex_password("docs/shield_block_flags.txt","");
	
	if(shieldblockhelpsize==0)
	{
	shieldblockhelpsize = file_size_ex_password("shield_block_flags.txt","");
	if(shieldblockhelpsize==0)
	{

		FFCore.ZScriptConsole
		(
			CConsoleLoggerEx::COLOR_RED |CConsoleLoggerEx::COLOR_INTENSITY | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"ZQuest Creator I/O Error: \n%s\n", 
			"shield_block_flags.txt not found!\nZQuest Creator cannot run without this file,\nand is now exiting.\n"
		);

		Z_error_fatal("Error: shield_block_flags.txt not found.");
		quit_game();
	}
	}
	
	shieldblockhelpbuf = (char*)malloc(shieldblockhelpsize<65536?65536:shieldblockhelpsize*2+1);
	
	if(!shieldblockhelpbuf)
	{

	FFCore.ZScriptConsole
	(
		CConsoleLoggerEx::COLOR_RED |CConsoleLoggerEx::COLOR_INTENSITY | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"ZQuest Creator Memory Error: \n%s\n", 
		"Failed allocating shieldblockhelp buffer!\nZQuest Creator cannot run without this allocation,\nand is now exiting.\n"
	);

		Z_error_fatal("Error allocating shieldblockhelp buffer.");
		quit_game();
	}
	
	FILE *shieldhb = fopen("docs/shield_block_flags.txt", "r");
	
	if(!shieldhb)
	{
	shieldhb = fopen("shield_block_flags.txt", "r");
	if(!shieldhb)
	{

		FFCore.ZScriptConsole
		(
			CConsoleLoggerEx::COLOR_RED |CConsoleLoggerEx::COLOR_INTENSITY | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"ZQuest Creator I/O Error: \n%s\n", 
			"Failed loading shield_block_flags.txt!\nZQuest Creator cannot run without this file,\nand is now exiting.\n"
		);

		Z_error_fatal("Error loading shield_block_flags.txt.");
		quit_game();
	}
	}
	
	char shieldc = fgetc(shieldhb);
	int32_t shieldhelpindex=0;
	
	while(!feof(shieldhb))
	{
		shieldblockhelpbuf[shieldhelpindex] = shieldc;
		shieldhelpindex++;
		shieldc = fgetc(shieldhb);
	}
	
	fclose(shieldhb);
	
	shieldblockhelpbuf[shieldblockhelpsize]=0;
	shieldblockhelpstr = shieldblockhelpbuf;
	Z_message("Found shield_block_flags.txt\n");	
	
	int32_t zscripthelpsz = file_size_ex_password("docs/zscript.txt","");
	
	if(zscripthelpsz==0)
	{
	zscripthelpsz = file_size_ex_password("zscript.txt",""); //LOOK IN 'DOCS/', THEN TRY ROOT
	if(zscripthelpsz==0)
	{

		FFCore.ZScriptConsole
		(
			CConsoleLoggerEx::COLOR_RED |CConsoleLoggerEx::COLOR_INTENSITY | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"ZQuest Creator I/O Error: \n%s\n", 
			"zscript.txt not found!\nZQuest Creator cannot run without this file,\nand is now exiting.\n"
		);

		Z_error_fatal("Error: zscript.txt not found.");
		quit_game();
	}
	}
	
	zscripthelpbuf = (char*)malloc(zscripthelpsz<65536?65536:zscripthelpsz*2+1);
	
	if(!zscripthelpbuf)
	{

	FFCore.ZScriptConsole
	(
		CConsoleLoggerEx::COLOR_RED |CConsoleLoggerEx::COLOR_INTENSITY | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"ZQuest Creator Memory Error: \n%s\n", 
		"Failed allocating ZScript Help buffer!\nZQuest Creator cannot run without this allocation,\nand is now exiting.\n"
	);

		Z_error_fatal("Error allocating ZScript Help buffer.");
		quit_game();
	}
	
	FILE *zscripthelphb = fopen("docs/zscript.txt", "r");
	
	if(!zscripthelphb)
	{
	zscripthelphb = fopen("zscript.txt", "r");
	if(!zscripthelphb)
	{

		FFCore.ZScriptConsole
		(
			CConsoleLoggerEx::COLOR_RED |CConsoleLoggerEx::COLOR_INTENSITY | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"ZQuest Creator I/O Error: \n%s\n", 
		"Failed loading zscript.txt!\nZQuest Creator cannot run without this file,\nand is now exiting.\n"
		);

		Z_error_fatal("Error loading zscript.txt.");
		quit_game();
	}
	}
	
	char zscripthelpc = fgetc(zscripthelphb);
	int32_t zscripthelpindex=0;
	
	while(!feof(zscripthelphb))
	{
		zscripthelpbuf[zscripthelpindex] = zscripthelpc;
		zscripthelpindex++;
		zscripthelpc = fgetc(zscripthelphb);
	}
	
	fclose(zscripthelphb);
	
	zscripthelpbuf[zscripthelpsz]=0;
	zscripthelpstr = zscripthelpbuf;
	Z_message("Found zscript.txt\n");	
	
	int32_t zstringshelpsz = file_size_ex_password("docs/zstrings.txt","");
	
	if(zstringshelpsz==0)
	{
	zstringshelpsz = file_size_ex_password("zstrings.txt",""); //LOOK IN 'DOCS/', THEN TRY ROOT
	if(zstringshelpsz==0)
	{

		FFCore.ZScriptConsole
		(
			CConsoleLoggerEx::COLOR_RED |CConsoleLoggerEx::COLOR_INTENSITY | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"ZQuest Creator I/O Error: \n%s\n", 
			"zstrings.txt not found!\nZQuest Creator cannot run without this file,\nand is now exiting.\n"
		);

		Z_error_fatal("Error: zstrings.txt not found.");
		quit_game();
	}
	}
	
	zstringshelpbuf = (char*)malloc(zstringshelpsz<65536?65536:zstringshelpsz*2+1);
	
	if(!zstringshelpbuf)
	{

	FFCore.ZScriptConsole
	(
		CConsoleLoggerEx::COLOR_RED |CConsoleLoggerEx::COLOR_INTENSITY | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"ZQuest Creator Memory Error: \n%s\n", 
		"Failed allocating zstrings Help buffer!\nZQuest Creator cannot run without this allocation,\nand is now exiting.\n"
	);

		Z_error_fatal("Error allocating zstrings Help buffer.");
		quit_game();
	}
	
	FILE *zstringshelphb = fopen("docs/zstrings.txt", "r");
	
	if(!zstringshelphb)
	{
	zstringshelphb = fopen("zstrings.txt", "r");
	if(!zstringshelphb)
	{

		FFCore.ZScriptConsole
		(
			CConsoleLoggerEx::COLOR_RED |CConsoleLoggerEx::COLOR_INTENSITY | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"ZQuest Creator I/O Error: \n%s\n", 
			"Failed loading zstrings.txt!\nZQuest Creator cannot run without this file,\nand is now exiting.\n"
		);

		Z_error_fatal("Error loading zstrings.txt.");
		quit_game();
	}
	}
	
	char zstringshelpc = fgetc(zstringshelphb);
	int32_t zstringshelpindex=0;
	
	while(!feof(zstringshelphb))
	{
		zstringshelpbuf[zstringshelpindex] = zstringshelpc;
		zstringshelpindex++;
		zstringshelpc = fgetc(zstringshelphb);
	}
	
	fclose(zstringshelphb);
	
	zstringshelpbuf[zstringshelpsz]=0;
	zstringshelpstr = zstringshelpbuf;
	Z_message("Found zstrings.txt\n");							   
	
	// loading data files...
	
	
	init_qts();
	
	filepath[0]=temppath[0]=0;
	
	const char *default_path="";
	
	strcpy(datapath,zc_get_config("zquest",data_path_name,default_path));
	strcpy(midipath,zc_get_config("zquest",midi_path_name,default_path));
	strcpy(imagepath,zc_get_config("zquest",image_path_name,default_path));
	strcpy(tmusicpath,zc_get_config("zquest",tmusic_path_name,default_path));
	chop_path(datapath);
	chop_path(midipath);
	chop_path(imagepath);
	chop_path(tmusicpath);
	
	DisableLPalShortcuts        = zc_get_config("zquest","dis_lpal_shortcut",1);
	DisableCompileConsole        = zc_get_config("zquest","internal_compile_console",0);
	MouseScroll					= zc_get_config("zquest","mouse_scroll",0);
	WarnOnInitChanged			  = zc_get_config("zquest","warn_initscript_changes",1);
	InvalidStatic				  = zc_get_config("zquest","invalid_static",1);
	MMapCursorStyle				= zc_get_config("zquest","cursorblink_style",1);
	TileProtection				 = zc_get_config("zquest","tile_protection",1);
	ShowGrid					   = zc_get_config("zquest","show_grid",0);
	GridColor					  = zc_get_config("zquest","grid_color",15);
	SnapshotFormat				 = zc_get_config("zquest","snapshot_format",3);
	SavePaths					  = zc_get_config("zquest","save_paths",1);
	CycleOn						= zc_get_config("zquest","cycle_on",1);
	Vsync						  = zc_get_config("zquest","vsync",1)!=0;
	ShowFPS						= zc_get_config("zquest","showfps",0)!=0;
	SaveDragResize						= zc_get_config("zquest","save_drag_resize",0)!=0;
	DragAspect						= zc_get_config("zquest","drag_aspect",0)!=0;
	SaveWinPos						= zc_get_config("zquest","save_window_position",0)!=0;
	ComboBrush					 = zc_get_config("zquest","combo_brush",0);
	FloatBrush					 = zc_get_config("zquest","float_brush",0);
	UseSmall					   = zc_get_config("zquest","small",0);
	RulesetDialog				  = zc_get_config("zquest","rulesetdialog",1);
	EnableTooltips				 = zc_get_config("zquest","enable_tooltips",1);
	TooltipsHighlight				 = zc_get_config("zquest","ttip_highlight",1);
	tooltip_maxtimer				 = vbound(zc_get_config("zquest","ttip_timer",30),15,60*60);
	ShowFFScripts				  = zc_get_config("zquest","showffscripts",1);
	ShowSquares					= zc_get_config("zquest","showsquares",1);
	ShowFFCs					= zc_get_config("zquest","showffcs",0);
	ShowInfo					   = zc_get_config("zquest","showinfo",1);
	skipLayerWarning			   = zc_get_config("zquest","skip_layer_warning",0);
	numericalFlags			  	 = zc_get_config("zquest","numerical_flags",0);
	
	OpenLastQuest				  = zc_get_config("zquest","open_last_quest",0);
	ShowMisalignments			  = zc_get_config("zquest","show_misalignments",0);
	AnimationOn					= zc_get_config("zquest","animation_on",1);
	AutoBackupRetention			= zc_get_config("zquest","auto_backup_retention",2);
	AutoSaveInterval			   = zc_get_config("zquest","auto_save_interval",6);
	AutoSaveRetention			  = zc_get_config("zquest","auto_save_retention",2);
	UncompressedAutoSaves		  = zc_get_config("zquest","uncompressed_auto_saves",1);
	OverwriteProtection			= zc_get_config("zquest","overwrite_prevention",0)!=0;
	ImportMapBias				  = zc_get_config("zquest","import_map_bias",0);
	
	KeyboardRepeatDelay		   = zc_get_config("zquest","keyboard_repeat_delay",300);
	KeyboardRepeatRate			= zc_get_config("zquest","keyboard_repeat_rate",80);
	
//  Frameskip					 = zc_get_config("zquest","frameskip",0); //todo: this is not actually supported yet.
	RequestedFPS				  = zc_get_config("zquest","fps",60);
	ForceExit					 = zc_get_config("zquest","force_exit",0);
	
	//Combo Page, Tile Page, an Map Tile Page Autofill
	PreFillTileEditorPage	  = zc_get_config("zquest","PreFillTileEditorPage",0);
	PreFillComboEditorPage	  = zc_get_config("zquest","PreFillComboEditorPage",0);
	PreFillMapTilePage		  =  zc_get_config("zquest","PreFillMapTilePage",0);
	
	pixeldb = zc_get_config("ZQ_GUI","bottom_8_pixels",0);
	large_merged_combopane = zc_get_config("ZQ_GUI","merge_cpane_large",0);
	compact_merged_combopane = zc_get_config("ZQ_GUI","merge_cpane_compact",1);
	
#ifdef _WIN32
	zqUseWin32Proc				 = zc_get_config("zquest","zq_win_proc_fix",0);
	
#endif
	
	if(RequestedFPS < 12 || RequestedFPS> 60)
	{
		RequestedFPS = vbound(RequestedFPS,12,60);
		zc_set_config("zquest","fps",RequestedFPS);
	}
	
	LOCK_VARIABLE(myvsync);
	LOCK_FUNCTION(myvsync_callback);
	
	if(install_int_ex(myvsync_callback,BPS_TO_TIMER(RequestedFPS)))
	{
		Z_error_fatal("couldn't allocate timer");
		quit_game();
	}
	
	// 1 <= zcmusic_bufsz <= 128
	zcmusic_bufsz = vbound(zc_get_config("zquest","zqmusic_bufsz",64),1,128);
	byte layermask = zc_get_config("zquest","layer_mask",0x7F);
	int32_t usefullscreen = zc_get_config("zquest","fullscreen",0);
	tempmode = (usefullscreen == 0 ? GFX_AUTODETECT_WINDOWED : GFX_AUTODETECT_FULLSCREEN);
	
	for(int32_t x=0; x<7; x++)
	{
		LayerMaskInt[x]=get_bit(&layermask,x);
	}
	
	DuplicateAction[0]			 = zc_get_config("zquest","normal_duplicate_action",2);
	DuplicateAction[1]			 = zc_get_config("zquest","horizontal_duplicate_action",0);
	DuplicateAction[2]			 = zc_get_config("zquest","vertical_duplicate_action",0);
	DuplicateAction[3]			 = zc_get_config("zquest","both_duplicate_action",0);
	LeechUpdate					= zc_get_config("zquest","leech_update",500);
	LeechUpdateTiles			   = zc_get_config("zquest","leech_update_tiles",1);
	OnlyCheckNewTilesForDuplicates = zc_get_config("zquest","only_check_new_tiles_for_duplicates",0);
	//gui_colorset				   = zc_get_config("zquest","gui_colorset",0);
	
	strcpy(last_timed_save,zc_get_config("zquest","last_timed_save",""));
	
	midi_volume					= zc_get_config("zquest", "midi", 255);
	
	abc_patternmatch			   = zc_get_config("zquest", "lister_pattern_matching", 1);
	NoScreenPreview			   = zc_get_config("zquest", "no_preview", 0);
	
	monochrome_console = zc_get_config("CONSOLE","monochrome_debuggers",0)?1:0;
	
	try_recovering_missing_scripts = 0;//zc_get_config("Compiler", "try_recovering_missing_scripts",0);
	//We need to remove all of the zeldadx refs to the config file for zquest. 
	
	set_keyboard_rate(KeyboardRepeatDelay,KeyboardRepeatRate);
	
	if(used_switch(argc,argv,"-small") || UseSmall==1)
	{
		is_large=false;
		BMM=1;
	}
	
	is_compact = is_large && zc_get_config("ZQ_GUI","compact_mode",1);
	init_custom_fonts();
	mapscreenbmp = nullptr;
	brushbmp = nullptr;
	brushscreen = nullptr;
	screen2 = nullptr;
	tmp_scr = nullptr;
	menu1 = nullptr;
	menu3 = nullptr;
	tooltipbmp = nullptr;
	load_size_poses();
	
	for(int32_t i=0; i<MAXFAVORITECOMBOS; ++i)
	{
		favorite_combos[i]=-1;
		pool_combos[i].clear();
	}
	pool_dirty = true;
	
	for(int32_t i=0; i<MAXFAVORITECOMBOALIASES; ++i)
	{
		favorite_comboaliases[i]=-1;
	}
	
	char cmdnametitle[20];
	
	for(int32_t x=0; x<MAXFAVORITECOMMANDS; ++x)
	{
		sprintf(cmdnametitle, "command%02d", x+1);
		favorite_commands[x]=zc_get_config("zquest",cmdnametitle,0);
		if(favorite_commands[x] >= cmdMAX || favorite_commands[x] < 0)
		{
			favorite_commands[x] = 0;
		}
		else if(commands[favorite_commands[x]].name[0] == ' ')
		{
			favorite_commands[x] = 0;
		}
	}
	
	
	if(used_switch(argc,argv,"-d"))
	{
		resolve_password(zquestpwd);
		set_debug(!strcmp(zquestpwd,zc_get_config("zquest","debug_this","")));
	}
	
	char qtnametitle[20];
	char qtpathtitle[20];
	
	for(int32_t x=1; x<MAXQTS; ++x)
	{
		sprintf(qtnametitle, "%s%d", qtname_name, x);
		sprintf(qtpathtitle, "%s%d", qtpath_name, x);
		strcpy(QuestTemplates[x].name,zc_get_config("zquest",qtnametitle,""));
		strcpy(QuestTemplates[x].path,zc_get_config("zquest",qtpathtitle,""));
		
		if(QuestTemplates[x].name[0]==0)
		{
			qt_count=x;
			break;
		}
	}
	
	Z_message("Initializing sound driver... ");
	
	if(used_switch(argc,argv,"-s") || zc_get_config("zquest","nosound",0))
	{
		Z_message("skipped\n");
	}
	else
	{
		if(install_sound(DIGI_AUTODETECT,DIGI_AUTODETECT,NULL))
		{
		

		FFCore.ZScriptConsole
		(
			CConsoleLoggerEx::COLOR_RED |CConsoleLoggerEx::COLOR_INTENSITY | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"ZQuest Creator Init Error: %s\n", 
			"Sound driver not available.  Sound disabled.!\n"
		);

			Z_message("Sound driver not available.  Sound disabled.\n");
		}
		else
		{
			Z_message("OK\n");
		}
	}
	
	if(used_switch(argc,argv,"-q"))
	{
		FFCore.ZScriptConsole
		(
			CConsoleLoggerEx::COLOR_RED |CConsoleLoggerEx::COLOR_INTENSITY | 
				CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"-q switch used, quitting program.\n"
		);

		Z_message("-q switch used, quitting program.\n");
		quit_game();
		exit(0);
	}
	zcmusic_init();
	
	switch(zqColorDepth) //defaults to 8bit
	{
	case 0:
		set_color_depth(desktop_color_depth());
		break;
		
	case 8:
		set_color_depth(8);
		break;
		
	case 15:
		set_color_depth(15);
		break;
		
	case 16:
		set_color_depth(16);
		break;
		
	case 24:
		set_color_depth(24);
		break;
		
	case 32:
		set_color_depth(32);
		break;
		
	default:
		zqColorDepth = 8;
		set_color_depth(8);
		break;
	}
	
	set_close_button_callback((void (*)()) hit_close_button);
	
	if(used_switch(argc,argv,"-fullscreen"))
	{
		tempmode = GFX_AUTODETECT_FULLSCREEN;
	}
	else if(used_switch(argc,argv,"-windowed"))
	{
		tempmode=GFX_AUTODETECT_WINDOWED;
	}
	
	/*if (tempmode==GFX_AUTODETECT_FULLSCREEN)
	{
	#ifdef ALLEGRO_MACOSX
	
	  if(used_switch(argc,argv,"-small") || UseSmall == 1)
		scale_arg=2;
	  else
		scale_arg=1;
	#else
	  if (scale_arg>2)
	  {
		scale_arg=1;
	  }
	#endif
	  zqwin_set_scale(scale_arg);
	}*/

	int32_t videofail = (set_gfx_mode(tempmode,zq_screen_w,zq_screen_h,0,0));

	//extra block here is intentional
	if(videofail!=0)
	{
		quit_game();
		allegro_exit();
	}
	else
	{
		Z_message("gfx mode set at -%d %dbpp %d x %d \n",
				  tempmode, get_color_depth(), zq_screen_w, zq_screen_h);
		//Z_message("OK\n");
	}

#ifndef __EMSCRIPTEN__
	if (!all_get_fullscreen_flag()) {
		// Just in case.
		while (!all_get_display()) {
			al_rest(1);
		}

		window_width = is_large ? zc_get_config("zquest","large_window_width",zq_screen_w) : zc_get_config("zquest","small_window_width",zq_screen_w);
		window_height = is_large ? zc_get_config("zquest","large_window_height",zq_screen_h) : zc_get_config("zquest","small_window_height",zq_screen_h);
		double monitor_scale = zc_get_monitor_scale();
		al_resize_display(all_get_display(), window_width*monitor_scale, window_height*monitor_scale);

		int window_w = al_get_display_width(all_get_display());
		int window_h = al_get_display_height(all_get_display());

		int new_x = zc_get_config("zquest","window_x",0);
		int new_y = zc_get_config("zquest","window_y",0);
		if(zc_get_config("zquest","save_window_position",0) && (new_x || new_y))
		{
			//load saved position
			//already stored in new_x/new_y
		}
		else
		{
			//Get default position
			ALLEGRO_MONITOR_INFO info;
			al_get_monitor_info(0, &info);
			
			int mw = (info.x2 - info.x1);
			int mh = (info.y2 - info.y1);
			new_x = mw / 2 - window_w / 2;
			new_y = mh / 2 - window_h / 2;
			//Don't spawn the window too far down (taskbar?)
			if(new_y + window_h > mh - 72)
				new_y = mh-72-window_h;
		}
		al_set_window_position(all_get_display(), new_x, new_y);
	}
#endif

	//check and log RTC date and time
	for (int32_t q = 0; q < curTimeLAST; q++) 
	{
		int32_t t_time_v = FFCore.getTime(q);
	}
	
	position_mouse(zq_screen_w/2,zq_screen_h/2);
	
	dmapbmp_small = create_bitmap_ex(8,65,33);
	dmapbmp_large = create_bitmap_ex(8,(is_large?177:113),(is_large?81:57));
	
	if(!screen2 || !tmp_scr || !menu1 || !menu3 || !dmapbmp_large || !dmapbmp_large || !brushbmp || !brushscreen)// || !brushshadowbmp )
	{
		Z_error_fatal("Failed to create system bitmaps!\n");
		allegro_exit();
		quit_game();
		return 1;
	}
	
	set_palette((RGB*)zcdata[PAL_ZQUEST].dat);
	get_palette(RAMpal);
	
	load_colorset(gui_colorset);
	
	set_palette(RAMpal);
	clear_to_color(screen,vc(0));
	
	//clear the midis (to keep loadquest from crashing by trying to destroy a garbage midi)
	for(int32_t i=0; i<MAXCUSTOMMIDIS_ZQ; ++i)
	{
		customtunes[i].data=NULL;
	}
	
	for(int32_t i=0; i<WAV_COUNT; i++)
	{
		if(sfx_string[i]!=NULL) delete sfx_string[i];
		customsfxdata[i].data=NULL;
		sfx_string[i] = new char[36];
		memset(sfx_string[i], 0, 36);
	}
	
	for(int32_t i=0; i<WPNCNT; i++)
	{
		if(weapon_string[i]!=NULL) delete weapon_string[i];
		weapon_string[i] = new char[64];
		memset(weapon_string[i], 0, 64);
	}
	
	for(int32_t i=0; i<ITEMCNT; i++)
	{
		if(item_string[i]!=NULL) delete item_string[i];
		item_string[i] = new char[64];
		memset(item_string[i], 0, 64);
	}
	
	for(int32_t i=0; i<eMAXGUYS; i++)
	{
		if(guy_string[i]!=NULL) delete guy_string[i];
		guy_string[i] = new char[64];
		memset(guy_string[i], 0, 64);
	}
	
	for(int32_t i=0; i<NUMSCRIPTFFC; i++)
	{
		if(ffscripts[i]!=NULL) delete ffscripts[i];
		ffscripts[i] = new script_data();
	}
	
	for(int32_t i=0; i<NUMSCRIPTITEM; i++)
	{
		if(itemscripts[i]!=NULL) delete itemscripts[i];
		itemscripts[i] = new script_data();
	}
	
	for(int32_t i=0; i<NUMSCRIPTGUYS; i++)
	{
		if(guyscripts[i]!=NULL) delete guyscripts[i];
		guyscripts[i] = new script_data();
	}
	
	for(int32_t i=0; i<NUMSCRIPTWEAPONS; i++)
	{
		if(lwpnscripts[i]!=NULL) delete lwpnscripts[i];
		lwpnscripts[i] = new script_data();
	}
	
	for(int32_t i=0; i<NUMSCRIPTWEAPONS; i++)
	{
		if(ewpnscripts[i]!=NULL) delete ewpnscripts[i];
		ewpnscripts[i] = new script_data();
	}
	
	for(int32_t i=0; i<NUMSCRIPTSCREEN; i++)
	{
		if(screenscripts[i]!=NULL) delete screenscripts[i];
		screenscripts[i] = new script_data();
	}
	
	for(int32_t i=0; i<3; i++) //should this be NUMSCRIPTGLOBAL or NUMSCRIPTGLOBALOLD? -Z
	{
		if(globalscripts[i]!=NULL) delete globalscripts[i];
		globalscripts[i] = new script_data();
	}
	
	for(int32_t i=0; i<NUMSCRIPTPLAYER; i++)
	{
		if(playerscripts[i]!=NULL) delete playerscripts[i];
		playerscripts[i] = new script_data();
	}
	
	for(int32_t i=0; i<NUMSCRIPTSDMAP; i++)
	{
		if(dmapscripts[i]!=NULL) delete dmapscripts[i];
		dmapscripts[i] = new script_data();
	}
	
	for(int32_t i=0; i<NUMSCRIPTSITEMSPRITE; i++)
	{
		if(itemspritescripts[i]!=NULL) delete itemspritescripts[i];
		itemspritescripts[i] = new script_data();
	}
	for(int32_t i=0; i<NUMSCRIPTSCOMBODATA; i++)
	{
		if(comboscripts[i]!=NULL) delete comboscripts[i];
		comboscripts[i] = new script_data();
	}
	
	zScript = string();
	strcpy(zScriptBytes, "0 Bytes in Buffer");
	for(int32_t i=0; i<MOUSE_BMP_MAX; i++)
	{
		for(int32_t j=0; j<4; j++)
		{
			mouse_bmp[i][j] = NULL;
			mouse_bmp_1x[i][j] = NULL;
		}
	}
	load_mice();
	gui_mouse_focus=0;
	set_mouse_sprite(mouse_bmp[MOUSE_BMP_NORMAL][0]);
	show_mouse(screen);
	//Display annoying beta warning message

#ifdef __EMSCRIPTEN__
	em_mark_ready_status();
#endif

#ifndef __EMSCRIPTEN__

#if V_ZC_ALPHA
	char *curcontrol = getBetaControlString();
	const char *oldcontrol = zc_get_config("zquest", "beta_warning", "");
	
	if(strcmp(curcontrol, oldcontrol))
	{
		InfoDialog("Alpha Warning", "WARNING:\nThis is an ALPHA version of ZQuest."
			" There may be major bugs, which could cause quests"
			"\nto crash or become corrupted. Keep backups of your quest file!!"
			"\nAdditionally, new features may change over time.").show();
	}

//	FFCore.ZScriptConsole(true);

	
	delete[] curcontrol;
#elif V_ZC_BETA
	char *curcontrol = getBetaControlString();
	const char *oldcontrol = zc_get_config("zquest", "beta_warning", "");
	
	if(strcmp(curcontrol, oldcontrol))
	{
		InfoDialog("Beta Warning", "WARNING:\nThis is an BETA version of ZQuest."
			" There may be bugs, which could cause quests"
			"\nto crash or become corrupted. Keep backups of your quest file!!").show();
	}

//	FFCore.ZScriptConsole(true);

	
	delete[] curcontrol;
#endif

#endif
	
	// A bit of festivity
	{
		time_t rawtime;
		time(&rawtime);
		
		if(strncmp(ctime(&rawtime)+4,"Jan  1",6)==0)
		{
			jwin_alert("Hooray!", "Happy New Year!", NULL, NULL, "OK", NULL, 0, 0, lfont);
		}
	}
	
	load_icons();
	
	bool load_last_timed_save=false;
	
	load_recent_quests();
	refresh_recent_menu();
	//clearConsole();
	if((last_timed_save[0]!=0)&&(exists(last_timed_save)))
	{
		if(jwin_alert("ZQuest","It appears that ZQuest crashed last time.","Would you like to load the last timed save?",NULL,"&Yes","&No",'y','n',lfont)==1)
		{
			int32_t ret = load_quest(last_timed_save,true,true);
			
			if(ret == qe_OK)
			{
				replace_extension(filepath,last_timed_save,"qst",2047);
				load_last_timed_save=true;
				saved=false;
			}
			else
			{
				jwin_alert("Error","Unable to reload the last timed save.",NULL,NULL,"OK",NULL,13,27,lfont);
			}
		}
	}
	
	if(!load_last_timed_save)
	{
		strcpy(filepath,zc_get_config("zquest",last_quest_name,""));
		
		if(argc>1 && argv[1][0]!='-')
		{
			replace_extension(temppath,argv[1],"qst",2047);
			int32_t ret = load_quest(temppath,true,true);
			
			if(ret == qe_OK)
			{
				first_save=true;
				strcpy(filepath,temppath);
				refresh(rALL);
			}
		}
		else if(OpenLastQuest&&filepath[0]&&exists(filepath)&&!used_switch(argc,argv,"-new"))
		{
			int32_t ret = load_quest(filepath,true,true);
			
			if(ret == qe_OK)
			{
				first_save=true;
				refresh(rALL);
			}
			else
			{
				filepath[0]=temppath[0]=0;
				first_save=false;
			}
		}
		else
		{
			init_quest(NULL);
			
			if(RulesetDialog)
			{
				PickRuleset();
				PickRuleTemplate();
			}
				
			//otherwise the blank quest gets the name of the last loaded quest... not good! -DD
			filepath[0]=temppath[0]=0;
			first_save=false;
		}
	}
	
	for(int32_t x=0; x<MAXITEMS; x++)
	{
		lens_hint_item[x][0]=0;
		lens_hint_item[x][1]=0;
	}
	
	for(int32_t x=0; x<MAXWPNS; x++)
	{
		lens_hint_weapon[x][0]=0;
		lens_hint_weapon[x][1]=0;
	}
	
	load_selections();
	load_arrows();
	clear_to_color(menu1,vc(0));
	refresh(rALL);
	DIALOG_PLAYER *player2=init_dialog(dialogs,-1);
	
	get_palette(RAMpal);
	
	rgb_map = &zq_rgb_table;

	Map.setCurrMap(zinit.last_map);
	Map.setCurrScr(zinit.last_screen);
#ifdef __EMSCRIPTEN__
	{
		int qs_map = EM_ASM_INT({
			return new URL(location.href).searchParams.get('map') ?? -1;
		});
		int qs_screen = EM_ASM_INT({
			return new URL(location.href).searchParams.get('screen') ?? -1;
		});
		if (qs_map != -1 && qs_screen != -1) {
			Map.setCurrMap(qs_map);
			Map.setCurrScr(qs_screen);
		}
	}
#endif

	//  setup_combo_animations();
	refresh(rALL);
	brush_width_menu[0].flags=D_SELECTED;
	brush_height_menu[0].flags=D_SELECTED;
	fill_menu[1].flags=D_SELECTED;
	
	rebuild_trans_table();
	
	set_display_switch_mode(SWITCH_BACKGROUND);
	set_display_switch_callback(SWITCH_OUT, switch_out);
	set_display_switch_callback(SWITCH_IN, switch_in);
	
	quit=!update_dialog(player2);
	//clear_keybuf();
	etc_menu[10].flags=commands[cmdChangeTrack].flags=D_DISABLED;
	
	fix_drawing_mode_menu();
	
	
#ifdef _WIN32
	
	if(zqUseWin32Proc != FALSE)
	{
		al_trace("Config file warning: \"zq_win_proc_fix\" enabled switch found. This can cause crashes on some computers.\n");
		win32data.zqSetDefaultThreadPriority(0);
		win32data.zqSetCustomCallbackProc(al_get_win_window_handle(all_get_display()));
	}
	
#endif
	
	time(&auto_save_time_start);
	
	FFCore.init();
	ZQincludePaths = FFCore.includePaths;
	
	Map.setCopyFFC(-1); //Do not have an initial ffc on the clipboard. 
	
	init_ffpos();
	
	/*
	if (!is_large) 
	{
		dialogs[0].dp = (void *) the_menu;
	}
	else dialogs[0].dp = (void *) the_menu_large;
	*/
	call_foo_dlg();
	while(!quit)
	{
	
#ifdef _WIN32
	
		try   // I *think* it might throw here.
		{
			if(zqUseWin32Proc != FALSE)
				win32data.Update(Frameskip); //experimental win32 fixes
		}
		catch(...)
		{
			set_gfx_mode(GFX_TEXT,0,0,0,0);
			allegro_message("ZQ-Windows Fatal Error: Set \"zq_win_proc_fix = 0\" in config file.");
			exit(1);
		}
		
#endif
		check_autosave();
		/*
		if (!is_large) 
		{
			dialogs[0].dp = (void *) the_menu;
		}
		else
			dialogs[0].dp = (void *) the_menu_large;
		*/
		++alignment_arrow_timer;
		
		if(alignment_arrow_timer>63)
		{
			alignment_arrow_timer=0;
		}
		
		/* Notice: Adjust and Update these values if you hae modified any of the following, where
			your modifications hae inserted or removed ANY entries. 
			dialogs[]
			paste_item_menu[]
			commands[]
			file_menu[]
			tool_menu[]
			defs_menu[]
			view_menu[]
			maps_menu[]
		*/
		
		file_menu[fileSave].flags =
			file_menu[fileRevert].flags =
				dialogs[19].flags =
					commands[cmdSave].flags =
						commands[cmdRevert].flags = (saved | disable_saving|OverwriteProtection) ? D_DISABLED : 0;
						
		file_menu[fileSaveAs].flags =
			commands[cmdSaveAs].flags = disable_saving ? D_DISABLED : 0;
		
		fixtools_menu[ftOSFix].flags = (get_bit(quest_rules, qr_OLD_STRING_EDITOR_MARGINS)
			|| get_bit(quest_rules, qr_STRING_FRAME_OLD_WIDTH_HEIGHT))
				? 0 : D_DISABLED;
		
		edit_menu[0].flags =
			commands[cmdUndo].flags = Map.CanUndo() ? 0 : D_DISABLED;
        edit_menu[1].flags =
			commands[cmdRedo].flags = Map.CanRedo() ? 0 : D_DISABLED;
			
		edit_menu[3].flags =
		    edit_menu[4].flags =
			edit_menu[5].flags =
			    edit_menu[6].flags =
				paste_menu[0].flags =
				    paste_menu[1].flags =
					paste_item_menu[0].flags =
					    paste_item_menu[1].flags =
						paste_item_menu[2].flags =
						    paste_item_menu[3].flags =
							paste_item_menu[4].flags =
							    paste_item_menu[5].flags =
								    paste_item_menu[6].flags =
									paste_item_menu[7].flags =
									    paste_item_menu[8].flags =
										paste_item_menu[9].flags =
										    paste_item_menu[10].flags =
											commands[cmdPaste].flags =
											    commands[cmdPasteAll].flags =
												commands[cmdPasteToAll].flags =
												    commands[cmdPasteAllToAll].flags =
													commands[cmdPasteUnderCombo].flags =
													    commands[cmdPasteSecretCombos].flags =
														commands[cmdPasteFFCombos].flags =
														    commands[cmdPasteScreenData].flags =
															commands[cmdPasteWarps].flags =
															    commands[cmdPasteWarpLocations].flags =
																commands[cmdPasteEnemies].flags =
																    commands[cmdPasteRoom].flags =
																	commands[cmdPasteGuy].flags =
																	    commands[cmdPasteDoors].flags =
																		commands[cmdPasteLayers].flags = Map.CanPaste() ? 0 : D_DISABLED;
                                                                                																																		
		edit_menu[2].flags =
			edit_menu[7].flags =
				commands[cmdCopy].flags =
					commands[cmdDelete].flags = (Map.CurrScr()->valid&mVALID) ? 0 : D_DISABLED;
					
		tool_menu[0].flags =
			//data_menu[7].flags = //Allow setting doors on template screens > 0x82. -Z ( 24th March, 2019 )
				commands[cmdTemplate].flags = (Map.getCurrScr()<TEMPLATE) ? 0 : D_DISABLED;
					
	data_menu[7].flags = //Allow setting doors on template screens > 0x82. -Z ( 1st July, 2019 )
		commands[cmdDoors].flags = (Map.getCurrScr()<0x88) ? 0 : D_DISABLED;
		
		defs_menu[1].flags =
			commands[cmdDefault_Tiles].flags = 0;
			
		// Are some things selected?
		view_menu[3].flags=(Flags&cWALK)?D_SELECTED:0; // Show Walkability
		view_menu[4].flags=(Flags&cFLAGS)?D_SELECTED:0; // Show Flags
		view_menu[5].flags=(Flags&cCSET)?D_SELECTED:0; // Show CSet
		view_menu[6].flags=(Flags&cCTYPE)?D_SELECTED:0; // Show Type
		view_menu[8].flags=(!is_large)?D_DISABLED:(ShowInfo)?D_SELECTED:0; // Show Info
		view_menu[9].flags=(ShowSquares)?D_SELECTED:0; // Show Squares
		view_menu[10].flags=(ShowFFCs)?D_SELECTED:0; // Show Squares
		view_menu[11].flags=(ShowFFScripts)?D_SELECTED:0; // Show Script Names
		view_menu[12].flags=(ShowGrid)?D_SELECTED:0; // Show Grid
		view_menu[13].flags=(get_bit(quest_rules,qr_NEW_DARKROOM) && (Flags&cNEWDARK))?D_SELECTED:0; // Show Grid
		view_menu[14].flags=(ViewLayer3BG)?D_SELECTED:0; // Show Grid
		view_menu[15].flags=(ViewLayer2BG)?D_SELECTED:0; // Show Grid
		
		maps_menu[1].flags=(Map.getCurrMap()<map_count && map_count>0) ? 0 : D_DISABLED;
		maps_menu[2].flags=(Map.getCurrMap()>0)? 0 : D_DISABLED;
		
		etc_menu[2].flags=etc_menu_smallmode[2].flags=(isFullScreen()==1)?D_DISABLED:0;
		etc_menu[4].flags=(isFullScreen()==1)?D_SELECTED:0;
		quit = !update_dialog(player2);
		
		//clear_keybuf();
		if(close_button_quit)
		{
			close_button_quit=false;
			
			if(onExit()==D_CLOSE)
			{
				quit=true;
			}
		}
	}
	parser_console.kill();
	killConsole();
	
	quit_game();
	
	if(ForceExit) //last resort fix to the allegro process hanging bug.
		exit(0);
	
	return 0;
// memset(qtpathtitle,0,10);//UNREACHABLE
}
END_OF_MAIN()

void init_bitmap(BITMAP** bmp, int32_t w, int32_t h)
{
	if(*bmp)
		destroy_bitmap(*bmp);
	*bmp = create_bitmap_ex(8,w,h);
	clear_bitmap(*bmp);
}
void load_size_poses()
{
	tooltip_box.set(-1,-1,0,0);
	tooltip_trigger.set(-1,-1,0,0);
	tooltip_highlight.clear();
	
	FONT* favcmdfont = get_custom_font(CFONT_FAVCMD);
	FONT* guifont = get_custom_font(CFONT_GUI);
	
	dialogs[0].dp2 = guifont;
	jwin_menu_proc(MSG_START, &dialogs[0], 0);
	
	commands_list.xscale = command_buttonwidth;
	//commands_list.yscale = command_buttonheight;
	commands_list.yscale = 10+text_height(favcmdfont);
	
	auto drawmode_wid = 64;
	for(auto q = 0; q < dm_max; ++q)
	{
		auto wid = text_length(guifont, dm_names[q]);
		if(wid > drawmode_wid)
			drawmode_wid = wid;
	}
	
	//Main GUI objects
	if(is_compact)
	{
		memcpy(the_menu, the_menu_large, sizeof(the_menu));
		
		num_combo_cols = 2;
		combo_col_scale = 16;
		if(compact_merged_combopane)
		{
			num_combo_cols = 1;
			combo_col_scale = 32;
		}
		
		mapscreen_x=0;
		mapscreen_y=text_height(guifont)+10;
		mapscreensize=3;
		showedges=0;
		showallpanels=0;
		
		blackout_color=8;
		zq_screen_w=LARGE_W;
		zq_screen_h=LARGE_H;
		
		auto mapscr_wid = (((showedges?2:0)+16)*16*mapscreensize);
		combolist_window.w=zq_screen_w-mapscr_wid;
		combolist_window.x=zq_screen_w-combolist_window.w;
		
		favorites_window.x=combolist_window.x;
		favorites_window.w=combolist_window.w;
		favorites_window.h=136;
		favorites_window.y=zq_screen_h-favorites_window.h;
		
		combolist_window.y=0;
		combolist_window.h=favorites_window.y-combolist_window.y;
		
		combo_preview.x=zq_screen_w-32-8;
		combo_preview.y=combolist_window.y+6;
		combo_preview.w=32;
		combo_preview.h=32;
		
		auto col_wid = 4*combo_col_scale;
		auto cols_wid = col_wid * num_combo_cols;
		auto cols_spacing = (combolist_window.w-cols_wid)/(num_combo_cols+1);
		for(auto q = 0; q < num_combo_cols; ++q)
		{
			combolist[q].x=combolist_window.x+(cols_spacing*(q+1))+(col_wid*q);
			combolist[q].y=combolist_window.y+54;
			combolist[q].w=4;
			combolist[q].h=compact_merged_combopane ? 15 : 30;
			combolist[q].xscale = combo_col_scale;
			combolist[q].yscale = combo_col_scale;
			
			comboaliaslist[q].x = combolist[q].x;
			comboaliaslist[q].y = combolist[q].y;
			comboaliaslist[q].w = 4;
			comboaliaslist[q].h = compact_merged_combopane ? 13 : 26;
			comboaliaslist[q].xscale = combo_col_scale;
			comboaliaslist[q].yscale = combo_col_scale;
			
			combolistscrollers[q].w=11;
			combolistscrollers[q].h=11;
			combolistscrollers[q].x=combolist[q].x+(combolist[q].w*combolist[q].xscale/2)-11;
			combolistscrollers[q].y=combolist[q].y-combolistscrollers[q].h-3;
		}
		
		comboalias_preview.x=zq_screen_w-((combolist_window.w+64)/2);
		comboalias_preview.h=64;
		comboalias_preview.y=favorites_window.y-comboalias_preview.h-8;
		comboalias_preview.w=64;
		
		combo_merge_btn.w = 20;
		combo_merge_btn.h = 20;
		combo_merge_btn.x = zq_screen_w-(combolist_window.w+combo_merge_btn.w)/2;
		combo_merge_btn.y = combolist[0].y-combo_merge_btn.h;
		
		if(num_combo_cols == 1)
		{
			combolistscrollers[0].x += 10;
			combo_merge_btn.x -= 10;
		}
		drawmode_btn.x = combolist_window.x-drawmode_wid;
		drawmode_btn.y = 0;
		drawmode_btn.w = drawmode_wid;
		drawmode_btn.h = mapscreen_y;
		
		compactbtn.w = text_length(guifont,"> Compact")+10;
		compactbtn.x = drawmode_btn.x-compactbtn.w;
		compactbtn.y = drawmode_btn.y;
		compactbtn.h = drawmode_btn.h;
		
		mainbar.x = dialogs[0].w+2;
		mainbar.y = 0;
		mainbar.w = compactbtn.x-mainbar.x;
		mainbar.h = drawmode_btn.h;
		
		for(int32_t i=0; i<=8; i++)
		{
			map_page_bar[i].w = 48;
			map_page_bar[i].x = mapscreen_x+(i*48);
			map_page_bar[i].y = mapscreen_y+(11*16*mapscreensize);
			map_page_bar[i].h = text_height(guifont)+12;
		}
		
		minimap.w=7+48*BMM;
		minimap.h=16+27*BMM;
		
		layer_panel.x=map_page_bar[6].x;
		layer_panel.y=map_page_bar[0].y;
		layer_panel.w=combolist_window.x - layer_panel.x;
		layer_panel.h=map_page_bar[0].h;
		layerpanel_buttonwidth = 51;
		layerpanel_buttonheight = layer_panel.h;
		layerpanel_checkbox_hei = layerpanel_buttonheight-4;
		layerpanel_checkbox_wid = 15;
		
		for(int32_t i=0; i<9; i++)
		{
			panel[i].x=10+48*BMM;
			panel[i].y=layer_panel.y+layer_panel.h;
			panel[i].w=64;
			panel[i].h=zq_screen_h-panel[i].y;
		}
		
		minimap.x=3;
		minimap.y=layer_panel.y+layer_panel.h+4;
		
		screrrorpos.x = combolist_window.x - 3;
		screrrorpos.y = layer_panel.y - 16;
		
		mouse_scroll_h=10;
		
		favorites_list.x=favorites_window.x+8;
		favorites_list.y=favorites_window.y+16;
		favorites_list.w=(favorites_window.w-16)>>4;
		favorites_list.h=(favorites_window.h-24)>>4;
		
		favorites_x.x = favorites_window.x + favorites_window.w - 2 - 12;
		favorites_x.y = favorites_list.y - 14;
		favorites_x.w = 12;
		favorites_x.h = 12;
		
		commands_list.w=4;
		
		commands_window.w=commands_list.w*commands_list.xscale+16;
		commands_window.x=combolist_window.x-commands_window.w;
		commands_window.y=layer_panel.y+layer_panel.h;
		commands_window.h=zq_screen_h-commands_window.y;
		
		commands_list.h=(zq_screen_h - (commands_window.y+4)) / commands_list.yscale;
		commands_list.x=commands_window.x+8;
		commands_list.y=commands_window.y+(commands_window.h-(commands_list.h*commands_list.yscale))/2;
		
		panel[0].w = commands_window.x - panel[0].x;
		panel[8].x = 0;
		panel[8].w = commands_window.x - panel[8].x;
		
		txtoffs_single.x = 10;
		txtoffs_single.y = 22;
		txtoffs_double_1.x = 10;
		txtoffs_double_1.y = 22;
		txtoffs_double_2.x = 10;
		txtoffs_double_2.y = 30;
		panel_align = 1;
		
		itemsqr_pos.x = panel[0].x+14;
		itemsqr_pos.y = panel[0].y+12;
		itemsqr_pos.w = 4+16;
		itemsqr_pos.h = 4+16;
		stairsqr_pos.x = panel[0].x+14+32;
		stairsqr_pos.y = panel[0].y+12;
		stairsqr_pos.w = 4+16;
		stairsqr_pos.h = 4+16;
		warparrival_pos.x = panel[0].x+14+64;
		warparrival_pos.y = panel[0].y+12;
		warparrival_pos.w = 4+16;
		warparrival_pos.h = 4+16;
		flagsqr_pos.x = panel[0].x+14+96;
		flagsqr_pos.y = panel[0].y+12;
		flagsqr_pos.w = 4+16;
		flagsqr_pos.h = 4+16;
		for(auto q = 0; q < 4; ++q)
		{
			warpret_pos[q].x = panel[0].x+14+(32*q);
			warpret_pos[q].y = panel[0].y+54;
			warpret_pos[q].w = 4+16;
			warpret_pos[q].h = 4+16;
		}
		enemy_prev_pos.x = 2+panel[0].x+14+4*32;
		enemy_prev_pos.y = 2+panel[0].y+12;
		enemy_prev_pos.w = 4+(16*4);
		enemy_prev_pos.h = 4+(16*3);
		
		auto& last_alias_list = comboaliaslist[num_combo_cols-1];
		combopool_preview.x=comboaliaslist[0].x;
		combopool_preview.y=comboaliaslist[num_combo_cols-1].y+(last_alias_list.h*last_alias_list.yscale)+16;
		combopool_preview.w=(comboaliaslist[num_combo_cols-1].x+(last_alias_list.w*last_alias_list.xscale))-comboaliaslist[0].x;
		combopool_preview.h=zq_screen_h-8-combopool_preview.y;
		combopool_preview.w -= combopool_preview.w%16;
		combopool_preview.h -= combopool_preview.h%16;
		
		FONT* tfont = is_large?lfont_l:nfont;
		combopool_prevbtn.w = text_length(tfont, "Unweighted")+10;
		combopool_prevbtn.h = 11;
		combopool_prevbtn.x = combopool_preview.x;
		combopool_prevbtn.y = combopool_preview.y-combopool_prevbtn.h;
		
		mappage_count = 6;
	}
	else if(is_large)
	{
		memcpy(the_menu, the_menu_large, sizeof(the_menu));
		
		num_combo_cols = 4;
		combo_col_scale = 16;
		if(large_merged_combopane)
		{
			num_combo_cols = 2;
			combo_col_scale = 32;
		}
		
		mapscreen_x=0;
		mapscreen_y=text_height(guifont)+10;
		mapscreensize=2;
		showedges=1;
		showallpanels=0;
		
		blackout_color=8;
		zq_screen_w=LARGE_W;
		zq_screen_h=LARGE_H;
		
		favorites_window.h=136;
		favorites_window.y=zq_screen_h-favorites_window.h;
		
		auto mapscr_wid = (((showedges?2:0)+16)*16*mapscreensize);
		combolist_window.w=zq_screen_w-mapscr_wid;
		combolist_window.x=zq_screen_w-combolist_window.w;
		combolist_window.y=0;
		combolist_window.h=favorites_window.y-combolist_window.y;
		
		favorites_window.x=combolist_window.x;
		favorites_window.w=combolist_window.w;
		
		combo_preview.x=(zq_screen_w-(combolist_window.w/2))-40;
		combo_preview.y=combolist_window.y+6;
		combo_preview.w=32;
		combo_preview.h=32;
		
		auto col_wid = 4*combo_col_scale;
		auto cols_wid = col_wid * num_combo_cols;
		auto cols_spacing = (combolist_window.w-cols_wid)/(num_combo_cols+1);
		for(auto q = 0; q < num_combo_cols; ++q)
		{
			combolist[q].x=combolist_window.x+(cols_spacing*(q+1))+(col_wid*q);
			combolist[q].y=combolist_window.y+60;
			combolist[q].w=4;
			combolist[q].h=large_merged_combopane ? 15 : 30;
			combolist[q].xscale = combo_col_scale;
			combolist[q].yscale = combo_col_scale;
			
			comboaliaslist[q].x=combolist[q].x;
			comboaliaslist[q].y=combolist[q].y;
			comboaliaslist[q].w=4;
			comboaliaslist[q].h=large_merged_combopane ? 12 : 25;
			comboaliaslist[q].xscale = combo_col_scale;
			comboaliaslist[q].yscale = combo_col_scale;
			
			combolistscrollers[q].w=11;
			combolistscrollers[q].h=11;
			combolistscrollers[q].x=combolist[q].x+(combolist[q].w*combolist[q].xscale/2)-11;
			combolistscrollers[q].y=combolist[q].y-combolistscrollers[q].h-2;
		}
		
		comboalias_preview.x=zq_screen_w-((combolist_window.w+64)/2);
		comboalias_preview.h=64;
		comboalias_preview.w=64;
		comboalias_preview.y=favorites_window.y-comboalias_preview.h-8;
		
		combo_merge_btn.w = 20;
		combo_merge_btn.h = 20;
		combo_merge_btn.x = zq_screen_w-(combolist_window.w+combo_merge_btn.w)/2;
		combo_merge_btn.y = combolist[0].y-combo_merge_btn.h;
		
		drawmode_btn.x = combolist_window.x-drawmode_wid;
		drawmode_btn.y = 0;
		drawmode_btn.w = drawmode_wid;
		drawmode_btn.h = mapscreen_y;
		
		compactbtn.w = text_length(guifont,"> Compact")+10;
		compactbtn.x = drawmode_btn.x-compactbtn.w;
		compactbtn.y = drawmode_btn.y;
		compactbtn.h = drawmode_btn.h;
		
		mainbar.x = dialogs[0].w+2;
		mainbar.y = 0;
		mainbar.w = compactbtn.x-mainbar.x;
		mainbar.h = drawmode_btn.h;
		
		for(int32_t i=0; i<=8; i++)
		{
			map_page_bar[i].x = mapscreen_x+(i*16*2*mapscreensize);
			map_page_bar[i].y = mapscreen_y+((showedges?13:11)*16*mapscreensize);
			map_page_bar[i].w = 64;
			map_page_bar[i].h = text_height(guifont)+12;
		}
		
		minimap.w=7+48*BMM;
		minimap.h=16+27*BMM;
		
		layer_panel.x=map_page_bar[0].x;
		layer_panel.y=map_page_bar[0].y+map_page_bar[0].h;
		layer_panel.w=map_page_bar[8].x+map_page_bar[8].w;
		layer_panel.h=text_height(guifont)+8;
		layerpanel_buttonwidth = 58;
		layerpanel_buttonheight = layer_panel.h;
		layerpanel_checkbox_hei = layerpanel_buttonheight-4;
		layerpanel_checkbox_wid = 14;
		
		for(int32_t i=0; i<9; i++)
		{
			panel[i].x=10+48*BMM;
			panel[i].y=layer_panel.y+layer_panel.h;
			panel[i].w=(map_page_bar[6].x)-(minimap.w+3);
			panel[i].h=76+32;
		}
		
		minimap.x=3;
		minimap.y=panel[0].y+4;
		
		screrrorpos.x = 575;
		screrrorpos.y = 388;
		
		mouse_scroll_h=10;
		
		favorites_list.x=favorites_window.x+8;
		favorites_list.y=favorites_window.y+16;
		favorites_list.w=(favorites_window.w-16)>>4;
		favorites_list.h=(favorites_window.h-24)>>4;
		
		favorites_x.x = favorites_window.x + favorites_window.w - 2 - 12;
		favorites_x.y = favorites_list.y - 14;
		favorites_x.w = 12;
		favorites_x.h = 12;
		
		commands_list.w=4;
		
		commands_window.w=commands_list.w*commands_list.xscale+16;
		commands_window.x=combolist_window.x-commands_window.w;
		commands_window.y=panel[0].y;
		commands_window.h=zq_screen_h-commands_window.y;
		
		commands_list.h=(zq_screen_h - (commands_window.y+4)) / commands_list.yscale;
		commands_list.x=commands_window.x+8;
		commands_list.y=commands_window.y+(commands_window.h-(commands_list.h*commands_list.yscale))/2;
		
		//buttons panel
		panel[0].x = 0;
		panel[0].w = commands_window.x - panel[0].x;
		panel[0].h = zq_screen_h - panel[0].y;
		
		panel[8] = panel[0]; //preview panel 
		
		txtoffs_single.x = 22;
		txtoffs_single.y = 6;
		txtoffs_double_1.x = 22;
		txtoffs_double_1.y = 2;
		txtoffs_double_2.x = 22;
		txtoffs_double_2.y = 10;
		panel_align = 0;
		
		itemsqr_pos.x = minimap.x+minimap.w+4;
		itemsqr_pos.y = panel[0].y+10;
		itemsqr_pos.w = 4+16;
		itemsqr_pos.h = 4+16;
		flagsqr_pos.x = itemsqr_pos.x;
		flagsqr_pos.y = itemsqr_pos.y+24;
		flagsqr_pos.w = 4+16;
		flagsqr_pos.h = 4+16;
		stairsqr_pos.x = flagsqr_pos.x;
		stairsqr_pos.y = flagsqr_pos.y+24;
		stairsqr_pos.w = 4+16;
		stairsqr_pos.h = 4+16;
		warparrival_pos.x = stairsqr_pos.x;
		warparrival_pos.y = stairsqr_pos.y+24;
		warparrival_pos.w = 4+16;
		warparrival_pos.h = 4+16;
		
		enemy_prev_pos.x = panel[0].x+14;
		enemy_prev_pos.y = panel[0].y+12 + minimap.h;
		enemy_prev_pos.w = 4+(16*4);
		enemy_prev_pos.h = 4+(16*3);
		
		auto x2 = warparrival_pos.x;
		auto y1 = warparrival_pos.y+24;
		auto y2 = y1+24;
		auto x1 = x2 - (20+(8*3)+2);
		
		warpret_pos[0].x = x1;
		warpret_pos[0].y = y1;
		warpret_pos[0].w = 4+16;
		warpret_pos[0].h = 4+16;
		warpret_pos[1].x = x1;
		warpret_pos[1].y = y2;
		warpret_pos[1].w = 4+16;
		warpret_pos[1].h = 4+16;
		warpret_pos[2].x = x2;
		warpret_pos[2].y = y1;
		warpret_pos[2].w = 4+16;
		warpret_pos[2].h = 4+16;
		warpret_pos[3].x = x2;
		warpret_pos[3].y = y2;
		warpret_pos[3].w = 4+16;
		warpret_pos[3].h = 4+16;
		
		combopool_preview.x=comboaliaslist[0].x;
		combopool_preview.y=comboaliaslist[0].y+(comboaliaslist[0].h<<4)+16;
		combopool_preview.w=(comboaliaslist[num_combo_cols-1].x+(comboaliaslist[num_combo_cols-1].w<<4))-comboaliaslist[0].x;
		combopool_preview.h=(favorites_window.y-combopool_preview.y)+favorites_window.h-10;
		combopool_preview.w -= combopool_preview.w%16;
		combopool_preview.h -= combopool_preview.h%16;
		
		FONT* tfont = is_large?lfont_l:nfont;
		combopool_prevbtn.w = text_length(tfont, "Unweighted")+10;
		combopool_prevbtn.h = 11;
		combopool_prevbtn.x = combopool_preview.x;
		combopool_prevbtn.y = combopool_preview.y-combopool_prevbtn.h;
		
		mappage_count = 9;
	}
	else
	{
		num_combo_cols = 1;
		//the_menu[8] = the_menu[9]; //end menus at visible length
		memcpy(the_menu, the_menu_small, sizeof(the_menu));
		blackout_color=0;
		zq_screen_w=320;
		zq_screen_h=240;
		
		mainbar.clear();
		
		minimap.x=3;
		minimap.y=195;
		minimap.w=55;
		minimap.h=43;
		combolist[0].x=256;
		combolist[0].y=16;
		combolist[0].w=4;
		combolist[0].h=14;
		
		comboaliaslist[0].x=256;
		comboaliaslist[0].y=16;
		comboaliaslist[0].w=4;
		comboaliaslist[0].h=10;
		comboalias_preview.x=256;
		comboalias_preview.y=176;
		comboalias_preview.w=64;
		comboalias_preview.h=64;
		combolist[0].xscale = 16;
		combolist[0].yscale = 16;
		comboaliaslist[0].xscale = 16;
		comboaliaslist[0].yscale = 16;
		
		combopool_preview.x=comboaliaslist[0].x;
		combopool_preview.y=comboaliaslist[0].y+(comboaliaslist[0].h<<4)+16;
		combopool_preview.w=comboaliaslist[0].w<<4;
		combopool_preview.h=48;
		
		FONT* tfont = is_large?lfont_l:nfont;
		combopool_prevbtn.w = text_length(tfont, "Unweighted")+10;
		combopool_prevbtn.h = 11;
		combopool_prevbtn.x = combopool_preview.x+4;
		combopool_prevbtn.y = combopool_preview.y-combopool_prevbtn.h;
		
		mapscreen_x=0;
		mapscreen_y=16;
		mapscreensize=1;
		showedges=0;
		showallpanels=0;
		
		for(int32_t i=0; i<9; i++)
		{
			panel[i].x=58;
			panel[i].y=192;
			panel[i].w=198;
			panel[i].h=48;
		}
		
		combolist_window.x=-1;
		combolist_window.y=-1;
		combolist_window.w=-1;
		combolist_window.h=-1;
		combo_preview.x=304;
		combo_preview.y=0;
		combo_preview.w=16;
		combo_preview.h=16;
		combolistscrollers[0].w=11;
		combolistscrollers[0].h=11;
		combolistscrollers[0].x=panel[0].x+panel[0].w-15;
		combolistscrollers[0].y=panel[0].y+9;
		
		mouse_scroll_h=16;
		
		favorites_window.x=-1;
		favorites_window.y=-1;
		favorites_window.w=-1;
		favorites_window.h=-1;
		
		favorites_list.x=-1;
		favorites_list.y=-1;
		favorites_list.w=-1;
		favorites_list.h=-1;
		
		favorites_x.x = -1;
		favorites_x.y = -1;
		favorites_x.w = -1;
		favorites_x.h = -1;
		
		commands_window.x=-1;
		commands_window.y=-1;
		commands_window.w=-1;
		commands_window.h=-1;
		
		commands_list.x=-1;
		commands_list.y=-1;
		commands_list.w=-1;
		commands_list.h=-1;
		
		layer_panel.x=-1;
		layer_panel.y=-1;
		layer_panel.w=-1;
		layer_panel.h=-1;
		layerpanel_buttonwidth = 58;
		layerpanel_buttonheight = 16;
		layerpanel_checkbox_hei = 13;
		layerpanel_checkbox_wid = 13;
		
		screrrorpos.x = 575;
		screrrorpos.y = 388;
		mappage_count = 8;
	}
	
	//Dialog popups
	if(is_large)
	{
		//Help Dialogue Sizing
		help_dlg[0].w=zq_screen_w;
		help_dlg[0].h=zq_screen_h;
		help_dlg[1].w=zq_screen_w-8;
		help_dlg[1].h=zq_screen_h-27;
		help_dlg[2].w=zq_screen_w-8-4;
		help_dlg[2].h=zq_screen_h-27-4;
		
		zscripthelp_dlg[0].w=zq_screen_w;
		zscripthelp_dlg[0].h=zq_screen_h;
		zscripthelp_dlg[1].w=zq_screen_w-8;
		zscripthelp_dlg[1].h=zq_screen_h-27;
		zscripthelp_dlg[2].w=zq_screen_w-8-4;
		zscripthelp_dlg[2].h=zq_screen_h-27-4;
	
		Zstringshelp_dlg[0].w=zq_screen_w;
		Zstringshelp_dlg[0].h=zq_screen_h;
		Zstringshelp_dlg[1].w=zq_screen_w-8;
		Zstringshelp_dlg[1].h=zq_screen_h-27;
		Zstringshelp_dlg[2].w=zq_screen_w-8-4;
		Zstringshelp_dlg[2].h=zq_screen_h-27-4;
	
		shieldblockhelp_dlg[0].w=zq_screen_w;
		shieldblockhelp_dlg[0].h=zq_screen_h;
		shieldblockhelp_dlg[1].w=zq_screen_w-8;
		shieldblockhelp_dlg[1].h=zq_screen_h-27;
		shieldblockhelp_dlg[2].w=zq_screen_w-8-4;
		shieldblockhelp_dlg[2].h=zq_screen_h-27-4;
		
		edit_zscript_dlg[0].w=zq_screen_w;
		edit_zscript_dlg[0].h=zq_screen_h;
		edit_zscript_dlg[1].w=zq_screen_w-8;
		edit_zscript_dlg[1].h=zq_screen_h-27;
		edit_zscript_dlg[2].w=zq_screen_w-8-4;
		edit_zscript_dlg[2].h=zq_screen_h-27-4;
		
		editmsg_help_dlg[0].w=zq_screen_w;
		editmsg_help_dlg[0].h=zq_screen_h;
		editmsg_help_dlg[1].w=zq_screen_w-8;
		editmsg_help_dlg[1].h=zq_screen_h-27;
		editmsg_help_dlg[2].w=zq_screen_w-8-4;
		editmsg_help_dlg[2].h=zq_screen_h-27-4;
		
		enlargeIntegrityReportDialog();
	}
	
	//Ensure current combo list selected is valid
	current_combolist=vbound(current_combolist,0,num_combo_cols-1);
	current_comboalist=vbound(current_comboalist,0,num_combo_cols-1);
	current_cpoollist=vbound(current_cpoollist,0,num_combo_cols-1);
	
	//Generate bitmaps
	init_bitmap(&mapscreenbmp,16*(showedges?18:16),16*(showedges?13:11));
	init_bitmap(&brushbmp,256*mapscreensize,176*mapscreensize);
	init_bitmap(&brushscreen,(256+(showedges?16:0))*mapscreensize,(176+(showedges?16:0))*mapscreensize);
	
	init_bitmap(&screen2,zq_screen_w,zq_screen_h);
	init_bitmap(&tmp_scr,zq_screen_w,zq_screen_h);
	init_bitmap(&menu1,zq_screen_w,zq_screen_h);
	init_bitmap(&menu3,zq_screen_w,zq_screen_h);
	init_bitmap(&tooltipbmp,zq_screen_w,zq_screen_h); //Decrease size at your own risk.
	
	center_zq_class_dialogs();
	center_zq_custom_dialogs();
	center_zq_files_dialogs();
	center_zq_subscreen_dialogs();
	center_zq_tiles_dialogs();
	center_zquest_dialogs();
	
	aspect_ratio = zq_screen_h / double(zq_screen_w);
}

void remove_locked_params_on_exit()
{
    al_trace("Removing timers. \n");
    remove_int(fps_callback);
    remove_int(myvsync_callback);
    remove_int(dclick_check);
}


void cleanup_datafiles_on_exit()
{
    al_trace("Cleaning datafiles. \n");
    
    if(zcdata) unload_datafile(zcdata);
    
    if(fontsdata) unload_datafile(fontsdata);
    
    if(sfxdata) unload_datafile(sfxdata);
}


void destroy_bitmaps_on_exit()
{
    al_trace("Cleaning bitmaps...");
    destroy_bitmap(screen2);
    destroy_bitmap(tmp_scr);
    destroy_bitmap(menu1);
    destroy_bitmap(menu3);
    destroy_bitmap(mapscreenbmp);
    destroy_bitmap(dmapbmp_small);
    destroy_bitmap(dmapbmp_large);
    destroy_bitmap(brushbmp);
    destroy_bitmap(brushscreen);
    destroy_bitmap(tooltipbmp);
    al_trace("...");
    show_mouse(NULL);
    
    for(int32_t i=0; i<MOUSE_BMP_MAX*4; i++)
	{
        destroy_bitmap(mouse_bmp[i/4][i%4]);
        destroy_bitmap(mouse_bmp_1x[i/4][i%4]);
	}
        
    for(int32_t i=0; i<ICON_BMP_MAX*4; i++)
        destroy_bitmap(icon_bmp[i/4][i%4]);
        
    for(int32_t i=0; i<2; i++)
        destroy_bitmap(select_bmp[i]);
        
    for(int32_t i=0; i<MAXARROWS; i++)
        destroy_bitmap(arrow_bmp[i]);
        
    al_trace(" OK. \n");
}


void quit_game()
{
    deallocate_biic_list();
    
    
    set_last_timed_save(nullptr);
    save_config_file();
    set_palette(black_palette);
    zc_stop_midi();
    
    remove_locked_params_on_exit();
    
    al_trace("Cleaning aliases. \n");
    
    for(int32_t i=0; i<MAXCOMBOALIASES; i++)
    {
        if(combo_aliases[i].combos != NULL)
        {
            delete[] combo_aliases[i].combos;
        }
        
        if(combo_aliases[i].csets != NULL)
        {
            delete[] combo_aliases[i].csets;
        }
        
        if(temp_aliases[i].combos != NULL)
        {
            delete[] temp_aliases[i].combos;
        }
        
        if(temp_aliases[i].csets != NULL)
        {
            delete[] temp_aliases[i].csets;
        }
    }
    
    al_trace("Cleaning subscreens. \n");
    
    for(int32_t i=0; i<4; i++)
    {
        for(int32_t j=0; j<MAXSUBSCREENITEMS; j++)
        {
            switch(custom_subscreen[i].objects[j].type)
            {
            case ssoTEXT:
            case ssoTEXTBOX:
            case ssoCURRENTITEMTEXT:
            case ssoCURRENTITEMCLASSTEXT:
                if(custom_subscreen[i].objects[j].dp1 != NULL) delete[](char *)custom_subscreen[i].objects[j].dp1;
                
                break;
            }
        }
    }
    
    al_trace("Cleaning sfx. \n");
    
    for(int32_t i=0; i<WAV_COUNT; i++)
    {
        if(customsfxdata[i].data!=NULL)
        {
//      delete [] customsfxdata[i].data;
            free(customsfxdata[i].data);
        }
        
        delete [] sfx_string[i];
    }
    
    for(int32_t i=0; i<WPNCNT; i++)
    {
        delete [] weapon_string[i];
    }
    
    for(int32_t i=0; i<ITEMCNT; i++)
    {
        delete [] item_string[i];
    }
    
    for(int32_t i=0; i<eMAXGUYS; i++)
    {
        delete [] guy_string[i];
    }
    
    al_trace("Cleaning script buffer. \n");
    
    for(int32_t i=0; i<NUMSCRIPTFFC; i++)
    {
        if(ffscripts[i]!=NULL) delete ffscripts[i];
    }
    
    for(int32_t i=0; i<NUMSCRIPTITEM; i++)
    {
        if(itemscripts[i]!=NULL) delete itemscripts[i];
    }
    
    for(int32_t i=0; i<NUMSCRIPTGUYS; i++)
    {
        if(guyscripts[i]!=NULL) delete guyscripts[i];
    }
    
    for(int32_t i=0; i<NUMSCRIPTWEAPONS; i++)
    {
        if(lwpnscripts[i]!=NULL) delete lwpnscripts[i];
    }
    
    for(int32_t i=0; i<NUMSCRIPTWEAPONS; i++)
    {
        if(ewpnscripts[i]!=NULL) delete ewpnscripts[i];
    }
    
    for(int32_t i=0; i<NUMSCRIPTSCREEN; i++)
    {
        if(screenscripts[i]!=NULL) delete screenscripts[i];
    }
    
    for(int32_t i=0; i<3; i++) //should this be NUMSCRIPTGLOBAL or NUMSCRIPTGLOBALOLD? -Z
    {
        if(globalscripts[i]!=NULL) delete globalscripts[i];
    }
    
    for(int32_t i=0; i<NUMSCRIPTPLAYER; i++)
    {
        if(playerscripts[i]!=NULL) delete playerscripts[i];
    }
    
    for(int32_t i=0; i<NUMSCRIPTSDMAP; i++)
    {
        if(dmapscripts[i]!=NULL) delete dmapscripts[i];
    }
    for(int32_t i=0; i<NUMSCRIPTSITEMSPRITE; i++)
    {
        if(itemspritescripts[i]!=NULL) delete itemspritescripts[i];
    }
    for(int32_t i=0; i<NUMSCRIPTSCOMBODATA; i++)
    {
        if(comboscripts[i]!=NULL) delete comboscripts[i];
    }
    
    al_trace("Cleaning qst buffers. \n");
    del_qst_buffers();
    
    
    al_trace("Cleaning midis. \n");
    
    if(customtunes)
    {
        for(int32_t i=0; i<MAXCUSTOMMIDIS_ZQ; i++)
            customtunes[i].reset();
            
        free(customtunes);
    }
    
    al_trace("Cleaning undotilebuf. \n");
    
    if(undocombobuf) free(undocombobuf);
    
    if(newundotilebuf)
    {
        for(int32_t i=0; i<NEWMAXTILES; i++)
            if(newundotilebuf[i].data) free(newundotilebuf[i].data);
            
        free(newundotilebuf);
    }
    
    if(filepath) free(filepath);
    
    if(temppath) free(temppath);
    
    if(datapath) free(datapath);
    
    if(midipath) free(midipath);
    
    if(imagepath) free(imagepath);
    
    if(tmusicpath) free(tmusicpath);
    
    if(last_timed_save) free(last_timed_save);
    
    cleanup_datafiles_on_exit();
    destroy_bitmaps_on_exit();
}

void quit_game2()
{
    deallocate_biic_list();
    
    
    set_last_timed_save(nullptr);
    save_config_file();
    set_palette(black_palette);
    zc_stop_midi();
    
    remove_locked_params_on_exit();
    
    al_trace("Cleaning aliases. \n");
    
    for(int32_t i=0; i<MAXCOMBOALIASES; i++)
    {
        if(combo_aliases[i].combos != NULL)
        {
            delete[] combo_aliases[i].combos;
        }
        
        if(combo_aliases[i].csets != NULL)
        {
            delete[] combo_aliases[i].csets;
        }
        
        if(temp_aliases[i].combos != NULL)
        {
            delete[] temp_aliases[i].combos;
        }
        
        if(temp_aliases[i].csets != NULL)
        {
            delete[] temp_aliases[i].csets;
        }
    }
    
    al_trace("Cleaning subscreens. \n");
    
    for(int32_t i=0; i<4; i++)
    {
        for(int32_t j=0; j<MAXSUBSCREENITEMS; j++)
        {
            switch(custom_subscreen[i].objects[j].type)
            {
            case ssoTEXT:
            case ssoTEXTBOX:
            case ssoCURRENTITEMTEXT:
            case ssoCURRENTITEMCLASSTEXT:
                if(custom_subscreen[i].objects[j].dp1 != NULL) delete[](char *)custom_subscreen[i].objects[j].dp1;
                
                break;
            }
        }
    }
    
    al_trace("Cleaning sfx. \n");
    
    for(int32_t i=0; i<WAV_COUNT; i++)
    {
        if(customsfxdata[i].data!=NULL)
        {
//      delete [] customsfxdata[i].data;
            free(customsfxdata[i].data);
        }
        
        delete [] sfx_string[i];
    }
    
    for(int32_t i=0; i<WPNCNT; i++)
    {
        delete [] weapon_string[i];
    }
    
    for(int32_t i=0; i<ITEMCNT; i++)
    {
        delete [] item_string[i];
    }
    
    for(int32_t i=0; i<eMAXGUYS; i++)
    {
        delete [] guy_string[i];
    }
    
    al_trace("Cleaning script buffer. \n");
    
    for(int32_t i=0; i<NUMSCRIPTFFC; i++)
    {
        if(ffscripts[i]!=NULL) delete ffscripts[i];
    }
    
    for(int32_t i=0; i<NUMSCRIPTITEM; i++)
    {
        if(itemscripts[i]!=NULL) delete itemscripts[i];
    }
    
    for(int32_t i=0; i<NUMSCRIPTGUYS; i++)
    {
        if(guyscripts[i]!=NULL) delete guyscripts[i];
    }
    
    for(int32_t i=0; i<NUMSCRIPTWEAPONS; i++)
    {
        if(lwpnscripts[i]!=NULL) delete lwpnscripts[i];
    }
    
    for(int32_t i=0; i<NUMSCRIPTWEAPONS; i++)
    {
        if(ewpnscripts[i]!=NULL) delete ewpnscripts[i];
    }
    
    for(int32_t i=0; i<NUMSCRIPTSCREEN; i++)
    {
        if(screenscripts[i]!=NULL) delete screenscripts[i];
    }
    
    for(int32_t i=0; i<3; i++) //should this be NUMSCRIPTGLOBAL or NUMSCRIPTGLOBALOLD? -Z
    {
        if(globalscripts[i]!=NULL) delete globalscripts[i];
    }
    
    for(int32_t i=0; i<NUMSCRIPTPLAYER; i++)
    {
        if(playerscripts[i]!=NULL) delete playerscripts[i];
    }
    
    for(int32_t i=0; i<NUMSCRIPTSDMAP; i++)
    {
        if(dmapscripts[i]!=NULL) delete dmapscripts[i];
    }
    for(int32_t i=0; i<NUMSCRIPTSITEMSPRITE; i++)
    {
        if(itemspritescripts[i]!=NULL) delete itemspritescripts[i];
    }
    for(int32_t i=0; i<NUMSCRIPTSCOMBODATA; i++)
    {
        if(comboscripts[i]!=NULL) delete comboscripts[i];
    }
    
    al_trace("Cleaning qst buffers. \n");
    del_qst_buffers();
    
    
    al_trace("Cleaning midis. \n");
    
    if(customtunes)
    {
        for(int32_t i=0; i<MAXCUSTOMMIDIS_ZQ; i++)
            customtunes[i].reset();
            
        free(customtunes);
    }
    
    al_trace("Cleaning undotilebuf. \n");
    
    if(undocombobuf) free(undocombobuf);
    
    if(newundotilebuf)
    {
        for(int32_t i=0; i<NEWMAXTILES; i++)
            if(newundotilebuf[i].data) free(newundotilebuf[i].data);
            
        free(newundotilebuf);
    }
    
    if(filepath) free(filepath);
    
    if(temppath) free(temppath);
    
    if(datapath) free(datapath);
    
    if(midipath) free(midipath);
    
    if(imagepath) free(imagepath);
    
    if(tmusicpath) free(tmusicpath);
    
    if(last_timed_save) free(last_timed_save);
    
    cleanup_datafiles_on_exit();
    //destroy_bitmaps_on_exit();
}

void center_zquest_dialogs()
{
    jwin_center_dialog(assignscript_dlg);
    jwin_center_dialog(autolayer_dlg);
    jwin_center_dialog(clist_dlg);
    jwin_center_dialog(cpage_dlg);
    center_zq_cset_dialogs();
    jwin_center_dialog(change_track_dlg);
    jwin_center_dialog(csetfix_dlg);
    jwin_center_dialog(dmapmaps_dlg);
    center_zq_door_dialogs();
    jwin_center_dialog(editcomboa_dlg);
    jwin_center_dialog(editdmap_dlg);
    jwin_center_dialog(editinfo_dlg);
    jwin_center_dialog(editmidi_dlg);
    jwin_center_dialog(editmusic_dlg);
    jwin_center_dialog(editshop_dlg);
    jwin_center_dialog(elist_dlg);
    jwin_center_dialog(enemy_dlg);
    jwin_center_dialog(ffcombo_sel_dlg);
    jwin_center_dialog(getnum_dlg);
    jwin_center_dialog(glist_dlg);
    jwin_center_dialog(help_dlg);
    jwin_center_dialog(ilist_dlg);
    jwin_center_dialog(layerdata_dlg);
    jwin_center_dialog(list_dlg);
    jwin_center_dialog(loadmap_dlg);
    jwin_center_dialog(mapstyles_dlg);
    jwin_center_dialog(misccolors_dlg);
    jwin_center_dialog(newcomboa_dlg);
    jwin_center_dialog(options_dlg);
    jwin_center_dialog(orgcomboa_dlg);
    jwin_center_dialog(path_dlg);
    jwin_center_dialog(pattern_dlg);
    jwin_center_dialog(scrdata_dlg);
    jwin_center_dialog(screen_pal_dlg);
    jwin_center_dialog(secret_dlg);
    jwin_center_dialog(selectdmap_dlg);
    jwin_center_dialog(selectmidi_dlg);
    jwin_center_dialog(selectmusic_dlg);
    jwin_center_dialog(sfxlist_dlg);
    jwin_center_dialog(sfx_edit_dlg);
    jwin_center_dialog(showpal_dlg);
    jwin_center_dialog(strlist_dlg);
    jwin_center_dialog(subscreen_type_dlg);
    jwin_center_dialog(template_dlg);
    center_zq_tiles_dialog();
    jwin_center_dialog(tp_dlg);
    jwin_center_dialog(under_dlg);
    jwin_center_dialog(warp_dlg);
    jwin_center_dialog(warpring_dlg);
    jwin_center_dialog(wlist_dlg);
    center_zscript_dialogs();
}


void animate_coords()
{
    coord_frame=(coord_timer>>3)&3;
    
    if(++coord_timer>=(1<<5))
    {
        coord_timer=0;
    }
}

static int32_t help_pos=0;

static const char *help_list[] =
{
    "PREVIEW MODE",
    "PgUp/PgDn - Scroll through hotkey list",
    "Esc/Enter - Exit Preview Mode",
    "R - Restore screen to original state",
    "C - Toggle combo cycling On/Off",
    "S - Trigger screen secrets",
    "Q/W/F - These still work",
    "P - Pause everything",
    "A - Advance frame-by-frame",
    "1-4 - Trigger tile warp A-D",
    "5-8 - Trigger side warp A-D",
    "9 - Enable timed warps",
    "",
    "",
};

void do_animations()
{
    if(AnimationOn||CycleOn)
    {
        if(AnimationOn)
        {
            animate_combos();
            update_freeform_combos();
        }
        
        if(CycleOn)
        {
            cycle_palette();
        }
    }
    
    animate_coords();
    custom_vsync();
}

void do_previewtext()
{
    //Put in help areas
    textprintf_ex(menu1,font,panel[8].x+1,panel[8].y+3,jwin_pal[jcTEXTFG],-1,"%s",help_list[help_pos]);
    textprintf_ex(menu1,font,panel[8].x+1,panel[8].y+8+3,jwin_pal[jcTEXTFG],-1,"%s",help_list[help_pos+1]);
    textprintf_ex(menu1,font,panel[8].x+1,panel[8].y+16+3,jwin_pal[jcTEXTFG],-1,"%s",help_list[help_pos+2]);
    textprintf_ex(menu1,font,panel[8].x+1,panel[8].y+24+3,jwin_pal[jcTEXTFG],-1,"%s",help_list[help_pos+3]);
    textprintf_ex(menu1,font,panel[8].x+1,panel[8].y+32+3,jwin_pal[jcTEXTFG],-1,"%s",help_list[help_pos+4]);
    
    if(!is_large) return;
    
    textprintf_ex(menu1,font,panel[8].x+1,panel[8].y+40+3,jwin_pal[jcTEXTFG],-1,"%s",help_list[help_pos+5]);
    
	if(is_compact)
	{
		int offs = 0;
		for(auto q = 0; q < 6; ++q)
		{
			int len = text_length(font,help_list[help_pos+q]);
			if(len > offs)
				offs = len;
		}
		offs += 2;
		textprintf_ex(menu1,font,panel[8].x+1+offs,panel[8].y+3,jwin_pal[jcTEXTFG],-1,"%s",help_list[help_pos+6]);
		textprintf_ex(menu1,font,panel[8].x+1+offs,panel[8].y+8+3,jwin_pal[jcTEXTFG],-1,"%s",help_list[help_pos+7]);
		textprintf_ex(menu1,font,panel[8].x+1+offs,panel[8].y+16+3,jwin_pal[jcTEXTFG],-1,"%s",help_list[help_pos+8]);
		textprintf_ex(menu1,font,panel[8].x+1+offs,panel[8].y+24+3,jwin_pal[jcTEXTFG],-1,"%s",help_list[help_pos+9]);
		textprintf_ex(menu1,font,panel[8].x+1+offs,panel[8].y+32+3,jwin_pal[jcTEXTFG],-1,"%s",help_list[help_pos+10]);
		textprintf_ex(menu1,font,panel[8].x+1+offs,panel[8].y+40+3,jwin_pal[jcTEXTFG],-1,"%s",help_list[help_pos+11]);
	}
	else
	{
		textprintf_ex(menu1,font,panel[8].x+1,panel[8].y+48+3,jwin_pal[jcTEXTFG],-1,"%s",help_list[help_pos+6]);
		textprintf_ex(menu1,font,panel[8].x+1,panel[8].y+56+3,jwin_pal[jcTEXTFG],-1,"%s",help_list[help_pos+7]);
		textprintf_ex(menu1,font,panel[8].x+1,panel[8].y+64+3,jwin_pal[jcTEXTFG],-1,"%s",help_list[help_pos+8]);
		textprintf_ex(menu1,font,panel[8].x+1,panel[8].y+72+3,jwin_pal[jcTEXTFG],-1,"%s",help_list[help_pos+9]);
		textprintf_ex(menu1,font,panel[8].x+1,panel[8].y+81+3,jwin_pal[jcTEXTFG],-1,"%s",help_list[help_pos+10]);
		textprintf_ex(menu1,font,panel[8].x+1,panel[8].y+90+3,jwin_pal[jcTEXTFG],-1,"%s",help_list[help_pos+11]);
	}
}


bool reload_fonts = false;
int32_t d_nbmenu_proc(int32_t msg,DIALOG *d,int32_t c)
{
	static int32_t ret=D_O_K;
	if(reload_fonts)
	{
		init_custom_fonts();
		load_size_poses();
		reload_fonts = false;
	}
	domouse();
	do_animations();
	refresh(rCLEAR|rALL);
	
	if(msg==MSG_GOTMOUSE||msg==MSG_XCHAR)
	{
		ComboBrushPause=1;
		refresh(rMAP);
		ComboBrushPause=0;
		// restore_mouse();
		clear_tooltip();
	}
	
	//YIELD();
	rest(4);
	ret = jwin_menu_proc(msg,d,c);
	
	return ret;
}

bool prv_press=false;

void dopreview()
{
    //set_mouse_sprite(mouse_bmp[MOUSE_BMP_FLAG][0]);
    refresh(rMAP);
    
    while(!(gui_mouse_b()))
    {
        //ret = jwin_menu_proc(msg,d,c);
        if(keypressed())
        {
            if(!prv_press)
            {
                prv_press=true;
                
                switch(readkey()>>8)
                {
                case KEY_ESC:
                case KEY_ENTER:
                case KEY_ENTER_PAD:
                    goto finished;
                    break;
                    
                case KEY_F:
                    Flags^=cFLAGS;
                    refresh(rMAP);
                    break;
                    
                case KEY_R:
                    onRKey();
                    break;
                    
                case KEY_S:
                    onSKey();
                    break;
                    
                    /*
                              case KEY_E:
                                Map.prv_secrets(true);
                                refresh(rALL);
                                break;
                    */
                case KEY_C:
                    onCopy();
                    break;
                    
                case KEY_A:
                    onAKey();
                    break;
                    
                case KEY_P:
                    onP();
                    break;
				
				case KEY_L:
					onShowDarkness();
					break;
                    
                case KEY_1:
                    Map.prv_dowarp(0,0);
                    prv_warp=0;
                    break;
                    
                case KEY_2:
                    Map.prv_dowarp(0,1);
                    prv_warp=0;
                    break;
                    
                case KEY_3:
                    Map.prv_dowarp(0,2);
                    prv_warp=0;
                    break;
                    
                case KEY_4:
                    Map.prv_dowarp(0,3);
                    prv_warp=0;
                    break;
                    
                case KEY_5:
                    Map.prv_dowarp(1,0);
                    prv_warp=0;
                    break;
                    
                case KEY_6:
                    Map.prv_dowarp(1,1);
                    prv_warp=0;
                    break;
                    
                case KEY_7:
                    Map.prv_dowarp(1,2);
                    prv_warp=0;
                    break;
                    
                case KEY_8:
                    Map.prv_dowarp(1,3);
                    prv_warp=0;
                    break;
                    
                case KEY_9:
                    if(prv_twon)
                    {
                        prv_twon=0;
                        Map.set_prvtime(0);
                        prv_warp=0;
                    }
                    else
                    {
                        Map.set_prvtime(Map.get_prvscr()->timedwarptics);
                        prv_twon=1;
                    }
                    
                    break;
                    
                case KEY_W:
                    onShowWalkability();
                    break;
                    
                case KEY_Q:
                    onShowComboInfoCSet();
                    break;
                    
                case KEY_PGUP:
                    help_pos--;
                    
                    if(help_pos<0)
                    {
                        help_pos=0;
                    }
                    
                    break;
                    
                case KEY_PGDN:
                    help_pos++;
                    
                    if(help_pos>(is_large ? 1 : 9))
                    {
                        help_pos--;
                    }
                    
                    break;
                }
            }
            else
            {
                readkey();
            }
        }
        else
        {
            prv_press=false;
        }
        
        if(prv_warp)
        {
            Map.prv_dowarp(1,0);
            prv_warp=0;
        }
        
        if(Map.get_prvfreeze())
        {
            if(Map.get_prvadvance())
            {
                do_animations();
                Map.set_prvadvance(0);
            }
        }
        else
        {
            do_animations();
            Map.set_prvadvance(0);
        }
        
        refresh(rALL);
    }
    
finished:
    //Flags=of;
    reset_combo_animations();
    reset_combo_animations2();
    set_mouse_sprite(mouse_bmp[MOUSE_BMP_NORMAL][0]);
    prv_mode=0;
    Map.set_prvcmb(0);
    Map.set_prvadvance(0);
    Map.set_prvfreeze(0);
    Map.set_prvtime(0);
    prv_warp=0;
    loadlvlpal(Map.getcolor());
    rebuild_trans_table();
    refresh(rMAP+rMENU);
    
    while(gui_mouse_b())
    {
        /* do nothing */
        rest(1);
    }
}

void call_vidmode_dlg();
int32_t onZQVidMode()
{
    call_vidmode_dlg();
    return D_O_K;
}

bool is_zquest()
{
    return true;
}

bool screenIsScrolling()
{
    return false;
}

void write_includepaths()
{
	FILE* f = fopen("includepaths.txt", "w");
	if(f)
	{
		fwrite(FFCore.includePathString,1,strlen(FFCore.includePathString),f);
		fclose(f);
	}
}

int32_t save_config_file()
{
    //packfile_password("");

    char cmdnametitle[20];
    char qtnametitle[20];
    char qtpathtitle[20];
    char *datapath2=(char *)malloc(2048);
    char *midipath2=(char *)malloc(2048);
    char *imagepath2=(char *)malloc(2048);
    char *tmusicpath2=(char *)malloc(2048);
    strcpy(datapath2, datapath);
    strcpy(midipath2, midipath);
    strcpy(imagepath2, imagepath);
    strcpy(tmusicpath2, tmusicpath);
    chop_path(datapath2);
    chop_path(midipath2);
    chop_path(imagepath2);
    chop_path(tmusicpath2);
    
	zc_set_config("ZCMODULE","current_module",moduledata.module_name);
	//
	write_includepaths();
	
    zc_set_config("zquest",data_path_name,datapath2);
    zc_set_config("zquest",midi_path_name,midipath2);
    zc_set_config("zquest",image_path_name,imagepath2);
    zc_set_config("zquest",tmusic_path_name,tmusicpath2);
	
    if (all_get_display() && !all_get_fullscreen_flag() && SaveDragResize) 
    {
		double monitor_scale = zc_get_monitor_scale();
		window_width = al_get_display_width(all_get_display()) / monitor_scale;
		window_height = al_get_display_height(all_get_display()) / monitor_scale;
		if (is_large) 
		{
			zc_set_config("zquest","large_window_width",window_width);
			zc_set_config("zquest","large_window_height",window_height);
		}
		else
		{
			zc_set_config("zquest","small_window_width",window_width);
			zc_set_config("zquest","small_window_height",window_height);
		}
    }
    if (all_get_display() && !all_get_fullscreen_flag() && SaveWinPos)
    {
		int o_window_x, o_window_y;
		al_get_window_position(all_get_display(), &o_window_x, &o_window_y);
		zc_set_config("zquest", "window_x", o_window_x);
		zc_set_config("zquest", "window_y", o_window_y);
    }
    
	byte b = 0;
    for(int32_t x=0; x<7; x++)
    {
        set_bit(&b,x,LayerMaskInt[x]);
    }
    
    zc_set_config("zquest","layer_mask",b);
    
    for(int32_t x=1; x<qt_count+1; x++)
    {
        sprintf(qtnametitle, qtname_name, x);
        sprintf(qtpathtitle, qtpath_name, x);
        
        if(QuestTemplates[x].path[0]!=0)
        {
            zc_set_config("zquest",qtnametitle,QuestTemplates[x].name);
            zc_set_config("zquest",qtpathtitle,QuestTemplates[x].path);
        }
        else
        {
            break;
        }
    }
    
    //save the beta warning confirmation info
	char *uniquestr = getBetaControlString();
	zc_set_config("zquest", "beta_warning", uniquestr);
	delete[] uniquestr;
    
    flush_config_file();
#ifdef __EMSCRIPTEN__
    em_sync_fs();
#endif
    free(datapath2);
    free(midipath2);
    free(imagepath2);
    free(tmusicpath2);
    return 0;
}

int32_t d_timer_proc(int32_t msg, DIALOG *d, int32_t c)
{
    //these are here to bypass compiler warnings about unused arguments
    c=c;
    d=d;
    
    switch(msg)
    {
    case MSG_IDLE:
#ifdef _WIN32
        if(zqUseWin32Proc != FALSE)
            win32data.Update(Frameskip); //experimental win32 fixes
            
#endif
            
        // This has been crashing on Windows, and it saves plenty without it
        //check_autosave();
        break;
    }
    
    return D_O_K;
}

void check_autosave()
{
    if(AutoSaveInterval>0)
    {
        time(&auto_save_time_current);
        auto_save_time_diff = difftime(auto_save_time_current,auto_save_time_start);
        
        if(auto_save_time_diff>AutoSaveInterval*60)
        {
            set_mouse_sprite(mouse_bmp[MOUSE_BMP_NORMAL][0]);
            if(first_save)
                replace_extension(last_timed_save, filepath, "qt0", 2047);
            else
                strcpy(last_timed_save, "untitled.qt0");
			set_last_timed_save(last_timed_save);
            go();
            
            if((header.zelda_version != ZELDA_VERSION || header.build != VERSION_BUILD) && first_save)
            {
                jwin_alert("Auto Save","This quest was saved in an older version of ZQuest.","If you wish to use the autosave feature, you must manually","save the files in this version first.","OK",NULL,13,27,lfont);
                time(&auto_save_time_start);
                comeback();
                return;
            }
            
            int32_t ret = save_quest(last_timed_save, true);
            
            if(ret)
            {
                jwin_alert("Error","Timed save did not complete successfully.",NULL,NULL,"O&K",NULL,'k',0,lfont);
                set_last_timed_save(nullptr);
            }
            
            save_config_file();
            time(&auto_save_time_start);
            comeback();
        }
    }
}

void flushItemCache() {}
void ringcolor(bool forceDefault)
{
    forceDefault=forceDefault;
}

//annoying beta message :)
char *getBetaControlString()
{
    char *result = new char[11];
    const char *compiledate = __DATE__;
    const char *compiletime = __TIME__;
    int32_t i=0;
    byte tempbyte;
    
    for(i=0; i<zc_min(10, zc_min((int32_t)strlen(compiledate),(int32_t)strlen(compiletime))); i++)
    {
        tempbyte = (compiledate[i]*compiletime[i])^i;
        tempbyte = zc_max(tempbyte, 33);
        tempbyte = zc_min(126, tempbyte);
        result[i] = tempbyte;
    }
    
    for(int32_t j=i; j<11; ++j)
    {
        result[j] = '\0';
    }
    
    return result;
}

bool item_disabled(int32_t)
{
    return false;
}

int32_t onCmdExit()
{
    // replaces onExit for the -large button command "Exit"
    close_button_quit = true;
    return 0;
}

//remember to adjust this number in zquest.h if it changes here!
//P.S: Must be listed in the same order as the enum in zquest.h. No exceptions! -L
//These auto-alphabetize in the dialog! Don't add in the middle! -Em
//Starting with a space in the name invalidates it- it will not appear in the dialog, and will be set to 0 in configs. -Em
command_pair commands[cmdMAX]=
{
    { "(None)",                             0, NULL },
    { "About",                              0, (intF) onAbout },
    { " Catch All",                         0, NULL },
    { "Change track",                       0, (intF) changeTrack },
    { "Cheats",                             0, (intF) onCheats },
    { "Color Set Fix",                      0, (intF) onCSetFix },
    { "Combo Alias Mode",                   0, (intF) onDrawingModeAlias },
    { "Edit Combo Aliases",                 0, (intF) onEditComboAlias },
    { "Combos",                             0, (intF) onCombos },
    { "Compile ZScript",                    0, (intF) onCompileScript },
    { "Copy",                               0, (intF) onCopy },
    { "Default Combos",                     0, (intF) onDefault_Combos },
    { "Delete Map",                         0, (intF) onDeleteMap },
    { "Delete Screen",                      0, (intF) onDelete },
    { "DMaps",                              0, (intF) onDmaps },
    { "Door Combo Sets",                    0, (intF) onDoorCombos },
    { "Edit Doors",                         0, (intF) onDoors },
    { "Paste Doors",                        0, (intF) onPasteDoors },
    { "Dungeon Carving Mode",               0, (intF) onDrawingModeDungeon },
    { "End String",                         0, (intF) onEndString },
    { "Enemy Editor",                       0, (intF) onCustomEnemies },
    { "Default Enemies",                    0, (intF) onDefault_Guys },
    { "Set Enemies",                        0, (intF) onEnemies },
    { "Paste Enemies",                      0, (intF) onPasteEnemies },
    { " Enhanced Music",                    0, (intF) onEnhancedMusic },
    { "Exit",                               0, (intF) onCmdExit },
    { "Export Combos",                      0, (intF) onExport_Combos },
    { "Export DMaps",                       0, (intF) onExport_DMaps },
    { "Export Map",                         0, (intF) onExport_Map },
    { "Export Palettes",                    0, (intF) onExport_Pals },
    { "Export Quest Template",              0, (intF) onExport_ZQT },
    { "Export Strings",                     0, (intF) onExport_Msgs },
    { "Export Subscreen",                   0, (intF) onExport_Subscreen },
    { "Export Tiles",                       0, (intF) onExport_Tiles },
    { "Export Unencoded Quest",             0, (intF) onExport_UnencodedQuest },
    { "Export Graphics Pack",               0, (intF) onExport_ZGP },
    { "Flags",                              0, (intF) onFlags },
    { "Paste Freeform Combos",              0, (intF) onPasteFFCombos },
    { "Freeform Combos",                    0, (intF) onSelectFFCombo },
    { "Toggle Fullscreen",                  0, (intF) onFullScreen },
    { "Game icons",                         0, (intF) onIcons },
    { "Goto Map",                           0, (intF) onGotoMap },
    { " Guy",                               0,  NULL },
    { "Paste Guy/String",                   0, (intF) onPasteGuy },
    { "Header",                             0, (intF) onHeader },
    { "Help",                               0, (intF) onHelp },
    { "Import ZASM",                        0, (intF) onImportZASM },
    { " Import Global ASM Script",          0, NULL },
    { " Import Item ASM Script",            0, NULL },
    { "Import Combos",                      0, (intF) onImport_Combos },
    { "Import DMaps",                       0, (intF) onImport_DMaps },
    { "Import Graphics Pack",               0, (intF) onImport_ZGP },
    { "Import Map",                         0, (intF) onImport_Map },
    { "Import Palettes",                    0, (intF) onImport_Pals },
    { "Import Quest Template",              0, (intF) onImport_ZQT },
    { "Import Strings",                     0, (intF) onImport_Msgs },
    { "Import Subscreen",                   0, (intF) onImport_Subscreen },
    { "Import Tiles",                       0, (intF) onImport_Tiles },
    { "Import Unencoded Quest",             0, (intF) onImport_UnencodedQuest },
    { "Info Types",                         0, (intF) onInfoTypes },
    { "Init Data",                          0, (intF) onInit },
    { "Integ. Check (All)",                 0, (intF) onIntegrityCheckAll },
    { "Integ. Check (Screens)",             0, (intF) onIntegrityCheckRooms },
    { "Integ. Check (Warps)",               0, (intF) onIntegrityCheckWarps },
    { "Set Item",                           0, (intF) onItem },
    { "Item Editor",                        0, (intF) onCustomItems },
    { "Layers",                             0, (intF) onLayers },
    { "Paste Layers",                       0, (intF) onPasteLayers },
    { "Palettes - Levels",                  0, (intF) onColors_Levels },
    { "Player Sprite",                        0, (intF) onCustomHero },
    { "List Combos Used",                   0, (intF) onUsedCombos },
    { "Palettes - Main",                    0, (intF) onColors_Main },
    { " Map Count",                         0, NULL },
    { "Default Map Styles",                 0, (intF) onDefault_MapStyles },
    { "Map Styles",                         0, (intF) onMapStyles },
    { "Master Subscreen Type",              0, (intF) onSubscreen },
    { " Message String",                    0, NULL },
    { "MIDIs",                              0, (intF) onMidis },
    { "Misc Colors",                        0, (intF) onMiscColors },
    { "New",                                0, (intF) do_NewQuest },
    { "Normal Mode",                        0, (intF) onDrawingModeNormal },
    { "Open",                               0, (intF) do_OpenQuest },
    { "Options",                            0, (intF) onOptions },
    { "Palette",                            0, (intF) onScreenPalette },
    { "Default Palettes",                   0, (intF) onDefault_Pals },
    { "Paste",                              0, (intF) onPaste },
    { "Paste All",                          0, (intF) onPasteAll },
    { "Paste All To All",                   0, (intF) onPasteAllToAll },
    { "Paste To All",                       0, (intF) onPasteToAll },
    { "Maze Path",                          0, (intF) onPath },
    { "Play Music",                         0, (intF) playMusic },
    { "Preview Mode",                       0, (intF) onPreviewMode },
    { "Quest Templates",                    0, (intF) onQuestTemplates },
    { "Apply Template to All",              0, (intF) onReTemplate },
    { "Relational Mode",                    0, (intF) onDrawingModeRelational },
    { "Revert",                             0, (intF) onRevert },
    { "Room Data",                          0, (intF) onRoom },
    { "Paste Room Type Data",               0, (intF) onPasteRoom },
    { " Rules - Animation",                 0, NULL },
    { "Save",                               0, (intF) onSave },
    { "Save as",                            0, (intF) onSaveAs },
    { "Paste Screen Data",                  0, (intF) onPasteScreenData },
    { "Screen Data",                        0, (intF) onScrData },
    { "Paste Secret Combos",                0, (intF) onPasteSecretCombos },
    { "Secret Combos",                      0, (intF) onSecretCombo },
    { "SFX Data",                           0, (intF) onSelectSFX },
    { "Shop Types",                         0, (intF) onShopTypes },
    { "Side Warp",                          0, (intF) onSideWarp },
    { "Palettes - Sprites",                 0, (intF) onColors_Sprites },
    { "Default Weapon Sprites",             0, (intF) onDefault_Weapons },
    { "Stop Tunes",                         0, (intF) stopMusic },
    { "Strings",                            0, (intF) onStrings },
    { "Subscreens",                         0, (intF) onEditSubscreens },
    { "Take ZQ Snapshot",                   0, (intF) onSnapshot },
    { "Ambient Music",                      0, (intF) playTune1 },
    { "NES Dungeon Template",               0, (intF) onTemplate },
    { "Edit Templates",                     0, (intF) onTemplates },
    { "Tile Warp",                          0, (intF) onTileWarp },
    { "Default Tiles",                      0, (intF) onDefault_Tiles },
    { "Tiles",                              0, (intF) onTiles },
    { "Toggle Grid",                        0, (intF) onToggleGrid },
    { "Triforce Pieces",                    0, (intF) onTriPieces },
    { "Under Combo",                        0, (intF) onUnderCombo },
    { "Paste Undercombo",                   0, (intF) onPasteUnderCombo },
    { "Undo",                               0, (intF) onUndo },
    { "Video Mode",                         0, (intF) onZQVidMode },
    { "View Map",                           0, (intF) onViewMap },
    { "View Palette",                       0, (intF) onShowPal },
    { "View Pic",                           0, (intF) onViewPic },
    { "Paste Warp Return",                  0, (intF) onPasteWarpLocations },
    { "Warp Rings",                         0, (intF) onWarpRings },
    { "Paste Warps",                        0, (intF) onPasteWarps },
    { "Sprite Data",                        0, (intF) onCustomWpns },
    { "View Darkness",                      0, (intF) onShowDarkness },
    { "Toggle Walkability",                 0, (intF) onShowWalkability },
    { "Toggle Flags",                       0, (intF) onShowFlags },
    { "Toggle CSets",                       0, (intF) onShowCSet },
    { "Toggle Types",                       0, (intF) onShowCType },
    { " Rules - Combos",                    0, NULL },
    { " Rules - Items",                     0, NULL },
    { " Rules - Enemies",                   0, NULL },
    { " Rules - NES Fixes",                 0, NULL },
    { " Rules - Other",                     0, NULL },
    { "Default Items",                      0, (intF) onDefault_Items },
    { "Item Drop Set Editor",               0, (intF) onItemDropSets },
    { "Paste Palette",                      0, (intF) onPastePalette },
    { "Quest Rules",                        0, (intF) onRulesDlg },
    { "Report: Combo Locations",            0, (intF) onComboLocationReport },
    { "Report: Combo Type Locs.",           0, (intF) onComboTypeLocationReport },
    { "Report: Enemy Locations",            0, (intF) onEnemyLocationReport },
    { "Report: Item Locations",             0, (intF) onItemLocationReport },
    { "Report: Script Locations",           0, (intF) onScriptLocationReport },
    { "Report: What Links Here",            0, (intF) onWhatWarpsReport },
    { "Report: Integrity Check",            0, (intF) onIntegrityCheckAll },
    { " Save ZQuest Settings",              0, NULL },
    { "Clear Quest Filepath",               0, (intF) onClearQuestFilepath },
    { "Find Buggy Next->",                  0, (intF) onBuggedNextComboLocationReport },
    { "Rules - ZScript",                    0, (intF) onZScriptSettings },
    { "Export ZASM",                        0, (intF) onExportZASM },
    { " Rules - Hero",                      0, NULL },
    { "Rules - Compiler",                   0, (intF) onZScriptCompilerSettings },
    { " Rules - Weapons",                   0, NULL },
    { "Screen Script",                      0, (intF) onScreenScript },
    { "Take Screen Snapshot",               0, (intF) onMapscrSnapshot },
    { "View L2 as BG",                      0, (intF) onLayer2BG },
    { "View L3 as BG",                      0, (intF) onLayer3BG },
    { "Bottle Types",                       0, (intF) onBottleTypes },
    { "Bottle Shop Types",                  0, (intF) onBottleShopTypes },
    { "Water Solidity Fix",                 0, (intF) onWaterSolidity },
    { "Effect Square Fix",                  0, (intF) onEffectFix },
    { "Test Quest",                         0, (intF) onTestQst },
    { "Redo",                               0, (intF) onRedo },
    { "Combo Pool Mode",                    0, (intF) onDrawingModePool },
    { "Quest Rules Search",                 0, (intF) onRulesSearch }
};

/********************************/
/*****      Tool Tips      ******/
/********************************/
int32_t strchrnum(char *str, char c)
{
	for(int32_t i=0; str[i]; ++i)
	{
		if(str[i]==c)
		{
			return i;
		}
	}
	
	return -1;
}

int32_t get_longest_line_length(FONT *f, char *str)
{
	int32_t maxlen=0;
	//char *kill=(char *)calloc(strlen(str),1);
	char *tmpstr=str;
	char temp=0;
	//sprintf(tmpstr, "%s", str);
	int32_t t=0;
	int32_t new_t=-1;
	while(tmpstr[0])
	{
		t=strchrnum(tmpstr, '\n');
		
		if(t==-1)
		{
			t=(int32_t)strlen(tmpstr);
		}
		
		if((uint32_t)t!=strlen(tmpstr))
		{
			new_t=t+1;
		}
		else
		{
			new_t=-1;
		}
		
		temp = tmpstr[t];
		tmpstr[t]=0;
		maxlen=zc_max(maxlen,text_length(f, tmpstr));
		tmpstr[t]=temp;
		
		if(new_t!=-1)
		{
			tmpstr+=new_t;
		}
		else break;
	}
	
	//free(kill);
	return maxlen;
}

int32_t count_lines(char *str)
{
	int32_t count=1;
	
	for(word i=0; i<strlen(str); ++i)
	{
		if(str[i]=='\n')
		{
			++count;
		}
	}
	
	return count;
}

void update_tooltip(int32_t x, int32_t y, size_and_pos const& sqr, char *tipmsg)
{
	update_tooltip(x,y,sqr.x,sqr.y,sqr.w,sqr.h,tipmsg);
}
void update_tooltip(int32_t x, int32_t y, int32_t trigger_x, int32_t trigger_y, int32_t trigger_w, int32_t trigger_h, char *tipmsg)
{
	if(!EnableTooltips)
	{
		return;
	}
	
	tooltip_trigger.x=trigger_x;
	tooltip_trigger.y=trigger_y;
	tooltip_trigger.w=trigger_w;
	tooltip_trigger.h=trigger_h;
	
	
	if(x<0||y<0) //if we want to clear the tooltip
	{
		tooltip_box.x=x;
		tooltip_box.y=y;
		tooltip_box.w=0;
		tooltip_box.h=0;
		tooltip_timer=0;
		tooltip_highlight.clear();
		return; //cancel
	}
	tooltip_highlight.set(trigger_x, trigger_y, trigger_w, trigger_h);
	FONT* oldfont = font;
	font = get_custom_font(CFONT_TTIP);
	
	y+=16;
	
	if(tooltip_timer<=tooltip_maxtimer)
	{
		++tooltip_timer;
	}
	
	if(tooltip_timer==tooltip_maxtimer)
	{
		tooltip_box.x=x;
		tooltip_box.y=y;
		int32_t lines=count_lines(tipmsg);
		tooltip_box.w=get_longest_line_length(font, tipmsg)+8+1;
		tooltip_box.h = (lines * text_height(font)) + 8 + 1;
		if (tooltip_box.w > zq_screen_w)
			tooltip_box.w = zq_screen_w;
		if (tooltip_box.h > zq_screen_h)
			tooltip_box.h = zq_screen_h;
		
		if(tooltip_box.x+tooltip_box.w>=zq_screen_w)
		{
			tooltip_box.x=(zq_screen_w - tooltip_box.w);
		}
		
		if(tooltip_box.y+tooltip_box.h>=zq_screen_h)
		{
			tooltip_box.y=(zq_screen_h - tooltip_box.h);
		}
		
		rectfill(tooltipbmp, 1, 1, tooltip_box.w-3, tooltip_box.h-3, jwin_pal[jcTEXTBG]);
		rect(tooltipbmp, 0, 0, tooltip_box.w-2, tooltip_box.h-2, jwin_pal[jcTEXTFG]);
		vline(tooltipbmp, tooltip_box.w-1, 0,           tooltip_box.h-1, jwin_pal[jcTEXTFG]);
		hline(tooltipbmp,           1, tooltip_box.h-1, tooltip_box.w-2, jwin_pal[jcTEXTFG]);
		tooltipbmp->line[tooltip_box.h-1][0]=0;
		tooltipbmp->line[0][tooltip_box.w-1]=0;
		
		//char *kill=(char *)calloc(strlen(tipmsg)*2,1);
		char *tmpstr=tipmsg;
		char temp = 0;
		//sprintf(tmpstr, "%s", tipmsg);
		int32_t t=0;
		int32_t new_t=-1;
		int32_t i=0;
		
		while(tmpstr[t])
		{
			t=strchrnum(tmpstr, '\n');
			
			if(t==-1)
			{
				t=(int32_t)strlen(tmpstr);
			}
			
			if((uint32_t)t!=strlen(tmpstr))
			{
				new_t=t+1;
			}
			else
			{
				new_t=-1;
			}
			
			temp = tmpstr[t];
			tmpstr[t]=0;
			textprintf_ex(tooltipbmp, font, 4, (i*text_height(font))+4, jwin_pal[jcTEXTFG], -1, "%s", tmpstr);
			tmpstr[t]=temp;
			++i;
			
			if(new_t!=-1)
			{
				tmpstr+=new_t;
				t=0;
			}
		}
		
		//free(kill);
	}
	font = oldfont;
	return;
}

void clear_tooltip()
{
	update_tooltip(-1, -1, -1, -1, 0, 0, NULL);
}

void ZQ_ClearQuestPath()
{
	zc_set_config("zquest","win_last_quest",(char const*)nullptr);
	strcpy(filepath,"");
}

void __zc_always_assert(bool e, const char* expression, const char* file, int32_t line)
{
    //for best results set a breakpoint in here.
    if(!e)
    {
        char buf[1024];
        sprintf(buf, "ASSERTION FAILED! : %s, %s line %i\n", expression, file, line);
        
        al_trace("%s", buf);
        set_gfx_mode(GFX_TEXT, 0, 0, 0, 0);
        allegro_message("%s", buf);
        //...
    }
}

//FFCore

int32_t FFScript::GetScriptObjectUID(int32_t type)
{
	++script_UIDs[type];
	return script_UIDs[type];
}

void FFScript::init()
{
	for ( int32_t q = 0; q < wexLast; q++ ) warpex[q] = 0;
	print_ZASM = 0;
	numscriptdraws = 0;
	max_ff_rules = qr_MAX;
	temp_no_stepforward = 0;
	nostepforward = 0;
	
	coreflags = 0;
	skip_ending_credits = 0;
	for ( int32_t q = 0; q < susptLAST; q++ ) { system_suspend[q] = 0; }
	
	for ( int32_t q = 0; q < UID_TYPES; ++q ) { script_UIDs[q] = 0; }
	//for ( int32_t q = 0; q < 512; q++ ) FF_rules[q] = 0;
	int32_t usr_midi_volume = usr_digi_volume = usr_sfx_volume = usr_music_volume = usr_panstyle = 0;
	FF_hero_action = 0;
	enemy_removal_point[spriteremovalY1] = -32767;
	enemy_removal_point[spriteremovalY2] = 32767;
	enemy_removal_point[spriteremovalX1] = -32767;
	enemy_removal_point[spriteremovalX2] = 32767;
	enemy_removal_point[spriteremovalZ1] = -32767;
	enemy_removal_point[spriteremovalZ2] = 32767;
	
	//Clear internal arrays for use by <std>, <ghost>, <tango>
	for ( int32_t q = 0; q < 256; ++q )
	{
		StdArray[q] = 0;
		GhostArray[q] = 0;
		TangoArray[q] = 0;
	}
	
	for ( int32_t q = 0; q < 4; q++ ) 
	{
		FF_screenbounds[q] = 0;
		FF_screen_dimensions[q] = 0;
		FF_subscreen_dimensions[q] = 0;
		FF_eweapon_removal_bounds[q] = 0; 
		FF_lweapon_removal_bounds[q] = 0;
	}
	for ( int32_t q = 0; q < FFSCRIPTCLASS_CLOCKS; q++ )
	{
		FF_clocks[q] = 0;
	}
	for ( int32_t q = 0; q < SCRIPT_DRAWING_RULES; q++ )
	{
		ScriptDrawingRules[q] = 0;
	}
	for ( int32_t q = 0; q < NUM_USER_MIDI_OVERRIDES; q++ ) 
	{
		FF_UserMidis[q] = 0;
	}
	subscreen_scroll_speed = 0; //make a define for a default and read quest override! -Z
	kb_typing_mode = false;
	FFCore.user_bitmaps_init();
	initIncludePaths();
	initRunString();
	for(int32_t q = 0; q < 7; ++q)
	{
		tempScreens[q] = NULL;
		ScrollingScreens[q] = NULL;
	}
}

void FFScript::updateIncludePaths()
{
	includePaths.clear();
	int32_t pos = 0; int32_t pathnumber = 0;
	for ( int32_t q = 0; includePathString[pos]; ++q )
	{
		int32_t dest = 0;
		char buf[2048] = {0};
		while(includePathString[pos] != ';' && includePathString[pos])
		{
			buf[dest] = includePathString[pos];
			++pos;
			++dest;
		}
		++pos;
		string str(buf);
		includePaths.push_back(str);
	}
}

void FFScript::initRunString()
{
	memset(scriptRunString,0,sizeof(scriptRunString));
	strcpy(scriptRunString,zc_get_config("Compiler","run_string","run",App::zscript));
}

void FFScript::initIncludePaths()
{
	memset(includePathString,0,sizeof(includePathString));
	FILE* f = fopen("includepaths.txt", "r");
	if(f)
	{
		int32_t pos = 0;
		int32_t c;
		do
		{
			c = fgetc(f);
			if(c!=EOF) 
				includePathString[pos++] = c;
		}
		while(c!=EOF && pos<MAX_INCLUDE_PATH_CHARS);
		if(pos<MAX_INCLUDE_PATH_CHARS)
			includePathString[pos] = '\0';
		includePathString[MAX_INCLUDE_PATH_CHARS-1] = '\0';
		fclose(f);
	}
	else strcpy(includePathString, "include/;headers/;scripts/;");
	al_trace("Full path string is: ");
	safe_al_trace(includePathString);
	al_trace("\n");
	updateIncludePaths();

	for ( size_t q = 0; q < includePaths.size(); ++q )
	{
		al_trace("Include path %zu: ",q);
		safe_al_trace(includePaths.at(q).c_str());
		al_trace("\n");
	}
}

int32_t FFScript::getQRBit(int32_t rule)
{
	return ( get_bit(quest_rules,rule) ? 1 : 0 );
}

int32_t FFScript::getTime(int32_t type)
{
	//struct tm *tm_struct = localtime(time(NULL));
	struct tm * tm_struct;
	time_t rawtime;
	time (&rawtime);
	tm_struct = localtime (&rawtime);
	
	switch(type)
	{
		case curyear:
		{
			int32_t year = tm_struct->tm_year + 1900;        /* year */
			//year format starts at 1900, so we add it to the return
			//al_trace("The current year is: %d\n",year);
			return year;
			
		}
		case curmonth:
		{
			int32_t month = tm_struct->tm_mon +1;         /* month */
			//Months start at 0, but we want 1->12
			//al_trace("The current month is: %d\n",month);
			return month;
		}
		case curday_month:
		{
			int32_t day_month = tm_struct->tm_mday;        /* day of the month */
			//al_trace("The current day of the month is: %d\n",day_month);
			return day_month;
		}
		case curday_week: 
		{
			int32_t day_week = tm_struct->tm_wday;        /* day of the week */
			//al_trace("The current day of the week is: %d\n",day_week);
			return day_week;
		}
		case curhour:
		{
			int32_t hour = tm_struct->tm_hour;        /* hours */
			//al_trace("The current hour is: %d\n",hour);
			return hour;
		}
		case curminute: 
		{
			int32_t minutes = tm_struct->tm_min;         /* minutes */
			//al_trace("The current hour is: %d\n",minutes);
			return minutes;
		}
		case cursecond:
		{
			int32_t secs = tm_struct->tm_sec;         /* seconds */
			//al_trace("The current second is: %d\n",secs);
			return secs;
		}
		case curdayyear:
		{
			int32_t day_year = tm_struct->tm_yday;        /* day in the year */
			//al_trace("The current day out of the year is: %d\n",day_year);
			return day_year;
		}
		case curDST:
		{
			int32_t isDST = tm_struct->tm_isdst;       /* daylight saving time */
			//al_trace("The current DSTis: %d\n",isDST);
			return isDST;
		}
		default: return -1;
		
	}
}

extern const char *itemclass_help_string_defaults[itype_max];
//ZModule Functions



/* end */

int32_t FFScript::getQuestHeaderInfo(int32_t type)
{
    return quest_format[type];
}


script_bitmaps scb;

//script_bitmaps scb;
void FFScript::user_bitmaps_init()
{
	scb.clear();
}

void FFScript::user_files_init(){}
void FFScript::user_dirs_init(){}
void FFScript::user_objects_init(){}
void FFScript::user_stacks_init(){}

void FFScript::deallocateAllArrays(const byte scriptType, const int32_t UID, bool requireAlways){}

void FFScript::deallocateAllArrays(){}

bool isSideViewGravity(int32_t t)
{
    return (Map.CurrScr()->flags7&fSIDEVIEW) != 0;
}




void FFScript::ZScriptConsole(bool open)
{


	#ifdef _WIN32
	if ( console_is_open )
	{
		zscript_coloured_console.Create("ZQuest Creator Logging Console", 600, 200);
		zscript_coloured_console.cls(CConsoleLoggerEx::COLOR_BACKGROUND_BLACK);
		zscript_coloured_console.gotoxy(0,0);
		zscript_coloured_console.cprintf( CConsoleLoggerEx::COLOR_BLUE | CConsoleLoggerEx::COLOR_INTENSITY |
		CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"ZQuest Creator Logging Console\n");
	}
	else
	{
		//close
		zscript_coloured_console.Close();
	}
	#endif	
}

template <typename ...Params>
void FFScript::ZScriptConsole(int32_t attributes,const char *format, Params&&... params)
{
	#ifdef _WIN32
	initConsole();
	zscript_coloured_console.cprintf( attributes, format, std::forward<Params>(params)... );
	#endif	
}

void FFScript::ZASMPrint(bool open)
{
	#ifdef _WIN32
	if ( open )
	{
		coloured_console.Create("ZASM Debugger", 600, 200);
		coloured_console.cls(CConsoleLoggerEx::COLOR_BACKGROUND_BLACK);
		coloured_console.gotoxy(0,0);
		coloured_console.cprintf( CConsoleLoggerEx::COLOR_GREEN | CConsoleLoggerEx::COLOR_INTENSITY |
		CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"ZASM Stack Trace:\n");
		//coloured_console.SetAsDefaultOutput();
		
	}
	else
	{
		//close
		coloured_console.Close();
	
	}
	#endif	
}


void FFScript::ZASMPrintCommand(const word scommand)
{
	//overloaded from class
	return;
}

void FFScript::ZASMPrintVarSet(const int32_t arg, int32_t argval)
{
	//overloaded from class
	return;
}

void FFScript::ZASMPrintVarGet(const int32_t arg, int32_t argval)
{
	//overloaded from class
	return;
}

int32_t getpitfall(int32_t x, int32_t y){return 0;}

int32_t iswaterexzq(int32_t combo, int32_t map, int32_t screen, int32_t layer, int32_t x, int32_t y, bool secrets, bool fullcheck, bool LayerCheck){return 0;}

int32_t MAPCOMBOzq(int32_t x, int32_t y){return 0;}

void doDarkroomCircle(int32_t cx, int32_t cy, byte glowRad,BITMAP* dest,BITMAP* transdest)
{
	if(!glowRad) return;
	//
	int32_t ditherRad = glowRad + (int32_t)(glowRad * (zinit.dither_percent/(double)100.0));
	int32_t transRad = glowRad + (int32_t)(glowRad * (zinit.transdark_percent/(double)100.0));
	
	if(dest)
	{
		dithercircfill(dest, cx, cy, ditherRad, 0, zinit.dither_type, zinit.dither_arg);
		circlefill(dest, cx, cy, zc_max(glowRad,transRad), 0);
	}
	if(transdest)
	{
		dithercircfill(transdest, cx, cy, ditherRad, 0, zinit.dither_type, zinit.dither_arg);
		circlefill(transdest, cx, cy, glowRad, 0);
	}
}
void doDarkroomCone(int32_t sx, int32_t sy, byte glowRad, int32_t dir, BITMAP* dest,BITMAP* transdest){}

bool update_hw_pal = false;
void update_hw_screen(bool force)
{
	if(force || myvsync)
	{
		zc_process_display_events();
		if(update_hw_pal)
		{
			set_palette(RAMpal);
			update_hw_pal=false;
		}
		if (myvsync)
			render_zq();
		myvsync=0;
	}
}

bool checkCost(int32_t ctr, int32_t amnt)
{
	if(!game) return true;
	if(amnt <= 0) return true;
	switch (ctr)
	{
		case crMONEY: //rupees
		{
			if ( current_item_power(itype_wallet) ) return true;
			break;
		}
		case crMAGIC: //magic
		{
			if (get_bit(quest_rules,qr_ENABLEMAGIC))
			{
				return (((current_item_power(itype_magicring) > 0)
					 ? game->get_maxmagic()
					 : game->get_magic()+game->get_dmagic())>=amnt*game->get_magicdrainrate());
			}
			return true;
		}
		case crARROWS:
		{
			if(current_item_power(itype_quiver))
				return true;
			if(!get_bit(quest_rules,qr_TRUEARROWS))
				return checkCost(crMONEY, amnt);
			break;
		}
		case crBOMBS:
		{
			if(current_item_power(itype_bombbag))
				return true;
			break;
		}
		case crSBOMBS:
		{
			if(current_item_power(itype_bombbag)
				&& itemsbuf[current_item_id(itype_bombbag)].flags & ITEM_FLAG1)
				return true;
			break;
		}
	}
	return (game->get_counter(ctr)+game->get_dcounter(ctr)>=amnt);
}
bool checkmagiccost(int32_t itemid)
{
	if(itemid < 0)
	{
		return false;
	}
	itemdata const& id = itemsbuf[itemid];
	return checkCost(id.cost_counter[0], id.cost_amount[0])
		&& checkCost(id.cost_counter[1], id.cost_amount[1]);
}

void payCost(int32_t ctr, int32_t amnt, int32_t tmr, bool ignoreTimer)
{
	return;
}
void paymagiccost(int32_t itemid, bool ignoreTimer)
{
	return;
}

void enter_sys_pal(){}
void exit_sys_pal(){}

void replay_step_comment(std::string comment) {}
bool replay_is_active() {return false;}
bool replay_is_replaying() {return false;}
int replay_get_version() {return 0;}
bool replay_is_debug() {return false;}

#ifdef __EMSCRIPTEN__
extern "C" void open_test_mode()
{
	int dmap = -1;
	int32_t pal = Map.getcolor();
	for(auto q = 0; q < MAXDMAPS; ++q)
	{
		if(DMaps[q].map == Map.getCurrMap())
		{
			if(pal == DMaps[q].color)
			{
				dmap = q;
				break;
			}
			if(dmap < 0)
				dmap = q;
		}
	}
	if(dmap < 0) dmap = 0;

	em_open_test_mode(filepath, dmap, Map.getCurrScr(), -1);
}

extern "C" void get_shareable_url()
{
	EM_ASM({
        ZC.setShareableUrl({quest: UTF8ToString($0), map: $1, screen: $2});
	}, filepath, Map.getCurrMap(), Map.getCurrScr());
}
#endif
